[
  {
    "language": "Scala",
    "code": "import scala.io.Source.stdin\nimport scala.collection.mutable.Queue\nimport scala.collection.mutable.{ Set => mSet }\n\nobject Main {\n  val rgb = \"rgb\".toCharArray\n\n  def main(argv: Array[String]): Unit = {\n    stdin.getLines.foreach { l =>\n      if (l == \"0\") return\n      val q = new Queue[(String, Int)]()\n      q.enqueue((l, 0))\n      val rgbSet = mSet(Array.fill(l.length)(\"r\").mkString,\n        Array.fill(l.length)(\"g\").mkString,\n        Array.fill(l.length)(\"b\").mkString)\n\n      val done = mSet[String]()\n\n      var continue = true\n\n      if (rgbSet.contains(l)) {\n        println(0)\n        continue = false\n      }\n      while (continue && q.length > 0) {\n        val (buf, time) = q.dequeue\n        val pairs = (buf.drop(1) zip buf.take(buf.length-1)).map{ case (a, b) => Array(a, b) }.zipWithIndex\n\n        pairs.foreach { case (arr, i) =>\n          if (arr(0) != arr(1)) {\n            val res = buf.take(i) + convert(arr).mkString + buf.drop(i + 2)\n            // 終了判定\n            if (rgbSet.contains(res)) {\n              println(time+1)\n              continue = false\n            }\n            if (!done.contains(res)) {\n              q.enqueue(res -> (time+1))\n              done += res\n            }\n          }\n        }\n\n        if (continue && q.length == 0) {\n          println(\"NA\")\n        }\n      }\n    }\n  }\n\n  def convert(st: Array[Char]): Array[Char] = {\n    val c = rgb.filterNot(c => st.contains(c))(0)\n    Array(c, c)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.Source.stdin\nimport scala.collection.mutable.Queue\nimport scala.collection.mutable.{ Set => mSet }\n\nobject Main {\n  val rgb = \"rgb\".toCharArray\n\n  def main(argv: Array[String]): Unit = {\n    stdin.getLines.foreach { l =>\n      if (l == \"0\") return\n      val q = new Queue[(String, Int)]()\n      q.enqueue((l, 0))\n      val rgbSet = mSet(Array.fill(l.length)(\"r\").mkString,\n        Array.fill(l.length)(\"g\").mkString,\n        Array.fill(l.length)(\"b\").mkString)\n\n      val done = mSet[String]()\n\n      var continue = true\n\n      if (rgbSet.contains(l)) {\n        println(0)\n        continue = false\n      }\n      while (continue && q.length > 0) {\n        val (buf, time) = q.dequeue\n        val pairs = (buf.drop(1) zip buf.take(buf.length-1)).map{ case (a, b) => Array(a, b) }.zipWithIndex\n\n        pairs.foreach { case (arr, i) =>\n          if (arr(0) != arr(1)) {\n            val res = buf.take(i) + convert(arr).mkString + buf.drop(i + 2)\n            // 終了判定\n            if (rgbSet.contains(res)) {\n              println(time+1)\n              continue = false\n            }\n            if (!done.contains(res)) {\n              q.enqueue(res -> (time+1))\n              done += res\n            }\n          }\n        }\n\n        if (continue && q.length == 0) {\n          println(\"NA\")\n        }\n      }\n    }\n  }\n\n  def convert(st: Array[Char]): Array[Char] = {\n    val c = rgb.filterNot(c => st.contains(c))(0)\n    Array(c, c)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nobject Main extends App {\n\n  import scala.io.StdIn._\n\n  solve\n  def solve: Unit = {\n    val state = readLine.trim\n    if (state == \"0\") return\n    val color = state.map{\n      case 'r' ⇒ 0\n      case 'b' ⇒ 1\n      case 'g' ⇒ 2\n    }\n    val minStep = Array.tabulate(exponent(3, state.length)){_ ⇒ -1}\n    minStep(color.foldLeft(0){(a, b) ⇒ a * 3 + b}) = 0\n    val queue = mutable.Queue[IndexedSeq[Int]]().also{q ⇒ q.enqueue(color)}\n    while(queue.nonEmpty){\n      val top = queue.dequeue()\n      val topI = top.foldLeft(0){(a, b) ⇒ a * 3 + b}\n      for (i ← state.indices.tail if top(i) != top(i - 1)) {\n        val next = top.updated(i - 1, (top(i) + top(i - 1)) * 2 % 3).updated(i, (top(i) + top(i - 1)) * 2 % 3)\n        val index = next.foldLeft(0){(a, b) ⇒ a * 3 + b}\n        if (minStep(index) == -1){\n          minStep(index) = minStep(topI) + 1\n          queue.enqueue(next)\n        }\n      }\n    }\n    val green = minStep(exponent(3, state.length) - 1)\n    val blue = minStep((exponent(3, state.length) - 1) / 2)\n    val red = minStep(0)\n    List(green, blue, red).filterNot(_ == -1) match {\n      case Nil ⇒ println(\"NA\")\n      case l ⇒ println(l.min)\n    }\n    solve\n  }\n  def exponent(base: Int, exp: Int): Int = {\n    exp match {\n      case 0 ⇒ 1\n      case 1 ⇒ base\n      case _ ⇒ exponent(base, exp / 2).let{i ⇒ i * i * exponent(base, exp % 2)}\n    }\n  }\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.Source.stdin\nimport scala.collection.mutable.Queue\nimport scala.collection.mutable.{ Set => mSet }\n\nobject Main {\n  val rgb = \"rgb\".toCharArray\n\n  def main(argv: Array[String]): Unit = {\n    stdin.getLines.foreach { l =>\n      if (l == \"0\") sys.exit()\n\n      val q = new Queue[(String, Int)]()\n      q.enqueue((l, 0))\n      val rgbSet = mSet(Array.fill(l.length)(\"r\").mkString,\n        Array.fill(l.length)(\"g\").mkString,\n        Array.fill(l.length)(\"b\").mkString)\n\n      val done = mSet[String]()\n\n      var continue = true\n\n      if (rgbSet.contains(l)) {\n        println(0)\n        continue = false\n      }\n      while (continue && q.length > 0) {\n        val (buf, time) = q.dequeue\n        val pairs = (buf.drop(1) zip buf.take(buf.length-1)).map{ case (a, b) => Array(a, b) }.zipWithIndex\n\n        pairs.foreach { case (arr, i) =>\n          if (arr(0) != arr(1)) {\n            val res = buf.take(i) + convert(arr).mkString + buf.drop(i + 2)\n            // 終了判定\n            if (rgbSet.contains(res) && continue) {\n              println(time+1)\n              continue = false\n            }\n            if (!done.contains(res)) {\n              q.enqueue(res -> (time+1))\n              done += res\n            }\n          }\n        }\n\n        if (continue && q.length == 0) {\n          println(\"NA\")\n        }\n      }\n    }\n  }\n\n  def convert(st: Array[Char]): Array[Char] = {\n    val c = rgb.filterNot(c => st.contains(c))(0)\n    Array(c, c)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.Source.stdin\nimport scala.collection.mutable.Queue\nimport scala.collection.mutable.{ Set => mSet }\n\nobject Main {\n  val rgb = \"rgb\".toCharArray\n\n  def main(argv: Array[String]): Unit = {\n    stdin.getLines.foreach { l =>\n      if (l == \"0\") sys.exit()\n      val q = new Queue[(String, Int)]()\n      q.enqueue((l, 0))\n      val rgbSet = mSet(Array.fill(l.length)(\"r\").mkString,\n        Array.fill(l.length)(\"g\").mkString,\n        Array.fill(l.length)(\"b\").mkString)\n\n      val done = mSet[String]()\n\n      var continue = true\n\n      if (rgbSet.contains(l)) {\n        println(0)\n        continue = false\n      }\n      while (continue && q.length > 0) {\n        val (buf, time) = q.dequeue\n        val pairs = (buf.drop(1) zip buf.take(buf.length-1)).map{ case (a, b) => Array(a, b) }.zipWithIndex\n\n        pairs.foreach { case (arr, i) =>\n          if (arr(0) != arr(1)) {\n            val res = buf.take(i) + convert(arr).mkString + buf.drop(i + 2)\n            // 終了判定\n            if (rgbSet.contains(res)) {\n              println(time+1)\n              continue = false\n            }\n            if (!done.contains(res)) {\n              q.enqueue(res -> (time+1))\n              done += res\n            }\n          }\n        }\n\n        if (continue && q.length == 0) {\n          println(\"NA\")\n        }\n      }\n    }\n  }\n\n  def convert(st: Array[Char]): Array[Char] = {\n    val c = rgb.filterNot(c => st.contains(c))(0)\n    Array(c, c)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.Source.stdin\nimport scala.collection.mutable.Queue\nimport scala.collection.mutable.{ Set => mSet }\n\nobject Main {\n  val rgb = \"rgb\".toCharArray\n\n  def main(argv: Array[String]): Unit = {\n    stdin.getLines.foreach { l =>\n      if (l == \"0\") sys.exit()\n\n      val q = new Queue[(String, Int)]()\n      q.enqueue((l, 0))\n      val rgbSet = mSet(Array.fill(l.length)(\"r\").mkString,\n        Array.fill(l.length)(\"g\").mkString,\n        Array.fill(l.length)(\"b\").mkString)\n\n      val done = mSet[String]()\n\n      var continue = true\n\n      if (rgbSet.contains(l)) {\n        println(0)\n        continue = false\n      }\n      while (continue && q.length > 0) {\n        val (buf, time) = q.dequeue\n        val pairs = (buf.drop(1) zip buf.take(buf.length-1)).map{ case (a, b) => Array(a, b) }.zipWithIndex\n\n        pairs.foreach { case (arr, i) =>\n          if (arr(0) != arr(1)) {\n            val res = buf.take(i) + convert(arr).mkString + buf.drop(i + 2)\n            // 終了判定\n            if (rgbSet.contains(res)) {\n              println(time+1)\n              continue = false\n            }\n            if (!done.contains(res)) {\n              q.enqueue(res -> (time+1))\n              done += res\n            }\n          }\n        }\n\n        if (continue && q.length == 0) {\n          println(\"NA\")\n        }\n      }\n    }\n  }\n\n  def convert(st: Array[Char]): Array[Char] = {\n    val c = rgb.filterNot(c => st.contains(c))(0)\n    Array(c, c)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.Source.stdin\nimport scala.collection.mutable.Queue\nimport scala.collection.mutable.{ Set => mSet }\n\nobject Main {\n  val rgb = \"rgb\".toCharArray\n\n  def main(argv: Array[String]): Unit = {\n    stdin.getLines.foreach { l =>\n      if (l == \"0\") sys.exit()\n\n      val q = new Queue[(String, Int)]()\n      q.enqueue((l, 0))\n      val rgbSet = mSet(Array.fill(l.length)(\"r\").mkString,\n        Array.fill(l.length)(\"g\").mkString,\n        Array.fill(l.length)(\"b\").mkString)\n\n      val done = mSet[String]()\n      var continue = true\n\n      while (continue && q.length > 0) {\n        val (buf, time) = q.dequeue\n        // 終了判定\n        if (rgbSet.contains(buf) && continue) {\n          println(time)\n          continue = false\n        }\n\n        val pairs = (buf.drop(1) zip buf.take(buf.length-1)).map{ case (a, b) => Array(a, b) }.zipWithIndex\n        pairs.foreach { case (arr, i) =>\n          if (arr(0) != arr(1)) {\n            val res = buf.take(i) + convert(arr).mkString + buf.drop(i + 2)\n            if (!done.contains(res)) {\n              q.enqueue(res -> (time+1))\n              done += res\n            }\n          }\n        }\n\n        if (continue && q.length == 0) {\n          println(\"NA\")\n        }\n      }\n    }\n  }\n\n  def convert(st: Array[Char]): Array[Char] = {\n    val c = rgb.filterNot(c => st.contains(c))(0)\n    Array(c, c)\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nusing namespace std;\n\n\nclass Q{\n\tpublic:\n\tstring str;\n\tint dep;\n\t//Q(string a,int n){str=a;dep=n;}\n\tQ(string str, int dep) : str(str), dep(dep) {}\n};\n\nint saiki(string imo){\n\t\n\tqueue<Q> que;\n\t\n\tque.push(Q(imo,0));\n\t\n\tmap<string,int> visit;\n\t\n\twhile(1){\n\t\t\n\t\tif(que.empty()==1){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tQ u = que.front();\n\t\tque.pop();\n\t\t\n\t\tstring s = u.str;\n\t\t\n\t\tif(visit[s]==1){\n\t\t\tcontinue;\n\t\t}\n\t\tvisit[s]=1;\n\t\t\n\t\t\n\t\t//printf(\"%d pop( %s )\\n\",u.dep,s.c_str());\n\t\tchar ch=s[0];\n\t\tint flg=1;\n\t\trep(i,s.size()-1){\n\t\t\tif(s[i+1]!=ch) {flg=0;break;}\n\t\t}\n\t\tif(flg==1){\n\t\t\treturn u.dep;\n\t\t}\n\t\t\n\t\trep(i,s.size()-1){\n\t\t\t\n\t\t\tif((s[i]=='r' && s[i+1]=='g')||(s[i+1]=='r' && s[i]=='g')){\n\t\t\t\tstring t=s;\n\t\t\t\tt[i]=t[i+1]='b';\n\t\t\t\tque.push(Q(t,u.dep+1));\n\t\t//printf(\"%d push( %s )\\n\",u.dep,t.c_str());\n\t\t\t}else\n\t\t\tif((s[i]=='b' && s[i+1]=='r')||(s[i+1]=='b' && s[i]=='r')){\n\t\t\t\tstring t=s;\n\t\t\t\tt[i]=t[i+1]='g';\n\t\t\t\tque.push(Q(t,u.dep+1));\n\t\t//printf(\"%d push( %s )\\n\",u.dep,t.c_str());\n\t\t\t}else\n\t\t\tif((s[i]=='g' && s[i+1]=='b')||(s[i+1]=='g' && s[i]=='b')){\n\t\t\t\tstring t=s;\n\t\t\t\tt[i]=t[i+1]='r';\n\t\t\t\tque.push(Q(t,u.dep+1));\n\t\t//printf(\"%d push( %s )\\n\",u.dep,t.c_str());\n\t\t\t}\n\t\t}\n\t}\n\treturn 100;\n\t\n}\n\nint main(){\n\twhile(1){\n\t\tstring a;\n\t\tcin>>a;\n\t\t\n\t\tif(a==\"0\"){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint ans=saiki(a);\n\t\t\n\t\tif(ans==-1){\n\t\t\tputs(\"NA\");\n\t\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n\tqueue<P> que;\n\tque.push(P(worm, 0));\n\n\tset<string> d;\n\t\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tif(d.count(p.first)) continue;\n\n\t\tstring str = p.first;\n\t\t\n\t\tbool flag = false;\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) return p.second;\n\t\td.insert(p.first);\n\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\n\t\t\t\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t\t\t\t\ttemp = 'b';\n\t\t\t\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t\t\t\t\ttemp = 'g';\n\t\t\t\t}else{\n\t\t\t\t\ttemp = 'r';\n\t\t\t\t}\n\n\t\t\t\tnext = str;\n\t\t\t\tnext[i] = next[i+1] = temp;\n\n\t\t\t\tque.push(P(next, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring worm;\n\twhile(cin >> worm && worm != \"0\"){\n\t\tint ret = bfs(worm);\n\t\tif(ret>=0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstring insect = \"brg\";\nstring str,str2;\nint cnt;\nqueue <string> Q;\n\n\nbool bfs( string str) {\n  int l = Q.size();\n  while ( !Q.empty() ) {\n    \n    str = Q.front();\n    Q.pop();\n    l--;\n    //cout << \"l\" << \" \" << l << endl;\n    int len = str.size();\n     \n    for ( int i = 0; i < len-1; i++ ) {\n      str2 = str;\n      for ( int j = 0; j < 3; j++ ) {\n\tif ( str2[i] != str2[i+1] \n\t     && str2[i] != insect[j] && str2[i+1] != insect[j] ) {\n\t  str2[i] = insect[j];\n\t  str2[i+1] = insect[j];\n\n\t  Q.push( str2 );\n\t  int flag = 0;\n\t  for ( int k = 0; k < len-1; k++ ) {\n\t    if ( str2[k] != str2[k+1] ) flag = 1;\n\t  }\n\t  // cout << \"i\" << \" \" << i << \" \" << \"j\" << \" \" << j << endl;\n\t  // cout << \"cnt\" << \" \" << cnt << endl;\n\t  // cout << \"str2\" << \" \" << str2 << endl;\n\t  // cout << endl;\n\t  \n\t  if ( flag == 0 ) return 1;\n\t}\n      }\n    }\n    if ( l == 0 ) return 0;\n  }\n  return 0;\n}\n\nint main() {\n\n  while (1) {\n\n    cin >> str;\n    int length = str.size();\n    int f = 0;\n    for ( int i = 0; i < length-1; i++ ) {\n      if ( str[i] != str[i+1] ) f = 1;\n    }\n\n    if ( str == \"0\" ) break;\n    while( !Q.empty() ) Q.pop();\n    cnt = 0;\n    Q.push( str );\n    while (1) {\n    if ( f == 0 ){\n      cout << 0 << endl;\n      break;\n    }\n      cnt++;\n      if ( cnt == 10 ){\n\tcout << \"NA\" << endl;\n\tbreak;\n      }\n      if ( bfs( str ) ) {\n\tcout <<  cnt << endl;\n\tbreak;\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nmain(){\n  string in;                    //¶ñÌúóÔ(ªÆÈé)\n  while(cin>>in){\n    if(in[0]=='0')break;        //I¹ð\n\n    //gpÏÌú»\n    int ans=-1;                 //answer(ðÉHèÂ¯È¢ê-1ÌÜÜ)\n    set<string> vis;            //Tõµ½m[h\n    queue<pair<string,int> > q; //ÉTõ·é¶ñðüêéB\n\n    q.push(make_pair(in,0));    //ªðL[ÉüêéBÅZèÍà¿ëñ0\n    vis.insert(in);             //¶ñssÍTõµ½B\n\n    \n    //TõÌæªcÁÄ¨èAðÉ½Çè¢ÄÈ¢ÀèTõ\n    while(!q.empty()){\n      //Tõm[hÌ¶ñÆA[³ðæèo·B\n      string str=q.front().first;\n      int depth=q.front().second;\n      q.pop();\n      \n      //¶ñªê¶ÌÝ©ç\\¬³êÄ¢é©ð»èB\n      //ê¶ÌÝ©çÈÁÄ¢½êA¦ª©Â©Á½±ÆÉÈéÌÅTõðÅ¿ØéB\n      int r=0,g=0,b=0;\n      for(int i=0;i<str.size();i++){\n        switch(str[i]){\n        case 'r':++r;break;\n        case 'g':++g;break;\n        case 'b':++b;break;\n        }\n      }\n      if(r==str.size() || g==str.size() || b==str.size()){\n        ans=depth;\n        break;\n      }\n\n      //ÙÈéñgÌ¶ðTµoµA»êðL[ÉlßéB\n      for(int i=0;i<str.size()-1;i++){\n        if(str[i]!=str[i+1]){\n          string next(str);      //ðÁ¦é¶ñ(ÈºÌ3ÂÌif¶ÅKp)\n          \n          if( (str[i]=='b' && str[i+1]=='g') ||\n              (str[i]=='g' && str[i+1]=='b')){\n            next[i]='r';\n            next[i+1]='r';\n          }\n\n          if( (str[i]=='r' && str[i+1]=='g') ||\n              (str[i]=='g' && str[i+1]=='r')){\n            next[i]='b';\n            next[i+1]='b';\n          }\n          \n          if( (str[i]=='b' && str[i+1]=='r') ||\n              (str[i]=='r' && str[i+1]=='b')){\n            next[i]='g';\n            next[i+1]='g';\n          }\n\n          //·ÅÉTõµÄ¢½¶ñ¾Á½êXLbv\n          if(vis.count(next)==1)continue;\n\n          //Tõ\\èÌm[hÆµÄL[ÉüêéB\n          q.push(make_pair(next,depth+1));\n          vis.insert(next);\n        }\n      }\n    }\n    \n    if(ans==-1)cout<<\"NA\"<<endl;    //SÄðTõµÄàðª©Â©çÈ©Á½ê\n    else cout<<ans<<endl;           //ðª©Â©Á½êÅZðoÍ\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct Data{\n    string s;\n    int t;\n    Data(string _s,int _t){\n        s =_s,t =_t;\n    }\n};\nint main(){\n    string str;\n    while(cin>>str,str!=\"0\"){\n        queue<Data> Q;\n        map<string,bool> M;\n        Q.push(Data(str,0));\n        while(!Q.empty()){\n            Data E = Q.front();\n            //cout<<E.s<<endl;\n            Q.pop();\n            if(M[E.s])continue;\n            M[E.s] = true;\n            bool flg = true;\n            for(int i = 1;i < E.s.length();i++){\n                if(E.s[i] != E.s[0])flg = false;\n            }\n            if(flg){\n                cout<<E.t<<endl;\n                goto e;\n            }\n            for(int i = 0;i < E.s.length()-1;i++){\n                Data D = E;\n                if(D.s[i]!=D.s[i+1]){\n                    bool flg[3]={};\n                    string w = \"rgb\";\n                    if(D.s[i]=='r'||D.s[i+1]=='r')flg[0] = true;\n                    if(D.s[i]=='g'||D.s[i+1]=='g')flg[1] = true;\n                    if(D.s[i]=='b'||D.s[i+1]=='b')flg[2] = true;\n                    for(int j = 0;j < 3;j++){\n                        if(!flg[j])D.s[i] = D.s[i+1] = w[j];\n                    }\n                    D.t++;\n                    //cout<<D.s<<endl;\n                    Q.push(D);\n                }\n            }\n        }\n        cout<<\"NA\"<<endl;\n        e:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct W\n{\n\tstring s;\n\tint num;\n\t\n\tW(string s = \"\",int num = 0) : s(s),num(num) {}\n};\n\nchar change(char a,char b)\n{\n\tif((a == 'r' && b == 'g') || (a == 'g' && b == 'r'))\n\t{\n\t\treturn 'b';\t\n\t}\n\telse if((a == 'r' && b == 'b') || (a == 'b' && b == 'r'))\n\t{\n\t\treturn 'g';\n\t}\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g'))\n\t{\n\t\treturn 'r';\n\t}\n\treturn 'N';\n}\n\nint main()\n{\n\tstring s;\n\twhile(cin >> s)\n\t{\n\t\tif(s == \"0\") break;\n\t\t\n\t\tstring t = \"\",t2 = \"\",t3 = \"\";\n\t\trep(i,s.size())\n\t\t{\n\t\t\tt += \"r\";\n\t\t\tt2 += \"g\";\n\t\t\tt3 += \"b\";\n\t\t}\n\n\t\tqueue<W> que;\n\t\tque.push(W(s,0));\n\t\tmap<string,int> m;\n\t\tint ans = 0;\n\t\tbool flag = true;\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tW w = que.front();\n\t\t\tque.pop();\n\n\t\t\tif(m[w.s] > 0) \n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(w.s == t || w.s == t2 || w.s == t3)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tans = w.num;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm[w.s] = w.num;\n\n\t\t\trep(i,s.size()-1)\n\t\t\t{\n\t\t\t\tstring temp = w.s;\n\t\t\t\tif(change(w.s[i],w.s[i+1]) == 'N') continue;\n\t\t\t\t\n\t\t\t\ttemp[i] = temp[i+1] = change(w.s[i],w.s[i+1]);\n\t\t\t\tque.push(W(temp,w.num+1));\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tstring s;\n\tchar a[] = {'r','g','b'};\n\tset<string> u;\n\tqueue< pair<string,int> > q;\n\tcin >> s;\n\tif(s == \"0\") break;\n\tu.insert(s);\n\tq.push( pair<string,int>(s,0));\n\tint ans = 0;\n\twhile(!q.empty()){\n\t    s = q.front().first;\n\t    int v = q.front().second;\n\t    q.pop();\n\t    REP(i,s.size()-1){\n\t\tif(s[i] != s[i+1]){\n\t\t    string s1 = s;\n\t\t    char key;\n\t\t    REP(j,3){\n\t\t\tif(s[i] != a[j] && s[i+1] != a[j]){\n\t\t\t    key = a[j];\n\t\t\t}\n\t\t    }\n\t\t    s1[i] = key;\n\t\t    s1[i+1] = key;\n\t\t    if(u.find(s1) == u.end()){\n\t\t\tu.insert(s1);\n\t\t\tq.push(pair<string,int>(s1,v+1));\n\t\t    }\n\t\t}\n\t    }\n\t    bool flg = true;\n\t    REP(i,s.size()-1){\n\t\tif(s[i] != s[i+1] ) flg = false;\n\t    }\n\t    if(flg){\n\t\tcout << v << endl;\n\t\tbreak;\n\t    }else if(q.empty()){\n\t\tcout << \"NA\" << endl;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tstring s;\n\twhile (cin >> s)\n\t{\n\t\tif (s == \"0\") break;\n\t\tqueue<string> que;\n\t\tque.push(s);\n\t\tmap<string,int> t;\n\t\tt[s] = 0;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tstring tmp = que.front();\n\t\t\tque.pop();\n\t\t\tbool f = true;\n\t\t\tREP(i, tmp.size())\n\t\t\t{\n\t\t\t\tif (tmp[i] != tmp[0]) f = false;\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tcout << t[tmp] << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tREP(i, tmp.size() - 1)\n\t\t\t{\n\t\t\t\tif (tmp[i] != tmp[i + 1])\n\t\t\t\t{\n\t\t\t\t\tchar a = 'r' + 'g' + 'b' - tmp[i] - tmp[i + 1];\n\t\t\t\t\tstring tmps = tmp;\n\t\t\t\t\ttmps[i] = tmps[i + 1] = a;\n\t\t\t\t\tif (t.find(tmps) == t.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tt[tmps] = t[tmp] + 1;\n\t\t\t\t\t\tque.push(tmps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\tend:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nmap<char, char> rot = {\n    {'r', 'g'}, {'g', 'b'}, {'b', 'r'}\n};\nmap<string, bool> used;\n\nvoid rotate(string &s) {\n    for (int i=0; i<(int)s.size(); ++i) s[i] = rot[s[i]];\n}\n\nint main() {\n    string s;\n    while (cin >> s, s != \"0\") {\n        used.clear();\n        string r = \"\", g = \"\", b = \"\";\n        for (int i=0; i<(int)s.size(); ++i) {\n            r += \"r\"; g += \"g\"; b += \"b\";\n        }\n        queue<pair<string,int> > q;\n        q.push(make_pair(s, 0));\n        int res = -1;\n        while ( ! q.empty()) {\n            string col = q.front().first;\n            used[col] = true; rotate(col);\n            used[col] = true; rotate(col);\n            used[col] = true; rotate(col);\n            int t = q.front().second;\n            if (col == r || col == g || col == b) {\n                res = t;\n                break;\n            }\n            q.pop();\n            for (int i=0; i<(int)col.size()-1; ++i) {\n                if (col[i] != col[i+1]) {\n                    string nxt = col;\n                    if (col[i] != 'r' && col[i+1] != 'r') {\n                        nxt[i] = 'r'; nxt[i+1] = 'r';\n                    } else if (col[i] != 'g' && col[i+1] != 'g') {\n                        nxt[i] = 'g'; nxt[i+1] = 'g';\n                    } else if (col[i] != 'b' && col[i+1] != 'b') {\n                        nxt[i] = 'b'; nxt[i+1] = 'b';\n                    }\n                    if ( ! used[nxt]) {\n                        q.push(make_pair(nxt, t+1));\n                    }\n                }\n            }\n        }\n        if (res < 0) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//01 = r, 10 = g, 11 = b\n\n#include<iostream>\n#include<queue>\n#include<set>\n#include<string>\n#include<map>\n#include<cmath>\nusing namespace std;\n\n#define P pair<int, int>\n\nint makeWormBit(string str);\nvoid makeEnd(int size);\nbool checkEnd(int n);\nint changeColor(int n, int i, int size);\nint searchChangeColor(int n, int i, int mask);\nint makeResetMask(int size, int mask);\n\nint endColor[3];\n\nint main(){\n    string str;\n    while(cin >>str){\n        if(str[0] == '0') break;\n        int bw = makeWormBit(str), deep = 1;\n        queue<P> q;\n        set<int> s;\n        q.push( make_pair(0, bw) );\n        s.insert(bw);\n        makeEnd(str.size());\n        while(!q.empty()){\n            P tmp = q.front();\n            if(checkEnd(tmp.second)){\n                cout <<tmp.first <<endl;\n                break;\n            } else{\n                for(int i = 0; i < str.size() - 1; i++){\n                    int t = changeColor(tmp.second, i, str.size());\n                    if(s.find(t) == s.end()){\n                        q.push( make_pair(tmp.first + 1, t) );\n                        s.insert(t);\n                    }\n                }\n            }\n            q.pop();\n        }\n        if(q.empty()) cout <<\"NA\" <<endl;\n    }\n    return 0;\n}\n\nint makeWormBit(string str){\n    int ret = 0;\n    for(int i = 0; i < str.size(); i++){\n        ret = ret << 2;\n        if(str[i] == 'r') ret |= 1;\n        else if(str[i] == 'g') ret |= 2;\n        else if(str[i] == 'b') ret |= 3;\n    }\n    return ret;\n}\nbool checkEnd(int n){\n    bool ret = false;\n    for(int i = 0; i < 3; i++){\n        if(endColor[i] == n){\n            ret = true;\n            break;\n        }\n    }\n    return ret;\n}\nint changeColor(int n, int i, int size){\n    int ret = n, mask = 15 << (i * 2), resetMask = makeResetMask(size, mask), color = searchChangeColor(n, i, mask);\n    ret &= resetMask;\n    ret |= (color << (i * 2));\n    return ret;\n}\n\nvoid makeEnd(int size){\n    int dx[] = {1, 2, 3}, ans;\n    for(int i = 0; i < 3; i++){\n        ans = 0;\n        for(int j = 0; j < size; j++){\n            ans = ans << 2;\n            ans |= dx[i];\n        }\n        endColor[i] = ans;\n    }\n}\n\nint searchChangeColor(int n, int i, int mask){\n    int strc[] = {5, 10, 15, 6, 7, 9, 11, 13, 14}, strret[] = {5, 10, 15, 15, 10, 15, 5, 10, 5};\n    int c = (n & mask), ret;\n    c = c >> (i * 2);\n    for(int i = 0; i < 9; i++){\n        if(c == strc[i]) ret = strret[i];\n    }\n    return ret;\n}\n\nint makeResetMask(int size, int mask){\n    int ret = 1 << (size * 2);\n    ret--;\n    ret ^= mask;\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <string, int> P;\n\n#define mp(a, b) make_pair(a, b)\n\nchar diff(char a, char b)\n{\n\tif (a != 'r' && b != 'r') return 'r';\n\tif (a != 'g' && b != 'g') return 'g';\n\tif (a != 'b' && b != 'b') return 'b';\n\treturn 'a';\n}\n\nbool check(string str)\n{\n\tchar c = str[0];\n\tfor (int i = 0; i < str.length(); i++){\n\t\tif (c != str[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tstring str;\n\n\twhile (cin >> str){\n\t\tif (str == \"0\") return 0;\n\n\t\tint ret = -1, a;\n\t\tqueue < P > q;\n\t\tq.push(mp(str, 0));\n\t\twhile (!q.empty()){\n\t\t\tP now = q.front();\n\t\t\tq.pop();\n\t\t\tif (check(now.first)){\n\t\t\t\tret = now.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (q.size() > 700000){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < now.first.length()-1; i++){\n\t\t\t\tif (now.first[i] != now.first[i + 1]){\n\t\t\t\t\tstring tmp = now.first;\n\t\t\t\t\ttmp[i] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\ttmp[i + 1] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\tq.push(mp(tmp, now.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret >= 0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define INF 10000000\nusing namespace std;\ntypedef pair<string ,int>P;\nint cnt;\n\nint bfs(string worm){\n  map<string,int>used;\n  queue<P> que;\n  que.push(P(worm,0));\n  string next;\n  \n  while(!que.empty()){\n    char tmp;\n    P p = que.front();\n    que.pop();\n    if(used[p.first] == 1)continue;\n    bool f = true;\n    string str = p.first;\n    for(int i = 0 ; i < p.first.size()-1 ; i++ ){\n      if(str[i] != str[i+1])f = false;\n    }\n    if(f)return p.second;\n    used[p.first] = 1;\n    for(int i = 0 ; i < worm.size()-1 ; i++ ){\n      if(str[i] != str[i+1]){\n\tif(str[i] != 'r' && str[i+1] != 'r'){\n\t  tmp = 'r';\n\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t  tmp = 'g';\n\t} else {\n\t  tmp = 'b';\n      }\n\tnext = str;\n\tnext[i] = next[i+1] = tmp;\n\tque.push(P(next,p.second+1));\n\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string worm;\n  while(cin >> worm){\n    if(worm[0] == '0')break;\n    cnt = 0;\n    int ret = bfs(worm);\n    if(ret == -1){\n      cout << \"NA\" << endl;\n    }else cout << ret << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  string s;\n  while(cin >> s && s!= \"0\"){\n    set<string> st;\n    queue<string> q;\n    q.push(s);\n    int num = 0;\n    int flag = 0;\n    while(1){\n      auto n = q.size();\n      rep(i,n){\n        auto el = q.front();q.pop();\n//         debug(el);\n        if(st.insert(el).se){\n          auto el2 = el;\n          bool f = true;\n          rep(j,el.size()){\n            if(el[0] != el[j]){\n              f = false;\n              break;\n            }\n          }\n          if(f){\n            flag = 2;\n            break;\n          }\n          rep(j,el.size()-1){\n            el = el2;\n            if(el[j] != el[j+1]){\n              if(el[j] != 'g' && el[j+1] != 'g'){\n                el[j] = 'g';\n                el[j+1] = 'g';\n              }\n              else if(el[j] != 'r' && el[j+1] != 'r'){\n                el[j] = 'r';\n                el[j+1] = 'r';\n              }\n              else{\n                el[j] = 'b';\n                el[j+1] = 'b';\n              }\n              q.push(el);\n            }\n          }\n        }\n      }\n      if(!q.size() && flag != 2){\n        cout << \"NA\" <<endl;\n        break;\n      }\n      else if(flag == 2){\n        cout << num <<endl;\n        break;\n      }\n      ++num;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n\nchar z[3]={'r','b','g'};\n\nint Unzip(string s){\n  int ans=0;\n  for(int i=0;i<s.size();i++){\n    ans*=3;\n    for(int j=0;j<3;j++){\n      if(s[i]==z[j])ans+=j;\n    }\n  }\n  return ans;\n}\nchar Other(char a,char b){\n  for(int i=0;i<3;i++){\n    if(z[i]!=a&&z[i]!=b)return z[i];\n  }\n  return '#';\n}\n\nint dis[60000];\nqueue<pair<string,int> >Q;\nint main(){\n  string s;\n  while(cin>>s&&s!=\"0\"){\n    lol(i,60000)dis[i]=mod;\n    Q.push(make_pair(s,0));\n    while(!Q.empty()){\n      string x=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      int index=Unzip(x);\n      if(dis[index]<=len)continue;\n      dis[index]=len;\n      for(int i=0;i<x.size()-1;i++){\n\tif(x[i]!=x[i+1]){\n\t  string news=x;\n\t  news[i]=Other(x[i],x[i+1]);\n\t  news[i+1]=Other(x[i],x[i+1]);\n\t  Q.push(make_pair(news,len+1));\n\t}\n      }\n    }\n    int ans=mod;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<s.size();j++)s[j]=z[i];\n      int index=Unzip(s);\n      ans=min(ans,dis[index]);\n    }\n    if(ans==mod)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint ans = 0;\n\nstring change(string s, int a, int b){\n\tif((s[a] == 'r' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'r'))\n\t\ts[b] = s[a] = 'b';\n\telse if((s[a] == 'b' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'b'))\n\t\ts[b] = s[a] = 'r';\n\telse\n\t\ts[b] = s[a] = 'g';\n\t\n\treturn s;\n}\n\nvoid bfs(string s, int res){\n\tif(res >= ans)\n\t\treturn;\n\tfor(int i = 0; i < s.size() - 1; ++i){\n\t\tif(s[i] != s[i + 1])\n\t\t\tbreak;\n\t\tif(i == s.size() - 2){\n\t\t\tans = min(res, ans);\n\t\t\treturn;\n\t\t}\n\t}\n\tif(res >= 10)\n\t\treturn;\n\tfor(int i = 0; i < s.size() - 1; ++i){\n\t\tif(s[i] != s[i + 1]){\n\t\t\tstring str = change(s, i, i + 1);\n\t\t\tbfs(str, res + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s == \"0\")\n\t\t\tbreak;\n\t\tans = INF;\n\t\tbfs(s, 0);\n\t\tif(ans == INF)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <stack>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<string, int>;\nusing edge = struct\n{\n    int to;\n    int cost;\n};\n\nint wfs(string worm)\n{\n    queue<P> que;\n    que.push(P(worm, 0));\n\n    map<string, int> mp;\n\n    while (!que.empty())\n    {\n        P p = que.front();\n        que.pop();\n\n        string tmp = p.first;\n\n        if(mp[p.first]) continue;\n\n        bool flag = true;\n\n        for (int i = 0; i < tmp.size() - 1; i++)\n        {\n            if (tmp[i] != tmp[i + 1])\n            {\n                flag = false;\n                break;\n            }\n        }\n\n        if (flag) return p.second;\n\n        mp[p.first] = p.second;\n\n        for(int i = 0; i < tmp.size() - 1; i++)\n        {\n            if(tmp[i] == tmp[i + 1]) continue;\n\n            string nworm = tmp;\n\n            if(tmp[i] != 'g' && tmp[i + 1] != 'g')\n            {\n                nworm[i] = 'g';\n                nworm[i + 1] = 'g';\n            }\n            else if(tmp[i] != 'b' && tmp[i + 1] != 'b')\n            {\n                nworm[i] = 'b';\n                nworm[i + 1] = 'b';\n            }\n            else\n            {\n                nworm[i] = 'r';\n                nworm[i + 1] = 'r';\n            }\n\n            que.push(P(nworm, p.second + 1));\n\n        }        \n    }\n    return -1;\n}\n\nint main()\n{\n    string input;\n\n    while(cin >> input && input != \"0\")\n    {\n        cout << (wfs(input) ? to_string(wfs(input)) : \"NA\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nusing namespace std;\n\nchar get_color(char c1, char c2) {\n    if ((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r'))\n        return 'b';\n    else if ((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g'))\n        return 'r';\n    else\n        return 'g';\n}\n\nbool is_finish(string s) {\n    rep(i, s.size()) if (s[0] != s[i]) return false;\n    return true;\n}\n\nstring s;\nvoid solve() {\n    queue<string> worm;\n    map<string, int> dict;\n\n    int ans = -1;\n    worm.push(s);\n    while (worm.size()) {\n        string t = worm.front();\n        int now = dict[t];\n        worm.pop();\n        if (is_finish(t)) {\n            ans = now;\n            break;\n        }\n\n        rep(i, t.size() - 1) {\n            if (t[i] != t[i + 1]) {\n                string next = t;\n                next[i] = next[i + 1] = get_color(t[i], t[i + 1]);\n                if (dict.count(next) == 0) {\n                    // cout << t << \" -> \" << next << endl;\n                    worm.push(next);\n                    dict[next] = now + 1;\n                }\n            }\n        }\n    }\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n}\n\nint main() {\n    while (cin >> s) {\n        if (s == \"0\") break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n\nint main(){\n\tstring str,tmp,s;\n\tbool f;\n\twhile(cin >> str){\n\t\tqueue<string> que;\n\t\tmap<string,int> m;\n\t\tif(str == \"0\") break;\n\t\tque.push(str);\n\t\twhile(!que.empty()){\n\t\t\tf = true;\n\t\t\ts = tmp = que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i = 0;i < s.length()-1;++i){\n\t\t\t\tif(s[i] != s[i+1]) f = false; \n\t\t\t}\n\t\t\tif(f) break;\n\t\t\tfor(int i = 0;i < tmp.length()-1;++i){\n\t\t\t\tif(tmp[i] == 'r'){\n\t\t\t\t\tif(tmp[i+1] == 'b') tmp[i] = tmp[i+1] = 'g';\n\t\t\t\t\telse if(tmp[i+1] == 'g') tmp[i] = tmp[i+1] = 'b';\n\t\t\t\t}\n\t\t\t\telse if(tmp[i] == 'b'){\n\t\t\t\t\tif(tmp[i+1] == 'r') tmp[i] = tmp[i+1] = 'g';\n\t\t\t\t\telse if(tmp[i+1] == 'g') tmp[i] = tmp[i+1] = 'r';\n\t\t\t\t}\n\t\t\t\telse if(tmp[i] == 'g'){\n\t\t\t\t\tif(tmp[i+1] == 'r') tmp[i] = tmp[i+1] = 'b';\n\t\t\t\t\telse if(tmp[i+1] == 'b') tmp[i] = tmp[i+1] = 'r';\n\t\t\t\t}\n\t\t\t\tif(!m.count(tmp)) {\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t\tm[tmp] = m[s] + 1;\n\t\t\t\t}\n\t\t\t\ttmp = s;\n\t\t\t}\n\t\t}\n\t\tif(f) cout << m[s] << endl;\n\t\telse cout << \"NA\" << endl;\n\t\tm.clear();\n\t\twhile(!que.empty()) que.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nchar get(char a,char b){\n\tbool c[128]={0};\n\tc[a] = c[b] = true;\n\tif(!c['r'])return 'r';\n\tif(!c['g'])return 'g';\n\tif(!c['b'])return 'b';\n}\nbool same(string t){\n\tfor(int i=0;i<t.size();i++)\n\t\tif(t[i] != t[0])return false;\n\treturn true;\n}\nint main(){\n\tstring str;\n\twhile(cin >> str , str != \"0\"){\n\t\tqueue<string> Q;\n\t\tmap<string,int> done;\n\t\tdone[str] = 0;\n\t\tQ.push(str);\n\t\tint ans = -1;\n\t\twhile(Q.size()){\n\t\t\tstring q = Q.front(); Q.pop();\n\t\t\tif(same(q)){ans = done[q];break;};\n\t\t\tfor(int i=0;i<q.size()-1;i++){\n\t\t\t\tif(q[i] != q[i+1]){\n\t\t\t\t\tstring t = q;\n\t\t\t\t\tt[i] = t[i+1] = get(q[i],q[i+1]);\n\t\t\t\t\tif(done.find(t) == done.end()){\n\t\t\t\t\t\tdone[t] = done[q]+1;\n\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(~ans)cout << ans << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing pii = pair<int, int>; using vi = vector<int>;\nstatic const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nstatic const int MOD = (int)(1e9 + 7);\n\nbool f(string s) {\n\trep(i, 0, s.size() - 1)\n\t\tif (s[i] != s[i + 1])return false;\n\treturn true;\n}\n\nsigned main() {\n\tfor (string s; cin >> s&&s != \"0\";) {\n\t\tmap<string, int> m;\n\t\tm[s] = 0;\n\t\tqueue<string> q;\n\t\tq.emplace(s);\n\t\twhile (!q.empty()) {\n\t\t\tstring t = q.front(); q.pop();\n\t\t\trep(i, 0, t.size() - 1) {\n\t\t\t\tif (t[i] == t[i + 1])continue;\n\t\t\t\tstring tmp = t;\n\t\t\t\tif (t[i] + t[i + 1] == 'r' + 'g')tmp[i] = tmp[i + 1] = 'b';\n\t\t\t\tif (t[i] + t[i + 1] == 'g' + 'b')tmp[i] = tmp[i + 1] = 'r';\n\t\t\t\tif (t[i] + t[i + 1] == 'b' + 'r')tmp[i] = tmp[i + 1] = 'g';\n\n\t\t\t\tif (m.find(tmp) == m.end()) {\n\t\t\t\t\tq.emplace(tmp);\n\t\t\t\t\tm[tmp] = m[t] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (auto itr = m.begin(); itr != m.end(); itr++) {\n\t\t\tif (f(itr->first))ans=min(ans,itr->second);\n\t\t}\n\t\tif (ans == INF)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\nint dp[60000];\n\n\n\nint main(){\n    string s;\n    while(cin>>s){\n        if(s==\"0\")break;\n        int l=s.size();\n        rep(i,60000)dp[i]=INF;\n        bool ff=true;\n        rep(i,s.size()-1){\n            if(s[i]!=s[i+1])ff=false;\n        }\n        if(ff)cout<<\"0\"<<endl;\n        if(ff)continue;\n        int num=0;\n        rep(i,s.size()){\n            num*=3;\n            int p=0;\n            if(s[i]=='g')p=1;\n            if(s[i]=='b')p=2;\n            num+=p;\n        }\n        dp[num]=0;\n        \n        queue<pii> que;\n        que.push(pii(num,0));\n        while(que.size()){\n//            cout<<que.size()<<endl;\n            pii q=que.front();\n            que.pop();\n            vector<int> vec;\n            rep(i,l){\n                vec.pb(q.first%3);\n                q.first/=3;\n            }\n            reverse(all(vec));\n            reverse(all(vec));\n            rep(i,l-1){\n                if(vec[i]!=vec[i+1]){\n                    int a=vec[i],b=vec[i+1];\n                    if(a>b)swap(a,b);\n                    vector<int> v=vec;\n                    if(a==0&&b==1)v[i]=v[i+1]=2;\n                    if(a==1&&b==2)v[i]=v[i+1]=0;\n                    if(a==0&&b==2)v[i]=v[i+1]=1;\n                    bool f=true;\n                    rep(i,vec.size()-1){\n                        if(v[i]!=v[i+1])f=false;\n                    }\n                    if(f){\n                        cout<<q.second+1<<endl;\n                        goto next;\n                    }\n                    int x=0;\n                    rep(j,v.size()){\n                        x*=3;\n                        x+=v[j];\n                    }\n                    if(dp[x]==INF){\n                        dp[x]=q.second+1;\n                        que.push(pii(x,q.second+1));\n                    }\n                }\n            }\n        }\n        cout<<\"NA\"<<endl;\n    next:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint res[11][180000];\n\nint p(int n){\n\tif(n==0) return 1;\n\treturn 3*p(n-1);\n}\n\npriority_queue<pint,vector<pint>,greater<pint> > bfs;\nint i;\n\nvoid g(pint a){\n\tint j;\n\tfor(j=0;j<i-1;j++){\n\t\tif(a.second%p(j+1)/p(j)==a.second%p(j+2)/p(j+1)){\n\t\t\tint k=a.second%p(j+1)/p(j);\n\t\t\tint l=a.second;\n\t\t\tl-=k*p(j)+k*p(j+1);\n\t\t\tif(k==0){\n\t\t\t\tbfs.push(mp(a.first+1,l+p(j)+2*p(j+1)));\n\t\t\t\tbfs.push(mp(a.first+1,l+2*p(j)+p(j+1)));\n\t\t\t}\n\t\t\tif(k==1){\n\t\t\t\tbfs.push(mp(a.first+1,l+2*p(j+1)));\n\t\t\t\tbfs.push(mp(a.first+1,l+2*p(j)));\n\t\t\t}\n\t\t\tif(k==2){\n\t\t\t\tbfs.push(mp(a.first+1,l+p(j+1)));\n\t\t\t\tbfs.push(mp(a.first+1,l+p(j)));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tmemset(res,-1,sizeof(res));\n\tfor(i=2;i<=10;i++){\n\t\tint j,k=0;\n\t\twhile(!bfs.empty())bfs.pop();\n\t\tfor(j=0;j<i;j++)k+=p(j)*0;\n\t\tres[i][k]=0;\n\t\tg(mp(0,k));\n\t\tk=0;\n\t\tfor(j=0;j<i;j++)k+=p(j)*1;\n\t\tres[i][k]=0;\n\t\tg(mp(0,k));\n\t\tk=0;\n\t\tfor(j=0;j<i;j++)k+=p(j)*2;\n\t\tres[i][k]=0;\n//cout<<k<<endl;\n\t\tg(mp(0,k));\n\t\twhile(!bfs.empty()){\n\t\t\tpint buf;\n\t\t\tbuf=bfs.top();\n\t\t\tbfs.pop();\n//cout<<buf.first<<\" \"<<buf.second<<endl;\n\t\t\tif(res[i][buf.second]!=-1&&res[i][buf.second]<=buf.first)continue;\n\t\t\tres[i][buf.second]=buf.first;\n\t\t\tg(buf);\n\t\t}\n\t}\n//for(i=2;i<=10;i++){\n//\tint j;\n//\tfor(j=0;j<p(i);j++){\n//\t\tint l;\n//\t\tfor(l=0;l<i;l++){\n//\t\t\tif(j/p(l)%3==0)cout<<\"r\";\n//\t\t\tif(j/p(l)%3==1)cout<<\"b\";\n//\t\t\tif(j/p(l)%3==2)cout<<\"g\";\n//\t\t}\n//\t\tcout<<\" \"<<res[i][j]<<endl;\n//\t}\n//}\n\tstring str;\n\twhile(cin>>str,str!=\"0\"){\n\t\tint k=0;\n\t\tint j;\n\t\tfor(j=0;j<str.size();j++){\n\t\t\tif(str[j]=='r')k=k*3+0;\n\t\t\tif(str[j]=='b')k=k*3+1;\n\t\t\tif(str[j]=='g')k=k*3+2;\n\t\t}\n\t\tif(res[str.size()][k]>=0)cout<<res[str.size()][k]<<endl;\n\t\telse cout<<\"NA\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  string s;\n  while (cin >> s) {\n    if (s == \"0\")\n      break;\n\n    queue<pair<int, string> > que;\n    que.push(make_pair(0, s));\n    set<string> memo;\n    int ans = -1;\n    while (!que.empty()) {\n      const pair<int, string> p = que.front();\n      que.pop();\n\n      if (p.second.find_first_of(\"rg\") == string::npos ||\n\t  p.second.find_first_of(\"rb\") == string::npos ||\n\t  p.second.find_first_of(\"gb\") == string::npos) {\n\tans = p.first;\n\tbreak;\n      }\n\n      if (memo.find(p.second) != memo.end())\n\tcontinue;\n      memo.insert(p.second);\n\n      for (int i = 0; i < p.second.size()-1; ++i) {\n\tif (p.second[i] != p.second[i+1]) {\n\t  s = p.second;\n\t  if (s[i] == 'r' && s[i+1] == 'g' || s[i] == 'g' && s[i+1] == 'r')\n\t    s[i] = s[i+1] = 'b';\n\t  else if (s[i] == 'r' && s[i+1] == 'b' || s[i] == 'b' && s[i+1] == 'r')\n\t    s[i] = s[i+1] = 'g';\n\t  else if (s[i] == 'g' && s[i+1] == 'b' || s[i] == 'b' && s[i+1] == 'g')\n\t    s[i] = s[i+1] = 'r';\n\n\t  if (memo.find(s) == memo.end())\n\t    que.push(make_pair(p.first+1, s));\n\t}\n      }\n\n    }\n\n    if (ans == -1)\n      cout << \"NA\" << endl;\n    else\n      cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nstatic const char a[] = {'r','g','b'};\n\nbool checkColor(const string& str){\n\n\tbool res = false;\n\tfor(int i=0;i<3;i++){\n\t\tif(count(str.begin(),str.end(),a[i]) == str.size()) res=true;\n\t}\n\n\treturn res;\n}\n\nint changeColor(string str,int cost,map<string,int>& visited){\n\n\tif(checkColor(str)) return 0;\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,str));\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\tstring now = que.top().second;\n\n\t\tque.pop();\n\t\tfor(int i=0;i+1<now.size();i++){\n\t\t\tstring tmp = now;\n\t\t\tif(now[i] != now[i+1]){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(a[j] != now[i] && a[j] != now[i+1]){\n\t\t\t\t\t\ttmp[i] = a[j];\n\t\t\t\t\t\ttmp[i+1] = a[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(visited.find(tmp) != visited.end()) continue;\n\n\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\tif(checkColor(tmp)) return cost+1;\n\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint main(){\n\tstring str;\n\n\twhile(cin>>str){\n\t\tif(str.size() == 1 && str[0] == '0') break;\n\t\tmap<string,int> visited;\n\t\tvisited[str] = 0;\n\n\t\tint res = changeColor(str,0,visited);\n\n\t\tif(res==-1) printf(\"%s\\n\",\"NA\");\n\t\telse printf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\nchar conv(char c1,char c2){\n  if(c1=='r'){\n    if(c2=='g')return 'b';\n    if(c2=='b')return 'g';\n  }else if(c1=='g'){\n    if(c2=='r')return 'b';\n    if(c2=='b')return 'r';\n  }else if(c1=='b'){\n    if(c2=='r')return 'g';\n    if(c2=='g')return 'r';\n  }\n}\nint bfs(string s){\n  queue< pair<int, string> > qs;\n  qs.push( make_pair(0,s) );\n  while(!qs.empty()){\n    bool bFound=false;\n    int ret = qs.front().first;\n    string now = qs.front().second;\n    if(ret>s.length())break;\n    qs.pop();\n    for(int i = 0; i < now.length()-1; ++i){\n      if(now[i]!=now[i+1]){\n\tbFound = true;\n\tstring next = now;\n\tchar nc = conv(now[i],now[i+1]);\n\tnext[i] = next[i+1] = nc;\n\tqs.push(make_pair(ret+1,next));\n      }\n    }\n    if(!bFound){\n      //cout << now << endl;\n      return ret;\n    }\n  }\n  return -1;\n}\nint main(){\n  while(true){\n    string s;\n    cin >> s;\n    if( s == \"0\" )  break;\n    int ans = bfs(s);\n    if( ans < 0 )\n      cout << \"NA\" << endl;\n    else\n      cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\n  string s,col[3];\n  queue<string> que;\n  map<string,int> mp;\n  int flag;\n\n  while(cin >> s && s != \"0\"){\n    flag = 1;\n    que.push(s);\n    mp[s] = 0;\n    for(int i=0;i<3;i++) col[i] = \"\";\n    for(int i=0;i<s.size();i++){\n      col[0] += \"r\";\n      col[1] += \"b\";\n      col[2] += \"g\";\n    }\n    while(!que.empty()){\n      if(que.front()==col[0]){\n\tcout << mp[col[0]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[1]){\n\tcout << mp[col[1]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[2]){\n\tcout << mp[col[2]] << endl;\n\tflag--;\n\tbreak;\n      }\n      for(int i=0;i<s.size()-1;i++){\n\tif(que.front()[i] != que.front()[i+1]){\n\t  s = que.front();\n\t  if(s[i] != 'r' && s[i+1] != 'r'){\n\t    s[i] = 'r';\n\t    s[i+1] = 'r';\n\t  } else if(s[i] != 'b' && s[i+1] != 'b'){\n\t    s[i] = 'b';\n\t    s[i+1] = 'b';\n\t  }else if(s[i] != 'g' && s[i+1] != 'g'){\n\t    s[i] = 'g';\n\t    s[i+1] = 'g';\n\t  }\n\t  if(mp.find(s) == mp.end()){\n\t    que.push(s);\n\t    mp[s] = mp[que.front()]+1;\n\t  }\n\t}\n      }\n      que.pop();\n    }\n    while(!que.empty()) que.pop();\n    if(flag) cout << \"NA\" << endl;\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  typedef pair<string,int>P;\n  while(1){\n    string str;\n    map<string,int>maps;\n    queue<P>que;\n    int kaku=0;\n    cin>>str;\n    if(str[0]=='0')break;\n     que.push(P(str,0));\n     while(!que.empty()){\n       P p=que.front();que.pop();\n       string  now,turn;\n       int cnt=1;\n       int ans;\n       now=p.first;\n       turn=p.first;\n       ans=p.second;\n       //   cout<<now<<\" \"<<ans<<endl;\n       if(maps[now]==1)continue;\n       maps[now]=1;\n       \n       for(int i=0;i<str.size()-1;i++){\n\t if(now[i]==now[i+1])cnt++;\n       }\n       if(cnt==str.size()){\n\t cout<<ans<<endl;\n\t kaku=1;\n\t break;\n       }\n       for(int i=0;i<str.size()-1;i++){\n\t if(now[i]=='b' && now[i+1]=='r' || now[i]=='r' && now[i+1]=='b'){\n\t   now[i]='g';now[i+1]='g';\n\t   que.push(P(now,ans+1));\n\t   now=turn;\n\t }\n\t if(now[i]=='r' && now[i+1]=='g' || now[i]=='g' && now[i+1]=='r'){\n\t   now[i]='b';now[i+1]='b';\n\t   que.push(P(now,ans+1));\n\t   now=turn;\n\t }\n\t if(now[i]=='b' && now[i+1]=='g' || now[i]=='g' && now[i+1]=='b'){\n\t   now[i]='r';now[i+1]='r';\n\t   que.push(P(now,ans+1));\n\t   now=turn;\n\t }\n       }\n     }\n     if(!kaku)cout<<\"NA\"<<endl;\n  }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\nstruct worm{\n\tint c;\n\tstring s;\n};\nqueue<worm> que;\nbool str_check(string str){\n\tfor(int i = 1;i < str.size();++i){\n\t\tif(str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\nint f(){\n\tmap<string,int> check;\n\twhile(que.size()){\n\t\tworm w = que.front(),tmp;\n\t\tque.pop();\n\t\tint n = w.c;\n\t\tstring str = w.s;\n\t\tif(str_check(str)){\n\t\t\treturn n;\n\t\t}\n\t\tfor(int i = 0;i < str.size() - 1;++i){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tif((str[i] == 'r' && str[i+1] == 'b') || (str[i] == 'b' && str[i+1] == 'r')){\n\t\t\t\t\tstr[i] = str[i+1] = 'g';\n\t\t\t\t}\n\t\t\t\telse if((str[i] == 'g' && str[i+1] == 'b') || (str[i] == 'b' && str[i+1] == 'g')){\n\t\t\t\t\tstr[i] = str[i+1] = 'r';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[i] = str[i+1] = 'b';\n\t\t\t\t}\n\n\t\t\t\tif(!check.count(str)){\n\t\t\t\t\ttmp.s = str;\n\t\t\t\t\ttmp.c = n + 1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t\tcheck[str] = n + 1;\n\t\t\t\t}\n\t\t\t\tstr = w.s;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\tstring str;\n\tworm w;\n\twhile(cin >> str){\n\t\tif(str == \"0\") break;\n\t\tw.s = str;\n\t\tw.c = 0;\n\t\tque.push(w);\n\t\tint n = f();\n\t\tif(n == -1) cout << \"NA\\n\";\n\t\telse cout << n << endl;\n\t\twhile(que.size()){\n\t\t\tque.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n\tqueue<P> que;\n\tque.push(P(worm, 0));\n\n\tmap<string, int> d;\n\t\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\t//重複パターンはcontinue\n\t\tif(d[p.first]) continue;\n\n\t\tstring str = p.first;\n\n\t\t//全色同じかどうかのチェック\n\t\tbool flag = false;\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//同じならreturn\n\t\tif(!flag) return p.second;\n\n\t\t//重複パターン判別用\n\t\td[p.first] = p.second;\n\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\t//隣り合わせで色が異なるとき\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\n\t\t\t\t//tempに含まれない一色を代入\n\t\t\t\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t\t\t\t\ttemp = 'b';\n\t\t\t\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t\t\t\t\ttemp = 'g';\n\t\t\t\t}else{\n\t\t\t\t\ttemp = 'r';\n\t\t\t\t}\n\n\t\t\t\t//変化後の順番をnextに詰め込む\n\t\t\t\tnext = str;\n\t\t\t\tnext[i] = next[i+1] = temp;\n\n\t\t\t\t//キューにプッシュ\n\t\t\t\tque.push(P(next, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring worm;\n\twhile(cin >> worm && worm != \"0\"){\n\t\tint ret = bfs(worm);\n\t\tif(ret>=0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct s{\n    string worm;\n    int nowans;\n};\nint main(){\n    char dc[6][3]={'r','g','b','g','r','b','r','b','g','b','r','g','g','b','r','b','g','r'};\n    while(1){\n        int che[100000]={0},chenum=0;\n        s IN,now;\n        queue <s> que;\n        cin >> IN.worm;\n        IN.nowans=0;\n        if(IN.worm[0]=='0')\n            break;\n        que.push(IN);\n        while(1){\n            chenum=0;\n            now=que.front(),que.pop();\n            for(int i=0;i<10;i++){\n                if(now.worm[i]=='r')\n                    chenum+=pow(3,i);\n                else if(now.worm[i]=='g')\n                    chenum+=pow(3,i)*2;\n                else if(now.worm[i]=='b')\n                    chenum+=pow(3,i)*3;\n            }\n            if(che[chenum])\n                continue;\n            else\n                che[chenum]=1;\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1])\n                    break;\n                if(i==now.worm.size()-1-1){\n                    printf(\"%d\\n\",now.nowans);\n                    goto exit;\n                }\n            }\n            if(now.nowans==20){\n                puts(\"NA\");\n                goto exit;\n            }\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1]){\n                    for(int j=0;j<6;j++){\n                        if(now.worm[i]==dc[j][0]&&now.worm[i+1]==dc[j][1]){\n                            now.worm[i]=dc[j][2],now.worm[i+1]=dc[j][2],now.nowans++;\n                            que.push(now);\n                            now.worm[i]=dc[j][0],now.worm[i+1]=dc[j][1],now.nowans--;\n                        }\n                    }\n                }\n            }\n        }\nexit:\n    printf(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint worm[4][4][4][4][4][4][4][4][4][4];\n\nint main() {\n    fill_n((int *)worm, 4*4*4*4*4*4*4*4*4*4, -1);\n    FOR(len, 2, 11) {\n        queue<vi> que;\n        FOR(color, 1, 4) {\n            vi v(10, 0);\n            REP(i, len) v[i] = color;\n            que.push(v);\n        }\n        que.push({});\n        int cnt = 0;\n        while (1) {\n            vi v = que.front(); que.pop();\n            if (v.empty()) {\n                if (que.empty()) break;\n                que.push({});\n                cnt++;\n                continue;\n            }\n            if (worm[v[9]][v[8]][v[7]][v[6]][v[5]][v[4]][v[3]][v[2]][v[1]][v[0]] != -1) continue;\n            worm[v[9]][v[8]][v[7]][v[6]][v[5]][v[4]][v[3]][v[2]][v[1]][v[0]] = cnt;\n            REP(i, len-1) {\n                if (v[i+1] != 0 && v[i] == v[i+1]) {\n                    int c1 = (v[i]) % 3 + 1, c2 = (v[i]+1) % 3 + 1;\n                    vi v1 = v;\n                    v1[i] = c1, v1[i+1] = c2;\n                    que.push(v1);\n                    vi v2 = v;\n                    v2[i] = c2, v2[i+1] = c1;\n                    que.push(v2);\n                }\n            }\n        }\n    }\n\n    string line;\n    while (cin >> line, line != \"0\") {\n        vi v(10, 0);\n        REP(i, line.size()) v[i] = line[i] % 3 + 1; // rgb -> 123\n        int res = worm[v[9]][v[8]][v[7]][v[6]][v[5]][v[4]][v[3]][v[2]][v[1]][v[0]];\n        if (res == -1) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef long long int ll;\n\nll tr(string a);\nbool cl(string a);\nint c3(ll a);\nint solve(string st);\n\nint main()\n{\n    string input;\n    cin >> input;\n    while (input[0] != '0') {\n        int ans = solve(input);\n        if (ans != INF) {\n            cout << ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n        cin >> input;\n    }\n    return 0;\n}\n\nint solve(string st)\n{\n    int ans = 0;\n    bool check[1048576];\n    queue<string> a, b, c;\n    if ( cl(st) ) {\n        return ans;\n    }\n    a.push(st);\n    while (!a.empty()) {\n        while (!a.empty()) {\n            st = a.front();\n            a.pop();\n            if (check[c3(tr(st))]) {\n                continue;\n            } else {\n                check[c3(tr(st))] = true;\n                //cout << c3(tr(st)) << endl;\n            }\n            if (cl(st)) {\n                return ans;\n            }\n            for (int i = 1; i < st.size(); i++) {\n                if (st[i-1] != st[i]) {\n                    string nw(st);\n                    if (st[i-1] != 'r' && st[i] != 'r') {\n                        nw[i-1] = 'r';\n                        nw[i] = 'r';\n                    } else if (st[i-1] != 'g' && st[i] != 'g') {\n                        nw[i-1] = 'g';\n                        nw[i] = 'g';\n                    } else if (st[i-1] != 'b' && st[i] != 'b') {\n                        nw[i-1] = 'b';\n                        nw[i] = 'b';\n                    }\n                    b.push(nw);\n                }\n            }\n        }\n        a = b;\n        b = c;\n        ans++;\n    }\n    return INF;\n}\n\nll tr(string a)\n{\n    ll ret = 0;\n    for (int i = 0; i < a.size(); i++) {\n        ret *= 10;\n        if (a[i] == 'r') {\n            ret += 1;\n        } else if (a[i] == 'g') {\n            ret += 2;\n        } else {\n            ret += 3;\n        }\n    }\n    return ret;\n}\n\nbool cl(string a)\n{\n    for (int i = 1; i < a.size(); i++) {\n        if (a[i-1] != a[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint c3(ll a)\n{\n    int ret = 0;\n    if (a) {\n        ret = c3(a / 10);\n        ret *= 4;\n        ret += a % 10;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    map<string, int> m;\n    que.push(pair<string, int>(worm, 0));\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        string worm1 = que.front().first;\n        int num = que.front().second;\n        que.pop();\n\n        if(m[worm1]){\n            continue;\n        }\n        if(all(worm1) == 0){\n            return num;\n        }\n\n        m[worm1] = num;\n\n        REP(i, worm1.size()-1){\n            string tmp = worm1;\n            if(tmp[i] != tmp[i+1]){\n                if(tmp[i] != 'r' && tmp[i+1] != 'r') tmp[i] = tmp[i+1] = 'r';\n                else if(tmp[i] != 'g' && tmp[i+1] != 'g') tmp[i] = tmp[i+1] = 'g';\n                else tmp[i] = tmp[i+1] = 'b';\n\n                que.push(pair<string, int> (tmp, num+1));\n           }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    string S;\n    while(cin>>S,S!=\"0\"){\n        map<string,int>dist;\n        dist[S]=0;\n\n        queue<string>que;\n        que.push(S);\n        while(que.size()){\n            string s=que.front();\n            que.pop();\n\n            for(int i=0;i+1<s.size();i++){\n                if(s[i]==s[i+1])continue;\n                int c;\n                rep(j,3)if(\"rgb\"[j]!=s[i]&&\"rgb\"[j]!=s[i+1])c=j;\n                string ss=s;\n                ss[i]=ss[i+1]=\"rgb\"[c];\n                if(dist.find(ss)!=dist.end())continue;\n                dist[ss]=dist[s]+1;\n                que.push(ss);\n            }\n        }\n\n        int mi=1001001001;\n        rep(i,3){\n            string s=string(S.size(),\"rgb\"[i]);\n            if(dist.find(s)!=dist.end())chmin(mi,dist[s]);\n        }\n\n        if(mi==1001001001)cout<<\"NA\"<<endl;\n        else cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef pair<string,int> P;\n\nstring change(char a, char b) {\n  string s;\n  if((a=='r' && b=='g') || (a=='g' && b=='r')) s=\"bb\";\n  if((a=='r' && b=='b') || (a=='b' && b=='r')) s=\"gg\";\n  if((a=='g' && b=='b') || (a=='b' && b=='g')) s=\"rr\";\n  return s;\n}\n\nint main() {\n  string t;\n  while(cin >> t && t!=\"0\") {\n    map<string,int> color;\n    queue<P> que;\n    que.push(P(t,0));\n    color[t]=1;\n    int ans=-1;\n    while(!que.empty()) {\n      P p=que.front();\n      que.pop();\n      string s=p.first;\n      bool ck=true;\n      for(int i=0; i<s.size()-1; i++) {\n\tif(s[i]!=s[i+1]) {\n\t  string r;\n\t  r=s.substr(0,i)+change(s[i],s[i+1])+s.substr(i+2,s.size()-i-2);\n\t  if(color[r]!=1) {\n\t    que.push(P(r,p.second+1));\n\t    color[r]=1;\n\t  }\n\t  ck=false;\n\t}\n      }\n      if(ck) {\n\tans=p.second;\n\tbreak;\n      }\n    }\n    if(ans==-1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nchar dir[]{ 'r','g','b' };\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"0\") {\n\t\tqueue<string>que;\n\t\tunordered_map<string, int>mp;\n\t\tque.push(s);\n\t\tmp[s] = 1;\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tint r, g;\n\t\t\tif ((r = count(u.begin(), u.end(), 'r')) == u.size() ||\n\t\t\t\t(r == 0 && (g = count(u.begin(), u.end(), 'g')) == u.size()) ||\n\t\t\t\t(r == 0 && g == 0)) {\n\t\t\t\tprintf(\"%d\\n\", mp[u] - 1);\n\t\t\t\tgoto goal;\n\t\t\t}\n\t\t\trep(i, u.size() - 1) {\n\t\t\t\tif (u[i] != u[i + 1]) {\n\t\t\t\t\tstring v = u;\n\t\t\t\t\tv[i] = v[i + 1] = dir[3 - (find(dir, dir + 3, u[i]) - dir) - (find(dir, dir + 3, u[i + 1]) - dir)];\n\t\t\t\t\tif (!mp[v]) {\n\t\t\t\t\t\tmp[v] = mp[u] + 1;\n\t\t\t\t\t\tque.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"NA\");\n\tgoal:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\n\nint memo[1 << 20];\nint w[10];\nint f[3];\n\nvoid make_f(int n){\n\trep(i, 3){\n\t\tint num = 0;\n\t\trep(j, n){\n\t\t\tnum = num * 4 + i;\n\t\t}\n\t\tf[i] = num;\n\t}\n}\n\nint get_s(const string &s){\n\tint res = 0;\n\trep(i, s.size()){\n\t\tres *= 4;\n\t\tif(s[i] == 'r') res++;\n\t\tif(s[i] == 'g') res += 2;\n\t}\n\treturn res;\n}\n\nint get_color(int a, int b){\n\tint c = min(a, b);\n\tint d = max(a, b);\n\tif(c == 0 && d == 1) return 2;\n\tif(c == 0 && d == 2) return 1;\n\telse return 0;\n}\n\nint get_num(int *w, int n){\n\tint res = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tres = res * 4 + w[i];\n\t}\n\treturn res;\n}\n\nvoid to_w(int num, int n){\n\tfor(int i = 0; i < n; i++){\n\t\tw[i] = num % 4;\n\t\tnum /= 4;\n\t}\n\treverse(w, w + n);\n}\n\nint main(){\n\tint n, start;\n\tstring s;\n\twhile(cin >> s && s != \"0\"){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tn = s.size();\n\t\tstart = get_s(s);\n\t\tmake_f(n);\n\t\tqueue<int> que;\n\t\tque.push(start);\n\t\tmemo[start] = 0;\n\t\tbool ok = false;\n\t\twhile(!que.empty()){\n\t\t\tint num = que.front();\n\t\t\tint c = memo[num];\n\t\t\tque.pop();\n\t\t\tif(num == f[0] || num == f[1] || num == f[2]){\n\t\t\t\tcout << c << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tto_w(num, n);\n\t\t\trep(i, n-1){\n\t\t\t\tif(w[i] != w[i+1]){\n\t\t\t\t\tint a = w[i];\n\t\t\t\t\tint b = w[i+1];\n\t\t\t\t\tw[i] = get_color(a, b);\n\t\t\t\t\tw[i+1] = get_color(a, b);\n\t\t\t\t\tint num2 = get_num(w, n);\n\t\t\t\t\tif(memo[num2] == -1){\n\t\t\t\t\t\tmemo[num2] = c + 1;\n\t\t\t\t\t\tque.push(num2);\n\t\t\t\t\t}\n\t\t\t\t\tw[i] = a;\n\t\t\t\t\tw[i+1] = b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\ntypedef long long ll;\n\nint main(void) {\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \"0\") break;\n        map<string, int> mi;\n        queue<string> q;\n        q.push(s);\n        mi[s] = 0;\n        bool flag = true;\n        while (!q.empty()) {\n            string now = q.front(); q.pop();\n            // 全て同じ文字かどうかのチェック\n            int i;\n            for (i = 0; i < now.size()-1; i++) {\n                if (now[i] != now[i+1]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (i == now.size()-1) {\n                cout << mi[now] << endl;\n                break;\n            }\n            // いろいろ移行するところを考える\n            for (int i = 0; i < now.size()-1; i++) {\n                string s = now;\n                if (s[i] != s[i+1]) {\n                    if (s[i] != 'r' && s[i+1] != 'r') {\n                        s[i] = 'r'; s[i+1] = 'r';\n                    } else if (s[i] != 'g' && s[i+1] != 'g') {\n                        s[i] = 'g'; s[i+1] = 'g';\n                    } else {\n                        s[i] = 'b'; s[i+1] = 'b';\n                    }\n                }\n                if (mi.find(s) == mi.end()) {\n                    q.push(s);\n                    mi.insert(map<string, int>::value_type(s, mi[now]+1));\n                }\n            }\n        }\n        if (flag) cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct Data{\n    string s;\n    int t;\n    Data(string _s,int _t){\n        s =_s,t =_t;\n    }\n};\nmap<string,bool> M;\nint main(){\n    string str;\n    while(cin>>str,str!=\"0\"){\n        queue<Data> Q;\n        Q.push(Data(str,0));\n        while(!Q.empty()){\n            Data E = Q.front();\n            //cout<<E.s<<endl;\n            Q.pop();\n            if(M[E.s])continue;\n            M[E.s] = true;\n            bool flg = true;\n            for(int i = 1;i < E.s.length();i++){\n                if(E.s[i] != E.s[0])flg = false;\n            }\n            if(flg){\n                cout<<E.t<<endl;\n                goto e;\n            }\n            for(int i = 0;i < E.s.length()-1;i++){\n                Data D = E;\n                if(D.s[i]!=D.s[i+1]){\n                    bool flg[3]={};\n                    string w = \"rgb\";\n                    if(D.s[i]=='r'||D.s[i+1]=='r')flg[0] = true;\n                    if(D.s[i]=='g'||D.s[i+1]=='g')flg[1] = true;\n                    if(D.s[i]=='b'||D.s[i+1]=='b')flg[2] = true;\n                    for(int j = 0;j < 3;j++){\n                        if(!flg[j])D.s[i] = D.s[i+1] = w[j];\n                    }\n                    D.t++;\n                    //cout<<D.s<<endl;\n                    Q.push(D);\n                }\n            }\n        }\n        cout<<\"NA\"<<endl;\n        e:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    que.push(pair<string, int>(worm, 0));\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        string worm1 = que.front().first;\n        int num = que.front().second;\n        que.pop();\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        if(num > 10){\n            return -1;\n        }\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            string tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define MAX_v 100\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<string,int> P;\nint main(){\n\tstring s;\n\twhile(cin >> s , s!=\"0\"){\n\t\tint len = s.size();\n\t\tint check = -1;\n\t\tqueue<P> Q;\n\t\tQ.push(P(s,0));\n\t\tvector<string> vis;\n\t\twhile( Q.size() ){\n\t\t\tP p = Q.front();Q.pop();\n\t\t\tstring tmp = p.first;\n\t\t\tstring k = p.first;\n\t\t\t//cout << \"D:\" << tmp << endl;\n\t\t\tbool f = false;\n\t\t\trep(i,len-1){\n\t\t\t\tif(tmp[i] != tmp[i+1]){f = true;break;}\n\t\t\t}\n\t\t\tif(!f){check = p.second;break;}\n\t\t\tif(find(vis.begin(),vis.end(),tmp) != vis.end())continue;\n\t\t\tvis.push_back(tmp);\n\t\t\trep(i,len-1){\n\t\t\t\tif(tmp[i] < tmp[i+1]){\n\t\t\t\t\tswap(k[i],k[i+1]);\n\t\t\t\t}\n\t\t\t\tif(k[i]=='r'&&k[i+1]=='g'){k[i]=k[i+1]='b';Q.push(P(k,p.second+1));}\n\t\t\t\telse if(k[i]=='r'&&k[i+1]=='b'){k[i]=k[i+1]='g';Q.push(P(k,p.second+1));}\n\t\t\t\telse if(k[i]=='g'&&k[i+1]=='b'){k[i]=k[i+1]='r';Q.push(P(k,p.second+1));}\n\t\t\t\tk = p.first;\n\t\t\t}\n\t\t}\n\t\t(check != -1) ? printf(\"%d\\n\",check) : puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<string, int>;\n\nint main() {\n  map<char, int> rbg;\n  rbg['r'] = 0;\n  rbg['b'] = 1;\n  rbg['g'] = 2;\n\n  string s;\n  while (cin >> s && s[0] != '0') {\n    int len = s.length();\n    vector<string> goal(3);\n    for (int i = 0; i < 3; ++i) {\n      goal[i] = string(len, \"rbg\"[i]);\n    }\n\n    auto check = [&](string s) {\n      for (int i = 0; i < 3; ++i) {\n        if (goal[i] == s) return true;\n      }\n      return false;\n    };\n    int ans;\n    bool ok = true;\n    queue<P, deque<P>> que;\n    map<string, bool> mp = {{s, true}};\n\n    que.push({s, 0});\n    while (ok) {\n      tie(s, ans) = que.front(); que.pop();\n      if (check(s)) break;\n\n      for (int i = 0; i < len - 1; ++i) {\n        if (s[i] == s[i + 1]) continue;\n        string nxt = s;\n        int n = 3 - rbg[s[i]] - rbg[s[i + 1]];\n        nxt[i] = nxt[i + 1] = \"rbg\"[n];\n        if (!mp[nxt]) {\n          que.push({nxt, ans + 1});\n          mp[nxt] = true;\n        }\n      }\n      if (que.empty()) ok = false;\n    }\n    cout << ( (ok) ? to_string(ans) : \"NA\" ) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s) {\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\n\n\twhile (!q.empty()) {\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif(m[p.first]) continue;\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tm[p.first] = p.second;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\t\t\t\ttemp = color(now[i], now[i + 1]);\n\t\t\t\tnext = now;\n\t\t\t\tnext[i] = next[i + 1] = temp;\n\t\t\t\tq.push(P(next, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\n//????????????????????????????????????\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\n//??£?????????2?????????????????§?????????????????????\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s ){\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\t//?????\\??????????????¶????????\\??????\n\tif(m[p.first]) continue;\n\n\twhile (!q.empty()) {\t//?????\\??????????????¶?????????????????§\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\t//??£?????????2????????°????????¨???\n\t\t\t\tchar tmp = color(now[i], now[i + 1]);\n\t\t\t\tstring D = now;\n\t\t\t\tD[i] = tmp;\n\t\t\t\tD[i + 1] = tmp;\n\t\t\t\tq.push(P(D, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n\nstruct Worm {\n\tstd::string body;\n\tint step;\n\tWorm() {}\n\tWorm(std::string body, int step) : body(body), step(step) {}\n};\n\nbool meetColor(std::string body)\n{\n\tchar c = body[0];\n\tfor (int i=1; i<body.length(); i++) {\n\t\tif (body[i] != c) return false;\n\t}\n\treturn true;\n}\n\nint getMinStep(std::queue<Worm> que, std::set<std::string>& checked)\n{\n\twhile (!que.empty()) {\n\t\tWorm worm = que.front(); que.pop();\n\t\tif (meetColor(worm.body)) return worm.step;\n\t\tif (checked.find(worm.body) != checked.end()) continue;\n\t\tchecked.insert(worm.body);\n\t\tfor (int i=0; i<worm.body.length()-1; i++) {\n\t\t\tif (worm.body[i] == worm.body[i+1]) continue;\n\t\t\tstd::string new_body = worm.body;\n\t\t\tif (new_body[i] == 'r' && new_body[i+1] == 'g') new_body[i] = new_body[i+1] = 'b';\n\t\t\telse if (new_body[i] == 'r' && new_body[i+1] == 'b') new_body[i] = new_body[i+1] = 'g';\n\t\t\telse if (new_body[i] == 'g' && new_body[i+1] == 'r') new_body[i] = new_body[i+1] = 'b';\n\t\t\telse if (new_body[i] == 'g' && new_body[i+1] == 'b') new_body[i] = new_body[i+1] = 'r';\n\t\t\telse if (new_body[i] == 'b' && new_body[i+1] == 'r') new_body[i] = new_body[i+1] = 'g';\n\t\t\telse new_body[i] = new_body[i+1] = 'r';\n\t\t\tque.push(Worm(new_body, worm.step+1));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tstd::string worm;\n\twhile (true) {\n\t\tstd::cin >> worm;\n\t\tif (worm==\"0\") break;\n\t\tstd::queue<Worm> que;\n\t\tque.push(Worm(worm,0));\n\t\tstd::set<std::string> checked;\n\t\tint res = getMinStep(que, checked);\n\t\tif (res >= 0) std::cout << res << std::endl;\n\t\telse std::cout << \"NA\" << std::endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nclass S{\n\tpublic:\n\t\n\tstring a;\n\tint b;\n\t\n\tS(){}\n\tS(string a,int b):a(a),b(b){}\n};\n\n\nchar nn[333][333];\n\nint main(){\n\t\n\tnn['r']['g']='b';\n\tnn['g']['r']='b';\n\t\n\tnn['g']['b']='r';\n\tnn['b']['g']='r';\n\t\n\tnn['b']['r']='g';\n\tnn['r']['b']='g';\n\t\n\twhile(1){\n\t\tstring a;\n\t\tcin>>a;\n\t\t\n\t\tif(a==\"0\")break;\n\t\t\n\t\tmap<string,int> ch;\n\t\t\n\t\tqueue<S> que;\n\t\tque.push(S(a,0));\n\t\t\n\t\twhile(1){\n\t\t\tif(que.empty()){\n\t\t\t\tcout<<\"NA\"<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tS u = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(ch[u.a]==1)continue;\n\t\t\tch[u.a]=1;\n\t\t\t\n\t\t\tint flg=1;\n\t\t\trep(i,u.a.size()-1){\n\t\t\t\tif(u.a[i] != u.a[i+1]){\n\t\t\t\t\tflg=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg==1){\n\t\t\t\tcout<<u.b<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,u.a.size()-1){\n\t\t\t\tif(u.a[i]!=u.a[i+1]){\n\t\t\t\t\tstring b = u.a;\n\t\t\t\t\tb[i] = nn[u.a[i]][u.a[i+1]];\n\t\t\t\t\tb[i+1] = nn[u.a[i]][u.a[i+1]];\n\t\t\t\t\t\n\t\t\t\t\tque.push(S(b,u.b+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint solve(string s)\n{\n    map<string, bool> mem;\n    queue<pair<string, int> > q;\n\n    q.push(pair<string, int>(s, 0));\n    mem[s] = true;\n\n    while (!q.empty()) {\n        pair<string, int> tmp;\n        bool flag = true;\n\n        tmp = q.front();\n        q.pop();\n\n        // Check\n        for (int i = 1; i < tmp.first.size(); i++)\n            if (tmp.first[0] != tmp.first[i]) {\n                flag = false;\n                break;\n            }\n        if (flag) \n            return tmp.second;\n\n        for (int i = 0; i < tmp.first.size() - 1; i++) {\n            if (tmp.first[i] != tmp.first[i + 1]) {\n                string str = tmp.first;\n                int num = (int)(tmp.first[i] + tmp.first[i + 1]);\n\n                if (num == 217) \n                    str[i] = str[i + 1] = 'b';\n                else if (num == 212) \n                    str[i] = str[i + 1] = 'g';\n                else if (num == 201) \n                    str[i] = str[i + 1] = 'r';\n\n                if (mem.count(str) == 0) {\n                    q.push(pair<string, int>(str, tmp.second + 1));\n                    mem[str] = true;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    string inp;\n\n    while (cin >> inp, inp != \"0\") {\n        int num = solve(inp);\n\n        if (num >= 0)\n            cout << num << endl;\n        else \n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint que[60000][10],flg[1050000];\nint main(void){\n\tint p1,p2,i,j,len,time[60000],copy[10],f,x,ans,iro;\n\tchar ca[11];\n\twhile(1){\n\t\tcin>>ca;\n\t\tif(ca[0]=='0') break;\n\t\tlen=strlen(ca);\n\t\tfor(i=0;i<len;i++){\n\t\t\tif(ca[i]=='r') que[0][i]=0;\n\t\t\tif(ca[i]=='g') que[0][i]=1;\n\t\t\tif(ca[i]=='b') que[0][i]=2;\n\t\t}\n\t\tfor(i=0;i<=1050000;i++) flg[i]=0;\n\t\tp1=0; p2=1; time[0]=0; ans=-1;\n\t\twhile(1){\n\t\t\tif(p1==p2){\n//\t\t\t\tcout<<p1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n/*\t\t\tcout<<p1<<' ';\n\t\t\tfor(i=0;i<len;i++) cout<<que[p1][i];\n\t\t\tcout<<' '<<time[p1]<<endl;*/\n\t\t\tf=1;\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tif(que[p1][i]!=que[p1][i+1]){\n\t\t\t\t\tf=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==1){\n\t\t\t\tans=time[p1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tfor(j=0;j<len;j++) copy[j]=que[p1][j];\n\t\t\t\tif(copy[i]!=copy[i+1]){\n\t\t\t\t\tiro=copy[i]+copy[i+1];\n\t\t\t\t\tif(iro==3){\n\t\t\t\t\t\tcopy[i]=0; copy[i+1]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==2){\n\t\t\t\t\t\tcopy[i]=1; copy[i+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==1){\n\t\t\t\t\t\tcopy[i]=2; copy[i+1]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=copy[0];\n\t\t\t\tfor(j=1;j<len;j++) x=x*4+copy[j];\n\t\t\t\tif(flg[x]==0){\n\t\t\t\t\tflg[x]=1; time[p2]=time[p1]+1;\n\t\t\t\t\tfor(j=0;j<len;j++) que[p2][j]=copy[j];\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1++;\n\t\t}\n\t\tif(ans==-1) cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<string, int> P;\nint main() {\n    string w;\n    while (cin>>w) {\n        if (w==\"0\") break;\n        queue<P> que;\n        que.push(P(w,0));\n        int res=-1;\n        set<string> done;\n        while (!que.empty()) {\n            P p=que.front(); que.pop();\n            char f=p.first[0]; bool flag=true;\n            for (int i=1; i<p.first.length(); i++) if (p.first[i]!=f) {\n                flag=false;\n                break;\n            }\n            if (flag) {\n                res=p.second;\n                break;\n            }\n            for (int i=0; i<p.first.length()-1; i++) {\n                if (p.first[i]!=p.first[i+1]) {\n                    string temp=p.first;\n                    if (temp[i]!='r'&&temp[i+1]!='r') {\n                        temp[i]='r'; temp[i+1]='r';\n                    } else if (temp[i]!='g'&&temp[i+1]!='g') {\n                        temp[i]='g'; temp[i+1]='g';\n                    } else if (temp[i]!='b'&&temp[i+1]!='b') {\n                        temp[i]='b'; temp[i+1]='b';\n                    }\n                    if (done.count(temp)==0) {\n                        que.push(P(temp,p.second+1));\n                        done.insert(temp);\n                    }\n                }\n            }\n        }\n        if (res==-1) puts(\"NA\");\n        else printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tstring s;\n\tchar c[] = { \"rgb\" };\n\n\twhile( cin >> s && s != \"0\" ){\n\t\tset< string > memo;\n\t\tvector< string > sample;\n\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\tsample.push_back( string( s.size(), c[ i ] ) );\n\t\t}\n\n\t\tqueue< string > pattern;\n\t\tpattern.push( s );\n\t\tint sec = 0;\n\t\tbool found = false;\n\t\twhile( !pattern.empty() ){\n\t\t\tint size = pattern.size();\n\t\t\twhile( size > 0 ){\n\t\t\t\tstring p = pattern.front();\n\t\t\t\tpattern.pop();\n\t\t\t\tif( memo.find( p ) != memo.end() ){\n\t\t\t\t\t--size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemo.insert( p );\n\t\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\t\tif( p == sample[ i ] ){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( found ) break;\n\n\t\t\t\tfor( int i = 0; i < (int)p.size() - 1; ++i ){\n\t\t\t\t\tif( p[ i ] == p[ i + 1 ] ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint oo = p[ i ] + p[ i + 1 ];\n\t\t\t\t\tchar color;\n\t\t\t\t\tswitch( oo ){\n\t\t\t\t\t\tcase 'r' + 'g': color = 'b'; break;\n\t\t\t\t\t\tcase 'g' + 'b': color = 'r'; break;\n\t\t\t\t\t\tcase 'b' + 'r': color = 'g'; break;\n\t\t\t\t\t}\n\t\t\t\t\tstring cpy = p;\n\t\t\t\t\tcpy[ i ] = cpy[ i + 1 ] = color;\n\t\t\t\t\tpattern.push( cpy );\n\t\t\t\t}\n\t\t\t\t--size;\n\t\t\t}\n\t\t\tif( found ) break;\n\t\t\t++sec;\n\t\t}\n\t\tif( found ){\n\t\t\tcout << sec << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nint main()\n{\n\tstring s;\n\twhile (cin >> s, s[0] != '0') {\n\t\tmap<string, bool> m;\n\n\t\tqueue<string> q, r;\n\n\t\tq.push(s);\n\n\t\tint cnt = 0;\n\n\t\twhile (q.size()) {\n\t\t\twhile (q.size()) {\n\t\t\t\tstring t = q.front(); q.pop();\n\t\t\t\tif (m[t]) continue;\n\t\t\t\tm[t] = true;\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int i = 0; i < t.size() - 1; ++i) {\n\t\t\t\t\tif ((t[i] == 'r' && t[i + 1] == 'b') || (t[i] == 'b' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'g';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'b' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'b')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'r';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'r' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'b';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tcout << cnt << endl;\n\t\t\t\t\tgoto nxt;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (r.size()) {\n\t\t\t\tstring t = r.front(); r.pop();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\tcout << \"NA\" << endl;\nnxt:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <string, int> P;\n\n#define mp(a, b) make_pair(a, b)\n\nchar diff(char a, char b)\n{\n\tif (a != 'r' && b != 'r') return 'r';\n\tif (a != 'g' && b != 'g') return 'g';\n\tif (a != 'b' && b != 'b') return 'b';\n\treturn 'a';\n}\n\nbool check(string str)\n{\n\tchar c = str[0];\n\tfor (int i = 0; i < str.length(); i++){\n\t\tif (c != str[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tstring str;\n\n\twhile (cin >> str){\n\t\tif (str == \"0\") return 0;\n\n\t\tint ret = -1, a;\n\t\tqueue < P > q;\n\t\tq.push(mp(str, 0));\n\t\twhile (!q.empty()){\n\t\t\tP now = q.front();\n\t\t\tq.pop();\n\t\t\tif (check(now.first)){\n\t\t\t\tret = now.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (q.size() > 500000){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < now.first.length()-1; i++){\n\t\t\t\tif (now.first[i] != now.first[i + 1]){\n\t\t\t\t\tstring tmp = now.first;\n\t\t\t\t\ttmp[i] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\ttmp[i + 1] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\tq.push(mp(tmp, now.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret >= 0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s==\"0\")break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(!q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }else if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp.count(y)==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(!f)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n\nusing namespace std;\n\nint main(void){\n  string s;\n  while(cin>>s){\n    set<string> se;\n    queue<pair<string,int> > q;\n    se.insert(s);\n    q.push(make_pair(s,0));\n    int cnt = 10;\n    char a[3] = {'r','g','b'};\n    string ans[3];\n    rep(i,3){\n      rep(j,s.size()){\n        ans[i] += a[i];\n      }\n      //cout<<ans[i]<<endl;\n    }\n    bool find = true;\n    while(true){\n      if(q.size()==0)break;\n  //    cout<<q.front().first<<\" \"<<q.front().second<<endl;\n      pair<string,int> qq = q.front(); q.pop();\n      string ss = qq.first;\n      int n = qq.second;\n      if(ss.size()==s.size()+2 ){\n        break;\n      }\n      cnt ++;\n      bool f = false;\n      rep(i,3){\n        if(ans[i] == ss){\n          f = true;\n          find = false;\n          break;\n        }\n      }\n      if(f)break;\n      n++;\n      rep(i,ss.size()-1){\n        if(ss[i] != ss[i+1]){\n          if((ss[i] == a[0] && ss[i+1] == a[1]) || (ss[i] == a[1] && ss[i+1] == a[0])){\n            string word = ss.substr(0,i) + a[2] + a[2] + ss.substr(i+2,ss.size()-i+2);\n            if(se.find(word) != se.end())continue;\n            se.insert(word);\n            q.push(make_pair(word,n));\n            se.insert(word);\n          }\n          if((ss[i] == a[0] && ss[i+1] == a[2]) || (ss[i] == a[2] && ss[i+1] == a[0])){\n            string word = ss.substr(0,i) + a[1] + a[1] + ss.substr(i+2,ss.size()-i+2);\n            if(se.find(word) != se.end())continue;\n            se.insert(word);\n            q.push(make_pair(word,n));\n            se.insert(word);\n          }\n          if((ss[i] == a[2] && ss[i+1] == a[1]) || (ss[i] == a[1] && ss[i+1] == a[2])){\n            string word = ss.substr(0,i) + a[0] + a[0] + ss.substr(i+2,ss.size()-i+2);\n            if(se.find(word) != se.end())continue;\n            se.insert(word);\n            q.push(make_pair(word,n));\n            se.insert(word);\n          }\n        }\n      }\n    }\n    if(find)cout<<\"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <climits>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\nstring s;\nstring qf;\n/*\nint foo1(int D[]){\n\tint res=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tres*=10;\n\t\tres+=D[i];\n\t}\n\treturn res;\n}\nvoid foo2(int D[],int m){\n\trep(j,s.size()){\n\t\tD[j]=0;\n\t}\n\tfor(int i=s.size()-1;i>=0;--i){\n\t\tD[i]=m%10;\n\t\tm/=10;\n\t\trep(j,s.size()){\n\t\t}\n\t}\n}\n*/\nset<string> vis;\n\nbool check(string a){\n\tchar t=a[0];\n\trep(i,s.size()){\n\t\tif(t!=a[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=-1;\n\t\tqueue<string> qu;\n\t\tif(check(s)){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvis.insert(s);\n\t\tqu.push(s);\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\t//int c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\t//c++;\n\t\t\t//if(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\t//cout<<qf<<endl;\n\t\t\t\tqu.pop();\n\t\t\t\tif(check(qf)){\n\t\t\t\t\tcout<<ans<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(qf[j]!=qf[j+1]){\n\t\t\t\t\t\tstring tmp=qf;\n\t\t\t\t\t\ttmp[j] = tmp[j+1] = 'r'+'g'+'b'-qf[j]-qf[j+1];\n\t\t\t\t\t\tif(vis.find(tmp)==vis.end()){\n\t\t\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\t\tvis.insert(tmp);\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n\n/*\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=0;\n\t\tqueue<int> qu;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='r') a[i]=0;\n\t\t\telse if(s[i]=='g') a[i]=1;\n\t\t\telse if(s[i]=='b') a[i]=2;\n\t\t}\n\t\tif(check()){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqu.push(foo1(a));\n\t\tvis.insert(foo1(a));\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\t//int c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\t//c++;\n\t\t\t//if(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\tfoo2(a,qf);\n\t\t\t\tif(check()){\n\t\t\t\t\tcout<<ans-1<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(a[j]!=a[j+1]){\n\t\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\t\ttmp[k]=a[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[j]*a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=0;\n\t\t\t\t\t\t\ttmp[j+1]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(a[j]==2||a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=1;\n\t\t\t\t\t\t\ttmp[j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttmp[j]=2;\n\t\t\t\t\t\t\ttmp[j+1]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(vis.find(foo1(tmp))==vis.end()){\n\t\t\t\t\t\t\tqu.push(foo1(tmp));\n\t\t\t\t\t\t\tvis.insert(foo1(tmp));\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\nqueue<int> q;\nint t[59049];\nint INF=100000;\nint encode(vector<int> vc){\n\tint p=0;\n\tfor(int i=0;i<vc.size();i++){\n\t\tp=p*3+vc[i];\n\t}\n\treturn p;\n}\nvector<int> decode(int p,int n){\n\tvector<int> vc(n);\n\tfor(int i=0;i<n;i++){\n\t\tvc[n-i-1]=p%3;\n\t\tp/=3;\n\t}\n\treturn vc;\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<59049;i++) t[i]=INF;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint n=s.size(),start=0,goal=1;\n\t\tfor(int i=0;i<n;i++) goal*=3;\n\t\tgoal-=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(s[i]=='r') start=start*3+2;\n\t\t\tif(s[i]=='g') start=start*3+1;\n\t\t\tif(s[i]=='b') start=start*3;\n\t\t}\n\t\tq.push(start);\n\t\tt[start]=0;\n\t\tint ok=-1;\n\t\twhile(q.size()){\n\t\t\tint p=q.front();\n\t\t\tif(p==0 || p==goal/2 || p==goal){\n\t\t\t\tok=p;\n\t\t\t\twhile(q.size()) q.pop(); \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t\tvector<int> vc=decode(p,n);\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tif(vc[i]==vc[i+1]) continue;\n\t\t\t\tvector<int> vc_c=vc;\n\t\t\t\tvc_c[i]=vc_c[i+1]=((vc[i]+vc[i+1])*2)%3;\n\t\t\t\tint hoge=encode(vc_c);\n\t\t\t\tif(t[hoge]!=INF) continue;\n\t\t\t\tq.push(hoge);\n\t\t\t\tt[hoge]=t[p]+1;\n\t\t\t}\n\t\t}\n\t\tif(ok==-1) cout << \"NA\" << endl;\n\t\telse cout << t[ok] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nstring rgb = \"rgb\";\nint tab[300];\nint n;\n\nint encode(string s){\n  int ret = 0;\n  for(int i=0; i<n; i++){\n    ret *= 3;\n    ret += tab[s[i]];\n  }\n  return ret;\n}\n\nstring decode(int c){\n  string s = \"\";\n  for(int i=0; i<n; i++){\n    s = rgb[c%3] + s;\n    c /= 3;\n  }\n  return s;\n}\n\n\nint main(){\n  int q[100000];\n  int memo[100000];\n  tab['r'] = 0;\n  tab['g'] = 1;\n  tab['b'] = 2;\n  \n  for(;;){\n    for(int i=0; i<100000; i++){\n      memo[i] = -1;\n    }\n    string s;\n    cin >> s;\n    if(s[0]=='0') break;\n    n = s.length();\n    \n    int ql = 0;\n    int qr = 1;\n    q[0] = encode(s);\n    memo[encode(s)] = 0;\n    \n    int found = 0;\n    while(qr-ql>0){\n      int c = q[ql];\n      string s = decode(c);\n//      cout << s << endl;\n      int ok = 1;\n      for(int i=0; i<n-1; i++){\n        if(s[i]!=s[i+1]){\n          ok = 0;\n          break;\n        }\n      }\n      if(ok){\n        found = 1;\n        cout << memo[c] << endl;\n        break;\n      }\n      \n      for(int i=0; i<n-1; i++){\n        if(s[i]!=s[i+1]){\n          string ns = s;\n          if('r'!=s[i] && 'r'!=s[i+1]){\n            ns[i] = 'r';\n            ns[i+1] = 'r';\n          }\n          if('g'!=s[i] && 'g'!=s[i+1]){\n            ns[i] = 'g';\n            ns[i+1] = 'g';\n          }\n          if('b'!=s[i] && 'b'!=s[i+1]){\n            ns[i] = 'b';\n            ns[i+1] = 'b';\n          }\n          int nc = encode(ns);\n          if(memo[nc]==-1){\n            memo[nc] = memo[c]+1;\n            q[qr] = nc;\n            qr++;\n          }\n        }\n      }\n      \n      ql++;\n      \n    }\n    if(found==0){\n      cout << \"NA\" << endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cnt,ccnt = 0;\nint len;\nstring s, ss, tmp;\nint flag = 0;\nchar c;\npair<string,int> ps;\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tlen = s.length();\n\t\tqueue<pair<string,int> > qq;\n\t\tqq.push(make_pair(s,0));\n\t\twhile (!qq.empty()) {\n\t\t\tps = qq.front();\n\t\t\tqq.pop();\n\t\t\tc = ps.first[0];\n\t\t\tccnt=ps.second;\n\t\t\tflag = 0;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tif (c != ps.first[i]) {\n\t\t\t\t\t//cout<<ps.first[i]<<endl;//deb\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\t//cout<<ps.first<<endl;//deb\n\t\t\t\tif(ccnt>8){cout<<\"NA\"<<endl;break;}\n\n\t\t\t\tfor (int i = 0; i < len - 1; ++i) {\n\t\t\t\t\ttmp = ps.first;\n\t\t\t\t\tif (ps.first[i] != ps.first[i+1]) {\n\t\t\t\t\t\tif (ps.first[i] != 'r' && ps.first[i+1] != 'r') {\n\t\t\t\t\t\t\ttmp[i] = 'r';\n\t\t\t\t\t\t\ttmp[i + 1] = 'r';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'g' && ps.first[i+1] != 'g' ){\n\t\t\t\t\t\t\ttmp[i] = 'g';\n\t\t\t\t\t\t\ttmp[i + 1] = 'g';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'b' && ps.first[i+1] != 'b') {\n\t\t\t\t\t\t\ttmp[i] = 'b';\n\t\t\t\t\t\t\ttmp[i + 1] = 'b';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcout << ccnt << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nstring s, ans[3];\nset<string> ses;\nint res;\n\nvector<string> change(string s){\n\tvector<string> vs;\n\tstring t;\n\tREP(i, t.size() - 1){\n\t\tt = s;\n\t\tif (t[i] != t[i + 1]){\n\t\t\tif (t[i] == 'r'){\n\t\t\t\tif (t[i + 1] == 'g') t[i] = t[i + 1] = 'b';\n\t\t\t\telse t[i] = t[i + 1] = 'g';\n\t\t\t}\n\t\t\telse if (t[i] == 'g'){\n\t\t\t\tif (t[i + 1] == 'r')t[i] = t[i + 1] = 'b';\n\t\t\t\telse t[i] = t[i + 1] = 'r';\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (t[i + 1] == 'r')t[i] = t[i + 1] = 'g';\n\t\t\t\telse t[i] = t[i + 1] = 'r';\n\t\t\t}\n\t\t\tif (ses.find(t) == ses.end()){\n\t\t\t\tses.insert(t);\n\t\t\t\tvs.push_back(t);\n\t\t\t}\n\t\t}\n\t}\n\treturn vs;\n}\n\nvoid solve(string s){\n\tbool f = 1;\n\tqueue<string> que;\n\n\tque.push(s);\n\tses.insert(s);\n\n\tint k = que.size(), co = -1;\n\n\tfor (int j = 0; j < k;j++){\n\t\tvector<string> vs;\n\t\tstring t = que.front();\n\n\t\t//cout << \"!\" << t << endl;\n\t\t//if (f){\n\t\t//\tcout << \"!\";\n\t\t//\tREP(i, 3){\n\t\t//\t\tif (t == ans[i]){\n\t\t//\t\t\tcout << \"!\";\n\t\t//\t\t\tcout << t << endl;\n\t\t//\t\t\tf = 0;\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\n\t\t//cout << t << endl;\n\t\t//cout << \"res ; \" << res << endl;\n\t\t//cout << \"j : \" << j << endl;\n\n\t\tque.pop();\n\t\tvs = change(t);\n\t\tREP(i, vs.size()){\n\t\t\tque.push(vs[i]);\n\t\t\t/*cout << vs[i] << \" \";*/\n\t\t}\n\t\t//cout << endl;\n\n\t\tif (j == k - 1){\n\t\t\tj = -1;\n\t\t\tk = que.size();\n\t\t\tres++;\n\t\t}\n\t\t/*cout << res << endl;*/\n\n\t\tif (f){\n\t\t\tREP(i, 3){\n\t\t\t\tif (find(ALL(vs), ans[i]) != vs.end()){\n\t\t\t\t\t//cout << \"!\";\n\t\t\t\t\t//cout << t << endl;\n\t\t\t\t\t//cout << \"!\";\n\t\t\t\t\tif (res == 1) cout << res << endl;\n\t\t\t\t\telse cout << res + 1 << endl;\n\t\t\t\t\t\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f)break;\n\t}\n\n\tif (f)cout << \"NA\" << endl;\n}\n\nint main(){\n\twhile (cin >> s){\n\t\tif (s == \"0\")break;\n\t\tans[0] = ans[1] = ans[2] = \"\";\n\t\tREP(i, s.size()){\n\t\t\tans[0] += 'r';\n\t\t\tans[1] += 'g';\n\t\t\tans[2] += 'b';\n\t\t}\n\t\tif (ans[0] == s || ans[1] == s || ans[2] == s){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tres = 0;\n\t\tsolve(s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vvi;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \nstring str;\nbool f(string s){\n\tfor(int i = 1; i <s.size(); i++){\n\t\tif(s[i] != s[i-1]) return false;\n\t}\n\treturn true;\n}\n\nstring calc(int i,string s){\n\tstring ret = s;\n\tif(s[i] != s[i+1]){\n\t\tif((ret[i]=='g' && ret[i+1] == 'r') ||(ret[i]=='r' && ret[i+1] == 'g')) ret[i] = ret[i+1] ='b';\n\t\telse if((ret[i]=='b' && ret[i+1] == 'r') ||(ret[i]=='r' && ret[i+1] == 'b')) ret[i] = ret[i+1] ='g';\n\t\telse if((ret[i]=='g' && ret[i+1] == 'b') ||(ret[i]=='b' && ret[i+1] == 'g')) ret[i] = ret[i+1] ='r';\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>str){\n\t\tif(str == \"0\") break;\n\t\tset<string> s;\n\t\tqueue<pair<string,int> > q;\n\t\tint ans = 0;\n\t\tpair<string,int> p;\n\t\ts.insert(str);\n\t\tq.push(pair<string,int>(str,0));\n\t\tbool flag = false;\n\t\twhile(!q.empty()){\n\t\t\tp = q.front();\n\t\t\tq.pop();\n\t\t\tif(f(p.fi)) {\n\t\t\t\tans = p.se;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i< str.size()-1; i++){\n\t\t\t\tif(!s.count(calc(i,p.fi))){\n\t\t\t\t\tq.push(pair<string,int>(calc(i,p.fi),p.se+1));\n\t\t\t\t\ts.insert(calc(i,p.fi));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) cout<<ans<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool isAns(string s){\n  int len = s.length();\n  FOR(i,1,len){\n    if(s[0] != s[i]) return false;\n  }\n  return true;\n}\n\nchar diffColor(char a, char b){\n  if((a == 'r' && b == 'g') || (a == 'g' && b == 'r')){\n    return 'b';\n  }else if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')){\n    return 'r';\n  }else{\n    return 'g';\n  }\n}\n\nint main(){\n\n  while(true){\n    string s;\n    cin >> s;\n    if(s == \"0\") break;\n\n    map<string, int> mp;\n    mp[s] = 1;\n    queue<string> que;\n\n    que.push(s);\n    bool found = false;\n    while(!que.empty()){\n      s = que.front();\n      que.pop();\n\n      if(isAns(s)){\n        found = true;\n        cout << mp[s] - 1 << \"\\n\";\n        break;\n      }\n\n      int len = s.length();\n      REP(i,len-1){\n        if(s[i] != s[i+1]){\n          string v = s;\n          char tmp = diffColor(s[i], s[i+1]);\n          v[i] = tmp; v[i+1] = tmp;\n          if(mp[v] == 0){\n            mp[v] = mp[s] + 1;\n            que.push(v);\n          }\n        }\n      }\n    }\n    if(!found){\n      cout << \"NA\\n\";\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n#include <map>\n#include <queue>\n#include <utility>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nusing P = pair<string, int>;\n\nchar getLast(char c1, char c2) {\n    if (c1 > c2) swap(c1, c2);\n    if (c1 == 'b' && c2 == 'g') return 'r';\n    if (c1 == 'b' && c2 == 'r') return 'g';\n    return 'b';\n}\n\n#include <set>\nbool check(string s) {\n    set<int> st;\n    for(auto &c: s) {\n        st.insert(c);\n    }\n    return st.size() == 1;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    while (cin >> s, s != \"0\") {\n        map<string, int> mp;\n        int n = s.size();\n        queue<P> q;\n        q.emplace(s, 0);\n        int ans = -1;\n        while (q.size()) {\n            string e = q.front().first;\n            int cnt = q.front().second;\n            q.pop();\n            if (check(e)) {\n                ans = cnt;\n                break;\n            }\n            mp[e] = cnt;\n            REP (i, 0, n - 1) {\n                if (e[i] != e[i + 1]) {\n                    string tmp = e;\n                    tmp[i] = tmp[i + 1] = getLast(e[i], e[i + 1]);\n                    if (mp.count(tmp) == 0) {\n                        q.emplace(tmp, cnt + 1);\n                        mp[tmp] = cnt + 1;\n                    }\n                }\n            }\n        }\n        if (ans == -1) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(char w[11];cin>>w,w[0]!='0';){\n    queue<pair<vector<int>,int> >que;\n    vector<int> in;\n    for(int i=0;w[i];i++){\n      int n=(w[i]=='r')?1:(w[i]=='g')?2:4;\n      in.push_back(n);\n    }\n    que.push(make_pair(in,0));\n    set<vector<int> > s;\n    while(!que.empty()){\n      int c=0;\n      vector<int> v=que.front().first;\n      if(s.find(v)!=s.end()){\n\tque.pop();\n      }else{\n\tfor(int i=0;i<v.size();i++){\n\t  c|=v[i];\n\t}\n\tif((c&(c-1))==0)break;\n\tfor(int i=0;i<v.size()-1;i++){\n\t  vector<int> n=v;\n\t  int nc=7^v[i]^v[i+1];\n\t  n[i]=n[i+1]=nc;\n\t  if(s.find(n)==s.end()){\n\t    que.push(make_pair(n,que.front().second+1));\n\t  }\n\t}\n\tque.pop();\n      }\n    }\n    if(que.empty()){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().second<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\nchar kagasan(char A,char B){\n\tif(A=='r'&&B=='g')return 'b';\n\tif(A=='r'&&B=='b')return 'g';\n\tif(A=='g'&&B=='r')return 'b';\n\tif(A=='g'&&B=='b')return 'r';\n\tif(A=='b'&&B=='g')return 'r';\n\tif(A=='b'&&B=='r')return 'g';\n}\n\nint main(){\n\tstring STR;\n\twhile(cin>>STR){\n\t\tif(STR==\"0\")break;\n\t\tmap<string,int>time;\n\t\tqueue<string>name;\n\t\tname.push(STR);\n\t\ttime[STR]=1;\n\t\tint flag=1;\n\t\twhile(name.empty()==0){\n\t\t\tint mini=1;\n\t\t\tstring s=name.front();\n\t\t\tfor(int i=0;i<s.size()-1;i++){\n\t\t\t\tif(s[i]!=s[i+1]){\n\t\t\t\t\tmini=0;\n\t\t\t\t\tstring ka=s;\n\t\t\t\t\tka[i]=kagasan(s[i],s[i+1]);\n\t\t\t\t\tka[i+1]=kagasan(s[i],s[i+1]);\n\t\t\t\t\tif(time[ka]==0){\n\t\t\t\t\t\ttime[ka]=time[s]+1;\n\t\t\t\t\t\tname.push(ka);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mini){\n\t\t\t\tcout<<time[name.front()]-1<<endl;\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tname.pop();\n\t\t}\n\t\tif(flag)cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vvi;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \nstring str;\nbool f(string s){\n\tfor(int i = 1; i <s.size(); i++){\n\t\tif(s[i] != s[i-1]) return false;\n\t}\n\treturn true;\n}\n\nstring calc(int i,string s){\n\tstring ret = s;\n\tif(s[i] != s[i+1]){\n\t\tif((ret[i]=='g' && ret[i+1] == 'r') ||(ret[i]=='r' && ret[i+1] == 'g')) ret[i] = ret[i+1] ='b';\n\t\telse if((ret[i]=='b' && ret[i+1] == 'r') ||(ret[i]=='r' && ret[i+1] == 'b')) ret[i] = ret[i+1] ='g';\n\t\telse if((ret[i]=='g' && ret[i+1] == 'b') ||(ret[i]=='b' && ret[i+1] == 'g')) ret[i] = ret[i+1] ='r';\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>str){\n\t\tif(str == \"0\") break;\n\t\tset<string> s;\n\t\tqueue<pair<string,int> > q;\n\t\tint ans = 0;\n\t\tbool flag = false;\n\t\tpair<string,int> p;\n\t\ts.insert(str);\n\t\tq.push(pair<string,int>(str,0));\n\t\twhile(!q.empty()){\n\t\t\tp = q.front();\n\t\t\tq.pop();\n\t\t\tif(f(p.fi)) {\n\t\t\t\tans = p.se;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i< str.size()-1; i++){\n\t\t\t\tif(!s.count(calc(i,p.fi))){\n\t\t\t\t\tq.push(pair<string,int>(calc(i,p.fi),p.se+1));\n\t\t\t\t\ts.insert(calc(i,p.fi));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) cout<<ans<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n\ntypedef pair<string ,int> P;\n\nint bfs(string str)\n{\n\tmap<string, int> m;\n\tqueue<P> que;\n\tque.push(P(str,1));\n\twhile(!que.empty())\n\t{\n\t\tP p = que.front();que.pop();\n\t\tif(m[p.first]) continue;//すでに数字が存在するときはやりなおし\n\t\tbool flag=true;\n\t\tfor(int i=0;i<p.first.size()-1;++i){\n\t\t\tif(p.first[i] != p.first[i+1])\n\t\t\t\tflag = false;\n\t\t}\n\t\tif(flag) return p.second-1;\n\t\tm[p.first] = p.second;//重複をなくす\n\t\tfor(int i=0;i<str.size()-1;++i){\n\t\t\tchar c;\n\t\t\tif(p.first[i] == p.first[i+1])\n\t\t\t\tcontinue;\n\t\t\tif(p.first[i] != 'r' && p.first[i+1] != 'r')\n\t\t\t\tc = 'r';\n\t\t\tif(p.first[i] != 'g' && p.first[i+1] != 'g')\n\t\t\t\tc = 'g';\n\t\t\tif(p.first[i] != 'b' && p.first[i+1] != 'b')\n\t\t\t\tc = 'b';\n\t\t\tstring next = p.first;\n\t\t\tnext[i] = next[i+1] = c;\n\t\t\tque.push(P(next,p.second+1));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str[0] == '0')\n\t\t\treturn 0;\n\t\tint res = bfs(str);\n\t\tif(res >= 0)\n\t\t\tcout << res << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n\nusing namespace std;\n\ntypedef pair <string,int> P;\n\nint ans;\nstring str;\n\nbool f(string s){\n\tfor (int i=1; i<s.size(); i++) {\n\t\tif (s[0]!=s[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar c(char a,char b){\n\tif (a=='r'&&b=='g'||a=='g'&&b=='r') {\n\t\treturn 'b';\n\t}\n\telse if (a=='r'&&b=='b'||a=='b'&&b=='r') {\n\t\treturn 'g';\n\t}\n\telse {\n\t\treturn 'r';\n\t}\n}\n\n\nbool bfs(){\n\tqueue<P> que;\n\tmap<string,int> mat;\n\tque.push(P(str,0));\n\twhile (que.size()) {\n\t\tP p=que.front();\n\t\tque.pop();\n\t\t\n\t\tstring s=p.first;\n\t\tint n=p.second+1;\n\t\tif (mat[s]) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (f(s)) {\n\t\t\tans=n-1;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tmat[s]=n;\n\t\t\n\t\tfor (int i=0; i<s.size()-1; i++) {\n\t\t\tif (s[i]!=s[i+1]) {\n\t\t\t\tstring t=s;\n\t\t\t\tchar u=c(t[i],t[i+1]);\n\t\t\t\tt[i]=t[i+1]=u;\n\t\t\t\tque.push(P(t,n));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\treturn false;\n}\n\nint main(){\n\t\n\twhile (cin>>str&&str!=\"0\") {\n\t\tif (bfs()) {\n\t\t\tcout << ans <<endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" <<endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\ntypedef pair<string,int> psi;\n\nchar st[200][200]={0};\n\nint main(void){\n\t\n\tA:;\n\tstring str;\n\tcin>>str;\n\t\n\tif(str==\"0\")return 0;\n\t\n\tqueue<psi> que;\n\tque.push(psi(str,0));\n\t\n\tmap<string,int> memo;\n\t\n\tst['r']['b']='g';\n\tst['b']['r']='g';\n\tst['r']['g']='b';\n\tst['g']['r']='b';\n\tst['g']['b']='r';\n\tst['b']['g']='r';\n\t\n\tint ans = -1;\n\twhile(1){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpsi u = que.front();\n\t\tque.pop();\n\t\t\n\t\tbool flg = true;\n\t\trep(i,u.first.size()-1)if(u.first[i]!=u.first[i+1])flg=false;\n\t\t\n\t\tif(flg){\n\t\t\tans = u.second;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(memo[u.first]==1)continue;\n\t\tmemo[u.first]=1;\n\t\t\n\t\trep(i,u.first.size()-1){\n\t\t\tif(u.first[i] == u.first[i+1])continue;\n\t\t\tstring copy = u.first;\n\t\t\tchar c3 = st[u.first[i]][u.first[i+1]];\n\t\t\tcopy[i] = copy[i+1] = c3;\n\t\t\tque.push(psi(copy,u.second+1));\n\t\t}\n\t}\n\t\n\tif(ans==-1)printf(\"NA\\n\");\n\telse printf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\ntypedef pair<string,int> Psi;\n\nstring in;\n\ninline bool check(const string& str) {\n  rep (i,str.size()) if (str[0] != str[i]) return false;\n  return true;\n}\n\nchar another(const char a, const char b) {\n  static const char cs[3] = { 'r', 'g', 'b' };\n  rep (i,3) if (cs[i] != a && cs[i] != b) return cs[i];\n}\n\nint main() {\n  while (cin >> in) {\n    if (in == \"0\") break;\n    if (check(in)) { cout << 0 << endl; continue; }\n    \n    queue<Psi> q;\n    set<string> s;\n    q.push(make_pair(in, 0));\n\n    int ans = -1;\n    while (!q.empty()) {\n      Psi p = q.front(); q.pop();\n      string str = p.first;\n      \n      if (s.count(str)) continue;\n      s.insert(str);\n      \n      if (check(str)) {\n        ans = p.second;\n        break;\n      }\n      \n      for (int i = 0; i < str.size() - 1; ++i) {\n        if (str[i] != str[i+1]) {\n          string copy = str;\n          char c = another(str[i], str[i+1]);\n          copy[i] = copy[i+1] = c;\n          q.push(make_pair(copy, p.second + 1));\n        }\n      }\n    }\n    \n    \n    if (ans == -1) {\n      cout << \"NA\" <<endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n\n\nint main()\n{\n    map<string, string> ct;\n    ct[\"rr\"] = \"rr\";\n    ct[\"rb\"] = \"gg\";\n    ct[\"rg\"] = \"bb\";\n\n    ct[\"gr\"] = \"bb\";\n    ct[\"gg\"] = \"gg\";\n    ct[\"gb\"] = \"rr\";\n\n    ct[\"br\"] = \"gg\";\n    ct[\"bg\"] = \"rr\";\n    ct[\"bb\"] = \"bb\";\n\n    map<string, bool> dt;\n    dt[\"rr\"] = true;\n    dt[\"gg\"] = true;\n    dt[\"bb\"] = true;\n    \n    for(;;) {\n        string in;\n        cin >> in;\n\n        if ( in == \"0\" )\n            break;\n\n        std::map<string, bool> correct;\n        correct[string(in.size(), 'r')] = true;\n        correct[string(in.size(), 'g')] = true;\n        correct[string(in.size(), 'b')] = true;\n\n        int result_times = 0;\n\n        queue<pair<int, string> > q;\n        q.push( make_pair( 0, in ) );\n\n        map<string, bool> memo;\n        bool goal = false;\n\n        // loop\n        while( !q.empty() ) {\n            int const times = q.front().first;\n            string const s = q.front().second;\n            q.pop();\n\n            //cout << gtimes << endl;\n            if ( correct[s] ) {\n                goal = true;\n                result_times = times;\n                break;\n            } \n\n            //cout << \"---\" << endl;\n            for( size_t i=0; i<s.size()-1; ++i ){\n                string const pa = s.substr( i, 2 );\n                string const t = s.substr( 0, i ) + ct[pa] + s.substr( i + 2 );\n\n                if ( t == s )\n                    continue;\n                if ( memo[t] )\n                    continue;\n\n                memo[t] = true;\n\n                q.push( make_pair( times + 1, t ) );\n                //cout << t << endl;\n            }\n        }\n\n        // put\n        if ( goal ) {\n            cout << result_times << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nint main() {\n  string musi;\n  while(cin >> musi, musi != \"0\") {\n    string tonum;\n    for(int i=0; i<musi.size(); i++) {\n      if(musi[i] == 'r')\n        tonum.push_back('1');\n      if(musi[i] == 'g')\n        tonum.push_back('2');\n      if(musi[i] == 'b')\n        tonum.push_back('3');\n    }\n    queue< pair<string, int> > q;\n    pair<string, int> p;\n    p.first = tonum;\n    p.second = 0;\n    q.push(p);\n    bool flg = true;\n    set<string> memo;\n    int test = 0;\n    while(q.size()) {\n      p = q.front();\n      q.pop();\n      int cnt = 0;\n      for(int i=1; i<p.first.size(); i++) {\n        if(p.first[i-1] != p.first[i]) {\n          pair<string, int> p2;\n          p2 = p;\n          int n = (int)p.first[i-1] + (int)p.first[i] - '0' - '0';\n          if(n==3) {\n            p2.first[i-1] = '3';\n            p2.first[i] = '3';\n          }\n          else if(n==4) {\n            p2.first[i-1] = '2';\n            p2.first[i] = '2';\n          }\n          else if(n==5) {\n            p2.first[i-1] = '1';\n            p2.first[i] = '1';\n          }\n          if(memo.find(p2.first) == memo.end()) {\n            p2.second++;\n            q.push(p2);\n            memo.insert(p2.first);\n          }\n        }\n        else cnt++;\n      }\n      if(cnt == p.first.size()-1) {\n        flg = false;\n        cout << p.second << endl;\n        break;\n      }\n    }\n    if(flg) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nstruct worm{\n\tint c;\n\tstring s;\n};\nqueue<worm> que;\nbool str_check(string str){\n\tfor(int i = 1;i < str.size();++i){\n\t\tif(str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\nint f(){\n\twhile(que.size()){\n\t\tworm w = que.front(),tmp;\n\t\tque.pop();\n\t\tint n = w.c;\n\t\tif(n > 10) break;\n\t\tstring str = w.s;\n\t\tif(str_check(str)){\n\t\t\treturn n;\n\t\t}\n\t\tfor(int i = 0;i < str.size() - 1;++i){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tif((str[i] == 'r' && str[i+1] == 'b') || (str[i] == 'b' && str[i+1] == 'r')){\n\t\t\t\t\tstr[i] = str[i+1] = 'g';\n\t\t\t\t}\n\t\t\t\telse if((str[i] == 'g' && str[i+1] == 'b') || (str[i] == 'b' && str[i+1] == 'g')){\n\t\t\t\t\tstr[i] = str[i+1] = 'r';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[i] = str[i+1] = 'b';\n\t\t\t\t}\n\t\t\t\ttmp.s = str;\n\t\t\t\ttmp.c = n + 1;\n\t\t\t\tque.push(tmp);\n\t\t\t\tstr = w.s;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\tstring str;\n\tworm w;\n\twhile(cin >> str){\n\t\tif(str == \"0\") break;\n\t\tw.s = str;\n\t\tw.c = 0;\n\t\tque.push(w);\n\t\tint n = f();\n\t\tif(n == -1) cout << \"NA\\n\";\n\t\telse cout << n << endl;\n\t\twhile(que.size()){\n\t\t\tque.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s==\"0\")break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(!q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }else if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp[y]==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(!f)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    que.push(pair<string, int>(worm, 0));\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        string worm1 = que.front().first;\n        int num = que.front().second;\n        que.pop();\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            string tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n        if(num > 10000)\n            return -1;\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstatic const char TBL[] = \" rgb\";\n\nunsigned encode(const string& s)\n{\n  unsigned t = 0;\n  for (string::const_iterator it = s.begin(); it != s.end(); ++it) {\n    t <<= 2;\n    switch (*it) {\n      case 'r': t |= 1; break;\n      case 'g': t |= 2; break;\n      case 'b': t |= 3; break;\n      default:  throw __LINE__;\n    }\n  }\n  return t;\n}\n\nstring decode(unsigned t)\n{\n  string s;\n  while (t != 0) {\n    s = TBL[t&3] + s;\n    t >>= 2;\n  }\n  return s;\n}\n\nint bfs(unsigned init)\n{\n  queue<unsigned> q;\n  vector<int> dist(1<<20, 10000000);\n  q.push(init);\n  dist[init] = 0;\n  while (!q.empty()) {\n    const int t = q.front();\n    const string s = decode(t);\n    q.pop();\n    const int d = dist[t];\n    const int N = s.size();\n    if (count(s.begin(), s.end(), s[0]) == N) {\n      return d;\n    }\n    for (int i = 0; i < N-1; i++) {\n      if (s[i] != s[i+1]) {\n        string u = s;\n        for (int j = 1; j <= 3; j++) {\n          if (TBL[j] != s[i] && TBL[j] != s[i+1]) {\n            u[i] = u[i+1] = TBL[j];\n            const unsigned v = encode(u);\n            if (d+1 < dist[v]) {\n              dist[v] = d+1;\n              q.push(v);\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  string s;\n  while (cin >> s && s != \"0\") {\n    const int ans = bfs(encode(s));\n    if (ans < 0) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nint checkTable[59049];\n\nstruct Data{\n\tint number,depth;\n};\n\nint getNum(char ch){\n\tswitch(ch){\n\tcase 'r':return 0;\n\tcase 'g':return 1;\n\tcase 'b':return 2;\n\t}\n\treturn -1; //must not reach here\n}\n\nint getWeight(int w){\n\tswitch(w){\n\tcase 0:return 1;\n\tcase 1:return 3;\n\tcase 2:return 9;\n\tcase 3:return 27;\n\tcase 4:return 81;\n\tcase 5:return 243;\n\tcase 6:return 729;\n\tcase 7:return 2187;\n\tcase 8:return 6561;\n\tcase 9:return 19683;\n\t}\n\treturn -1;\t//must not reach here\n}\n\nint translateData(char table[],int size){\n\tint ret = 0;\n\n\tfor(int i = 0; i < size; i++){\n\t\tret += getNum(table[i])*pow(3,(size-1)-i);\n\t}\n\n\treturn ret;\n}\n\nvoid setData(char warm[],int code,int size){\n\tint tmp;\n\tfor(int i = 0; i < size; i++){\n\t\ttmp = code/getWeight(size-1-i);\n\t\tif(tmp == 0){\n\t\t\twarm[i] = 'r';\n\t\t}else if(tmp == 1){\n\t\t\twarm[i] = 'g';\n\t\t}else{\n\t\t\twarm[i] = 'b';\n\t\t}\n\t\tcode %= getWeight(size-1-i);\n\t}\n}\n\nint dfs(char warm[],int size){\n\n\tint ret = -1;\n\tData data;\n\tdata.number = translateData(warm,size);\n\tdata.depth = 0;\n\n\tqueue<Data> Q;\n\tQ.push(data);\n\n\tData tmp;\n\tchar tmp_warm[11], next_warm[11];\n\tint code;\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\n\t\tsetData(tmp_warm,tmp.number,size);\n\n\t\tbool FLG = true;\n\t\tfor(int i = 0; i < size-1; i++){\n\t\t\tif(tmp_warm[i] != tmp_warm[i+1]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG){\n\t\t\t//while(!Q.empty())Q.pop();\n\t\t\tret = tmp.depth;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0; i < size-1; i++){\n\t\t\tif(tmp_warm[i] != tmp_warm[i+1]){\n\t\t\t\tData new_data;\n\t\t\t\tfor(int k = 0; k < size; k++)next_warm[k] = tmp_warm[k];\n\n\t\t\t\tif(tmp_warm[i] != 'r' && tmp_warm[i+1] != 'r'){\n\t\t\t\t\tnext_warm[i] = 'r';\n\t\t\t\t\tnext_warm[i+1] = 'r';\n\t\t\t\t}else if(tmp_warm[i] != 'g' && tmp_warm[i+1] != 'g'){\n\t\t\t\t\tnext_warm[i] = 'g';\n\t\t\t\t\tnext_warm[i+1] = 'g';\n\t\t\t\t}else{\n\t\t\t\t\tnext_warm[i] = 'b';\n\t\t\t\t\tnext_warm[i+1] = 'b';\n\t\t\t\t}\n\n\t\t\t\tcode = translateData(next_warm,size);\n\t\t\t\tif(checkTable[code] == -1){\n\t\t\t\t\tcheckTable[code] = 1;\n\t\t\t\t\tnew_data.number = code;\n\t\t\t\t\tnew_data.depth = tmp.depth+1;\n\t\t\t\t\tQ.push(new_data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint size,minimum;\n\tchar buf[11];\n\n\twhile(true){\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0] == '0')break;\n\n\t\tfor(size = 0;buf[size] != '\\0';size++);\n\n\t\tfor(int i = 0; i < 59049; i++)checkTable[i] = -1;\n\n\t\tcheckTable[translateData(buf,size)] = 1;\n\n\t\tminimum = dfs(buf,size);\n\n\t\tif(minimum == -1)printf(\"NA\\n\");\n\t\telse{\n\t\t\tprintf(\"%d\\n\",minimum);\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<string,int>P;\nint bfs(string worm){\n  queue<P>que;\n  que.push(P(worm,0));\n  map<string,int>d;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n\n    if(d[p.first])continue;\n    string str = p.first;\n    bool flag = false;\n    for(int i = 0 ; i < str.size()-1 ; i++ ){\n      if(str[i] != str[i+1] ){\n\tflag = true;\n\tbreak;\n      }\n    }\n    if(!flag)return p.second;\n    d[p.first] = p.second;\n    for(int i = 0 ; i < str.size()-1 ; i++ ){\n      if(str[i] != str[i+1]){\n\tchar tmp;\n\tstring next;\n\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t  tmp = 'b'; \n\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t  tmp = 'g';\n\t}else {\n\t  tmp = 'r';\n\t}\n\tnext = str;\n\tnext[i] = next[i+1] = tmp;\n\tque.push(P(next,p.second + 1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string worm; \n  while(  cin >> worm ){\n    if(worm[0] == '0' )break;  \n    int ret = bfs(worm);\n    if(ret >= 0)cout << ret << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint main(){\n  string worm;\n  int cost[60000];\n  int count = 0;\n  while(1) {\n    if(count > 60000) break;\n    count++;\n    cin >> worm;\n    if(worm[0] == '0') break;\n\n    int ima[10];\n    for(int i=0;i<worm.size();i++) {\n      if(worm[i] == 'r') ima[i] = 0;\n      else if(worm[i] =='b') ima[i] = 1;\n      else ima[i] = 2;\n    }\n\n    int t = 1,m = worm.size();\n    int deci = 0;\n    // 3 to 10\n    for(int i=0;i<m;i++) {\n      deci += ima[m-1-i]*t;\n      t *= 3;\n    }\n\n   \n    for(int i=0;i<60000;i++) cost[i] = 1000000000;  \n    cost[deci] = 0;\n\n    queue <int> Q;\n    Q.push(deci);\n\n    int befo[2];\n    int a;\n    int ans = 1000000000;\n    while(!Q.empty()) {\n      a = Q.front();\n      Q.pop();\n      int b = a;\n      //      cout << a << endl;\n      for(int i =0;i<m;i++) {\n\tima[m-1-i] = b%3;\n\tb/=3;\n      }\n      \n      //      cout << \"start\";\n      //for(int i=0;i<m;i++) cout << ima[i];\n      //cout << endl;\n    \n      for(int j=0;j<m-1;j++) {\n\tif(ima[j] != ima[j+1]) break;\n\tif(j == m-2) ans = min(ans,cost[a]);\n      }\n      \n\n      int flg[3] = {};\n      for(int i=0;i<m-1;i++) {\n\tif(ima[i] != ima[i+1]) {\n\t  befo[0] = ima[i];\n\t  befo[1] = ima[i+1];\n\t  flg[ima[i]] = flg[ima[i+1]] = 1;\n\t  for(int j=0;j<3;j++) if(flg[j] == 0) ima[i] = ima[i+1] = j;\n\t  // for(int j=0;j<m;j++) cout << ima[j];\n\t  // cout << endl;\n\t  t = 1;\n\t  deci = 0;\n\t  // 3 to 10\n\t  for(int j=0;j<m;j++) {\n\t    deci += ima[m-1-j]*t;\n\t    t *= 3;\n\t  }\n\n\t  if(cost[deci]  > cost[a]+1 && ans > cost[a] +1 ) {\n\t    cost[deci] = cost[a]+1;\n\t    // cout << \"deci =\"<< deci << endl;\n\t    Q.push(deci);\n\t  }\n\t  ima[i] = befo[0];\n\t  ima[i+1] = befo[1];\n\t  flg[0] = flg[1] = flg[2] = 0;\n\t}\n      }\n    }\n\t\n\n\n\n    if(ans == 1000000000) cout <<\"NA\" <<endl;\n    else cout << ans << endl;\n\n\n  }\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\nint main(){\n\tint n, g, b, c, x, y, i, c1, c2;\n\tchar s[20];\n\tfor(; cin >> s, *s - '0';){\n\t\tbitset<0xAAAAB> t;\n\t\tqueue<int> q;\n\t\tfor( x = n = 0; s[n]; n++ ){\n\t\t\tx |= ( s[n] == 'b' ? 2 : s[n] == 'g' ) << ( 2 * n );\n\t\t}\n\t\tn *= 2;\n\t\tg = 0x55555 & ( 1 << n ) - 1;\n\t\tb = 0xAAAAA & ( 1 << n ) - 1;\n\n\t\tq.push(x);\n\t\tq.push(-1);\n\t\tc = 0;\n\t\tfor(; q.size() > 1; ){\n\t\t\tx = q.front();\n\t\t\tif( !x || x == g || x == b ){\tbreak;\t}\n\t\t\tq.pop();\n\t\t\tif( x == -1 ){\t++c;\tq.push(-1);\t}\n\t\t\telse{\n\t\t\t\tc1 = x & 3;\n\t\t\t\tfor( i = 2; i < n; i += 2 ){\n\t\t\t\t\tc2 = x >> i & 3;\n\t\t\t\t\tif( c1 != c2 ){\n\t\t\t\t\t\ty = x & ~( 15 << i - 2 );\n\t\t\t\t\t\ty |= ( 3 - c1 - c2 ) * 5 << i - 2;\n\t\t\t\t\t\tif( !t[y] ){\n\t\t\t\t\t\t\tt.set(y);\n\t\t\t\t\t\t\tq.push(y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc1 = c2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( q.size() > 1 ){\tcout << c << \"\\n\";\t}\n\t\telse{\tcout << \"NA\\n\";\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <utility>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, string> P;\n\nint main()\n{\n    char worm[32];\n\n    while (scanf(\"%s\", worm), *worm != '0'){\n        queue<P> que;\n        set<string> exist;\n\n        for (que.push(P(0, string(worm))); que.size(); que.pop()){\n            P tmp = que.front();\n            string s = tmp.second;\n            bool flag = true;\n\n            for (int i = 0; i < s.length() - 1; i++){\n                string t = s;\n\n                if (t[i] != t[i + 1]){\n                    flag = false;\n                    if (t[i] != 'r' && t[i + 1] != 'r'){\n                        t[i] = t[i + 1] = 'r';\n                    }\n                    else if (t[i] != 'g' && t[i + 1] != 'g'){\n                        t[i] = t[i + 1] = 'g';\n                    }\n                    else {\n                        t[i] = t[i + 1] = 'b';\n                    }\n                    que.push(P(tmp.first + 1, t));\n                }\n            }\n            if (flag){\n                printf(\"%d\\n\", tmp.first);\n                break;\n            }\n        }\n        if (que.empty()){\n            puts(\"NA\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint change( string target )\n{\n\tint a = 1;\n\tint sum = 0;\n\n\tfor( int i = 0;i < target.size();i++ ){\n\t\tif( target[i] == 'r' ) target[i] = 0;\n\t\telse if( target[i] == 'g' ) target[i] = 1;\n\t\telse if( target[i] == 'b' ) target[i] = 2;\n\t\t\n\t\tsum += target[i] * a;\n\t\ta *= 3;\n\t}\n\n\treturn sum;\n}\n\n\t\t\n\nint bfs( string target )\n{\n\tset<int> history;\n\tqueue<string> data;\n\tmap<string,int> dist;\n\n\tdata.push( target );\n\tdist[target] = 0;\n\n\twhile( !data.empty() ){\n\t\tconst string u = data.front();\n\t\tif( count( u.begin(), u.end(), 'r' ) == u.size() || count( u.begin(), u.end(), 'g' ) == u.size() || count( u.begin(), u.end(), 'b' ) == u.size() ) return dist[u];\n\n\t\tfor( int i = 0;i < u.size() - 1;i++ ){\n\t\t\tif( u[i] != u[i + 1] ){\n\t\t\t\tstring hoge = u;\n\t\t\t\thoge[i] = hoge[i + 1] = ( 'r' + 'g' + 'b' ) - ( hoge[i] + hoge[i + 1] );\n\t\t\t\tint piyo = change( hoge );\n\t\t\t\tif( history.count( piyo ) ) continue;\n\t\t\t\thistory.insert( piyo );\n\t\t\t\tdata.push( hoge );\n\t\t\t\tdist[hoge] = dist[u] + 1;\n\t\t\t}\n\t\t}\n\n\t\tdata.pop();\n\t}\n\treturn -1;\n\n}\n\nint main(int argc, char const* argv[])\n{\n\tstring target;\n\n\twhile( cin >> target && target != \"0\" ){\n\t\tint answer = bfs( target );\n\t\tif( answer != -1 ) cout << answer << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<string, int> bug;\ntypedef map<string, int> closeMap;\n\nint isOK(string str) {\n    // cout << \"str:\" << str << \" \" << str.size() << endl;\n    for ( int i = 0; i < str.size(); i++ ) {\n        if ( str[0] != str[i] ) return 0;\n    }\n    return 1;\n}\n\nchar cc(char a, char b) {\n    // 並び替え\n    if ( b < a ) {\n        char tmp = a;\n        a = b;\n        b = tmp;\n    }\n\n    if ( a == 'b' && b == 'g' ) {\n        return 'r';\n    } else if ( a == 'b' && b == 'r' ) {\n        return 'g';\n    } else {\n        return 'b';\n    }\n}\n\nvoid wfs(string str) {\n    int cnt = -1;\n    string first = str;\n    queue<bug> open;\n    closeMap close;\n\n    // 初期状態をプッシュ\n    open.push( make_pair(str, 0) );\n\n    close.insert( closeMap::value_type(str, 1) );\n    // cout << str << \" key:\" << close[str] << endl;\n\n    while(!open.empty()) {\n        bug b = open.front(); open.pop();\n        string cs = b.first;\n\n        if ( isOK(cs) ) {\n            cnt = b.second;\n            break;\n        }\n\n        int c = 0;\n        for ( int i = 1; i < cs.size(); i++ ) {\n            if ( cs[i-1] != cs[i] ) {\n                string tmp = cs;\n                char nc = cc(cs[i-1], cs[i]);\n                tmp[i-1] = nc;\n                tmp[i] = nc;\n\n                if ( close[tmp] )continue;\n                open.push( make_pair(tmp, b.second+1) );\n                close[tmp] = 1;\n                c++;\n            }\n        }\n    }\n\n    if ( cnt == -1 ) {\n        cout << \"NA\" << endl;\n    } else {\n        cout << cnt << endl;\n    }\n\n\n}\n\nint main() {\n    string n;\n\n    while ( cin >> n, n != \"0\" ) {\n        wfs(n);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nclass Info{\npublic:\n\tstring s;\n\tint depth;\n};\n\nbool is_answer(string s){\n\tfor(int i=1;i<s.length();i++){\n\t\tif(s.at(0) != s.at(i)) return false;\n\t}\n\treturn true;\n}\n\nstring change_color(string s, int i){\n\tchar f = s.at(i);\n\tchar b = s.at(i+1);\n\n\tif(f == 'r' && b == 'g' || f == 'g' && b == 'r'){\n\t\ts.replace(i,2,\"bb\");\n\t}\n\telse if(f == 'r' && b == 'b' || f == 'b' && b == 'r'){\n\t\ts.replace(i,2,\"gg\");\n\t}\n\telse if(f == 'g' && b == 'b' || f == 'b' && b == 'g'){\n\t\ts.replace(i,2,\"rr\");\n\t}\n\n\treturn s;\n}\n\nint bfs(string s){\n\tint len = s.length();\n\tset<string> worm_set;\n\tqueue<Info> q;\n\tInfo tmp = {s,0};\n\n\tif(is_answer(s)){\n\t\treturn 0;\n\t}\n\n\tq.push(tmp);\n\tworm_set.insert(s);\n\n\twhile(!q.empty()){\n\t\ttmp = q.front(); q.pop();\n\n\t\tfor(int i=0;i<len-1;i++){\n\t\t\tstring next_worm = change_color(tmp.s,i);\n\n\t\t\tif(is_answer(next_worm)){\n\t\t\t\treturn tmp.depth + 1;\n\t\t\t}\n\n\t\t\tif(next_worm != tmp.s &&\n\t\t\t\t worm_set.find(next_worm) == worm_set.end()){\n\t\t\t\tInfo next_info = {next_worm, tmp.depth + 1};\n\n\t\t\t\tq.push(next_info);\n\t\t\t\tworm_set.insert(next_worm);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\tstring s;\n\n\twhile(cin >> s && s != \"0\"){\n\t\tint ans = bfs(s);\n\n\t\tif(ans >= 0){\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NA\\n\";\n\t\t}\n\t}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nstring s;\nstring rbg = \"rbg\";\nchar calc(char a, char b)\n{\n    for(int i = 0; i < rbg.size(); i++) if(rbg[i] != a and rbg[i] != b) return rbg[i];\n}\nbool check(string s)\n{\n    char ch = s[0];\n    for(int i = 0; i < s.size(); i++) if(ch != s[i]) return false;\n    return true;\n}\nint solve()\n{\n    map<string, int> mp;\n    queue<pair<string, int>> que;\n    que.push(make_pair(s, 0));\n    while(que.size())\n    {\n        pair<string, int> p = que.front(); que.pop();\n        string target = p.first;\n        int cnt = p.second;\n        if(mp.count(target)) continue;\n        if(check(target)) return cnt;\n        mp[target] = cnt;\n        int pos = 0;\n        while(pos < target.size() - 1)\n        {\n            string next_target = target;\n            char a = next_target[pos], b = next_target[pos + 1];\n            if(a != b)\n            {\n                next_target[pos] = next_target[pos + 1] = calc(a, b);\n                que.push(make_pair(next_target, cnt + 1));\n            }\n            pos++;\n        }\n    }\n    return -1;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> s, s != \"0\")\n    {\n        int ans = solve();\n        if(ans == -1) cout << \"NA\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n \nusing namespace std;\n \nint len;\nstring str;\n \nbool check(string s){\n  char ch = s[0];\n \n  for(int i = 1 ; i < len ; i++){\n    if(ch != s[i]) return false;\n  }\n  return true;\n}\n \nint bfs(){\n  string ans;\n  queue<string> Q;\n  Q.push(str);\n \n  bool found = false;\n  set<string> used;\n  used.insert(str);\n  map<string,int> dist;\n  dist[str] = 0;\n \n  while(!Q.empty()){\n    string s = Q.front(); Q.pop();\n     \n    if(check(s)){\n      found = true;\n      ans = s;\n      break;\n    }\n \n    for(int i = 1 ; i < len ; i++){\n      string next = s;\n      if(s[i-1] == 'b' && s[i] == 'r' ||\n     s[i-1] == 'r' && s[i] == 'b'){\n    next[i-1] = next[i] = 'g';\n      }else if(s[i-1] == 'b' && s[i] == 'g' ||\n           s[i-1] == 'g' && s[i] == 'b'){\n    next[i-1] = next[i] = 'r';\n      }else if(s[i-1] == 'r' && s[i] == 'g' ||\n           s[i-1] == 'g' && s[i] == 'r'){\n    next[i-1] = next[i] = 'b';\n      }\n       \n      if(!used.count(next)){\n    dist[next] = dist[s] + 1;\n    used.insert(next);\n    Q.push(next);\n      }\n    }\n  }\n \n  if(!found) return -1;\n  return dist[ans];\n}\n \nint main(){\n  while(cin >> str,str != \"0\"){\n    len = (int)str.size();\n    int res = bfs();\n    if(res == -1){\n      cout << \"NA\" << endl;\n    }else{\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<string, int> psi;\n\nbool check(string worm) {\n    for (int i = 1; i < worm.size(); i++) {\n        if (worm[i] != worm[i-1]) return false;\n    }\n    return true;\n}\n\nchar change_color(char a, char b) {\n    char c;\n    if (a == 'r') {\n        if (b == 'g') c = 'b';\n        else c = 'g';\n    }\n    if (a == 'g') {\n        if (b == 'r') c = 'b';\n        else c = 'r';\n    }\n    if (a == 'b') {\n        if (b == 'r') c = 'g';\n        else c = 'r';\n    }\n    return c;\n}\n\nint solve(string worm) {\n    int ans = -1;\n    map<string, int> memo;\n    queue<psi> Q;\n\n    Q.push(make_pair(worm, 0));\n    while(!Q.empty()) {\n        psi now = Q.front(); Q.pop();\n        if (check(now.first)) {\n            return now.second;\n        }\n        if (memo[now.first]) continue;\n        memo[now.first] = now.second;\n\n        for (int i = 1; i < now.first.size(); i++) {\n            if (now.first[i] == now.first[i-1]) continue;\n            char color = change_color(now.first[i-1], now.first[i]);\n            string next = now.first;\n            next[i-1] = next[i] = color;\n\n            Q.push(make_pair(next, now.second + 1));\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    string worm;\n    while(cin >> worm) {\n        if (worm == \"0\") break;\n        int ans = solve(worm);\n        if (ans == -1)\n            cout << \"NA\" << endl;\n        else\n            cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint main(){\n\tmap<string,string>q;\n\tq[\"bg\"]=q[\"gb\"]=\"rr\";\n\tq[\"gr\"]=q[\"rg\"]=\"bb\";\n\tq[\"rb\"]=q[\"br\"]=\"gg\";\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tchar qqq=s[0];\n\t\tbool h=true;\n\t\trep(i,s.size())if(s[i]!=qqq)h=false;\n\t\tif(h){cout<<0<<endl;continue;}\n\t\tvector<string>in;\n\t\tmap<string,bool>tmp;\n\t\tin.pb(s);\n\t\tint co=0;\n\t\twhile(1){\n\t\t\tvector<string>out;\n\t\t\tbool h=false;\n\t\t\trep(i,in.size()){\n\t\t\t\tstring s=in[i];\n\t\t\t\ttmp[s]=true;\n\t\t\t\t//h=true;\n\t\t\t\t//char qq=in[i][0];\n\t\t\t\t//rep(j,s.size())if(qq!=in[i][j])h=false;\n\t\t\t\t//if(h)break;\n\t\t\t\trep(j,s.size()-1)if(s[j]!=s[j+1]){\n\t\t\t\t\tstring www=s.substr(j,2);\n\t\t\t\t\tstring w=q[www];\n\t\t\t\t\tstring ww=s;\n\t\t\t\t\tww[j]=w[0];ww[j+1]=w[1];\n\t\t\t\t\th=true;\n\t\t\t\t\tchar qq=ww[0];\n\t\t\t\t\trep(k,ww.size())if(qq!=ww[k])h=false;\n\t\t\t\t\tif(h)break;\n\t\t\t\t\tif(!tmp[ww]){out.pb(ww);tmp[ww]=true;}\n\t\t\t\t}\n\t\t\t\tif(h)break;\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t\t//rep(i,out.size())cout<<out[i]<<endl;\n\t\t\t//cout<<tmp.size()<<endl;\n\t\t\t//cout<<out.size()<<endl;\n\t\t\tif(h)break;\n\t\t\tco++;\n\t\t\tin=out;\n\t\t\t//cout<<\" \"<<in.size()<<endl;\n\t\t\tif(co==100)break;\n\t\t}\n\t\tif(co==100)cout<<\"NA\"<<endl;\n\t\telse cout<<co+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n\tstring sin,ans;\n\twhile(cin >> sin && sin != \"0\"){\n\t\tqueue<string> Q;\n\t\tmap<string,int> B;\n\t\tans = \"\";\n\t\tQ.push(sin);\n\t\tB[sin] = 0;\n\t\twhile(!Q.empty()){\n\t\t\tstring s = Q.front();Q.pop();\n\t\t\tchar t = s[0];\n\t\t\tbool allF = true;\n\t\t\tfor(int i = 0;i<s.length();i++){\n\t\t\t\tif(s[i] != t){\n\t\t\t\t\tallF = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(allF){\n\t\t\t\tans = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1;i<s.length();i++){\n\t\t\t\tstring ss = s;\n\t\t\t\tif(s[i] != s[i-1]){\n\t\t\t\t\tchar c = 'r' + 'g' + 'b' - s[i] - s[i-1];\n\t\t\t\t\tss[i] = c;\n\t\t\t\t\tss[i-1] = c;\n\t\t\t\t\tif(B[ss] == 0){\n\t\t\t\t\t\tB[ss] = B[s] + 1;\n\t\t\t\t\t\tQ.push(ss);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ans.empty()){\n\t\t\tcout << B[ans] << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nstring S;\nmap<string, bool> seen;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> S) {\n    if (S == \"0\") break;\n    int N = S.length();\n    rep(i, N) {\n      if (S[i] == 'r') S[i] = 1;\n      else if (S[i] == 'g') S[i] = 2;\n      else S[i] = 3;\n    }\n    queue< pair<string, int> > q;\n    seen.clear();\n    seen[S] = true;\n    q.push(make_pair(S, 0));\n\n    bool done = false;\n    while (q.size()) {\n      string s = q.front()._1;\n      int r = q.front()._2;\n      q.pop();\n      if (r > 20) break;\n\n      bool ok = true;\n      rep(i, N) if (s[i] != s[0]) ok = false;\n      if (ok) {\n        done = true;\n        cout << r << \"\\n\";\n        break;\n      }\n      rep(i, N-1) {\n        if (s[i] == s[i+1]) continue;\n        string t(s);\n        t[i] = t[i+1] = s[i]^s[i+1];\n        if (seen[t]) continue;\n        seen[t] = true;\n        q.push(make_pair(t, r+1));\n      }\n    }\n    if (!done) {\n      cout << \"NA\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<string,bool > passed;\nmap<string,int> dp;\n\nconst int INF=100000000;\n\nint dfs(string str){\n\tif(dp.find(str)!=dp.end()){\n\t\treturn dp[str];\n\t}\n\tif(passed.find(str)!=passed.end()&&passed[str]){\n\t\treturn INF;\n\t}\n\tchar cl=str[0];\n\tbool f=false;\n\tfor(int i = 1; i < str.size(); i++){\n\t\tif(str[i]!=cl){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)\n\t\treturn 0;\n\n\tbool flag[200];\n\tint minCnt=INF;\n\tfor(int i = 0; i < str.size()-1; i++){\n\t\tflag['r']=false;\n\t\tflag['g']=false;\n\t\tflag['b']=false;\n\t\tif(str[i]!=str[i+1]){\n\t\t\tflag[str[i]]=true;\n\t\t\tflag[str[i+1]]=true;\n\t\t\tif(!flag['r']){\n\t\t\t\tstring nstr=str;\n\t\t\t\tnstr[i]='r';\n\t\t\t\tnstr[i+1]='r';\n\t\t\t\tpassed[str]=true;\n\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t\t\t\tpassed[str]=false;\n\t\t\t}\n\t\t\telse if(!flag['g']){\n\t\t\t\tstring nstr=str;\n\t\t\t\tnstr[i]='g';\n\t\t\t\tnstr[i+1]='g';\n\t\t\t\tpassed[str]=true;\n\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t\t\t\tpassed[str]=false;\n\t\t\t}\n\t\t\telse if(!flag['b']){\n\t\t\t\tstring nstr=str;\n\t\t\t\tnstr[i]='b';\n\t\t\t\tnstr[i+1]='b';\n\t\t\t\tpassed[str]=true;\n\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t\t\t\tpassed[str]=false;\n\t\t\t}\n\t\t}\n\t}\n\t//if(minCnt!=INF)\n\t\tdp[str]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tstring str;\n\twhile(cin>>str&&str!=\"0\"){\n\t\tdp.clear();\n\t\tpassed.clear();\n\t\tint ret=dfs(str);\n\t\tif(ret!=INF)\n\t\t\tcout<<ret<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<string,int> P;\n\nint n;\nset<string> closed;\n\nbool check(string s){\n  for(int i = 0; i < n - 1; i++){\n    if(s[i] != s[i + 1]){\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid solve(string s){\n  queue<P> open;\n  open.push(P(s, 0));\n  closed.clear();\n  closed.insert(s);\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n    s = p.first;\n\n    if(check(s)){\n      cout << p.second << endl;\n      return;\n    }\n\n    for(int i = 0; i < n - 1; i++){\n      if(s[i] != s[i + 1]){\n        string next = s;\n        if(s[i] != 'r' && s[i + 1] != 'r') next[i] = next[i + 1] = 'r';\n        if(s[i] != 'g' && s[i + 1] != 'g') next[i] = next[i + 1] = 'g';\n        if(s[i] != 'b' && s[i + 1] != 'b') next[i] = next[i + 1] = 'b';\n\n        if(closed.find(next) == closed.end()){\n          closed.insert(next);\n          open.push(P(next, p.second + 1));\n        }\n      }\n    }\n  }\n\n  cout << \"NA\\n\";\n}\n\nint main(){\n  string s;\n\n  while(cin >> s, s != \"0\"){\n    n = s.length();\n    solve(s);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nint main()\n{\n    map<string, int> worm;\n    queue<string> que;\n    string chars = \"rgb\";\n    REP(i, 1, 11){\n        for (char c : chars) {\n            worm[string(i,c)] = 0;\n            que.push(string(i,c));\n            while (!que.empty()) {\n                string s = que.front(); que.pop();\n                rep(j, s.length()-1){\n                    if (s[j] != s[j+1])\n                        continue;\n                    rep(k, 3){\n                        if (s[j] == chars[k]) {\n                            REP(l, k+1, k+3){\n                                REP(m, k+1, k+3){\n                                    if (l != m) {\n                                        string p = s;\n                                        p[j] = chars[l%3];\n                                        p[j+1] = chars[m%3];\n                                        if(!EXIST(worm, p)){\n                                            que.push(p);\n                                            worm[p] = worm[s] + 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    string input;\n    while (cin >> input, input != \"0\") {\n        if (EXIST(worm, input))\n            cout << worm[input] << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<string, int> P;\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str == \"0\")\n\t\t\tbreak;\n\t\tint count = -1;\n\t\tmap<string,bool> mp;\n\t\tqueue<P> que;\n\t\tP p;p.first = str;p.second = 0;\n\t\tque.push(p);\n\t\twhile(que.size()){\n\t\t\tP s = que.front();que.pop();\n\t\t\tif(mp.find(s.first)!=mp.end())\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tmp[s.first] = true;\n\t\t\tbool is_all = true;\n\t\t\tfor(unsigned i=1;i<s.first.size();i++){\n\t\t\t\tif(s.first[0] != s.first[i]){\n\t\t\t\t\tis_all = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_all){\n\t\t\t\tcount = s.second;\n\t\t\t}\n\n\t\t\tint a=0;\n\t\t\tfor(unsigned i=0;i<s.first.size()-1;i++){\n\t\t\t\tP ss = s;\n\t\t\t\tif((ss.first[i] != ss.first[i+1])){\n\t\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'r')){\n\t\t\t\t\t\tss.first[i] = 'b';ss.first[i+1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'b') || (ss.first[i] == 'b' && ss.first[i+1] == 'r')){\n\t\t\t\t\t\tss.first[i] = 'g';ss.first[i+1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif((ss.first[i] == 'b' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'b')){\n\t\t\t\t\t\tss.first[i] = 'r';ss.first[i+1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tss.second = s.second+1;\n\t\t\t\t\tque.push(ss);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    map<string, int> m;\n    que.push(pair<string, int>(worm, 0));\n    string worm1, tmp;\n    int num;\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        worm1 = que.front().first;\n        num = que.front().second;\n        que.pop();\n\n        if(m[worm1]) continue;\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        if(num >= 10){\n            return -1;\n        }\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s==\"0\")break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(!q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }else if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp[y]==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(!f)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <complex>\n\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define tr(c, i) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define rtr(c, i) for (typeof((c).rbegin()) i = (c).rbegin(); i != (c).rend(); --i)\n#define contains(c, x) ((c).find(x) != (c).end())\n#define Contains(c, x) (find(all(c), x) != (c).end())\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, (n))\n#define To_String to_string< char,std::char_traits<char>,std::allocator<char> >\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n\nint a[11];\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tstring s;\n\twhile (cin >> s, s != \"0\") {\n\t\tint n = s.size();\n\t\trep(i, n) switch (s[i]) {\n\t\t\tcase 'r': a[i] = 0; break;\n\t\t\tcase 'g': a[i] = 1; break;\n\t\t\tcase 'b': a[i] = 2; break;\n\t\t}\n\t\tint x = 0;\n\t\trep(i, n) x = x * 3 + a[n-1-i];\n\n\t\tqueue<int> q;\n\t\tmap<int, int> m;\n\t\tq.push(x);\n\t\tm[x] = 0;\n\t\tint res = -1;\n\t\twhile (!q.empty()) {\n\t\t\tint p = q.front(); q.pop();\n\t\t\tint t = p, d = p % 3;\n\t\t\tbool ok = true;\n\t\t\trep(i, n) { a[i] = t % 3; t /= 3; ok = (ok && (a[i] == d)); }\n\t\t\tif (ok) { res = m[p]; break; }\n\n\t\t\trep(i, n-1) if (a[i] != a[i+1]) {\n\t\t\t\tint t1 = a[i], t2 = a[i+1];\n\t\t\t\ta[i] = a[i+1] = 3 - t1 - t2;\n\t\t\t\tint y = 0;\n\t\t\t\trep(j, n) y = y * 3 + a[n-1-j];\n\t\t\t\tif (!contains(m, y)) { q.push(y); m[y] = m[p] + 1; }\n\t\t\t\ta[i] = t1, a[i+1] = t2;\n\t\t\t}\n\t\t}\n\t\tif (res >= 0) cout << res << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nbool check(string s){\n    for(int i=0; i< s.size()-1; i++) if(s[i] != s[i+1]) return false;\n    return true;\n}\n\nvector<string> v;\n\nbool emergence(string s){\n    for(int i=0; i< v.size(); i++) if(v[i] == s) return true;\n    else return false;\n}\n\nint main(){\n    string s;\n    while(cin >> s, s!= \"0\"){\n        queue<pair<string, int> > que;\n        que.push(make_pair(s, 0));\n        int ret = 9;\n        while(que.size()){\n            s = que.front().first; int count = que.front().second; que.pop();\n\n            if(ret < count) continue;\n            if(check(s))ret = count;\n            if(emergence(s)) continue;\n            else v.push_back(s);\n\n            for(int i=0; i< s.size()-1; i++){\n                if(s[i] != s[i+1]){\n                    string t = s.substr(i, 2);\n                    sort(t.begin(),t.end());\n                    if(t == \"br\") t = \"gg\";\n                    else if(t == \"bg\") t = \"rr\";\n                    else if(t == \"gr\") t = \"bb\";\n                    que.push(make_pair(s.substr(0, i)+t+s.substr(i+2), count+1));\n                }\n            }\n        }\n        if(ret == 9) cout << \"NA\" << endl;\n        else cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <string>\n#include <queue>\n#include <climits>\n#include <vector>\nusing namespace std;\n\n#define _gp(l) const auto gcu{getchar##l}; const auto pcu{putchar##l}\n#ifdef __linux\n_gp(_unlocked);\n#else\n_gp();\n#endif\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;for(char c;c=gcu(),c!=' '&&c!='\\n';)s+=c;return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;if((c=gcu())=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n\t_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n\t_HT _OUT(H &&h, T... t){out(h);out(t...);}\n\ttemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n\tstruct range{\n\t\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\t\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\nstruct N {\n\tint s, n;\n};\n\nbool all(int n) {\n\tint c = n & 3;\n\tn >>= 2;\n\tfor (; n; n >>= 2)\n\t\tif ((n & 3) != c)\n\t\t\treturn false;\n\treturn true;\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s = in;\n\t\tif (s == \"0\")\n\t\t\treturn 0;\n\t\tvector<bool> m(1 << s.size() * 2);\n\t\tint t {};\n\t\tfor (char c: s)\n\t\t\tt = t << 2 | (c == 'r' ? 1 : c == 'g' ? 2 : 3);\n\t\tm[t] = true;\n\t\tqueue<N> q;\n\t\tq.push({t, 0});\n\t\t[&] {\n\t\t\twhile (!q.empty()) {\n\t\t\t\tN f {q.front()};\n\t\t\t\tq.pop();\n\t\t\t\tif (all(f.s)) {\n\t\t\t\t\toutl(f.n);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (int i: range(1, s.size())) {\n\t\t\t\t\tint x = (i - 1) * 2,\n\t\t\t\t\t\tm0 = f.s >> x & 3,\n\t\t\t\t\t\tm1 = f.s >> i * 2 & 3;\n\t\t\t\t\tif (m0 != m1) {\n\t\t\t\t\t\tint g = m0 ^ m1,\n\t\t\t\t\t\t\tt = (f.s & ~(15 << x)) | (g | g << 2) << x;\n\t\t\t\t\t\tif (!m[t]) {\n\t\t\t\t\t\t\tm[t] = true;\n\t\t\t\t\t\t\tq.push({t, f.n + 1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\toutl(\"NA\");\n\t\t}();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nmap<char, int> m;\nmap<string, int> ans;\n\nint main() {\n\n\tm['r'] = 1;\n\tm['g'] = 2;\n\tm['b'] = 4;\n\t\n\tstring str;\n\t\n\twhile (cin >> str, str != \"0\") {\n\t\tchar c[3] = {'r', 'g', 'b'};\n\t\tstring ser[3] = {};\n\t\tREP(i, 3) REP(j, str.size()) {\n\t\t\tser[i] += c[i];\n\t\t}\n\t\t\n\t\tqueue<pair<int, string> > que;\n\t\tREP(i, 3) que.push(make_pair(0, ser[i]));\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint t = que.front().first;\n\t\t\tstring now = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (ans.find(now) != ans.end()) continue;\n\t\t\tans[now] = t;\n\t\t\tif (now == str) break;\n\t\t\t\n\t\t\tREP(i, now.size() - 1) {\n\t\t\t\tif (now[i] == now[i + 1]) {\n\t\t\t\t\tstring next = now;\n\t\t\t\t\tint nextcor = 7 - m[now[i]];\n\t\t\t\t\tvector<char> pl;\n\t\t\t\t\tREP(j, 3) if (nextcor & (1<<j)) pl.push_back(c[j]);\n\t\t\t\t\tREP(j, 2) {\n\t\t\t\t\t\tnext[i] = pl[j];\n\t\t\t\t\t\tnext[i + 1] = pl[(j + 1) % 2];\n\t\t\t\t\t\tque.push(make_pair(t + 1, next)); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans.find(str) == ans.end()) puts(\"NA\");\n\t\telse cout << ans[str] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <climits>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\nstring s;\nint qf;\n\nint foo1(int D[]){\n\tint res=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tres*=10;\n\t\tres+=D[i];\n\t}\n\treturn res;\n}\nvoid foo2(int D[],int m){\n\trep(j,s.size()){\n\t\tD[j]=0;\n\t}\n\t//cout<<\"D = \";\n\tfor(int i=s.size()-1;i>=0;--i){\n\t\tD[i]=m%10;\n\t\tm/=10;\n\t\t//cout<<m<<endl;\n\t\t//cout<<\"D = \";\n\t\trep(j,s.size()){\n\t\t\t//cout<<D[j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t\t//D[i]=2;\n\t}\n\t//cout<<endl;\n}\n\n\nint a[30];\nint tmp[30];\nset<int> vis;\n\nbool check(){\n\tint t=a[0];\n\trep(i,s.size()){\n\t\tif(t!=a[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=0;\n\t\t//int lim=pow(3,s.size());\n\t\tqueue<int> qu;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='r') a[i]=0;\n\t\t\telse if(s[i]=='g') a[i]=1;\n\t\t\telse if(s[i]=='b') a[i]=2;\n\t\t}\n\t\tif(check()){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqu.push(foo1(a));\n\t\tvis.insert(foo1(a));\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\tint c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\tc++;\n\t\t\tif(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\t//cout<<qf<<endl;\n\t\t\t\tqu.pop();\n\t\t\t\tfoo2(a,qf);\n\t\t\t\tif(check()){\n\t\t\t\t\tcout<<ans-1<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(a[j]!=a[j+1]){\n\t\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\t\ttmp[k]=a[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[j]*a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=0;\n\t\t\t\t\t\t\ttmp[j+1]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(a[j]==2||a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=1;\n\t\t\t\t\t\t\ttmp[j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttmp[j]=2;\n\t\t\t\t\t\t\ttmp[j+1]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(vis.find(foo1(tmp))==vis.end()){\n\t\t\t\t\t\t\tqu.push(foo1(tmp));\n\t\t\t\t\t\t\tvis.insert(foo1(tmp));\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\n//????????????????????????????????????\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\n//??£?????????2?????????????????§?????????????????????\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s ){\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\t//?????\\??????????????¶????????\\??????\n\n\twhile (!q.empty()) {\t//?????\\??????????????¶?????????????????§\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif(m[p.first]) continue;\t//??????????????????\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tm[p.first] = p.second;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\t//??£?????????2????????°????????¨???\n\t\t\t\tchar tmp = color(now[i], now[i + 1]);\n\t\t\t\tstring D = now;\n\t\t\t\tD[i] = tmp;\n\t\t\t\tD[i + 1] = tmp;\n\t\t\t\tq.push(P(D, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nvoid solve()\n{\n\tstring str;\n\twhile(cin >> str)\n\t{\n\t\tif(str == \"0\")\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tqueue<string> Que;\n\t\tQue.push(str);\n\t\tqueue<string> NextQue;\n\t\tint depth = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tif(depth >= 10)\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tstring worm = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tbool same_color_flag = true;\n\t\t\t\tfor(int i = 1; i < worm.size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif(worm[i] != worm[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tsame_color_flag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(same_color_flag)\n\t\t\t\t{\n\t\t\t\t\tcout << depth << endl;\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\tchar before_color = worm[0];\n\t\t\t\tfor(int i = 1; i < worm.size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif(before_color != worm[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tstring next = worm;\n\t\t\t\t\t\tif(before_color == 'b')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(worm[i] == 'g')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'r';\n\t\t\t\t\t\t\t\tnext[i] = 'r';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(worm[i] == 'r')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'g';\n\t\t\t\t\t\t\t\tnext[i] = 'g';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(before_color == 'g')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(worm[i] == 'b')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'r';\n\t\t\t\t\t\t\t\tnext[i] = 'r';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(worm[i] == 'r')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'b';\n\t\t\t\t\t\t\t\tnext[i] = 'b';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(before_color == 'r')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(worm[i] == 'g')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'b';\n\t\t\t\t\t\t\t\tnext[i] = 'b';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(worm[i] == 'b')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'g';\n\t\t\t\t\t\t\t\tnext[i] = 'g';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tNextQue.push(next);\n\t\t\t\t\t}\n\t\t\t\t\tbefore_color = worm[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t\t++depth;\n\t\t}\nEND:\n\t\t;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nint n;\nmap<int,int> mp;\n\nint tohash(string &s){\n\tint a = 0;\n\tFOR(i,n){\n\t\ta *= 4;\n\t\tif(s[i] == 'r') a += 1;\n\t\telse if(s[i] == 'g') a += 2;\n\t\telse a += 3;\n\t}\n\treturn a;\n}\n\nint decodeC(int hash,int i){\n\treturn (hash >> (2*i)) & 3;\n}\n\nbool OK(int hash){\n\tint c = decodeC(hash,0);\n\tfor(int i = 1; i < n; i++)\n\t\tif(decodeC(hash,i) != c) return false;\n\treturn true;\n}\n\nvoid setC(int& hash,int i,int v){\n\thash = (hash & ~(3 << (2*i))) | (v << (2*i));\n}\n\ntypedef pair<int,int> P;\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tn = sz(s);\n\t\tmp.clear();\n\t\tmp[tohash(s)] = 0;\n\n\t\tint ans = -1;\n\n\t\tpriority_queue<P,vector<P>,greater<P> > q;\n\t\tq.push(P(0,tohash(s)));\n\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(mp[v] < p.first) continue;\n\n\t\t\tif(OK(v)){\n\t\t\t\tans = p.first;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tint hash = p.second;\n\t\t\t\tint c = decodeC(hash , i) ^ decodeC(hash, i + 1);\n\t\t\t\tif(c == 0) continue;\n\t\t\t\tsetC(hash,i,c);\n\t\t\t\tsetC(hash,i+1,c);\n\t\t\t\tif(mp.find(hash) == mp.end() ||  mp[hash] > p.first + 1){\n\t\t\t\t\tmp[hash] = p.first + 1;\n\t\t\t\t\tq.push(P(p.first + 1,hash));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1) puts(\"NA\");\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar c[3]={'r','g','b'};\nmain(){\n  string w;\n  while(cin>>w,w[0]!='0'){\n    unordered_set<string>a;\n    a.insert(w);\n    queue<pair<string,int> >q;\n    q.push(make_pair(w,0));\n    while(!q.empty()){\n      pair<string,int>ww=q.front();q.pop();\n      string s=ww.first;//cout<<s<<endl;\n      int d=ww.second;//cout<<d<<endl;\n      int cc=0;\n      for(int i=0;i<s.size()-1;i++)if(s[i]!=s[i+1])cc++;\n      if(!cc){cout<<d<<endl;goto L;}\n      for(int i=0;i<s.size()-1;i++){\n        if(s[i]!=s[i+1]){\n          int p=0;\n          for(int k=0;k<3;k++)\n            for(int j=0;j<3;j++)\n              if(s[i]==c[k]&&s[i+1]==c[j])p=k+j;\n          string t=s;\n          if(p==3)t[i+1]=t[i]='r';\n          else if(p==2)t[i+1]=t[i]='g';\n          else t[i+1]=t[i]='b';\n          if(!a.count(t)){//cout<<t<<endl;\n            q.push(make_pair(t,d+1));\n            a.insert(t);\n          }\n        }\n      }\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct s{\n    string worm;\n    int nowans;\n};\nint main(){\n    char dc[6][3]={'r','g','b','g','r','b','r','b','g','b','r','g','g','b','r','b','g','r'};\n    while(1){\n        int che[100000]={0};\n        s IN,now;\n        queue <s> que;\n        cin >> IN.worm;\n        IN.nowans=0;\n        if(IN.worm[0]=='0')\n            break;\n        que.push(IN);\n        while(1){\n            int chenum=0;\n            if(que.empty()){\n                puts(\"NA\");\n                goto exit;\n            }\n            now=que.front(),que.pop();\n            for(int i=0;i<now.worm.size();i++){\n                if(now.worm[i]=='r')\n                    chenum+=pow(3,i)*0;\n                else if(now.worm[i]=='g')\n                    chenum+=pow(3,i)*1;\n                else if(now.worm[i]=='b')\n                    chenum+=pow(3,i)*2;\n            }\n            if(che[chenum]==1)\n                continue;\n            else\n                che[chenum]=1;\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1])\n                    break;\n                if(i==now.worm.size()-1-1){\n                    printf(\"%d\\n\",now.nowans);\n                    goto exit;\n                }\n            }\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1]){\n                    for(int j=0;j<6;j++){\n                        if(now.worm[i]==dc[j][0]&&now.worm[i+1]==dc[j][1]){\n                            now.worm[i]=dc[j][2],now.worm[i+1]=dc[j][2],now.nowans++;\n                            que.push(now);\n                            now.worm[i]=dc[j][0],now.worm[i+1]=dc[j][1],now.nowans--;\n                        }\n                    }\n                }\n            }\n        }\nexit:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<string, int> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\twhile(cin >> s, s != \"0\") {\n\t\tint n = s.size();\n\t\tstring R = string(n, 'r');\n\t\tstring B = string(n, 'b');\n\t\tstring G = string(n, 'g');\n\n\t\tmap<string, int> m;\n\t\tm[s] = 0;\n\t\tqueue<P> q;\n\t\tq.push({ s, 0 });\n\t\twhile(q.size()) {\n\t\t\ts = q.front().first;\n\t\t\tint d = q.front().second;\n\t\t\tq.pop();\n\t\t\tif(m[s] < d) continue;\n\t\t\t//cout << s << endl;\n\t\t\tbool flag = false;\n\t\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\t\tstring ns = s;\n\t\t\t\tif(s[i] == 'r' && s[i + 1] == 'b' || s[i] == 'b' && s[i + 1] == 'r') ns[i] = ns[i + 1] = 'g';\n\t\t\t\telse if(s[i] == 'g' && s[i + 1] == 'b' || s[i] == 'b' && s[i + 1] == 'g') ns[i] = ns[i + 1] = 'r';\n\t\t\t\telse if(s[i] == 'r' && s[i + 1] == 'g' || s[i] == 'g' && s[i + 1] == 'r') ns[i] = ns[i + 1] = 'b';\n\t\t\t\tif(ns != s && m.count(ns) == 0) {\n\t\t\t\t\tm[ns] = d + 1;\n\t\t\t\t\tq.push({ ns, d + 1 });\n\t\t\t\t\tif(ns == R || ns == B || ns == G) { flag = true; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\n\t\tint ans = 1e9;\n\t\tif(m.count(R)) ans = min(ans, m[R]);\n\t\tif(m.count(B)) ans = min(ans, m[B]);\n\t\tif(m.count(G)) ans = min(ans, m[G]);\n\t\tif(ans != 1e9) {\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <utility>\n#include <queue>\n#include <set>\nusing namespace std;\n\ntypedef pair<int, string> P;\n\nint main()\n{\n    char worm[32];\n\n    while (scanf(\"%s\", worm), *worm != '0'){\n        queue<P> que;\n        set<string> exist;\n\n        exist.insert(string(worm));\n        for (que.push(P(0, string(worm))); que.size(); que.pop()){\n            P tmp = que.front();\n            string s = tmp.second;\n            bool flag = true;\n\n            for (int i = 0; i < s.length() - 1; i++){\n                string t = s;\n\n                if (t[i] != t[i + 1]){\n                    flag = false;\n                    if (t[i] != 'r' && t[i + 1] != 'r'){\n                        t[i] = t[i + 1] = 'r';\n                    }\n                    else if (t[i] != 'g' && t[i + 1] != 'g'){\n                        t[i] = t[i + 1] = 'g';\n                    }\n                    else {\n                        t[i] = t[i + 1] = 'b';\n                    }\n                    if (exist.find(t) == exist.end()){\n                        exist.insert(t);\n                        que.push(P(tmp.first + 1, t));\n                    }\n                }\n            }\n            if (flag){\n                printf(\"%d\\n\", tmp.first);\n                break;\n            }\n        }\n        if (que.empty()){\n            puts(\"NA\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<map>\n#include<string>\n \nusing namespace std;\n \ntypedef pair<string,int> P;\n \nbool judge(string str)\n{\n  for(int i=1;i<str.size();i++)\n    if(str[0]!=str[i])return false;\n  return true;\n}\n \nchar getch(char c1, char c2)\n{\n  if(c1=='r'&&c2=='b'||c1=='b'&&c2=='r')return 'g';\n  if(c1=='r'&&c2=='g'||c1=='g'&&c2=='r')return 'b';\n  if(c1=='b'&&c2=='g'||c1=='g'&&c2=='b')return 'r';\n}\n \nint bfs(string str)\n{\n  queue<P> q;\n  map<string,int> mat;\n  q.push(P(str,0));\n  while(!q.empty()){\n    P p = q.front(); q.pop();\n    string s=p.first;\n    int n=p.second+1;\n    if(mat[s])continue;\n    if(judge(s)){\n      return n-1;\n    }\n    mat[s]=n;\n    for(int i=0;i<s.size()-1;i++){\n      if(s[i]!=s[i+1]){\n        string t=s;\n        char ch=getch(t[i],t[i+1]);\n        t[i]=t[i+1]=ch;\n        q.push(P(t,n));\n      }\n    }\n  }\n  return -1;\n}\n \nint main(void)\n{\n  string str;\n  while(cin>>str&&str!=\"0\"){\n    int res;\n    res = bfs(str);\n    if(~res)printf(\"%d\\n\",res);\n    else puts(\"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\nint cnt,ccnt = 0;\nint len;\nstring s, ss, tmp;\nint flag = 0;\nint fflag=0;\nchar c;\nint cc=0;\nvector<string> v_list;\npair<string,int> ps;\nmap<string,int> m;\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tfflag=0;\n\t\t//v_list.push_back(s);\n\t\tlen = s.length();\n\t\tqueue<pair<string,int> > qq;\n\t\tqq.push(make_pair(s,0));\n\t\twhile (!qq.empty()) {\n\t\t\tps = qq.front();\n\t\t\tqq.pop();\n\t\t\tc = ps.first[0];\n\t\t\tccnt=ps.second;\n\t\t\tflag = 0;\n\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tif (c != ps.first[i]) {\n\t\t\t\t\t//cout<<ps.first[i]<<endl;//deb\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tcc=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int i = cc-1; i < len - 1; ++i) {\n\t\t\t\t\ttmp = ps.first;\n\t\t\t\t\tif (ps.first[i] != ps.first[i+1]) {\n\t\t\t\t\t\tif (ps.first[i] != 'r' && ps.first[i+1] != 'r') {\n\t\t\t\t\t\t\ttmp[i] = 'r';\n\t\t\t\t\t\t\ttmp[i + 1] = 'r';\n\t\t\t\t\t\t\tif(m[tmp])continue;\n\t\t\t\t\t\t\tm[tmp]=ps.second;\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'g' && ps.first[i+1] != 'g' ){\n\t\t\t\t\t\t\ttmp[i] = 'g';\n\t\t\t\t\t\t\ttmp[i + 1] = 'g';\n\t\t\t\t\t\t\tif(m[tmp])continue;\n\t\t\t\t\t\t\tm[tmp]=ps.second;\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'b' && ps.first[i+1] != 'b') {\n\t\t\t\t\t\t\ttmp[i] = 'b';\n\t\t\t\t\t\t\ttmp[i + 1] = 'b';\n\t\t\t\t\t\t\tif(m[tmp])continue;\n\t\t\t\t\t\t\tm[tmp]=ps.second;\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcout << ccnt << endl;\n\t\t\t\tfflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!fflag){printf(\"NA\");cout<<endl;};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nstring col = \"rgb\";\n\nint main() {\n  \n  string worm;\n  while(cin >> worm) {\n    if(worm==\"0\") break;\n    int const wsize = worm.size();\n    set<string> used;\n    queue<pair<int, string> > q;\n    q.push(make_pair(0, worm));\n    bool flg = false;\n    while(!q.empty()) {\n      int cost = q.front().first; worm = q.front().second; q.pop();\n      if(used.count(worm)) continue;\n      used.insert(worm);\n      bool check = true;\n      for(int i=0; i<wsize-1; i++) check = check && worm[i] == worm[i+1];\n      if(check) {\n        flg = true;\n        cout << cost << endl;\n        break;\n      }\n      for(int i=0; i<wsize-1; i++) {\n        if(worm[i]!=worm[i+1]) {\n          char next;\n          for(int j=0; j<3; j++) {\n            if(worm[i] == col[j]) continue;\n            if(worm[i+1] == col[j]) continue;\n            next = col[j];\n          }\n          string nworm = worm;\n          nworm[i] = nworm[i+1] = next;\n          if(used.count(nworm)) continue;\n          q.push(make_pair(cost+1, nworm));\n        }\n      }\n    }\n    if(!flg) cout << \"NA\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\n\nchar worm[12];\nint ans;\nbool flag;\nvoid bfs(){\n  string change;\n  map<string,int> used;\n  queue<string> que;\n  queue<int> zikan;\n  que.push(worm);\n  zikan.push(0);\n  while(!que.empty()){\n    string str = que.front();\n    ans = zikan.front();\n    que.pop();\n    zikan.pop();\n    for(int i = 0;i < str.length()-1;i++){//変化した状態が題意を満たすかチェック\n      if(str[i] !=str[i+1]){\n\tbreak;\n      }\n      if(i ==str.length()-2){\n\tflag = true;\n\treturn;\n      }\n    }\n    for(int i = 0;i <strlen(worm)-1;i++){\n      if(str[i]=='r'&&str[i+1]!='r'){\n\tif(str[i+1]=='b'){\n\t  change = str;\n\t  change[i] ='g';\n\t  change[i+1]='g';\n\t  if(used[change]==1){\n\t    continue;\n\t  }\n\t  que.push(change);\n\t  zikan.push(ans+1);\n\t  used[change]=1;\n\t}else if(str[i+1]=='g'){\n\t  change = str;\n\t  change[i] ='b';\n\t  change[i+1]='b';\n\t  if(used[change]==1){\n\t    continue;\n\t  }\n\t  que.push(change);\n\t  zikan.push(ans+1);\n\t  used[change]=1;\n\t}\n      }else if(str[i] =='b'&&str[i+1]!='b'){\n\tif(str[i+1]=='r'){\n\t  change = str;\n\t  change[i] ='g';\n\t  change[i+1]='g';\n\t  if(used[change]==1){\n\t    continue;\n\t  }\n\t  que.push(change);\n\t  zikan.push(ans+1);\n\t  used[change]=1;\n\t}else if(str[i+1]=='g'){\n\t  change = str;\n\t  change[i] ='r';\n\t  change[i+1]='r';\n\t  if(used[change]==1){\n\t    continue;\n\t  }\n\t  que.push(change);\n\t  zikan.push(ans+1);\n\t  used[change]=1;\n\t}\n      }\n      else if(str[i]=='g'&&str[i+1]!='g'){\n\tif(str[i+1]=='b'){\n\t  change = str;\n\t  change[i] ='r';\n\t  change[i+1]='r';\n\t  if(used[change]==1){\n\t    continue;\n\t  }\n\t  que.push(change);\n\t  zikan.push(ans+1);\n\t  used[change]=1;\n\t}else if(str[i+1]=='r'){\n\t  change = str;\n\t  change[i] ='b';\n\t  change[i+1]='b';\n\t  if(used[change]==1){\n\t    continue;\n\t  }\n\t  que.push(change);\n\t  zikan.push(ans+1);\n\t  used[change]=1;\n\t}\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(cin>>worm){\n    ans = 0;\n    if(worm[0]=='0')\n      return 0;\n    flag = false;\n    bfs();\n    if(flag)\n      cout <<ans<<endl;\n    else\n      cout <<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint ans = 0;\nint s_size;\n\nstring change(string s, int a, int b){\n\tif((s[a] == 'r' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'r'))\n\t\ts[b] = s[a] = 'b';\n\telse if((s[a] == 'b' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'b'))\n\t\ts[b] = s[a] = 'r';\n\telse\n\t\ts[b] = s[a] = 'g';\n\t\n\treturn s;\n}\n\nvoid bfs(string s, int res){\n\tif(res >= ans)\n\t\treturn;\n\tfor(int i = 0; i < s_size - 1; ++i){\n\t\tif(s[i] != s[i + 1])\n\t\t\tbreak;\n\t\tif(i == s_size - 2){\n\t\t\tans = min(res, ans);\n\t\t\treturn;\n\t\t}\n\t}\n\tif(res >= s_size)\n\t\treturn;\n\tfor(int i = 0; i < s_size - 1; ++i){\n\t\tif(s[i] != s[i + 1]){\n\t\t\tstring str = change(s, i, i + 1);\n\t\t\tbfs(str, res + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s == \"0\")\n\t\t\tbreak;\n\t\ts_size = s.size();\n\t\tans = INF;\n\t\tbfs(s, 0);\n\t\tif(ans == INF)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct data{\n\tstring str;\n\tint cnt;\n\tdata(){}\n\tdata(string str,int cnt):str(str),cnt(cnt){}\n};\nstring func(string str,int i) {\n\tint r,g,b;\n\tchar change;\n\tif(str[i] == 'r') {\n\t\tif(str[i+1] == 'g') change='b';\n\t\telse if(str[i+1] == 'b') change = 'g';\n\t\telse return str;\n\t}\n\telse if(str[i] == 'g') {\n\t\tif(str[i+1] == 'r') change='b';\n\t\telse if(str[i+1] == 'b') change = 'r';\n\t\telse return str;\n\t}\n\telse {\n\t\tif(str[i+1] == 'g') change = 'r';\n\t\telse if(str[i+1] == 'r') change = 'g';\n\t\telse return str;\n\t}\n\tstr[i] = change;\n\tstr[i+1] = change;\n\treturn str;\n}\nbool check(string str) {\n\tchar c = str[0];\n\tfor(int i = 1; i < str.size(); i++) {\n\t\tif(str[i] != c) return false;\n\t}\n\treturn true;\n}\nint main() {\n\tstring str;\n\twhile(1) {\n\t\tcin >> str;\n\t\tif(str == \"0\") break;\n\t\tint ans = -1;\n\t\tmap<string,bool> memo;\n\t\tqueue<data> Q;\n\t\tQ.push(data(str,0));\n\t\twhile(!Q.empty()) {\n\t\t\tdata d = Q.front();Q.pop();\n\t\t\tif(memo[d.str]) continue;\n\t\t\tmemo[d.str] = true;\n\t\t\tif(check(d.str)) {\n\t\t\t\tans = d.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < d.str.size() - 1; i++) {\n\t\t\t\tstring nstr = func(d.str,i);\n\t\t\t\tif(nstr == d.str) continue;\n\t\t\t\tQ.push(data(nstr,d.cnt+1));\n\t\t\t}\n\t\t}\n\t\tif(ans == -1) puts(\"NA\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\nchar change(char,char);\nint ok(string);\nint BFS(string);\n\nint main(void){\n  string s;\n  \n  while(cin >> s){\n    if(s==\"0\")break;\n    \n    int res=BFS(s);\n    \n    if(res>=0)cout << res << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}\n\nchar change(char c1,char c2){\n  string s=\"rgb\";\n  if(c1==c2)return '*';\n  for(int i=0;i<3;i++){\n    if(c1!=s[i] && c2!=s[i])return s[i];\n  }\n}\n\nint ok(string s){\n  for(int i=0;i<s.length()-1;i++)\n    if(s[i]!=s[i+1])return 0;\n  return 1;\n}\n\nint BFS(string s){\n  queue<string>Q;\n\n  map<string,int>dist;\n  Q.push(s);\n  dist[s]=1;\n\n  while(!Q.empty()){\n    string now=Q.front();\n    Q.pop();\n\n    if(ok(now))return dist[now]-1;\n\n    for(int i=0;i<now.length()-1;i++){\n      char res=change(now[i],now[i+1]);\n      if(res=='*')continue;\n\n      string tmp=now;\n      tmp[i]=tmp[i+1]=res;\n      if(dist[tmp]==0){\n\tdist[tmp]=dist[now]+1;\n\tQ.push(tmp);\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\nclass Data{\npublic:\n    string bc;\n    int t;\n    Data(string bc,int t):bc(bc),t(t){}\n    Data(){}\n};\nbool judge(string s,int l){\n    for(int i=0;i<l-1;++i){\n        if(s[i]!=s[i+1])return false;\n    }\n    return true;\n}\nchar cj(char a,char b){\n    if(a=='b'&&b=='g')return 'r';\n    if(a=='b'&&b=='r')return 'g';\n    if(a=='g'&&b=='r')return 'b';\n    swap(a,b);\n    if(a=='b'&&b=='g')return 'r';\n    if(a=='b'&&b=='r')return 'g';\n    if(a=='g'&&b=='r')return 'b';\n}\nint main()\n{\n    string s;\n    while(cin>>s,s!=\"0\")\n    {\n        int l=s.length();\n        int res=-1;\n        queue<Data> Q;\n        set<string> visited;\n        Q.push(Data(s,0));\n        while(!Q.empty())\n        {\n            Data t=Q.front();\n            Q.pop();\n            if(visited.count(t.bc))continue;\n            if(judge(t.bc,l)){\n                res=t.t;\n                break;\n            }\n            visited.insert(t.bc);\n            for(int i=0;i<l-1;++i){\n                if(t.bc[i]==t.bc[i+1])continue;\n                char nc=cj(t.bc[i],t.bc[i+1]);\n                string nbc=t.bc;\n                nbc[i]=nbc[i+1]=nc;\n                Q.push(Data(nbc,t.t+1));\n            }\n        }\n        if(res==-1)\n                cout<<\"NA\"<<endl;\n        else\n                cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n\tqueue<P> que;\n\tque.push(P(worm, 0));\n\n\tmap<string, int> d;\n\t\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\t//d¡p^[Ícontinue\n\t\tif(d[p.first]) continue;\n\n\t\tstring str = p.first;\n\n\t\t//SF¯¶©Ç¤©Ì`FbN\n\t\tbool flag = false;\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//¯¶Èçreturn\n\t\tif(!flag) return p.second;\n\n\t\t//d¡p^[»Êp\n\t\td[p.first] = p.second;\n\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\t//×èí¹ÅFªÙÈéÆ«\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\n\t\t\t\t//tempÉÜÜêÈ¢êFðãü\n\t\t\t\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t\t\t\t\ttemp = 'b';\n\t\t\t\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t\t\t\t\ttemp = 'g';\n\t\t\t\t}else{\n\t\t\t\t\ttemp = 'r';\n\t\t\t\t}\n\n\t\t\t\t//Ï»ãÌÔðnextÉlßÞ\n\t\t\t\tnext = str;\n\t\t\t\tnext[i] = next[i+1] = temp;\n\n\t\t\t\t//L[ÉvbV\n\t\t\t\tque.push(P(next, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring worm;\n\twhile(cin >> worm && worm != \"0\"){\n\t\tint ret = bfs(worm);\n\t\tif(ret>=0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nstruct bug{\n\tstring name;\n\tint tim;\n};\n\nint main()\n{\n\tstring worm;\n\twhile(cin >> worm){\n\t\tif(worm == \"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tmap<string,int> memo;\n\t\tbug w;\n\t\tw.name = worm;\n\t\tw.tim = 0;\n\t\tqueue<bug> que;\n\t\tque.push(w);\n\t\tbool fl = false;\n\t\twhile(que.size()){\n\t\t\tbug tmp = que.front();\n\t\t\tque.pop();\n\t\t\t//êF»è\n\t\t\tbool flag = true;\n\t\t\tfor(int i=0;i<tmp.name.size();i++){\n\t\t\t\tif(tmp.name[0] != tmp.name[i]){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfl = true;\n\t\t\t\tcout << tmp.tim << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//êxo½©»è\n\t\t\tif(memo.find(tmp.name) != memo.end())\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tmemo[tmp.name] = tmp.tim;\n\n\t\t\t//ÇÁ\n\t\t\tfor(int i=0;i<tmp.name.size();i++){\n\t\t\t\tif(tmp.name[i] != tmp.name[i+1]){\n\t\t\t\t\tbug t = tmp;\n\t\t\t\t\tif((tmp.name[i] == 'r' && tmp.name[i+1] == 'g') || (tmp.name[i] == 'g' && tmp.name[i+1] == 'r') ){\n\t\t\t\t\t\tt.name[i] = 'b'; t.name[i+1] = 'b';\n\t\t\t\t\t}else if((tmp.name[i] == 'g' && tmp.name[i+1] == 'b') || (tmp.name[i] == 'b' && tmp.name[i+1] == 'g') ){\n\t\t\t\t\t\tt.name[i] = 'r'; t.name[i+1] = 'r';\n\t\t\t\t\t}else if((tmp.name[i] == 'b' && tmp.name[i+1] == 'r') || (tmp.name[i] == 'r' && tmp.name[i+1] == 'b') ){\n\t\t\t\t\t\tt.name[i] = 'g'; t.name[i+1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tt.tim++;\n\t\t\t\t\tque.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!fl)\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nbool hantei (string a) {\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (a[0] == a[i]) {\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tstring a;\n\tstring abc = \"rgb\";\n\twhile (getline(cin, a)) {\n\t\tif (a[0] == '0') {\n\t\t\tbreak;\n\t\t}\n\t\tqueue<P> q;\n\t\tq.push(P(a, 0));\n\t\tbool han = true;\n\t\tint t;\n\t\tset<string> s;\n\t\tif (hantei(a)) {\n\t\t\than = false;\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\t\t\tstring pp = p.first;\n\t\t\tfor (int i = 0; i < pp.size()-1; i++) {\n\t\t\t\tif (!han) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pp[i] == pp[i+1]) {\n\t\t\t\t} else {\n\t\t\t\t\tstring qq = pp;\n\t\t\t\t\tint v, w;\n\t\t\t\t\tfor (int j = 0; j < abc.size(); j++) {\n\t\t\t\t\t\tif (abc[j] == pp[i]) {\n\t\t\t\t\t\t\tv = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (abc[j] == pp[i+1]) {\n\t\t\t\t\t\t\tw = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tqq[i] = qq[i+1] = abc[3-(v+w)];\n\t\t\t\t\tif (hantei(qq)) {\n\t\t\t\t\t\than = false;\n\t\t\t\t\t\tcout << p.second+1 << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (s.find(qq) == s.end()) {\n\t\t\t\t\t\ts.insert(qq);\n\t\t\t\t\t\tq.push(P(qq, p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (han) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nmap<char, int>chmp;\n\nint main() {\n\tchmp['r'] = 0;\n\tchmp['g'] = 1;\n\tchmp['b'] = 2;\n\twhile (1) {\n\n\t\tstring st; cin >> st;\n\t\tif (st == \"0\")break;\n\t\tvector<int>nums;\n\t\tfor (auto c : st) {\n\t\t\tnums.emplace_back(chmp[c]);\n\t\t}\n\n\t\tmap<vector<int>, int>mp;\n\t\tqueue<pair<int,vector<int>>>que;\n\t\tque.push(make_pair(0,nums));\n\t\tint ans = 1e8;\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tif (mp.find(p.second) != mp.end())continue;\n\t\t\tmp[p.second];\n\t\t\tif (all_of(p.second.begin(), p.second.end(), [=](const int n) {return n == p.second[0]; })) {\n\t\t\t\tans = p.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int>st(p.second);\n\t\t\tfor (int i = 0; i < st.size() - 1; ++i) {\n\t\t\t\tif (st[i] != st[i + 1]) {\n\t\t\t\t\tvector<int>nowst(st);\n\t\t\t\t\tnowst[i] = 3 - st[i] - st[i + 1];\n\t\t\t\t\tnowst[i + 1] = 3 - st[i] - st[i + 1];\n\t\t\t\t\tque.push(make_pair(p.first + 1, nowst));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans > 1e7) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<string>\n#include<iostream>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nbool isHomochrome(int stat,int len){\n\tint color=stat&3;\n\tfor(int i=0;i<len;i++,stat>>=2)\tif((stat&3)!=color)\treturn false;\n\treturn true;\n}\n\nint getColor(int stat,int i){\n\treturn (stat>>(2*i))&3;\n}\n\nvoid setColor(int &stat,int i,int c){\n\tstat&=~(3<<(2*i));\n\tstat|=c<<(2*i);\n}\n\nint main(){\n\tstatic int memo[1<<20];\n\tfor(string worm;cin>>worm,worm!=\"0\";){\n\t\tint len=worm.length();\n\t\tfor(int i=0;i<(1<<(2*len));i++)\tmemo[i]=1<<30;\n\n\t\tint inistat=0;\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(worm[i]=='r')\tinistat=(inistat<<2)+0;\n\t\t\tif(worm[i]=='g')\tinistat=(inistat<<2)+1;\n\t\t\tif(worm[i]=='b')\tinistat=(inistat<<2)+2;\n\t\t}\n\n\t\tint ans=-1;\n\t\tmemo[inistat]=0;\n\t\tqueue<pii> qu;\tqu.push(mp(0,inistat));\n\t\twhile(!qu.empty()){\n\t\t\tpii a=qu.front();\tqu.pop();\n\t\t\tint t=a.first,stat=a.second;\n\t\t\tif(isHomochrome(stat,len)){ ans=t; break; }\n\t\t\tfor(int i=0;i<len-1;i++){\n\t\t\t\tint clr[]={getColor(stat,i),getColor(stat,i+1)};\n\t\t\t\tif(clr[0]!=clr[1]){\n\t\t\t\t\tint nextclr;\n\t\t\t\t\tfor(int c=0;c<=2;c++)\tif(clr[0]!=c && clr[1]!=c)\tnextclr=c;\n\t\t\t\t\tint nextstat=stat;\n\t\t\t\t\tsetColor(nextstat,i  ,nextclr);\n\t\t\t\t\tsetColor(nextstat,i+1,nextclr);\n\t\t\t\t\tif(t+1<memo[nextstat]){\n\t\t\t\t\t\tqu.push(mp(t+1,nextstat));\n\t\t\t\t\t\tmemo[nextstat]=t+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(~ans)\tcout<<ans<<endl;\n\t\telse\t\tcout<<\"NA\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\ntypedef pair<string,int> SI;\n\nbool ok(string s)\n{\n  char c = s[0];\n  for(int i=0;i<s.length();i++)\n    if(c != s[i])\n      return false;\n  return true;\n}\n\nchar getc(char c,char cc)\n{\n  map<char,bool> index;\n  index['r'] = false,index['b'] = false,index['g'] = false;\n  index[c] = true;\n  index[cc] = true;\n  foreach(i,index)\n    if(!(*i).S)\n      return (*i).F;\n\n}\n\nint solve(string s)\n{\n\n  queue<SI> que;\n  que.push(SI(s,0));\n  map<string,bool> used;\n  while(!que.empty())\n    {\n      SI si = que.front(); que.pop();\n\n      if(used[si.F])\n\tcontinue;\n\n      used[si.F] = true;\n \n      if(ok(si.F))\n\t{\n\t  return si.S;\n\t}\n\n      if(si.S > 10)\n\tcontinue;\n\n      rep(i,si.F.length()-1)\n\t{\n\t  if(si.F[i] == si.F[i+1])\n\t    continue;\n\t  string news = si.F;\n\t  news[i] = news[i+1] = getc(si.F[i],si.F[i+1]);\n\t  que.push(SI(news,si.S+1));\n\t}\n\n    }\n\n  return -1;\n}\n\n\nint main(){\n\n  while(true)\n    {\n      string s;\n      cin >> s;\n      if(s[0] == '0')\n\tbreak;\n\n      int ans = solve(s);\n      ans != -1?cout << ans << endl:cout << \"NA\" << endl;\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\n//????????????????????????????????????\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\n//??£?????????2?????????????????§?????????????????????\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s ){\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\t//?????\\??????????????¶????????\\??????\n\n\twhile (!q.empty()) {\t//?????\\??????????????¶?????????????????§\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif(m[p.first]) continue;\t//??????????????????\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tm[p.first] = 1;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\t//??£?????????2????????°????????¨???\n\t\t\t\tchar tmp = color(now[i], now[i + 1]);\n\t\t\t\tstring D = now;\n\t\t\t\tD[i] = tmp;\n\t\t\t\tD[i + 1] = tmp;\n\t\t\t\tq.push(P(D, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<string, int> P;\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str[0] == '0')\n\t\t\tbreak;\n\t\tint count = -1;\n\t\tmap<string,bool> mp;\n\t\tqueue<P> que;\n\t\tP p;p.first = str;p.second = 0;\n\t\tque.push(p);\n\t\twhile(que.size()){\n\t\t\tP s = que.front();que.pop();\n\t\t\tif(mp.find(s.first)!=mp.end())\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tmp[s.first] = true;\n\n\t\t\tif(s.second > 10)\n\t\t\t\tbreak;\n\n\t\t\tbool is_all = true;\n\t\t\tfor(unsigned i=1;i<s.first.size();i++){\n\t\t\t\tif(s.first[0] != s.first[i]){\n\t\t\t\t\tis_all = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_all){\n\t\t\t\tcount = s.second;\n\t\t\t}\n\n\t\t\tint a=0;\n\t\t\tfor(unsigned i=0;i<s.first.size()-1;i++){\n\t\t\t\tP ss = s;\n\t\t\t\tif((ss.first[i] != ss.first[i+1])){\n\t\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'r')){\n\t\t\t\t\t\tss.first[i] = 'b';ss.first[i+1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'b') || (ss.first[i] == 'b' && ss.first[i+1] == 'r')){\n\t\t\t\t\t\tss.first[i] = 'g';ss.first[i+1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif((ss.first[i] == 'b' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'b')){\n\t\t\t\t\t\tss.first[i] = 'r';ss.first[i+1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tss.second = s.second+1;\n\t\t\t\t\tque.push(ss);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n\nclass Insect{\npublic:\n  string body;\n  int sec;\n  Insect(string body, int sec): body(body), sec(sec) {}\n};\n\nbool isOneColor(string str) {\n  char c = str[0];\n  for(int i = 1; i < str.length(); i++) {\n    if(str[i] != c) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(1) {\n    string str;\n    getline(cin, str);\n    if(str == \"0\") break;\n\n    map<string, bool> visited;\n    queue<Insect> Q;\n    Q.push(Insect(str, 0));\n    visited[str] = true;\n\n    int sec = -1;\n    while(!Q.empty()) {\n      Insect s = Q.front();\n      Q.pop();\n      \n      if(isOneColor(s.body)) {\n\tsec = s.sec;\n\tbreak;\n      }\n\n      for(int i = 0; i+1 < s.body.length(); i++) {\n\tif(s.body[i] != s.body[i+1]) {\n\t  string temp = s.body;\n\t  if(s.body[i] != 'r' && s.body[i+1] != 'r')\n\t    temp[i] = temp[i+1] = 'r';\n\t  if(s.body[i] != 'g' && s.body[i+1] != 'g')\n\t    temp[i] = temp[i+1] = 'g';\n\t  if(s.body[i] != 'b' && s.body[i+1] != 'b')\n\t    temp[i] = temp[i+1] = 'b';\n\n\t  if(!visited[temp]) {\n\t    Q.push(Insect(temp, s.sec+1));\n\t    visited[temp] = true;\n\t  }\n\t}\n      }\n    }\n\n    if(sec == -1) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << sec << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint base[11];\n\nint enc(int n, const int *c) {\n  int r = 0;\n  for (int i=0; i<n; i++) {\n    r += c[i] * base[i];\n  }\n  return r;\n}\n\nvoid dec(int n, int p, int *c) {\n  int t = p;\n  for (int i=0; i<n; i++) {\n    c[i] = t % 3; \n    t /= 3;\n  }\n}\n\nint main() {\n  string line;\n  int n, c0, rr, gg, bb, c, m, t1, t2, t3;\n  int color[10];\n  bool used[60000];\n  bool found;\n  queue<P> q;\n\n  base[0] = 1;\n  for (int i=1; i<=10; i++) {\n    base[i] = base[i-1]*3;\n  }\n\n  while (1) {\n    getline(cin, line);\n    if (line == \"0\") break;\n    n = line.length();\n    for (int i=0; i<n; i++) {\n      if (line[i] == 'r') {\n        color[i] = 0;\n      } else if (line[i] == 'g') {\n        color[i] = 1;\n      } else {\n        color[i] = 2;\n      }\n    }\n    for (int i=0; i<base[n]; i++) {\n      used[i] = false;\n    }\n\n    while (!q.empty()) q.pop();\n    c0 = enc(n, color);\n    for (int i=0; i<n; i++) color[i] = 0;\n    rr = enc(n, color);\n    for (int i=0; i<n; i++) color[i] = 1;\n    gg = enc(n, color);\n    for (int i=0; i<n; i++) color[i] = 2;\n    bb = enc(n, color);\n    found = false;\n    q.push(make_pair(c0, 0));\n    used[c0] = true;\n    while (!q.empty()) {\n      c = q.front().first;\n      m = q.front().second;\n      q.pop();\n      if (c == rr || c == gg || c == bb) {\n        found = true;\n        break;\n      }\n      dec(n, c, color);\n      for (int i=0; i<n-1; i++) {\n        if (color[i] != color[i+1]) {\n          t1 = color[i];\n          t2 = color[i+1];\n          t3 = 3 - t1 - t2;\n          color[i] = color[i+1] = t3;\n          c = enc(n, color);\n          color[i] = t1;\n          color[i+1] = t2;\n          if (used[c]) continue;\n          q.push(make_pair(c, m+1));\n          used[c] = true;\n        }\n      }\n    }\n    if (!found) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << m << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\n//????????????????????????????????????\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\n//??£?????????2?????????????????§?????????????????????\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s ){\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\t//?????\\??????????????¶????????\\??????\n\n\twhile (!q.empty()) {\t//?????\\??????????????¶?????????????????§\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\t//??£?????????2????????°????????¨???\n\t\t\t\tchar tmp = color(now[i], now[i + 1]);\n\t\t\t\tstring D = now;\n\t\t\t\tD[i] = tmp;\n\t\t\t\tD[i + 1] = tmp;\n\t\t\t\tq.push(P(D, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<stdlib.h>\n#include<set>\n#include<string>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\n\nint main(){\n\n\n\n\tstring start_str;\n\n\tcin >> start_str;\n\n\tdo{\n\n\t\tint ans = -1;\n\n\t\tqueue< pair<int, string> > que;\t//待ち行列 \n\n\t\tset<string> check_str;\n\n\t\tque.push(make_pair(0 , start_str));\n\t\twhile (que.size()){\n\n\t\t\tstring str;\n\t\t\tstring sstr;\t//色が変わったとき用\n\n\t\t\tint TIME = que.front().first;\n\t\t\tstr = que.front().second;\t//キューの先頭にある要素を取り出す\n\t\t\tque.pop();\t\t\t\t\t//キューからポップする\n\t\t\tfor (int i = 0; i < str.size() - 1; i++){\n\t\t\t\tif (str[i] != str[i + 1]){\n\t\t\t\t\tsstr = str;\n\t\t\t\t\tif (str[i] != 'r' && str[i + 1] != 'r'){\n\t\t\t\t\t\tsstr[i] = 'r'; sstr[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if (str[i] != 'b' && str[i + 1] != 'b'){\n\t\t\t\t\t\tsstr[i] = 'b'; sstr[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsstr[i] = 'g'; sstr[i + 1] = 'g';\n\t\t\t\t\t}\n\n\t\t\t\t\t//cout << \"TIME: \" << TIME + 1 << \"sstr: \" << sstr << endl;\n\n\t\t\t\t\tif (sstr == start_str){\t//変化した状態とスタートの状態が同じであったら\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (check_str.find(sstr) != check_str.end()){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int j = 0; j < sstr.size() - 1; j++){\n\t\t\t\t\t\tif (sstr[j] != sstr[j + 1]){\n\t\t\t\t\t\t\tcheck_str.insert(sstr);\n\t\t\t\t\t\t\tque.push(make_pair(TIME + 1, sstr));\t//make_pairは標準\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (j == sstr.size() - 2){\t//一色に染まってたら\n\t\t\t\t\t\t\tans = TIME + 1;\n\t\t\t\t\t\t\ti = str.size();\n\t\t\t\t\t\t\twhile (!que.empty())\n\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans == -1){\n\t\t\tfor (int i = 0;i < start_str.size() - 1;i++){\n\t\t\t\tif (start_str[i] != start_str[i + 1]){\n\t\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (i == start_str.size() - 2 ){\n\t\t\t\t\tcout << \"0\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tcin >> start_str;\n\t} while (start_str != \"0\");\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <string, int> P;\n\n#define mp(a, b) make_pair(a, b)\n\nchar diff(char a, char b)\n{\n\tif (a != 'r' && b != 'r') return 'r';\n\tif (a != 'g' && b != 'g') return 'g';\n\tif (a != 'b' && b != 'b') return 'b';\n\treturn 'a';\n}\n\nbool check(string str)\n{\n\tchar c = str[0];\n\tfor (int i = 0; i < str.length(); i++){\n\t\tif (c != str[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tstring str;\n\n\twhile (cin >> str){\n\t\tif (str == \"0\") return 0;\n\n\t\tint ret = -1, a;\n\t\tqueue < P > q;\n\t\tq.push(mp(str, 0));\n\t\twhile (!q.empty()){\n\t\t\tP now = q.front();\n\t\t\tq.pop();\n\t\t\tif (check(now.first)){\n\t\t\t\tret = now.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (q.size() > 800000){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < now.first.length()-1; i++){\n\t\t\t\tif (now.first[i] != now.first[i + 1]){\n\t\t\t\t\tstring tmp = now.first;\n\t\t\t\t\ttmp[i] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\ttmp[i + 1] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\tq.push(mp(tmp, now.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret >= 0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nstruct worm{\n\tint c;\n\tstring s;\n};\nqueue<worm> que;\nbool str_check(string str){\n\tfor(int i = 1;i < str.size();++i){\n\t\tif(str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\nint f(){\n\twhile(que.size()){\n\t\tworm w = que.front(),tmp;\n\t\tque.pop();\n\t\tint n = w.c;\n\t\tif(n > 9) break;\n\t\tstring str = w.s;\n\t\tif(str_check(str)){\n\t\t\treturn n;\n\t\t}\n\t\tfor(int i = 0;i < str.size() - 1;++i){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tif((str[i] == 'r' && str[i+1] == 'b') || (str[i] == 'b' && str[i+1] == 'r')){\n\t\t\t\t\tstr[i] = str[i+1] = 'g';\n\t\t\t\t}\n\t\t\t\telse if((str[i] == 'g' && str[i+1] == 'b') || (str[i] == 'b' && str[i+1] == 'g')){\n\t\t\t\t\tstr[i] = str[i+1] = 'r';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstr[i] = str[i+1] = 'b';\n\t\t\t\t}\n\t\t\t\ttmp.s = str;\n\t\t\t\ttmp.c = n + 1;\n\t\t\t\tque.push(tmp);\n\t\t\t\tstr = w.s;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\tstring str;\n\tworm w;\n\twhile(cin >> str){\n\t\tif(str == \"0\") break;\n\t\tw.s = str;\n\t\tw.c = 0;\n\t\tque.push(w);\n\t\tint n = f();\n\t\tif(n == -1) cout << \"NA\\n\";\n\t\telse cout << n << endl;\n\t\twhile(que.size()){\n\t\t\tque.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar c[3]={'r','g','b'};\nmain(){\n  string w;\n  while(cin>>w,w[0]!='0'){\n    set<string>a;\n    a.insert(w);\n    queue<pair<string,int> >q;\n    q.push(make_pair(w,0));\n    while(!q.empty()){\n      pair<string,int>ww=q.front();q.pop();\n      string s=ww.first;//cout<<s<<endl;\n      int d=ww.second;//cout<<d<<endl;\n      int cc=0;\n      for(int i=0;i<s.size()-1;i++)if(s[i]!=s[i+1])cc++;\n      if(!cc){cout<<d<<endl;goto L;}\n      for(int i=0;i<s.size()-1;i++){\n        if(s[i]!=s[i+1]){\n          int p=0;\n          for(int k=0;k<3;k++)\n            for(int j=0;j<3;j++)\n              if(s[i]==c[k]&&s[i+1]==c[j])p=k+j;\n          string t=s;\n          if(p==3)t[i+1]=t[i]='r';\n          else if(p==2)t[i+1]=t[i]='g';\n          else t[i+1]=t[i]='b';\n          if(!a.count(t)){//cout<<t<<endl;\n            q.push(make_pair(t,d+1));\n            a.insert(t);\n          }\n        }\n      }\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nint d[1 << 22];\nvoid p(int s, int n)\n{\n\tfor (int i = n-1; i >= 0; --i)\n\t{\n\t\tint t = (s & (3 << 2*i)) >> 2*i;\n\t\tif (t == 1)\n\t\t\tputchar('r');\n\t\telse if (t == 2)\n\t\t\tputchar('g');\n\t\telse if (t == 3)\n\t\t\tputchar('b');\n\t\telse\n\t\t\tputchar('*');\n\t}\n}\nint main()\n{\n\tchar buf[16];\n\twhile (cin.getline(buf, sizeof(buf)), *buf != '0')\n\t{\n\t\tint n = strlen(buf);\n\t\tint initial = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tif (buf[i] == 'r')\n\t\t\t\tt = 1;\n\t\t\telse if (buf[i] == 'g')\n\t\t\t\tt = 2;\n\t\t\telse\n\t\t\t\tt = 3;\n\n\t\t\tinitial = (initial << 2) | t;\n\t\t}\n\n\t\tmemset(d, -1, sizeof(d));\n\t\td[initial] = 0;\n\t\tqueue<int> state;\n\t\tstate.push(initial);\n\t\tint ans = -1;\n\t\twhile (!state.empty())\n\t\t{\n\t\t\tint s = state.front();\n\t\t\tstate.pop();\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < n-1; ++i)\n\t\t\t{\n\t\t\t\tint r = (s & (3 << 2*i)) >> 2*i;\n\t\t\t\tint l = (s & (3 << 2*(i+1))) >> 2*(i+1);\n\t\t\t\tbool same = l == r;\n\t\t\t\tok &= same;\n\t\t\t\tif (!same)\n\t\t\t\t{\n\t\t\t\t\tint color = -1;\n\t\t\t\t\tfor (int j = 1; j <= 3; ++j)\n\t\t\t\t\t\tif (j != l && j != r)\n\t\t\t\t\t\t\tcolor = j;\n\t\t\t\t\tint next = s & ~(15 << 2*i) | (5*color << 2*i);\n\t\t\t\t\tif (d[next] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[next] = d[s] + 1;\n\t\t\t\t\t\tstate.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tans = d[s];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define P pair<int,int>\n#define pb push_back\n\nchar c[]={'r','g','b'};\nstring s;\n\nint main(){\n\twhile(cin>>s&&s!=\"0\"){\n\t\tmap<string,int> M;\n\t\tqueue<string> Q;\n\t\tM[s]=0;\n\t\tQ.push(s);\n\t\tint ans=INF;\n\t\twhile(Q.size()){\n\t\t\tstring s=Q.front();\n\t\t\tint step=M[s],same=0;\n\t\t\tQ.pop();\n\t\t\trep(i,s.size()-1){\n\t\t\t\tif(s[i]!=s[i+1]){\n\t\t\t\t\tchar a=s[i],b=s[i+1];\n\t\t\t\t\trep(j,3){\n\t\t\t\t\t\tif(s[i]!=c[j]&&s[i+1]!=c[j]){\n\t\t\t\t\t\t\ts[i]=s[i+1]=c[j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!M[s]){\n\t\t\t\t\t\tM[s]=step+1;\n\t\t\t\t\t\tQ.push(s);\n\t\t\t\t\t}\n\t\t\t\t\ts[i]=a;s[i+1]=b;\n\t\t\t\t}\n\t\t\t\telse same++;\n\t\t\t}\n\t\t\tif(same==s.size()-1){\n\t\t\t\tans=step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<string, int> P;\n\nvoid solve()\n{\n\tstring str;\n\twhile(cin >> str)\n\t{\n\t\tif(str == \"0\")\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int j = 0; j < str.size() - 1; ++j)\n\t\t{\n\t\t\tif(str[j] != str[j + 1])\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> Que;\n\t\tQue.push(make_pair(str, 0));\n\t\tqueue<P> NextQue;\n\t\tmap<string, int> Map;\n\t\tint step = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tif(step == str.size())\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < str.size() - 1; ++i)\n\t\t\t\t{\n\t\t\t\t\tstring body = Que.front().first;\n\t\t\t\t\tif(body[i] == 'b' && body[i + 1] == 'g')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'b' && body[i + 1] == 'r')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'g' && body[i + 1] == 'b')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'g' && body[i + 1] == 'r')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'r' && body[i + 1] == 'b')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'r' && body[i + 1] == 'g')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor(int j = 0; j < str.size() - 1; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(body[j] != body[j + 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << Que.front().second + 1 << endl;\n\t\t\t\t\t\tgoto NEXT;\n\t\t\t\t\t}\n\t\t\t\t\tif(!Map[body])\n\t\t\t\t\t{\n\t\t\t\t\t\tNextQue.push(make_pair(body, Que.front().second + 1));\n\t\t\t\t\t}\n\t\t\t\t\tMap[body]++;\n\t\t\t\t}\n\t\t\t\tQue.pop();\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t\t++step;\n\t\t}\nNEXT:\n\t\t;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\nusing namespace std;\nint main(){\n\t\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tset<string> seto;\n\t\tqueue<string> q; \n\t\tint count=0;\n\t\tbool f=false;\n\t\tq.push(s);\n\t\tseto.insert(s);\n\t\twhile(!q.empty()){\n\t\t\tint k=q.size();\n\t\t\twhile(k>0){\n\t\t\tstring n=q.front();\n\t\t\t\t\t f=true;\n\t\t\tfor(int i=0;i<s.size();i++){\n\t\t\t\tif(n[0]!=n[i]){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<s.size()-1;i++){\n\t\t\t\tstring n=q.front();\n\t\t\t\tif(n[i]=='r'&&n[i+1]=='b'||n[i]=='b'&&n[i+1]=='r'){\n\t\t\t\t\t\tn[i]='g';\n\t\t\t\t\t\tn[i+1]='g';\n\t\t\t\t}\n\t\t\t\telse if(n[i]=='b'&&n[i+1]=='g'||n[i]=='g'&&n[i+1]=='b'){\n\t\t\t\t\t\tn[i]='r';\n\t\t\t\t\t\tn[i+1]='r';\n\t\t\t\t}\n\t\t\t\telse if(n[i]=='r'&&n[i+1]=='g'||n[i]=='g'&&n[i+1]=='r'){\n\t\t\t\t\t\tn[i]='b';\n\t\t\t\t\t\tn[i+1]='b';\n\t\t\t\t}\n\t\t\t\tset<string>::iterator a=seto.find(n);\n\t\t\t\tif(a==seto.end()){\n\t\t\t\t\tq.push(n);\n\t\t\t\t\tseto.insert(n);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.pop();\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tcout<<count<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\n\t\t\t\n\t}\n\t\n\t\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\nusing namespace std;\n\ntypedef pair<string,int> P;\n\nint main()\n{\n  for(;;)\n    {\n      string str;\n      cin>>str;\n      if(str==\"0\")\n\tbreak;\n      queue<P> qu;\n      set<string> hash;       \n      qu.push(P(str,0));\n      hash.insert(str);\n      int ans=-1;\n      while(!qu.empty())\n\t{\n\t  P a= qu.front();\n\t  qu.pop();\n\t  int count=0;\n\t \n\t  string t=a.first;\n\t  for(int i=0;i<t.size()-1;i++)\n\t    {\n\t      if(t[i]!=t[i+1])\n\t\t{\n\t\t  string x=t; \n\t\t  if((x[i]=='r'&&x[i+1]=='g') ||(x[i]=='g'&&x[i+1]=='r'))\n\t\t    x[i]='b',x[i+1]='b';\n\t\t  if((x[i]=='r'&&x[i+1]=='b') ||(x[i]=='b'&&x[i+1]=='r'))\n\t\t    x[i]='g',x[i+1]='g';\n\t\t  if((x[i]=='g'&&x[i+1]=='b') ||(x[i]=='b'&&x[i+1]=='g'))\n\t\t    x[i]='r',x[i+1]='r';\n\t\t  if(hash.find(x)==hash.end())\n\t\t    {\n\t\t      hash.insert(x);\n\t\t      qu.push(P(x,a.second+1));\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  count++;\n\t\t}\n\t    }\n\t  if(count==t.size()-1)\n\t    {\n\t      ans=a.second;\n\t      break;\n\t    }\n\t}\n      if(ans==-1)\n\t  cout<<\"NA\"<<endl;            \n\telse\n\t  cout<<ans<<endl;            \n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<int> vi;\nauto ok = [](const vi & v){\n    for (int i = 1; i < v.size(); i++){\n        if (v[i] != v[0]) return false;\n    }\n    return true;\n};\n\nstruct state {\n    vi v;\n    int n;\n};\n\nnamespace std{\n    ostream & operator<<(ostream & os, const vi & v){\n        os << '(';\n        for (int i = 0; i < v.size(); i++){\n            cout << v[i] << ',';\n        }\n        os << ')';\n        return os;\n    }\n}\n\nint main(){\n    string s;\n    while (cin >> s, s!=\"0\"){\n        vi init(s.size());\n        for (int i = 0; i < s.size(); i++){\n            if (s[i] == 'r') init[i] = 0;\n            else if (s[i] == 'g') init[i] = 1;\n            else init[i] = 2;\n        }\n        queue<state> q;\n        set<vi> dp;\n        q.push({ init, 0 });\n\n        int ans = -1;\n        while (q.size()){\n            state sta = q.front();\n            q.pop();\n            vi & sv = sta.v;\n            //cout << sv << endl;\n            auto pr = dp.insert(sv);\n            if (!pr.second){\n                continue;\n            }\n            if (ok(sv)){\n                ans = sta.n;\n                break;\n            }\n            for (int i = 1; i < sv.size(); i++){\n                if (sv[i] != sv[i - 1]){\n                    int a = sv[i];\n                    int b = sv[i - 1];\n                    sv[i] = sv[i - 1] = 3 - (a + b);\n                    q.push({ sv, sta.n + 1 });\n                    sv[i] = a;\n                    sv[i - 1] = b;\n                }\n            }\n        }\n        if (ans == -1){\n            cout << \"NA\" << endl;\n        }\n        else{\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nint bfs( string str )\n{\n\tconst int N = str.size();\n\n\tqueue< pair< string, int > > que;\n\tque.push( MP( str, 0 ) );\n\n\tset< string > visited;\n\tvisited.insert( str );\n\n\tset< char > chars;\n\tchars.insert( 'r' );\n\tchars.insert( 'g' );\n\tchars.insert( 'b' );\n\n\twhile ( !que.empty() )\n\t{\n\t\tauto cur = que.front().fst;\n\t\tauto time = que.front().snd;\n\t\tque.pop();\n\n\t\tif ( set<char>( ALL( cur ) ).size() == 1 )\n\t\t{\n\t\t\treturn time;\n\t\t}\n\n\t\tREP( i, 0, N - 1 )\n\t\t{\n\t\t\tif ( cur[i] == cur[ i + 1 ] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tauto c = chars;\n\t\t\tc.erase( cur[i] );\n\t\t\tc.erase( cur[ i + 1 ] );\n\n\t\t\tauto next = cur;\n\t\t\tnext[i] = next[ i + 1 ] = *c.begin();\n\n\t\t\tif ( EXIST( visited, next ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tque.push( MP( next, time + 1 ) );\n\t\t\tvisited.insert( next );\n\t\t}\n\t}\n\n\treturn -1;\n}\t\t\t\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif ( str == \"0\" )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint res = bfs( str );\n\n\t\tif ( res == -1 )\n\t\t{\n\t\t\tcout << \"NA\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << res;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    que.push(pair<string, int>(worm, 0));\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        string worm1 = que.front().first;\n        int num = que.front().second;\n        que.pop();\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        if(num > 9){\n            return -1;\n        }\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            string tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define MAX_v 100\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<string,int> P;\nint main(){\n\tstring s;\n\twhile(cin >> s , s!=\"0\"){\n\t\tint len = s.size();\n\t\tint check = -1;\n\t\tqueue<P> Q;\n\t\tQ.push(P(s,0));\n\t\tset<string> vis;\n\t\twhile( Q.size() ){\n\t\t\tP p = Q.front();Q.pop();\n\t\t\tstring tmp = p.first;\n\t\t\tstring k = p.first;\n\t\t\t//cout << \"D:\" << tmp << endl;\n\t\t\tbool f = false;\n\t\t\tif(vis.find(tmp) != vis.end())continue;\n\t\t\trep(i,len-1){\n\t\t\t\tif(tmp[i] != tmp[i+1]){f = true;break;}\n\t\t\t}\n\t\t\tif(!f){check = p.second;break;}\n\t\t\tvis.insert(tmp);\n\t\t\trep(i,len-1){\n\t\t\t\tif(tmp[i] < tmp[i+1]){\n\t\t\t\t\tswap(k[i],k[i+1]);\n\t\t\t\t}\n\t\t\t\tif(k[i]=='r'&&k[i+1]=='g'){k[i]=k[i+1]='b';Q.push(P(k,p.second+1));}\n\t\t\t\telse if(k[i]=='r'&&k[i+1]=='b'){k[i]=k[i+1]='g';Q.push(P(k,p.second+1));}\n\t\t\t\telse if(k[i]=='g'&&k[i+1]=='b'){k[i]=k[i+1]='r';Q.push(P(k,p.second+1));}\n\t\t\t\tk = p.first;\n\t\t\t}\n\t\t}\n\t\t(check != -1) ? printf(\"%d\\n\",check) : puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s[0]=='0')break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(!q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }\n          if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }\n          if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }\n          if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }\n          if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp[y]==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(f!=1)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 0179\n#include<iostream>\n#include<string>\n#include<set>\n#include<map>\n#include<queue>\n#include<functional>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int integer;\n\nbool end(string s) {\n  char c = s[0];\n  int len = s.size();\n  REP(i, len) {\n    if (c != s[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvector<string> gonext(string worm) {\n  vector<string> v;\n  for (int i = 1, len = worm.length(); i < len; i++) {\n    if (worm[i] == worm[i-1]) continue;\n    string s = worm;\n    char c = 'r' + 'g' + 'b' - worm[i] - worm[i-1];\n    s[i] = s[i-1] = c;\n    v.push_back(s);\n  }\n  return v;\n}\n\ntypedef pair<integer,string> P;\n\ninteger solve(string worm) {\n  priority_queue<P,vector<P>,greater<P> > q;\n  set<string> s;\n  q.push(make_pair(0,worm));\n  while (!q.empty()) {\n    P w = q.top();\n    q.pop();\n    if (end(w.second)) return w.first;\n    vector<string> nxts = gonext(w.second);\n    for (auto nxt : nxts) {\n      if (s.find(nxt) == s.end()) {\n        q.push(make_pair(w.first + 1, nxt));\n        s.insert(nxt);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  string s;\n  while (cin >> s and s != \"0\") {\n    integer ans = solve(s);\n    if (ans == -1) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint que[60000][10],flg[1050000];\nint main(void){\n\tint p1,p2,i,j,len,time[60000],copy[10],f,x,ans,iro;\n\tchar ca[11];\n\twhile(1){\n\t\tcin>>ca;\n\t\tif(ca[0]=='0') break;\n\t\tlen=strlen(ca);\n\t\tfor(i=0;i<len;i++){\n\t\t\tif(ca[i]=='r') que[0][i]=0;\n\t\t\tif(ca[i]=='g') que[0][i]=1;\n\t\t\tif(ca[i]=='b') que[0][i]=2;\n\t\t}\n\t\tfor(i=0;i<=1050000;i++) flg[i]=0;\n\t\tp1=0; p2=1; time[0]=0; ans=-1;\n\t\twhile(1){\n\t\t\tif(p1==p2){\n//\t\t\t\tcout<<p1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n/*\t\t\tcout<<p1<<' ';\n\t\t\tfor(i=0;i<len;i++) cout<<que[p1][i];\n\t\t\tcout<<' '<<time[p1]<<endl;*/\n\t\t\tf=1;\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tif(que[p1][i]!=que[p1][i+1]){\n\t\t\t\t\tf=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==1){\n\t\t\t\tans=time[p1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tfor(j=0;j<len;j++) copy[j]=que[p1][j];\n\t\t\t\tif(copy[i]!=copy[i+1]){\n\t\t\t\t\tiro=copy[i]+copy[i+1];\n\t\t\t\t\tif(iro==3){\n\t\t\t\t\t\tcopy[i]=0; copy[i+1]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==2){\n\t\t\t\t\t\tcopy[i]=1; copy[i+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==1){\n\t\t\t\t\t\tcopy[i]=2; copy[i+1]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=copy[0];\n\t\t\t\tfor(j=1;j<len;j++) x=x*4+copy[j];\n\t\t\t\tif(flg[x]==0){\n\t\t\t\t\tflg[x]=1; time[p2]=time[p1]+1;\n\t\t\t\t\tfor(j=0;j<len;j++) que[p2][j]=copy[j];\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1++;\n\t\t}\n\t\tif(ans==-1) cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\n  string s,str,col[3];\n  queue<string> que;\n  map<string,int> mp;\n  int flag;\n  while(cin >> s,s != \"0\"){\n    mp.clear();\n    flag = 1;\n    que.push(s);\n    mp[s] = 0;\n    for(int i=0;i<3;i++) col[i] = \"\";\n    for(int i=0;i<s.size();i++){\n      col[0] += \"r\";\n      col[1] += \"b\";\n      col[2] += \"g\";\n    }\n    while(!que.empty()){\n      if(que.front()==col[0]){\n\tcout << mp[col[0]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[1]){\n\tcout << mp[col[1]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[2]){\n\tcout << mp[col[2]] << endl;\n\tflag--;\n\tbreak;\n      }\n      \n      for(int i=0;i<s.size()-1;i++){\n\tstr = que.front();\n\tif(str[i] != str[i+1]){\n\t  if(str[i] != 'r' && str[i+1] != 'r'){\n\t    str[i] = 'r';\n\t    str[i+1] = 'r';\n\t  } else if(str[i] != 'b' && str[i+1] != 'b'){\n\t    str[i] = 'b';\n\t    str[i+1] = 'b';\n\t  }else if(str[i] != 'g' && str[i+1] != 'g'){\n\t    str[i] = 'g';\n\t    str[i+1] = 'g';\n\t  }\n\t  if(mp.count(str) == 0){\n\t    que.push(str);\n\t    mp[str] = mp[que.front()]+1;\n\t  }\n\t}\n      }\n      que.pop();\n    }\n    while(!que.empty()) que.pop();\n    if(flag) cout << \"NA\" << endl;\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int n,p;\n  bool b[3][3][3][3][3][3][3][3][3][3];\n  string s;\n  queue<pair<string,int> > c;\n  while(cin>>s&&s[0]!='0'){\n    n=s.length();\n    for(i=0;i<10-n;i++)\n      s+=(char)0;\n    memset(b,0,59049);\n    while(c.empty()==0)\n      c.pop();\n    c.push(make_pair(s,0));\n    while(c.empty()==0){\n      s=c.front().first;\n      p=c.front().second;\n      for(i=0;i<n;i++)\n\ts[i]+=3;\n      j=0;\n      for(i=0;i<n;i++){\n\tif(s[i]>2){\n\t  for(k=i+1;k<n;k++){\n\t    if(s[k]==s[i])\n\t      s[k]=j;\n\t  }\n\t  s[i]=j;\n\t  j++;\n\t}\n      }\n      for(i=1;i<n&&s[i-1]==s[i];i++);\n      if(i==n)\n\tbreak;\n      c.pop();\n      bool* q=&b[(int)s[0]][(int)s[1]][(int)s[2]][(int)s[3]][(int)s[4]][(int)s[5]][(int)s[6]][(int)s[7]][(int)s[8]][(int)s[9]];\n      if(*q==0){\n\t*q=1;\n\tfor(i=1;i<n;i++){\n\t  if(0){\n\t  }else if(s[i-1]<s[i]){\n\t    if(0){\n\t    }else if(s[i]-s[i-1]==1){\n\t      s[i-1]=(s[i-1]+2)%3;\n\t      s[i]=(s[i]+1)%3;\n\t      c.push(make_pair(s,p+1));\n\t      s[i-1]=s[i-1]-2+(s[i-1]-2<0?3:0);\n\t      s[i]=s[i]-1+(s[i]-1<0?3:0);\n\t    }else if(s[i]-s[i-1]==2){\n\t      s[i-1]=(s[i-1]+1)%3;\n\t      s[i]=(s[i]+2)%3;\n\t      c.push(make_pair(s,p+1));\n\t      s[i-1]=s[i-1]-1+(s[i-1]-1<0?3:0);\n\t      s[i]=s[i]-2+(s[i]-2<0?3:0);\n\t    }\n\t  }else if(s[i-1]>s[i]){\n\t    if(0){\n\t    }else if(s[i-1]-s[i]==1){\n\t      s[i]=(s[i]+2)%3;\n\t      s[i-1]=(s[i-1]+1)%3;\n\t      c.push(make_pair(s,p+1));\n\t      s[i]=s[i]-2+(s[i]-2<0?3:0);\n\t      s[i-1]=s[i-1]-1+(s[i-1]-1<0?3:0);\n\t    }else if(s[i-1]-s[i]==2){\n\t      s[i]=(s[i]+1)%3;\n\t      s[i-1]=(s[i-1]+2)%3;\n\t      c.push(make_pair(s,p+1));\n\t      s[i]=s[i]-1+(s[i]-1<0?3:0);\n\t      s[i-1]=s[i-1]-2+(s[i-1]-2<0?3:0);\n\t    }\n\t  }\t    \n\t}\n      }\n    }\n    if(c.empty())\n      cout<<\"NA\"<<endl;\n    else\n      cout<<p<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\nbool OK(string in){\n\tfor(int i = 0;i<in.size();i++){\n\t\tif (in[0] != in[i]) return false;\n\t}\n\treturn true;\n}\n\nchar ch(char a, char b){\n\tif (a != 'r' && b != 'r') return 'r';\n\telse if (a != 'g' && b != 'g') return 'g';\n\telse return 'b';\n}\n\nint main(){\n\tstring in;\n\twhile(cin >> in){\n\t\tif (in == \"0\") break;\n\t\tqueue<string> que;\n\t\tque.push(in);\n\t\tvector<string> check(pow(3, in.size()));\n\t\tint n = 0;\n\t\tbool map[60000] = {};\n\t\twhile(true){\n\t\t\tint que_size = que.size();\n\t\t\tbool flag = false;\n\t\t\tif(que_size == 0){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0;i<que_size;i++){\n\t\t\t\tstring que_front = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(OK(que_front)){\n\t\t\t\t\tcout << n << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < que_front.size() - 1; j++) {\n\t\t\t\t\tif (que_front[j] == que_front[j + 1]) continue;\n\t\t\t\t\tstring for_push = que_front;\n\t\t\t\t\tfor_push[j] = for_push[j + 1] = ch(que_front[j], que_front[j + 1]);\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tfor (int k = 0; k < for_push.size(); k++){\n\t\t\t\t\t\tif (for_push[k] == 'r') tmp += 2 * pow(3, k);\n\t\t\t\t\t\telse if (for_push[k] == 'g') tmp += pow(3, k);\n\t\t\t\t\t}\n\t\t\t\t\tif(!map[tmp]){\n\t\t\t\t\t\tmap[tmp] = true;\n\t\t\t\t\t\tque.push(for_push);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t\tn++;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\nint worm[4][4][4][4][4][4][4][4][4][4];\n\nint main() {\n\tfill_n((int *)worm, 4*4*4*4*4*4*4*4*4*4, -1);\n\n\tFOR(n, 2, 10 + 1){\n\t\tqueue<vi> que;\n\t\tREP(c, 3){\n\t\t\tvi w(10, 0);\n\t\t\tREP(i, n){\n\t\t\t\tw[i] = c+1;\n\t\t\t}\n\t\t\tworm[w[0]][w[1]][w[2]][w[3]][w[4]][w[5]][w[6]][w[7]][w[8]][w[9]] = 0;\n\t\t\tque.push(w);\n\t\t}\n\t\tque.push({});\n\n\t\tint step = 1;\n\t\twhile(1){\n\t\t\tvi p = que.front(); que.pop();\n\t\t\tif(p.size() == 0){\n\t\t\t\tif(que.empty())\n\t\t\t\t\tbreak;\n\t\t\t\tstep ++;\n\t\t\t\tque.push(p);\n\t\t\t}\n\t\t\tFOR(i, 1, p.size()){\n\t\t\t\tif(p[i-1] != p[i]) continue;\n\t\t\t\tif(p[i] == 0)continue;\n\t\t\t\tvi w1 = p;\n\t\t\t\tw1[i-1] = p[i-1] % 3 + 1;\n\t\t\t\tw1[i  ] = (p[i-1] + 1) % 3 + 1;\n\t\t\t\tvi w2 = p;\n\t\t\t\tw2[i-1] = (p[i-1] + 1) % 3 + 1;\n\t\t\t\tw2[i  ] = p[i-1]% 3 + 1;\n\n\t\t\t\tif (worm[w1[0]][w1[1]][w1[2]][w1[3]][w1[4]][w1[5]][w1[6]][w1[7]][w1[8]][w1[9]] == -1){\n\t\t\t\t\tworm[w1[0]][w1[1]][w1[2]][w1[3]][w1[4]][w1[5]][w1[6]][w1[7]][w1[8]][w1[9]] = step;\n\t\t\t\t\tque.push(w1);\n\t\t\t\t}\n\t\t\t\tif (worm[w2[0]][w2[1]][w2[2]][w2[3]][w2[4]][w2[5]][w2[6]][w2[7]][w2[8]][w2[9]] == -1){\n\t\t\t\t\tworm[w2[0]][w2[1]][w2[2]][w2[3]][w2[4]][w2[5]][w2[6]][w2[7]][w2[8]][w2[9]] = step;\n\t\t\t\t\tque.push(w2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstring wm;\n\twhile(cin >>wm, wm != \"0\"){\n\t\tvi w(10, 0);\n\t\tREP(i, wm.length()){\n\t\t\tw[i] = wm[i] % 3 + 1;\n\t\t}\n\n\t\tif(worm[w[0]][w[1]][w[2]][w[3]][w[4]][w[5]][w[6]][w[7]][w[8]][w[9]] == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << worm[w[0]][w[1]][w[2]][w[3]][w[4]][w[5]][w[6]][w[7]][w[8]][w[9]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nint checkTable[59049];\n\nstruct Data{\n\tint number,depth;\n};\n\nint getNum(char ch){\n\tswitch(ch){\n\tcase 'r':return 0;\n\tcase 'g':return 1;\n\tcase 'b':return 2;\n\t}\n\treturn -1; //must not reach here\n}\n\nint getWeight(int w){\n\tswitch(w){\n\tcase 0:return 1;\n\tcase 1:return 3;\n\tcase 2:return 9;\n\tcase 3:return 27;\n\tcase 4:return 81;\n\tcase 5:return 243;\n\tcase 6:return 729;\n\tcase 7:return 2187;\n\tcase 8:return 6561;\n\tcase 9:return 19683;\n\t}\n\treturn -1;\t//must not reach here\n}\n\nint translateData(char table[],int size){\n\tint ret = 0;\n\n\tfor(int i = 0; i < size; i++){\n\t\tret += getNum(table[i])*pow(3,(size-1)-i);\n\t}\n\n\treturn ret;\n}\n\nvoid setData(char warm[],int code,int size){\n\tint tmp;\n\tfor(int i = 0; i < size; i++){\n\t\ttmp = code/getWeight(size-1-i);\n\t\tif(tmp == 0){\n\t\t\twarm[i] = 'r';\n\t\t}else if(tmp == 1){\n\t\t\twarm[i] = 'g';\n\t\t}else{\n\t\t\twarm[i] = 'b';\n\t\t}\n\t\tcode %= getWeight(size-1-i);\n\t}\n}\n\nint dfs(char warm[],int size){\n\n\tint ret = -1;\n\tData data;\n\tdata.number = translateData(warm,size);\n\tdata.depth = 0;\n\n\tqueue<Data> Q;\n\tQ.push(data);\n\n\tData tmp;\n\tchar tmp_warm[11], next_warm[11];\n\tint code;\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\n\t\tsetData(tmp_warm,tmp.number,size);\n\n\t\tbool FLG = true;\n\t\tfor(int i = 0; i < size-1; i++){\n\t\t\tif(tmp_warm[i] != tmp_warm[i+1]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG){\n\t\t\twhile(!Q.empty())Q.pop();\n\t\t\tret = tmp.depth;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0; i < size-1; i++){\n\t\t\tif(tmp_warm[i] != tmp_warm[i+1]){\n\t\t\t\tData new_data;\n\t\t\t\tfor(int k = 0; k < size; k++)next_warm[k] = tmp_warm[k];\n\n\t\t\t\tif(tmp_warm[i] != 'r' && tmp_warm[i+1] != 'r'){\n\t\t\t\t\tnext_warm[i] = 'r';\n\t\t\t\t\tnext_warm[i+1] = 'r';\n\t\t\t\t}else if(tmp_warm[i] != 'g' && tmp_warm[i+1] != 'g'){\n\t\t\t\t\tnext_warm[i] = 'g';\n\t\t\t\t\tnext_warm[i+1] = 'g';\n\t\t\t\t}else{\n\t\t\t\t\tnext_warm[i] = 'b';\n\t\t\t\t\tnext_warm[i+1] = 'b';\n\t\t\t\t}\n\n\t\t\t\tcode = translateData(next_warm,size);\n\t\t\t\tif(checkTable[code] == -1){\n\t\t\t\t\tcheckTable[code] = 1;\n\t\t\t\t\tnew_data.number = code;\n\t\t\t\t\tnew_data.depth = tmp.depth+1;\n\t\t\t\t\tQ.push(new_data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint size,minimum;\n\tchar buf[11];\n\n\twhile(true){\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0] == '0')break;\n\n\t\tfor(size = 0;buf[size] != '\\0';size++);\n\n\t\tfor(int i = 0; i < 59049; i++)checkTable[i] = -1;\n\n\t\tcheckTable[translateData(buf,size)] = 1;\n\n\t\tminimum = dfs(buf,size);\n\n\t\tif(minimum == -1)printf(\"NA\\n\");\n\t\telse{\n\t\t\tprintf(\"%d\\n\",minimum);\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\nqueue<int> q;\nint t[59049];\nint INF=100000;\nint encode(vector<int> vc){\n\tint p=0;\n\tfor(int i=0;i<vc.size();i++){\n\t\tp=p*3+vc[i];\n\t}\n\treturn p;\n}\nvector<int> decode(int p,int n){\n\tvector<int> vc(n);\n\tfor(int i=0;i<n;i++){\n\t\tvc[n-i-1]=p%3;\n\t\tp/=3;\n\t}\n\treturn vc;\n}\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<59049;i++) t[i]=INF;\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(s==\"0\") break;\n\t\tint n=s.size(),start=0,goal=1;\n\t\tfor(int i=0;i<n;i++) goal*=3;\n\t\tgoal-=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(s[i]=='r') start=start*3+2;\n\t\t\tif(s[i]=='g') start=start*3+1;\n\t\t\tif(s[i]=='b') start=start*3;\n\t\t}\n\t\tq.push(start);\n\t\tt[start]=0;\n\t\tint ok=-1;\n\t\twhile(q.size()){\n\t\t\tint p=q.front();\n\t\t\tif(p==0 || p==goal/2 || p==goal){\n\t\t\t\tok=p;\n\t\t\t\twhile(q.size()) q.pop(); \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t\tvector<int> vc=decode(p,n);\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tif(vc[i]==vc[i+1]) continue;\n\t\t\t\tvector<int> vc_c=vc;\n\t\t\t\tvc_c[i]=vc_c[i+1]=((vc[i]+vc[i+1])*2)%3;\n\t\t\t\tint hoge=encode(vc_c);\n\t\t\t\tif(t[hoge]!=INF) continue;\n\t\t\t\tq.push(hoge);\n\t\t\t\tt[hoge]=t[p]+1;\n\t\t\t}\n\t\t}\n\t\tif(ok==-1) cout << \"NA\" << endl;\n\t\telse cout << t[ok] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\nint cnt,ccnt = 0;\nint len;\nstring s, ss, tmp;\nint flag = 0;\nint fflag=0;\nchar c;\nvector<string> v_list;\npair<string,int> ps;\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tfflag=0;\n\t\t//v_list.push_back(s);\n\t\tlen = s.length();\n\t\tqueue<pair<string,int> > qq;\n\t\tqq.push(make_pair(s,0));\n\t\twhile (!qq.empty()) {\n\t\t\tps = qq.front();\n\t\t\tqq.pop();\n\t\t\tc = ps.first[0];\n\n\t\t\tccnt=ps.second;\n\t\t\tflag = 0;\n\t\t\t//vector<int>::iterator cIter = std::find( v_list.begin(), v_list.end(), ps.first);\n\n\t\t\tif( (find( v_list.begin(), v_list.end(), ps.first)) != v_list.end() ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv_list.push_back(ps.first);\n\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tif (c != ps.first[i]) {\n\t\t\t\t\t//cout<<ps.first[i]<<endl;//deb\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int i = 0; i < len - 1; ++i) {\n\t\t\t\t\ttmp = ps.first;\n\t\t\t\t\tif (ps.first[i] != ps.first[i+1]) {\n\t\t\t\t\t\tif (ps.first[i] != 'r' && ps.first[i+1] != 'r') {\n\t\t\t\t\t\t\ttmp[i] = 'r';\n\t\t\t\t\t\t\ttmp[i + 1] = 'r';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'g' && ps.first[i+1] != 'g' ){\n\t\t\t\t\t\t\ttmp[i] = 'g';\n\t\t\t\t\t\t\ttmp[i + 1] = 'g';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'b' && ps.first[i+1] != 'b') {\n\t\t\t\t\t\t\ttmp[i] = 'b';\n\t\t\t\t\t\t\ttmp[i + 1] = 'b';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcout << ccnt << endl;\n\t\t\t\tfflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!fflag){printf(\"NA\");cout<<endl;};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n#define sint(i) scanf(\"%d\",&i);\n#define sintt(i,j) scanf(\"%d%d\",&i,&j);\n#define sinttt(i,j,k) scanf(\"%d%d%d\",&i,&j,&k);\n\n#define INF 1010000000\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nclass S{\n\tpublic:\n\tstring st;\n\tint n;\n\tS(string st,int n):st(st),n(n){}\n};\n\nint main(){\n\twhile(1){\n\t\tstring a;\n\t\tcin>>a;\n\t\t\n\t\tif(a==\"0\")break;\n\t\t\n\t\tqueue<S> que;\n\t\tque.push(S(a,0));\n\t\t\n\t\tmap<string,int> visit;\n\t\tint ans=-1;\n\t\twhile(1){\n\t\t\tif(que.empty()==1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tS u=que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.st]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisit[u.st]=1;\n\t\t\t\n\t\t\tint r=0,g=0,b=0;\n\t\t\trep(i,u.st.size()){\n\t\t\t\tif(u.st[i]=='r'){\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='g'){\n\t\t\t\t\tg++;\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='b'){\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif((r==0&&g==0)||(r==0&&b==0)||(b==0&&g==0)){\n\t\t\t\tans=u.n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,u.st.size()-1){\n\t\t\t\tstring nstr=u.st;\n\t\t\t\tif(u.st[i]=='r' && u.st[i+1]=='g'){\n\t\t\t\t\tnstr[i]=nstr[i+1]='b';\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='g' && u.st[i+1]=='r'){\n\t\t\t\t\tnstr[i]=nstr[i+1]='b';\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='r' && u.st[i+1]=='b'){\n\t\t\t\t\tnstr[i]=nstr[i+1]='g';\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='b' && u.st[i+1]=='r'){\n\t\t\t\t\tnstr[i]=nstr[i+1]='g';\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='b' && u.st[i+1]=='g'){\n\t\t\t\t\tnstr[i]=nstr[i+1]='r';\n\t\t\t\t}\n\t\t\t\tif(u.st[i]=='g' && u.st[i+1]=='b'){\n\t\t\t\t\tnstr[i]=nstr[i+1]='r';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.push(S(nstr,u.n+1));\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tputs(\"NA\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint ar[11], ag[11], ab[11];\nbool checked[59049];\nint p3[11];\nint change[9] = {0, 8, 4, 8, 4, 0, 4, 0, 8};\n\nint conv(string s) {\n    int ret = 0;\n    for (int i=0; i<(int)s.size(); ++i) {\n        ret *= 3;\n        if (s[i] == 'g') ret += 1;\n        if (s[i] == 'b') ret += 2;\n    }\n    return ret;\n}\n\nint rotate(int x, int n) {\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        ret = ret * 3 + (x % 3 + 1) % 3;\n        x /= 3;\n    }\n    return ret;\n}\n\nint main() {\n    p3[0] = 1;\n    for (int i=1; i<=10; ++i) {\n        p3[i] = p3[i-1] * 3;\n    }\n    ar[0] = ag[0] = ab[0] = 0;\n    for (int i=1; i<=10; ++i) {\n        ar[i] = ar[i-1];\n        ag[i] = ag[i-1] * 3 + 1;\n        ab[i] = ab[i-1] * 3 + 2;\n    }\n    string s;\n    while (cin >> s, s != \"0\") {\n        memset(checked, false, sizeof checked);\n        int n = s.size();\n        int first = conv(s);\n        queue<pair<int,int> > q;\n        q.push(make_pair(first, 0));\n        checked[first] = true;\n        int res = -1;\n        while ( ! q.empty()) {\n            int col = q.front().first;\n            int t = q.front().second;\n            q.pop();\n            if (col == ar[n] || col == ag[n] || col == ab[n]) {\n                res = t;\n                break;\n            }\n            for (int i=0; i<n-1; ++i) {\n                int replace = change[(col / p3[i]) % 9];\n                int nx = (col / p3[i+2]) * p3[i+2] + replace * p3[i] + (col % p3[i]);\n                if ( ! checked[nx]) {\n                    q.push(make_pair(nx, t+1));\n                    checked[nx] = true; nx = rotate(nx, n);\n                    checked[nx] = true; nx = rotate(nx, n);\n                    checked[nx] = true;\n                }\n            }\n        }\n        if (res < 0) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nmap<vector<int>, int>mp;\n\nmap<char, int>chmp;\nint getans(vector<int> st,int m) {\n\tif (mp.find(st) != mp.end())return  mp[st];\n\telse {\n\t\tif (m >= 1000)return 1e8;\n\t\tif (all_of(st.begin(), st.end(), [=](const int n) {return n == st[0]; }))return mp[st] = 0;\n\t\tmp[st] = 1e8;\n\t\tint ans = 1e8;\n\t\tfor (int i = 0; i < st.size() - 1; ++i) {\n\t\t\tif (st[i] != st[i + 1]) {\n\t\t\t\tvector<int>nowst(st);\n\t\t\t\tnowst[i] = 3 - st[i] - st[i + 1];\n\t\t\t\tnowst[i + 1] = 3 - st[i] - st[i + 1];\n\t\t\t\tans = min(ans, getans(nowst,m+1) + 1);\n\t\t\t}\n\t\t}\n\t\treturn mp[st] = ans;\n\t}\n}\n\nint main() {\n\tchmp['r'] = 0;\n\tchmp['g'] = 1;\n\tchmp['b'] = 2;\n\twhile (1) {\n\n\t\tstring st; cin >> st;\n\t\tif (st == \"0\")break;\n\t\tvector<int>nums;\n\t\tfor (auto c : st) {\n\t\t\tnums.emplace_back(chmp[c]);\n\t\t}\n\t\tint ans = getans(nums,0);\n\t\tif (ans > 1e7) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint ans = 0;\n\nstring change(string s, int a, int b){\n\tif((s[a] == 'r' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'r'))\n\t\ts[b] = s[a] = 'b';\n\telse if((s[a] == 'b' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'b'))\n\t\ts[b] = s[a] = 'r';\n\telse\n\t\ts[b] = s[a] = 'g';\n\t\n\treturn s;\n}\n\nvoid bfs(string s, int res){\n\tif(res >= ans)\n\t\treturn;\n\tfor(int i = 0; i < s.size() - 1; ++i){\n\t\tif(s[i] != s[i + 1])\n\t\t\tbreak;\n\t\tif(i == s.size() - 2){\n\t\t\tans = min(res, ans);\n\t\t\treturn;\n\t\t}\n\t}\n\tif(res >= 9)\n\t\treturn;\n\tfor(int i = 0; i < s.size() - 1; ++i){\n\t\tif(s[i] != s[i + 1]){\n\t\t\tstring str = change(s, i, i + 1);\n\t\t\tbfs(str, res + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s == \"0\")\n\t\t\tbreak;\n\t\tans = INF;\n\t\tbfs(s, 0);\n\t\tif(ans == INF)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reps(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reps(i, 0, n) \n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tchar str[16];\n\twhile(scanf(\"%s\", str), str[0]!='0'){\n\t\tint n = strlen(str);\n\t\tint ans = -1;\n\t\tset<string> visited;\n\t\tqueue<pair<string, int> > Q;\n\t\tQ.push(make_pair(str, 0));\n\t\twhile(!Q.empty()){\n\t\t\tpair<string, int> data = Q.front();\n\t\t\tQ.pop();\n\t\t\trep(i, n-1){\n\t\t\t\tchar a = min(data.first[i], data.first[i+1]);\n\t\t\t\tchar b = max(data.first[i], data.first[i+1]);\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tchar nc;\n\t\t\t\tif(a == 'b')\n\t\t\t\t\tnc = b=='g' ? 'r' : 'g';\n\t\t\t\telse\n\t\t\t\t\tnc = 'b';\n\t\t\t\t\n\t\t\t\tstring next = data.first;\n\t\t\t\tnext[i] = next[i+1] = nc;\n\t\t\t\tif(count(next.begin(), next.end(), nc) == n){\n\t\t\t\t\tans = data.second + 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif(!visited.count(next)){\n\t\t\t\t\tvisited.insert(next);\n\t\t\t\t\tQ.push(make_pair(next, data.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\nend:\n\t\tif(ans == -1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n\tqueue<P> que;\n\tque.push(P(worm, 0));\n\n\tmap<string, int> d;\n\t\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\t//d¡p^[Ícontinue\n\t\tif(d[p.first]) continue;\n\n\t\tstring str = p.first;\n\n\t\t//SF¯¶©Ç¤©Ì`FbN\n\t\tbool flag = false;\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//¯¶Èçreturn\n\t\tif(!flag) return p.second;\n\n\t\t//d¡p^[»Êp\n\t\td[p.first] = p.second;\n\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\t//×èí¹ÅFªÙÈéÆ«\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\n\t\t\t\t//tempÉÜÜêÈ¢êFðãü\n\t\t\t\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t\t\t\t\ttemp = 'b';\n\t\t\t\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t\t\t\t\ttemp = 'g';\n\t\t\t\t}else{\n\t\t\t\t\ttemp = 'r';\n\t\t\t\t}\n\n\t\t\t\t//Ï»ãÌÔðnextÉlßÞ\n\t\t\t\tnext = str;\n\t\t\t\tnext[i] = next[i+1] = temp;\n\n\t\t\t\t//L[ÉvbV\n\t\t\t\tque.push(P(next, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring worm;\n\twhile(cin >> worm && worm != \"0\"){\n\t\tint ret = bfs(worm);\n\t\tif(ret>=0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<iostream>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\nclass sint{\n\tpublic:\n\tstring st;int m;\n\tsint(){}\n\tsint(string a,int b){st=a;m=b;}\n};\n\nint musi(string str){\n\tqueue<sint> state;\n\tmap<string,int> mm;\n\t\n\tmm[str]=1;\n\t\n\tstate.push(sint(str,0));\n\t\n\twhile(1){\n\t\t\n\t\tif(state.empty()==1){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsint u;\n\t\tu=state.front();\n\t\tstate.pop();\n\t\t\n\t\t\n\t\t\n\t\t//cout<<u.st<<\" \"<<u.m<<endl;\n\t\t\n\t\tint cont[3];\n\t\tcont[0]=cont[1]=cont[2]=0;\n\t\tfor(int i=0;i<u.st.size();i++){\n\t\t\tif(u.st[i]=='r'){\n\t\t\t\tcont[0]++;\n\t\t\t}\n\t\t\tif(u.st[i]=='g'){\n\t\t\t\tcont[1]++;\n\t\t\t}\n\t\t\tif(u.st[i]=='b'){\n\t\t\t\tcont[2]++;\n\t\t\t}\n\t\t}\n\t\tint aaa=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(cont[i]==0){\n\t\t\t\taaa++;\n\t\t\t}\n\t\t}\n\t\tif(aaa==2){\n\t\t\treturn u.m;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=u.st.size();i++){\n\t\t\tstring nst=u.st;\n\t\t\tif(nst[i]!=nst[i-1]){\n\t\t\t\tif(nst[i]=='r'&&nst[i-1]=='g'){\n\t\t\t\t\tnst[i]=nst[i-1]='b';\n\t\t\t\t}\n\t\t\t\tif(nst[i]=='g'&&nst[i-1]=='b'){\n\t\t\t\t\tnst[i]=nst[i-1]='r';\n\t\t\t\t}\n\t\t\t\tif(nst[i]=='b'&&nst[i-1]=='r'){\n\t\t\t\t\tnst[i]=nst[i-1]='g';\n\t\t\t\t}\n\t\t\t\tif(nst[i-1]=='r'&&nst[i]=='g'){\n\t\t\t\t\tnst[i]=nst[i-1]='b';\n\t\t\t\t}\n\t\t\t\tif(nst[i-1]=='g'&&nst[i]=='b'){\n\t\t\t\t\tnst[i]=nst[i-1]='r';\n\t\t\t\t}\n\t\t\t\tif(nst[i-1]=='b'&&nst[i]=='r'){\n\t\t\t\t\tnst[i]=nst[i-1]='g';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mm[nst]!=1){\n\t\t\t\tmm[nst]=1;\n\t\t\t\tstate.push(sint(nst,u.m+1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tstring a;\n\t\tcin>>a;\n\t\tif(a==\"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tint b=musi(a);\n\t\tif(b==-1){\n\t\t\tputs(\"NA\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",b);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s==\"0\")break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(!q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }\n          if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }\n          if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }\n          if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }\n          if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp[y]==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(!f)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<set>\n#include<queue>\nusing namespace std;\nchar conv(char c1,char c2){\n  if(c1=='r'){\n    if(c2=='g')return 'b';\n    if(c2=='b')return 'g';\n  }else if(c1=='g'){\n    if(c2=='r')return 'b';\n    if(c2=='b')return 'r';\n  }else if(c1=='b'){\n    if(c2=='r')return 'g';\n    if(c2=='g')return 'r';\n  }\n}\nint bfs(string s){\n  queue< pair<int, string> > qs;\n  set<string> vis;\n  qs.push( make_pair(0,s) );\n  while(!qs.empty()){\n    bool bFound=false;\n    int ret = qs.front().first;\n    string now = qs.front().second;\n    qs.pop();\n\n    //cout << vis.size() << endl;\n    if( vis.find(now) != vis.end() ){\n      continue;\n    }\n    vis.insert(now);\n    for(int i = 0; i < now.length()-1; ++i){\n      if(now[i]!=now[i+1]){\n\tbFound = true;\n\tstring next = now;\n\tchar nc = conv(now[i],now[i+1]);\n\tnext[i] = next[i+1] = nc;\n\tqs.push(make_pair(ret+1,next));\n      }\n    }\n    if(!bFound){\n      //cout << now << endl;\n      return ret;\n    }\n  }\n  return -1;\n}\nint main(){\n  while(true){\n    string s;\n    cin >> s;\n    if( s == \"0\" )  break;\n    int ans = bfs(s);\n    if( ans < 0 )\n      cout << \"NA\" << endl;\n    else\n      cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define INF 10000000\nusing namespace std;\ntypedef pair<string ,int>P;\nint cnt;\n\nint bfs(string worm){\n  queue<P> que;\n  que.push(P(worm,cnt));\n  string next;\n  char tmp;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    bool f = true;\n    for(int i = 0 ; i < p.first.size()-1 ; i++ ){\n      if(worm[i] != worm[i+1])f = false;\n    }\n    if(f)return p.second;\n  for(int i = 0 ; i < worm.size()-1 ; i++ ){\n    if(worm[i] != worm[i+1]){\n      if(worm[i] != 'r' && worm[i+1] != 'r'){\n\ttmp = 'r';\n      }else if(worm[i] != 'g' && worm[i+1] != 'g'){\n\ttmp = 'g';\n      } else {\n\ttmp = 'b';\n      }\n      next = worm;\n      next[i] = next[i+1] = tmp;\n      que.push(P(next,cnt+1));\n    }\n  }\n  }\n  return -1;\n}\n\nint main(){\n  string worm;\n  while(cin >> worm){\n    if(worm[0] == '0')break;\n    cnt = 0;\n    int ret = bfs(worm);\n    if(ret == -1){\n      cout << \"NA\" << endl;\n    }else cout << ret << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n  queue<P> que;\n  que.push(P(worm, 0));\n\n  map<string, int>  d;\n\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n\n    if(d[p.first])  continue;\n\n    string str = p.first;\n\n    bool flag = true;\n    for(int i = 0; i < str.size()-1; i++){\n      if(str[i] != str[i+1]){\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag) return p.second;\n\n    for(int i = 0; i < str.size()-1; i++){\n      if(str[i] != str[i+1]){\n        string next;\n        char tmp;\n        if(str[i] != 'r' && str[i+1] != 'r'){\n          tmp = 'r';\n        }else if(str[i] != 'b' && str[i+1] != 'r'){\n          tmp = 'b';\n        }else{\n          tmp = 'g';\n        }\n\n        next = str;\n        next[i] = next[i+1] = tmp;\n        que.push(P(next, p.second+1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  string worm;\n  while(cin >> worm && worm != \"0\"){\n    int ans = bfs(worm);\n    if(ans >= 0)  cout << ans << endl;\n    else cout << \"NA\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef pair<string,int> bug;\n\nbool check(string insect) {\n  for ( int i = 1; i < insect.size(); i++ ) {\n    if ( insect[0] != insect[i] ) return 0;\n  }\n  return 1;\n}\n\nchar change( char a, char b ) {\n  if ( a > b ) swap(a,b);\n  if ( a == 'b' && b == 'g' ) return 'r';\n  else if ( a == 'b' && b == 'r' ) return 'g';\n  else return 'b';\n}\n\nvoid bfs ( string str ) {\n  map<string,int> close;\n  queue<bug> open;\n  open.push(make_pair(str,0));\n  close.insert(make_pair(str,1));\n  int cnt = -1;\n  while ( !open.empty() ) {\n    bug b = open.front(); open.pop();\n    string insect = b.first;\n    if ( check(insect) ) {\n      cnt = b.second;\n      break;\n    }\n    \n   \n    for ( int i = 0; i < insect.size()-1; i++ ) {\n      string tmp = insect;   \n      if ( tmp[i] != tmp[i+1] ) {\n\tchar nc = change( tmp[i],tmp[i+1] );\n\ttmp[i] = nc;\n\ttmp[i+1] = nc;\n\tif ( close[tmp] ) continue;\n\topen.push(make_pair(tmp,b.second+1));\n\tclose[tmp] = 1;\n      }\n    }\n\n  }\n  \n  if ( cnt == -1 ) cout << \"NA\" << endl;\n  else cout << cnt << endl;\n}\n\nint main() {\n  string str;\n  while( cin >> str, str != \"0\" ) {\n    bfs(str);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    que.push(pair<string, int>(worm, 0));\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        string worm1 = que.front().first;\n        int num = que.front().second;\n        que.pop();\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        if(que.size() > 10000){\n            return -1;\n        }\n\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            string tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nint dfs(string str) {\n     queue<P> s;\n     s.push(P(str,0));\n     int res = 999999999;\n     bool f2 = true;\n     M m;\n\n     while (s.size()) {\n\t  P p = s.front(); s.pop();\n\t  str = p.first;\n\t  if (m[str]) continue;\n\t  int num = p.second;\n\t  m[str] = num;\n\t  bool f = true;\n\t  int count = 0;\n\t  for (int i = 0; i < str.size() - 1; i++) {\n\t       string tmp = str;\n\t       bool flag = false;\n\t       if (tmp[i] != tmp[i + 1]) {\n\t\t    flag = true;\n\t\t    f = false;\n\t\t    count++;\n\t\t    if (tmp[i] != 'b' && tmp[i + 1] != 'b')\n\t\t\t tmp[i + 1] = tmp[i] = 'b';\n\t\t    else if (tmp[i] != 'r' && tmp[i + 1] != 'r')\n\t\t\t tmp[i + 1] = tmp[i] = 'r';\n\t\t    else if (tmp[i] != 'g' && tmp[i + 1] != 'g')\n\t\t\t tmp[i + 1] = tmp[i] = 'g';\n\t\t    if (tmp == str) flag = false;\n\t       }\n\t       if (flag && res > num + 1) s.push(P(tmp, num + 1));\n\t  }\n\t  if (f && res > num) {\n\t       res = num;\n\t       f2 = false;\n\t       break;\n\t  }\n\t  if (count == 1) s.pop();\n     }\n     if (f2) res = -1;\n     return res;\n}\n\nint main()\n{\n     string str;\n     while (cin >> str) {\n\t  if (str == \"0\") break;\n\t  int res = dfs(str);\n\t  if (res < 0) cout << \"NA\" << endl;\n\t  else cout << res << endl;\n     }\n\n\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\n#define INF (1 << 21)\n\nusing namespace std;\n\nint N;\n\nint check[1000000];\n\nqueue<string> que, que_next;\n\nint index(string str){\n\t\n\tint ref = 0;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tref += str[i] - '0';\n\t\tref *= 3;\n\t}\n\t\n\treturn ref;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tstring str;\n\t\tcin >> str;\n\t\t\n\t\tqueue<string> que_emp;\n\t\t\n\t\tque = que_emp;\n\t\tque_next = que_emp;\n\t\t\n\t\tfor(int i = 0; i < 1000000; i++){\n\t\t\tcheck[i] = INF;\n\t\t}\n\t\t\n\t\tif(str[0] == '0'){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tN = str.size();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(str[i] == 'r'){\n\t\t\t\t\tstr[i] = '0';\n\t\t\t\t}else if(str[i] == 'b'){\n\t\t\t\t\tstr[i] = '1';\n\t\t\t\t}else{\n\t\t\t\t\tstr[i] = '2';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tque.push(str);\n\t\t\n\t\tint depth = 0;\n\t\t\n\t\twhile(true){\n\t\t\twhile(!que.empty()){\n\t\t\t\tstring str = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(check[index(str)] != INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcheck[index(str)] = depth;\n\t\t\t\tfor(int i = 0; i < N - 1; i++){\n\t\t\t\t\tif(str[i] != str[i + 1]){\n\t\t\t\t\t\tstring str_copy = str;\n\t\t\t\t\t\tif(str[i] != '0' && str[i + 1] != '0'){\n\t\t\t\t\t\t\tstr_copy[i] = '0';\n\t\t\t\t\t\t\tstr_copy[i + 1] = '0';\n\t\t\t\t\t\t}else if(str[i] != '1' && str[i + 1] != '1'){\n\t\t\t\t\t\t\tstr_copy[i] = '1';\n\t\t\t\t\t\t\tstr_copy[i + 1] = '1';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tstr_copy[i] = '2';\n\t\t\t\t\t\t\tstr_copy[i + 1] = '2';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque_next.push(str_copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque = que_next;\n\t\t\tque_next = que_emp;\n\t\t\tdepth++;\n\t\t\tif(que.empty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout << depth << \" \" << que.size() << endl;;\n\t\t}\n\t\t\n\t\tstring check_0 = \"\";\n\t\tstring check_1 = \"\";\n\t\tstring check_2 = \"\";\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcheck_0 = check_0 + \"0\";\n\t\t\tcheck_1 = check_1 + \"1\";\n\t\t\tcheck_2 = check_2 + \"2\";\n\t\t}\n\t\t\n\t\tint ans = min(min(check[index(check_0)], check[index(check_1)]), check[index(check_2)]);\n\t\t\n\t\tif(ans == INF){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\n#define LIMIT 300\n\nint len;\nstring str;\n\nbool check(string s){\n  char ch = s[0];\n\n  for(int i = 1 ; i < len ; i++){\n    if(ch != s[i]) return false;\n  }\n  return true;\n}\n\nint bfs(){\n  string ans;\n  queue<string> Q;\n  Q.push(str);\n\n  bool found = false;\n  set<string> used;\n  used.insert(str);\n  map<string,int> dist;\n  dist[str] = 0;\n\n  while(!Q.empty()){\n    string s = Q.front(); Q.pop();\n    \n    if(check(s)){\n      found = true;\n      ans = s;\n      break;\n    }\n\n    for(int i = 1 ; i < len ; i++){\n      string next = s;\n      if(s[i-1] == 'b' && s[i] == 'r' ||\n\t s[i-1] == 'r' && s[i] == 'b'){\n\tnext[i-1] = next[i] = 'g';\n      }else if(s[i-1] == 'b' && s[i] == 'g' ||\n\t       s[i-1] == 'g' && s[i] == 'b'){\n\tnext[i-1] = next[i] = 'r';\n      }else if(s[i-1] == 'r' && s[i] == 'g' ||\n\t       s[i-1] == 'g' && s[i] == 'r'){\n\tnext[i-1] = next[i] = 'b';\n      }\n      \n      if(!used.count(next)){\n\tdist[next] = dist[s] + 1;\n\tused.insert(next);\n\tQ.push(next);\n      }\n    }\n  }\n\n  if(!found) return -1;\n  return dist[ans];\n}\n\nint main(){\n  while(cin >> str,str != \"0\"){\n    len = (int)str.size();\n    int res = bfs();\n    if(res == -1){\n      puts(\"NA\");\n    }else{\n      printf(\"%d\\n\" ,bfs());\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    que.push(pair<string, int>(worm, 0));\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        string worm1 = que.front().first;\n        int num = que.front().second;\n        que.pop();\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        if(num > 100){\n            return -1;\n        }\n\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            string tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <queue>\nusing namespace std;\n\n\nclass Worm {\npublic:\n\tstring str;\n\tint turn;\n\tWorm(string st, int t) : str(st), turn(t) {}\n};\n\nWorm nWorm(Worm w, int p) {\n\tif (w.str[p] > w.str[p+1]) {\n\t\tchar t=w.str[p];\n\t\tw.str[p] = w.str[p+1];\n\t\tw.str[p+1] = t;\n\t}\n\n\tif (w.str[p]=='b' && w.str[p+1]=='g') w.str[p] = w.str[p+1] = 'r';\n\telse if (w.str[p]=='b' && w.str[p+1]=='r') w.str[p] = w.str[p+1] = 'g'; \n\telse if (w.str[p]=='g' && w.str[p+1]=='r') w.str[p] = w.str[p+1] = 'b';\n\n\tw.turn++;\n\treturn w;\n}\n\nint main() {\n\tstring str;\n\twhile (cin >> str, str[0]!='0') {\n\t\tqueue<Worm> q;\n\t\tWorm init(str, 0);\n\t\tq.push(init);\n\t\tbool f=false, fl;\n\t\tset<string> s;\n\t\ts.insert(str);\n\n\t\twhile (!q.empty()) {\n\t\t\tWorm tmp = q.front(); q.pop();\n\t\t\tfor (int i=0; i<tmp.str.size()-1; i++) {\n\t\t\t\tWorm next = nWorm(tmp, i);\n\t\t\t\tif (s.insert(next.str).second) q.push(next);\n\t\t\t}\n\n\t\t\tfl = true;\n\t\t\tchar c = tmp.str[0];\n\t\t\tfor (int i=1; i<tmp.str.size(); i++)\n\t\t\t\tif (tmp.str[i] != c) { fl=false; break; }\n\n\t\t\tif (fl) { cout << tmp.turn << endl; f=true; break; }\n\t\t}\n\n\t\tif (!f) cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> >Q;\nmap<string,int> M;\nint main()\n{\n\tfor(;;)\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(s==\"0\")break;\n\t\tQ.push(make_pair(s,0));\n\t\tM[s]=1;\n\t\tint res=999;\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\tpair<string,int>p=Q.front();Q.pop();\n\t\t\ts=p.first;\n\t\t\tint flg=0;\n\t\t\tfor(int i=0;i<s.length()-1;i++)\n\t\t\t{\n\t\t\t\tif(s[i]!=s[i+1])\n\t\t\t\t{\n\t\t\t\t\tflg=1;\n\t\t\t\t\ts[i]=s[i+1]=315-s[i]-s[i+1];\n\t\t\t\t\tif(M[s]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[s]=1;\n\t\t\t\t\t\tpair<string,int> ins(s,p.second+1);\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t\ts=p.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg==0)\n\t\t\t\tres=min(res,p.second);\n\t\t}\n\t\tif(res==999)cout<<\"NA\"<<endl;\n\t\telse cout<<res<<endl;\n\t\tM.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s[0]=='0')break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    for(int i=0;i<1e3;i++){\n      string x=q.front();\n      q.pop();\n      for(int j=0;j<s.size()-1;j++){\n        string y=x;\n        if(y[j]=='r'&&y[j+1]=='g'){\n          y[j]='b';\n          y[j+1]='b';\n        }\n        if(y[j]=='b'&&y[j+1]=='g'){\n          y[j]='r';\n          y[j+1]='r';\n        }\n        if(y[j]=='r'&&y[j+1]=='b'){\n          y[j]='g';\n          y[j+1]='g';\n        }\n        if(y[j]=='g'&&y[j+1]=='b'){\n          y[j]='r';\n          y[j+1]='r';\n        }\n        if(y[j]=='g'&&y[j+1]=='r'){\n          y[j]='b';\n          y[j+1]='b';\n        }\n        if(y[j]=='b'&&y[j+1]=='r'){\n          y[j]='g';\n          y[j+1]='g';\n        }\n        //cout<<mp[x]+1<<\" \"<<y<<endl;\n        if(y==sr||y==sb||y==sg){\n          cout<<mp[x]+1<<endl;\n          f=1;\n          break;\n        }\n        if(mp[y]==0){\n          mp[y]=mp[x]+1;\n          q.push(y);\n        }\n      }\n      if(f)break;\n    }\n    if(!f)cout<<\"NA\"<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  string worm;\n  cin>>worm;\n  \n  while(worm != \"0\"){\n    queue<pair<string,int> >que;\n    que.push(make_pair(worm,0));\n    map<string,bool> done_str;\n    \n    int ans = -1;\n    \n    while(!que.empty()){\n      string s = que.front().first;\n      int count = que.front().second;\n      que.pop();\n\n        \n      string cmp_strR,cmp_strG,cmp_strB;\n\n      cmp_strR.append(worm.size(), 'r');\n      cmp_strG.append(worm.size(), 'g');\n      cmp_strB.append(worm.size(), 'b');\n      \n      if(s == cmp_strR || s == cmp_strG || s == cmp_strB ){\n\tans = count;\n\tbreak;\n      }else if(done_str.find(s) != done_str.end()){\n\tcontinue;\n      }else{\n\tdone_str.insert(make_pair(s,true));\n      }\n\n      \n      for(int i=0;i<s.size()-1;i++){\n\tif(s.at(i) != s.at(i+1)){\n\t  if(s.at(i) != 'r' && s.at(i+1)!='r'){\n\t    string tmp = s;\n\t    que.push(make_pair(tmp.replace(i,2,2,'r'),count+1));\n\n\t  }else if(s.at(i) != 'g' && s.at(i+1)!='g'){\n\t    string tmp = s;\n\t    que.push(make_pair(tmp.replace(i,2,2,'g'),count+1));\n\n\t  }else if(s.at(i) != 'b' && s.at(i+1)!='b'){\n\t    string tmp = s;\n\t    que.push(make_pair(tmp.replace(i,2,2,'b'),count+1));\n\t  }\n\t}\n      }\n    }\n\n    if(ans < 0){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<ans<<endl;\n    }\n    \n    cin>>worm;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\nbool terminal(string& worm){\n  for(int i = 1; i < (int)worm.size(); i++)\n    if(worm[i] != worm[i - 1])\n      return false;\n  return true;\n}\n\n\nchar othercolor(char a, char b){\n  if(a != b){\n    if(a != 'r' && b != 'r'){ return 'r'; }\n    if(a != 'g' && b != 'g'){ return 'g'; }\n    if(a != 'b' && b != 'b'){ return 'b'; }\n  }\n  return -1;\n}\n\n\nint main(void){\n  while(true){\n    string initworm;\n    cin >> initworm;\n    if(initworm == \"0\"){ break; }\n\n    queue<pair<int, string> > wait;\n    set<string> used;\n    wait.push(make_pair(0, initworm));\n    used.insert(initworm);\n    \n    int ans = -1;\n    while(!wait.empty()){\n      int nowcost = wait.front().first;\n      string nowworm = wait.front().second;\n      wait.pop();\n\n      if(terminal(nowworm)){\n        ans = nowcost;\n        break;\n      }\n\n      // ??£??\\??¶???\n      for(int i = 1; i < (int)nowworm.size(); i++){\n        char c = othercolor(nowworm[i], nowworm[i - 1]);\n        // ???????????????????????????????????§???????????????\n        if(c != -1){\n          string next = nowworm;\n          next[i] = next[i - 1] = c;\n          // ????????¶???????????¢?´¢?????£?????´???\n          if(used.count(next) == 0){\n            used.insert(next);\n            wait.push(make_pair(nowcost + 1, next));\n          } \n        }\n      }      \n    }\n    \n    // ??????\n    if(ans == -1){ cout << \"NA\" << endl; }\n    else{ cout << ans << endl; }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstring insect = \"brg\";\nint cnt;\nqueue <string> Q;\nqueue <string> Q2;\n\nbool bfs( string str) {\n  if ( cnt == 0 ) Q.push( str );\n  while ( !Q2.empty() ) {\n    string tmp;\n    tmp = Q2.front();Q2.pop();\n    Q.push(tmp);\n  }\n  \n  int count = 0;\n  while ( !Q.empty() ) {\n    int flag = 0;\n    count++;\n    str = Q.front();\n    Q.pop();\n    string str2;\n    int len = str.size();\n    for ( int k = 0; k < len-1; k++ ) {\n      if ( str[k] != str[k+1] ) flag = 1;\n    }\n    if ( flag == 0 ) return 1;\n    for ( int i = 0; i < len-1; i++ ) {\n      str2 = str;\n      for ( int j = 0; j < 3; j++ ) {\n\tif ( str2[i] != str2[i+1] \n\t     && str2[i] != insect[j] && str2[i+1] != insect[j] ) {\n\t  str2[i] = insect[j];\n\t  str2[i+1] = insect[j];\n\t  Q2.push( str2 );\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n\n  while (1) {\n\n    string str; cin >> str;\n    if ( str == \"0\" ) break;\n    while( !Q.empty() ) Q.pop();\n    while( !Q2.empty() ) Q2.pop();\n    cnt = -1;\n\n    while (1) {\n      cnt++;\n      if ( cnt == 10 ){\n\tcout << \"NA\" << endl;\n\tbreak;\n      }\n      if ( bfs( str ) ) {\n\tcout << \"ans\" << \" \" << cnt << endl;\n\tbreak;\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<string, int> I;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nchar rest(char a, char b){\n  char rgb[5] = \"rgb\";\n  REP(i,3){\n    if(rgb[i] != a && rgb[i] != b){\n      return rgb[i];\n    }\n  }\n  return ',';\n}\n  \nint bfs(I insect){\n  set<string> memo;\n  queue<I> que;\n  que.push(insect);\n  while(!que.empty()){\n    I inc = que.front(); que.pop();\n    string s = inc.first;\n    int t = inc.second;\n\n    if(memo.find(s) != memo.end()) continue;\n    memo.insert(s);\n\n    bool goal = true; \n    REP(i,s.size()-1){\n      if(s[i] != s[i+1]){\n        goal = false;\n        string nxt = s;\n        char rschar = rest(s[i],s[i+1]);\n        if(rschar == '.') abort();\n        nxt[i] = rschar;\n        nxt[i+1] = rschar;\n        que.push(I(nxt, t+1));\n      }\n    }\n    if(goal) return t;\n  }\n  return -1;\n}\n\nint main(void){\n  string insect;\n  while(cin>>insect){\n    if(insect == \"0\") break;\n    int ans = bfs(I(insect, 0));\n    if(ans == -1) cout<< \"NA\" << endl;\n    else  cout<< ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (n) ; ++i )\nbool same(string s){\n  rep(i,s.size()-1) if(s[i] != s[i+1]) return false;\n  return true;\n}\nchar change(char a,char b){\n  if(a != 'b' && b != 'b') return 'b';\n  if(a != 'g' && b != 'g') return 'g';\n  return 'r';\n}\nint bfs(string s){\n  queue<string>que;\n  que.push(s);\n  map<string,int> used;\n  used[s] = 0;\n  while(!que.empty()){\n    string s = que.front(); que.pop();\n    if(same(s)) return used[s];\n    rep(i,s.size()-1){\n      if(s[i] != s[i+1]){\n        string next = s;\n        next[i] = next[i+1] = change(next[i],next[i+1]);\n        if(!used[next]) que.push(next) , used[next] = used[s] + 1;\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  string s;\n  while(cin >> s , s != \"0\"){\n    int ans = bfs(s);\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<string>\n#include<set>\n\n#define R 114\n#define G 103\n#define B 98\n\nusing namespace std;\n\nclass DATA{\n\tpublic:\n\t\tDATA(string temp){\t\t\t//ÌzñÆzñÌ·³ðnµÄ °Ä­¾³¢\n\t\t\tstep = 0;\n\t\t\tarr = temp;\n\t\t}\n\t\t\n\t\tDATA(string temp, int step) :arr(temp), step(step) {}\n\t\t\n\t\t//I¹»èH\n\t\tint check(void){\n\t\t\tchar t = arr[0];\n\t\t\tfor(int i = 0; i < arr.size(); i++){\n\t\t\t\tif(arr[i] != t){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint step;\t\t//Xebv(JÚ)\n\t\tstring arr;\t//rgbÌÀÑ\n};\n\n//¦\nint ans = -1;\n\nint main()\n{\n\tstring rgb;\n\tstring temp;\n\tint i,j, len;\n\tint temp3;\n\tchar g;\n\t\n\t\n\tfor(;;){\n\t\t\n\t\tset<string> table;\n\n\t\tcin >> rgb;\n\t\tif(rgb == \"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tlen = rgb.size();\n\t\tans = -1;\n\t\tqueue<DATA> Q;\n\t\t\n\t\tDATA start(rgb,0);\n\t\t\n\t\tQ.push(start);\n\t\twhile(!Q.empty()){\n\t\t\t//`FbN·éf[^ðæèo·\n\t\t\tDATA d = Q.front();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif(table.count(d.arr)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttable.insert(d.arr);\n\t\t\t\n\t\t\t//I¹\n\t\t\tif(d.check() == 1){\n\t\t\t\tans = d.step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//·×ÄÌp^[ÉÎµÄóÔJÚµAL[Éi[\n\t\t\tfor(i = 0; i < len-1; i++){\n\t\t\t\ttemp = d.arr;\n\t\t\t\tif(d.arr[i] != d.arr[i+1]){\n\t\t\t\t\tswitch(d.arr[i]+d.arr[i+1]){\n\t\t\t\t\t\tcase R+B:\n\t\t\t\t\t\t\ttemp[i] = temp[i+1]= G;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase R+G:\n\t\t\t\t\t\t\ttemp[i] = temp[i+1] = B;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase G+B:\n\t\t\t\t\t\t\ttemp[i] = temp[i+1] = R;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tDATA next(temp,d.step+1);\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<set>\n#include<utility>\nusing namespace std;\nchar C(char a,char b)\n{\n\tif(a!='r'&&b!='r')return'r';\n\tif(a!='g'&&b!='g')return'g';\n\treturn'b';\n}\nint F(string s)\n{\n\tint i,b;\n\tstring n;\n\tset<string> h;\n\ttypedef pair<string,int>T;\n\tqueue<T> q;\t\n\tT p;\n\tq.push(make_pair(s,0));\n\twhile(!q.empty())\n\t{\n\t\tp=q.front();q.pop();\n\t\ts=p.first;\n\t\tif(!h.insert(s).second)continue;\n\t\tfor(b=1,i=0;i+1<s.size();++i)\n\t\t\tif(s[i]!=s[i+1])b=0;\n\t\tif(b) return p.second;\n\n\t\tfor(i=0;i+1<s.size();++i)\n\t\t{\n\t\t\tif(s[i]!=s[i+1])\n\t\t\t{\n\t\t\t\tn=s;\n\t\t\t\tn[i]=n[i+1]=C(n[i],n[i+1]);\n\t\t\t\tq.push(make_pair(n,p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n\tstring s;\n\tint n;\n\twhile(cin>>s,s[0]-'0')\n\t\tif((n=F(s))<0) cout<<\"NA\\n\";\n\t\telse cout<<n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clear time: 01:55\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<string, int> bug;\n\nint isOK(string str) {\n    // cout << \"str:\" << str << \" \" << str.size() << endl;\n    for ( int i = 0; i < str.size(); i++ ) {\n        if ( str[0] != str[i] ) return 0;\n    }\n    return 1;\n}\n\nchar cc(char a, char b) {\n    // 並び替え\n    if ( b < a ) {\n        char tmp = a;\n        a = b;\n        b = tmp;\n    }\n\n    if ( a == 'b' && b == 'g' ) {\n        return 'r';\n    } else if ( a == 'b' && b == 'r' ) {\n        return 'g';\n    } else {\n        return 'b';\n    }\n}\n\nint has(vector<string> &list, string str) {\n    vector<string>::iterator sit = find(list.begin(), list.end(), str);\n    return sit != list.end();\n}\n\nvoid wfs(string str) {\n    int cnt = -1;\n    string first = str;\n    queue<bug> open;\n    vector<string> closed;\n\n    // 初期状態をプッシュ\n    open.push( make_pair(str, 0) );\n\n    closed.push_back(str);\n\n\n    while(!open.empty()) {\n        bug b = open.front(); open.pop();\n        string cs = b.first;\n\n        if ( isOK(cs) ) {\n            cnt = b.second;\n            break;\n        }\n\n        int c = 0;\n        for ( int i = 1; i < cs.size(); i++ ) {\n            if ( cs[i-1] != cs[i] ) {\n                string tmp = cs;\n                char nc = cc(cs[i-1], cs[i]);\n                tmp[i-1] = nc;\n                tmp[i] = nc;\n\n                if ( has(closed, tmp) ) continue;\n                open.push( make_pair(tmp, b.second+1) );\n                closed.push_back(tmp);\n                c++;\n            }\n        }\n    }\n\n    if ( cnt == -1 ) {\n        cout << \"NA\" << endl;\n    } else {\n        cout << cnt << endl;\n    }\n\n\n}\n\nint main() {\n    string n;\n\n    while ( cin >> n, n != \"0\" ) {\n        wfs(n);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nint main() {\n  string musi;\n  while(cin >> musi, musi != \"0\") {\n    string tonum;\n    for(int i=0; i<musi.size(); i++) {\n      if(musi[i] == 'r')\n        tonum.push_back('1');\n      if(musi[i] == 'g')\n        tonum.push_back('2');\n      if(musi[i] == 'b')\n        tonum.push_back('3');\n    }\n    queue< pair<string, int> > q;\n    pair<string, int> p;\n    p.first = tonum;\n    p.second = 0;\n    q.push(p);\n    bool flg = true;\n//    vector<string> memo;\n    int test = 0;\n    while(q.size()) {\n      p = q.front();\n      q.pop();\n//      cout << p.first << ' ' << test << endl;\n      test++;\n      int cnt = 0;\n      for(int i=1; i<p.first.size(); i++) {\n        if(p.first[i-1] != p.first[i]) {\n          pair<string, int> p2;\n          p2 = p;\n          int n = (int)p.first[i-1] + (int)p.first[i] - '0' - '0';\n          if(n==3) {\n            p2.first[i-1] = '3';\n            p2.first[i] = '3';\n          }\n          else if(n==4) {\n            p2.first[i-1] = '2';\n            p2.first[i] = '2';\n          }\n          else if(n==5) {\n            p2.first[i-1] = '1';\n            p2.first[i] = '1';\n          }\n//          if(find(memo.begin(), memo.end(), p2.first) == memo.end()) {\n            p2.second++;\n            q.push(p2);\n//            memo.push_back(p2.first);\n//          }\n        }\n        else cnt++;\n        if(test > 100000) break;\n      }\n      if(cnt == p.first.size()-1) {\n        flg = false;\n        cout << p.second << endl;\n        break;\n      }\n    }\n    if(flg) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct s{\n    string worm;\n    int nowans;\n};\nint main(){\n    char dc[6][3]={'r','g','b','g','r','b','r','b','g','b','r','g','g','b','r','b','g','r'};\n    while(1){\n        int che[100000]={0},chenum=0;\n        s IN,now;\n        queue <s> que;\n        cin >> IN.worm;\n        IN.nowans=0;\n        if(IN.worm[0]=='0')\n            break;\n        que.push(IN);\n        while(1){\n            chenum=0;\n            now=que.front(),que.pop();\n            for(int i=0;i<10;i++){\n                if(now.worm[i]=='r')\n                    chenum+=pow(3,i);\n                else if(now.worm[i]=='g')\n                    chenum+=pow(3,i)*2;\n                else if(now.worm[i]=='b')\n                    chenum+=pow(3,i)*3;\n            }\n            if(che[chenum])\n                continue;\n            else\n                che[chenum]=1;\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1])\n                    break;\n                if(i==now.worm.size()-1-1){\n                    printf(\"%d\\n\",now.nowans);\n                    goto exit;\n                }\n            }\n            if(now.nowans==20){\n                puts(\"NA\");\n                goto exit;\n            }\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1]){\n                    for(int j=0;j<6;j++){\n                        if(now.worm[i]==dc[j][0]&&now.worm[i+1]==dc[j][1]){\n                            now.worm[i]=dc[j][2],now.worm[i+1]=dc[j][2],now.nowans++;\n                            que.push(now);\n                            now.worm[i]=dc[j][0],now.worm[i+1]=dc[j][1],now.nowans--;\n                        }\n                    }\n                }\n            }\n        }\nexit:\n    printf(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nmap<string, int> seenbefore;\nstring in;\nmap<string, int>::iterator it;\n\nstring check(string twochars){\n  if(twochars[0] == twochars[1]) return \"\";\n  if(twochars[0] == 'r')\n    if(twochars[1] == 'g') return \"b\";\n    else return \"g\";\n  else\n    if(twochars[0] == 'g')\n      if(twochars[1] == 'r') return \"b\";\n      else return \"r\";\n    else\n      if(twochars[1] == 'r') return \"g\";\n      else return \"r\";\n}\n\nint next_generation(string now, int gen){\n  if(now.find(\"r\") + now.find(\"g\") + now.find(\"b\") == -2) return gen;\n  if((it = seenbefore.find(now)) != seenbefore.end()){\n    if((*it).second > gen) (*it).second = gen;\n    else return -1;\n  }\n  seenbefore.insert(map<string, int>::value_type(now, gen));\n  int len = now.length();\n  int ans = 99999999, y;\n  for(int i = 0; i < len - 1; i++){\n    string che = check(now.substr(i, 2));\n    if(che != \"\"){\n      y = next_generation(now.substr(0, i) + che + che + now.substr(i+2), gen + 1);\n      if(y != -1) ans = min(ans, y);\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while((cin >> in), in != \"0\"){\n    seenbefore.clear();\n    int x = next_generation(in, 0);\n    if (x >= 0) cout << x << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint ar[11], ag[11], ab[11];\nbool checked[59049];\nint p3[11];\nmap<int,int> change = {\n    {0,0}, {1,8}, {2,4}, {3,8}, {4,4}, {5,0}, {6,4}, {7,0}, {8,8}\n};\n\nint conv(string s) {\n    int ret = 0;\n    for (int i=0; i<(int)s.size(); ++i) {\n        ret *= 3;\n        if (s[i] == 'g') ret += 1;\n        if (s[i] == 'b') ret += 2;\n    }\n    return ret;\n}\n\nint rotate(int x, int n) {\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        ret = ret * 3 + (x % 3 + 1) % 3;\n        x /= 3;\n    }\n    return ret;\n}\n\nint main() {\n    p3[0] = 1;\n    for (int i=1; i<=10; ++i) {\n        p3[i] = p3[i-1] * 3;\n    }\n    ar[0] = ag[0] = ab[0] = 0;\n    for (int i=1; i<=10; ++i) {\n        ar[i] = ar[i-1];\n        ag[i] = ag[i-1] * 3 + 1;\n        ab[i] = ab[i-1] * 3 + 2;\n    }\n    string s;\n    while (cin >> s, s != \"0\") {\n        memset(checked, false, sizeof checked);\n        int n = s.size();\n        int first = conv(s);\n        queue<pair<int,int> > q;\n        q.push(make_pair(first, 0));\n        checked[first] = true;\n        int res = -1;\n        while ( ! q.empty()) {\n            int col = q.front().first;\n            int t = q.front().second;\n            q.pop();\n            if (col == ar[n] || col == ag[n] || col == ab[n]) {\n                res = t;\n                break;\n            }\n            for (int i=0; i<n-1; ++i) {\n                int replace = change[(col / p3[i]) % 9];\n                int nx = (col / p3[i+2]) * p3[i+2] + replace * p3[i] + (col % p3[i]);\n                if ( ! checked[nx]) {\n                    q.push(make_pair(nx, t+1));\n                    checked[nx] = true; nx = rotate(nx, n);\n                    checked[nx] = true; nx = rotate(nx, n);\n                    checked[nx] = true;\n                }\n            }\n        }\n        if (res < 0) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n  return n;\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n}\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(i=0;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    k=-1;\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      if(mi==0||mi==n||mi==n*2)break;\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n    f(mi,a);\n    //for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n    a[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n    //for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n    j=g(a);//printf(\"%d\\n\",j);\n    //if(j==0||j==n||j==n*2)break;\n    if(c[j]>c[mi]+1){\n      c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n      k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n      for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n      h[j]=k;//printf(\"%d\\n\",j);\n    }\n      }//printf(\"\\n\");prih(h,r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n    h[i]=h[j=i*2];\n    if(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      if(r==1)break;\n      h[i/2]=k;\n    }\n    if(r-1||k==-1)printf(\"%d\\n\",c[mi]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nbool same(char* seq){\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    if(seq[i] != seq[i+1]){\n      return false;\n    }\n  }\n  return true;\n}\nint dls(char* seq, int depth){\n  if(depth<0){\n    return false;\n  }\n  if(same(seq)){\n    return true;\n  }\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    char t = seq[i];\n    char n = seq[i+1];\n    if(t != n){\n      if((t + n) == ('r' + 'b')){\n        seq[i] = seq[i+1] = 'g';\n      }\n      else if((t + n) == ('r' + 'g')){\n        seq[i] = seq[i+1] = 'b';\n      }\n      else{\n        seq[i] = seq[i+1] = 'r';\n      }\n      if(dls(seq, depth-1)){\n        return true;\n      }\n      seq[i] = t;\n      seq[i+1] = n;\n    }\n  }\n  return false;\n}\nvoid iddfs(char* seq){\n  for(int depth = 0;depth <= 9; ++depth){\n    if(dls(seq, depth)){\n      cout << depth << endl;\n      return;\n    }\n  }\n  cout << \"NA\" << endl;\n}\nint main(){\n  char seq[11];\n  while(true){\n    cin >> seq;\n    if(seq[0] == '0'){\n      break;\n    }\n    iddfs(seq);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nchar keisan(char a, char b) {\n\tif (a == b) {\n\t\treturn a;\n\t} else {\n\t\tstring abc = \"rbg\";\n\t\tint aa, bb;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (a == abc[i]) {\n\t\t\t\taa = i;\n\t\t\t} \n\t\t\tif (b == abc[i]) {\n\t\t\t\tbb = i;\n\t\t\t}\n\t\t}\n\t\treturn abc[3-(aa+bb)];\n\t}\n}\n\nbool hantei(string a) {\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (a[0] != a[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tstring a;\n\twhile (cin >> a) {\n\t\tif (a[0] == '0') {\n\t\t\tbreak;\n\t\t}\n\t\tif (hantei(a)) {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\tqueue<P> q;\n\t\t\tvector<string> hyou;\n\t\t\thyou.push_back(a);\n\t\t\tbool hantei2 = false;\n\t\t\tfor (int i = 0; i < a.size()-1; i++) {\n\t\t\t\tstring c;\n\t\t\t\tc = a;\n\t\t\t\tc[i] = keisan(a[i], a[i+1]);\n\t\t\t\tc[i+1] = keisan(a[i], a[i+1]);\n\t\t\t\tif (hantei(c)) {\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\thantei2 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = c;\n\t\t\t\t\tp.second = 2;\n\t\t\t\t\tq.push(p);\n\t\t\t\t\thyou.push_back(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!q.empty()) {\n\t\t\t\tif (hantei2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tstring b = p.first;\n\t\t\t\tfor (int i = 0; i < b.size()-1; i++) {\n\t\t\t\t\tstring c;\n\t\t\t\t\tc = b;\n\t\t\t\t\tc[i] = keisan(b[i], b[i+1]);\n\t\t\t\t\tc[i+1] = keisan(b[i], b[i+1]);\n\t\t\t\t\tif (hantei(c)) {\n\t\t\t\t\t\tcout << p.second << endl;\n\t\t\t\t\t\thantei2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbool hantei3 = true;\n\t\t\t\t\t\tfor (int i = 0; i < hyou.size(); i++) {\n\t\t\t\t\t\t\tif (c == hyou[i]) {\n\t\t\t\t\t\t\t\thantei3 = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hantei3) {\n\t\t\t\t\t\t\tP pp;\n\t\t\t\t\t\t\tpp.first = c;\n\t\t\t\t\t\t\tpp.second = p.second+1;\n\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\thyou.push_back(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hantei2) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define pb push_back\n#define mp make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)x;++i)\n#define rep1(i,x) for(int i=1;i<=(int)x;++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(int)x;i>=1;--i)\n#define repf(i,a,x) for(int i=a;i<(int)x;++i)\n#define repf1(i,a,x) for(int i=a;i<=(int)x;++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 1e18;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\twhile (cin >> s, s[0] != '0') {\n\t\tmap<string, bool> m;\n\n\t\tqueue<string> q, r;\n\n\t\tq.push(s);\n\n\t\tint cnt = 0;\n\n\t\twhile (q.size()) {\n\t\t\twhile (q.size()) {\n\t\t\t\tstring t = q.front(); q.pop();\n\t\t\t\tif (m[t]) continue;\n\t\t\t\tm[t] = true;\n\t\t\t\tbool f = true;\n\t\t\t\trep(i, t.size() - 1) {\n\t\t\t\t\tif ((t[i] == 'r' && t[i + 1] == 'b') || (t[i] == 'b' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'g';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'b' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'b')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'r';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'r' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'b';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tcout << cnt << endl;\n\t\t\t\t\tgoto nxt;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (r.size()) {\n\t\t\t\tstring t = r.front(); r.pop();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\tcout << \"NA\\n\";\nnxt:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nint main()\n{\n\tstring first;\n\tqueue<string> body;\n\tmap<string, int> second;\n\tbool aligned = true;\n\tchar changecolor;\n\tstring tmp;\n\n\twhile (1)\n\t{\n\t\tcin >> first;\n\t\tif (first[0] == '0') return 0;\n\n\t\tbody.push(first);\n\t\tsecond[first] = 0;\n\n\t\twhile (!body.empty())\n\t\t{\n\t\t\taligned = true;\n\n\t\t\tfor (int i = 0; i < body.front().size() - 1; ++i)\n\t\t\t{\n\t\t\t\ttmp = body.front();\n\n\t\t\t\tif (tmp[i] == 'r' && tmp[i + 1] == 'g') changecolor = 'b';\n\t\t\t\tif (tmp[i] == 'r' && tmp[i + 1] == 'b') changecolor = 'g';\n\t\t\t\tif (tmp[i] == 'g' && tmp[i + 1] == 'r') changecolor = 'b';\n\t\t\t\tif (tmp[i] == 'g' && tmp[i + 1] == 'b') changecolor = 'r';\n\t\t\t\tif (tmp[i] == 'b' && tmp[i + 1] == 'r') changecolor = 'g';\n\t\t\t\tif (tmp[i] == 'b' && tmp[i + 1] == 'g') changecolor = 'r';\n\n\t\t\t\tif (tmp[i] != tmp[i + 1])\n\t\t\t\t{\n\t\t\t\t\taligned = false;\n\t\t\t\t\ttmp[i] = changecolor;\n\t\t\t\t\ttmp[i + 1] = changecolor;\n\t\t\t\t}\n\n\t\t\t\tif (second.count(tmp) == 0)\n\t\t\t\t{\n\t\t\t\t\tsecond[tmp] = second[body.front()] + 1;\n\t\t\t\t\tbody.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (aligned)\n\t\t\t{\n\t\t\t\tcout << second[body.front()] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbody.pop();\n\t\t}\n\n\t\tif(body.empty()) cout << \"NA\" << endl;\n\n\t\tfirst.clear();\n\t\tsecond.clear();\n\t\twhile (!body.empty()) body.pop();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// c1, c2 テ」ツ??r', 'g', 'b', テ」ツ?凝」ツ?、(c1 != c2)テ」ツ?ョテ」ツ?ィテ」ツ??\n// m[c1+c2] テ」ツ?ァ c1, c2 テ」ツ?ァテ」ツ?ェテ」ツ??r', 'g', 'b'テ」ツ?古ィツソツ氾」ツ?」テ」ツ?ヲテ」ツ?湘」ツつ?\nmap<int,char> m;\n\n// テ・ツ?ィテゥツδィテ・ツ青古」ツ?佚ィツ可イテ」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool isSameColor(const string& s){\n\tchar c[3] = {'r','g','b'};\n\tfor(int i = 0 ; i < 3 ; i++ ){\n\t\tint cnt = 0;\n\t\tfor(int j=0 ; j < s.size() ; j++ ){\n\t\t\tif( s[j] == c[i] )\n\t\t\t\tcnt++;\n\t\t}\n\t\tif( cnt == s.size() )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint solve(string s_ ){\n\t// memo[s] = true テ」ツ?ェテ」ツつ嘉ヲツ篠「テァツエツ「テヲツクツ暗」ツ?ソ\n\tmap<string,bool> memo;\n\t// q.front().first テ」ツ?ッ ティツ卍ォテ」ツ?ョテァツ環カテヲツ??string) q.front().second テ」ツ?ッテヲツ可凝ヲツ閉ー(int)\n\tqueue< pair<string,int> > q;\n\t\n\t// テ・ツ按敕ヲツ慊淌ァツ環カテヲツ?凝」ツつ津」ツつュテ」ツδ・テ」ツδシテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ?\n\tpair<string,int> ini( s_ , 0  );\n\tq.push( ini );\n\tmemo[s_] = true;\n\t\n\t// テ」ツつュテ」ツδ・テ」ツδシテ」ツ?古ァツゥツコテ」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?セテ」ツ?ァテ」ツδォテ」ツδシテ」ツδ?\n\twhile( !q.empty() ){\n\t\t// stirng s; テ」ツ?ッティツ卍ォテ」ツ?ョテァツ環カテヲツ?? int cnt; テ」ツ?ッテヲツ可凝ヲツ閉ー\n\t\tstring s = q.front().first;\n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\t// テ・ツ?ィテゥツδィテ・ツ青古」ツ?佚ィツ可イテ」ツ?ェテ」ツつ嘉ヲツ篠「テァツエツ「テァツオツづ、ツコツ?\n\t\tif( isSameColor(s) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t// テ」ツ?セテ」ツ??ヲツ篠「テァツエツ「テ」ツ?療」ツ?ヲテ」ツ??」ツ?ェテ」ツ??ヲツャツ。テ」ツ?ョテァツ環カテヲツ?凝」ツつ津」ツつュテ」ツδ・テ」ツδシテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ?\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( s[i-1] != s[i] ){\n\t\t\t\tchar next_color = m[s[i-1]+s[i]];\n\t\t\t\tchar c1 = s[i-1];\n\t\t\t\tchar c2 = s[i];\n\t\t\t\ts[i-1] = s[i] = next_color;\n\t\t\t\tif( memo[s] != true ){\n\t\t\t\t\tmemo[s] = true;\n\t\t\t\t\tpair<string,int> next;\n\t\t\t\t\tnext.first = s;\n\t\t\t\t\tnext.second = cnt + 1;\n\t\t\t\t\tq.push( next );\n\t\t\t\t}\n\t\t\t\ts[i-1] = c1;\n\t\t\t\ts[i] = c2;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring s;\n\tm['r'+'g'] = 'b';\n\tm['g'+'b'] = 'r';\n\tm['b'+'r'] = 'g';\n\t\n\twhile( cin >> s , s != \"0\" ){\n\t\tint ans = solve( s );\n\t\tif( ans == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    que.push(pair<string, int>(worm, 0));\n    string worm1, tmp;\n    int num;\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        worm1 = que.front().first;\n        num = que.front().second;\n        que.pop();\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        if(num >= 10){\n            return -1;\n        }\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <queue>\nusing namespace std;\n\nmap<int,bool> isre;\nmap<int,int> dp;\n\nint code(string s){\n    int ret=0,kake=1;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='r') ret+=kake*1;\n        else if(s[i]=='g') ret+=kake*2;\n        else ret+=kake*3;\n        kake*=4;\n    }\n    return ret;\n}\n\nint main(){\n    string in;\n    for(;;){\n        cin>>in;\n        if(in==\"0\") break;\n        map<int,bool> isre;\n        queue<string> nq;\n        nq.push(in);\n        int ret=-1;\n        int cnt=0;\n        while(!nq.empty()){\n            int sz=nq.size();\n            for(int i=0;i<sz;i++){\n                string now=nq.front();\n                nq.pop();\n                int co=code(now);\n                if(isre.find(co)!=isre.end() && isre[co]) continue;\n                isre[co]=true;\n                bool is=true;\n                for(int j=0;j<now.size();j++){\n                    if(now[j]!=now[0]) is=false;\n                }\n                if(is){\n                    ret=cnt;\n                    goto EXIT;\n                }\n                for(int j=1;j<now.size();j++){\n                    string ne=now;\n                    if(now[j-1]!=now[j]){\n                        if(now[j-1]!='r'&&now[j]!='r'){\n                            ne[j-1]=ne[j]='r';\n                        }else if(now[j-1]!='g'&&now[j]!='g'){\n                            ne[j-1]=ne[j]='g';\n                        }else{\n                            ne[j-1]=ne[j]='b';\n                        }\n                        nq.push(ne);\n                    }\n                }\n            }\n            cnt++;\n        }\nEXIT:   ;\n        if(ret==-1) cout<<\"NA\"<<endl;\n        else cout<<ret<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint dp[60000];\nint hash_(string s) {\n\tint ret = 0;\n\tfor(int i = 0; i < s.size(); i++) {\n\t\tret *= 3;\n\t\tif(s[i] == 'g') ret += 1;\n\t\tif(s[i] == 'b') ret += 2;\n\t}\n\treturn ret;\n}\nstring s; int w, w2;\nint main() {\n\twhile(cin >> s, s != \"0\") {\n\t\tmemset(dp, -1, sizeof(dp)); w = 0, w2 = 1;\n\t\tfor(int i = 0; i < s.size(); i++) w += w2, w2 *= 3;\n\t\tint h2 = hash_(s); dp[h2] = 0;\n\t\tif(h2 % w == 0) {\n\t\t\tprintf(\"0\\n\"); continue;\n\t\t}\n\t\tqueue<string> que; que.push(s); bool flag = false;\n\t\twhile(!que.empty()) {\n\t\t\tstring t = que.front(); que.pop(); int h_ = hash_(t);\n\t\t\tfor(int i = 1; i < t.size(); i++) {\n\t\t\t\tif(t[i - 1] != t[i]) {\n\t\t\t\t\tstring u = t;\n\t\t\t\t\tif(t[i - 1] != 'r' && t[i] != 'r') u[i - 1] = 'r', u[i] = 'r';\n\t\t\t\t\telse if(t[i - 1] != 'g' && t[i] != 'g') u[i - 1] = 'g', u[i] = 'g';\n\t\t\t\t\telse u[i - 1] = 'b', u[i] = 'b';\n\t\t\t\t\tint h = hash_(u);\n\t\t\t\t\tif(h % w == 0) {\n\t\t\t\t\t\tprintf(\"%d\\n\", dp[h_] + 1); flag = true; break;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[h] == -1) {\n\t\t\t\t\t\tdp[h] = dp[h_] + 1; que.push(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tif(!flag) printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool isAns(string s){\n  int len = s.length();\n  FOR(i,1,len){\n    if(s[0] != s[i]) return false;\n  }\n  return true;\n}\n\nchar diffColor(char a, char b){\n  if((a == 'r' && b == 'g') || (a == 'g' && b == 'r')){\n    return 'b';\n  }else if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')){\n    return 'r';\n  }else{\n    return 'g';\n  }\n}\n\nint main(){\n\n  while(true){\n    string s;\n    cin >> s;\n    if(s == \"0\") break;\n\n    map<string, int> mp;\n    mp[s] = 1;\n    queue<string> que;\n\n    que.push(s);\n    bool found = false;\n    while(!que.empty()){\n      s = que.front();\n      que.pop();\n\n      if(isAns(s)){\n        found = true;\n        cout << mp[s] - 1 << \"\\n\";\n        break;\n      }\n\n      int len = s.length();\n      REP(i,len-1){\n        if(s[i] != s[i+1]){\n          string v = s;\n          char tmp = diffColor(s[i], s[i+1]);\n          v[i] = tmp; v[i+1] = tmp;\n          if(mp[v] == 0){\n            mp[v] = mp[s] + 1;\n            que.push(v);\n          }\n        }\n      }\n    }\n    if(!found){\n      cout << \"Na\\n\";\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<cstring>\n#include<set>\nusing namespace std;\n\n//I¹Èç1ðÔ·\nint samechar(string str);\n\n//¯¶àÌª©Â©Á½ç1AÝÂ©ÈçÈ©Á½ç0ðÔ·\nint samecheck(string str);\n\n//strÌ[chari_1]Æ[chari_2]ÌFðÏ»³¹é\nstring exchange(string str, int chari_1, int chari_2);\n\nset<string> samecheckset;\n\nint main(){\n\tstring input;\n\twhile(cin >>input){\n\t\tif(input[0] == '0') break;\n\t\t\n\t\tsamecheckset.clear();\n\t\t\n\t\t//cnt = oÍ·é¦([³) endflag = I¹ðª©Â©Á½ç1\n\t\tint cnt = 0, endflag = 0;\n\t\t\n\t\t//qu1 = ¡Ì[³Ìg qu2 = Ì[³Ìg\n\t\tqueue<string> qu1, qu2;\n\t\tqu1.push(input);\n\t\tqu2.push(\"temp\");\n\t\twhile(!qu2.empty()){\n\t\t\twhile(!qu2.empty()){\n\t\t\t\tqu2.pop();\n\t\t\t}\n\t\t\twhile(!qu1.empty()){\n\t\t\t\tstring temp = qu1.front();\n\t\t\t\tqu1.pop();\n\t\t\t\t\n\t\t\t\t//I¹ð¾Á½çbreak\n\t\t\t\tif(samechar(temp) == 1){\n\t\t\t\t\tendflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//¯¶àÌªsamechecksetÉ©Â©Á½çcontinue\n\t\t\t\tif(samecheck(temp) == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//temp©çÏ»·é·×ÄÌFÌp^[ÌÂ\\«ðqu2Éüêé\n\t\t\t\tfor(int i = 0; i < temp.size() - 1; i++){\n\t\t\t\t\tif(temp[i] != temp[i + 1]){\n\t\t\t\t\t\tqu2.push(exchange(temp, i, i + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(endflag == 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//Ì[³ÉÚéÌÅAqu2Ìgð·×Äqu1ÉÚ·\n\t\t\tqu1 = qu2;\n\t\t\t\n\t\t\t//[³(b)ð1Ââ·\n\t\t\tcnt++;\n\t\t}\n\t\tif(endflag == 0){\n\t\t\tcout <<\"NA\" <<endl;\n\t\t} else{\n\t\t\tcout <<cnt <<endl;\n\t\t}\n\t}\n}\n\nstring exchange(string str, int chari_1, int chari_2){\n\tif(str[chari_1] != 'r' && str[chari_2] != 'r'){\n\t\tstr[chari_1] = 'r';\n\t\tstr[chari_2] = 'r';\n\t} else if(str[chari_1] != 'g' && str[chari_2] != 'g'){\n\t\tstr[chari_1] = 'g';\n\t\tstr[chari_2] = 'g';\n\t} else if(str[chari_1] != 'b' && str[chari_2] != 'b'){\n\t\tstr[chari_1] = 'b';\n\t\tstr[chari_2] = 'b';\n\t}\n\treturn str;\n}\n\nint samechar(string str){\n\tint ans = 1;\n\tchar temp = str[0];\n\tfor(int i = 1; i < str.size(); i++){\n\t\tif(temp != str[i]){\n\t\t\tans = 0;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint samecheck(string str){\n\tif(samecheckset.find(str) == samecheckset.end()){\n\t\tsamecheckset.insert(str);\n\t\treturn 0;\n\t} else{\n\t\treturn 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nconst int inf = 99999;\n\nstruct St{\n  string worm;\n  int cnt;\n};\n\ntypedef map<string, bool> Mp;\n\nbool check(string str)\n{\n  bool f = true;  \n\n  for(int i = 1; i < str.size(); i++){\n    if(str[i] != str[0]){\n      f = false;\n      break;\n    }\n  }\n\n  return f;\n}\n\nchar getC(char s, char t)\n{\n  if((s == 'r' && t == 'g') || (s == 'g' && t == 'r')){\n    return 'b';\n  }\n  if((s == 'r' && t == 'b') || (s == 'b' && t == 'r')){\n    return 'g';\n  }\n\n  return 'r';\n}\n\nint bfs(string str)\n{\n  int r = inf+1;\n  queue<St> que;\n  map<string, bool> mpp;\n  St st1, st2;\n  st1.worm = str;\n  st1.cnt = 0;\n  que.push(st1);\n  mpp[str] = true;\n\n  while(!que.empty()){\n    st1 = que.front();\n    que.pop();\n    if(check(st1.worm) || st1.cnt > inf){\n      r = st1.cnt;\n      break;\n    }\n\n    for(int i = 0; i < (st1.worm).size()-1; i++){\n      string s1 = st1.worm;\n      if(s1[i] != s1[i+1]){\n\ts1[i] = s1[i+1] = getC(s1[i], s1[i+1]);\n\tif(!mpp[s1]){\n\t  mpp[s1] = true;\n\t  st2.worm = s1;\n\t  st2.cnt = st1.cnt+1;\n\t  que.push(st2);\n\t}\n      }\n    }\n  }\n\n\n  return r;\n}\n\nint main()\n{\n  int t;\n  string str;\n\n  while(cin>>str && str != \"0\"){\n    t = bfs(str);\n    if(t > inf){\n      cout << \"NA\" << endl;\n    } else {\n      cout << t << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<string,int> P;\nint main() {\n    string S;\n    while(cin>>S,S[0]!='0') {\n        set<string> ST;\n        queue<P> Q;\n        Q.push(P(S,0));\n        string R,G,B;\n        bool OK;\n        while(!Q.empty()) {\n            P p=Q.front();Q.pop();\n            OK=true;\n            for(int i=0;i<p.first.size()-1;i++) {\n                string SS=p.first;\n                if((p.first[i]=='r'&&p.first[i+1]=='g')||(p.first[i]=='g'&&p.first[i+1]=='r')) {\n                        SS[i]=SS[i+1]='b';\n                        if(ST.find(SS)==ST.end()){\n                            Q.push(P(SS,p.second+1));\n                            ST.insert(SS);\n                        }\n                        OK=false;\n                }else if((p.first[i]=='r'&&p.first[i+1]=='b')||(p.first[i]=='b'&&p.first[i+1]=='r')) {\n                        SS[i]=SS[i+1]='g';\n                        if(ST.find(SS)==ST.end()){\n                            Q.push(P(SS,p.second+1));\n                            ST.insert(SS);\n                        }\n                        OK=false;\n                }else if((p.first[i]=='g'&&p.first[i+1]=='b')||(p.first[i]=='b'&&p.first[i+1]=='g')) {\n                        SS[i]=SS[i+1]='r';\n                        if(ST.find(SS)==ST.end()){\n                            Q.push(P(SS,p.second+1));\n                            ST.insert(SS);\n                        }\n                        OK=false;\n                }\n            }\n            if(OK) {cout<<p.second<<endl;break;}\n        }\n        if(!OK)cout<<\"NA\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<string,bool > passed;\n\nconst int INF=100000000;\n\nint dfs(string str){\n\tif(passed.find(str)!=passed.end()&&passed[str]){\n\t\treturn INF;\n\t}\n\tchar cl=str[0];\n\tbool f=false;\n\tfor(int i = 1; i < str.size(); i++){\n\t\tif(str[i]!=cl){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)\n\t\treturn 0;\n\n\tbool flag[200];\n\tint minCnt=INF;\n\tfor(int i = 0; i < str.size()-1; i++){\n\t\tflag['r']=false;\n\t\tflag['g']=false;\n\t\tflag['b']=false;\n\t\tif(str[i]!=str[i+1]){\n\t\t\tflag[str[i]]=true;\n\t\t\tflag[str[i+1]]=true;\n\t\t\tif(!flag['r']){\n\t\t\t\tstring nstr=str;\n\t\t\t\tnstr[i]='r';\n\t\t\t\tnstr[i+1]='r';\n\t\t\t\tpassed[str]=true;\n\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t\t\t\tpassed[str]=false;\n\t\t\t}\n\t\t\telse if(!flag['g']){\n\t\t\t\tstring nstr=str;\n\t\t\t\tnstr[i]='g';\n\t\t\t\tnstr[i+1]='g';\n\t\t\t\tpassed[str]=true;\n\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t\t\t\tpassed[str]=false;\n\t\t\t}\n\t\t\telse if(!flag['b']){\n\t\t\t\tstring nstr=str;\n\t\t\t\tnstr[i]='b';\n\t\t\t\tnstr[i+1]='b';\n\t\t\t\tpassed[str]=true;\n\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t\t\t\tpassed[str]=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn minCnt;\n}\n\nint main(){\n\n\tstring str;\n\twhile(cin>>str&&str!=\"0\"){\n\t\tcout<<dfs(str)<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef long long int ll;\n\nll tr(string a);\nbool cl(string a);\nint c3(ll a);\nint solve(string st);\n\nint main()\n{\n    string input;\n    cin >> input;\n    while (input[0] != '0') {\n        int ans = solve(input);\n        if (ans != INF) {\n            cout << ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n        cin >> input;\n    }\n    return 0;\n}\n\nint solve(string st)\n{\n    int ans = 0;\n    bool check[177150];\n    queue<string> a, b, c;\n    if ( cl(st) ) {\n        return ans;\n    }\n    a.push(st);\n    while (!a.empty()) {\n        while (!a.empty()) {\n            st = a.front();\n            a.pop();\n            if (check[c3(tr(st))]) {\n                continue;\n            } else {\n                check[c3(tr(st))] = true;\n            }\n            if (cl(st)) {\n                return ans;\n            }\n            for (int i = 1; i < st.size(); i++) {\n                if (st[i-1] != st[i]) {\n                    string nw(st);\n                    if (st[i-1] != 'r' && st[i] != 'r') {\n                        nw[i-1] = 'r';\n                        nw[i] = 'r';\n                    } else if (st[i-1] != 'g' && st[i] != 'g') {\n                        nw[i-1] = 'g';\n                        nw[i] = 'g';\n                    } else if (st[i-1] != 'b' && st[i] != 'b') {\n                        nw[i-1] = 'b';\n                        nw[i] = 'b';\n                    }\n                    b.push(nw);\n                }\n            }\n        }\n        a = b;\n        b = c;\n        ans++;\n    }\n    return INF;\n}\n\nll tr(string a)\n{\n    ll ret = 0;\n    for (int i = 0; i < a.size(); i++) {\n        ret *= 10;\n        if (a[i] == 'r') {\n            ret += 1;\n        } else if (a[i] == 'g') {\n            ret += 2;\n        } else {\n            ret += 3;\n        }\n    }\n    return ret;\n}\n\nbool cl(string a)\n{\n    for (int i = 1; i < a.size(); i++) {\n        if (a[i-1] != a[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint c3(ll a)\n{\n    int ret = 0;\n    if (a) {\n        ret = c3(a / 10);\n        ret *= 3;\n        ret += a % 10;\n    }\n    return ret;\n}\n\n\n        \n\n\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nstring S;\nchar f(char a,char b)\n{\n\tif(a=='r'&&b=='b')return 'g';\n\telse if(a=='r'&&b=='g')return 'b';\n\telse if(a=='b'&&b=='r')return 'g';\n\telse if(a=='b'&&b=='g')return 'r';\n\telse if(a=='g'&&b=='r')return 'b';\n\telse return 'r';\n}\nmain()\n{\n\twhile(cin>>S,S!=\"0\")\n\t{\n\t\tqueue<pair<int,string> >P;\n\t\tP.push(make_pair(0,S));\n\t\tmap<string,bool>M;\n\t\tM[S]=1;\n\t\tbool flag=1;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint u=P.front().first;\n\t\t\tstring s=P.front().second;\n\t\t\tP.pop();\n\t\t\tbool F=0;\n\t\t\tfor(int i=0;i<s.size()-1;i++)\n\t\t\t{\n\t\t\t\tif(s[i]==s[i+1])continue;\n\t\t\t\tF=1;\n\t\t\t\tstring t=s;\n\t\t\t\tt[i]=t[i+1]=f(s[i],s[i+1]);\n\t\t\t\tif(!M[t])\n\t\t\t\t{\n\t\t\t\t\tM[t]=1;\n\t\t\t\t\tP.push(make_pair(u+1,t));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!F)\n\t\t\t{\n\t\t\t\tcout<<u<<endl;\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)cout<<\"NA\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <stdio.h>\n#include <map>\nusing namespace std;\n\nvoid bfs(string worm);\nchar jump(char c1, char c2);\nint main(int argc, char const* argv[])\n{\n    string worm;\n    while ( cin >> worm ) {\n        if( worm == \"0\" ) { break; }\n        else\n        {\n            bfs(worm);\n        }\n    }\n    return 0;\n}\n\n\nvoid bfs(string worm){\n    //puts(\"enter bfs\");\n    queue<string> q;\n    string str;\n    map<string, int> dis;\n    q.push(worm); \n    dis[worm] = 0;\n\n    while ( q.size() != 0 ) \n    {\n        //puts(\"enter while\");\n        //一つ取り出す\n        str = q.front(); q.pop();\n\n        //終了判定\n        bool is_same = true;\n        for( int i=0; i<str.length()-1; i++)\n        {\n            //cout << \n            if( str[i] != str[i+1]) { is_same = false; continue; }\n        }\n        if ( is_same == true ) \n        {\n            cout << dis[str] << endl;\n            return;\n        }\n        //cout<<\"worm:\" << worm<< endl;\n        //cout<<\"str:\" << str << endl;\n        //cout<<\"time:\" << time << endl;\n\n        //色が違ったらpush\n        for(int i=0; i<str.size()-1; i++){\n            //隣が色違い\n            //puts(\"enter while\");\n            if( str[i] != str[i+1])\n            {\n                string next_str = str;\n                next_str[i] = next_str[i+1] = jump(str[i], str[i+1]);\n                //まだ通ってない\n                if ( dis.find(next_str) == dis.end() )\n                {\n                    q.push(next_str);\n                    dis[next_str] = dis[str] + 1;\n                }\n                else { continue; }\n            }\n        }\n    }\n    cout << \"NA\" << endl;\n}\n\nchar jump(char c1, char c2){\n    if(c1 != 'r' && c2 != 'r')\n    {\n        return 'r';\n    }\n    else if(c1 != 'g' && c2 != 'g')\n    {\n        return 'g';\n    }\n    else if(c1 != 'b' && c2 != 'b')\n    {\n        return 'b';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define Rrep(i, j) for(int i = j; i >= 0; --i)\n#define INF (1 << 30)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<string, int> P;\n\nstring warm;\n\n/*???????????????????????????*/\nbool SameCol(string col) {\n\trep(i, col.size() - 1) {\n\t\tif(col[i] != col[i + 1]) return false;\n\t}\n\treturn true;\n}\n/*????????????*/\nchar ChangeCol(char a, char b) {\n\tif((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n\telse if((a == 'r' && b == 'g') || (a == 'g' && b == 'r')) return 'b';\n\telse if((a == 'b' && b == 'g') || (a == 'g' && b == 'b')) return 'r';\n}\n\nint solve(string s) {\n\tmap<string, bool> m;\t/*???????????\\??¨*/\n\tqueue<P> q;\n\tq.push(P(s, 0));\n\n\twhile(!q.empty()) {\n\t\tP p = q.front(); q.pop();\n\n\t\t/*????????????*/\n\t\tif(m[p.first]) continue;\n\t\tm[p.first] = true;\n\n\t\tif(SameCol(p.first)) return p.second;\n\t\tstring now = p.first;\n\t\trep(i, now.size() - 1) {\n\t\t\tif(now[i] != now[i + 1]) {\n\t\t\t\tchar tmp = ChangeCol(now[i], now[i + 1]);\n\t\t\t\tstring tmp2 = now;\n\t\t\t\ttmp2[i] = tmp; tmp2[i + 1] = tmp;\n\t\t\t\tq.push(P(tmp2, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> warm) {\n\t\tif(warm == \"0\") break;\n\t\tint ans = solve(warm);\n\t\tif(ans == -1) printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\nchar rgb(char a, char b) {\n    assert(a != b);\n    if (a == 'r') {\n        if (b == 'g') return 'b';\n        else if (b == 'b') return 'g';\n    } else if (a == 'g') {\n        if (b == 'r') return 'b';\n        else if (b = 'b') return 'r';\n    } else {\n        if (b == 'r') return 'g';\n        else if (b == 'g') return 'r';\n    }\n    exit(1);\n}\n\nstruct state_t {\n    string worm;\n    int count;\n    state_t(string worm, int count) : worm(worm), count(count) {}\n};\n\nbool same_characters(string s) {\n    assert(!s.empty());\n    char p = s[0];\n    for (int i = 0; i < s.size(); i++) {\n        if (p != s[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    string s;\n    while (getline(cin, s)) {\n        if (s == \"0\") break;\n\n        queue<state_t> q;\n        set<string> cache;\n\n        q.push(state_t(s, 0));\n\n        bool found = false;\n        while (!q.empty()) {\n            state_t p = q.front(); q.pop();\n            string u = p.worm;\n//            cout << u << endl;\n            if (cache.count(u)) continue;\n            cache.insert(u);\n            if (same_characters(u)) {\n                cout << p.count << endl;\n                found = true;\n                break;\n            }\n            for (int i = 0; i < u.size()-1; i++) {\n                if (!(u[i] == u[i+1])) {\n                    char c = rgb(u[i], u[i+1]);\n                    string t = u; t[i] = t[i+1] = c;\n                    q.push(state_t(t, p.count+1));\n                }\n            }\n        }\n\n        if (!found) cout << \"NA\" << endl;\n\n//        for (set<string>::iterator si = cache.begin();\n//                si != cache.end(); si++) {\n//            cout << *si << ' ';\n//        }\n//        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define F(X,Y) ((X)>>((Y-1)*2)&3)\n\ntypedef pair<int,int> P;\n\nint main() {\n\tchar st[10];\n\twhile(scanf(\"%s\",st),st[0]!='0') {\n\t\tqueue<P> que;\n\t\tmap<int,bool> mp;\n\t\tint x=0,d;\n\t\tfor(d=0;st[d]!='\\0';d++) {\n\t\t\tx<<=2;\n\t\t\tx|=st[d]=='r'?0:st[d]=='b'?1:2;\n\t\t}\n\t\tmp[x]=true;\n\t\tque.push(P(x,0));\n\t\tint ans=-1;\n\t\twhile(!que.empty()) {\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tx=p.first;\n\t\t\tbool b=true;\n\t\t\tfor(int i=d;i>1;i--) {\n\t\t\t\tint t1=F(x,i),t2=F(x,i-1),t3=3-(t1+t2);\n\t\t\t\tif(t1==t2) continue;\n\t\t\t\telse b=false;\n\t\t\t\tint y=0;\n\t\t\t\tfor(int j=d;j>0;j--) {\n\t\t\t\t\ty<<=2;\n\t\t\t\t\ty|=(j==i||j==(i-1))?t3:F(x,j);\n\t\t\t\t}\n\t\t\t\tif(!mp[y]) {\n\t\t\t\t\tmp[y]=true;\n\t\t\t\t\tque.push(P(y,p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b) {ans=p.second; break;}\n\t\t}\n\t\tprintf(ans==-1?\"NA\\n\":\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<string,int> P;\nchar color[3] = {'r','g','b'};\nstring com[3];\nstring str;\nint len;\nint bfs();\n\nint main(){\n\twhile(1){\n\t\tcin >> str;\n\t\tif(str == \"0\") break;\n\t\tlen = str.size();\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcom[i] = \"\";\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tcom[i] += color[i];\n\t\t\t}\n\t\t}\n\t\tint ans = bfs();\n\t\tif(ans == -1) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n\nint bfs(){\n\tqueue<P> que;\n\tque.push(P(str,0));\n\tmap<string,int> dp;\n\twhile(!(que.empty())){\n\t\tP p = que.front(); que.pop();\n\t\tstring now = p.first;\n\t\tint cou = p.second;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(now == com[i]) return cou;\n\t\t}\n\t\tif(dp[now]) continue;\n\t\tdp[now] = 1;\n\t\tfor(int j=0;j<len-1;j++){\n\t\t\tif(now[j] != now[j+1]){\n\t\t\t\tstring tmp = now;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(tmp[j] != color[k] && tmp[j+1] != color[k]){\n\t\t\t\t\t\ttmp[j] = color[k];\n\t\t\t\t\t\ttmp[j+1] = color[k];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.push(P(tmp,cou+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n\tqueue<P> que;\n\tque.push(P(worm, 0));\n\n\tmap<string, int> d;\n\t\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\t//?????????????????????continue\n\t\tif(d[p.first]) continue;\n\n\t\tstring str = p.first;\n\n\t\t//??¨?????????????????????????????§??????\n\t\tbool flag = false;\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//????????????return\n\t\tif(!flag) return p.second;\n\n\t\t//???????????????????????\\??¨\n\t\td[p.first] = p.second;\n\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\t//??£??????????????§????????°????????¨???\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\n\t\t\t\t//temp?????????????????????????????£??\\\n\t\t\t\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t\t\t\t\ttemp = 'b';\n\t\t\t\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t\t\t\t\ttemp = 'g';\n\t\t\t\t}else{\n\t\t\t\t\ttemp = 'r';\n\t\t\t\t}\n\n\t\t\t\t//?????????????????????next?????°?????????\n\t\t\t\tnext = str;\n\t\t\t\tnext[i] = next[i+1] = temp;\n\n\t\t\t\t//?????\\?????????????????\\\n\t\t\t\tque.push(P(next, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring worm;\n\twhile(cin >> worm && worm != \"0\"){\n\t\tint ret = bfs(worm);\n\t\tif(ret>=0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nbool dfs(string str, int c)\n{\n\tbool f = true;\n\tfor(int i = 1; i < str.size(); i++){\n\t\tif(str[0] != str[i]){\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(f){\n\t\treturn f;\n\t}\n\tif(c == 0){\n\t\treturn f;\n\t}\n\t\n\tchar s, t, u;\n\tfor(int i = 0; i < str.size()-1; i++){\n\t\tif(str[i] != str[i+1]){\n\t\t\ts = str[i];\n\t\t\tt = str[i+1];\n\t\t\tif((s == 'r' && t == 'b') || (s == 'b' && t == 'r')){\n\t\t\t\tu = 'g';\n\t\t\t} else if((s == 'r' && t == 'g') || (s == 'g' && t == 'r')){\n\t\t\t\tu = 'b';\n\t\t\t} else {\n\t\t\t\tu = 'r';\n\t\t\t}\n\t\t\tstr[i] = str[i+1] = u;\n\t\t\tf = dfs(str, c-1);\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr[i] = s;\n\t\t\tstr[i+1] = t;\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint main()\n{\n\tint t;\n\tstring str;\n\t\n\twhile(cin>>str){\n\t\tif(str == \"0\"){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(t = 0; t <= 10; t++){\n\t\t\tif(dfs(str, t)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(t > 10){\n\t\t\tcout << \"NA\" << endl;\n\t\t} else {\n\t\t\tcout << t << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint bfs(string start);\nbool isSameColor(string state);\n\nint main(){\n  string str;\n  while(1){\n    getline(cin,str);\n    if(str==\"0\") break;\n\n    int ans;\n    ans=bfs(str);\n\n    if(ans==-1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\nbool isSameColor(string state){\n  for(int i=1; i<state.size();i++){\n    if(state[i-1]!=state[i]) return false;\n  }\n  return true;\n}\n\nint bfs(string start){\n  queue<string> Q;\n  map<string,int> data;\n  map<string,bool> visited;\n  string u, v;\n\n  Q.push(start);\n  data[start] = 0;\n  visited[start] = true;\n\n  while(!Q.empty()){\n    u=Q.front(), Q.pop();\n    if(isSameColor(u)) return data[u];\n    for(int i=1;i<u.size();i++){\n      if(u[i]!=u[i-1]){\n\tchar firo;\n        if(u[i]=='r'){\n\t  if(u[i-1]=='b') firo='g';\n\t  else if(u[i-1]=='g') firo='b';\n\t}\n\telse if(u[i]=='b'){\n\t  if(u[i-1]=='g') firo='r';\n\t  else if(u[i-1]=='r') firo='g';\n\t}\n\telse if(u[i]=='g'){\n\t  if(u[i-1]=='r') firo='b';\n\t  else if(u[i-1]=='b') firo='r';\n\t}\n\n        v=u;\n        v[i]=v[i-1]=firo;\n        if(!visited[v]){\n\t  visited[v]=true;\n\t  data[v]=data[u]+1;\n\t  Q.push(v);\n\t}\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\n  string s,str,col[3];\n  queue<string> que;\n  map<string,int> mp;\n  int flag;\n  while(1){\n    cin >> s;\n    if(s == \"0\") break;\n    flag = 1;\n    que.push(s);\n    mp[s] = 0;\n    for(int i=0;i<3;i++) col[i] = \"\";\n    for(int i=0;i<s.size();i++){\n      col[0] += \"r\";\n      col[1] += \"b\";\n      col[2] += \"g\";\n    }\n    while(!que.empty()){\n      if(que.front()==col[0]){\n\tcout << mp[col[0]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[1]){\n\tcout << mp[col[1]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[2]){\n\tcout << mp[col[2]] << endl;\n\tflag--;\n\tbreak;\n      }\n      \n      for(int i=0;i<s.size()-1;i++){\n\tstr = que.front();\n\tif(str[i] != str[i+1]){\n\t  if(str[i] != 'r' && str[i+1] != 'r'){\n\t    str[i] = 'r';\n\t    str[i+1] = 'r';\n\t  } else if(str[i] != 'b' && str[i+1] != 'b'){\n\t    str[i] = 'b';\n\t    str[i+1] = 'b';\n\t  }else if(str[i] != 'g' && str[i+1] != 'g'){\n\t    str[i] = 'g';\n\t    str[i+1] = 'g';\n\t  }\n\t  if(mp.count(str) == 0){\n\t    que.push(str);\n\t    mp[str] = mp[que.front()]+1;\n\t  }\n\t}\n      }\n      que.pop();\n    }\n    while(!que.empty()) que.pop();\n    if(flag) cout << \"NA\" << endl;\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<string,int> P;\nint main() {\n\tstring S;\n\twhile(cin>>S) {\n\t\tset<string> ST;\n\t\tqueue<P> Q;\n\t\tQ.push(P(S,0));\n\t\tstring R,G,B;\n\t\tbool OK;\n\t\twhile(!Q.empty()) {\n\t\t\tP p=Q.front();Q.pop();\n\t\t\tOK=true;\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tstring SS=p.first;\n\t\t\t\tif((p.first[i]=='r'&&p.first[i+1]=='g')||(p.first[i]=='g'&&p.first[i+1]=='r')) {\n\t\t\t\t\t\tSS[i]=SS[i+1]='b';\n\t\t\t\t\t\tif(ST.find(SS)==ST.end()){\n\t\t\t\t\t\t\tQ.push(P(SS,p.second+1));\n\t\t\t\t\t\t\tST.insert(SS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOK=false;\n\t\t\t\t}else if((p.first[i]=='r'&&p.first[i+1]=='b')||(p.first[i]=='b'&&p.first[i+1]=='r')) {\n\t\t\t\t\t\tSS[i]=SS[i+1]='g';\n\t\t\t\t\t\tif(ST.find(SS)==ST.end()){\n\t\t\t\t\t\t\tQ.push(P(SS,p.second+1));\n\t\t\t\t\t\t\tST.insert(SS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOK=false;\n\t\t\t\t}else if((p.first[i]=='g'&&p.first[i+1]=='b')||(p.first[i]=='b'&&p.first[i+1]=='g')) {\n\t\t\t\t\t\tSS[i]=SS[i+1]='r';\n\t\t\t\t\t\tif(ST.find(SS)==ST.end()){\n\t\t\t\t\t\t\tQ.push(P(SS,p.second+1));\n\t\t\t\t\t\t\tST.insert(SS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK) {printf(\"%d\\n\",p.second);break;}\n\t\t}\n\t\tif(!OK)printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, n, m) for(int i = (n);i < (m);i++)\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define PII pair<int, int>\n\nusing namespace std;\n\nstring worm;\n\nint all(string a){\n    char b = a[0];\n    int cnt = 0;\n    for(int i = 1;a[i] != '\\0';i++){\n        if(a[i] != b)\n            cnt++;\n    }\n    return cnt;\n}\n\nint solve(){\n    queue< pair<string, int> > que;\n    map<string, int> m;\n    que.push(pair<string, int>(worm, 0));\n    string worm1, tmp;\n    int num;\n\n    if(all(worm) == 0){\n        return 0;\n    }\n\n    while(que.size()){\n        worm1 = que.front().first;\n        num = que.front().second;\n        que.pop();\n\n        if(m[worm1]) continue;\n\n        if(all(worm1) == 1){\n            continue;\n        }else if(all(worm1) == 0){\n            return num;\n        }\n\n        m[worm1] = num;\n\n        if(num >= 10){\n            return -1;\n        }\n        for(int i = 0;i < strlen(worm1.c_str())-1;i++){\n            tmp = worm1;\n            if(worm1[i] != worm1[i+1]){\n                if((worm1[i] == 'b' && worm1[i+1] == 'g') || (worm1[i] == 'g' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'r';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else if((worm1[i] == 'b' && worm1[i+1] == 'r') || (worm1[i] == 'r' && worm1[i+1] == 'b')){\n                    tmp[i] = tmp[i+1] = 'g';\n                    que.push(pair<string, int>(tmp, num+1));\n                }else{\n                    tmp[i] = tmp[i+1] = 'b';\n                    que.push(pair<string, int> (tmp, num+1));\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(void){\n    cin >> worm;\n    while(worm[0] != '0'){\n        int result = solve();\n        if(result >= 0){\n            cout << result << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n        cin >> worm;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nchar change(char a, char b) {\n\tswitch(a) {\n\tcase 'r':\n\t\treturn (b == 'g' ? 'b' : 'g');\n\tcase 'g':\n\t\treturn (b == 'r' ? 'b' : 'r');\n\tcase 'b':\n\t\treturn (b == 'r' ? 'g' : 'r');\n\t}\n}\n\nbool ok(string s) {\n\tREP(i, s.size()-1) {\n\t\tif(s[i] != s[i+1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstruct state {\n\tstring s;\n\tint t;\n\tstate(string s, int t) : s(s), t(t) {};\n};\n\nint main() {\n\tstring s;\n\twhile(cin >> s, s != \"0\") {\n\t\tqueue<state> Q;\n\t\tQ.push(state(s, 0));\n\t\tset<string> S;\n\t\tS.insert(s);\t\t\n\t\tint ans = -1;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tstring cs = st.s;\n\n\t\t\tif(ok(cs)) {\n\t\t\t\tans = st.t;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, cs.size()-1) {\n\t\t\t\tif(cs[i] != cs[i+1]) {\n\t\t\t\t\tstring ns = cs;\n\t\t\t\t\tchar a = cs[i];\n\t\t\t\t\tchar b = cs[i+1];\n\t\t\t\t\tns[i] = change(a, b);\n\t\t\t\t\tns[i+1] = change(a, b);\n\n\t\t\t\t\tif(S.find(ns) == S.end()) {\n\t\t\t\t\t\tS.insert(ns);\n\t\t\t\t\t\tQ.push(state(ns, st.t+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans != -1) {\n\t\t\tcout << ans << endl;\n\t\t} else {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define QUEUE_NUM (10192)\n\nstruct Data{\n\tchar color[15];\n\tint cnt;\n};\n\ntypedef struct {\n\tint top,bottom;\n\tData data[QUEUE_NUM];\n}Queue;\n\n//QÉdataðÇÁ\nvoid push(Queue* Q, Data data){\n\tQ->data[Q->bottom] = data;\n\tQ->bottom = (Q->bottom +1);\n}\n\n//QÌæªvfðæ¾\nData front(Queue* Q)\n{\n\treturn Q->data[Q->top];\n}\n\n//QÌæªvfðí\nvoid pop(Queue* Q)\n{\n\tQ->top = (Q->top + 1) %QUEUE_NUM;\n}\n\nint check(char str[],int n){\n\tint i,number,tem=1,temp;\n\tfor(i=0;i<n;i++){\n\t\tif(str[i]=='r'){\n\t\t\tstr[i]='0';\n\t\t}\n\t\telse if(str[i]=='g'){\n\t\t\tstr[i]='1';\n\t\t}\n\t\telse if(str[i]=='b'){\n\t\t\tstr[i]='2';\n\t\t}\n\t\telse{\n\t\t\tstr[i]='\\0';\n\t\t}\n\t}\n\t\n\tnumber = atoi(str);\n//\tputs(\"\\n--in--\");\n//\tprintf(\"%d  \",number);\n\tnumber=0;\n\twhile(i!=-1){\n\t\ttemp = (str[i]-48);\n\t\tnumber += tem*temp;\n\t\ttem*=3;\n\t\ti--;\n\t}\n//\tprintf(\"%d\\n\",number);\n//\tputs(\"--o--\");\n\treturn number;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tint i,j,n,ans=-1;\n\t\tchar col[4]={'r','g','b'},str[16];\n\t\tint temp;\n\t\tbool visited[178000]={0};\n\t\tQueue Q = {0,0,{0}};\n\t\tData bag;\n\t\t\n\t\tscanf(\"%s\",bag.color);\n\t\tif(bag.color[0]=='0')break;\n\t\tn = strlen(bag.color);\n\t\tbag.cnt=0;\n\t\tpush(&Q,bag);\n\t\t\n\t\twhile(!(Q.bottom==Q.top)){\n\t\t\tint flg=0,flag=0;\n\t\t\tData d = front(&Q); \n\t\t\tpop(&Q);\n\t\t\t\n\t\t\t\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tif(d.color[i]!=d.color[i+1])flg=1;\n\t\t\t}\n\t\t\tif(flg==0){\n\t\t\t\tans=d.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tif(d.color[i] != d.color[i+1]){\n\t\t\t\t\tint used[4]={0};\n\t\t\t\t\tData next;\n\t\t\t\t\tflg=0;\n\t\t\t\t\tstrcpy(next.color ,d.color);\n\t\t\t\t\t\n\t\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\t\tif(col[j]==next.color[i])used[j]=1;\n\t\t\t\t\t\tif(col[j]==next.color[i+1])used[j]=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\t\tif(used[j]==0){\n\t\t\t\t\t\t\tnext.color[i]=col[j];\n\t\t\t\t\t\t\tnext.color[i+1]=col[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/**/\n\t\t\t\t\tstrcpy(str,next.color);\n\t\t\t\t\ttemp=check(str,n);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[temp]==1){\n\t\t\t\t//\t\tprintf(\"d¡\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvisited[temp]=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/**/\n\t//\t\t\t\tprintf(\"now%d == %s\\n\",next.cnt,next.color);\n\t\t\t\t//\tSleep(100);\n\t\t\t\t\tnext.cnt = d.cnt+1;\n\t\t\t\t\tpush(&Q,next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tputs(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n\nusing namespace std;\n\nint main(void){\n  string s;\n  cin>>s;\n  set<string> se;\n  queue<pair<string,int> > q;\n  se.insert(s);\n  q.push(make_pair(s,0));\n  int cnt = 10;\n  char a[3] = {'r','g','b'};\n  string ans[3];\n  rep(i,3){\n    rep(j,s.size()){\n      ans[i] += a[i];\n    }\n    //cout<<ans[i]<<endl;\n  }\n  bool find = true;\n  while(true){\n    if(q.size()==0)break;\n//    cout<<q.front().first<<\" \"<<q.front().second<<endl;\n    pair<string,int> qq = q.front(); q.pop();\n    string ss = qq.first;\n    int n = qq.second;\n    if(ss.size()==s.size()+2 ){\n      break;\n    }\n    cnt ++;\n    bool f = false;\n    rep(i,3){\n      if(ans[i] == ss){\n        f = true;\n        find = false;\n        break;\n      }\n    }\n    if(f)break;\n    n++;\n    rep(i,ss.size()-1){\n      if(ss[i] != ss[i+1]){\n        if((ss[i] == a[0] && ss[i+1] == a[1]) || (ss[i] == a[1] && ss[i+1] == a[0])){\n          string word = ss.substr(0,i) + a[2] + a[2] + ss.substr(i+2,ss.size()-i+2);\n          if(se.find(word) != se.end())continue;\n          se.insert(word);\n          q.push(make_pair(word,n));\n          se.insert(word);\n        }\n        if((ss[i] == a[0] && ss[i+1] == a[2]) || (ss[i] == a[2] && ss[i+1] == a[0])){\n          string word = ss.substr(0,i) + a[1] + a[1] + ss.substr(i+2,ss.size()-i+2);\n          if(se.find(word) != se.end())continue;\n          se.insert(word);\n          q.push(make_pair(word,n));\n          se.insert(word);\n        }\n        if((ss[i] == a[2] && ss[i+1] == a[1]) || (ss[i] == a[1] && ss[i+1] == a[2])){\n          string word = ss.substr(0,i) + a[0] + a[0] + ss.substr(i+2,ss.size()-i+2);\n          if(se.find(word) != se.end())continue;\n          se.insert(word);\n          q.push(make_pair(word,n));\n          se.insert(word);\n        }\n      }\n    }\n  }\n  if(find)cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int,int> Pii;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint bfs(string worm) {\n  queue<Psi> q;\n  q.push(Psi(worm, 0));\n  map<string, int> m;\n\n  while(!q.empty()) {\n    Psi p = q.front(); q.pop();\n    if(m[p.fr]) continue;\n    bool flag = false;\n    string s = p.fr;\n    for(int i=0; i<s.size()-1; i++) {\n      if(s[i] != s[i+1]) {\n\tflag = true; \n\tbreak;\n      }\n    }\n\n    if(!flag) return p.sc;\n    m[p.fr] = p.sc;\n    for(int i=0; i<s.size()-1; i++) {\n      if(s[i] != s[i+1]) {\n\tstring next = s;\n\tchar c;\n\tif(s[i] != 'r' && s[i+1] != 'r') {\n\t  c = 'r';\n\t}\n\telse if(s[i] != 'g' && s[i+1] != 'g') {\n\t  c = 'g';\n\t}\n\telse if(s[i] != 'b' && s[i+1] != 'b') {\n\t  c = 'b';\n\t}\n\tnext[i] = next[i+1] = c;\n\tq.push(Psi(next, p.sc+1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  string s;\n  while(cin>> s && s != \"0\") {\n    int ans = bfs(s);\n    if(ans >= 0) cout<< ans<< endl;\n    else cout<< \"NA\"<< endl;\n  }\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\n#define INF (1 << 21)\n\nusing namespace std;\n\nint N;\n\nint check[100000];\n\nqueue<string> que, que_next;\n\nint index(string str){\n\t\n\tint ref = 0;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tref *= 3;\n\t\tref += str[i] - '0';\n\t}\n\t\n\treturn ref;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tstring str;\n\t\tcin >> str;\n\t\t\n\t\tqueue<string> que_emp;\n\t\t\n\t\tque = que_emp;\n\t\tque_next = que_emp;\n\t\t\n\t\tfor(int i = 0; i < 100000; i++){\n\t\t\tcheck[i] = INF;\n\t\t}\n\t\t\n\t\tif(str[0] == '0'){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tN = str.size();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(str[i] == 'r'){\n\t\t\t\t\tstr[i] = '0';\n\t\t\t\t}else if(str[i] == 'b'){\n\t\t\t\t\tstr[i] = '1';\n\t\t\t\t}else{\n\t\t\t\t\tstr[i] = '2';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tque.push(str);\n\t\t\n\t\tint depth = 0;\n\t\t\n\t\twhile(true){\n\t\t\twhile(!que.empty()){\n\t\t\t\tstring str = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(check[index(str)] != INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcheck[index(str)] = depth;\n\t\t\t\tfor(int i = 0; i < N - 1; i++){\n\t\t\t\t\tif(str[i] != str[i + 1]){\n\t\t\t\t\t\tstring str_copy = str;\n\t\t\t\t\t\tif(str[i] != '0' && str[i + 1] != '0'){\n\t\t\t\t\t\t\tstr_copy[i] = '0';\n\t\t\t\t\t\t\tstr_copy[i + 1] = '0';\n\t\t\t\t\t\t}else if(str[i] != '1' && str[i + 1] != '1'){\n\t\t\t\t\t\t\tstr_copy[i] = '1';\n\t\t\t\t\t\t\tstr_copy[i + 1] = '1';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tstr_copy[i] = '2';\n\t\t\t\t\t\t\tstr_copy[i + 1] = '2';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque_next.push(str_copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque = que_next;\n\t\t\tque_next = que_emp;\n\t\t\tdepth++;\n\t\t\tif(que.empty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout << depth << \" \" << que.size() << endl;;\n\t\t}\n\t\t\n\t\tstring check_0 = \"\";\n\t\tstring check_1 = \"\";\n\t\tstring check_2 = \"\";\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcheck_0 = check_0 + \"0\";\n\t\t\tcheck_1 = check_1 + \"1\";\n\t\t\tcheck_2 = check_2 + \"2\";\n\t\t}\n\t\t\n\t\tint ans = min(min(check[index(check_0)], check[index(check_1)]), check[index(check_2)]);\n\t\t\n\t\tif(ans == INF){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(!s.equals(\"0\")) solve(s);\n\t}\n    }\n\n    static void solve(String s){\n\t//String[] pattern = new String[60000];\n\tHashSet<String> set = new HashSet<String>();\n\tint pcnt = 0;\n\tStack stack = new Stack(s);\n\tString a = s;\n\tset.add(s);\n\t//pattern[pcnt++] = a;\n\tint t = 0;\n\twhile(!stack.isEmpty() && !color(a)){\n\t    //System.out.println(a+\" \"+color(a));\n\t    Worm w = (Worm)stack.pop();\n\t    a = w.getbody();\n\t    t = w.getTime();\n\t    for(int i=0; i<a.length()-1; i++){\n\t\tif(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t    String b = change(a, i, i+1);  \n\t\t    /*\n\t\t    int j=0;\n\t\t    while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t    if(pattern[j]==null){\n\t\t\t//System.out.println(b);\n\t\t\tpattern[j] = b;\n\t\t\tstack.in(b, t+1);\n\t\t\tpcnt++;\n\t\t    }\n\t\t    */\n\t\t    if(set.contains(b)) continue;\n\t\t    else{\n\t\t\tstack.in(b, t+1);\n\t\t\tset.add(b);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif(color(a))\n\t    System.out.println(t);\n\telse\n\t    System.out.println(\"NA\");\n    }\n\n    static boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    static String change(String x, int s, int e){\n\tString ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tans += a+a;\n\t    }\n\t    else{\n\t\tans += x.substring(i, i+1);\n\t    }\n\t}\n\treturn ans;\n    }\n\t\n    static String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\nclass Stack {\n    Object[] stack = new Object[60000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tout = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Object pop(){\n\treturn stack[out++];\n    }\n    /*\n    public String getb(){\n\tWorm a = (Worm)stack[sp-1];\n\treturn a.getbody();\n    }\n    public  int gett(){\n\tWorm a = (Worm)stack[sp-1];\n\tsp--;\n\treturn a.getTime();\n    }\n    */\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n\nclass Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nmap<char, int> m;\nmap<string, int> ans;\nchar c[3] = {'r', 'g', 'b'};\n\nint main() {\n\tREP(i, 3) m[c[i]] = 1<<i;\n\t\n\tstring str;\n\twhile (cin >> str, str != \"0\") {\n\t\tstring ser[3] = {};\n\t\tREP(i, 3) REP(j, str.size()) {\n\t\t\tser[i] += c[i];\n\t\t}\n\t\t\n\t\tqueue<pair<int, string> > que;\n\t\tREP(i, 3) que.push(make_pair(0, ser[i]));\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint t = que.front().first;\n\t\t\tstring now = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (ans.find(now) != ans.end()) continue;\n\t\t\tans[now] = t;\n\t\t\t\n\t\t\tREP(i, now.size() - 1) {\n\t\t\t\tif (now[i] == now[i + 1]) {\n\t\t\t\t\tstring next = now;\n\t\t\t\t\tint nextcor = 7 - m[now[i]];\n\t\t\t\t\tvector<char> pl;\n\t\t\t\t\tREP(j, 3) if (nextcor & (1<<j)) pl.push_back(c[j]);\n\t\t\t\t\tREP(j, 2) {\n\t\t\t\t\t\tnext[i] = pl[j];\n\t\t\t\t\t\tnext[i + 1] = pl[(j + 1) % 2];\n\t\t\t\t\t\tque.push(make_pair(t + 1, next));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans.find(str) == ans.end()) puts(\"NA\");\n\t\telse cout << ans[str] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\n\nint main() {\n\tint ans,i,j,k,f,e,u[60000],v;\n\tstring c,a,b,z1,z2,z3;\n\tstack<string> s[2];\n\twhile(cin >> c) {\n\t\tif (c[0]=='0') break;\n\t\tfor (i=0;i<60000;i++) u[i]=0; v=f=0; ans=-1;\n\t\tz1=z2=z3=\"\"; z1.append(c.size(),'r'); z2.append(c.size(),'g'); z3.append(c.size(),'b');\n\t\ts[f].push(c);\n\t\twhile(!s[f].empty()) {\n\t\t\tans++;\n\t\t\twhile(!s[f].empty()) {\n\t\t\t\tc=s[f].top(); s[f].pop();\n\t\t\t\tif (c==z1 || c==z2 || c==z3) { v=1; break;} \n\t\t\t\tfor (i=0; i<c.size()-1; i++) {\n\t\t\t\t  a=c[i]; b=c[i+1];\n\t\t\t      if (c[i]==c[i+1]) continue;\n\t\t\t      if ((a==\"r\" && b==\"g\") || (a==\"g\" && b==\"r\")) c[i]=c[i+1]='b';\n\t\t\t      if ((a==\"b\" && b==\"r\") || (a==\"r\" && b==\"b\")) c[i]=c[i+1]='g';\t \t\n\t\t\t      if ((a==\"b\" && b==\"g\") || (a==\"g\" && b==\"b\")) c[i]=c[i+1]='r';\n\t\t\t      for (j=0,k=1,e=0;j<c.size();j++,k*=3) if (c[j]=='g') e+=k; else if (c[j]=='b') e+=2*k;\n\t\t\t      if (u[e]==0) { u[e]=1; s[1-f].push(c);}\n\t\t\t      c[i]=a[0]; c[i+1]=b[0];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\tif (v==1) {\n\t\t\t\t\t while(!s[f].empty()) s[f].pop();\n\t\t\t\t\t while(!s[1-f].empty()) s[1-f].pop();\n\t\t\t\t\t break;\n\t\t\t\t } \n\t\t\t\tf=1-f;\n\t\t }\n\t\t if (v==1) cout << ans << endl; else cout << \"NA\" << endl;\n\t }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nint main() {\n  string musi;\n  while(cin >> musi, musi != \"0\") {\n    string tonum;\n    for(int i=0; i<musi.size(); i++) {\n      if(musi[i] == 'r')\n        tonum.push_back('1');\n      if(musi[i] == 'g')\n        tonum.push_back('2');\n      if(musi[i] == 'b')\n        tonum.push_back('3');\n    }\n    queue< pair<string, int> > q;\n    pair<string, int> p;\n    p.first = tonum;\n    p.second = 0;\n    q.push(p);\n    bool flg = true;\n    vector<string> memo;\n    while(q.size()) {\n      p = q.front();\n      q.pop();\n      int cnt = 0;\n      for(int i=1; i<p.first.size(); i++) {\n        if(p.first[i-1] != p.first[i]) {\n          pair<string, int> p2;\n          p2 = p;\n          int n = (int)p.first[i-1] + (int)p.first[i] - '0' - '0';\n          if(n==3) {\n            p2.first[i-1] = '3';\n            p2.first[i] = '3';\n          }\n          else if(n==4) {\n            p2.first[i-1] = '2';\n            p2.first[i] = '2';\n          }\n          else if(n==5) {\n            p2.first[i-1] = '1';\n            p2.first[i] = '1';\n          }\n          if(find(memo.begin(), memo.end(), p2.first) == memo.end()) {\n            p2.second++;\n            q.push(p2);\n            memo.push_back(p2.first);\n          }\n        }\n        else cnt++;\n      }\n      if(cnt == p.first.size()-1) {\n        flg = false;\n        cout << p.second << endl;\n        break;\n      }\n    }\n    if(flg) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint ans;\nstring s;\n\nmap<string, int> msi;\n\nvoid solve(){\n\tmsi[s] = 0;\n\n\tqueue<string> que;\n\n\tque.push(s);\n\n\twhile (que.size()){\n\t\tstring ret = que.front();\n\t\tque.pop();\n\n\t\tbool f = 0;\n\t\tREP(i, ret.size() - 1){\n\t\t\tif (ret[i] != ret[i + 1])break;\n\t\t\tif (i == ret.size() - 2)f = 1;\n\t\t}\n\t\tif (f){\n\t\t\tans = min(ans, msi[ret]);\n\t\t}\n\n\t\tREP(i, ret.size() - 1){\n\t\t\tstring t = ret;\n\t\t\tif (ret[i] != ret[i + 1]){\n\t\t\t\tif (ret[i] == 'r'&&ret[i + 1] == 'g'){\n\t\t\t\t\tt[i] = 'b';\n\t\t\t\t\tt[i + 1] = 'b';\n\t\t\t\t}\n\t\t\t\tif (ret[i] == 'g'&&ret[i + 1] == 'r'){\n\t\t\t\t\tt[i] = 'b';\n\t\t\t\t\tt[i + 1] = 'b';\n\t\t\t\t}\n\t\t\t\tif (ret[i] == 'r'&&ret[i + 1] == 'b'){\n\t\t\t\t\tt[i] = 'g';\n\t\t\t\t\tt[i + 1] = 'g';\n\t\t\t\t}\n\t\t\t\tif (ret[i] == 'b'&&ret[i + 1] == 'r'){\n\t\t\t\t\tt[i] = 'g';\n\t\t\t\t\tt[i + 1] = 'g';\n\t\t\t\t}\n\t\t\t\tif (ret[i] == 'b'&&ret[i + 1] == 'g'){\n\t\t\t\t\tt[i] = 'r';\n\t\t\t\t\tt[i + 1] = 'r';\n\t\t\t\t}\n\t\t\t\tif (ret[i] == 'g'&&ret[i + 1] == 'b'){\n\t\t\t\t\tt[i] = 'r';\n\t\t\t\t\tt[i + 1] = 'r';\n\t\t\t\t}\n\t\t\t\tif (t == ret)continue;\n\t\t\t\tif (msi.find(t) == msi.end()){\n\t\t\t\t\t//cout << t << endl;\n\t\t\t\t\tque.push(t);\n\t\t\t\t}\n\t\t\t\tmsi[t] = msi[ret] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> s&&s != \"0\"){\n\t\tans = INF;\n\t\tmsi.clear();\n\t\tsolve();\n\t\tif (ans == INF)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\n\nstring s;\nchar c[] = {'r','b','g'};\n\nchar rem(char a,char b){\n  for(int i=0;i<3;i++){\n    if(c[i] != a && c[i] != b)return c[i];\n  }\n  return 'x';\n}\n\nint main(){\n  while(cin >> s,s!=\"0\"){\n    map<string,int> m;\n    m[s] = 0;\n    queue<string> q;\n    q.push(s);\n    \n    int res = -1;\n    while(q.size()){\n      s = q.front(); q.pop();\n      bool f = true;\n      for(int i=0;i<s.size()-1;i++){\n\tif(s[i]!=s[i+1]){\n\t  f = false;\n\t  string tmp = s;\n\t  tmp[i] = tmp[i+1] = rem(s[i],s[i+1]);\n\t  if(m.find(tmp)==m.end()){\n\t    m[tmp] = m[s] + 1;\n\t    q.push(tmp);\n\t  }\n\t}\n      }\n      if(f){\n\tres = m[s];\n\tbreak;\n      }\n    }\n    if(res<0)cout << \"NA\\n\";\n    else cout << res << endl;\n  }\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint main()\n{\n\tstring s;\n\twhile (cin >> s)\n\t{\n\t\tif (s == \"0\") break;\n\t\tint l = s.size();\n\t\tmap<string, int> used;\n\t\tused[s] = 0;\n\t\tqueue<string> que;\n\t\tque.push(s);\n\t\twhile (que.size())\n\t\t{\n\t\t\tstring t = que.front();\n\t\t\tque.pop();\n\t\t\tbool f = true;\n\t\t\tREP(i, l)\n\t\t\t{\n\t\t\t\tif (t[i] != t[0]) f = false;\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tcout << used[t] << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tREP(i, l-1)\n\t\t\t{\n\t\t\t\tif (t[i] != t[i + 1])\n\t\t\t\t{\n\t\t\t\t\tchar c = 'r' + 'g' + 'b' - t[i] - t[i + 1];\n\t\t\t\t\tstring tmp = t;\n\t\t\t\t\ttmp[i] = c; tmp[i + 1] = c;\n\t\t\t\t\tif (used.find(tmp) == used.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tused[tmp] = used[t] + 1;\n\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"NA\");\n\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\ntypedef pair<string,int> SI;\n\nbool ok(string s)\n{\n  char c = s[0];\n  for(int i=0;i<s.length();i++)\n    if(c != s[i])\n      return false;\n  return true;\n}\n\nchar getc(char c,char cc)\n{\n  map<char,bool> index;\n  index['r'] = false,index['b'] = false,index['g'] = false;\n  index[c] = true;\n  index[cc] = true;\n  foreach(i,index)\n    if(!(*i).S)\n      return (*i).F;\n\n}\n\nint solve(string s)\n{\n\n  queue<SI> que;\n  que.push(SI(s,0));\n  map<string,bool> used;\n  while(!que.empty())\n    {\n      SI si = que.front(); que.pop();\n\n      if(used[si.F])\n\tcontinue;\n\n      used[si.F] = true;\n \n      if(ok(si.F))\n\t{\n\t  return si.S;\n\t}\n\n      if(si.S > 30)\n\tcontinue;\n\n      rep(i,si.F.length()-1)\n\t{\n\t  if(si.F[i] == si.F[i+1])\n\t    continue;\n\t  string news = si.F;\n\t  news[i] = news[i+1] = getc(si.F[i],si.F[i+1]);\n\t  que.push(SI(news,si.S+1));\n\t}\n\n    }\n\n  return -1;\n}\n\n\nint main(){\n\n  while(true)\n    {\n      string s;\n      cin >> s;\n      if(s[0] == '0')\n\tbreak;\n\n      int ans = solve(s);\n      ans != -1?cout << ans << endl:cout << \"NA\" << endl;\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint clr_int(string str)\n{\n\tint v = 0;\n\tint r = 1;\n\tfor(int i = 0;i < str.size();i++)\n\t{\n\t\tswitch(str[i])\n\t\t{\n\t\t\tcase 'g':\n\t\t\tv += r;\n\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tv += r*2;\n\t\t\tbreak;\n\t\t}\n\t\tr *= 3;\n\t}\n\treturn v;\n}\nstring int_clr(int v,int l)\n{\n\tstring str;\n\tfor(int i = 0;i < l;i++)\n\t{\n\t\tint r = v % 3;\n\t\tswitch(r)\n\t\t{\n\t\t\tcase 0:\n\t\t\tstr += \"r\";\n\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tstr += \"g\";\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tstr += \"b\";\n\t\t\tbreak;\n\t\t}\n\t\tv /= 3;\n\t}\n\treturn str;\n}\n\nvector<vector<int>> makeG(int l)\n{\n\tauto grh = vector<vector<int>>();\n\tint r = 1;\n\tfor(int i = 0;i < l;i++)\n\t{\n\t\tr *= 3;\n\t}\n\tfor(int i = 0;i < r;i++)\n\t{\n\t\tauto str = int_clr(i,l);\n\t\tauto ary = vector<int>();\n\t\tfor(int j = 0;j < (l-1);j++)\n\t\t{\n\t\t\tif(str[j] != str[j+1])\n\t\t\t{\n\t\t\t\tauto scp = string(str);\n\t\t\t\tswitch(str[j])\n\t\t\t\t{\n\t\t\t\t\tcase 'r':\n\t\t\t\t\tscp[j] = scp[j+1] = (str[j+1] == 'g')?'b':'g';\n\t\t\t\t\tary.push_back(clr_int(scp));\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'g':\n\t\t\t\t\tscp[j] = scp[j+1] = (str[j+1] == 'b')?'r':'b';\n\t\t\t\t\tary.push_back(clr_int(scp));\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tscp[j] = scp[j+1] = (str[j+1] == 'r')?'g':'r';\n\t\t\t\t\tary.push_back(clr_int(scp));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgrh.push_back(ary);\n\t}\n\treturn grh;\n}\n\nint main()\n{\n\tstring str;\n\tcin >> str;\n\twhile(str.size() > 1)\n\t{\n\t\tauto graph = makeG(str.size());\n\t\t//cout << \"l:\" << str.size() << \"r:\" << graph.size() << endl;\n\t\tqueue<pair<int,int>> q;\n\t\tq.push(pair<int,int>(clr_int(str),0));\n\t\tauto table = vector<int>(graph.size(),0);\n\t\tint c = 0;\n\t\twhile(q.size() > 0)\n\t\t{\n\t\t\tauto n = q.front();\n\t\t\tif(graph[n.first].size() == 0)\n\t\t\t{\n\t\t\t\tcout << n.second << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == graph.size())\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst int l = graph[n.first].size();\n\t\t\t\tfor(int i = 0;i < l;i++)\n\t\t\t\t{\n\t\t\t\t\tif(table[graph[n.first][i]] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttable[graph[n.first][i]] = 1;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tq.push(pair<int,int>(graph[n.first][i],n.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tif(q.size() == 0)\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\tcin >> str;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nbool judge(string s){\n  for(int i = 1; i < s.length(); ++i) if(s[0] != s[i]) return false;\n  return true;\n}\n\nint main(){\n  char worm[16];\n  while(scanf(\"%s\", worm) && worm[0] != '0'){\n    queue<string> q;\n    q.push(string(worm));\n    set<string>s;\n    s.insert(string(worm));\n    if(judge(q.front())){\n      puts(\"0\");\n      continue;\n    }\n    int res = 1;\n    while(!q.empty()){\n      int q_size = (int)q.size();\n      for(int j = 0; j < q_size; ++j){\n\tstring tmp = q.front(); q.pop();\n\tint len = (int)tmp.length();\n\tfor(int i = 0; i < len-1; ++i){\n\t  string n = tmp;\n\t  if(n[i] != n[i+1]){\n\t    if((n[i] == 'r' && n[i+1] == 'b') || (n[i] == 'b' && n[i+1] == 'r')) n[i] = n[i+1] = 'g';\n\t    else if((n[i]=='r'&&n[i+1]=='g') || (n[i]=='g'&&n[i+1]=='r')) n[i] = n[i+1] = 'b';\n\t    else if((n[i]=='g'&&n[i+1]=='b') || (n[i]=='b'&&n[i+1]=='g')) n[i] = n[i+1] = 'r';\n\t  }\n\t  ///\t  puts(n.c_str());\n\t  if(s.find(n) != s.end()) continue;\n\n\t  if(judge(n)){\n\t    printf(\"%d\\n\", res);\n\t    goto end;\n\t  }\n\t  s.insert(n);\n\t  q.push(n);\n\t}\n      }\n      //      printf(\"%d\\n\", res);\n      //      for(int i = 0; i < f.size(); ++i) puts(f[i].c_str());\n      //      queue<string>t;\n      //      t = q;\n      //      while(!t.empty()){ puts(t.front().c_str()); t.pop();}\n      //      puts(\"\");\n      \n      res++;\n    }\n    puts(\"NA\");\n  end:;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\ntypedef pair<string,int> SI;\n\nbool ok(string s)\n{\n  char c = s[0];\n  for(int i=0;i<s.length();i++)\n    if(c != s[i])\n      return false;\n  return true;\n}\n\nchar getc(char c,char cc)\n{\n  map<char,bool> index;\n  index['r'] = false,index['b'] = false,index['g'] = false;\n  index[c] = true;\n  index[cc] = true;\n  foreach(i,index)\n    if(!(*i).S)\n      return (*i).F;\n\n}\n\nint solve(string s)\n{\n\n  queue<SI> que;\n  que.push(SI(s,0));\n  map<string,bool> used;\n  while(!que.empty())\n    {\n      SI si = que.front(); que.pop();\n\n      if(used[si.F])\n\tcontinue;\n\n      used[si.F] = true;\n \n      if(ok(si.F))\n\t{\n\t  return si.S;\n\t}\n\n      if(si.S > 20)\n\tcontinue;\n\n      rep(i,si.F.length()-1)\n\t{\n\t  if(si.F[i] == si.F[i+1])\n\t    continue;\n\t  string news = si.F;\n\t  news[i] = news[i+1] = getc(si.F[i],si.F[i+1]);\n\t  que.push(SI(news,si.S+1));\n\t}\n\n    }\n\n  return -1;\n}\n\n\nint main(){\n\n  while(true)\n    {\n      string s;\n      cin >> s;\n      if(s[0] == '0')\n\tbreak;\n\n      int ans = solve(s);\n      ans != -1?cout << ans << endl:cout << \"NA\" << endl;\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint ans;\nconst int MAX_COUNT = 1000;\nchar color[3] = {'r', 'g', 'b'};\nset<string> mSet;\n\ntypedef pair<string, int> PSI;\n\nbool solve(string str)\n{\n\tqueue<PSI> que;\n\tque.push(PSI(str, 0));\n\t\n\twhile(!que.empty())\n\t{\n\t\tPSI current = que.front();\n\t\tque.pop();\n\n\t\tbool is_solved = true;\n\t\tfor(int i=0; i<current.first.size()-1; i++)\n\t\t{\n\t\t\tif(current.first[i] != current.first[i+1])\n\t\t\t{\n\t\t\t\tis_solved = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(is_solved)\n\t\t{\n\t\t\tans = current.second;\n\t\t\treturn true;\n\t\t}\n\n\t\tif(mSet.find(current.first) == mSet.end())\n\t\t{\n\t\t\tmSet.insert(current.first);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n \t\tfor(int i=0; i<current.first.size()-1; i++)\n\t\t{\n\t\t\tif(current.first[i] != current.first[i+1])\n\t\t\t{\n\t\t\t\tfor(int k=0; k<3; k++)\n\t\t   \t\t{\n\t   \t\t\t\tif(current.first[i] != color[k] && current.first[i+1] != color[k])\n   \t\t\t\t\t{\n\t\t\t\t   \t\tstring new_str = string(current.first.begin(), current.first.end());\n\t\t\t   \t\t\tnew_str[i] = color[k];\n\t\t  \t\t\t\tnew_str[i+1] = color[k];\n\t\t\t\t\t\tque.push(PSI(new_str, current.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tstring str;\n\twhile( 1 )\n\t{\n\t\tcin >> str;\n\t\tif(str == \"0\") break;\n\n\t\tans = MAX_COUNT;\n\t\tmSet.clear();\n\n\t\tif(!solve(str))\n\t\t{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nbool judge(string s){\n  for(int i = 1; i < s.length(); ++i) if(s[0] != s[i]) return false;\n  return true;\n}\n\nint main(){\n  char worm[16];\n  while(scanf(\"%s\", worm) && worm[0] != '0'){\n    queue<string> q;\n    q.push(string(worm));\n    vector<string>f;\n    f.push_back(string(worm));\n    if(judge(q.front())){\n      puts(\"0\");\n      continue;\n    }\n    int res = 1;\n    while(!q.empty()){\n      int q_size = (int)q.size();\n      for(int j = 0; j < q_size; ++j){\n\tstring tmp = q.front(); q.pop();\n\tint len = (int)tmp.length();\n\tfor(int i = 0; i < len-1; ++i){\n\t  string n = tmp;\n\t  if(n[i] != n[i+1]){\n\t    if(n[i] == 'r' && n[i+1] == 'b' || n[i] == 'b' && n[i+1] == 'r') n[i] = n[i+1] = 'g';\n\t    else if(n[i]=='r'&&n[i+1]=='g' || n[i]=='g'&&n[i+1]=='r') n[i] = n[i+1] = 'b';\n\t    else if(n[i]=='g'&&n[i+1]=='b' || n[i]=='b'&&n[i+1]=='g') n[i] = n[i+1] = 'r';\n\t  }\n\t  ///\t  puts(n.c_str());\n\t  if(find(f.begin(), f.end(), n) != f.end()) continue;\n\n\t  if(judge(n)){\n\t    printf(\"%d\\n\", res);\n\t    goto end;\n\t  }\n\t  f.push_back(n);\n\t  q.push(n);\n\t}\n      }\n      //      printf(\"%d\\n\", res);\n      //      for(int i = 0; i < f.size(); ++i) puts(f[i].c_str());\n      //      queue<string>t;\n      //      t = q;\n      //      while(!t.empty()){ puts(t.front().c_str()); t.pop();}\n      //      puts(\"\");\n      \n      res++;\n    }\n    puts(\"NA\");\n  end:;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 30;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n\n\nint ans;\nstring str;\nset<string> can_str;\n\nint main() {\n\twhile ( cin >> str && str != \"0\" ) {\n\t\tint ans = -1;\n\t\tqueue<pair<string, int> > q;\n\t\tq.push( make_pair( str, 0 ) );\n\t\twhile ( q.size() ) {\n\t\t\tstring s = q.front().first;\n\t\t\tint n = q.front().second;\n\t\t\tq.pop();\n\t\t\tif ( can_str.count( s ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcan_str.insert( s );\n\t\t\tbool can_break = true;\n\t\t\tfor ( int i = 1; i < s.size(); i++ ) {\n\t\t\t\tif ( s[ i ] != s[ i - 1 ] ) {\n\t\t\t\t\tcan_break = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( can_break ) {\n\t\t\t\tans = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor ( int i = 1; i < s.size(); i++ ) {\n\t\t\t\tif ( s[ i ] != s[ i - 1 ] ) {\n\t\t\t\t\tstring s_copy = s;\n\t\t\t\t\tif ( s[ i ] == 'r' ) {\n\t\t\t\t\t\tif ( s[ i - 1 ] == 'g' ) {\n\t\t\t\t\t\t\ts[ i ] = s[ i - 1 ] = 'b';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts[ i ] = s[ i - 1 ] = 'g';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( s[ i ] == 'g' ) {\n\t\t\t\t\t\tif ( s[ i - 1 ] == 'r' ) {\n\t\t\t\t\t\t\ts[ i ] = s[ i - 1 ] = 'b';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts[ i ] = s[ i - 1 ] = 'r';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( s[ i ] == 'b' ) {\n\t\t\t\t\t\tif ( s[ i - 1 ] == 'g' ) {\n\t\t\t\t\t\t\ts[ i ] = s[ i - 1 ] = 'r';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts[ i ] = s[ i - 1 ] = 'g';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq.push( make_pair( s, n + 1 ) );\n\t\t\t\t\ts = s_copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ans < 0 ) {\n\t\t\tprintf( \"NA\\n\" );\n\t\t}\n\t\telse {\n\t\t\tprintf( \"%d\\n\", ans );\n\t\t}\n\t\tcan_str.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n\n\nint main()\n{\n    map<string, string> ct;\n    ct[\"rr\"] = \"rr\";\n    ct[\"rb\"] = \"gg\";\n    ct[\"rg\"] = \"bb\";\n\n    ct[\"gr\"] = \"bb\";\n    ct[\"gg\"] = \"gg\";\n    ct[\"gb\"] = \"rr\";\n\n    ct[\"br\"] = \"gg\";\n    ct[\"bg\"] = \"rr\";\n    ct[\"bb\"] = \"bb\";\n    \n    for(;;) {\n        string in;\n        cin >> in;\n\n        if ( in == \"0\" )\n            break;\n\n        std::map<string, bool> correct;\n        correct[string(in.size(), 'r')] = true;\n        correct[string(in.size(), 'g')] = true;\n        correct[string(in.size(), 'b')] = true;\n\n        int result_times = 0;\n\n        queue<pair<int, string> > q;\n        q.push( make_pair( 0, in ) );\n\n        map<string, bool> memo;\n        bool goal = false;\n\n        // loop\n        while( !q.empty() ) {\n            int const times = q.front().first;\n            string const s = q.front().second;\n            q.pop();\n\n            //cout << gtimes << endl;\n            if ( correct[s] ) {\n                goal = true;\n                result_times = times;\n                break;\n            } \n\n            for( size_t i=0; i<s.size()-1; ++i ){\n                string const pa = s.substr( i, 2 );\n                string const t = s.substr( 0, i ) + ct[pa] + s.substr( i + 2 );\n\n                if ( t == s )\n                    continue;\n                if ( memo[t] )\n                    continue;\n\n                memo[t] = true;\n\n                q.push( make_pair( times + 1, t ) );\n            }\n        }\n\n        // put\n        if ( goal ) {\n            cout << result_times << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<string,int> P;\n\nint main() {\n\tstring str;\n\tchar col[3]={'r','g','b'};\n\n\twhile(cin>>str,str[0]!='0') {\n\t\tqueue<P> que;\n\t\tmap<string,bool> mp;\n\n\t\tmp[str]=true;\n\t\tque.push(P(str,0));\n\t\tint ans=-1;\n\t\twhile(!que.empty()) {\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint len=p.first.length();\n\t\t\tbool f=true;\n\t\t\tfor(int i=0;i<len-1;i++) {\n\t\t\t\tif(p.first[i]!=p.first[i+1]) {\n\t\t\t\t\tf=false;\n\t\t\t\t\tpair<int,int> tmp(p.first[i],p.first[i+1]);\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif(p.first[i]!=col[j]&&p.first[i+1]!=col[j]) {\n\t\t\t\t\t\t\tp.first[i]=p.first[i+1]=col[j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(mp[p.first]==false) {\n\t\t\t\t\t\tmp[p.first]=true;\n\t\t\t\t\t\tque.push(P(p.first,p.second+1));\n\t\t\t\t\t}\n\t\t\t\t\tp.first[i]=tmp.first;\n\t\t\t\t\tp.first[i+1]=tmp.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f) {ans=p.second;break;}\n\t\t}\n\t\tif(ans==-1) {\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}else {\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n\tqueue<P> que;\n\tque.push(P(worm, 0));\n\n\tmap<string, int> d;\n\t\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\tif(d[p.first]) continue;\n\n\t\tstring str = p.first;\n\n\t\tbool flag = false;\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!flag) return p.second;\n\n\t\td[p.first] = p.second;\n\n\t\tfor(int i=0;i<str.size()-1;i++){\n\t\t\tif(str[i] != str[i+1]){\n\t\t\t\tchar temp;\n\t\t\t\tstring next;\n\n\t\t\t\tif(str[i] != 'b' && str[i+1] != 'b'){\n\t\t\t\t\ttemp = 'b';\n\t\t\t\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t\t\t\t\ttemp = 'g';\n\t\t\t\t}else{\n\t\t\t\t\ttemp = 'r';\n\t\t\t\t}\n\n\t\t\t\tnext = str;\n\t\t\t\tnext[i] = next[i+1] = temp;\n\n\t\t\t\tque.push(P(next, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring worm;\n\twhile(cin >> worm && worm != \"0\"){\n\t\tint ret = bfs(worm);\n\t\tif(ret>=0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<queue>\nusing namespace std;\n\nstruct worm{\n\tchar part[11];\n\tint dep;\n\tworm(){\n\t\tdep = 0;\n\t}\n};\n\nint main(){\n\tworm input;\n\twhile (cin >> input.part, input.part[0] != '0'){\n\t\tint len;\n\t\tfor (len = 0; input.part[len] != '\\0'; len++){\n\t\t\tif (input.part[len] == 'r') input.part[len] = 0;\n\t\t\telse if (input.part[len] == 'g') input.part[len] = 1;\n\t\t\telse input.part[len] = 2;\n\t\t}\n\t\tqueue<worm> q;\n\t\tq.push(input);\n\t\tworm q_c;\n\t\tbool memo[1000000] = {};\n\t\twhile (1){\n\t\t\tbool color[3] = {};\n\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\tint cnt_clr = 0;\n\n\t\t\tif (q.empty()){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tq_c = q.front();\n\n\t\t\tfor (int i = 0; i < len; i++){\n\t\t\t\tcolor[q_c.part[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) if (color[i]) cnt_clr++;\n\t\t\tif (cnt_clr == 1){\n\t\t\t\tprintf(\"%d\\n\", q_c.dep);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*for (int i = 0; i < len; i++){\n\t\t\t\tprintf(\"%d\", q_c.part[i]);\n\t\t\t\t}*/\n\t\t\tfor (int i = 0; i < len; i++){\n\t\t\t\tsum1 += q_c.part[i] * pow(3, i + 1);\n\t\t\t\tsum2 += q_c.part[i] * pow(3, len - i);\n\t\t\t\t//printf(\" %d*%d^%d\", q_c.part[i], 3, i + 1);\n\t\t\t}\n\t\t\t//printf(\" =%d\\n\", sum1);\n\t\t\tif (memo[sum1]){\n\t\t\t\tq.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemo[sum1] = true;\n\t\t\tmemo[sum2] = true;\n\n\t\t\tfor (int i = 1; i < len; i++){\n\t\t\t\tif (q_c.part[i - 1] != q_c.part[i]){\n\t\t\t\t\tfor (int j = 0; j < 3; j++) color[j] = false;\n\n\t\t\t\t\tcolor[q_c.part[i - 1]] = true;\n\t\t\t\t\tcolor[q_c.part[i]] = true;\n\n\t\t\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\t\t\tif (!color[j]){\n\t\t\t\t\t\t\tq_c.part[i - 1] = j;\n\t\t\t\t\t\t\tq_c.part[i] = j;\n\t\t\t\t\t\t\tq_c.dep++;\n\t\t\t\t\t\t\tq.push(q_c);\n\t\t\t\t\t\t\tq_c = q.front();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint que[60000][10],flg[1050000];\nint main(void){\n\tint p1,p2,i,j,len,time[60000],copy[10],f,x,ans,iro;\n\tchar ca[11];\n\twhile(1){\n\t\tcin>>ca;\n\t\tif(ca[0]=='0') break;\n\t\tlen=strlen(ca);\n\t\tfor(i=0;i<len;i++){\n\t\t\tif(ca[i]=='r') que[0][i]=0;\n\t\t\tif(ca[i]=='g') que[0][i]=1;\n\t\t\tif(ca[i]=='b') que[0][i]=2;\n\t\t}\n\t\tfor(i=0;i<=1050000;i++) flg[i]=0;\n\t\tp1=0; p2=1; time[0]=0; ans=-1;\n\t\twhile(1){\n\t\t\tif(p1==p2){\n//\t\t\t\tcout<<p1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t  /*cout<<p1<<' ';\n\t\t\tfor(i=0;i<len;i++) cout<<que[p1][i];\n\t\t\tcout<<' '<<time[p1]<<endl;*/\n\t\t\tf=1;\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tif(que[p1][i]!=que[p1][i+1]){\n\t\t\t\t\tf=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==1){\n\t\t\t\tans=time[p1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tfor(j=0;j<len;j++) copy[j]=que[p1][j];\n\t\t\t\tif(copy[i]!=copy[i+1]){\n\t\t\t\t\tiro=copy[i]+copy[i+1];\n\t\t\t\t\tif(iro==3){\n\t\t\t\t\t\tcopy[i]=0; copy[i+1]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==2){\n\t\t\t\t\t\tcopy[i]=1; copy[i+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==1){\n\t\t\t\t\t\tcopy[i]=2; copy[i+1]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=copy[0];\n\t\t\t\tfor(j=1;j<len;j++) x=x*4+copy[j];\n\t\t\t\tif(flg[x]==0){\n\t\t\t\t\tflg[x]=1; time[p2]=time[p1]+1;\n\t\t\t\t\tfor(j=0;j<len;j++) que[p2][j]=copy[j];\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1++;\n\t\t}\n\t\tif(ans==-1) cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\ntypedef long long ll;\n\nint main(void) {\n    while (1) {\n        string s;\n        cin >> s;\n        if (s == \"0\") break;\n        map<string, int> mi;\n        queue<string> q;\n        q.push(s);\n        mi[s] = 0;\n        bool flag = true;\n        while (!q.empty()) {\n            string now = q.front(); q.pop();\n            // 全て同じ文字かどうかのチェック\n            int i;\n            for (i = 0; i < now.size()-1; i++) {\n                if (now[i] != now[i+1]) {\n                    break;\n                }\n            }\n            if (i == now.size()-1) {\n                cout << mi[now] << endl;\n                flag = false;\n                break;\n            }\n            // いろいろ移行するところを考える\n            for (int i = 0; i < now.size()-1; i++) {\n                string s = now;\n                if (s[i] != s[i+1]) {\n                    if (s[i] != 'r' && s[i+1] != 'r') {\n                        s[i] = 'r'; s[i+1] = 'r';\n                    } else if (s[i] != 'g' && s[i+1] != 'g') {\n                        s[i] = 'g'; s[i+1] = 'g';\n                    } else {\n                        s[i] = 'b'; s[i+1] = 'b';\n                    }\n                }\n                if (mi.find(s) == mi.end()) {\n                    q.push(s);\n                    mi.insert(map<string, int>::value_type(s, mi[now]+1));\n                }\n            }\n        }\n        if (flag) cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <string, int> P;\n\n#define mp(a, b) make_pair(a, b)\n\nchar diff(char a, char b)\n{\n\tif (a != 'r' && b != 'r') return 'r';\n\tif (a != 'g' && b != 'g') return 'g';\n\tif (a != 'b' && b != 'b') return 'b';\n\treturn 'a';\n}\n\nbool check(string str)\n{\n\tchar c = str[0];\n\tfor (int i = 0; i < str.length(); i++){\n\t\tif (c != str[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tstring str;\n\n\twhile (cin >> str){\n\t\tif (str == \"0\") return 0;\n\n\t\tint ret = -1, a;\n\t\tqueue < P > q;\n\t\tq.push(mp(str, 0));\n\t\twhile (!q.empty()){\n\t\t\tP now = q.front();\n\t\t\tq.pop();\n\t\t\tif (check(now.first)){\n\t\t\t\tret = now.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (q.size() > 1e6){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < now.first.length()-1; i++){\n\t\t\t\tif (now.first[i] != now.first[i + 1]){\n\t\t\t\t\tstring tmp = now.first;\n\t\t\t\t\ttmp[i] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\ttmp[i + 1] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\tq.push(mp(tmp, now.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret >= 0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nint f(char a,char b){\n\tif( a == 'r' && b == 'g' ) return 'b';\n\tif( a == 'b' && b == 'r' ) return 'g';\n\tif( a == 'b' && b == 'g' ) return 'r';\n\tswap(a,b);\n\tif( a == 'r' && b == 'g' ) return 'b';\n\tif( a == 'b' && b == 'r' ) return 'g';\n\tif( a == 'b' && b == 'g' ) return 'r';\n\treturn 0;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s && s != \"0\" ){\n\t\tmap<string,int> done;\n\t\tqueue< pair<string,int> > Q;\n\t\tQ.push(make_pair(s,0));\n\t\twhile(Q.size()){\n\t\t\tpair<string,int> q = Q.front(); Q.pop();\n\t\t\tif( done[q.first]++) continue;\n\t\t\tif( count(q.first.begin(),q.first.end(),q.first[0]) == q.first.size() ) {\n\t\t\t\tcout << q.second << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < q.first.size() - 1 ; i++){\n\t\t\t\tif( f(q.first[i],q.first[i+1]) ){\n\t\t\t\t\tchar c = f(q.first[i],q.first[i+1]);\n\t\t\t\t\tstring next = q.first;\n\t\t\t\t\tnext[i] = next[i+1] = c;\n\t\t\t\t\tQ.push(make_pair(next,q.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint main() {\n\tstring s;\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tmap<string, int> mp;\n\t\tqueue<P> q;\n\t\tq.push(P(s, 0));\n\t\tint count = -1;\n\t\tint sz = s.size();\n\t\tchar cc = s[0];\n\t\tbool hantei = true;\n\t\tfor (int i = 1; i < sz; i++) {\n\t\t\tif (s[i] != cc) {\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmp[s]++;\n\t\tif (hantei) {\n\t\t\tcout << 0 << endl; \n\t\t} else {\n\t\t\twhile (!q.empty()) {\n\t\t\t\tP aa = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tstring a = aa.first;\n\t\t\t\tfor (int i = 0; i < sz-1; i++) {\n\t\t\t\t\tif (a[i] == a[i+1]) {\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstring b = a;\n\t\t\t\t\t\tif ((a[i] == 'r' && a[i+1] == 'g')||(a[i] == 'g' && a[i+1] == 'r')) {\n\t\t\t\t\t\t\tb[i] = b[i+1] = 'b';\n\t\t\t\t\t\t} else if ((a[i] == 'g' && a[i+1] == 'b')||(a[i] == 'b' && a[i+1] == 'g')) {\n\t\t\t\t\t\t\tb[i] = b[i+1] = 'r';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tb[i] = b[i+1] = 'g';\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << b << endl;\n\t\t\t\t\t\tmp[b]++;\n\t\t\t\t\t\tif (mp[b] > 1) {\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar ccb = b[0];\n\t\t\t\t\t\t\tbool hantei2 = true;\n\t\t\t\t\t\t\tfor (int i = 1; i < sz; i++) {\n\t\t\t\t\t\t\t\tif (b[i] != ccb) {\n\t\t\t\t\t\t\t\t\thantei2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hantei2) {\n\t\t\t\t\t\t\t\tcount = aa.second+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tq.push(P(b, aa.second+1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count != -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count != -1) {\n\t\t\t\tcout << count << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define QUEUE_NUM (20386)\n\nstruct Data{\n\tchar color[15];\n\tint cnt;\n};\n\ntypedef struct {\n\tint top,bottom;\n\tData data[QUEUE_NUM];\n}Queue;\n\n//QÉdataðÇÁ\nvoid push(Queue* Q, Data data){\n\tQ->data[Q->bottom] = data;\n\tQ->bottom = (Q->bottom +1);\n}\n\n//QÌæªvfðæ¾\nData front(Queue* Q)\n{\n\treturn Q->data[Q->top];\n}\n\n//QÌæªvfðí\nvoid pop(Queue* Q)\n{\n\tQ->top = (Q->top + 1) %QUEUE_NUM;\n}\n\nint check(char str[],int n){\n\tint i,number,tem=1,temp;\n\tfor(i=0;i<n;i++){\n\t\tif(str[i]=='r'){\n\t\t\tstr[i]='0';\n\t\t}\n\t\telse if(str[i]=='g'){\n\t\t\tstr[i]='1';\n\t\t}\n\t\telse if(str[i]=='b'){\n\t\t\tstr[i]='2';\n\t\t}\n\t\telse{\n\t\t\tstr[i]='\\0';\n\t\t}\n\t}\n\t\n\tnumber = atoi(str);\n//\tputs(\"\\n--in--\");\n//\tprintf(\"%d  \",number);\n\tnumber=0;\n\twhile(i!=-1){\n\t\ttemp = (str[i]-48);\n\t\tnumber += tem*temp;\n\t\ttem*=3;\n\t\ti--;\n\t}\n//\tprintf(\"%d\\n\",number);\n//\tputs(\"--o--\");\n\treturn number;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tint i,j,n,ans=-1;\n\t\tchar col[4]={'r','g','b'},str[16];\n\t\tint temp;\n\t\tbool visited[178000]={0};\n\t\tQueue Q = {0,0,{0}};\n\t\tData bag;\n\t\t\n\t\tscanf(\"%s\",bag.color);\n\t\tif(bag.color[0]=='0')break;\n\t\tn = strlen(bag.color);\n\t\tbag.cnt=0;\n\t\tpush(&Q,bag);\n\t\t\n\t\twhile(!(Q.bottom==Q.top)){\n\t\t\tint flg=0,flag=0;\n\t\t\tData d = front(&Q); \n\t\t\tpop(&Q);\n\t\t\t\n\t\t\t\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tif(d.color[i]!=d.color[i+1])flg=1;\n\t\t\t}\n\t\t\tif(flg==0){\n\t\t\t\tans=d.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tif(d.color[i] != d.color[i+1]){\n\t\t\t\t\tint used[4]={0};\n\t\t\t\t\tData next;\n\t\t\t\t\tflg=0;\n\t\t\t\t\tstrcpy(next.color ,d.color);\n\t\t\t\t\t\n\t\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\t\tif(col[j]==next.color[i])used[j]=1;\n\t\t\t\t\t\tif(col[j]==next.color[i+1])used[j]=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(j=0;j<3;j++){\n\t\t\t\t\t\tif(used[j]==0){\n\t\t\t\t\t\t\tnext.color[i]=col[j];\n\t\t\t\t\t\t\tnext.color[i+1]=col[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/**/\n\t\t\t\t\tstrcpy(str,next.color);\n\t\t\t\t\ttemp=check(str,n);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[temp]==1){\n\t\t\t\t//\t\tprintf(\"d¡\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvisited[temp]=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/**/\n\t//\t\t\t\tprintf(\"now%d == %s\\n\",next.cnt,next.color);\n\t\t\t\t//\tSleep(100);\n\t\t\t\t\tnext.cnt = d.cnt+1;\n\t\t\t\t\tpush(&Q,next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tputs(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\nint cnt,ccnt = 0;\nint len;\nstring s, ss, tmp;\nint flag = 0;\nint fflag=0;\nchar c;\nint cc=0;\nvector<string> v_list;\npair<string,int> ps;\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tmap<string,int> m;\n\t\tfflag=0;\n\t\t//v_list.push_back(s);\n\t\tlen = s.length();\n\t\tqueue<pair<string,int> > qq;\n\t\tqq.push(make_pair(s,0));\n\t\twhile (!qq.empty()) {\n\t\t\tps = qq.front();\n\t\t\tqq.pop();\n\t\t\tc = ps.first[0];\n\t\t\tccnt=ps.second;\n\t\t\tflag = 0;\n\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tif (c != ps.first[i]) {\n\t\t\t\t\t//cout<<ps.first[i]<<endl;//deb\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tcc=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int i = cc-1; i < len - 1; ++i) {\n\t\t\t\t\ttmp = ps.first;\n\t\t\t\t\tif (ps.first[i] != ps.first[i+1]) {\n\t\t\t\t\t\tif (ps.first[i] != 'r' && ps.first[i+1] != 'r') {\n\t\t\t\t\t\t\ttmp[i] = 'r';\n\t\t\t\t\t\t\ttmp[i + 1] = 'r';\n\t\t\t\t\t\t\tif(m[tmp])continue;\n\t\t\t\t\t\t\tm[tmp]=ps.second;\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'g' && ps.first[i+1] != 'g' ){\n\t\t\t\t\t\t\ttmp[i] = 'g';\n\t\t\t\t\t\t\ttmp[i + 1] = 'g';\n\t\t\t\t\t\t\tif(m[tmp])continue;\n\t\t\t\t\t\t\tm[tmp]=ps.second;\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'b' && ps.first[i+1] != 'b') {\n\t\t\t\t\t\t\ttmp[i] = 'b';\n\t\t\t\t\t\t\ttmp[i + 1] = 'b';\n\t\t\t\t\t\t\tif(m[tmp])continue;\n\t\t\t\t\t\t\tm[tmp]=ps.second;\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcout << ccnt << endl;\n\t\t\t\tfflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!fflag){printf(\"NA\");cout<<endl;};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\nchar get_another_color(char a, char b){\n  if (a > b) swap(a, b);\n  if (a == 'b') return \"gr\"[b == 'g'];\n  if (a == 'g') return 'b';\n  return '#';\n}\n\nint solve(string init)\n{\n  queue<string> Q;\n  set<string> vis;\n  Q.push(init);\n  vis.insert(init);\n  int turn = 0;\n  while (!Q.empty()){\n    queue<string> nQ;\n    while (!Q.empty()){\n      string state = Q.front();\n      Q.pop();\n      bool ok = true;\n      rep(i, state.size() - 1){\n        if (state[i] != state[i + 1]){\n          ok = false;\n          string nstate = state;\n          nstate[i] = nstate[i + 1] = get_another_color(nstate[i], nstate[i + 1]);\n          if (vis.find(nstate) != vis.end()) continue;\n          vis.insert(nstate);\n          nQ.push(nstate);\n        }\n      }\n      if (ok) return turn;\n    }\n    turn++;\n    swap(Q, nQ);\n  }\n  return -1;\n}\n\nint main()\n{\n  string state;\n  while (cin >> state, state != \"0\"){\n    int result = solve(state);\n    if (result < 0) puts(\"NA\");\n    else printf(\"%d\\n\", result);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n#define P pair<string,int>\n#define C(X)((X)=='r'?0:(X)=='b'?1:2)\nint main() {\n\tstring w;\n\twhile(cin>>w,w!=\"0\") {\n\t\tqueue<P> q;\n\t\tset<string> s;\n\t\tq.push(P(w,0));\n\t\ts.insert(w);\n\t\tbool OK=false;\n\t\twhile(!q.empty()) {\n\t\t\tP p=q.front();q.pop();\n\t\t\tbool ok=true;\n\t\t\tfor(int i=1;i<p.first.size();i++) {\n\t\t\t\tif(p.first[i-1]!=p.first[i]) {\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tcout<<p.second<<endl;\n\t\t\t\tOK=true;break;\n\t\t\t}\n\t\t\tfor(int i=1;i<p.first.size();i++) {\n\t\t\t\tif(p.first[i-1]!=p.first[i]) {\n\t\t\t\t\tstring ns=p.first;\n\t\t\t\t\tbool chr[3]={0};\n\t\t\t\t\tchr[C(ns[i-1])]=true;\n\t\t\t\t\tchr[C(ns[i])]=true;\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif(chr[j]==false) {\n\t\t\t\t\t\t\tns[i-1]=ns[i]=(j==0?'r':j==1?'b':'g');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s.find(ns)==s.end()) {\n\t\t\t\t\t\tq.push(P(ns,p.second+1));\n\t\t\t\t\t\ts.insert(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(OK==false)cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n//#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\nstring str;\nstring t;\nstring tmp;\nint count;\n\nint main(){\n\twhile(cin >> str){\n\t\tmap<string,int> mp;\n\t\tmp[str] = 0;\n\t\tif(str == \"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tqueue<string> q;\n\t\tq.push(str);\n\n\t\tchar a[5] = {'r','g','b'};\n\t\tbool q_flag = true;\n\n\t\twhile(!q.empty()){\n\t\t\ttmp = q.front();\n\t\t\tq.pop();\n\t\t\tbool flag = true;\n\n\t\t\tfor(int i=0; i+1<tmp.size(); i++){\n\t\t\t\tif(tmp[i] != tmp[i+1]){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tfor(int j=0; j<3; j++){\n\t\t\t\t\t\tif(a[j] != tmp[i] && a[j] != tmp[i+1]){\n\t\t\t\t\t\t\tt = tmp;\n\t\t\t\t\t\t\tt[i+1] = a[j];\n\t\t\t\t\t\t\tt[i] = a[j];\n\t\t\t\t\t\t\tif(mp.count(t) == 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp[t] = mp[tmp] + 1;\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == true){\n\t\t\t\tcout << mp[tmp] << endl;\n\t\t\t\tq_flag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(q_flag == true){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\nchar p[3][12]={\n    \"rrrrrrrrrr\",\n    \"bbbbbbbbbb\",\n    \"gggggggggg\"\n};\ntypedef struct worm{\n    char b[12];\n    int s;\n}worm;\nusing namespace std;\nint main(){\n    char a[15];\n    while(cin>>a,a[0]!='0'){\n        int len=strlen(a);\n        queue<worm>Q;\n        worm o;\n        strcpy(o.b,a);\n        o.s=0;\n        Q.push(o);\n        bool f=true;\n        while(Q.size()){\n            worm gar=Q.front();\n            Q.pop();\n            bool f2=false;\n            for(int i=0;i<3;i++)if(!strncmp(gar.b,p[i],len))f2=true;\n            if(f2){\n                cout<<gar.s<<endl;\n                f=false;\n                break;\n            }\n            if(gar.s>9)break;\n            for(int i=0;i<len-1;i++){\n                char gar2[12];\n                strcpy(gar2,gar.b);\n\n                if(gar2[i]!=gar2[i+1]){\n                    if(gar2[i]!='g'&&gar2[i+1]!='g')strncpy(gar2+i,p[2],2);\n                    else if(gar2[i]!='r'&&gar2[i+1]!='r')strncpy(gar2+i,p[0],2);\n                    else if(gar2[i]!='b'&&gar2[i+1]!='b')strncpy(gar2+i,p[1],2);\n                }\n                if(strcmp(gar.b,gar2)){\n                    worm gar3;\n                    strcpy(gar3.b,gar2);\n                    gar3.s=gar.s+1;\n                    Q.push(gar3);\n                }\n            }\n\n        }\n        if(f)cout<<\"NA\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint f(char a,char b){\n\tif( a == 'r' && b == 'g' ) return 'b';\n\tif( a == 'b' && b == 'r' ) return 'g';\n\tif( a == 'b' && b == 'g' ) return 'r';\n\tswap(a,b);\n\tif( a == 'r' && b == 'g' ) return 'b';\n\tif( a == 'b' && b == 'r' ) return 'g';\n\tif( a == 'b' && b == 'g' ) return 'r';\n\treturn 0;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s && s != \"0\" ){\n\t\tmap<string,int> done;\n\t\tqueue< pair<string,int> > Q;\n\t\tQ.push(make_pair(s,0));\n\t\twhile(Q.size()){\n\t\t\tpair<string,int> q = Q.front(); Q.pop();\n\t\t\tif( done[q.first]++) continue;\n\t\t\tif( count(q.first.begin(),q.first.end(),q.first[0]) == q.first.size() ) {\n\t\t\t\tcout << q.second << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < q.first.size() - 1 ; i++){\n\t\t\t\tif( f(q.first[i],q.first[i+1]) ){\n\t\t\t\t\tchar c = f(q.first[i],q.first[i+1]);\n\t\t\t\t\tstring next = q.first;\n\t\t\t\t\tnext[i] = next[i+1] = c;\n\t\t\t\t\tQ.push(make_pair(next,q.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<string, int>;\n\nint main() {\n  map<char, int> rbg;\n  rbg['r'] = 0;\n  rbg['b'] = 1;\n  rbg['g'] = 2;\n\n  string s;\n  while (cin >> s && s[0] != '0') {\n    vector<string> goal;\n    for (int i = 0; i < 3; ++i) goal.push_back(string(s.length(), \"rbg\"[i]));\n\n    auto check = [&](string s) {\n      for (int i = 0; i < 3; ++i) {\n        if (goal[i] == s) return true;\n      }\n      return false;\n    };\n\n    map<string, bool> mp; mp[s] = true;\n    queue<P, deque<P>> que; que.push({s, 1});\n\n    int ans = 0;\n    bool ok = check(s);\n    while (!que.empty() && !ok) {\n      tie(s, ans) = que.front(); que.pop();\n      if (!mp[s]) continue;\n\n      for (int i = 0; i < s.length() - 1; ++i) {\n        string tmp(s);\n        if (s[i] == s[i + 1]) continue;\n        int c = 3 - rbg[s[i]] - rbg[s[i + 1]];\n        tmp[i] = tmp[i + 1] = \"rbg\"[c];\n        if (check(tmp)) ok = true;\n        if (!mp[tmp]) que.push({tmp, ans + 1});\n        mp[tmp] = true;\n      }\n    }\n    cout << ( (ok) ? to_string(ans) : \"NA\" ) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <stack>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<string, int>;\nusing edge = struct\n{\n    int to;\n    int cost;\n};\n\nint wfs(string worm)\n{\n    queue<P> que;\n    que.push(P(worm, 0));\n\n    map<string, int> mp;\n\n    while (!que.empty())\n    {\n        P p = que.front();\n        que.pop();\n\n        string tmp = p.first;\n\n        if(mp[p.first]) continue;\n\n        bool flag = true;\n\n        for (int i = 0; i < tmp.size() - 1; i++)\n        {\n            if (tmp[i] != tmp[i + 1])\n            {\n                flag = false;\n                break;\n            }\n        }\n\n        if (flag) return p.second;\n\n        mp[p.first] = p.second;\n\n        for(int i = 0; i < tmp.size() - 1; i++)\n        {\n            if(tmp[i] == tmp[i + 1]) continue;\n\n            string nworm = tmp;\n\n            if(tmp[i] != 'g' && tmp[i + 1] != 'g')\n            {\n                nworm[i] = 'g';\n                nworm[i + 1] = 'g';\n            }\n            else if(tmp[i] != 'b' && tmp[i + 1] != 'b')\n            {\n                nworm[i] = 'b';\n                nworm[i + 1] = 'b';\n            }\n            else\n            {\n                nworm[i] = 'r';\n                nworm[i + 1] = 'r';\n            }\n\n            que.push(P(nworm, p.second + 1));\n\n        }        \n    }\n    return -1;\n}\n\nint main()\n{\n    string input;\n\n    while(cin >> input && input != \"0\")\n    {\n        cout << (wfs(input) != - 1 ? to_string(wfs(input)) : \"NA\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<string>\nusing namespace std;\ntypedef pair<string,int> P;\nint bfs(string);\nint main(){\n    string worm;\n    while(cin>>worm,worm!=\"0\"){\n        int rep=bfs(worm);\n        if(rep>=0)cout<<rep<<endl;\n        else cout<<\"NA\"<<endl;\n    }\n    return 0;\n}\n\nint bfs(string worm){\n    queue<P>Q;\n    map<string,bool>M;\n    Q.push(make_pair(worm,0));\n\n    while(Q.size()){\n        P p=Q.front();\n        Q.pop();\n        if(M[p.first])continue;\n        M[p.first]=true;\n        string str=p.first;\n        bool flag=false;\n        for(int i=0;i<str.size()-1;i++)\n            if(str[i]!=str[i+1])flag=true;\n\n        if(!flag)return p.second;\n\n        for(int i=0;i<str.size()-1;i++){\n            string next=str;\n            char temp;\n            if(next[i]!=next[i+1]){\n                if(next[i]!='g'&&next[i+1]!='g')temp='g';\n                else if(next[i]!='r'&&next[i+1]!='r')temp='r';\n                else temp='b';\n\n                next[i]=next[i+1]=temp;\n                Q.push(make_pair(next,p.second+1));\n            }\n        }\n\n\n        }\n\n        return -1;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\n\nint main() {\n\tint ans,i,j,k,f,g,e,u[60000],v;\n\tstring c,a,b,z1,z2,z3;\n\tstack<string> s[2];\n\twhile(cin >> c) {\n\t\tif (c[0]=='0') break;\n\t\tfor (i=0;i<60000;i++) u[i]=0; v=f=0; ans=-1;\n\t\tz1=z2=z3=\"\"; z1.append(c.size(),'r'); z2.append(c.size(),'g'); z3.append(c.size(),'b');\n\t\ts[f].push(c);\n\t\twhile(!s[f].empty()) {\n\t\t\tans++;\n\t\t\twhile(!s[f].empty()) {\n\t\t\t\tc=s[f].top(); s[f].pop();\n\t\t\t\tif (c==z1 || c==z2 || c==z3) { v=1; break;} \n\t\t\t\tfor (i=0; i<c.size()-1; i++) {\n\t\t\t\t  a=c[i]; b=c[i+1];\n\t\t\t      if (c[i]==c[i+1]) continue;\n\t\t\t      if ((a==\"r\" && b==\"g\") || (a==\"g\" && b==\"r\")) c[i]=c[i+1]='b';\n\t\t\t      if ((a==\"b\" && b==\"r\") || (a==\"r\" && b==\"b\")) c[i]=c[i+1]='g';\t \t\n\t\t\t      if ((a==\"b\" && b==\"g\") || (a==\"g\" && b==\"b\")) c[i]=c[i+1]='r';\n\t\t\t      for (j=0,k=1,e=0;j<c.size();j++,k*=3) if (c[j]=='g') e+=k; else if (c[j]=='b') e+=2*k;\n\t\t\t      if (u[e]==0) { u[e]=1; s[1-f].push(c);}\n\t\t\t      c[i]=a[0]; c[i+1]=b[0];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\tif (v==1) { while(!s[f].empty()) s[f].pop(); break;} \n\t\t\t\tf=1-f;\n\t\t }\n\t\t if (v==1) cout << ans << endl; else cout << \"NA\" << endl;\n\t }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<algorithm>\n\ntypedef pair<string,int> P;\n\nint main()\n{\n  string body;\n  int check = 0;\n\n  while(1){\n    cin >> body;\n    if(body == \"0\")return 0;\n\n    map<string,int> used;\n\n    queue<P> que;\n\n    que.push(P(body,0));\n    while(!que.empty()){\n      P p = que.front();que.pop();\n      string now = p.first;\n      int co = p.second;\n      int c = 1;\n      for(int i = 0;i < body.size();i++){\n        if(now[0] == now[i+1])c++;\n      }\n      if(c == body.size()){\n        cout << co << endl;\n        check = 1;\n        break;\n      }\n      if(used[now] == 1)continue;\n      used[now] = 1;\n\n      for(int i = 0;i < body.size()-1;i++){\n        string next = now;\n        if(next[i] == next[i+1])continue;\n        if((next[i] == 'r' && next[i+1] == 'b') || (next[i] == 'b' && next[i+1] == 'r')){\n          next[i] = 'g';\n          next[i+1] = 'g';\n          que.push(P(next,co+1));\n        }\n        if((next[i] == 'r' && next[i+1] == 'g') || (next[i] == 'g' && next[i+1] == 'r')){\n          next[i] = 'b';\n          next[i+1] = 'b';\n          que.push(P(next,co+1));\n        }\n        if((next[i] == 'g' && next[i+1] == 'b') || (next[i] == 'b' && next[i+1] == 'g')){\n          next[i] = 'r';\n          next[i+1] = 'r';\n          que.push(P(next,co+1));\n        }\n      }\n    }\n    if(check == 0)cout << \"NA\" << endl;\n    check = 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\nint main(){\n  int i,j,k,n;\n  string str,ans,a1,a2,a3;\n  while(1){\n    cin >> str;\n    if(str == \"0\") break;\n    queue <string> Q;\n    map <string,int> d,f;\n\n    a1 = \"r\";\n    a2 = \"b\";\n    a3 = \"g\";\n    for(i=1;i<str.size();i++){\n    a1 += \"r\";\n    a2 += \"b\";\n    a3 += \"g\";\n  }\n\n    d[str] = 0;\n    Q.push(str);\n    ans = \"NA\";\n\n    while(!Q.empty()){\n      string u,v;\n      u = Q.front();\n      Q.pop();\n      f[u] = 1;\n      if(u == a1 || u == a2 || u == a3){\n\tans = u;\n\tbreak;\n      }\n\n      for(i=0;i<u.size()-1;i++){\n\tif(u[i] == 'r' && u[i+1] == 'g' || u[i] == 'g' && u[i+1] == 'r'){\n\t  v = u;\n\t  v[i] = v[i+1] = 'b';\n\t  \n\t  if(!f[v]){\n\t    d[v] = d[u] + 1;\n\t    Q.push(v);\n\t    f[v] = 1;\n\t  }\n\t}\n\n\telse if(u[i] == 'r' && u[i+1] == 'b' || u[i] == 'b' && u[i+1] == 'r'){\n\t  v = u;\n\t  v[i] = v[i+1] = 'g';\n\n\t  if(!f[v]){\n\t    d[v] = d[u] + 1;\n\t    Q.push(v);\n\t    f[v] = 1;\n\t  }\n\t}\n\t\n\telse if(u[i] == 'g' && u[i+1] == 'b' || u[i] == 'b' && u[i+1] == 'g'){\n\t  v = u;\n\t  v[i] = v[i+1] = 'r';\n\t  \n\t  if(!f[v]){\n\t    d[v] = d[u] + 1;\n\t    Q.push(v);\n\t    f[v] = 1;\n\t  }\n\t}\n      }\n    }\n    if(ans != \"NA\") cout << d[ans] << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <climits>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\nstring s;\nint qf;\n\nint foo1(int D[]){\n\tint res=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tres*=10;\n\t\tres+=D[i];\n\t}\n\treturn res;\n}\nvoid foo2(int D[],int m){\n\trep(j,s.size()){\n\t\tD[j]=0;\n\t}\n\tfor(int i=s.size()-1;i>=0;--i){\n\t\tD[i]=m%10;\n\t\tm/=10;\n\t\trep(j,s.size()){\n\t\t}\n\t}\n}\n\n\nint a[30];\nint tmp[30];\nset<long int> vis;\n\nbool check(){\n\tint t=a[0];\n\trep(i,s.size()){\n\t\tif(t!=a[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=0;\n\t\tqueue<int> qu;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='r') a[i]=0;\n\t\t\telse if(s[i]=='g') a[i]=1;\n\t\t\telse if(s[i]=='b') a[i]=2;\n\t\t}\n\t\tif(check()){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqu.push(foo1(a));\n\t\tvis.insert(foo1(a));\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\tint c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\tc++;\n\t\t\tif(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\tfoo2(a,qf);\n\t\t\t\tif(check()){\n\t\t\t\t\tcout<<ans-1<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(a[j]!=a[j+1]){\n\t\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\t\ttmp[k]=a[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[j]*a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=0;\n\t\t\t\t\t\t\ttmp[j+1]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(a[j]==2||a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=1;\n\t\t\t\t\t\t\ttmp[j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttmp[j]=2;\n\t\t\t\t\t\t\ttmp[j+1]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(vis.find(foo1(tmp))==vis.end()){\n\t\t\t\t\t\t\tqu.push(foo1(tmp));\n\t\t\t\t\t\t\tvis.insert(foo1(tmp));\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    string s;\n    while(cin >> s, s != \"0\"){\n        map<string, int> m;\n        queue<string> Q;\n        Q.emplace(s);\n        m[s] = 0;\n        int p = 0;\n        while(!Q.empty()){\n            string x = Q.front(); Q.pop();\n            int ok = 1;\n            for (int i = 0; i+1 < x.size(); ++i) {\n                if(x[i] != x[i+1]) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if(ok) {\n                p = 1;\n                cout << m[x] << \"\\n\";\n                break;\n            }\n            for (int i = 0; i+1 < x.size(); ++i) {\n                if(x[i] == x[i+1]) continue;;\n                string y = x;\n                auto w = 'r'^'g'^'b'^x[i]^x[i+1];\n                y[i] = y[i+1] = w;\n                if(!m.count(y)){\n                    m[y] = m[x]+1;\n                    Q.emplace(y);\n                }\n            }\n        }\n        if(!p){\n            puts(\"NA\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <map>\n#define INF 100000000\nusing namespace std;\ntypedef pair<string,int>P;\n\nint bfs(string worm){\n  queue<P>que;\n  map<string,int>d;\n  que.push(P(worm,0));\n  while(!que.empty()){\n    P p = que.front(); \n    string str = p.first;\n    que.pop();\n    if(d[p.first])continue;\n\n    bool flag = false;\n    for(int i = 0 ; i < str.size()-1 ; i++ ) {\n      if(str[i] != str[i+1]){\n\tflag = true;\n\tbreak;\n      }\n    }\n    if(!flag)return p.second;\n    d[p.first] = p.second;\n    for(int i = 0 ; i < str.size()-1 ; i++ ){\n      if(str[i]!=str[i+1]){\n\tchar tmp;\n\tif(str[i] != 'r' && str[i+1] != 'r' ){\n\t  tmp = 'r';\n\t}else if(str[i] != 'g' && str[i+1] != 'g'){\n\t  tmp = 'g';\n\t}else {\n\t  tmp = 'b';\n\t}\n\tstring next = str;\n\tnext[i] = next[i+1] = tmp; \n\tque.push(P(next,p.second+1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string worm;\n  while(cin >> worm){\n    if(worm[0] == '0')break;\n    int res = bfs(worm);\n    if(res>=0)cout << res << endl;\n    else cout << \"NA\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(i=0;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n    }\n     while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t\tj=g(a);//printf(\"%d\\n\",j);\n\t\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      if(mi==0||mi==n||mi==n*2)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      if(r==1)break;\n      h[i/2]=k;\n    }\n    if(r-1||k==-1)printf(\"%d\\n\",c[mi]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint qqq(int r, int g, int b)\n{\n\tif (r == string::npos)\n\t{\n\t\tif (g == string::npos)return 1;\n\t\tif (b == string::npos)return 1;\n\t}\n\tif (g== string::npos)\n\t{\n\t\tif (b == string::npos)return 1;\n\t}\n\treturn 0;\n\n}\nstring ch(char a, char b){\n\tif (a == b)return \"0\";\n\tif (a == 'r')\n\t{\n\t\tif (b == 'g')return \"bb\";\n\t\telse return \"gg\";\n\t}\n\tif (a == 'g')\n\t{\n\t\tif (b == 'r')return \"bb\";\n\t\telse return \"rr\";\n\t}\n\tif (a == 'b')\n\t{\n\t\tif (b == 'r')return \"gg\";\n\t\telse return \"rr\";\n\t}\n\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tstring musi;\n\t\tqueue<string> now;\n\t\tmap<string, int> cou;\n\n\t\tcin >> musi;\t\tif (musi == \"0\")break;\n\n\t\tcou[musi] = 0;\n\t\tnow.push(musi);\n\n\t\twhile (1)\n\t\t{\n\t\t\tstring ss = now.front();\n\t\t\tint r, g, b;\n\t\t\tr = ss.find(\"r\", 0);\n\t\t\tg = ss.find(\"g\", 0);\n\t\t\tb = ss.find(\"b\", 0);\n\t\t\tif (qqq(r, g, b)){\n\t\t\t\tcout << cou[ss] << endl;\n\t\t\t\tcou.clear();\n\t\t\t\twhile (!now.empty())now.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint siz = ss.size();\n\n\t\t\tfor (int i = 0; i < siz - 1; i++)\n\t\t\t{\n\t\t\t\tif (ch(ss.at(i), ss.at(i + 1)) == \"0\")continue;\n\t\t\t\tstring hoge=ss;\n\t\t\t\thoge.replace(i, 2, ch(ss.at(i), ss.at(i + 1)));\n\t\t\t\tif (!cou.count(hoge)){\n\t\t\t\t\tcou[hoge] = cou[ss] + 1;\n\t\t\t\t\tnow.push(hoge);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow.pop();\n\t\t\tif (now.empty()){ cout << \"NA\" << endl; break; }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<string,bool> P;\n\nint main()\n{\n\n  string worm;\n\n  while(cin >> worm && worm != \"0\")\n    {\n\n      map<string,bool> state_record;\n      queue<string> worm_state;\n      bool NAflag = false;\n      bool flag = false;\n      int rank = 0;\n\n      worm_state.push(worm);\n\n      while(!flag && !NAflag)\n        {\n\n          string temp;\n          int state_num = worm_state.size();\n          int count = 0;\n\n          NAflag = true;\n\n          for(int j = 0; j < state_num && !flag;j++)\n            {\n\n              if(state_record[worm_state.front()] == true)\n                {\n                  worm_state.pop();\n                  continue;\n                }\n              for(int i = 0; i < worm.length() - 1 && !flag; i++)\n                {\n\n                  temp = worm_state.front();\n\n                  if(!temp.compare(i, 2, \"rg\") || !temp.compare( i, 2, \"gr\"))\n                    {\n                      temp.replace(i,2,\"bb\");\n                      worm_state.push(temp);\n                    }\n                  else if(!temp.compare(i, 2, \"rb\") || !temp.compare(i, 2, \"br\"))\n                    {\n                      temp.replace(i,2,\"gg\");\n                      worm_state.push(temp);\n                    }\n                  else if(!temp.compare(i, 2, \"gb\") || !temp.compare(i, 2, \"bg\"))\n                    {\n                      temp.replace(i,2,\"rr\");\n                      worm_state.push(temp);\n                    }\n\n                  count = 0;\n\n                  for(int t = 0; t < worm.length(); t++) if(temp[0]==temp[t]) count++;\n\n                  if(count == worm.length()) flag = true;\n\n                }\n\n              state_record[worm_state.front()] = true;\n\n              worm_state.pop();\n\n              NAflag = false;\n\n            }\n\n          if(!worm_state.empty()) rank++;\n\n          if(flag) cout << rank << endl;\n\n          if(NAflag) cout << \"NA\" << endl;\n\n        }\n\n      state_record.clear();\n\n    }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<string, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        string s; cin>>s;\n        if(s == \"0\") return 0;\n\n        queue<P> que;\n        que.push(P(s, 0));\n        map<string, bool> visited;\n        visited[s] = true;\n        bool valid = false;\n        while(que.size()){\n            string t;\n            int cnt;\n            tie(t, cnt) = que.front();\n            que.pop();\n\n            bool allR = true, allB = true, allG = true;\n            for(int i=0; i<t.size(); i++){\n                if(t[i] == 'r'){\n                    allB = false;\n                    allG = false;\n                }\n                if(t[i] == 'b'){\n                    allR = false;\n                    allG = false;\n                }\n                if(t[i] == 'g'){\n                    allR = false;\n                    allB = false;\n                }\n            }\n\n            if(allR || allB || allG){\n                valid = true;\n                cout << cnt << endl;\n                break;\n            }\n\n            for(int i=0; i<t.size()-1; i++){\n                bool R = true, B = true, G = true;\n\n                if(t[i] != t[i+1]){\n                    if(t[i] == 'r' || t[i+1] == 'r') R = false;\n                    if(t[i] == 'b' || t[i+1] == 'b') B = false;\n                    if(t[i] == 'g' || t[i+1] == 'g') G = false;\n\n                    if(R){\n                        string r = t;\n                        r[i] = 'r';\n                        r[i+1] = 'r';\n\n                        if(!visited[r]){\n                            que.push(P(r, cnt+1));\n                            visited[r] = true;\n                        }\n                    }\n                    if(B){\n                        string b = t;\n                        b[i] = 'b';\n                        b[i+1] = 'b';\n\n                        if(!visited[b]){\n                            que.push(P(b, cnt+1));\n                            visited[b] = true;\n                        }\n                    }\n                    if(G){\n                        string g = t;\n                        g[i] = 'g';\n                        g[i+1] = 'g';\n\n                        if(!visited[g]){\n                            que.push(P(g, cnt+1));\n                            visited[g] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!valid){\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint len;\nstring str;\n\nbool check(string s){\n  char ch = s[0];\n\n  for(int i = 1 ; i < len ; i++){\n    if(ch != s[i]) return false;\n  }\n  return true;\n}\n\nint bfs(){\n  string ans;\n  queue<string> Q;\n  Q.push(str);\n\n  bool found = false;\n  set<string> used;\n  used.insert(str);\n  map<string,int> dist;\n  dist[str] = 0;\n\n  while(!Q.empty()){\n    string s = Q.front(); Q.pop();\n    \n    if(check(s)){\n      found = true;\n      ans = s;\n      break;\n    }\n\n    for(int i = 1 ; i < len ; i++){\n      string next = s;\n      if(s[i-1] == 'b' && s[i] == 'r' ||\n\t s[i-1] == 'r' && s[i] == 'b'){\n\tnext[i-1] = next[i] = 'g';\n      }else if(s[i-1] == 'b' && s[i] == 'g' ||\n\t       s[i-1] == 'g' && s[i] == 'b'){\n\tnext[i-1] = next[i] = 'r';\n      }else if(s[i-1] == 'r' && s[i] == 'g' ||\n\t       s[i-1] == 'g' && s[i] == 'r'){\n\tnext[i-1] = next[i] = 'b';\n      }\n      \n      if(!used.count(next)){\n\tdist[next] = dist[s] + 1;\n\tused.insert(next);\n\tQ.push(next);\n      }\n    }\n  }\n\n  if(!found) return -1;\n  return dist[ans];\n}\n\nint main(){\n  while(cin >> str,str != \"0\"){\n    len = (int)str.size();\n    int res = bfs();\n    if(res == -1){\n      cout << \"NA\" << endl;\n    }else{\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nstring S;\nmap<string, bool> seen;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> S) {\n    if (S == \"0\") break;\n    int N = S.length();\n    rep(i, N) {\n      if (S[i] == 'r') S[i] = 1;\n      else if (S[i] == 'g') S[i] = 2;\n      else S[i] = 3;\n    }\n    queue< pair<string, int> > q;\n    seen.clear();\n    seen[S] = true;\n    q.push(make_pair(S, 0));\n\n    while (q.size()) {\n      string s = q.front()._1;\n      int r = q.front()._2;\n      q.pop();\n\n      bool ok = true;\n      rep(i, N) if (s[i] != s[0]) ok = false;\n      if (ok) {\n        cout << r << \"\\n\";\n        break;\n      }\n      if (r > 20) {\n        cout << \"NA\\n\";\n        break;\n      }\n      rep(i, N-1) {\n        if (s[i] == s[i+1]) continue;\n        string t(s);\n        t[i] = t[i+1] = s[i]^s[i+1];\n        if (seen[t]) continue;\n        seen[t] = true;\n        q.push(make_pair(t, r+1));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string,int> bug;\n\nbool check(string str ) {\n  for ( int i = 1; i < str.size(); i++ ) {\n    if ( str[0] != str[i] ) return 0;\n  }\n  return 1;\n}\n\nchar change( char a, char b ) {\n  if ( a > b ) swap(a,b);\n  if ( a == 'b' && b == 'g' ) return 'r';\n  else if ( a == 'b' && b == 'r' ) return 'g';\n  else return 'b';\n}\n\nvoid bfs(string str ) {\n  int ans = -1;\n  queue<bug> Q;\n  map<string,int> close;\n\n  Q.push( make_pair(str, 0) );\n  close.insert( make_pair(str, 1) );\n\n  while( !Q.empty() ) {\n    bug b = Q.front(); Q.pop();\n    string tmp1 = b.first;\n    if ( check(tmp1) ) {\n      ans = b.second;\n      break;\n    }\n\n    for ( int i = 0; i < tmp1.size()-1; i++ ) {\n      if ( tmp1[i] != tmp1[i+1] ) {\n\tstring tmp2 = tmp1;\n\tchar nc = change(tmp2[i],tmp2[i+1]);\n\ttmp2[i] = nc;\n\ttmp2[i+1] = nc;\n\tif ( close[tmp2] ) continue;\n\tQ.push( make_pair(tmp2,b.second+1) );\n\tclose[tmp2] = 1;\n\t\n      }\n    }\n\n  }\n\n  if ( ans == -1 ) cout << \"NA\" << endl;\n  else cout << ans << endl;\n\n}\n\n\nint main() {\n  string str;\n  while ( cin >> str , str != \"0\") {\n    bfs(str);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct St{\n  string worm;\n  int cnt;\n};\n\nbool check(string str)\n{\n  bool f = true;  \n\n  for(int i = 1; i < str.size(); i++){\n    if(str[i] != str[0]){\n      f = false;\n      break;\n    }\n  }\n\n  return f;\n}\n\nint bfs(string str)\n{\n  int r = 101;\n  vector<St> vec;\n  St stt, stt2;\n  stt.worm = str;\n  stt.cnt = 0;\n\n  vec.push_back(stt);\n  while(!vec.empty()){\n    stt = vec[0];\n    vec.erase(vec.begin());\n\n    if(check(stt.worm) || stt.cnt > 10){\n      r = stt.cnt;\n      break;\n    }\n\n    for(int i = 0; i < (stt.worm).size()-1; i++){\n      string s = stt.worm;\n      if(s[i] != s[i+1]){\n\tif((s[i] == 'r' && s[i+1] == 'g')||(s[i] == 'g' && s[i+1] == 'r')){\n\t  s[i] = s[i+1] = 'b';\n\t} else if((s[i] == 'r' && s[i+1] == 'b')||(s[i] == 'b' && s[i+1] == 'r')){\n\t  s[i] = s[i+1] = 'g';\n\t} else {\n\t  s[i] = s[i+1] = 'r';\n\t}\n\n\tbool f = true;\n\tfor(int j = 0; j < vec.size(); j++){\n\n\t  if(vec[j].worm == s){\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\n\tif(f){\n\t  stt2.worm = s;\n\t  stt2.cnt = stt.cnt + 1;\n\t  vec.push_back(stt2);\n\t}\n      }\n    }\n\n  }\n\n  return r;\n}\n\nint main()\n{\n  int t;\n  string str;\n\n  while(cin>>str && str != \"0\"){\n\n    t = bfs(str);\n    if(t > 10){\n      cout << \"NA\" << endl;\n    } else {\n      cout << t << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef long long int ll;\n\nll tr(string a);\nbool cl(string a);\nint c3(ll a);\nint solve(string st);\n\nint main()\n{\n    string input;\n    cin >> input;\n    while (input[0] != '0') {\n        int ans = solve(input);\n        if (ans != INF) {\n            cout << ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n        cin >> input;\n    }\n    return 0;\n}\n\nint solve(string st)\n{\n    int ans = 0;\n    bool check[177150];\n    queue<string> a, b, c;\n    if ( cl(st) ) {\n        return ans;\n    }\n    a.push(st);\n    while (!a.empty()) {\n        while (!a.empty()) {\n            st = a.front();\n            a.pop();\n            if (check[c3(tr(st))]) {\n                continue;\n            } else {\n                check[c3(tr(st))] = true;\n            }\n            if (cl(st)) {\n                return ans;\n            }\n            for (int i = 1; i < st.size(); i++) {\n                if (st[i-1] != st[i]) {\n                    string nw(st);\n                    if (st[i-1] != 'r' && st[i] != 'r') {\n                        nw[i-1] = 'r';\n                        nw[i] = 'r';\n                    } else if (st[i-1] != 'g' && st[i] != 'g') {\n                        nw[i-1] = 'g';\n                        nw[i] = 'g';\n                    } else if (st[i-1] != 'b' && st[i] != 'b') {\n                        nw[i-1] = 'b';\n                        nw[i] = 'b';\n                    }\n                    b.push(nw);\n                }\n            }\n        }\n        a = b;\n        b = c;\n        ans++;\n    }\n    return INF;\n}\n\nll tr(string a)\n{\n    ll ret = 0;\n    for (int i = 0; i < a.size(); i++) {\n        ret *= 10;\n        if (a[i] == 'r') {\n            ret += 1;\n        } else if (a[i] == 'g') {\n            ret += 2;\n        } else {\n            ret += 3;\n        }\n    }\n    return ret;\n}\n\nbool cl(string a)\n{\n    for (int i = 1; i < a.size(); i++) {\n        if (a[i-1] != a[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint c3(ll a)\n{\n    int ret = 0;\n    if (a) {\n        ret = c3(a / 10);\n        ret *= 3;\n        ret += a % 10;\n    }\n    return ret;\n}\n\n\n        \n\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define pb push_back\n#define mp make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)x;++i)\n#define rep1(i,x) for(int i=1;i<=(int)x;++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(int)x;i>=1;--i)\n#define repf(i,a,x) for(int i=a;i<(int)x;++i)\n#define repf1(i,a,x) for(int i=a;i<=(int)x;++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 1e18;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    while (cin >> s, s[0] != '0') {\n        map<string, bool> m;\n\n        queue<string> q, r;\n\n        q.push(s);\n\n        int cnt = 0;\n\n        while (q.size()) {\n            while (q.size()) {\n                string t = q.front(); q.pop();\n                if (m[t]) continue;\n                m[t] = true;\n                bool f = true;\n                rep(i, t.size() - 1) {\n                    if ((t[i] == 'r' && t[i + 1] == 'b') || (t[i] == 'b' && t[i + 1] == 'r')) {\n                        char c = t[i], d = t[i + 1];\n                        t[i] = t[i + 1] = 'g';\n                        r.push(t);\n                        t[i] = c, t[i + 1] = d;\n                        f = false;\n                    } else if ((t[i] == 'b' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'b')) {\n                        char c = t[i], d = t[i + 1];\n                        t[i] = t[i + 1] = 'r';\n                        r.push(t);\n                        t[i] = c, t[i + 1] = d;\n                        f = false;\n                    } else if ((t[i] == 'r' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'r')) {\n                        char c = t[i], d = t[i + 1];\n                        t[i] = t[i + 1] = 'b';\n                        r.push(t);\n                        t[i] = c, t[i + 1] = d;\n                        f = false;\n                    }\n                }\n                if (f) {\n                    cout << cnt << endl;\n                    goto nxt;\n                }\n            }\n            while (r.size()) {\n                string t = r.front(); r.pop();\n                q.push(t);\n            }\n            cnt++;\n        }\n\n        cout << \"NA\\n\";\nnxt:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\nint BFS(string);\nint ok(string);\nchar change(char, char);\n\n\nint main(){\n\n  string s;\n  while(1){\n    cin >> s;\n    if(s == \"0\") break;\n    int res = BFS(s);\n    if(res == -1) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n}\n\n\nint BFS(string s){\n  queue<string> Q;\n  map<string, int> dist;\n  Q.push(s);\n  dist[s] = 1;\n  while(!Q.empty()){\n    string now = Q.front();\n    Q.pop();\n    if(ok(now) == 1) return dist[now]-1;\n    for(int i = 0; i < now.length()-1; i++){\n      char res = change(now[i], now[i+1]);\n      if(res == '*') continue;\n\n      string tmp = now;\n      tmp[i] = tmp[i+1] = res;\n      if(dist[tmp] == 0){\n\tdist[tmp] = dist[now] + 1;\n\tQ.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\nint ok(string s){\n  for(int i = 1; i < s.length(); i++){\n    if(s[0] != s[i]) return 0;\n  }\n  return 1;\n}\n\nchar change(char c1, char c2){\n  string s = \"rgb\";\n  if(c1 == c2) return '*';\n    for(int i = 0; i < 3; i++){\n      if(c1 != s[i] && c2 != s[i]) return s[i];\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\nmap<char, map<char, char> > convert;\n\nvoid solve(const string& s) {\n\tmap<string, int> visited;\n\tqueue<string> que;\n\tvisited[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tstring current = que.front();\n\t\tque.pop();\n\t\tif (current == string(current.size(), current[0])) {\n\t\t\tcout << visited[current] << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor (unsigned i = 0; i < current.size() - 1; i++) {\n\t\t\tif (current[i] != current[i + 1]) {\n\t\t\t\tchar c = convert[current[i]][current[i + 1]];\n\t\t\t\tstring next = current;\n\t\t\t\tnext[i] = next[i + 1] = c;\n\t\t\t\tif (visited.find(next) != visited.end()) continue;\n\t\t\t\tvisited[next] = visited[current] + 1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tconvert['r']['g'] = 'b';\n\tconvert['g']['r'] = 'b';\n\tconvert['r']['b'] = 'g';\n\tconvert['b']['r'] = 'g';\n\tconvert['b']['g'] = 'r';\n\tconvert['g']['b'] = 'r';\n\tstring str;\n\twhile (cin >> str, str != \"0\") {\n\t\tsolve(str);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(char w[11];cin>>w,w[0]!='0';){\n    queue<pair<vector<int>,int> >que;\n    vector<int> in;\n    for(int i=0;w[i];i++){\n      int n=(w[i]=='r')?1:(w[i]=='g')?2:4;\n      in.push_back(n);\n    }\n    que.push(make_pair(in,0));\n    set<vector<int> > s;\n    while(!que.empty()){\n      vector<int> v=que.front().first;\n      if(s.find(v)!=s.end()){\n\tque.pop();\n      }else{\n\ts.insert(v);\n\tint c=0;\n\tfor(int i=0;i<v.size();i++){\n\t  c|=v[i];\n\t}\n\tif((c&(c-1))==0)break;\n\tfor(int i=0;i<v.size()-1;i++){\n\t  if(v[i]!=v[i+1]){\n\t    vector<int> n=v;\n\t    int nc=7^v[i]^v[i+1];\n\t    n[i]=n[i+1]=nc;\n\t    que.push(make_pair(n,que.front().second+1));\n\t  }\n\t}\n\tque.pop();\n      }\n    }\n    if(que.empty()){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().second<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(). (a).end()\n\nusing namespace std;\n\nint other(int x, int y){\n\tif(x > y)return other(y,x);\n\tif(x == 0 && y == 1)return 2;\n\tif(x == 0 && y == 2)return 1;\n\tif(x == 1 && y == 2)return 0;\n}\n\nint main(){\n\twhile(true){\n\t\tstring str; cin >> str;\n\t\tif(str == \"0\")break;\n\t\tvector<int> b(str.size());\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tswitch(str[i]){\n\t\t\t\tcase 'r':\n\t\t\t\t\tb[i] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\tb[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tb[i] = 2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tqueue<vector<int> > q;\n\t\tmap<vector<int> , int> m;\n\t\tq.push(b);\n\t\tm[b] = 0;\n\t\twhile(!q.empty()){\n\t\t\tauto t = q.front();\n\t\t\tq.pop();\n\t\t\tint c = t[0];\n\t\t\tbool flag = true;\n\t\t\tfor(auto e : t){\n\t\t\t\tif(e != c){\n\t\t\t\t\tflag =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tans = m[t];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < t.size(); i++){\n\t\t\t\tauto tt = t;\n\t\t\t\tif(t[i] != t[i-1]){\n\t\t\t\t\ttt[i] = tt[i-1] = other(t[i], t[i-1]);\n\t\t\t\t}\n\t\t\t\tif(m.find(tt) == m.end()){\n\t\t\t\t\tq.push(tt);\n\t\t\t\t\tm[tt] = m[t]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <cstdio>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\n\n\nint ans;\nset<string> memo;\nqueue<string> q;\nbool na;\n\nvoid bfs(){\n\t//cout<<ans<<endl;\n\tqueue<string> nq;\n\t\n\twhile(!q.empty()){\n\t\tstring ss=q.front();q.pop();\n\t\tif(memo.count(ss)){\n\t\t\t//cout<<ss<<\" finded\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t//cout<<ss<<endl;\n\t\tmemo.insert(ss);\n\t\tbool end=true;\n\t\tfor(int i=0;i<ss.size()-1;i++)if(ss[i]!=ss[i+1])end=false;\n\t\tif(end){\n\t\t\t//cout<<ss<<\" \"<<ans<<endl;\n\t\t\treturn ;\n\t\t}\n\n\t\tfor(int i=0;i<ss.size()-1;i++){\n\t\t\tif(ss[i]!=ss[i+1]){\n\t\t\t\tstring sss(ss);\n\t\t\t\tif(ss[i]!= 'r' && ss[i+1]!='r')sss[i]=sss[i+1]='r';\n\t\t\t\tif(ss[i]!= 'g' && ss[i+1]!='g')sss[i]=sss[i+1]='g';\n\t\t\t\tif(ss[i]!= 'b' && ss[i+1]!='b')sss[i]=sss[i+1]='b';\n\t\t\t\tnq.push(sss);\n\t\t\t}\n\t\t}\n\t}\n\tif(!nq.empty()){\n\t\t++ans;\n\t\tq=nq;\n\t\tbfs();\n\t}else na=true;\n}\n\n\nmain(){\n\tstring ss;\n\twhile(cin>>ss){\n\t\tif(ss[0]=='0')break;\n\t\tans=0;\n\t\tna=false;\n\t\tmemo.clear();\n\t\twhile(!q.empty())q.pop();\n\t\tq.push(ss);\n\t\tbfs();\n\t\tif(na)cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\n//????????????????????????????????????\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\n//??£?????????2?????????????????§?????????????????????\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s ){\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\t//?????\\??????????????¶????????\\??????\n\tif(m[p.first]) continue;\t//??????????????????\n\n\twhile (!q.empty()) {\t//?????\\??????????????¶?????????????????§\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\t//??£?????????2????????°????????¨???\n\t\t\t\tchar tmp = color(now[i], now[i + 1]);\n\t\t\t\tstring D = now;\n\t\t\t\tD[i] = tmp;\n\t\t\t\tD[i + 1] = tmp;\n\t\t\t\tq.push(P(D, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar convert[256];\n\nvoid init() {\n\tconvert['r' + 'g'] = 'b';\n\tconvert['g' + 'b'] = 'r';\n\tconvert['b' + 'r'] = 'g';\n}\n\nstring bfs(const string &worm) {\n\ttypedef pair<string, int> state;\n\n\tconst int n = worm.size();\n\n\tunordered_set<string> visited{worm};\n\tqueue<state> que;\n\tque.push({worm, 0});\n\n\n\twhile(!que.empty()) {\n\t\tconst auto s = que.front().first;\n\t\tconst auto d = que.front().second;\n\t\tque.pop();\n\n\t\tif(all_of(s.begin(), s.end(), [&](char c) { return c == s[0]; })) {\n\t\t\treturn to_string(d);\n\t\t}\n\n\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\tif(s[i] != s[i + 1]) {\n\t\t\t\tstring next(s);\n\t\t\t\tnext[i] = next[i + 1] = convert[s[i] + s[i + 1]];\n\n\t\t\t\tif(!visited.count(next)) {\n\t\t\t\t\tvisited.insert(next);\n\t\t\t\t\tque.push({next, d + 1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"NA\";\n}\n\nint main() {\n\tinit();\n\tfor(string worm; cin >> worm && worm != \"0\";) {\n\t\tcout << bfs(worm) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nbool check(string s){\n    for(int i=0; i< s.size()-1; i++) if(s[i] != s[i+1]) return false;\n    return true;\n}\n\nvector<string> v;\n\nbool emergence(string s){\n    for(int i=0; i< v.size(); i++) if(v[i] == s) return true;\n    else return false;\n}\n\nint main(){\n    string s;\n    while(cin >> s, s!= \"0\"){\n        v.clear();\n        queue<pair<string, int> > que;\n        que.push(make_pair(s, 0));\n        int ret = 9;\n        while(que.size()){\n            s = que.front().first; int count = que.front().second; que.pop();\n\n            if(ret < count) continue;\n            if(check(s))ret = count;\n            if(emergence(s)) continue;\n            else v.push_back(s);\n\n            for(int i=0; i< s.size()-1; i++){\n                if(s[i] != s[i+1]){\n                    string t = s.substr(i, 2);\n                    sort(t.begin(),t.end());\n                    if(t == \"br\") t = \"gg\";\n                    else if(t == \"bg\") t = \"rr\";\n                    else if(t == \"gr\") t = \"bb\";\n                    que.push(make_pair(s.substr(0, i)+t+s.substr(i+2), count+1));\n                }\n            }\n        }\n        if(ret == 9) cout << \"NA\" << endl;\n        else cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nqueue <pair<string,int> > worm;\nmap <string,int> M;\nint s1,n;\nstring str,strrr,sample[3]={\"gggggggggg\",\"bbbbbbbbbb\",\"rrrrrrrrrr\"},worms[3];\nbool flag=false;\n\nint main(){\n    while(1){\n        cin >> str;\n        if(str==\"0\")break;\n            s1=str.size();\n            for(int i=0;i<3;i++)worms[i]=sample[i].substr(0,s1);\n            worm.push(make_pair(str,0));\n\n\n        while(!worm.empty()){\n            str=worm.front().first;\n            n=worm.front().second;\n            worm.pop();\n            //cout << n << endl;\n            if(s1<n)break;\n            if(str==worms[0]||str==worms[1]||str==worms[2]){\n                    flag=true;\n                cout  << n << endl;\n                while(!worm.empty())worm.pop();\n                break;\n            }else{\n                for(int i=1;i<s1;i++){\n                    if(str[i]!=str[i-1]){\n                        if(str[i]!='r'&&str[i-1]!='r'){\n                            strrr=str;\n                            str[i]='r',str[i-1]='r';\n                            worm.push(make_pair(str,n+1));\n                            str=strrr;\n                        }\n                        if(str[i]!='b'&&str[i-1]!='b'){\n                            strrr=str;\n                            str[i]='b',str[i-1]='b';\n                            worm.push(make_pair(str,n+1));\n                            str=strrr;\n                        }\n                        if(str[i]!='g'&&str[i-1]!='g'){\n                            strrr=str;\n                            str[i]='g',str[i-1]='g';\n                            worm.push(make_pair(str,n+1));\n                            str=strrr;\n                        }\n                    }\n                }\n\n            }\n\n\n    //end:\n    }\n\n        if(flag==false)cout << \"NA\" << endl;\n        flag=false;\n        while(!worm.empty())worm.pop();\n        n=0;\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \";if(_c.size()){cout<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;}cout<<\" ]\"<<endl; }\n}\nostream &operator<<(ostream &os, const pair<int,int> &p){return(os<<\"(\"<<p.first<<\",\"<<p.second<<\")\");}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nchar chg(char a, char b){\n    return 'r'^'g'^'b'^a^b;\n}\n\nint solve(string s){\n    int n = s.size();\n    set<string> memo;\n    deque<pair<string,int> > q;\n    memo.insert(s);\n    q.pb(mp(s,0));\n\n    while(!q.empty()){\n        string &s = q.front().first;\n        int c = q.front().second;\n        int cnt = 0;\n        REP(i,n-1){\n            if(s[i] != s[i+1]){\n                string ns = s;\n                char cc = chg(s[i],s[i+1]);\n                ns[i] = ns[i+1] = cc;\n                if(!memo.count(ns)){\n                    memo.insert(ns);\n                    q.pb(mp(ns,c+1));\n                }\n                cnt++;\n            }\n        }\n        if(cnt == 0) return c;\n        q.pop_front();\n    }\n    return -1;\n}\n\nint main(){\n    string s;\n    while(cin >> s){\n        if(s == \"0\") break;\n        int ret = solve(s);\n        if(ret < 0){\n            cout << \"NA\" << endl;\n        } else {\n            cout << ret << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair <string, int> P;\n\n#define mp(a, b) make_pair(a, b)\n\nchar diff(char a, char b)\n{\n\tif (a != 'r' && b != 'r') return 'r';\n\tif (a != 'g' && b != 'g') return 'g';\n\tif (a != 'b' && b != 'b') return 'b';\n\treturn 'a';\n}\n\nbool check(string str)\n{\n\tchar c = str[0];\n\tfor (int i = 0; i < str.length(); i++){\n\t\tif (c != str[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tstring str;\n\n\twhile (cin >> str){\n\t\tif (str == \"0\") return 0;\n\n\t\tint ret = -1, a;\n\t\tqueue < P > q;\n\t\tmap <string, bool> memo;\n\t\tq.push(mp(str, 0));\n\t\twhile (!q.empty()){\n\t\t\tP now = q.front();\n\t\t\tq.pop();\n\t\t\tif (memo[now.first]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemo[now.first] = true;\n\t\t\tif (check(now.first)){\n\t\t\t\tret = now.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < now.first.length()-1; i++){\n\t\t\t\tif (now.first[i] != now.first[i + 1]){\n\t\t\t\t\tstring tmp = now.first;\n\t\t\t\t\ttmp[i] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\ttmp[i + 1] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\tq.push(mp(tmp, now.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret >= 0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;struct D{string s;int n;};main(){map<int,int>C;string s;int i,n,F;for(C[217]=98,C[201]='r',C[212]='g';cin>>s,s!=\"0\";F?puts(\"NA\"):printf(\"%d\\n\",n)){map<string,int>M;queue<D>q;D d={s,0};q.push(d);for(M[s]=1;q.size();){d=q.front();q.pop();s=d.s;n=d.n;for(i=F=0;++i<s.size();)if(s[i-1]-s[i]){D d={s,n+1};d.s[i-1]=d.s[i]=C[s[i-1]+s[i]];if(M.find(d.s)==M.end())q.push(d);F=M[d.s]=1;}if(!F)break;}}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<queue>\n#include<unordered_map>\n#include<map>\n#define P pair<string,int>\n#define p pair<char,char>\nusing namespace std;\n\nint main()\n{\n\tmap<p, char>M;\n\tM[p('b', 'g')] = 'r';\n\tM[p('g', 'b')] = 'r';\n\tM[p('b', 'r')] = 'g';\n\tM[p('r', 'b')] = 'g';\n\tM[p('r', 'g')] = 'b';\n\tM[p('g', 'r')] = 'b';\n\tstring a;\n\twhile (cin >> a, a != \"0\") {\n\t\tunordered_map<string, int>U;\n\t\tqueue<P>Q;\n\t\tQ.push(P(a, 1));\n\t\twhile (Q.size()) {\n\t\t\tP c = Q.front(); Q.pop();\n\t\t\tbool d = true;\n\t\t\tfor (int e = 1; e < c.first.length(); e++)if (c.first[e - 1] != c.first[e])d = false;\n\t\t\tif (d) { cout << c.second - 1 << endl; break; }\n\t\t\tfor (int e = 1; e < c.first.length(); e++) {\n\t\t\t\tif (c.first[e - 1] != c.first[e]) {\n\t\t\t\t\tstring copy = c.first;\n\t\t\t\t\tcopy[e - 1] = copy[e] = M[p(c.first[e - 1], c.first[e])];\n\t\t\t\t\tif (U[copy] == 0) { U[copy] = c.second + 1; Q.push(P(copy,U[copy])); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n\nbool isSameColor(string a){\n\tchar b=a[0];\n\tint s=a.size();\n\t\n\tfor(int i=0; i<s; ++i){\n\t\tif(a[i]!=b) return false;\n\t}\n\t\n\treturn true;\t\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s){\n\t\tif(s==\"0\") break;\n\t\t\n\t\tqueue<string> que;\n\t\tmap<string, long> mp;\n\t\t\n\t\tque.push(s);\n\t\tmp[s]=0;\t\n\t\t\n\t\tbool found=false;\n\t\twhile(!que.empty()){\n\t\t\tstring v=que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tint size=v.size();\n\t\t\tfor(int i=0; i<size-1; ++i){\n\t\t\t\tstring tmp=v;\n\t\t\t\t\n\t\t\t\tif((tmp[i]=='r'&&tmp[i+1]=='g') || (tmp[i]=='g'&&tmp[i+1]=='r')) tmp[i]=tmp[i+1]='b';\n\t\t\t\telse if((tmp[i]=='r'&&tmp[i+1]=='b') || (tmp[i]=='b'&&tmp[i+1]=='r')) tmp[i]=tmp[i+1]='g';\n\t\t\t\telse if((tmp[i]=='b'&&tmp[i+1]=='g') || (tmp[i]=='g'&&tmp[i+1]=='b')) tmp[i]=tmp[i+1]='r';\n\t\t\t\t\n\t\t\t\tif(mp.find(tmp) == mp.end()){\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t\tmp[tmp]=mp[v]+1;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isSameColor(tmp)){\n\t\t\t\t\tcout << mp[tmp] << endl;\t\n\t\t\t\t\tfound=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t\t\n\t\t\tif(found) break;\n\t\t}\n\t\t\n\t\tif(!found) printf(\"NA\\n\");\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\nclass S{\npublic:\n  string s;\n  int n;\n  S(string s,int n):s(s),n(n){}\n};\n\nint main(){\n  while(1){\n    string a;\n    cin>>a;\n    if(a==\"0\")break;\n\n    queue<S> que;\n    map<string,int> memo;\n    char cc[111][111];\n    rep(i,111)rep(j,111)cc[i][j]=-1;\n    que.push(S(a,0));\n    int ans=0;\n    int kn=0;\n    while(1){\n      if(que.empty()==1){\n\tbreak;\n      }\n      S u = que.front();\n      que.pop();\n      ans=u.n;\n      //cout<<u.s<<\" \"<<u.n<<endl;\n      if(memo[u.s]!=0){\n\tcontinue;\n      }\n      memo[u.s]=1;\n      int comp=1;\n      int ch=u.s[0];\n      reps(i,u.s.size()-1){\n\tif(ch!=u.s[i]){\n\t  comp=0;\n\t  break;\n\t}\n      }\n      if(comp==1){\n\tkn=1;\n\tbreak;\n      }\n      cc['r']['g']=cc['g']['r']='b';\n      cc['r']['b']=cc['b']['r']='g';\n      cc['b']['g']=cc['g']['b']='r';\n      rep(i,u.s.size()-1){\n\tstring cop=u.s;\n\tif(u.s[i]!=u.s[i+1]){\n\t  cop[i]=cop[i+1]=cc[cop[i]][cop[i+1]];\n\t  que.push(S(cop,u.n+1));\n\t}\n      }\n    }\n    if(kn==1){\n      printf(\"%d\\n\",ans);\n    }else{\n      printf(\"-1\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define rep(i,N) FOR(i, 0, N)\n#define ALL(s) (s).begin(), (s).end()\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).reeal(), (b).real) && EQ((a).imag(), (b).imag()))\n#define NIL -1\n\nll g;\nll w;\nll d[100000];\nchar table[] = {'r','g','b'};\n\nstring myitos(ll num){\n    string res = \"\";\n    rep(i,w){\n        res += table[num % 3];\n        num /= 3;\n    }\n    reverse(ALL(res));\n    return res;\n}\n\nll mystoi(string s){\n    ll res = 0;\n    rep(i,s.size()){\n        res *= 3;\n        if(s[i] == 'g')res++;\n        else if(s[i] == 'b')res += 2;\n    }\n    return res;\n}\n\nvoid dijkstra(ll start){\n    fill(d,d+100000,INF);\n    d[start] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(P(0,start));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        ll v = p.second;\n        ll cost = p.first;\n        if(d[v] < cost)continue;\n        // d[v] = cost;\n        if(v == 0 || v == g || v == 2*g)continue;\n\n        string now = myitos(v);\n\n        rep(i,now.size() - 1){\n            char c1 = now[i];\n            char c2 = now[i+1];\n            string t = now;\n            if((c1 == 'r' && c2 == 'g') || (c1 == 'g' && c2 == 'r')){\n                t[i] = 'b';\n                t[i+1] = 'b';\n            }\n            if((c1 == 'g' && c2 == 'b') || (c1 == 'b' && c2 == 'g')){\n                t[i] = 'r';\n                t[i+1] = 'r';\n            }\n            if((c1 == 'b' && c2 == 'r') || (c1 == 'r' && c2 == 'b')){\n                t[i] = 'g';\n                t[i+1] = 'g';\n            }\n            ll to = mystoi(t);\n            // cout << t << endl;\n            if(d[to] > cost+1){\n                d[to] = cost + 1;\n                que.push(P(cost+1,to));\n            }\n        }\n\n    }\n}\n\nstring s;\n\nint main(){\n    while(cin >> s && s != \"0\"){\n        int start = 0;\n        w = s.size();\n        g = 0;\n        rep(i,s.size()){\n            g *= 3;\n            g++;\n            int num = 0;\n            if(s[i] == 'g')num++;\n            if(s[i] == 'b')num += 2;\n            start = 3*start + num;\n        }\n        // string t = myitos(start);\n        // cout << t << endl;\n        // cout << mystoi(t) << endl;\n        // continue;\n        dijkstra(start);\n        ll ans = min(d[0],min(d[g],d[2*g]));\n        if(ans == INF)cout << \"NA\" << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n// テァツオツづ、ツコツ?ァツ環カテヲツ?凝」ツ?凝・ツ按、テ・ツョツ堙」ツ?凖」ツつ?\ninline bool ok(const string & v){\n    for (int i = 1; i < v.size(); i++){\n        if (v[i] != v[0]) return false;\n    }\n    return true;\n};\n\n// 3ティツ可イテ」ツ?ョテ」ツ??」ツ?。ティツ可イa,ティツ可イbテ」ツ?ョテ」ツ?ゥテ」ツ?。テ」ツつ嘉」ツ?ァテ」ツつづ」ツ?ェテ」ツ??ィツ可イテ」ツつ津ィツソツ氾」ツ??\ninline char other(char a, char b){\n    if (a>b)swap(a, b);\n    if (a == 'g' && b == 'r'){\n        return 'b';\n    }\n    if (a == 'b' && b == 'g'){\n        return 'r';\n    }\n    if (a == 'b' && b == 'r'){\n        return 'g';\n    }\n    // テ・ツ?ィテ」ツ?ヲテ」ツ?ョifテ」ツ?ォテ・ツシツ陛」ツ?」テ」ツ?凝」ツ?凝」ツつ嘉」ツ?ェテ」ツ??」ツ?ョテ」ツ?ッテヲツ伉偲」ツつ嘉」ツ?凝」ツ?ォテ・ツ、ツ嘉」ツ?ェテ」ツ?ョテ」ツ?ァtry-catchテァツ?。テ」ツ?療」ツ?ァテ、ツセツ凝・ツ、ツ姪」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // テ」ツ?禿」ツ??」ツ?凖」ツつ凝」ツ?ィテ」ツつクテ」ツδ」テ」ツδε」ツつクテ」ツ?ァWAテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?蹴Eテ」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?ョテ」ツ?ァテ」ツδ?」ツδ静」ツδε」ツつーテ」ツ?療」ツつ?」ツ?凖」ツ??\n    // Cティツィツ?ィツェツ榲」ツ?ァテ」ツ?ッassertテ」ツ?古、ツスツソテ」ツ?暗」ツつ?\n    throw \"illigal char\";\n}\n\n// テ」ツつュテ」ツδ・テ」ツδシテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ凝ァツ環カテヲツ?凝」ツ?ョテ・ツ楪?\nstruct state {\n    string str;\n    int n;\n};\n\nint main(){\n    string s;\n    while (cin >> s, s != \"0\"){\n        queue<state> q;\n        // テ」ツ?凖」ツ?ァテ」ツ?ォティツィツェテ」ツつ古」ツ?淌ァツ環カテヲツ?凝」ツつ津ヲツ?シテァツエツ催」ツ?凖」ツつ虐et テ・ツ按敕」ツつ?」ツ?ッテァツゥツコ\n        set<string> dp;\n        // テ・ツ按敕ヲツ慊淌ァツ環カテヲツ?凝」ツつ智ueueテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ?\n        q.push({ s, 0 });\n\n        int ans = -1;\n        while (q.size()){\n            // staテ」ツ?繋ueueテ」ツ?ョテ、ツクツ?ァツ閉ェテ、ツクツ甘」ツ?ョテァツ環カテヲツ?凝」ツつ津、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツ?ォテ」ツ?療ッツシツ繋ueueテ」ツ?凝」ツつ嘉・ツ?コテ」ツ??\n            state sta = q.front();\n            q.pop();\n            string & sv = sta.str;\n\n            // setテ」ツ?ォテ、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツつ津・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィティツゥツヲテ」ツ?ソテ」ツつ凝ッツシツ?\n            // autoテ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲティツゥツウテ」ツ?療」ツ?湘」ツ?ッテヲツ慊?・ツセツ古」ツ?ョテ」ツつウテ」ツδ。テ」ツδウテ」ツδ暗」ツ?ォ\n            auto pr = dp.insert(sv);\n            if (!pr.second){\n                // テ、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツ?茎etテ」ツ?ォテヲツ猟「テ」ツ?ォテ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツ??」ツ?淌」ツ?淌」ツつ（nsertテ」ツ?ォテ・ツ、ツアテヲツ閉療」ツ?療」ツ?淌ッツシツ?\n                // テ」ツ?、テ」ツ?セテ」ツつ甘ッツシツ古ゥツ?偲・ツ篠サテ」ツ?ョテ」ツδォテ」ツδシテ」ツδ療」ツ?ァテァツ「ツコティツェツ催ヲツクツ暗」ツ?ソテ」ツ?ョテ」ツ?淌」ツつ?ッツシツ古」ツ?禿」ツ?ョテァツ環カテヲツ?凝、ツサツ・テゥツ卍催」ツつ津ヲツ篠「テァツエツ「テ」ツ?凖」ツつ凝・ツソツ?ィツヲツ?」ツ?ッテ」ツ?ェテ」ツ??」ツ?凝」ツつ嘉」ツδォテ」ツδシテ」ツδ療」ツつ津ヲツ環愿」ツ?妥」ツつ?\n                continue;\n            }\n\n            // テァツ崢ョテァツ堋?」ツ?ョテァツ環カテヲツ?凝」ツ?ォティツセツソテ」ツつ甘ァツ敖?」ツ??」ツ?淌」ツ?ェテ」ツつ嘉ヲツ篠「テァツエツ「テァツオツづ、ツコツ?\n            if (ok(sv)){\n                ans = sta.n;\n                break;\n            }\n\n            // テ」ツ?敕」ツ??」ツ?ァテ」ツ?ェテ」ツ?妥」ツつ古」ツ?ーテッツシツ古、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツ?凝」ツつ嘉ァツァツサテ」ツつ古」ツつ凝・ツ?ィテ」ツ?ヲテ」ツ?ョテァツ環カテヲツ?凝」ツつ智ueueテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ?\n            for (int i = 1; i < sv.size(); i++){\n                // テ」ツつづ」ツ?療ゥツ堋」テ」ツ?ィテゥツ?陛」ツ??ィツ可イテ」ツ?ェテ」ツつ嘉ッツシツ?\n                if (sv[i] != sv[i - 1]){\n                    char a = sv[i];\n                    char b = sv[i - 1];\n                    sv[i] = sv[i - 1] = other(a, b);\n                    q.push({ sv, sta.n + 1 });\n                    sv[i] = a;\n                    sv[i - 1] = b;\n                }\n            }\n        }\n\n        // ansテ」ツ?ョテ・ツ?、テ」ツ?古ヲツ崢エテヲツ鳴ーテ」ツ?陛」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ?妥」ツつ古」ツ?ーテッツシツ古ァツュツ氾」ツ?暗」ツ?ィテ」ツ?ェテ」ツつ凝ヲツ可凝ゥツ??」ツ?ッティツヲツ凝」ツ?、テ」ツ?凝」ツ?」テ」ツ?ヲテ」ツ??」ツ?ェテ」ツ??\n        if (ans == -1){\n            cout << \"NA\" << endl;\n        }\n        else{\n            cout << ans << endl;\n        }\n    }\n}\n\n// テ・ツ楪凝・ツ青催」ツ?ォautoテ」ツ?ィテヲツ崢クテ」ツ?湘」ツ?ィテ・ツ楪凝」ツつ津ヲツ篠ィティツォツ姪」ツ?療」ツ?ヲテ」ツ?湘」ツつ古」ツつ?C++11テゥツ卍静・ツョツ? g++ -std=c++11 a.cpp テ」ツ?ョテ」ツつ暗」ツ??」ツ?ォテ」ツつウテ」ツδウテ」ツδ妥」ツつ、テ」ツδォテ」ツ?凖」ツつ凝」ツ?ィテ、ツスツソテ」ツ?暗」ツつ凝ッツシツ?\n// setテ」ツ?ョテ」ツδ。テ」ツδウテ」ツδ静」ツδシテゥツ鳴「テヲツ閉ーテ」ツ?景nsertテ」ツ?催」ツ?ョテヲツ按サテ」ツつ甘・ツ?、テ」ツ?ョテ・ツ楪凝」ツ?ッ pair<set<state>::const_iterator, bool> テ・ツ楪凝」ツ?ァテッツシツ古」ツ?禿」ツつ古」ツつ津ヲツ崢クテ」ツ?湘」ツ?ョテ」ツ?ッテ」ツ?療」ツつ禿」ツ?ゥテ」ツ??」ツ??\n// autoテ」ツつ津、ツスツソテ」ツ?暗」ツ?ーテ」ツ?禿」ツ?ョテ」ツつ暗」ツ??」ツ?ェテゥツ閉キテ」ツ??・ツスツ「テ・ツ青催」ツつ津ァツ慊?ァツ閉・テ」ツ?ァテ」ツ?催」ツつ?テ・ツ楪凝ヲツ篠ィティツォツ?テッツシツ?\n// auto pr = dp.insert(sv);\n// テ」ツ?ッ\n// pair<set<state>::const_iterator, bool> pr = dp.insert(sv);\n// テ」ツ?ィテ・ツ青古」ツ?佚ッツシツ?"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nbool dfs(string str, int c)\n{\n\tbool f = true;\n\tfor(int i = 1; i < str.size(); i++){\n\t\tif(str[0] != str[i]){\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(f){\n\t\treturn f;\n\t}\n\tif(c == 0){\n\t\treturn f;\n\t}\n\t\n\tchar s, t, u;\n\tfor(int i = 0; i < str.size()-1; i++){\n\t\tif(str[i] != str[i+1]){\n\t\t\ts = str[i];\n\t\t\tt = str[i+1];\n\t\t\tif((s == 'r' && t == 'b') || (s == 'b' && t == 'r')){\n\t\t\t\tu = 'g';\n\t\t\t} else if((s == 'r' && t == 'g') || (s == 'g' && t == 'r')){\n\t\t\t\tu = 'b';\n\t\t\t} else {\n\t\t\t\tu = 'r';\n\t\t\t}\n\t\t\tstr[i] = str[i+1] = u;\n\t\t\tf = dfs(str, c-1);\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr[i] = s;\n\t\t\tstr[i+1] = t;\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint main()\n{\n\tint t;\n\tstring str;\n\t\n\twhile(cin>>str){\n\t\tif(str == \"0\"){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(t = 0; t <= 9; t++){\n\t\t\tif(dfs(str, t)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(t > 9){\n\t\t\tcout << \"NA\" << endl;\n\t\t} else {\n\t\t\tcout << t << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\nusing namespace std;\n\nbool check(string a){\n    char pivot = a[0];\n    for(int i = 1; i < a.length(); i++) if(a[i] != pivot)   return false;\n    return true;\n}\n\nchar rgb[3] = {'r', 'g', 'b'};\n\nint main(){\n    string x;\n    while(cin >> x){\n        if(x == \"0\")    break;\n\n        queue<pair<string,int>> q;\n        set<string> s;\n\n        q.push({x,0});\n\n        int ans = -1;\n        while(!q.empty()){\n            pair<string,int> t = q.front(); q.pop();\n            if(check(t.first)){\n                ans = t.second;\n                break;\n            }\n            \n            if(s.find(t.first) != s.end())  continue;\n\n            s.insert(t.first);\n            for(int i = 0; i < t.first.length()-1; i++){\n                if(t.first[i] == t.first[i+1])  continue;\n\n                for(int j = 0; j < 3; j++){\n                    if(t.first[i] != rgb[j] && t.first[i+1] != rgb[j]){\n                        string copy = t.first;\n                        copy.replace(i, 2, 2, rgb[j]);\n                        if(s.find(copy) == s.end()) q.push({copy, t.second+1});\n                    }\n                }\n            }\n        }\n\n        if(ans == -1)   cout << \"NA\" << endl;\n        else            cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n\tchar str[256];\n\tchar col[3] = \"rgb\";\n\t\n\twhile (scanf(\"%s\", str) && str[0] !='0'){\n\t\tmap<string, int> minTime;\n\t\tqueue<string> q;\n\t\tstring s = str;\n\t\t\n\t\tminTime[s] = 0;\n\t\t\n\t\tbool ng = true;\n\t\tfor (q.push(s); !q.empty(); q.pop()){\n\t\t\tstring look = q.front();\n\t\t\t\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 0; i < look.size() - 1; i++){\n\t\t\t\tif (look[i + 1] != look[i]) flag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (flag){\n\t\t\t\tprintf(\"%d\\n\", minTime[look]);\n\t\t\t\tng = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int c = 0; c < 3; c++){\n\t\t\t\tfor (int i = 0; i < look.size() - 1; i++){\n\t\t\t\t\tif (look[i + 1] != col[c] && look[i] != col[c] && look[i + 1] != look[i]){\n\t\t\t\t\t\tstring next = look;\n\t\t\t\t\t\tnext[i + 1] = next[i] = col[c];\n\t\t\t\t\t\tif (minTime.count(next) > 0) continue;\n\t\t\t\t\t\tminTime[next] = minTime[look] + 1;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ng) printf(\"NA\\n\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <utility>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, string> P;\n\nint main()\n{\n    char worm[32];\n\n    while (scanf(\"%s\", worm), *worm != '0'){\n        queue<P> que;\n\n        for (que.push(P(0, string(worm))); que.size(); que.pop()){\n            P tmp = que.front();\n            string s = tmp.second;\n            bool flag = true;\n\n            for (int i = 0; i < s.length() - 1; i++){\n                string t = s;\n\n                if (t[i] != t[i + 1]){\n                    flag = false;\n                    if (t[i] != 'r' && t[i + 1] != 'r'){\n                        t[i] = t[i + 1] = 'r';\n                    }\n                    else if (t[i] != 'g' && t[i + 1] != 'g'){\n                        t[i] = t[i + 1] = 'g';\n                    }\n                    else {\n                        t[i] = t[i + 1] = 'b';\n                    }\n                    que.push(P(tmp.first + 1, t));\n                }\n            }\n            if (flag){\n                printf(\"%d\\n\", tmp.first);\n                break;\n            }\n        }\n        if (que.empty()){\n            puts(\"NA\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<string,int> P;\nint main() {\n\tstring S;\n\twhile(cin>>S) {\n\t\tset<string> ST;\n\t\tqueue<P> Q;\n\t\tQ.push(P(S,0));\n\t\tstring R,G,B;\n\t\tbool OK;\n\t\twhile(!Q.empty()) {\n\t\t\tP p=Q.front();Q.pop();\n\t\t\tOK=true;\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tstring SS=p.first;\n\t\t\t\tif((p.first[i]=='r'&&p.first[i+1]=='g')||(p.first[i]=='g'&&p.first[i+1]=='r')) {\n\t\t\t\t\t\tSS[i]=SS[i+1]='b';\n\t\t\t\t\t\tif(ST.find(SS)==ST.end()){\n\t\t\t\t\t\t\tQ.push(P(SS,p.second+1));\n\t\t\t\t\t\t\tST.insert(SS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOK=false;\n\t\t\t\t}else if((p.first[i]=='r'&&p.first[i+1]=='b')||(p.first[i]=='b'&&p.first[i+1]=='r')) {\n\t\t\t\t\t\tSS[i]=SS[i+1]='g';\n\t\t\t\t\t\tif(ST.find(SS)==ST.end()){\n\t\t\t\t\t\t\tQ.push(P(SS,p.second+1));\n\t\t\t\t\t\t\tST.insert(SS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOK=false;\n\t\t\t\t}else if((p.first[i]=='g'&&p.first[i+1]=='b')||(p.first[i]=='b'&&p.first[i+1]=='g')) {\n\t\t\t\t\t\tSS[i]=SS[i+1]='r';\n\t\t\t\t\t\tif(ST.find(SS)==ST.end()){\n\t\t\t\t\t\t\tQ.push(P(SS,p.second+1));\n\t\t\t\t\t\t\tST.insert(SS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK) {cout<<p.second<<endl;break;}\n\t\t}\n\t\tif(!OK)cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nint main()\n{\n\tchar s[11];\n\twhile (~scanf(\"%s\", s), s[0] != '0') {\n\t\tmap<string, bool> m;\n\n\t\tqueue<string> q, r;\n\n\t\tq.push(s);\n\n\t\tint cnt = 0;\n\n\t\twhile (q.size()) {\n\t\t\twhile (q.size()) {\n\t\t\t\tstring t = q.front(); q.pop();\n\t\t\t\tif (m[t]) continue;\n\t\t\t\tm[t] = true;\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int i = 0; i < t.size() - 1; ++i) {\n\t\t\t\t\tif ((t[i] == 'r' && t[i + 1] == 'b') || (t[i] == 'b' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'g';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'b' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'b')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'r';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'r' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'b';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tprintf(\"%d\\n\", cnt);\n\t\t\t\t\tgoto nxt;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (r.size()) {\n\t\t\t\tstring t = r.front(); r.pop();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\tprintf(\"NA\\n\");\nnxt:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/02/23 Tazoe\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstruct change{\n\tstring dat;\n\tint tim;\n};\n\nint main()\n{\n\twhile(true){\n\t\tstruct change wor;\n\t\tcin >> wor.dat;\n\t\tif(wor.dat==\"0\")\n\t\t\tbreak;\n\t\twor.tim = 0;\n\n\t\tqueue<struct change> que;\n\t\tque.push(wor);\n\n\t\tmap<string, bool> mem;\n\n\t\tint cost;\n\t\twhile(true){\n\t\t\tif(que.empty()){\n\t\t\t\tcost = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twor = que.front();\n\t\t\tque.pop();\n//\t\t\tcout << wor.dat << ' ' << wor.tim << endl;\n\n\t\t\tif(mem[wor.dat])\n\t\t\t\tcontinue;\n\t\t\tmem[wor.dat] = true;\n\n\t\t\tbool flg = true;\n\t\t\tfor(int i=1; i<wor.dat.size(); i++)\n\t\t\t\tif(wor.dat[i]!=wor.dat[0]){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tcost = wor.tim;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstruct change tmp;\n\t\t\tfor(int i=0; i<wor.dat.size()-1; i++)\n\t\t\t\tif(wor.dat[i]==wor.dat[i+1])\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(wor.dat[i]!='r'&&wor.dat[i+1]!='r'){\n\t\t\t\t\ttmp.dat = wor.dat;\n\t\t\t\t\ttmp.dat[i] = tmp.dat[i+1] = 'r';\n\t\t\t\t\ttmp.tim = wor.tim+1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t\telse if(wor.dat[i]!='g'&&wor.dat[i+1]!='g'){\n\t\t\t\t\ttmp.dat = wor.dat;\n\t\t\t\t\ttmp.dat[i] = tmp.dat[i+1] = 'g';\n\t\t\t\t\ttmp.tim = wor.tim+1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t\telse if(wor.dat[i]!='b'&&wor.dat[i+1]!='b'){\n\t\t\t\t\ttmp.dat = wor.dat;\n\t\t\t\t\ttmp.dat[i] = tmp.dat[i+1] = 'b';\n\t\t\t\t\ttmp.tim = wor.tim+1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t}\n\n\t\tif(cost==-1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n\tchar str[256];\n\tchar col[4] = \"rgb\";\n\t\n\twhile (scanf(\"%s\", str) && str[0] !='0'){\n\t\tmap<string, int> minTime;\n\t\tqueue<string> q;\n\t\tstring s = str;\n\t\t\n\t\tminTime[s] = 0;\n\t\t\n\t\tbool ng = true;\n\t\tfor (q.push(s); !q.empty(); q.pop()){\n\t\t\tstring look = q.front();\n\t\t\t\n\t\t\tbool flag = true;\n\t\t\tfor (int i = 0; i < look.size() - 1; i++){\n\t\t\t\tif (look[i + 1] != look[i]) flag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (flag){\n\t\t\t\tprintf(\"%d\\n\", minTime[look]);\n\t\t\t\tng = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int c = 0; c < 3; c++){\n\t\t\t\tfor (int i = 0; i < look.size() - 1; i++){\n\t\t\t\t\tif (look[i + 1] != col[c] && look[i] != col[c] && look[i + 1] != look[i]){\n\t\t\t\t\t\tstring next = look;\n\t\t\t\t\t\tnext[i + 1] = next[i] = col[c];\n\t\t\t\t\t\tif (minTime.count(next) > 0) continue;\n\t\t\t\t\t\tminTime[next] = minTime[look] + 1;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ng) printf(\"NA\\n\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, string> P;\n\nstring worm;\n\nbool chkColor(int len){\n  for(int i = 0; i < len - 1; ++i) if(worm[i] != worm[i + 1]) return false;\n  return true;\n}\n\nint bfs(){\n\n  int cnt, len = worm.length();\n  queue<P> q; q.push(P(0, worm));\n  map<string, bool> mpworm; mpworm[worm] = true;\n\n  while(!q.empty()){\n\n    P p = q.front(); q.pop();\n    cnt = p.first;\n    worm = p.second;\n\n    if(chkColor(len)) return cnt;\n\n    for(int i = 0; i < len - 1; ++i){\n\n      char ncolor;\n      string nworm = worm;\n\n      if(worm[i] != worm[i + 1]){\n        if(worm[i] == 'r' && worm[i + 1] == 'g' || worm[i] == 'g' && worm[i + 1] == 'r') ncolor = 'b';\n  \t    else if(worm[i] == 'g' && worm[i + 1] == 'b' || worm[i] == 'b' && worm[i + 1] == 'g') ncolor = 'r';\n        else if(worm[i] == 'b' && worm[i + 1] == 'r' || worm[i] == 'r' && worm[i + 1] == 'b') ncolor = 'g';\n        nworm[i] = ncolor;\n        nworm[i + 1] = ncolor;\n        if(mpworm[nworm] != true){\n          mpworm[nworm] = true;\n          q.push(P(cnt + 1, nworm));\n        }\n      }\n\n    }\n\n  }\n  return -1;\n}\n\n\nint main(){\n\n  int ans;\n\n  while(1){\n\n    cin >> worm;\n    if(worm == \"0\")break;\n    ans = bfs();\n    if(ans == -1)cout << \"NA\" << endl;\n    else cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tstring s,t;for(int i,n,f;cin>>s,s!=\"0\";){\n\t\tqueue<string>q;\n\t\tmap<string,int>d;d[s]=1;\n\t\tfor(q.push(s);q.size();){\n\t\t\ts=q.front();q.pop();n=s.length();\n\t\t\tfor(f=i=0;i<n-1;i++)if(s[i]!=s[i+1]){\n\t\t\t\tt=s;t[i]=t[i+1]=(char)('r'+'g'+'b'-s[i]-s[i+1]);f++;\n\t\t\t\tif(!d[t])d[t]=d[s]+1,q.push(t);\n\t\t\t}\n\t\t\tif(!f){cout<<d[s]-1<<endl;goto N;}\n\t\t}\n\t\tcout<<\"NA\"<<endl;N:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<string.h>\n\nusing namespace std;\nchar c[11];\nint d[10];\nint bfs[59049];\nint temp[10];\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",c);\n\t\tif(c[0]=='0')return 0;\n\t\tqueue<int> Q;\n\t\tfor(int i=0;i<59049;i++)bfs[i]=-1;\n\t\tint first=0;\n\t\tint s=strlen(c);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tfirst*=3;\n\t\t\tif(c[i]=='r')first+=2;\n\t\t\tif(c[i]=='g')first++;\n\t\t}\n\t\tbfs[first]=0;\n\t\tQ.push(first);\n\t\twhile(Q.size()){\n\t\t\tint now=Q.front();\n\t\t\tint val=now;\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\td[s-i-1]=val%3;\n\t\t\t\tval/=3;\n\t\t\t\ttemp[s-i-1]=d[s-i-1];\n\t\t\t}\n\t\t\tfor(int i=0;i<s-1;i++){\n\t\t\t\tif(d[i]!=d[i+1]){\n\t\t\t\t\tif(d[i]!=0&&d[i+1]!=0){\n\t\t\t\t\t\ttemp[i]=temp[i+1]=0;\n\t\t\t\t\t\tint next=0;\n\t\t\t\t\t\tfor(int j=0;j<s;j++){\n\t\t\t\t\t\t\tnext*=3;\n\t\t\t\t\t\t\tnext+=temp[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bfs[next]==-1){\n\t\t\t\t\t\t\tbfs[next]=bfs[now]+1;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(d[i]!=1&&d[i+1]!=1){\n\t\t\t\t\t\ttemp[i]=temp[i+1]=1;\n\t\t\t\t\t\tint next=0;\n\t\t\t\t\t\tfor(int j=0;j<s;j++){\n\t\t\t\t\t\t\tnext*=3;\n\t\t\t\t\t\t\tnext+=temp[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bfs[next]==-1){\n\t\t\t\t\t\t\tbfs[next]=bfs[now]+1;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(d[i]!=2&&d[i+1]!=2){\n\t\t\t\t\t\ttemp[i]=temp[i+1]=2;\n\t\t\t\t\t\tint next=0;\n\t\t\t\t\t\tfor(int j=0;j<s;j++){\n\t\t\t\t\t\t\tnext*=3;\n\t\t\t\t\t\t\tnext+=temp[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bfs[next]==-1){\n\t\t\t\t\t\t\tbfs[next]=bfs[now]+1;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp[i]=d[i];\n\t\t\t\t\ttemp[i+1]=d[i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tint q=0;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tq*=3;\n\t\t\tq++;\n\t\t}\n\t\tint r=0;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tr*=3;\n\t\t\tr+=2;\n\t\t}\n\t\tint ans=99999999;\n\t\tif(bfs[0]!=-1&&ans>bfs[0])ans=bfs[0];\n\t\tif(bfs[q]!=-1&&ans>bfs[q])ans=bfs[q];\n\t\tif(bfs[r]!=-1&&ans>bfs[r])ans=bfs[r];\n\t\tif(ans==99999999)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\nmap<string, int> cache;\nbool same(string seq){\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    if(seq[i] != seq[i+1]){\n      return false;\n    }\n  }\n  return true;\n}\nint dls(string seq, int depth){\n  if(depth<0){\n    return false;\n  }\n  if(same(seq)){\n    return true;\n  }\n  if(cache.find(seq) != cache.end()){\n    if(cache[seq] >= depth){\n      return false;\n    }\n    cache[seq] = depth;\n  }\n  else{\n    cache[seq] = depth;\n  }\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    char t = seq[i];\n    char n = seq[i+1];\n    if(t != n){\n      if((t + n) == ('r' + 'b')){\n        seq[i] = seq[i+1] = 'g';\n      }\n      else if((t + n) == ('r' + 'g')){\n        seq[i] = seq[i+1] = 'b';\n      }\n      else{\n        seq[i] = seq[i+1] = 'r';\n      }\n      if(dls(seq, depth-1)){\n        return true;\n      }\n      seq[i] = t;\n      seq[i+1] = n;\n    }\n  }\n  return false;\n}\nvoid iddfs(string seq){\n  cache = map<string, int>();\n  for(int depth = 0;depth <= 20; ++depth){\n    if(dls(seq, depth)){\n      cout << depth << endl;\n      return;\n    }\n  }\n  cout << \"NA\" << endl;\n}\nint main(){\n  char seq[11];\n  while(true){\n    cin >> seq;\n    if(seq[0] == '0'){\n      break;\n    }\n    iddfs(seq);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\ntypedef long long int lli;\nusing namespace std;\n\nint main(){\n\tstring str;\n\twhile(cin>>str&&str!=\"0\"){\n\t\tmap<string,int> d;\n\t\tqueue<string> que;\n\t\tque.push(str);\n\t\td[str]=0;\n\t\tint flag1=true;\n\t\twhile(que.size()){\n\t\t\tstring tmp=que.front();\n\t\t\tque.pop();\n\t\t\tint flag2=true;\n\t\t\tchar a=tmp[0];\n\t\t\tfor(int i=1; i<tmp.size(); ++i){\n\t\t\t\tif(a!=tmp[i]) {\n\t\t\t\t\tflag2=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ta=tmp[i];\n\t\t\t}\n\t\t\tif(flag2){\n\t\t\t\tcout << d[tmp] << \"\\n\";\n\t\t\t\tflag1=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0; i+1<tmp.size(); ++i){\n\t\t\t\tif(tmp[i]!=tmp[i+1]){\n\t\t\t\t\tstring nstr=tmp;\n\t\t\t\t\tif(tmp[i]!='r'&&tmp[i+1]!='r'){\n\t\t\t\t\t\tnstr[i]='r';\n\t\t\t\t\t\tnstr[i+1]='r';\n\t\t\t\t\t} else if(tmp[i]!='g'&&tmp[i+1]!='g'){\n\t\t\t\t\t\tnstr[i]='g';\n\t\t\t\t\t\tnstr[i+1]='g';\n\t\t\t\t\t} else if(tmp[i]!='b'&&tmp[i+1]!='b'){\n\t\t\t\t\t\tnstr[i]='b';\n\t\t\t\t\t\tnstr[i+1]='b';\n\t\t\t\t\t}\n\t\t\t\t\tif(nstr[i]==nstr[i+1]&&d.count(nstr)==0){\n\t\t\t\t\t\tque.push(nstr);\n\t\t\t\t\t\td[nstr]=d[tmp]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag1) cout << \"NA\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n\nstruct Bug{\n\tint red, blue, green, days;\n\tstd::string body;\n};\n\nint main(){\n\tstd::string s;\n\twhile(std::cin >> s, s != \"0\"){\n\t\tint bug_length = s.length();\n\t\tstd::queue<Bug> bug_s;\n\t\tstd::map<std::string, int> bug_m;\n\t\tBug first_bug = {0, 0, 0, 0, s};\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s[i] == 'r'){\n\t\t\t\tfirst_bug.red++;\n\t\t\t}\n\t\t\tif(s[i] == 'g'){\n\t\t\t\tfirst_bug.green++;\n\t\t\t}\n\t\t\tif(s[i] == 'b'){\n\t\t\t\tfirst_bug.blue++;\n\t\t\t}\n\t\t}\n\t\tbug_s.push(first_bug);\n\t\tint res = -1;\n\t\twhile(!bug_s.empty()){\n\t\t\tBug b = bug_s.front();bug_s.pop();\n\t\t\tif(bug_m[b.body] > 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.red == bug_length || b.blue == bug_length || b.green == bug_length){\n\t\t\t\tres = b.days;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBug temp;\n\t\t\tfor(int i=0;i<bug_length-1;i++){\n\t\t\t\ttemp = b;\n\t\t\t\tif(temp.body[i] != temp.body[i+1]){\n\t\t\t\t\tif(temp.body[i]+temp.body[i+1] == 'r'+'b'){\n\t\t\t\t\t\ttemp.body[i] = temp.body[i+1] = 'g';\n\t\t\t\t\t\ttemp.red--;temp.blue--;temp.green+=2;\n\t\t\t\t\t}else if(temp.body[i]+temp.body[i+1] == 'r'+'g'){\n\t\t\t\t\t\ttemp.body[i] = temp.body[i+1] = 'b';\n\t\t\t\t\t\ttemp.red--;temp.green--;temp.blue+=2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp.body[i] = temp.body[i+1] = 'r';\n\t\t\t\t\t\ttemp.blue--;temp.green--;temp.red+=2;\n\t\t\t\t\t}\n\t\t\t\t\ttemp.days++;\n\t\t\t\t\tbug_s.push(temp);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tbug_m[b.body]++;\n\t\t}\n\n\t\tif(res != -1){\n\t\t\tstd::cout << res << std::endl;\n\t\t}else{\n\t\t\tstd::cout << \"NA\\n\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef long long int ll;\n\nll tr(string a);\nbool cl(string a);\nint c3(ll a);\nint solve(string st);\n\nint main()\n{\n    string input;\n    cin >> input;\n    while (input[0] != '0') {\n        int ans = solve(input);\n        if (ans != INF) {\n            cout << ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n        cin >> input;\n    }\n    return 0;\n}\n\nint solve(string st)\n{\n    int ans = 0;\n    vector<bool> check(1048576, false);\n    queue<string> a, b, c;\n    if ( cl(st) ) {\n        return ans;\n    }\n    a.push(st);\n    while (!a.empty()) {\n        while (!a.empty()) {\n            st = a.front();\n            a.pop();\n            if (check[c3(tr(st))]) {\n                continue;\n            } else {\n                check[c3(tr(st))] = true;\n                //cout << c3(tr(st)) << endl;\n            }\n            if (cl(st)) {\n                return ans;\n            }\n            for (int i = 1; i < st.size(); i++) {\n                if (st[i-1] != st[i]) {\n                    string nw(st);\n                    if (st[i-1] != 'r' && st[i] != 'r') {\n                        nw[i-1] = 'r';\n                        nw[i] = 'r';\n                    } else if (st[i-1] != 'g' && st[i] != 'g') {\n                        nw[i-1] = 'g';\n                        nw[i] = 'g';\n                    } else if (st[i-1] != 'b' && st[i] != 'b') {\n                        nw[i-1] = 'b';\n                        nw[i] = 'b';\n                    }\n                    b.push(nw);\n                }\n            }\n        }\n        a = b;\n        b = c;\n        ans++;\n    }\n    return INF;\n}\n\nll tr(string a)\n{\n    ll ret = 0;\n    for (int i = 0; i < a.size(); i++) {\n        ret *= 10;\n        if (a[i] == 'r') {\n            ret += 1;\n        } else if (a[i] == 'g') {\n            ret += 2;\n        } else {\n            ret += 3;\n        }\n    }\n    return ret;\n}\n\nbool cl(string a)\n{\n    for (int i = 1; i < a.size(); i++) {\n        if (a[i-1] != a[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint c3(ll a)\n{\n    int ret = 0;\n    if (a) {\n        ret = c3(a / 10);\n        ret *= 4;\n        ret += a % 10;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct Data{string s;int n;};\nint main()\n{\n  map<int,int> change;\n  change['r'+'g']='b';\n  change['g'+'b']='r';\n  change['b'+'r']='g';\n  map<string,int> changed;\n  queue<Data> q;\n  string s;\n  Data d;\n  int i,n;\n  bool flag;\n  int t=0;\n  while(cin>>s,s!=\"0\"){\n    changed.clear();\n    while(!q.empty())q.pop();\n    d.s=s;\n    d.n=0;\n    q.push(d);\n    changed[d.s]=1;\n    while(!q.empty()){\n      d=q.front();\n      s=d.s;\n      n=d.n;\n      q.pop();\n      flag=true;\n      for(i=1;i<s.size();i++){\n\tif(s[i-1]==s[i])continue;\n\tflag=false;\n\td.s=s;\n\td.s[i-1]=d.s[i]=change[d.s[i-1]+d.s[i]];\n\td.n=n+1;\n\tif(changed.find(d.s)!=changed.end())continue;\n\tchanged[d.s]=1;\n\tq.push(d);\n      }\n      if(flag)break;\n    }\n    if(flag)cout<<n<<endl;\n    else puts(\"NA\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\nusing namespace std;\ntypedef pair<string,int> P;\nint main(){\n\tmap<string,int> mp;\n\tstring s,arr,mo;\n\tint now;\n\tchar c;\n\twhile(cin>>s,s[0]!='0'){\n\t\tqueue<P> que;\n\t\tque.push(P(s,0));\n\t\twhile(!que.empty()){\n\t\t\tP pre=que.front();\n\t\t\tque.pop();\n\t\t\tnow=pre.second;\n\t\t\tarr=pre.first;\n\t\t\tif(mp[arr]==1)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tmp[arr]=1;\n\t\t\tint j;\n\t\t\tfor(j=1;j<(int)arr.size();j++)\n\t\t\t\tif(arr[j-1]!=arr[j])\n\t\t\t\t\tbreak;\n\t\t\tif(j==(int)arr.size()){\n\t\t\t\tcout<<now<<endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tfor(int i=1;i<(int)arr.size();i++){\n\t\t\t\tmo=arr;\n\t\t\t\tif(arr[i-1]!=arr[i]){\n\t\t\t\t\tif((arr[i-1]=='b'&&arr[i]=='g')||(arr[i-1]=='g'&&arr[i]=='b'))\n\t\t\t\t\t\tc='r';\n\t\t\t\t\telse if((arr[i-1]=='r'&&arr[i]=='g')||(arr[i-1]=='g'&&arr[i]=='r'))\n\t\t\t\t\t\tc='b';\n\t\t\t\t\telse c='g';\n\t\t\t\t\tmo[i-1]=c;\n\t\t\t\t\tmo[i]=c;\n\t\t\t\t\tque.push(P(mo,now+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"NA\"<<endl;\n\t\tend:\n\t\tmp.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nqueue <pair<string,int> > worm;\nmap <string,int> M;\nint s1,n;\nstring str,strrr,sample[3]={\"gggggggggg\",\"bbbbbbbbbb\",\"rrrrrrrrrr\"},worms[3];\nbool flag=false;\n\nint main(){\n    while(1){\n        cin >> str;\n        if(str==\"0\")break;\n            s1=str.size();\n            for(int i=0;i<3;i++)worms[i]=sample[i].substr(0,s1);\n            worm.push(make_pair(str,0));\n\n\n        while(!worm.empty()){\n            str=worm.front().first;\n            n=worm.front().second;\n            worm.pop();\n            if(M[str]>0);\n            else{\n            //cout << n << endl;\n            if(s1*2<n)break;\n            M[str]++;\n            if(str==worms[0]||str==worms[1]||str==worms[2]){\n                    flag=true;\n                cout  << n << endl;\n                while(!worm.empty())worm.pop();\n                break;\n            }else{\n                for(int i=1;i<s1;i++){\n                    if(str[i]!=str[i-1]){\n                        if(str[i]!='r'&&str[i-1]!='r'){\n                            strrr=str;\n                            str[i]='r',str[i-1]='r';\n                            worm.push(make_pair(str,n+1));\n                            str=strrr;\n                        }\n                        if(str[i]!='b'&&str[i-1]!='b'){\n                            strrr=str;\n                            str[i]='b',str[i-1]='b';\n                            worm.push(make_pair(str,n+1));\n                            str=strrr;\n                        }\n                        if(str[i]!='g'&&str[i-1]!='g'){\n                            strrr=str;\n                            str[i]='g',str[i-1]='g';\n                            worm.push(make_pair(str,n+1));\n                            str=strrr;\n                        }\n                    }\n                }\n\n            }\n        }\n\n    //end:\n    }\n\n        if(flag==false)cout << \"NA\" << endl;\n        flag=false;\n        while(!worm.empty())worm.pop();\n        n=0;\n        M.clear();\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\nclass S{\npublic:\n  string s;\n  int n;\n  S(string s,int n):s(s),n(n){}\n};\n\nint main(){\n  while(1){\n    string a;\n    cin>>a;\n    if(a==\"0\")break;\n\n    queue<S> que;\n    map<string,int> memo;\n    char cc[111][111];\n    rep(i,111)rep(j,111)cc[i][j]=-1;\n    que.push(S(a,0));\n    int ans=0;\n    int kn=0;\n    while(1){\n      if(que.empty()==1){\n\tbreak;\n      }\n      S u = que.front();\n      que.pop();\n      ans=u.n;\n      //cout<<u.s<<\" \"<<u.n<<endl;\n      if(memo[u.s]!=0){\n\tcontinue;\n      }\n      memo[u.s]=1;\n      int comp=1;\n      int ch=u.s[0];\n      reps(i,u.s.size()-1){\n\tif(ch!=u.s[i]){\n\t  comp=0;\n\t  break;\n\t}\n      }\n      if(comp==1){\n\tkn=1;\n\tbreak;\n      }\n      cc['r']['g']=cc['g']['r']='b';\n      cc['r']['b']=cc['b']['r']='g';\n      cc['b']['g']=cc['g']['b']='r';\n      rep(i,u.s.size()-1){\n\tstring cop=u.s;\n\tif(u.s[i]!=u.s[i+1]){\n\t  cop[i]=cop[i+1]=cc[cop[i]][cop[i+1]];\n\t  que.push(S(cop,u.n+1));\n\t}\n      }\n    }\n    if(kn==1){\n      printf(\"%d\\n\",ans);\n    }else{\n      printf(\"NA\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef pair<string,int> P;\ntypedef map<string,int> M;\n\nint dfs(string str) {\n     queue<P> s;\n     s.push(P(str,0));\n     int res = -1;\n     M m;\n\n     while (s.size()) {\n\t  P p = s.front(); s.pop();\n\t  str = p.first;\n\t  if (m[str]) continue;\n\t  int num = p.second;\n\t  m[str] = num;\n\t  bool f = true;\n\t  int count = 0;\n\t  for (int i = 0; i < str.size() - 1; i++) {\n\t       string tmp = str;\n\t       bool flag = false;\n\t       if (tmp[i] != tmp[i + 1]) {\n\t\t    flag = true;\n\t\t    f = false;\n\t\t    count++;\n\t\t    if (tmp[i] != 'b' && tmp[i + 1] != 'b')\n\t\t\t tmp[i + 1] = tmp[i] = 'b';\n\t\t    else if (tmp[i] != 'r' && tmp[i + 1] != 'r')\n\t\t\t tmp[i + 1] = tmp[i] = 'r';\n\t\t    else if (tmp[i] != 'g' && tmp[i + 1] != 'g')\n\t\t\t tmp[i + 1] = tmp[i] = 'g';\n\t\t    if (tmp == str) flag = false;\n\t       }\n\t       if (flag) s.push(P(tmp, num + 1));\n\t  }\n\t  if (f) {\n\t       res = num;\n\t       break;\n\t  }\n\n     }\n\n     return res;\n}\n\nint main()\n{\n     string str;\n     while (cin >> str) {\n\t  if (str == \"0\") break;\n\t  int res = dfs(str);\n\t  if (res < 0) cout << \"NA\" << endl;\n\t  else cout << res << endl;\n     }\n\n\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint ans;\nconst int MAX_COUNT = 1000;\nchar color[3] = {'r', 'g', 'b'};\nset<string> mSet;\n\ntypedef pair<string, int> PSI;\n\nbool solve(string str)\n{\n\tqueue<PSI> que;\n\tque.push(PSI(str, 0));\n\t\n\twhile(!que.empty())\n\t{\n\t\tPSI current = que.front();\n\t\tque.pop();\n\n\t\tbool is_solved = true;\n\t\tfor(int i=0; i<current.first.size()-1; i++)\n\t\t{\n\t\t\tif(current.first[i] != current.first[i+1])\n\t\t\t{\n\t\t\t\tis_solved = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(is_solved)\n\t\t{\n\t\t\tans = current.second;\n\t\t\treturn true;\n\t\t}\n\n\t\tif(mSet.find(current.first) == mSet.end())\n\t\t{\n\t\t\tmSet.insert(current.first);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n \t\tfor(int i=0; i<current.first.size()-1; i++)\n\t\t{\n\t\t\tif(current.first[i] != current.first[i+1])\n\t\t\t{\n\t\t\t\tfor(int k=0; k<3; k++)\n\t\t   \t\t{\n\t   \t\t\t\tif(current.first[i] != color[k] && current.first[i+1] != color[k])\n   \t\t\t\t\t{\n\t\t\t\t   \t\tstring new_str = string(current.first.begin(), current.first.end());\n\t\t\t   \t\t\tnew_str[i] = color[k];\n\t\t  \t\t\t\tnew_str[i+1] = color[k];\n\t\t\t\t\t\tque.push(PSI(new_str, current.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tstring str;\n\twhile( 1 )\n\t{\n\t\tcin >> str;\n\t\tif(str == \"0\") break;\n\n\t\tans = MAX_COUNT;\n\t\tmSet.clear();\n\n\t\tif(!solve(str))\n\t\t{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nstring input;\nset<string> checked;\nqueue<P> que;\n\nbool check_all_same(string s)\n{\n\tchar color = s[0];\n\tfor (int i=1; i<s.length(); i++)\n\t{\n\t\tif (color != s[i]) return false;\n\t}\n\treturn true;\n}\n\nchar get_other(char a, char b)\n{\n\t//             r     g     b\n\tbool arr[3] = {true, true, true};\n\tif (a == 'r') arr[0] = false;\n\tif (a == 'g') arr[1] = false;\n\tif (a == 'b') arr[2] = false;\n\tif (b == 'r') arr[0] = false;\n\tif (b == 'g') arr[1] = false;\n\tif (b == 'b') arr[2] = false;\n\trep(i,3)\n\t{\n\t\tif (arr[i])\n\t\t{\n\t\t\tif (i == 0) return 'r';\n\t\t\telse if (i == 1) return 'g';\n\t\t\telse return 'b';\n\t\t}\n\t}\n}\n\nvector<string> get_next_str(string in)\n{\n\tvector<string> ret;\n\n\tfor (int i=0; i<in.length()-1; i++)\n\t{\n\t\tif (in[i] != in[i + 1])\n\t\t{\n\t\t\tstring next(in);\n\t\t\tchar new_char = get_other(in[i], in[i + 1]);\n\t\t\tnext[i] = new_char;\n\t\t\tnext[i + 1] = new_char;\n\n\t\t\tret.push_back(next);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main()\n{\n\t/*\n\tvector<string> nexts = get_next_str(\"rbgrg\");\n\tfor (int i=0; i<nexts.size(); i++)\n\t{\n\t\tcout << nexts[i] << endl;\n\t}\n\t*/\n\n\twhile (true)\n\t{\n\t\tcin >> input;\n\t\tif (input == \"0\") break;\n\n\t\tchecked.clear();\n\t\tchecked.insert(input);\n\n\t\tqueue<P> empty;\n\t\tswap(que, empty);\n\t\tque.push(P(input, 0));\n\n\t\tbool find = false;\n\n\t\twhile (que.size())\n\t\t{\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif (check_all_same(p.first))\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", p.second);\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<string> nexts = get_next_str(p.first);\n\t\t\trep(i,nexts.size())\n\t\t\t{\n\t\t\t\tif (checked.find(nexts[i]) == checked.end())\n\t\t\t\t{\n\t\t\t\t\tque.push(P(nexts[i], p.second + 1));\n\t\t\t\t\tchecked.insert(nexts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!find) printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    string color = \"rgb\";\n\n    for(;;){\n        string s;\n        cin >> s;\n        if(s == \"0\")\n            return 0;\n        int n = s.size();\n\n        set<string> worm;\n        queue<pair<string, int> > q;\n        worm.insert(s);\n        q.push(make_pair(s, 0));\n        int ok = false;\n        while(!q.empty()){\n            s = q.front().first;\n            int k = q.front().second;\n            q.pop();\n\n            ok = true;\n            for(int i=1; i<n; ++i){\n                if(s[i] != s[i-1]){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                cout << k << endl;\n                break;\n            }\n\n            for(int i=1; i<n; ++i){\n                if(s[i] == s[i-1])\n                    continue;\n                for(int j=0; j<3; ++j){\n                    if(s[i] != color[j] && s[i-1] != color[j]){\n                        string s1 = s;\n                        s1[i] = s1[i-1] = color[j];\n                        if(worm.find(s1) == worm.end()){\n                            worm.insert(s1);\n                            q.push(make_pair(s1, k+1));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!ok)\n            cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// clear time: 01:55\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<string, int> bug;\ntypedef map<string, int> closeMap;\n\nint isOK(string str) {\n    // cout << \"str:\" << str << \" \" << str.size() << endl;\n    for ( int i = 0; i < str.size(); i++ ) {\n        if ( str[0] != str[i] ) return 0;\n    }\n    return 1;\n}\n\nchar cc(char a, char b) {\n    // 並び替え\n    if ( b < a ) {\n        char tmp = a;\n        a = b;\n        b = tmp;\n    }\n\n    if ( a == 'b' && b == 'g' ) {\n        return 'r';\n    } else if ( a == 'b' && b == 'r' ) {\n        return 'g';\n    } else {\n        return 'b';\n    }\n}\n\nvoid wfs(string str) {\n    int cnt = -1;\n    string first = str;\n    queue<bug> open;\n    closeMap close;\n\n    // 初期状態をプッシュ\n    open.push( make_pair(str, 0) );\n\n    close.insert( closeMap::value_type(str, 1) );\n    // cout << str << \" key:\" << close[str] << endl;\n\n    while(!open.empty()) {\n        bug b = open.front(); open.pop();\n        string cs = b.first;\n\n        if ( isOK(cs) ) {\n            cnt = b.second;\n            break;\n        }\n\n        int c = 0;\n        for ( int i = 1; i < cs.size(); i++ ) {\n            if ( cs[i-1] != cs[i] ) {\n                string tmp = cs;\n                char nc = cc(cs[i-1], cs[i]);\n                tmp[i-1] = nc;\n                tmp[i] = nc;\n\n                if ( close[tmp] )continue;\n                open.push( make_pair(tmp, b.second+1) );\n                close[tmp] = 1;\n                c++;\n            }\n        }\n    }\n\n    if ( cnt == -1 ) {\n        cout << \"NA\" << endl;\n    } else {\n        cout << cnt << endl;\n    }\n\n\n}\n\nint main() {\n    string n;\n\n    while ( cin >> n, n != \"0\" ) {\n        wfs(n);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<set>\n#define psi pair<string, int>\n\nusing namespace std;\n\nbool check(string str){\n    return (str[0]!=str[1]);\n}\n\nbool same(string str){\n    for(int i=0; i<str.size(); i++){\n        if(str[0]!=str[i]) return false;\n    }\n    return true;\n}\n\nchar getColor(string str){\n    char c1=min(str[0], str[1]);\n    char c2=max(str[0], str[1]);\n    if(c1=='b'&&c2=='g') return 'r';\n    if(c1=='b'&&c2=='r') return 'g';\n    if(c1=='g'&&c2=='r') return 'b';\n}\nint solve(string str){\n    queue<psi> qu;\n    qu.push(psi(str, 0));\n    set<string> done;\n\n    while(!qu.empty()){\n        psi w=qu.front(); qu.pop();\n        string s=w.first;\n        done.insert(s);\n\n        if(same(s)){\n            return w.second;\n        }\n\n        for(int i=0; i<s.size()-1; i++){\n            if(check(s.substr(i, 2))){\n                char new_color=getColor(s.substr(i, 2));\n                string nx=s;\n                nx[i+1]=nx[i]=new_color;\n                if(done.count(nx)==1) continue;\n                //cout<< nx<< endl;\n                qu.push(psi(nx, w.second+1));\n                done.insert(nx);\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n\n    while(1){\n        string s;\n        cin>> s;\n        if(s==\"0\") break;\n\n        int ans=solve(s);\n        if(ans==-1){\n            cout<< \"NA\"<< endl;\n        }else{\n            cout<< ans<< endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef pair<string, int> P;\n/** Problem0179 : Mysterious Worm **/\nint bfs(string in)\n{\n\tqueue<P> Q;\n\tmap<string, int> d;\n\t\n\tQ.push(P(in, 0));\n\t\n\twhile (Q.size()) {\n\t\tP p = Q.front(); Q.pop();\n\t\tstring s = p.first;\n\t\t\n\t\tif (d[s]) continue;\n\t\t\n\t\tbool flag=true;\n\t\trep(i, s.length()-1) {\n\t\t\tif (s[i] != s[i+1]) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t\treturn p.second;\n\t\t\n\t\td[s] = 1;\n\t\t\n\t\trep(i, s.length()-1) {\n\t\t\tstring ns = s;\n\t\t\tif (s[i] != s[i+1]) {\n\t\t\t\tchar c1 = s[i], c2 = s[i+1], nc;\n\t\t\t\tif (c1 != 'r' && c2 != 'r')\n\t\t\t\t\tnc = 'r';\n\t\t\t\telse if (c1 != 'g' && c2 != 'g')\n\t\t\t\t\tnc = 'g';\n\t\t\t\telse if (c1 != 'b' && c2 != 'b')\n\t\t\t\t\tnc = 'b';\n\t\t\t\t\n\t\t\t\tns[i]=nc;\n\t\t\t\tns[i+1]=nc;\n\t\t\t\t\n\t\t\t\tQ.push(P(ns, p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tstring s;\n\tint ans;\n\twhile (cin>>s, s!=\"0\") {\n\t\tans = bfs(s);\n\t\tif (ans >= 0)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nint n;\nint mp[1<<20];\n\nint tohash(string &s){\n\tint a = 0;\n\tFOR(i,n){\n\t\ta *= 4;\n\t\tif(s[i] == 'r') a += 1;\n\t\telse if(s[i] == 'g') a += 2;\n\t\telse a += 3;\n\t}\n\treturn a;\n}\n\nint decodeC(int hash,int i){\n\treturn (hash >> (2*i)) & 3;\n}\n\nbool OK(int hash){\n\tint c = decodeC(hash,0);\n\tfor(int i = 1; i < n; i++)\n\t\tif(decodeC(hash,i) != c) return false;\n\treturn true;\n}\n\nvoid setC(int& hash,int i,int v){\n\thash = (hash & ~(3 << (2*i))) | (v << (2*i));\n}\n\ntypedef pair<int,int> P;\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tn = sz(s);\n\t\tmemset(mp,0x7F,sizeof(mp));\n\t\tmp[tohash(s)] = 0;\n\n\t\tint ans = -1;\n\n\t\tpriority_queue<P,vector<P>,greater<P> > q;\n\t\tq.push(P(0,tohash(s)));\n\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(mp[v] < p.first) continue;\n\n\t\t\tif(OK(v)){\n\t\t\t\tans = p.first;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tint hash = p.second;\n\t\t\t\tint c = decodeC(hash , i) ^ decodeC(hash, i + 1);\n\t\t\t\tif(c == 0) continue;\n\t\t\t\tsetC(hash,i,c);\n\t\t\t\tsetC(hash,i+1,c);\n\t\t\t\tif(mp[hash] > p.first + 1){\n\t\t\t\t\tmp[hash] = p.first + 1;\n\t\t\t\t\tq.push(P(p.first + 1,hash));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1) puts(\"NA\");\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n\nchar change_color (char c1, char c2 )\n{\n\tmap<char, bool> used_color;\n\tused_color['r'] = false;\n\tused_color['g'] = false;\n\tused_color['b'] = false;\n\n\tused_color[c1] = true;\n\tused_color[c2] = true;\n\n\tmap<char, bool>::iterator it = used_color.begin();\n\tfor (; it != used_color.end(); ++it){\n\t\tif ( (*it).second == false ){\n\t\t\treturn (*it).first;\n\t\t} // end if\n\t} // end for\n} \nbool same_color (string s )\n{\n\tint len = s.length();\n\tint n = (int)count (s.begin(), s.end(), s[0] );\n\n\tif (n == len ){\n\t\treturn true;\n\t} // end if\n\n\treturn false;\n}\t\n\t\n\nint bfs (string str )\n{\n\tint len = str.length();\n\tint i;\n\n\tqueue <string> Q;\n\tstring s = str;\n\tQ.push (s );\n\tset <string> S;\n\tmultimap <string, string> D;\n\n\twhile (!Q.empty() ){\n\t\ts = Q.front(); Q.pop();\n//\t\tcout << s << endl;\n\t\tif (same_color (s ) ){\n\t\t\tbreak;\n\t\t} // end if\n\n\t\tmap<int, int> change_part;\n\n\t\tfor (i = 0; i < len - 1; ++i){\n\t\t\tif (s[i] != s[i+1] ){\n\t\t\t\tchange_part[i] = i+1;\n\t\t\t} // end if\n\t\t} // end for\n\t\t\n\t\tif (!change_part.empty() ){\n\t\t\tmap<int, int>::iterator it = change_part.begin();\n\t\t\tfor (; it != change_part.end(); ++it){\n\t\t\t\tstring t = s;\n\t\t\t\tt[(*it).first] = change_color (s[(*it).first], s[(*it).second] );\n\t\t\t\tt[(*it).second] = change_color (s[(*it).first], s[(*it).second] );\n\t\t\t\tif (!S.count (t ) ){\n\t\t\t\t\tS.insert (t );\n\t\t\t\t\tQ.push (t );\n\t\t\t\t\tD.insert ( make_pair (t, s ) );\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end if\n\t} // end while\n\n\tif (Q.empty() && !same_color (s ) ){\n\t\treturn -1;\n\t} // end if\n\n\tint res = 0;\n\tif (!D.empty() ){\n\t\t++res;\n\t\tmultimap <string, string>::iterator it = D.begin();\n\t\tfor (; it != D.end(); ++it){\n\t\t\tif ((*it).first == s ){\n\t\t\t\t break;\n\t\t\t} // end if\n\t\t} // end for\n\t\tstring from = (*it).second;\n\t\twhile (from != str ){\n\t\t\tfor (it = D.begin(); it != D.end(); ++it){\n\t\t\t\tif ( (*it).first == from ){\n\t\t\t\t\tfrom = (*it).second;\n\t\t\t\t\t++res;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end while\n\t} // end if\n\n\treturn res;\t\n}\t\t\t\t\t\t\t \n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.Mworm\", \"r\", stdin );\n\tstring str = \"\";\n\tint n;\n\n\twhile (getline (cin, str ) ){\n\t\tint len = str.length();\n\t\tif (len == 1 && str[0] == '0'){\n\t\t\tbreak;\n\t\t} // end if\n\t\tint i;\n\t\tint res = 0;\n\t\t\n\t\tres = bfs (str );\n\t\tif (res == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\t\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<string>\n#include<set>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool ck(string &s){\n\trep(k,s.size()-1)if(s[k]!=s[k+1])return 0;\n\treturn 1;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tint step=0; bool sc=ck(s);\n\t\tvector<string> frontier,next;\n\t\tfrontier.push_back(s);\n\t\tset<string> visited; visited.insert(s);\n\t\tfor(bool cg=1;cg&&!sc;step++){\n\t\t\tcg=0; next.clear();\n\t\t\trep(i,frontier.size()){\n\t\t\t\trep(j,frontier[i].size()-1){\n\t\t\t\t\tchar c,cc=frontier[i][j],cn=frontier[i][j+1];\n\t\t\t\t\tif(cc==cn)continue;\n\t\t\t\t\tif(cc>cn)swap(cc,cn);\n\t\t\t\t\tif(cc=='b')c=cn=='g'?'r':'g';\n\t\t\t\t\telse c='b';\n\t\t\t\t\t\n\t\t\t\t\tstring nx=frontier[i];\n\t\t\t\t\tnx[j]=nx[j+1]=c;\n\t\t\t\t\tif(visited.find(nx)==visited.end()){\n\t\t\t\t\t\tcg=1;\n\t\t\t\t\t\tsc=sc||ck(nx);\n\t\t\t\t\t\tnext.push_back(nx),visited.insert(nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfrontier=next;\n\t\t}\n\t\tif(sc)cout<<step<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nstatic int\nvalidate (\n  const char * s\n  )\n{\n  while ( *( ++s ) != '\\0' )\n  {\n    if ( s[ -1 ] != s[ 0 ] )  return ( 0 );\n  }\n\n  return ( 1 );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    typedef pair<string,int> Point;\n    queue<Point> lis;\n    set<string> h;\n    char si[ 11 ];\n\n    scanf ( \" %s\", si );\n    if ( *si == '0' ) break ;\n\n    lis.push ( make_pair ( si, 0 ) );\n    h.insert ( si );\n    while ( !lis.empty ( ) )\n    {\n      const Point s = lis.front ( );\n      lis.pop ( );\n\n      if ( validate ( s.first.c_str ( ) ) )\n      {\n        printf ( \"%d\\n\", s.second );\n        goto ESC;\n      }\n\n      for ( i = 1; i < s.first.size ( ); ++i )\n      {\n        if ( s.first[ i - 1 ] != s.first[ i ] )\n        {\n          string g = s.first;\n\n          if ( ( g[ i - 1 ] == 'r' && g[ i ] == 'g' )\n            || ( g[ i - 1 ] == 'g' && g[ i ] == 'r' ) )\n          {\n            g.replace ( i - 1, 2, \"bb\" );\n          }\n          if ( ( g[ i - 1 ] == 'g' && g[ i ] == 'b' )\n            || ( g[ i - 1 ] == 'b' && g[ i ] == 'g' ) )\n          {\n            g.replace ( i - 1, 2, \"rr\" );\n          }\n          if ( ( g[ i - 1 ] == 'b' && g[ i ] == 'r' )\n            || ( g[ i - 1 ] == 'r' && g[ i ] == 'b' ) )\n          {\n            g.replace ( i - 1, 2, \"gg\" );\n          }\n\n          if ( h.find ( g ) == h.end ( ) )\n          {\n            lis.push ( make_pair ( g, s.second + 1 ) );\n            h.insert ( g );\n          }\n        }\n      }\n    }\n    puts ( \"NA\" );\n\nESC: ;\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nint main()\n{\n    map<string, int> worm;\n    queue<string> que;\n    string chars = \"rgb\";\n    REP(i, 2, 11){\n        for (char c : chars) {\n            worm[string(i,c)] = 0;\n            que.push(string(i,c));\n            while (!que.empty()) {\n                string s = que.front(); que.pop();\n                rep(j, s.length()-1){\n                    if (s[j] != s[j+1])\n                        continue;\n                    rep(k, 3){\n                        if (s[j] == chars[k]) {\n                            REP(l, k+1, k+3){\n                                REP(m, k+1, k+3){\n                                    if (l != m) {\n                                        string p = s;\n                                        p[j] = chars[l%3];\n                                        p[j+1] = chars[m%3];\n                                        if(!EXIST(worm, p)){\n                                            que.push(p);\n                                            worm[p] = worm[s] + 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    string input;\n    while (cin >> input, input != \"0\") {\n        if (EXIST(worm, input))\n            cout << worm[input] << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<queue>\n#include<unordered_map>\n#include<map>\n#define P pair<string,int>\n#define p pair<char,char>\nusing namespace std;\n\nint main()\n{\n\tmap<p, char>M;\n\tM[p('b', 'g')] = 'r';\n\tM[p('g', 'b')] = 'r';\n\tM[p('b', 'r')] = 'g';\n\tM[p('r', 'b')] = 'g';\n\tM[p('r', 'g')] = 'b';\n\tM[p('g', 'r')] = 'b';\n\tstring a;\n    l:;\n\twhile (cin >> a, a != \"0\") {\n\t\tunordered_map<string, int>U;\n\t\tqueue<P>Q;\n\t\tQ.push(P(a, 1));\n\t\twhile (Q.size()) {\n\t\t\tP c = Q.front(); Q.pop();\n\t\t\tbool d = true;\n\t\t\tfor (int e = 1; e < c.first.length(); e++)if (c.first[e - 1] != c.first[e])d = false;\n\t\t\tif (d) { cout << c.second - 1 << endl; goto l; }\n\t\t\tfor (int e = 1; e < c.first.length(); e++) {\n\t\t\t\tif (c.first[e - 1] != c.first[e]) {\n\t\t\t\t\tstring copy = c.first;\n\t\t\t\t\tcopy[e - 1] = copy[e] = M[p(c.first[e - 1], c.first[e])];\n\t\t\t\t\tif (U[copy] == 0) { U[copy] = c.second + 1; Q.push(P(copy,U[copy])); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct data{\n\tstring str;\n\tint cnt;\n\tdata(){}\n\tdata(string str,int cnt):str(str),cnt(cnt){}\n};\nstring func(string str,int i) {\n\tint r,g,b;\n\tchar change;\n\tif(str[i] == 'r') {\n\t\tif(str[i+1] == 'g') change='b';\n\t\telse if(str[i+1] == 'b') change = 'g';\n\t\telse return str;\n\t}\n\telse if(str[i] == 'g') {\n\t\tif(str[i+1] == 'r') change='b';\n\t\telse if(str[i+1] == 'b') change = 'r';\n\t\telse return str;\n\t}\n\telse {\n\t\tif(str[i+1] == 'g') change = 'r';\n\t\telse if(str[i+1] == 'r') change = 'g';\n\t\telse return str;\n\t}\n\tstr[i] = change;\n\tstr[i+1] = change;\n\treturn str;\n}\nbool check(string str) {\n\tchar c = str[0];\n\tfor(int i = 0; i < str.size(); i++) {\n\t\tif(str[i] != c) return false;\n\t}\n\treturn true;\n}\nmap<string,int> memo;\nint main() {\n\tstring str;\n\twhile(1) {\n\t\tcin >> str;\n\t\tif(str == \"0\") break;\n\t\tint ans = -1;\n\t\tqueue<data> Q;\n\t\tQ.push(data(str,0));\n\t\twhile(!Q.empty()) {\n\t\t\tdata d = Q.front();Q.pop();\n\t\t\tif(memo.find(d.str) != memo.end()) continue;\n\t\t\tmemo[d.str] = d.cnt;\n\t\t\tif(check(d.str)) {\n\t\t\t\tans = d.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < d.str.size() - 1; i++) {\n\t\t\t\tstring nstr = func(d.str,i);\n\t\t\t\tif(nstr == d.str) continue;\n\t\t\t\tQ.push(data(nstr,d.cnt+1));\n\t\t\t}\n\t\t}\n\t\tif(ans == -1) puts(\"NA\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <deque>\n#include <string>\n\nusing namespace std;\n\nint main(void){\n\tstring str;\n\t\n\twhile(cin >> str && str != \"0\"){\n\t\tint ret = -1;\n\t\tmap<string,bool> m;\n\t\tdeque<pair<string,int> > q;\n\t\tstring curstr,tmpstr;\n\t\tint curtime;\n\t\t\n\t\tq.push_back(make_pair(str,0));\n\t\tm[str] = true;\n\t\twhile(!q.empty()){\n\t\t\tcurstr = q.front().first;\n\t\t\tcurtime = q.front().second;\n\t\t\tq.pop_front();\n\t\t\t\n\t\t\t//cout << curstr << endl;\n\t\t\t\n\t\t\tbool isended = true;\n\t\t\t\n\t\t\tfor(int i=0;i<curstr.size()-1;i++){\n\t\t\t\tif(curstr[i] != curstr[i+1]) isended = false;\n\t\t\t}\n\t\t\t\n\t\t\tif(isended){\n\t\t\t\tret = curtime;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ttmpstr = curstr;\n\t\t\t\n\t\t\tfor(int i=0;i<curstr.size()-1;i++){\n\t\t\t\tif((tmpstr[i] == 'b' && tmpstr[i+1] == 'g') ||\n\t\t\t\t(tmpstr[i] == 'g' && tmpstr[i+1] == 'b')){\n\t\t\t\t\ttmpstr[i] = 'r'; tmpstr[i+1] = 'r';\n\t\t\t\t\t//cout << tmpstr << endl;\n\t\t\t\t\tif(m[tmpstr] == false){\n\t\t\t\t\t\tm[tmpstr] = true;\n\t\t\t\t\t\tq.push_back(make_pair(tmpstr, curtime+1));\n\t\t\t\t\t}\n\t\t\t\t\ttmpstr = curstr;\n\t\t\t\t}else if((tmpstr[i] == 'r' && tmpstr[i+1] == 'g') ||\n\t\t\t\t(tmpstr[i] == 'g' && tmpstr[i+1] == 'r')){\n\t\t\t\t\ttmpstr[i] = 'b'; tmpstr[i+1] = 'b';\n\t\t\t\t\tif(m[tmpstr] == false){\n\t\t\t\t\t\tm[tmpstr] = true;\n\t\t\t\t\t\tq.push_back(make_pair(tmpstr, curtime+1));\n\t\t\t\t\t}\n\t\t\t\t\ttmpstr = curstr;\n\t\t\t\t}else if((tmpstr[i] == 'b' && tmpstr[i+1] == 'r') ||\n\t\t\t\t(tmpstr[i] == 'r' && tmpstr[i+1] == 'b')){\n\t\t\t\t\ttmpstr[i] = 'g'; tmpstr[i+1] = 'g';\n\t\t\t\t\tif(m[tmpstr] == false){\n\t\t\t\t\t\tm[tmpstr] = true;\n\t\t\t\t\t\tq.push_back(make_pair(tmpstr, curtime+1));\n\t\t\t\t\t}\n\t\t\t\t\ttmpstr = curstr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;struct D{string s;int n;};main(){map<int,int>C;string s;int i,n,F;for(C[217]=98,C[201]='r',C[212]='g';cin>>s,s!=\"0\";F?puts(\"NA\"):printf(\"%d\\n\",n)){map<string,int>M;queue<D>q;D d={s,0};q.push(d);for(M[s]=1;q.size();){d=q.front();q.pop();s=d.s;n=d.n;for(i=F=0;++i<s.size();)if(s[i-1]-s[i]){D d={s,n+1};d.s[i-1]=d.s[i]=C[s[i-1]+s[i]];if(M.find(d.s)==M.end())q.push(d);F=M[d.s]=1;}if(!F)break;}}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\nbool OK(string in){\n\tfor(int i = 0;i<in.size();i++){\n\t\tif (in[0] != in[i]) return false;\n\t}\n\treturn true;\n}\n\nchar ch(char a, char b){\n\tif (a != 'r' && b != 'r') return 'r';\n\telse if (a != 'g' && b != 'g') return 'g';\n\telse return 'b';\n}\n\nint main(){\n\tstring in;\n\twhile(cin >> in){\n\t\tif (in == \"0\") break;\n\t\tqueue<string> que;\n\t\tque.push(in);\n\t\tvector<string> check(pow(3, in.size()));\n\t\tint n = 0, N = 0;\n\t\twhile(true){\n\t\t\tint que_size = que.size();\n\t\t\tbool flag = false;\n\t\t\tif(que_size == 0){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0;i<que_size;i++){\n\t\t\t\tstring que_front = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(OK(que_front)){\n\t\t\t\t\tcout << n << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < que_front.size() - 1; j++) {\n\t\t\t\t\tif (que_front[j] == que_front[j + 1]) continue;\n\t\t\t\t\tstring for_push = que_front;\n\t\t\t\t\tfor_push[j] = for_push[j + 1] = ch(que_front[j], que_front[j + 1]);\n\t\t\t\t\tfor (int k = 0; k <= N; k++){\n\t\t\t\t\t\tif (check[k] == for_push) break;\n\t\t\t\t\t\tif(k == N){\n\t\t\t\t\t\t\tN++;\n\t\t\t\t\t\t\tcheck[N] = for_push;\n\t\t\t\t\t\t\tque.push(for_push);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t\tn++;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2013-5\n\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <time.h>\n#define mp make_pair\n#define fs first\n#define sc second\n#define rep(x,n) for(int x = 0;x < n;x ++)\n#define Rep(x,n) for(int x = 1;x <= n;x ++)\nusing namespace std;\n\nchar retcol(char c1,char c2){\n    if((c1 == 'g' && c2== 'r')||(c1 == 'r' && c2== 'g'))\n        return 'b';\n    else if((c1 == 'b' && c2 == 'r')||(c1 == 'r' && c2 == 'b'))\n        return 'g';\n    else\n        return 'r';\n}\n\nint n;\n\nbool issame(string xx){\n    int nu = xx.size();\n    rep(i,nu-1)\n        if(xx[i]!=xx[i+1])\n            return 0;\n    return 1;\n}\n\nint main(){\n\n    bool tf = 0;\n    string str,next;\n    while(cin >> str&&str != \"0\"){\n        queue<string> que;\n        que.push(str);\n        tf = 0;\n        n = str.size();\n        //この時点で判定\n        if(issame(str)){\n            printf(\"0\\n\");\n            continue;\n        }\n        map<string,int> flag;\n        flag.insert(make_pair(str,0));\n        //探索\n        while(!que.empty()&& tf == 0){\n            string str = que.front();\n            que.pop();\n            if(flag.find(str)==flag.end())\n                continue;\n            int num = flag.find(str)->second;\n            rep(i,n-1){\n                if(str[i]!=str[i+1]){\n                    next = str;\n                    next[i]=retcol(str[i],str[i+1]);\n                    next[i+1]=next[i];\n                    if(issame(next)){\n                        tf = 1;\n                        cout << num + 1 << endl;\n                        break;\n                    }\n                    if(flag.find(next)==flag.end()){\n                        que.push(next);\n                        flag.insert(make_pair(next,num+1));\n                    }\n                    \n                }\n            }\n        }\n        if(tf == 0){\n            printf(\"NA\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define NA 10000000\n\nstring str;\n\nchar rgb(char v1, char v2)\n{\n  bool r, g, b;\n  r = v1 == 'r' || v2 == 'r';\n  b = v1 == 'b' || v2 == 'b';\n  g = v1 == 'g' || v2 == 'g';\n  \n  if(!r)\n    return 'r';\n  if(!b)\n    return 'b';\n  return 'g';\n}\nint dfs(string s, bool isFirst, int n)\n{\n  int ans = 10000000;\n  bool isEnd = true;\n\n  //cout << \"s: \"<< s << endl;\n\n  if(n > 10)\n    return NA;\n  if(str == s && !isFirst)\n    return ans;\n  for(int i = 0; i < s.length(); i++)\n    isEnd &= s[0] == s[i];\n  if(isEnd)\n    return n;\n\n  for(int i = 0; i < s.length() - 1; i++)\n  {\n    //cout << i << endl;\n    if(s[i] != s[i + 1])\n    {\n      char c1 = s[i], c2 = s[i + 1];\n      \n      char c = rgb(s[i], s[i + 1]);\n      //cout << c1 << c2;\n      s[i] = s[i + 1] = c;\n      ans = min(ans, dfs(s, false, n + 1));\n      s[i] = c1;\n      s[i + 1] = c2;\n    }\n  }\n\n  return ans;\n}\n\n\nint main()\n{\n  while(1)\n  {\n    cin >> str;\n    if(str[0] == '0')\n      break;\n    int a = dfs(str, true, 0);\n    if(a == NA)\n      cout << \"NA\\n\";\n    else\n      cout << a << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <climits>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\nstring s;\nint qf;\n\nint foo1(int D[]){\n\tint res=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tres*=10;\n\t\tres+=D[i];\n\t}\n\treturn res;\n}\nvoid foo2(int D[],int m){\n\trep(j,s.size()){\n\t\tD[j]=0;\n\t}\n\tfor(int i=s.size()-1;i>=0;--i){\n\t\tD[i]=m%10;\n\t\tm/=10;\n\t\trep(j,s.size()){\n\t\t}\n\t}\n}\n\n\nint a[30];\nint tmp[30];\nset<unsigned int> vis;\n\nbool check(){\n\tint t=a[0];\n\trep(i,s.size()){\n\t\tif(t!=a[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=0;\n\t\tqueue<int> qu;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='r') a[i]=0;\n\t\t\telse if(s[i]=='g') a[i]=1;\n\t\t\telse if(s[i]=='b') a[i]=2;\n\t\t}\n\t\tif(check()){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqu.push(foo1(a));\n\t\tvis.insert(foo1(a));\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\tint c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\tc++;\n\t\t\tif(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\tfoo2(a,qf);\n\t\t\t\tif(check()){\n\t\t\t\t\tcout<<ans-1<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(a[j]!=a[j+1]){\n\t\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\t\ttmp[k]=a[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[j]*a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=0;\n\t\t\t\t\t\t\ttmp[j+1]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(a[j]==2||a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=1;\n\t\t\t\t\t\t\ttmp[j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttmp[j]=2;\n\t\t\t\t\t\t\ttmp[j+1]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(vis.find(foo1(tmp))==vis.end()){\n\t\t\t\t\t\t\tqu.push(foo1(tmp));\n\t\t\t\t\t\t\tvis.insert(foo1(tmp));\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nmap<char, char> rot = {\n    {'r', 'g'}, {'g', 'b'}, {'b', 'r'}\n};\nmap<string, bool> used;\n\nvoid rotate(string &s) {\n    for (int i=0; i<(int)s.size(); ++i) s[i] = rot[s[i]];\n}\n\nint main() {\n    string s;\n    while (cin >> s, s != \"0\") {\n        used.clear();\n        string r = \"\", g = \"\", b = \"\";\n        for (int i=0; i<(int)s.size(); ++i) {\n            r += \"r\"; g += \"g\"; b += \"b\";\n        }\n        queue<pair<string,int> > q;\n        q.push(make_pair(s, 0));\n        int res = -1;\n        while ( ! q.empty()) {\n            string col = q.front().first;\n            used[col] = true; rotate(col);\n            used[col] = true; rotate(col);\n            used[col] = true; rotate(col);\n            int t = q.front().second;\n            if (col == r || col == g || col == b) {\n                res = t;\n                break;\n            }\n            q.pop();\n            for (int i=0; i<(int)col.size()-1; ++i) {\n                if (col[i] != col[i+1]) {\n                    string nxt = col;\n                    if (col[i] != 'r' && col[i+1] != 'r') {\n                        nxt[i] = 'r'; nxt[i+1] = 'r';\n                    } else if (col[i] != 'g' && col[i+1] != 'g') {\n                        nxt[i] = 'g'; nxt[i+1] = 'g';\n                    } else if (col[i] != 'b' && col[i+1] != 'b') {\n                        nxt[i] = 'b'; nxt[i+1] = 'b';\n                    }\n                    if ( ! used[nxt]) {\n                        q.push(make_pair(nxt, t+1));\n                    }\n                }\n            }\n        }\n        if (res < 0) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<string>\n#include<set>\n\n#define R 114\n#define G 103\n#define B 98\n\nusing namespace std;\n\nclass DATA{\n\tpublic:\n\t\tDATA(string temp){\t\t\t//ÌzñÆzñÌ·³ðnµÄ °Ä­¾³¢\n\t\t\tstep = 0;\n\t\t\tarr = temp;\n\t\t}\n\t\t\n\t\tDATA(string temp, int step) :arr(temp), step(step) {}\n\t\t\n\t\t//I¹»èH\n\t\tint check(void){\n\t\t\tchar t = arr[0];\n\t\t\tfor(int i = 0; i < arr.size(); i++){\n\t\t\t\tif(arr[i] != t){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint step;\t\t//Xebv(JÚ)\n\t\tstring arr;\t//rgbÌÀÑ\n};\n\nset<string> table;\n\n//¦\nint ans = -1;\n\nint main()\n{\n\tstring rgb;\n\tstring temp;\n\tint i,j, len;\n\tint temp3;\n\tchar g;\n\t\n\t\n\tfor(;;){\n\t\tcin >> rgb;\n\t\tif(rgb == \"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tlen = rgb.size();\n\t\tans = -1;\n\t\tqueue<DATA> Q;\n\t\t\n\t\tDATA start(rgb,0);\n\t\t\n\t\tQ.push(start);\n\t\twhile(!Q.empty()){\n\t\t\t//`FbN·éf[^ðæèo·\n\t\t\tDATA d = Q.front();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif(table.count(d.arr)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttable.insert(d.arr);\n\t\t\t\n\t\t\t//I¹\n\t\t\tif(d.check() == 1){\n\t\t\t\tans = d.step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//·×ÄÌp^[ÉÎµÄóÔJÚµAL[Éi[\n\t\t\tfor(i = 0; i < len-1; i++){\n\t\t\t\ttemp = d.arr;\n\t\t\t\tif(d.arr[i] != d.arr[i+1]){\n\t\t\t\t\tswitch(d.arr[i]+d.arr[i+1]){\n\t\t\t\t\t\tcase R+B:\n\t\t\t\t\t\t\ttemp[i] = temp[i+1]= G;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase R+G:\n\t\t\t\t\t\t\ttemp[i] = temp[i+1] = B;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase G+B:\n\t\t\t\t\t\t\ttemp[i] = temp[i+1] = R;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tDATA next(temp,d.step+1);\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\t\n\twhile(true){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str[0] == '0'){\n\t\t\tbreak;\n\t\t}\n\t\tmap<string, int> m;\n\t\t\n\t\tqueue<string> que;\n\t\tque.push(str);\n\t\t\n\t\tfor(int loop = 0; loop < 10000000; loop++){\n\t\t\tint N = que.size();\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int poyo = 0; poyo < N; poyo++){\n\t\t\t\tstring s = que.front();\n\t\t\t\t//cout << s << endl;\n\t\t\t\tque.pop();\n\t\t\t\tif(m.find(s) != m.end()){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tm[s] = loop;\n\t\t\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\t\t\tstring ss = s;\n\t\t\t\t\tif(s[i] != s[i + 1]){\n\t\t\t\t\t\tif(s[i] != 'r' && s[i + 1] != 'r'){\n\t\t\t\t\t\t\tss[i] = 'r';\n\t\t\t\t\t\t\tss[i + 1] = 'r';\n\t\t\t\t\t\t}else if(s[i] != 'b' && s[i + 1] != 'b'){\n\t\t\t\t\t\t\tss[i] = 'b';\n\t\t\t\t\t\t\tss[i + 1] = 'b';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tss[i] = 'g';\n\t\t\t\t\t\t\tss[i + 1] = 'g';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tque.push(ss);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 10000000;\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tstr[i] = 'r';\n\t\t}\n\t\tif(m.find(str) != m.end()){\n\t\t\tans = min(ans, m[str]);\n\t\t}\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tstr[i] = 'b';\n\t\t}\n\t\tif(m.find(str) != m.end()){\n\t\t\tans = min(ans, m[str]);\n\t\t}\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tstr[i] = 'g';\n\t\t}\n\t\tif(m.find(str) != m.end()){\n\t\t\tans = min(ans, m[str]);\n\t\t}\n\t\tif(ans == 10000000){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint ar[11], ag[11], ab[11];\nbool checked[59049];\nint p3[11];\nmap<int,int> change = {\n    {0,0}, {1,8}, {2,4}, {3,8}, {4,4}, {5,0}, {6,4}, {7,0}, {8,8}\n};\n\nint conv(string s) {\n    int ret = 0;\n    for (int i=0; i<(int)s.size(); ++i) {\n        ret *= 3;\n        if (s[i] == 'g') ret += 1;\n        if (s[i] == 'b') ret += 2;\n    }\n    return ret;\n}\n\nint main() {\n    p3[0] = 1;\n    for (int i=1; i<=10; ++i) {\n        p3[i] = p3[i-1] * 3;\n    }\n    ar[0] = ag[0] = ab[0] = 0;\n    for (int i=1; i<=10; ++i) {\n        ar[i] = ar[i-1];\n        ag[i] = ag[i-1] * 3 + 1;\n        ab[i] = ab[i-1] * 3 + 2;\n    }\n    string s;\n    while (cin >> s, s != \"0\") {\n        memset(checked, false, sizeof checked);\n        int n = s.size();\n        int first = conv(s);\n        queue<pair<int,int> > q;\n        q.push(make_pair(first, 0));\n        checked[first] = true;\n        int res = -1;\n        while ( ! q.empty()) {\n            int col = q.front().first;\n            int t = q.front().second;\n            q.pop();\n            if (col == ar[n] || col == ag[n] || col == ab[n]) {\n                res = t;\n                break;\n            }\n            for (int i=0; i<n-1; ++i) {\n                int replace = change[(col / p3[i]) % 9];\n                int nx = (col / p3[i+2]) * p3[i+2] + replace * p3[i] + (col % p3[i]);\n                if ( ! checked[nx]) {\n                    q.push(make_pair(nx, t+1));\n                    checked[nx] = true;\n                }\n            }\n        }\n        if (res < 0) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n\ntypedef struct {\n\tchar nood[11];\n\tint time;\n} WORM;\n\nunsigned int makeHash(char nood[])\n{\n\tint i = 0;\n\tunsigned int ret = 0;\n\twhile (nood[i] != -1){\n\t\tret += nood[i];\n\t\tret *= 3;\n\t\ti++;\n\t}\n\t\n\treturn (ret);\n}\n\nint add_worm(list<WORM>* lstWorm, list<unsigned>& lstHash)\n{\n\tWORM add;\n\t\n\tadd.time = lstWorm->front().time + 1;\n\t\n\tint i = 0;\n\twhile (lstWorm->front().nood[i + 1] != -1){\n\t\tif (lstWorm->front().nood[i] != lstWorm->front().nood[i + 1]){\n\t\t\tmemcpy(add.nood, lstWorm->front().nood, 11);\n\t\t\tadd.nood[i] = add.nood[i + 1] = 3 - (lstWorm->front().nood[i] + lstWorm->front().nood[i + 1]);\n\t\t\tif (find(lstHash.begin(), lstHash.end(), makeHash(add.nood)) == lstHash.end()){\n\t\t\t\tlstWorm->push_back(add);\n\t\t\t\tlstHash.push_back(makeHash(add.nood));\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (0);\n}\n\nbool checkNood(char nood[])\n{\n\tint i = 1;\n\tint d = nood[0];\n\tbool ret = true;\n\t\n\twhile (nood[i] != -1){\n\t\tif (d != nood[i]){\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\tlist<unsigned int> lstHash;\n\tlist<WORM> lstWorm;\n\tWORM add;\n\t\n\twhile (1){\n\t\tlstHash.clear();\n\t\tlstWorm.clear();\n\t\tscanf(\"%s\", add.nood);\n\t\tif (add.nood[0] == '0'){\n\t\t\tbreak;\n\t\t}\n\t\tint i = 0;\n\t\twhile (add.nood[i] != '\\0'){\n\t\t\tswitch(add.nood[i]){\n\t\t\t  case 'r': add.nood[i] = 0; break;\n\t\t\t  case 'g': add.nood[i] = 1; break;\n\t\t\t  case 'b': add.nood[i] = 2; break;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tadd.nood[i] = -1;\n\t\tadd.time = 0;\n\t\t\n\t\tlstWorm.push_back(add);\n\t\tlstHash.push_back(makeHash(add.nood));\n\t\t\n\t\twhile (lstWorm.empty() == false && checkNood(lstWorm.front().nood) == false){\n\t\t\tadd_worm(&lstWorm, lstHash);\n\t\t\tlstWorm.pop_front();\n\t\t}\n\t\t\n\t\tif (lstWorm.empty() == true){\n\t\t\tputs(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", lstWorm.front().time);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<string, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nchar judge(char a, char b){\n    if((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if((a == 'b' && b == 'g') || (a == 'g' && b == 'b')) return 'r';\n    if((a == 'g' && b == 'r') || (a == 'r' && b == 'g')) return 'b';\n}\n\nint main(){\n    while(1){\n        string s; cin>>s;\n        if(s == \"0\") return 0;\n\n        queue<P> que;\n        que.push(P(s, 0));\n        map<string, bool> visited;\n        visited[s] = true;\n        bool isNA = true;\n        while(que.size()){\n            string t;\n            int cnt;\n            tie(t, cnt) = que.front();\n            que.pop();\n\n            bool valid = true;\n\n            for(int i=0; i<t.size()-1; i++){\n                if(t[i] != t[i+1]){\n                    valid = false;\n                    string nt = t;\n                    nt[i] = nt[i+1] = judge(t[i], t[i+1]);\n\n                    if(!visited[nt]){\n                        visited[nt] = true;\n                        que.push(P(nt, cnt+1));\n                    }\n                }\n            }\n\n            if(valid){\n                isNA = false;\n                cout << cnt << endl;\n                break;\n            }\n        }\n\n        if(isNA){\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\n\nstruct Worm{\n  int body[10];\n  bool operator < ( const Worm &p ) const{\n    for(int i=0;i<10;i++){\n      if(body[i]==p.body[i])continue;\n      return body[i] < p.body[i];\n    }\n  }\n};\n\nint size,nowcnt;\nWorm now,next,X;\nstring str;\nmap < Worm , bool > vd;\nqueue <Worm> Q;\nqueue < int > cnt;\nvoid input();\nvoid init();\nvoid solve();\n\nint main(){\n  while(cin>>str&&str!=\"0\"){\n    input();\n    init();\n    solve();\n  }\n  return 0;\n}\n\nvoid init(){\n  vd.clear();\n  while(!Q.empty()){\n    Q.pop();\n    cnt.pop();\n  }\n}\n\nvoid input(){\n  size=str.size();\n  for(int i=0;i<size;i++){\n    if(str[i]=='r')X.body[i]=1;\n    if(str[i]=='g')X.body[i]=2;\n    if(str[i]=='b')X.body[i]=3;\n  }\n  for(int i=size;i<10;i++){\n    X.body[i]=0;\n  }\n}\n\nvoid solve(){\n  int count;\n  Q.push(X);\n  cnt.push(0);\n  vd[X]=true;\n\n  while(!Q.empty()){\n    now=Q.front();Q.pop();\n    nowcnt=cnt.front();cnt.pop();\n    \n    count=0;\n    for(int i=1;i<size;i++)\n      if(now.body[i]==now.body[i-1])count++;\n    if(count==size-1){\n      cout<<nowcnt<<endl;\n      return;\n    }\n    \n    for(int i=0;i<size-1;i++){\n      if(now.body[i]==now.body[i+1])continue;\n      next=now;\n      next.body[i]=next.body[i+1]=(6-now.body[i]-now.body[i+1]);\n      if(vd[next]==true)continue;\n      vd[next]=true;\n      Q.push(next);\n      cnt.push(nowcnt+1);\n\n    }\n\n  }\n  cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nbool same(string s) {\n\trep(i,s.size()-1) {\n\t\tif(s[i+1] != s[i]) return false;\n\t}\n\treturn true;\n}\nchar change(char a, char b) {\n\tchar c[3] = {'r', 'b', 'g'};\n\trep(i,3) {\n\t\tif(a != c[i] && b != c[i]) return c[i];\n\t}\n}\nint bfs(string str) {\n\tqueue<string> q;\n\tq.push(str);\n\tmap<string, int> m;\n\tm[str] = 0;\n\twhile(!q.empty()) {\n\t\tstring s = q.front(); q.pop();\n\t\tif(same(s)) return m[s];\n\t\trep(i,s.size()-1) {\n\t\t\tif(s[i+1] != s[i]) {\n\t\t\t\tstring ns = s;\n\t\t\t\tns[i+1] = ns[i] = change(ns[i+1],ns[i]);\n\t\t\t\tif(!m[ns]) {\n\t\t\t\t\tq.push(ns);\n\t\t\t\t\tm[ns] = m[s] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\tstring s;\n\twhile(cin >> s) {\n\t\tif(s ==\"0\") break;\n\t\tint ret = bfs(s);\n\t\tif(ret == -1) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n// テァツオツづ、ツコツ?ァツ環カテヲツ?凝」ツ?凝・ツ按、テ・ツョツ堙」ツ?凖」ツつ?\ninline bool ok(const string & v){\n    for (int i = 1; i < v.size(); i++){\n        if (v[i] != v[0]) return false;\n    }\n    return true;\n};\n\n// 3ティツ可イテ」ツ?ョテ」ツ??」ツ?。ティツ可イa,ティツ可イbテ」ツ?ョテ」ツ?ゥテ」ツ?。テ」ツつ嘉」ツ?ァテ」ツつづ」ツ?ェテ」ツ??ィツ可イテ」ツつ津ィツソツ氾」ツ??\ninline char other(char a, char b){\n    if (a>b)swap(a, b);\n    if (a == 'g' && b == 'r'){\n        return 'b';\n    }\n    if (a == 'b' && b == 'g'){\n        return 'r';\n    }\n    if (a == 'b' && b == 'r'){\n        return 'g';\n    }\n    // テ・ツ?ィテ」ツ?ヲテ」ツ?ョifテ」ツ?ォテ・ツシツ陛」ツ?」テ」ツ?凝」ツ?凝」ツつ嘉」ツ?ェテ」ツ??」ツ?ョテ」ツ?ッテヲツ伉偲」ツつ嘉」ツ?凝」ツ?ォテ・ツ、ツ嘉」ツ?ェテ」ツ?ョテ」ツ?ァtry-catchテァツ?。テ」ツ?療」ツ?ァテ、ツセツ凝・ツ、ツ姪」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // テ」ツ?禿」ツ??」ツ?凖」ツつ凝」ツ?ィテ」ツつクテ」ツδ」テ」ツδε」ツつクテ」ツ?ァWAテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?蹴Eテ」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?ョテ」ツ?ァテ」ツδ?」ツδ静」ツδε」ツつーテ」ツ?療」ツつ?」ツ?凖」ツ??\n    // Cティツィツ?ィツェツ榲」ツ?ァassertテ」ツ?古、ツスツソテ」ツ?暗」ツつ?\n    throw \"illigal char\";\n}\n\n// テ」ツつュテ」ツδ・テ」ツδシテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ凝ァツ環カテヲツ?凝」ツ?ョテ・ツ楪?\nstruct state {\n    string str;\n    int n;\n};\n\nint main(){\n    string s;\n    while (cin >> s, s != \"0\"){\n        queue<state> q;\n        // テ」ツ?凖」ツ?ァテ」ツ?ォティツィツェテ」ツつ古」ツ?淌ァツ環カテヲツ?凝」ツつ津ヲツ?シテァツエツ催」ツ?凖」ツつ虐et テ・ツ按敕」ツつ?」ツ?ッテァツゥツコ\n        set<string> dp;\n        // テ・ツ按敕ヲツ慊淌ァツ環カテヲツ?凝」ツつ智ueueテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ?\n        q.push({ s, 0 });\n\n        int ans = -1;\n        while (q.size()){\n            // staテ」ツ?繋ueueテ」ツ?ョテ、ツクツ?ァツ閉ェテ、ツクツ甘」ツ?ョテァツ環カテヲツ?凝」ツつ津、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツ?ォテ」ツ?療ッツシツ繋ueueテ」ツ?凝」ツつ嘉・ツ?コテ」ツ??\n            state sta = q.front();\n            q.pop();\n            string & sv = sta.str;\n\n            // setテ」ツ?ォテ、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツつ津・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィティツゥツヲテ」ツ?ソテ」ツつ凝ッツシツ?\n            // autoテ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲティツゥツウテ」ツ?療」ツ?湘」ツ?ッテヲツ慊?・ツセツ古」ツ?ョテ」ツつウテ」ツδ。テ」ツδウテ」ツδ暗」ツ?ォ\n            auto pr = dp.insert(sv);\n            if (!pr.second){\n                // テ、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツ?茎etテ」ツ?ォテヲツ猟「テ」ツ?ォテ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツ??」ツ?淌」ツ?淌」ツつ（nsertテ」ツ?ォテ・ツ、ツアテヲツ閉療」ツ?療」ツ?淌ッツシツ?\n                // テ」ツ?、テ」ツ?セテ」ツつ甘ゥツ?偲・ツ篠サテ」ツ?ョテ」ツδォテ」ツδシテ」ツδ療」ツ?ァテァツ「ツコティツェツ催ヲツクツ暗」ツ?ソテ」ツ?ョテ」ツ?淌」ツつ?ッツシツ古」ツ?禿」ツ?ョテァツ環カテヲツ?凝、ツサツ・テゥツ卍催」ツつ津ヲツ篠「テァツエツ「テ」ツ?凖」ツつ凝・ツソツ?ィツヲツ?」ツ?ッテ」ツ?ェテ」ツ??」ツ?凝」ツつ嘉」ツδォテ」ツδシテ」ツδ療」ツつ津ヲツ環愿」ツ?妥」ツつ?\n                continue;\n            }\n            // テァツ崢ョテァツ堋?」ツ?ョテァツ環カテヲツ?凝」ツ?ォティツセツソテ」ツつ甘ァツ敖?」ツ??」ツ?淌」ツ?ェテ」ツつ嘉ヲツ篠「テァツエツ「テァツオツづ、ツコツ?\n            if (ok(sv)){\n                ans = sta.n;\n                break;\n            }\n\n            // テ」ツ?敕」ツ??」ツ?ァテ」ツ?ェテ」ツ?妥」ツつ古」ツ?ーテッツシツ古、ツサツ甘」ツ?ョテァツ環カテヲツ?凝」ツ?凝」ツつ嘉ァツァツサテ」ツつ古」ツつ凝・ツ?ィテ」ツ?ヲテ」ツ?ョテァツ環カテヲツ?凝」ツつ智ueueテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ?\n            for (int i = 1; i < sv.size(); i++){\n                // テ」ツつづ」ツ?療ゥツ堋」テ」ツ?ィテゥツ?陛」ツ??ィツ可イテ」ツ?ェテ」ツつ嘉ッツシツ?\n                if (sv[i] != sv[i - 1]){\n                    char a = sv[i];\n                    char b = sv[i - 1];\n                    sv[i] = sv[i - 1] = other(a, b);\n                    q.push({ sv, sta.n + 1 });\n                    sv[i] = a;\n                    sv[i - 1] = b;\n                }\n            }\n        }\n\n        // ansテ」ツ?ョテ・ツ?、テ」ツ?古ヲツ崢エテヲツ鳴ーテ」ツ?陛」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ?妥」ツつ古」ツ?ーテッツシツ古ァツュツ氾」ツ?暗」ツ?ィテ」ツ?ェテ」ツつ凝ヲツ可凝ゥツ??」ツ?ッティツヲツ凝」ツ?、テ」ツ?凝」ツ?」テ」ツ?ヲテ」ツ??」ツ?ェテ」ツ??\n        if (ans == -1){\n            cout << \"NA\" << endl;\n        }\n        else{\n            cout << ans << endl;\n        }\n    }\n}\n\n// テ・ツ楪凝・ツ青催」ツ?ォautoテ」ツ?ィテヲツ崢クテ」ツ?湘」ツ?ィテ・ツ楪凝」ツつ津ヲツ篠ィティツォツ姪」ツ?療」ツ?ヲテ」ツ?湘」ツつ古」ツつ?C++11テゥツ卍静・ツョツ? g++ -std=c++11 a.cpp テ」ツ?ョテ」ツつ暗」ツ??」ツ?ォテ」ツつウテ」ツδウテ」ツδ妥」ツつ、テ」ツδォテ」ツ?凖」ツつ凝」ツ?ィテ、ツスツソテ」ツ?暗」ツつ凝ッツシツ?\n// setテ」ツ?ョテ」ツδ。テ」ツδウテ」ツδ静」ツδシテゥツ鳴「テヲツ閉ーinsertテ」ツ?ョテヲツ按サテ」ツつ甘・ツ?、テ」ツ?ョテ・ツ楪凝」ツ?ッ pair<set<string>::const_iterator, bool> テ・ツ楪凝」ツ?ァテ」ツ?づ」ツつ甘ッツシツ古」ツ?禿」ツつ古」ツつ津ヲツ崢クテ」ツ?湘」ツ?ョテ」ツ?ッテ」ツ?療」ツつ禿」ツ?ゥテ」ツ??」ツ??\n// autoテ」ツつ津、ツスツソテ」ツ?暗」ツ?ーテ」ツ?禿」ツ?ョテ」ツつ暗」ツ??」ツ?ェテゥツ閉キテ」ツ??・ツスツ「テ・ツ青催」ツつ津ァツ慊?ァツ閉・テ」ツ?ァテ」ツ?催」ツつ?テ・ツ楪凝ヲツ篠ィティツォツ?テッツシツ?\n// auto pr = dp.insert(sv);\n// テ」ツ?ッ\n// pair<set<string>::const_iterator, bool> pr = dp.insert(sv);\n// テ」ツ?ィテ・ツ青古」ツ?佚ッツシツ?"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\ninline bool ok(const vi & v){\n    for (int i = 1; i < v.size(); i++){\n        if (v[i] != v[0]) return false;\n    }\n    return true;\n};\n\nstruct state {\n    vi v;\n    int n;\n};\n\nint main(){\n    string s;\n    while (cin >> s, s != \"0\"){\n        vi init(s.size());\n        for (int i = 0; i < s.size(); i++){\n            if (s[i] == 'r') init[i] = 0;\n            else if (s[i] == 'g') init[i] = 1;\n            else init[i] = 2;\n        }\n        queue<state> q;\n        set<vi> dp;\n        q.push({ init, 0 });\n\n        int ans = -1;\n        while (q.size()){\n            state sta = q.front();\n            q.pop();\n            vi & sv = sta.v;\n            auto pr = dp.insert(sv);\n            if (!pr.second){\n                continue;\n            }\n            if (ok(sv)){\n                ans = sta.n;\n                break;\n            }\n            for (int i = 1; i < sv.size(); i++){\n                if (sv[i] != sv[i - 1]){\n                    int a = sv[i];\n                    int b = sv[i - 1];\n                    sv[i] = sv[i - 1] = 3 - (a + b);\n                    q.push({ sv, sta.n + 1 });\n                    sv[i] = a;\n                    sv[i - 1] = b;\n                }\n            }\n        }\n        if (ans == -1){\n            cout << \"NA\" << endl;\n        }\n        else{\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<string, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nchar judge(char a, char b){\n    if((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if((a == 'b' && b == 'g') || (a == 'g' && b == 'b')) return 'r';\n    if((a == 'g' && b == 'r') || (a == 'r' && b == 'g')) return 'b';\n}\n\nint main(){\n    while(1){\n        string s; cin>>s;\n        if(s == \"0\") return 0;\n\n        queue<P> que;\n        que.push(P(s, 0));\n        map<string, bool> visited;\n        visited[s] = true;\n        bool valid = false;\n        while(que.size()){\n            string t;\n            int cnt;\n            tie(t, cnt) = que.front();\n            que.pop();\n\n            int isR = 0, isB = 0, isG = 0;\n            for(int i=0; i<t.size(); i++){\n                if(t[i] == 'r') isR = 1;\n                if(t[i] == 'b') isB = 1;\n                if(t[i] == 'g') isG = 1;\n            }\n\n            if(isR + isB + isG <= 1){\n                valid = true;\n                cout << cnt << endl;\n                break;\n            }\n\n            for(int i=0; i<t.size()-1; i++){\n                if(t[i] != t[i+1]){\n                    string nt = t;\n                    nt[i] = nt[i+1] = judge(t[i], t[i+1]);\n\n                    if(!visited[nt]){\n                        visited[nt] = true;\n                        que.push(P(nt, cnt+1));\n                    }\n                }\n            }\n        }\n\n        if(!valid){\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\nint cnt,ccnt = 0;\nint len;\nstring s, ss, tmp;\nint flag = 0;\nint fflag=0;\nchar c;\nint cc=0;\nvector<string> v_list;\npair<string,int> ps;\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tfflag=0;\n\t\t//v_list.push_back(s);\n\t\tlen = s.length();\n\t\tqueue<pair<string,int> > qq;\n\t\tqq.push(make_pair(s,0));\n\t\twhile (!qq.empty()) {\n\t\t\tps = qq.front();\n\t\t\tqq.pop();\n\t\t\tc = ps.first[0];\n\n\t\t\tccnt=ps.second;\n\t\t\tflag = 0;\n\t\t\t//vector<int>::iterator cIter = std::find( v_list.begin(), v_list.end(), ps.first);\n\n\t\t\t/*if( (find( v_list.begin(), v_list.end(), ps.first)) != v_list.end() ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv_list.push_back(ps.first);*/\n\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tif (c != ps.first[i]) {\n\t\t\t\t\t//cout<<ps.first[i]<<endl;//deb\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tcc=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int i = cc-1; i < len - 1; ++i) {\n\t\t\t\t\ttmp = ps.first;\n\t\t\t\t\tif (ps.first[i] != ps.first[i+1]) {\n\t\t\t\t\t\tif (ps.first[i] != 'r' && ps.first[i+1] != 'r') {\n\t\t\t\t\t\t\ttmp[i] = 'r';\n\t\t\t\t\t\t\ttmp[i + 1] = 'r';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tif( (find( v_list.begin(), v_list.end(), tmp)) != v_list.end() ){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv_list.push_back(tmp);\n\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'g' && ps.first[i+1] != 'g' ){\n\t\t\t\t\t\t\ttmp[i] = 'g';\n\t\t\t\t\t\t\ttmp[i + 1] = 'g';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tif( (find( v_list.begin(), v_list.end(), tmp)) != v_list.end() ){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv_list.push_back(tmp);\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'b' && ps.first[i+1] != 'b') {\n\t\t\t\t\t\t\ttmp[i] = 'b';\n\t\t\t\t\t\t\ttmp[i + 1] = 'b';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tif( (find( v_list.begin(), v_list.end(), tmp)) != v_list.end() ){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv_list.push_back(tmp);\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcout << ccnt << endl;\n\t\t\t\tfflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!fflag){printf(\"NA\");cout<<endl;};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s==\"0\")break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(!q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }else if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }else if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }else if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp[y]==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(!f)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  while(true){\n    string s;\n    cin>>s;\n    if(s[0]=='0')break;\n    string sr(s.size(),'r');\n    string sg(s.size(),'g');\n    string sb(s.size(),'b');\n    map<string,int> mp;\n    queue<string> q;\n    q.push(s);\n    mp[s]=0;\n    int f=0;\n    if(s==sr||s==sb||s==sg){\n      cout<<0<<endl;\n    }else{\n      //for(int i=0;i<1e6;i++){\n      while(q.empty()){\n        string x=q.front();\n        q.pop();\n        for(int j=0;j<s.size()-1;j++){\n          string y=x;\n          if(y[j]=='r'&&y[j+1]=='g'){\n            y[j]='b';\n            y[j+1]='b';\n          }\n          if(y[j]=='b'&&y[j+1]=='g'){\n            y[j]='r';\n            y[j+1]='r';\n          }\n          if(y[j]=='r'&&y[j+1]=='b'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          if(y[j]=='g'&&y[j+1]=='b'){\n            y[j]='r';\n            y[j+1]='r';\n          }\n          if(y[j]=='g'&&y[j+1]=='r'){\n            y[j]='b';\n            y[j+1]='b';\n          }\n          if(y[j]=='b'&&y[j+1]=='r'){\n            y[j]='g';\n            y[j+1]='g';\n          }\n          //cout<<mp[x]+1<<\" \"<<y<<endl;\n          if(y==sr||y==sb||y==sg){\n            cout<<mp[x]+1<<endl;\n            f=1;\n            break;\n          }\n          if(mp[y]==0){\n            mp[y]=mp[x]+1;\n            q.push(y);\n          }\n        }\n        if(f)break;\n      }\n      if(f!=1)cout<<\"NA\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,string> P;\nint main(){\n  string s1;\n  int i;\n  while(1){\n    cin >> s1;\n    if(s1==\"0\"){\n      return 0;\n    }\n    int ans=(1<<29);\n    map<string,int> mp;\n    queue<P> que;\n    que.push(P(0,s1));\n    while(!que.empty()){\n      int x=que.front().first;\n      string s=que.front().second;\n      que.pop();\n      if(mp.find(s)!=mp.end() && mp[s]<=x){\n        continue;\n      }\n      if(x>=ans){\n        continue;\n      }\n      mp[s]=x;\n      int res=0;\n      for(i=1;i<s.size();i++){\n        if(s[i-1]!=s[i]){\n          res=1;\n          break;\n        }\n      }\n      if(res==0){\n        ans=x;\n        continue;\n      }\n      for(i=1;i<s.size();i++){\n        string t=s;\n        if(s[i-1]=='r' && s[i]=='g'){\n          t[i-1]='b',t[i]='b';\n          que.push(P(x+1,t));\n        }\n        if(s[i-1]=='r' && s[i]=='b'){\n          t[i-1]='g',t[i]='g';\n          que.push(P(x+1,t));\n        }\n        if(s[i-1]=='g' && s[i]=='b'){\n          t[i-1]='r',t[i]='r';\n          que.push(P(x+1,t));\n        }\n        if(s[i-1]=='g' && s[i]=='r'){\n          t[i-1]='b',t[i]='b';\n          que.push(P(x+1,t));\n        }\n        if(s[i-1]=='b' && s[i]=='g'){\n          t[i-1]='r',t[i]='r';\n          que.push(P(x+1,t));\n        }\n        if(s[i-1]=='b' && s[i]=='r'){\n          t[i-1]='g',t[i]='g';\n          que.push(P(x+1,t));\n        }\n      }\n    }\n    if(ans==(1<<29)){\n      cout << \"NA\" << endl;\n      continue;\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nint d[110][60000]={0};\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    for(i=0;i<110;i++){\n      for(j=0;j<60000;j++)d[i][j]=0;\n    }\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[0][n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<100;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==0)continue;\n\td[i+1][j]=zMIN(d[i+1][j],d[i][j]);\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[i+1][g(a)]=zMIN(d[i+1][g(a)],d[i][j]+1);\n\t}\n      }\n    }\n    d[100][0]=zMIN(d[100][0],zMIN(d[100][n/2],d[100][n]));\n    if(d[100][0])printf(\"%d\\n\",d[100][0]-1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nmap<char, int> m;\nmap<string, int> ans;\n\nint main() {\n\n\tm['r'] = 1;\n\tm['g'] = 2;\n\tm['b'] = 4;\n\t\n\tstring str;\n\twhile (cin >> str, str != \"0\") {\n\t\t\n\t\tqueue<pair<int, string> > que;\n\t\tque.push(make_pair(0, str));\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint t = que.front().first;\n\t\t\tstring now = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif (ans.find(now) != ans.end()) continue;\n\t\t\tans[now] = t;\n\t\t\t\n\t\t\tREP(i, now.size() - 1) {\n\t\t\t\tif (now[i] != now[i + 1]) {\n\t\t\t\t\tstring next = now;\n\t\t\t\t\tint nextcor = 7 - m[now[i]] - m[now[i + 1]];\n\t\t\t\t\tswitch (nextcor) {\n\t\t\t\t\tcase 1: next[i] = next[i + 1] = 'r'; break;\n\t\t\t\t\tcase 2: next[i] = next[i + 1] = 'g'; break;\n\t\t\t\t\tcase 4: next[i] = next[i + 1] = 'b'; break;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(make_pair(t + 1, next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchar c[3] = {'r', 'g', 'b'};\n\t\tstring ser[3] = {};\n\t\tREP(i, 3) REP(j, str.size()) {\n\t\t\tser[i] += c[i];\n\t\t}\n\t\tint miner = INF;\n\t\tREP(i, 3) if (ans.find(ser[i]) != ans.end()) miner = min(miner, ans[ser[i]]);\n\t\tif (miner == INF) puts(\"NA\");\n\t\telse cout << miner << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstring s;\n\nint judge(string j){\n  rep(i, j.size()-1) if(j[i] != j[i+1]) return 0;\n  return 1;\n}\n\nint main(){\n  while(cin >> s){\n    if(s[0] == '0') break;\n\n    queue<pair<string,int> >q;\n    map<string, int>m;\n    q.push(MP(s, 0));\n    m[s] = 1;\n\n    while(!q.empty()){\n      pair<string, int> p = q.front(); q.pop();\n\n      if(judge(p.F)){\n\tprintf(\"%d\\n\", p.S);\n\tgoto e;\n      }\n\n      rep(i, s.size()-1){\n\tstring n = p.F;\n\tif(n[i] == n[i+1]) continue;\n\tif(n[i] == 'r' && n[i+1] == 'g') n[i] = n[i+1] = 'b';\n\telse if(n[i] == 'r' && n[i+1] == 'b') n[i] = n[i+1] = 'g';\n\telse if(n[i] == 'g' && n[i+1] == 'r') n[i] = n[i+1] = 'b';\n\telse if(n[i] == 'g' && n[i+1] == 'b') n[i] = n[i+1] = 'r';\n\telse if(n[i] == 'b' && n[i+1] == 'g') n[i] = n[i+1] = 'r';\n\telse if(n[i] == 'b' && n[i+1] == 'r') n[i] = n[i+1] = 'g';\n\n\tif(m.find(n) != m.end()) continue;\n\tq.push(MP(n, p.S+1));\n\tm[n] = 1;\n      }\n    }\n    puts(\"NA\");\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint ar[11], ag[11], ab[11];\nbool checked[59049];\nint p3[11];\nmap<int,int> change = {\n    {0,0}, {1,8}, {2,4}, {3,8}, {4,4}, {5,0}, {6,4}, {7,0}, {8,8}\n};\n\nint conv(string s) {\n    int ret = 0;\n    for (int i=0; i<(int)s.size(); ++i) {\n        ret *= 3;\n        if (s[i] == 'g') ret += 1;\n        if (s[i] == 'b') ret += 2;\n    }\n    return ret;\n}\n\nint rotate(int x, int n) {\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        ret = ret * 3 + (x % 3 + 1) % 3;\n        x /= 3;\n    }\n    return ret;\n}\n\nint main() {\n    p3[0] = 1;\n    for (int i=1; i<=10; ++i) {\n        p3[i] = p3[i-1] * 3;\n    }\n    ar[0] = ag[0] = ab[0] = 0;\n    for (int i=1; i<=10; ++i) {\n        ar[i] = ar[i-1];\n        ag[i] = ag[i-1] * 3 + 1;\n        ab[i] = ab[i-1] * 3 + 2;\n    }\n    string s;\n    while (cin >> s, s != \"0\") {\n        memset(checked, false, sizeof checked);\n        int n = s.size();\n        int first = conv(s);\n        queue<pair<int,int> > q;\n        q.push(make_pair(first, 0));\n        checked[first] = true;\n        int res = -1;\n        while ( ! q.empty()) {\n            int col = q.front().first;\n            int t = q.front().second;\n            q.pop();\n            if (col == ar[n] || col == ag[n] || col == ab[n]) {\n                res = t;\n                break;\n            }\n            for (int i=0; i<n-1; ++i) {\n                int replace = change[(col / p3[i]) % 9];\n                int nx = (col / p3[i+2]) * p3[i+2] + replace * p3[i] + (col % p3[i]);\n                if ( ! checked[nx]) {\n                    q.push(make_pair(nx, t+1));\n                    checked[nx] = true; nx = rotate(nx, n);\n                    checked[nx] = true; nx = rotate(nx, n);\n                    checked[nx] = true;\n                }\n            }\n        }\n        if (res < 0) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<string, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nchar judge(char a, char b){\n    if((a == 'r' && b == 'b') || (a == 'b' && b == 'r')) return 'g';\n    if((a == 'b' && b == 'g') || (a == 'g' && b == 'b')) return 'r';\n    if((a == 'g' && b == 'r') || (a == 'r' && b == 'g')) return 'b';\n}\n\nint main(){\n    while(1){\n        string s; cin>>s;\n        if(s == \"0\") return 0;\n\n        queue<P> que;\n        que.push(P(s, 0));\n        map<string, bool> visited;\n        visited[s] = true;\n        bool isNA = true;\n        while(que.size()){\n            string t;\n            int cnt;\n            tie(t, cnt) = que.front();\n            que.pop();\n\n            bool valid = true;\n            for(int i=0; i<t.size()-1; i++){\n                if(t[i] != t[i+1]) valid = false;\n            }\n\n            if(valid){\n                isNA = false;\n                cout << cnt << endl;\n                break;\n            }\n\n            for(int i=0; i<t.size()-1; i++){\n                if(t[i] != t[i+1]){\n                    string nt = t;\n                    nt[i] = nt[i+1] = judge(t[i], t[i+1]);\n\n                    if(!visited[nt]){\n                        visited[nt] = true;\n                        que.push(P(nt, cnt+1));\n                    }\n                }\n            }\n        }\n\n        if(isNA){\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tstring s,temp;\n\tint cnt;\n\tint i1,i2;\n\tint check;\n\n\tmap<string,string> clr;\n\tclr[\"rg\"]=\"bb\";\n\tclr[\"gr\"]=\"bb\";\n\tclr[\"gb\"]=\"rr\";\n\tclr[\"bg\"]=\"rr\";\n\tclr[\"br\"]=\"gg\";\n\tclr[\"rb\"]=\"gg\";\n\n\twhile(1){\n\t\tcin>>s;\n\t\tif(s==\"0\") break;\n\n\t\tqueue<pair<string,int> > q;\n\t\tq.push(make_pair(s,0));\n\t\tset<string> bf;\n\t\tbf.insert(s);\n\n\t\twhile(!q.empty()){\n\t\t\ts=q.front().first;\n\t\t\tcnt=q.front().second;\n\t\t\tq.pop();\n\n\t\t\tcheck=0;\n\t\t\tfor(i1=0;i1<s.size()-1;i1++){\n\t\t\t\tif(s[i1]!=s[i1+1]) {\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tif(i1<s.size()-2){\n\t\t\t\t\t\ttemp=s.substr(0,i1)+clr[s.substr(i1,2)]+s.substr(i1+2);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttemp=s.substr(0,i1)+clr[s.substr(i1,2)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(bf.find(temp)==bf.end()) {\n\t\t\t\t\t\tq.push(make_pair(temp,cnt+1));\n\t\t\t\t\t\tbf.insert(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==0) {\n\t\t\t\tcheck=2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(check==2) cout<<cnt<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstruct s{\n    string worm;\n    int nowans;\n};\nint main(){\n    char dc[6][3]={'r','g','b','g','r','b','r','b','g','b','r','g','g','b','r','b','g','r'};\n    while(1){\n        s IN,now;\n        queue <s> que;\n        cin >> IN.worm;\n        IN.nowans=0;\n        if(IN.worm[0]=='0')\n            break;\n        que.push(IN);\n        while(1){\n            now=que.front(),que.pop();\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1])\n                    break;\n                if(i==now.worm.size()-1-1){\n                    printf(\"%d\\n\",now.nowans);\n                    goto exit;\n                }\n            }\n            if(now.nowans==10){\n                puts(\"NA\");\n                goto exit;\n            }\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1]){\n                    for(int j=0;j<6;j++){\n                        if(now.worm[i]==dc[j][0]&&now.worm[i+1]==dc[j][1]){\n                            now.worm[i]=dc[j][2],now.worm[i+1]=dc[j][2],now.nowans++;\n                            que.push(now);\n                            now.worm[i]=dc[j][0],now.worm[i+1]=dc[j][1],now.nowans--;\n                        }\n                    }\n                }\n            }\n        }\nexit:\n    printf(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// c1, c2 ª'r', 'g', 'b', ©Â(c1 != c2)ÌÆ«\n// m[c1+c2] Å c1, c2 ÅÈ¢'r', 'g', 'b'ªÔÁÄ­é\nmap<int,char> m;\n\n// S¯¶F©Ç¤©\nbool isSameColor(const string& s){\n\tchar c[3] = {'r','g','b'};\n\tfor(int i = 0 ; i < 3 ; i++ ){\n\t\tint cnt = 0;\n\t\tfor(int j=0 ; j < s.size() ; j++ ){\n\t\t\tif( s[j] == c[i] )\n\t\t\t\tcnt++;\n\t\t}\n\t\tif( cnt == s.size() )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint solve(string s_ ){\n\t// memo[s] = true ÈçTõÏÝ\n\tmap<string,bool> memo;\n\t// q.front().first Í ÌóÔ(string) q.front().second Íè(int)\n\tqueue< pair<string,int> > q;\n\t\n\t// úóÔðL[Éüêé\n\tpair<string,int> ini( s_ , 0  );\n\tq.push( ini );\n\tmemo[s_] = true;\n\t\n\t// L[ªóÉÈéÜÅ[v\n\twhile( !q.empty() ){\n\t\t// stirng s; ÍÌóÔ, int cnt; Íè\n\t\tstring s = q.front().first;\n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\t// S¯¶FÈçTõI¹\n\t\tif( isSameColor(s) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t// Ü¾TõµÄ¢È¢ÌóÔðL[Éüêé\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( s[i-1] != s[i] ){\n\t\t\t\tchar next_color = m[s[i-1]+s[i]];\n\t\t\t\tchar c1 = s[i-1];\n\t\t\t\tchar c2 = s[i];\n\t\t\t\ts[i-1] = s[i] = next_color;\n\t\t\t\tif( memo[s] != true ){\n\t\t\t\t\tmemo[s] = true;\n\t\t\t\t\tpair<string,int> next;\n\t\t\t\t\tnext.first = s;\n\t\t\t\t\tnext.second = cnt + 1;\n\t\t\t\t\tq.push( next );\n\t\t\t\t}\n\t\t\t\ts[i-1] = c1;\n\t\t\t\ts[i] = c2;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring s;\n\tm['r'+'g'] = 'b';\n\tm['g'+'b'] = 'r';\n\tm['b'+'r'] = 'g';\n\t\n\twhile( cin >> s , s != \"0\" ){\n\t\tint ans = solve( s );\n\t\tif( ans == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\ntypedef pair<string,int> SI;\n\nbool ok(string s)\n{\n  char c = s[0];\n  for(int i=0;i<s.length();i++)\n    if(c != s[i])\n      return false;\n  return true;\n}\n\nchar getc(char c,char cc)\n{\n  map<char,bool> index;\n  index['r'] = false,index['b'] = false,index['g'] = false;\n  index[c] = true;\n  index[cc] = true;\n  foreach(i,index)\n    if(!(*i).S)\n      return (*i).F;\n\n}\n\nint solve(string s)\n{\n\n  queue<SI> que;\n  que.push(SI(s,0));\n  map<string,bool> used;\n  while(!que.empty())\n    {\n      SI si = que.front(); que.pop();\n\n      if(used[si.F])\n\tcontinue;\n\n      used[si.F] = true;\n \n      if(ok(si.F))\n\t{\n\t  return si.S;\n\t}\n\n      if(si.S > 11)\n\tcontinue;\n\n      rep(i,si.F.length()-1)\n\t{\n\t  if(si.F[i] == si.F[i+1])\n\t    continue;\n\t  string news = si.F;\n\t  news[i] = news[i+1] = getc(si.F[i],si.F[i+1]);\n\t  que.push(SI(news,si.S+1));\n\t}\n\n    }\n\n  return -1;\n}\n\n\nint main(){\n\n  while(true)\n    {\n      string s;\n      cin >> s;\n      if(s[0] == '0')\n\tbreak;\n\n      int ans = solve(s);\n      ans != -1?cout << ans << endl:cout << \"NA\" << endl;\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<map>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint main(){\n  string worm;\n  cin>>worm;\n  \n  while(worm != \"0\"){\n    queue<pair<string,int> >que;\n    que.push(make_pair(worm,0));\n    set<string> done_str;\n    \n    int ans = -1;\n    \n    while(!que.empty()){\n      string s = que.front().first;\n      int count = que.front().second;\n      que.pop();\n\n      string cmp_strR,cmp_strG,cmp_strB;\n\n      cmp_strR.append(worm.size(), 'r');\n      cmp_strG.append(worm.size(), 'g');\n      cmp_strB.append(worm.size(), 'b');\n      \n      if(s == cmp_strR || s == cmp_strG || s == cmp_strB ){\n\tans = count;\n\tbreak;\n      }else if(done_str.find(s) != done_str.end()){\n\tcontinue;\n      }else{\n\tdone_str.insert(s);\n      }\n\n      for(int i=0;i<s.size()-1;i++){\n\tif(s.at(i) != s.at(i+1)){\n\t  if(s.at(i) != 'r' && s.at(i+1)!='r'){\n\t    string tmp = s;\n\t    que.push(make_pair(tmp.replace(i,2,2,'r'),count+1));\n\n\t  }else if(s.at(i) != 'g' && s.at(i+1)!='g'){\n\t    string tmp = s;\n\t    que.push(make_pair(tmp.replace(i,2,2,'g'),count+1));\n\n\t  }else if(s.at(i) != 'b' && s.at(i+1)!='b'){\n\t    string tmp = s;\n\t    que.push(make_pair(tmp.replace(i,2,2,'b'),count+1));\n\t  }\n\t}\n      }\n    }\n\n    if(ans < 0){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<ans<<endl;\n    }\n    \n    cin>>worm;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n#define P pair<string,int>\n#define C(X)((X)=='r'?0:(X)=='b'?1:2)\nint main() {\n\tstring w;\n\twhile(cin>>w,w!=\"0\") {\n\t\tqueue<P> q;\n\t\tset<string> s;\n\t\tq.push(P(w,0));\n\t\ts.insert(w);\n\t\tbool OK=false;\n\t\twhile(!q.empty()) {\n\t\t\tP p=q.front();q.pop();\n\t\t\tbool ok=true;\n\t\t\tfor(int i=1;i<p.first.size();i++) {\n\t\t\t\tif(p.first[i-1]!=p.first[i]) {\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tprintf(\"%d\\n\",p.second);\n\t\t\t\tOK=true;break;\n\t\t\t}\n\t\t\tfor(int i=1;i<p.first.size();i++) {\n\t\t\t\tif(p.first[i-1]!=p.first[i]) {\n\t\t\t\t\tstring ns=p.first;\n\t\t\t\t\tbool chr[3]={0};\n\t\t\t\t\tchr[C(ns[i-1])]=true;\n\t\t\t\t\tchr[C(ns[i])]=true;\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif(chr[j]==false) {\n\t\t\t\t\t\t\tns[i-1]=ns[i]=(j==0?'r':j==1?'b':'g');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s.find(ns)==s.end()) {\n\t\t\t\t\t\tq.push(P(ns,p.second+1));\n\t\t\t\t\t\ts.insert(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(OK==false)printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string& str)\n{\n\tfor (int i = 1; i < str.size(); i++){\n\t\tif (str[i] != str[0]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tstring str;\n\twhile (cin >> str, str != \"0\"){\n\t\tqueue<pair<string, int> > que;\n\t\tque.push({str, 0});\n\t\tset<string> done;\n\t\tint res = -1;\n\t\twhile (!que.empty()){\n\t\t\tpair<string, int> p = que.front(); que.pop();\n\t\t\t//cout << p.first << endl;\n\t\t\tif (check(p.first)){\n\t\t\t\tres = p.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (done.count(p.first)) continue;\n\t\t\tdone.insert(p.first);\n\t\t\t\n\t\t\tfor (int i = 1; i < p.first.size(); i++){\n\t\t\t\tif (p.first[i] != p.first[i - 1]){\n\t\t\t\t\tint cnt[256] = {0};\n\t\t\t\t\tcnt[p.first[i]]++;\n\t\t\t\t\tcnt[p.first[i - 1]]++;\n\t\t\t\t\t\n\t\t\t\t\tstring tmp = p.first;\n\t\t\t\t\tif (!cnt['r']){\n\t\t\t\t\t\ttmp[i] = tmp[i - 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if (!cnt['g']){\n\t\t\t\t\t\ttmp[i] = tmp[i - 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmp[i] = tmp[i - 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tque.push({tmp, p.second + 1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res == -1) puts(\"NA\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dist[60000];\nvector<int> x[60000];\nstring S; queue<int>Q;\nint power[12], p2[12];\nint main() {\n\tpower[0] = 1; p2[0] = 1;\n\tfor (int i = 1; i < 12; i++)power[i] = power[i - 1] * 3;\n\tfor (int i = 1; i < 12; i++)p2[i] = p2[i - 1] + power[i];\n\twhile (true) {\n\t\tcin >> S; if (S == \"0\") break;\n\t\tint bit[12], c[12], D = 0;\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'r')D += 0 * power[i];\n\t\t\tif (S[i] == 'g')D += 1 * power[i];\n\t\t\tif (S[i] == 'b')D += 2 * power[i];\n\t\t}\n\t\tfor (int i = 0; i < 60000; i++) {\n\t\t\tdist[i] = 99999; x[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < power[S.size()]; i++) {\n\t\t\tfor (int j = 0; j < S.size(); j++)bit[j] = (i / power[j]) % 3;\n\t\t\tfor (int j = 0; j < S.size() - 1; j++) {\n\t\t\t\tfor (int k = 0; k < S.size(); k++)c[k] = bit[k];\n\t\t\t\tif (bit[j] != bit[j + 1]) {\n\t\t\t\t\tint V = bit[j] + bit[j + 1];\n\t\t\t\t\tV = 3 - V; c[j] = V; c[j + 1] = V;\n\t\t\t\t\tint T = 0;\n\t\t\t\t\tfor (int k = 0; k < S.size(); k++) {\n\t\t\t\t\t\tT += c[k] * power[k];\n\t\t\t\t\t}\n\t\t\t\t\tx[i].push_back(T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(D); dist[D] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a = Q.front(); Q.pop();\n\t\t\tfor (int i = 0; i < x[a].size(); i++) {\n\t\t\t\tif (dist[x[a][i]] == 99999) {\n\t\t\t\t\tdist[x[a][i]] = dist[a] + 1;\n\t\t\t\t\tQ.push(x[a][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minx = min(dist[0], min(dist[p2[S.size() - 1]], dist[2 * p2[S.size() - 1]]));\n\t\tif (minx == 99999)cout << \"NA\" << endl;\n\t\telse cout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0179\n#include<iostream>\n#include<string>\n#include<set>\n#include<map>\n#include<queue>\n#include<functional>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int integer;\n\nbool end(string s) {\n  char c = s[0];\n  int len = s.size();\n  REP(i, len) {\n    if (c != s[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvector<string> gonext(string worm) {\n  vector<string> v;\n  for (int i = 1, len = worm.length(); i < len; i++) {\n    if (worm[i] == worm[i-1]) continue;\n    string s = worm;\n    char c = 'r' + 'g' + 'b' - worm[i] - worm[i-1];\n    s[i] = s[i-1] = c;\n    v.push_back(s);\n  }\n  return v;\n}\n\ntypedef pair<integer,string> P;\n\ninteger solve(string worm) {\n  priority_queue<P,vector<P>,greater<P> > q;\n  set<string> s;\n  q.push(make_pair(0,worm));\n  while (!q.empty()) {\n    P w = q.top();\n    q.pop();\n    if (end(w.second)) return w.first;\n    vector<string> nxts = gonext(w.second);\n    for (auto nxt : nxts) {\n      if (s.find(nxt) == s.end()) {\n        q.push(make_pair(w.first + 1, nxt));\n        s.insert(nxt);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  string s;\n  while (cin >> s and s != \"0\") {\n    integer ans = solve(s);\n    if (ans == -1) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n \nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define MCLR(a) memset((a), -1 ,sizeof(a))\n#define SZ(a) (sizeof(a))\n#define FILL(a,v) fill((int*)a,(int*)(a+(SZ(a)/SZ(*(a)))),v)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n\nbool cheak(int x,int y,int xMax,int yMax)\n{return x >= 0 && y >= 0 && xMax > x && yMax > y;}\nconst int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nconst int INF = 2147483647;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n//???????????¢?´¢\nstruct Bfs\n{\n\tset<string> memo;\n\tint search(string s)\n\t{\n\t\tqueue<string> que;\n\t\tqueue<int>    time;\n\t\tque.push(s);\n\t\ttime.push(0);\n\t\tmemo.insert(s);\n\t\twhile(que.size())\n\t\t{\n\t\t\tstring now = que.front();que.pop();\n\t\t\tint anstime = time.front();time.pop();\n\t\t\t//??????\n\t\t\t\n\t\t\tbool end = true;\n\t\t\tREP(i,now.size()-1)\n\t\t\tif(now[i] != now[i+1])\n\t\t\tend = false;\n\t\t\tif(end)return anstime; \n\t\t\t//\n\n\t\t\tREP(i,now.size()-1)\n\t\t\t{\n\t\t\t\tstring ts = now;\n\t\t\t\tchar c0 = now[i];\n\t\t\t\tchar c1 = now[i+1];\n\t\t\t\tchar sc;\n\t\t\t\tif(c0 != c1)\n\t\t\t\t{\n\t\t\t\t\tif(c0 != 'b' && c1 != 'b')\n\t\t\t\t\t\tsc = 'b';\n\t\t\t\t\tif(c0 != 'r' && c1 != 'r')\n\t\t\t\t\t\tsc = 'r';\n\t\t\t\t\tif(c0 != 'g' && c1 != 'g')\n\t\t\t\t\t\tsc = 'g';\n\t\t\t\t\t\n\t\t\t\t\tts[i] = sc;ts[i+1] = sc;\n\t\t\t\t\tif(!memo.count(ts))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo.insert(ts);\n\t\t\t\t\t\tque.push(ts);\n\t\t\t\t\t\ttime.push(1+anstime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str && str != \"0\")\n\t{\n\t\tBfs bfs;\n\t\tint ans = bfs.search(str);\n\t\tif(ans == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout <<  ans << endl;\n\t}\n\treturn 0;\n}\n\n\n//????¬????????????????????????¨?????????\n/*\n\tREP(i,mx)\n\t{\n\t\tREP(j,my)\n\t\tcout << n[i][j];\n\t\tcout << endl;\n\t}\n\tcout << endl;\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\nusing namespace std;\nmap<string, int> cache;\nbool same(string seq){\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    if(seq[i] != seq[i+1]){\n      return false;\n    }\n  }\n  return true;\n}\nint dls(string seq, int depth){\n  if(depth<0){\n    return false;\n  }\n  if(same(seq)){\n    return true;\n  }\n  if(cache.find(seq) != cache.end() && cache[seq] >= depth){\n    return false;\n  }\n  else{\n    cache[seq] = depth;\n  }\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    char t = seq[i];\n    char n = seq[i+1];\n    if(t != n){\n      if((t + n) == ('r' + 'b')){\n        seq[i] = seq[i+1] = 'g';\n      }\n      else if((t + n) == ('r' + 'g')){\n        seq[i] = seq[i+1] = 'b';\n      }\n      else{\n        seq[i] = seq[i+1] = 'r';\n      }\n      if(dls(seq, depth-1)){\n        return true;\n      }\n      seq[i] = t;\n      seq[i+1] = n;\n    }\n  }\n  return false;\n}\nvoid iddfs(string seq){\n  cache = map<string, int>();\n  for(int depth = 0;depth <= 20; ++depth){\n    if(dls(seq, depth)){\n      cout << depth << endl;\n      return;\n    }\n  }\n  cout << \"NA\" << endl;\n}\nint main(){\n  char seq[11];\n  while(true){\n    cin >> seq;\n    if(seq[0] == '0'){\n      break;\n    }\n    iddfs(seq);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/21 Tazoe\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstruct state{\n\tstring seg;\n\tint tim;\n};\n\nint main()\n{\n\twhile(true){\n\t\tstruct state wrm;\n\t\tcin >> wrm.seg;\n\t\tif(wrm.seg==\"0\")\n\t\t\tbreak;\n\t\twrm.tim = 0;\n\n\t\tqueue<struct state> que;\n\t\tque.push(wrm);\n\n\t\tmap<string, bool> memo;\n\n\t\twhile(true){\n\t\t\tif(que.empty()){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twrm = que.front();\n\t\t\tque.pop();\n\n\t\t\tif(memo[wrm.seg])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tmemo[wrm.seg] = true;\n\n\t\t\tbool flg = true;\n\t\t\tfor(int i=1; i<wrm.seg.size(); i++)\n\t\t\t\tif(wrm.seg[i]!=wrm.seg[0]){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tcout << wrm.tim << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstruct state tmp;\n\t\t\tfor(int i=0; i<wrm.seg.size()-1; i++)\n\t\t\t\tif(wrm.seg[i]==wrm.seg[i+1])\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(wrm.seg[i]!='r'&&wrm.seg[i+1]!='r'){\n\t\t\t\t\ttmp.seg = wrm.seg;\n\t\t\t\t\ttmp.seg[i] = tmp.seg[i+1] = 'r';\n\t\t\t\t\ttmp.tim = wrm.tim+1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t\telse if(wrm.seg[i]!='g'&&wrm.seg[i+1]!='g'){\n\t\t\t\t\ttmp.seg = wrm.seg;\n\t\t\t\t\ttmp.seg[i] = tmp.seg[i+1] = 'g';\n\t\t\t\t\ttmp.tim = wrm.tim+1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t\telse if(wrm.seg[i]!='b'&&wrm.seg[i+1]!='b'){\n\t\t\t\t\ttmp.seg = wrm.seg;\n\t\t\t\t\ttmp.seg[i] = tmp.seg[i+1] = 'b';\n\t\t\t\t\ttmp.tim = wrm.tim+1;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nint main()\n{\n    map<string, int> worm;\n    queue<string> que;\n    string chars = \"rgb\";\n    REP(i, 2, 11){\n        for (char c : chars) {\n            worm[string(i,c)] = 0;\n            que.push(string(i,c));\n            while (!que.empty()) {\n                string s = que.front(); que.pop();\n                rep(j, s.length()-1){\n                    if (s[j] != s[j+1])\n                        continue;\n                    rep(k, 3){\n                        if (s[j] == chars[k]) {\n                            REP(l, k+1, k+3){\n                                REP(m, k+1, k+3){\n                                    if (l != m) {\n                                        string p = s;\n                                        p[j] = chars[l%3];\n                                        p[j+1] = chars[m%3];\n                                        if(!EXIST(worm, p) || worm[p] > worm[s]+1){\n                                            que.push(p);\n                                            worm[p] = worm[s] + 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    string input;\n    while (cin >> input, input != \"0\") {\n        if (EXIST(worm, input))\n            cout << worm[input] << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint que[60000][10],flg[1050000];\nint main(void){\n\tint p1,p2,i,j,len,time[60000],copy[10],f,x,ans,iro;\n\tchar ca[11];\n\twhile(1){\n\t\tcin>>ca;\n\t\tif(ca[0]=='0') break;\n\t\tlen=strlen(ca);\n\t\tfor(i=0;i<len;i++){\n\t\t\tif(ca[i]=='r') que[0][i]=0;\n\t\t\tif(ca[i]=='g') que[0][i]=1;\n\t\t\tif(ca[i]=='b') que[0][i]=2;\n\t\t}\n\t\tfor(i=0;i<=1050000;i++) flg[i]=0;\n\t\tp1=0; p2=1; time[0]=0; ans=-1;\n\t\twhile(1){\n\t\t\tf=1;\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tif(que[p1][i]!=que[p1][i+1]){\n\t\t\t\t\tf=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==1){\n\t\t\t\tans=time[p1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<len-1;i+=2){\n\t\t\t\tfor(j=0;j<len;j++) copy[j]=que[p1][j];\n\t\t\t\tif(copy[i]!=copy[i+1]){\n\t\t\t\t\tiro=copy[i]+copy[i+1];\n\t\t\t\t\tif(iro==3){\n\t\t\t\t\t\tcopy[i]=0; copy[i+1]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==2){\n\t\t\t\t\t\tcopy[i]=1; copy[i+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==1){\n\t\t\t\t\t\tcopy[i]=2; copy[i+1]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=copy[0];\n\t\t\t\tfor(j=1;j<len;j++) x=x*4+copy[j];\n\t\t\t\tif(flg[x]==0){\n\t\t\t\t\tflg[x]=1; time[p2]=time[p1]+1;\n\t\t\t\t\tfor(j=0;j<len;j++) que[p2][j]=copy[j];\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1++;\n\t\t}\n\t\tif(ans==-1) cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nvoid solve()\n{\n\tstring str;\n\twhile(cin >> str)\n\t{\n\t\tif(str == \"0\")\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tqueue<string> Que;\n\t\tQue.push(str);\n\t\tqueue<string> NextQue;\n\t\tint depth = 0;\n\t\tset<string> Valiation;\n\t\tValiation.insert(str);\n\t\twhile(true)\n\t\t{\n\t\t\tif(depth >= 20)\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tstring worm = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tbool same_color_flag = true;\n\t\t\t\tfor(int i = 1; i < worm.size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif(worm[i] != worm[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tsame_color_flag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(same_color_flag)\n\t\t\t\t{\n\t\t\t\t\tcout << depth << endl;\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\tchar before_color = worm[0];\n\t\t\t\tfor(int i = 1; i < worm.size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif(before_color != worm[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tstring next = worm;\n\t\t\t\t\t\tif(before_color == 'b')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(worm[i] == 'g')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'r';\n\t\t\t\t\t\t\t\tnext[i] = 'r';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(worm[i] == 'r')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'g';\n\t\t\t\t\t\t\t\tnext[i] = 'g';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(before_color == 'g')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(worm[i] == 'b')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'r';\n\t\t\t\t\t\t\t\tnext[i] = 'r';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(worm[i] == 'r')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'b';\n\t\t\t\t\t\t\t\tnext[i] = 'b';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(before_color == 'r')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(worm[i] == 'g')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'b';\n\t\t\t\t\t\t\t\tnext[i] = 'b';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(worm[i] == 'b')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnext[i - 1] = 'g';\n\t\t\t\t\t\t\t\tnext[i] = 'g';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Valiation.find(next) == Valiation.end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNextQue.push(next);\n\t\t\t\t\t\t\tValiation.insert(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbefore_color = worm[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t\t++depth;\n\t\t}\nEND:\n\t\t;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<complex>\n#include<cfloat>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define EPS (1e-10)\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint encode(char *buff, int &len){\n  int ret = 0;\n  len = 0;\n  while(true){\n    if(*buff == 'r'){\n      ret <<= 2;\n      ret += 0;\n    }else if(*buff == 'g'){\n      ret <<= 2;\n      ret += 1;\n    }else if(*buff == 'b'){\n      ret <<= 2;\n      ret += 2;\n    }else{\n      return ret;\n    }\n    buff++;\n    len++;\n  }\n  return ret;\n}\n\nvoid print(int now, int len){\n  REP(i,len){\n    int t = (now >> (2 * i)) & ((1<<2) - 1);\n    if(t == 0) putchar('r');\n    if(t == 1) putchar('g');\n    if(t == 2) putchar('b');\n  }\n  puts(\"\");\n}\n\nint main(){\n  char buff[64];\n  int change[1<<6];\n\n  memset(change, -1, sizeof(change));\n  REP(i,3) REP(j,3) REP(k,3)\n    if(i != j && j != k && i != k)\n      change[i | (j << 2)] = (k | (k << 2));\n\n  while(fgets(buff,sizeof(buff),stdin), *buff != '0'){\n    int len;\n    int now = encode(buff,len);\n\n    int ans[3];\n    REP(i,3){\n      int tmp = 0;\n      REP(j,len){\n\ttmp <<= 2;\n\ttmp += i;\n      }\n      ans[i] = tmp;\n    }\n\n    \n\n    set<int> s;\n    queue<int> q;\n    int n = 0;\n    q.push(now);\n    q.push(-1);\n    s.insert(now);\n\n    while(true){\n      now = q.front();\n\n      bool f = false;\n      REP(i,3){\n\tif(ans[i] == now){\n\t  printf(\"%d\\n\",n);\n\t  f = true;\n\t  break;\n\t}\n      }\n      if(f) break;\n\n      q.pop();\n      \n      if(q.empty()){\n\tputs(\"NA\");\n\tbreak;\n      }\n\n      if(now == -1){\n\tn++;\n\tq.push(-1);\n\tcontinue;\n      }\n\n      //printf(\"now: \"); print(now,len);\n\n      REP(i,len-1){\n\tint cc   = (now >> (i * 2)) & ((1<<4) - 1);\n\n\tif(change[cc] != -1){\n\t  int next = now & ~(((1<<4)-1) << (i * 2));\n\t  next |= (change[cc] << (i * 2));\n\t  //print(next, len);\n\t  if(s.find(next) == s.end()){\n\t    s.insert(next);\n\t    q.push(next);\n\t  }\n\t}\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n \nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define MCLR(a) memset((a), -1 ,sizeof(a))\n#define SZ(a) (sizeof(a))\n#define FILL(a,v) fill((int*)a,(int*)(a+(SZ(a)/SZ(*(a)))),v)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n\nbool cheak(int x,int y,int xMax,int yMax)\n{return x >= 0 && y >= 0 && xMax > x && yMax > y;}\nconst int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nconst int INF = 2147483647;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n//???????????¢?´¢\nstruct Bfs\n{\n\tset<string> memo;\n\tset<string> memo2;\n\tint search(string s)\n\t{\n\t\tqueue<string> que;\n\t\tqueue<int>    time;\n\t\tque.push(s);\n\t\ttime.push(0);\n\t\tmemo.insert(s);\n\t\tmemo2.insert(s);\n\t\twhile(que.size())\n\t\t{\n\t\t\tstring now = que.front();que.pop();\n\t\t\tint anstime = time.front();time.pop();\n\t\t\t//??????\n\t\t\t\n\t\t\tbool end = true;\n\t\t\tREP(i,now.size()-1)\n\t\t\tif(now[i] != now[i+1])\n\t\t\tend = false;\n\t\t\tif(end)return anstime; \n\t\t\t//\n\n\t\t\tREP(i,now.size()-1)\n\t\t\t{\n\t\t\t\tstring ts = now;\n\t\t\t\tchar c0 = now[i];\n\t\t\t\tchar c1 = now[i+1];\n\t\t\t\tchar sc;\n\t\t\t\tif(c0 != c1)\n\t\t\t\t{\n\t\t\t\t\tif(c0 != 'b' && c1 != 'b')\n\t\t\t\t\t\tsc = 'b';\n\t\t\t\t\tif(c0 != 'r' && c1 != 'r')\n\t\t\t\t\t\tsc = 'r';\n\t\t\t\t\tif(c0 != 'g' && c1 != 'g')\n\t\t\t\t\t\tsc = 'g';\n\t\t\t\t\t\n\t\t\t\t\tts[i] = sc;ts[i+1] = sc;\n\t\t\t\t\tif(!memo2.count(ts))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(memo.count(ts))\n\t\t\t\t\t\t\tmemo2.insert(ts);\n\t\t\t\t\t\tmemo.insert(ts);\n\t\t\t\t\t\tque.push(ts);\n\t\t\t\t\t\ttime.push(1+anstime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str && str != \"0\")\n\t{\n\t\tBfs bfs;\n\t\tint ans = bfs.search(str);\n\t\tif(ans == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout <<  ans << endl;\n\t}\n\treturn 0;\n}\n\n\n//????¬????????????????????????¨?????????\n/*\n\tREP(i,mx)\n\t{\n\t\tREP(j,my)\n\t\tcout << n[i][j];\n\t\tcout << endl;\n\t}\n\tcout << endl;\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\nint main(){\n\tstring s;\n\twhile(1){\n\t\tmap<string,bool> used;\n\t\tcin >> s;\n\t\tif(s == \"0\") break;\n\t\tqueue<string> que;\n\t\tque.push(s);\n\t\tfor(int i = 0;;i++){\n\t\t\tint siz = que.size();\n\t\t\tif(!siz){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int j = 0;j < siz;j++){\n\t\t\t\ts = que.front();que.pop();\n\t\t\t\tif(used[s]) continue;\n\t\t\t\tused[s] = true;\n\t\t\t\tchar c = s[0];\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = 1;k < s.length();k++){\n\t\t\t\t\tif(s[k] != c) flag = false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tcout << i << endl;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tfor(int k = 0;k < s.length() - 1;k++){\n\t\t\t\t\tif(s[k] != s[k + 1]){\n\t\t\t\t\t\tstring t = s;\n\t\t\t\t\t\tif(s[k] != 'g' && s[k + 1] != 'g'){\n\t\t\t\t\t\t\tt[k] = 'g';\n\t\t\t\t\t\t\tt[k + 1] = 'g';\n\t\t\t\t\t\t\tque.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s[k] != 'r' && s[k + 1] != 'r'){\n\t\t\t\t\t\t\tt[k] = 'r';\n\t\t\t\t\t\t\tt[k + 1] = 'r';\n\t\t\t\t\t\t\tque.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tt[k] = 'b';\n\t\t\t\t\t\t\tt[k + 1] = 'b';\n\t\t\t\t\t\t\tque.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:\n\t\tcontinue;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <climits>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\nstring s;\nstring qf;\nset<string> vis;\n\nbool check(string a){\n\tchar t=a[0];\n\trep(i,a.size()){\n\t\tif(t!=a[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\t//cout<<s<<endl;\n\t\tvis.clear();\n\t\tint ans=-1;\n\t\tqueue<string> qu;\n\t\tif(check(s)){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvis.insert(s);\n\t\tqu.push(s);\n\t\tbool f1=false;\n\t\tbool f2=false;\n\t\tbool f3=false;\n\t\twhile(!qu.empty()){\n\t\t\tf1=false;\n\t\t\tf2=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(qf[j]!=qf[j+1]){\n\t\t\t\t\t\tstring tmp=qf;\n\t\t\t\t\t\ttmp[j] = tmp[j+1] = 'r'+'g'+'b'-qf[j]-qf[j+1];\n\t\t\t\t\t\tif(vis.find(tmp)==vis.end()){\n\t\t\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\t\tvis.insert(tmp);\n\t\t\t\t\t\t\tf1=true;\n\t\t\t\t\t\t\tif(check(tmp)) f3=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf2=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f3) break;\n\t\t}\n\t\tif(f3) cout<<ans+1<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<string, int> P;\nvector<string> vs;\n\nbool is_memo(string str)\n{\n\tfor(unsigned i=0;i<vs.size();i++){\n\t\tif(vs[i] == str)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint search(string str)\n{\n\tqueue<P> que;\n\tP p;p.first = str;p.second = 0;\n\tque.push(p);\n\tvs.push_back(p.first);\n\twhile(que.size()){\n\t\tP s = que.front();que.pop();\n\t\tif(s.second > 10)\n\t\t\tbreak;\n\t\tbool is_all = true;\n\t\tfor(unsigned i=0;i<s.first.size();i++){\n\t\t\tif(s.first[0] != s.first[i]){\n\t\t\t\tis_all = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(is_all){\n\t\t\treturn s.second;\n\t\t}\n\t\tint a=0;\n\t\tfor(unsigned i=0;i<s.first.size()-1;i++){\n\t\t\tP ss = s;\n\t\t\tif((ss.first[i] != ss.first[i+1])){\n\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'r')){\n\t\t\t\t\tss.first[i] = 'b';ss.first[i+1] = 'b';\n\t\t\t\t\tif(is_memo(ss.first)){\n\t\t\t\t\t\tss.second++; que.push(ss);vs.push_back(ss.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'b') || (ss.first[i] == 'b' && ss.first[i+1] == 'r')){\n\t\t\t\t\tss.first[i] = 'g';ss.first[i+1] = 'g';\n\t\t\t\t\tif(is_memo(ss.first)){\n\t\t\t\t\t\tss.second++; que.push(ss);vs.push_back(ss.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif((ss.first[i] == 'b' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'b')){\n\t\t\t\t\tss.first[i] = 'r';ss.first[i+1] = 'r';\n\t\t\t\t\tif(is_memo(ss.first)){\n\t\t\t\t\t\tss.second++; que.push(ss);vs.push_back(ss.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str[0] == '0')\n\t\t\tbreak;\n\t\tint p = search(str);\n\t\tif(p == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << p << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define pb push_back\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\ntypedef pair<string,int> SI;\n\nbool ok(string s)\n{\n  char c = s[0];\n  for(int i=0;i<s.length();i++)\n    if(c != s[i])\n      return false;\n  return true;\n}\n\nchar getc(char c,char cc)\n{\n  map<char,bool> index;\n  index['r'] = false,index['b'] = false,index['g'] = false;\n  index[c] = true;\n  index[cc] = true;\n  foreach(i,index)\n    if(!(*i).S)\n      return (*i).F;\n\n}\n\nint solve(string s)\n{\n\n  queue<SI> que;\n  que.push(SI(s,0));\n  map<string,bool> used;\n  while(!que.empty())\n    {\n      SI si = que.front(); que.pop();\n\n      if(used[si.F])\n\tcontinue;\n\n      used[si.F] = true;\n \n      if(ok(si.F))\n\t{\n\t  return si.S;\n\t}\n\n      if(si.S > 15)\n\tcontinue;\n\n      rep(i,si.F.length()-1)\n\t{\n\t  if(si.F[i] == si.F[i+1])\n\t    continue;\n\t  string news = si.F;\n\t  news[i] = news[i+1] = getc(si.F[i],si.F[i+1]);\n\t  que.push(SI(news,si.S+1));\n\t}\n\n    }\n\n  return -1;\n}\n\n\nint main(){\n\n  while(true)\n    {\n      string s;\n      cin >> s;\n      if(s[0] == '0')\n\tbreak;\n\n      int ans = solve(s);\n      ans != -1?cout << ans << endl:cout << \"NA\" << endl;\n\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <climits>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\nstring s;\nint qf;\n\nint foo1(int D[]){\n\tint res=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tres*=10;\n\t\tres+=D[i];\n\t}\n\treturn res;\n}\nvoid foo2(int D[],int m){\n\trep(j,s.size()){\n\t\tD[j]=0;\n\t}\n\tfor(int i=s.size()-1;i>=0;--i){\n\t\tD[i]=m%10;\n\t\tm/=10;\n\t\trep(j,s.size()){\n\t\t}\n\t}\n}\n\n\nint a[30];\nint tmp[30];\nset<string> vis;\n\nbool check(){\n\tchar t=a[0];\n\trep(i,s.size()){\n\t\tif(t!=a[i]) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=0;\n\t\tqueue<string> qu;\n\t\tif(check()){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvis.insert(s);\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\t//int c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\t//c++;\n\t\t\t//if(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\tif(check()){\n\t\t\t\t\tcout<<ans-1<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(s[j]!=s[j+1]){\n\t\t\t\t\t\tstring tmp=s;\n\t\t\t\t\t\ttmp[j] = tmp[j+1] = 'r'+'g'+'b'-s[j]-s[j+1];\n\t\t\t\t\t\tif(vis.find(tmp)==vis.end()){\n\t\t\t\t\t\t\tqu.push(tmp);\n\t\t\t\t\t\t\tvis.insert(tmp);\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n\n/*\nint main(){\n\t\n\twhile(cin>>s,s[0]!='0'){\n\t\tvis.clear();\n\t\tint ans=0;\n\t\tqueue<int> qu;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='r') a[i]=0;\n\t\t\telse if(s[i]=='g') a[i]=1;\n\t\t\telse if(s[i]=='b') a[i]=2;\n\t\t}\n\t\tif(check()){\n\t\t\tcout<<\"0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqu.push(foo1(a));\n\t\tvis.insert(foo1(a));\n\t\tbool f=false;\n\t\tbool f1=false;\n\t\t//int c=0;\n\t\twhile(!qu.empty()&&!f1){\n\t\t\t//c++;\n\t\t\t//if(c>50) break;\n\t\t\tf=false;\n\t\t\tans++;\n\t\t\tint qs=qu.size();\n\t\t\trep(i,qs){\n\t\t\t\tqf=qu.front();\n\t\t\t\tqu.pop();\n\t\t\t\tfoo2(a,qf);\n\t\t\t\tif(check()){\n\t\t\t\t\tcout<<ans-1<<endl;\n\t\t\t\t\tf1=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trep(j,s.size()-1){\n\t\t\t\t\tif(a[j]!=a[j+1]){\n\t\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\t\ttmp[k]=a[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(a[j]*a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=0;\n\t\t\t\t\t\t\ttmp[j+1]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(a[j]==2||a[j+1]==2){\n\t\t\t\t\t\t\ttmp[j]=1;\n\t\t\t\t\t\t\ttmp[j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttmp[j]=2;\n\t\t\t\t\t\t\ttmp[j+1]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(vis.find(foo1(tmp))==vis.end()){\n\t\t\t\t\t\t\tqu.push(foo1(tmp));\n\t\t\t\t\t\t\tvis.insert(foo1(tmp));\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\t\tif(f1) break;\n\t\t}\n\t\tif(f1) continue;\n\t\tif(!f&&!f1) cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\nusing namespace std;\n\nmap<int,bool> isre;\nmap<int,int> dp;\n\nint code(string s){\n    int ret=0,kake=1;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='r') ret+=kake*1;\n        else if(s[i]=='g') ret+=kake*2;\n        else ret+=kake*3;\n        kake*=4;\n    }\n    return ret;\n}\n\nint solve(string st){\n    int co=code(st);\n    if(dp.find(co)==dp.end()){\n        bool is=true;\n        for(int i=0;i<st.size();i++){\n            if(st[i]!=st[0]) is=false;\n        }\n        if(is) return dp[co]=0;\n        if(isre[co]) return dp[co]=-1;\n        isre[co]=true;\n        int miti=INT_MAX;\n        for(int i=1;i<st.size();i++){\n            string ne=st;\n            if(st[i-1]!=st[i]){\n                if(st[i-1]!='r'&&st[i]!='r'){\n                    ne[i-1]=ne[i]='r';\n                }else if(st[i-1]!='g'&&st[i]!='g'){\n                    ne[i-1]=ne[i]='g';\n                }else{\n                    ne[i-1]=ne[i]='b';\n                }\n            }\n            int ret=solve(ne);\n            if(ret!=-1) miti=min(miti,ret+1);\n        }\n        isre[co]=false;\n        if(miti==INT_MAX) return dp[co]=-1;\n        else return dp[co]=miti;\n    }else return dp[co];\n}\n\nint main(){\n    string in;\n    for(;;){\n        cin>>in;\n        if(in==\"0\") break;\n        isre=map<int,bool>();\n        dp=map<int,int>();\n        int ret=solve(in);\n        if(ret==-1) cout<<\"NA\"<<endl;\n        else cout<<ret<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\nint cnt,ccnt = 0;\nint len;\nstring s, ss, tmp;\nint flag = 0;\nint fflag=0;\nchar c;\nvector<string> v_list;\npair<string,int> ps;\nint main() {\n\twhile (cin >> s) {\n\t\tif (s == \"0\") {\n\t\t\tbreak;\n\t\t}\n\t\tfflag=0;\n\t\t//v_list.push_back(s);\n\t\tlen = s.length();\n\t\tqueue<pair<string,int> > qq;\n\t\tqq.push(make_pair(s,0));\n\t\twhile (!qq.empty()) {\n\t\t\tps = qq.front();\n\t\t\tqq.pop();\n\t\t\tc = ps.first[0];\n\n\t\t\tccnt=ps.second;\n\t\t\tflag = 0;\n\t\t\t//vector<int>::iterator cIter = std::find( v_list.begin(), v_list.end(), ps.first);\n\n\t\t\t/*if( (find( v_list.begin(), v_list.end(), ps.first)) != v_list.end() ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv_list.push_back(ps.first);*/\n\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tif (c != ps.first[i]) {\n\t\t\t\t\t//cout<<ps.first[i]<<endl;//deb\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int i = 0; i < len - 1; ++i) {\n\t\t\t\t\ttmp = ps.first;\n\t\t\t\t\tif (ps.first[i] != ps.first[i+1]) {\n\t\t\t\t\t\tif (ps.first[i] != 'r' && ps.first[i+1] != 'r') {\n\t\t\t\t\t\t\ttmp[i] = 'r';\n\t\t\t\t\t\t\ttmp[i + 1] = 'r';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tif( (find( v_list.begin(), v_list.end(), tmp)) != v_list.end() ){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv_list.push_back(tmp);\n\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'g' && ps.first[i+1] != 'g' ){\n\t\t\t\t\t\t\ttmp[i] = 'g';\n\t\t\t\t\t\t\ttmp[i + 1] = 'g';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tif( (find( v_list.begin(), v_list.end(), tmp)) != v_list.end() ){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv_list.push_back(tmp);\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ps.first[i] != 'b' && ps.first[i+1] != 'b') {\n\t\t\t\t\t\t\ttmp[i] = 'b';\n\t\t\t\t\t\t\ttmp[i + 1] = 'b';\n\t\t\t\t\t\t\t//cout<<tmp<<endl;//deb\n\t\t\t\t\t\t\tif( (find( v_list.begin(), v_list.end(), tmp)) != v_list.end() ){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv_list.push_back(tmp);\n\t\t\t\t\t\t\tqq.push(make_pair(tmp,ccnt+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcout << ccnt << endl;\n\t\t\t\tfflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!fflag){printf(\"NA\");cout<<endl;};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<cstring>\n\ntypedef pair<string,int> P;\n\nint main(){\n  int kaku=0;\n  string body;\n  while(1){\n  cin>>body;\n  if(body==\"0\")return 0;\n  map<string,int> used;\n  queue<P> que;\n  que.push(P(body,0));\n  while(!que.empty()){\n    P p =que.front();que.pop();\n    string now = p.first;\n    int co = p.second;\n    int c=1;\n    for(int i=0;i<body.size();i++){\n      if(now[0]==now[i+1])c++;\n    }\n    if(c==body.size()){\n      cout<<co<<endl;\n      kaku=1;\n      break;\n    }\n    if(used[now]==1)continue;\n    used[now]=1;\n    for(int i=0;i<body.size()-1;i++){\n      string next=now;\n    if(next[i]==next[i+1])continue;\n    if((next[i]=='r' && next[i+1]=='b') || (next[i]=='b' && next[i+1]=='r')){\n      next[i]='g';\n      next[i+1]='g';\n      que.push(P(next,co+1));\n    }\n    if((next[i]=='r' && next[i+1]=='g') || (next[i]=='g' && next[i+1]=='r')){\n      next[i]='b';\n      next[i+1]='b';\n      que.push(P(next,co+1));\n    }\n    if((next[i]=='g' && next[i+1]=='b') || (next[i]=='b' && next[i+1]=='g')){\n      next[i]='r';\n      next[i+1]='r';\n      que.push(P(next,co+1));\n    }\n  }\n  }\n  if(kaku==0)cout<<\"NA\"<<endl;\n  kaku=0;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    while (cin >> s, s[0] != '0') {\n\t\tmap<string, bool> m;\n\n\t\tqueue<string> q, r;\n\n\t\tq.push(s);\n\n\t\tint cnt = 0;\n\n\t\twhile (q.size()) {\n\t\t\twhile (q.size()) {\n\t\t\t\tstring t = q.front(); q.pop();\n\t\t\t\tif (m[t]) continue;\n\t\t\t\tm[t] = true;\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int i = 0; i < t.size() - 1; ++i) {\n\t\t\t\t\tif ((t[i] == 'r' && t[i + 1] == 'b') || (t[i] == 'b' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'g';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'b' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'b')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'r';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t} else if ((t[i] == 'r' && t[i + 1] == 'g') || (t[i] == 'g' && t[i + 1] == 'r')) {\n\t\t\t\t\t\tchar c = t[i], d = t[i + 1];\n\t\t\t\t\t\tt[i] = t[i + 1] = 'b';\n\t\t\t\t\t\tr.push(t);\n\t\t\t\t\t\tt[i] = c, t[i + 1] = d;\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n                    cout << cnt << endl;\n\t\t\t\t\tgoto nxt;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (r.size()) {\n\t\t\t\tstring t = r.front(); r.pop();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n        cout << \"NA\" << endl;\nnxt:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\nclass Data{\npublic:\n    string bc;\n    int t;\n    Data(string bc,int t):bc(bc),t(t){}\n    Data(){}\n};\nbool judge(string s,int l){\n    for(int i=0;i<l-1;++i){\n        if(s[i]!=s[i+1])return false;\n    }\n    return true;\n}\nchar cj(char a,char b){\n    if(a=='b'&&b=='g')return 'r';\n    if(a=='b'&&b=='r')return 'g';\n    if(a=='g'&&b=='r')return 'b';\n    swap(a,b);\n    if(a=='b'&&b=='g')return 'r';\n    if(a=='b'&&b=='r')return 'g';\n    if(a=='g'&&b=='r')return 'b';\n}\nint main()\n{\n    string s;\n    while(cin>>s,s!=\"s\")\n    {\n        int l=s.length();\n        int res=-1;\n        queue<Data> Q;\n        set<string> visited;\n        Q.push(Data(s,0));\n        while(!Q.empty())\n        {\n            Data t=Q.front();\n            Q.pop();\n            if(visited.count(t.bc))continue;\n            if(judge(t.bc,l)){\n                res=t.t;\n                break;\n            }\n            visited.insert(t.bc);\n            for(int i=0;i<l-1;++i){\n                if(t.bc[i]==t.bc[i+1])continue;\n                char nc=cj(t.bc[i],t.bc[i+1]);\n                string nbc=t.bc;\n                nbc[i]=nbc[i+1]=nc;\n                Q.push(Data(nbc,t.t+1));\n            }\n        }\n        if(res==-1)\n                cout<<\"NA\"<<endl;\n        else\n                cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nbool is_goal( string s )\n{\n\tbool ok = true;\n\tfor ( int i = 0; i + 1 < s.size(); i++ ) if ( s[i] != s[i+1] ) ok = false;\n\treturn ok;\n}\n\nchar change_color( char a, char b )\n{\n\tif ( a == 'r' )\n\t\treturn ( b == 'g' ) ? 'b' : 'g';\n\n\telse if ( a == 'g' )\n\t\treturn ( b == 'b' ) ? 'r' : 'b';\n\n\telse if ( a == 'b' )\n\t\treturn ( b == 'r' ) ? 'g' : 'r';\n\n\treturn ' ';\n}\n\nint main( void )\n{\n\tstring in;\n\twhile ( cin >> in )\n\t{\n\t\tif ( in == \"0\" )\n\t\t\tbreak;\n\n\t\tmap <string, int>\tV;\n\t\tqueue <string>\t\tQ;\n\n\t\tV[in] = 0;\n\t\tQ.push( in );\n\n\t\tint kotae = -1;\n\t\twhile ( Q.empty() == false )\n\t\t{\n\t\t\tstring now = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif ( is_goal( now ) )\n\t\t\t{\n\t\t\t\tkotae = V[now];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i + 1 < now.size(); i++ )\n\t\t\t{\n\t\t\t\tstring tmp = now;\n\t\t\t\tif ( tmp[i] != tmp[i+1] )\n\t\t\t\t{\n\t\t\t\t\ttmp[i] = tmp[i+1] = change_color( tmp[i], tmp[i+1] );\n\t\t\t\t}\n\n\t\t\t\tif ( V.find( tmp ) == V.end() )\n\t\t\t\t{\n\t\t\t\t\tV[tmp] = V[now] + 1;\n\t\t\t\t\tQ.push( tmp );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( kotae == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << kotae << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<string, int> psi;\n\nint bfs(string worm) {\n  queue<psi> que;\n  que.push(psi(worm, 0));\n\n  map<string, int> d;\n\n  while (!que.empty()) {\n    psi p = que.front();\n    que.pop();\n\n    if (d[p.first]) continue;\n\n    string str = p.first;\n\n    bool flag = false;\n    for (int i = 0; i < str.size() - 1; i++) {\n      if (str[i] != str[i+1]) {\n\t  flag = true;\n\t  break;\n      }\n    }\n\n    if (!flag) return p.second;\n\n    d[p.first] = p.second;\n\n    for (int i = 0; i < str.size() - 1; i++) {\n      if (str[i] != str[i+1]) {\n\tchar temp;\n\tstring next;\n\n\tif (str[i] != 'b' && str[i+1] != 'b') {\n\t  temp = 'b';\n\t} else if (str[i] != 'g' && str[i+1] != 'g') {\n\t  temp = 'g';\n\t} else {\n\t  temp = 'r';\n\t}\n\n\tnext = str;\n\tnext[i] = next[i+1] = temp;\n\n\tque.push(psi(next, p.second+1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void) {\n  string worm;\n  while (cin >> worm) {\n    if (worm[0] == '0') {\n      break;\n    }\n\n    int ret = bfs(worm);\n    if (ret != -1) {\n      cout << ret << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\n//????????????????????????????????????\nbool judge(string str) {\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tif (str[0] != str[i]) return false;\n\t}\n\treturn true;\n}\n\n//??£?????????2?????????????????§?????????????????????\nchar color(char a, char b){\n\tif((a == 'g' && b == 'r') || (a == 'r' && b == 'g'))return 'b';\n\telse if((a == 'b' && b == 'r') || (a == 'r' && b == 'b')) return 'g';\n\telse if((a == 'g' && b == 'b') || (a == 'b' && b == 'g')) return 'r';\n}\n\nint solve(string s ){\n\n\tqueue<P> q;\n\tmap<string, int> m;\n\tq.push(P(s, 0));\t//?????\\??????????????¶????????\\??????\n\n\twhile (!q.empty()) {\t//?????\\??????????????¶?????????????????§\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif(m[p.first]) continue;\t//??????????????????\n\t\tstring now = p.first;\n\t\tif (judge(now)) return p.second;\n\t\tfor (int i = 0; i < now.size() - 1; ++i) {\n\t\t\tif (now[i] != now[i+1]){\t//??£?????????2????????°????????¨???\n\t\t\t\tchar tmp = color(now[i], now[i + 1]);\n\t\t\t\tstring D = now;\n\t\t\t\tD[i] = tmp;\n\t\t\t\tD[i + 1] = tmp;\n\t\t\t\tq.push(P(D, p.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tstring worm;\n\twhile (cin >> worm) {\n\t\tif (worm == \"0\") break;\n\t\tint count = solve(worm);\n\t\tif (count == -1) cout << \"NA\" << endl;\n\t\telse cout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<string,int> P;\nint main() {\n\tstring str;\n\twhile(cin>>str,str!=\"0\") {\n\t\tqueue<P> Q;\n\t\tQ.push(P(str,0));\n\t\tset<string> S;\n\t\tS.insert(str);\n\t\tbool NA=true;\n\t\twhile(!Q.empty()) {\n\t\t\tP p=Q.front(); Q.pop();\n\t\t\tbool Flag=true;\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tif(p.first[i]!=p.first[i+1]) {Flag=false;break;}\n\t\t\t}\n\t\t\tif(Flag) {printf(\"%d\\n\",p.second);NA=false;break;}\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tstring tmp=p.first;\n\t\t\t\tif((tmp[i]=='r' && tmp[i+1]=='g') || (tmp[i+1]=='r' && tmp[i]=='g')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='b';\n\t\t\t\t}else if((tmp[i]=='r' && tmp[i+1]=='b') || (tmp[i+1]=='r' && tmp[i]=='b')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='g';\n\t\t\t\t}else if((tmp[i]=='b' && tmp[i+1]=='g') || (tmp[i+1]=='b' && tmp[i]=='g')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='r';\n\t\t\t\t}else continue;\n\t\t\t\tif(S.find(tmp)==S.end()) {\n\t\t\t\t\tS.insert(tmp);\n\t\t\t\t\tQ.push(P(tmp,p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(NA) printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nbool same(char* seq){\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    if(seq[i] != seq[i+1]){\n      return false;\n    }\n  }\n  return true;\n}\nint dls(char* seq, int depth){\n  if(depth<0){\n    return false;\n  }\n  if(same(seq)){\n    return true;\n  }\n  for(int i = 0; seq[i+1] != '\\0'; ++i){\n    char t = seq[i];\n    char n = seq[i+1];\n    if(t != n){\n      if((t + n) == ('r' + 'b')){\n        seq[i] = seq[i+1] = 'g';\n      }\n      else if((t + n) == ('r' + 'g')){\n        seq[i] = seq[i+1] = 'b';\n      }\n      else{\n        seq[i] = seq[i+1] = 'r';\n      }\n      if(dls(seq, depth-1)){\n        return true;\n      }\n      seq[i] = t;\n      seq[i+1] = n;\n    }\n  }\n  return false;\n}\nvoid iddfs(char* seq){\n  for(int depth = 0;depth <= 10; ++depth){\n    if(dls(seq, depth)){\n      cout << depth << endl;\n      return;\n    }\n  }\n  cout << \"NA\" << endl;\n}\nint main(){\n  char seq[11];\n  while(true){\n    cin >> seq;\n    if(seq[0] == '0'){\n      break;\n    }\n    iddfs(seq);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<string, int> P;\n\nint main()\n{\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str[0] == '0')\n\t\t\tbreak;\n\t\tint count = -1;\n\t\tmap<string,bool> mp;\n\t\tqueue<P> que;\n\t\tP p;p.first = str;p.second = 0;\n\t\tque.push(p);\n\t\twhile(que.size()){\n\t\t\tP s = que.front();que.pop();\n\t\t\tif(mp[s.first])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tmp[s.first] = true;\n\n\t\t\tif(s.second > 10)\n\t\t\t\tbreak;\n\n\t\t\tbool is_all = true;\n\t\t\tfor(unsigned i=1;i<s.first.size();i++){\n\t\t\t\tif(s.first[0] != s.first[i]){\n\t\t\t\t\tis_all = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_all){\n\t\t\t\tcount = s.second;\n\t\t\t}\n\n\t\t\tint a=0;\n\t\t\tfor(unsigned i=0;i<s.first.size()-1;i++){\n\t\t\t\tP ss = s;\n\t\t\t\tif((ss.first[i] != ss.first[i+1])){\n\t\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'r')){\n\t\t\t\t\t\tss.first[i] = 'b';ss.first[i+1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\tif((ss.first[i] == 'r' && ss.first[i+1] == 'b') || (ss.first[i] == 'b' && ss.first[i+1] == 'r')){\n\t\t\t\t\t\tss.first[i] = 'g';ss.first[i+1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif((ss.first[i] == 'b' && ss.first[i+1] == 'g') || (ss.first[i] == 'g' && ss.first[i+1] == 'b')){\n\t\t\t\t\t\tss.first[i] = 'r';ss.first[i+1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tss.second = s.second+1;\n\t\t\t\t\tque.push(ss);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == -1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<cmath>\nusing namespace std;\n\nint s_i(string str){\n  int ans = 0;\n  int tmp = 1;\n  for(int i=0;i<str.size();i++){\n    if(str[i] == 'g')ans += tmp;\n    else if(str[i] == 'b')ans += 2 * tmp;\n    tmp *= 3;\n  }\n  return ans;\n}\nint main(){\n  string worm,tmp;\n  deque<string> open,open2;\n  char first;\n  int ans,max;\n  bool flag;\n  bool check[100000];\n\n  while(1){\n    cin >> worm;\n    if(worm == \"0\")break;\n\n    max = 1;\n    for(int i=0;i<worm.size();i++)max *= 3;\n    for(int i=0;i<max;i++)check[i] = false;\n\n    open.clear();\n    open2.clear();\n\n    open.push_back(worm);\n    check[s_i(worm)] = true;\n    ans = 0;\n\n    while(1){\n      while(open.size()){\n\tworm = open[0];\n\topen.pop_front();\n\t\n\tflag = true;\n\tfirst = worm[0];\n\tfor(int i=1;i<worm.size();i++){\n\t  if(worm[i]!=first){\n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif(flag)break;\n\t\n\tfor(int i=0;i<worm.size()-1;i++){\n\t  if(worm[i]!=worm[i+1]){\n\t    tmp = worm;\n\t    if(worm[i]!= 'r' && worm[i+1] != 'r')tmp[i] = tmp[i+1] = 'r';\n\t    else if(worm[i]!= 'g' && worm[i+1] != 'g')tmp[i] = tmp[i+1] = 'g';\n\t    else if(worm[i]!= 'b' && worm[i+1] != 'b')tmp[i] = tmp[i+1] = 'b';\n\t    if(!check[s_i(tmp)]){\n\t      check[s_i(tmp)] = true;\n\t      open2.push_back(tmp);\n\t    }\n\t  }\n\t}\n      }\n      if(flag)break;\n      if(!open2.size())break;\n      open = open2;\n      open2.clear();\n      ans++;\n    }\n    if(flag)cout << ans << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\nusing namespace std;\n\nmap<string,bool> isre;\nmap<string,int> dp;\n\nint solve(string st){\n    if(dp.find(st)==dp.end()){\n        bool is=true;\n        for(int i=0;i<st.size();i++){\n            if(st[i]!=st[0]) is=false;\n        }\n        if(is) return dp[st]=0;\n        if(isre[st]) return dp[st]=-1;\n        isre[st]=true;\n        int miti=INT_MAX;\n        for(int i=1;i<st.size();i++){\n            string ne=st;\n            if(st[i-1]!=st[i]){\n                if(st[i-1]!='r'&&st[i]!='r'){\n                    ne[i-1]=ne[i]='r';\n                }else if(st[i-1]!='g'&&st[i]!='g'){\n                    ne[i-1]=ne[i]='g';\n                }else{\n                    ne[i-1]=ne[i]='b';\n                }\n            }\n            int ret=solve(ne);\n            if(ret!=-1) miti=min(miti,ret+1);\n        }\n        isre[st]=false;\n        if(miti==INT_MAX) return dp[st]=-1;\n        else return dp[st]=miti;\n    }else return dp[st];\n}\n\nint main(){\n    string in;\n    for(;;){\n        cin>>in;\n        if(in==\"0\") break;\n        isre=map<string,bool>();\n        dp=map<string,int>();\n        int ret=solve(in);\n        if(ret==-1) cout<<\"NA\"<<endl;\n        else cout<<ret<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<string, int> P;\n\nint ans = 0;\nint s_size;\n\nstring change(string s, int a, int b){\n\tif((s[a] == 'r' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'r'))\n\t\ts[b] = s[a] = 'b';\n\telse if((s[a] == 'b' && s[b] == 'g') || (s[a] == 'g' && s[b] == 'b'))\n\t\ts[b] = s[a] = 'r';\n\telse\n\t\ts[b] = s[a] = 'g';\n\t\n\treturn s;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\tstring str;\n\twhile(cin >> str){\n\t\tif(str == \"0\")\n\t\t\tbreak;\n\t\ts_size = str.size();\n\t\tans = INF;\n\t\tqueue<P> que;\n\t\tmap<string, bool> visited;\n\t\tque.push(P(str, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tstring s = p.first;\n\t\t\tif(visited[s])\n\t\t\t\tcontinue;\n\t\t\tvisited[s] = true;\n\t\t\tbool flag = false;\n\t\t\tfor(int i = 0; i < s_size - 1; ++i){\n\t\t\t\tif(s[i] != s[i + 1])\n\t\t\t\t\tbreak;\n\t\t\t\tif(i == s_size - 2){\n\t\t\t\t\tans = min(ans, p.second);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t\tcontinue;\n\t\t\tfor(int i = 0; i < s_size - 1; ++i){\n\t\t\t\tif(s[i] != s[i + 1]){\n\t\t\t\t\tstring t = change(s, i, i + 1);\n\t\t\t\t\tque.push(P(t, p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:\n\t\tif(ans == INF)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nbool check(string s) {\n  for (int i = 0; i < int(s.size()); i++) {\n    if (s[i] != s[0]) return false;\n  }\n  return true;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  const string col = \"rgb\";\n  string s;\n  while (cin >> s, s != \"0\") {\n    int n = s.size();\n    map<string, int> dis;\n    queue<string> que;\n    dis[s] = 0;\n    que.emplace(s);\n    int ans = -1;\n    while (!que.empty()) {\n      s = que.front(); que.pop();\n      if (check(s)) {\n        ans = dis[s];\n        break;\n      }\n      for (int i = 0; i + 1 < n; i++) {\n        if (s[i] == s[i + 1]) continue;\n        for (int j = 0; j < 3; j++) {\n          if (s[i] != col[j] && s[i + 1] != col[j]) {\n            string ns = s;\n            ns[i] = ns[i + 1] = col[j];\n            if (dis.find(ns) != dis.end()) continue;\n            dis[ns] = dis[s] + 1;\n            que.emplace(ns);\n          }\n        }\n      }\n    }\n    if (ans < 0) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<math.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nstring InputStr, StrNow;\nmap<string, int> DpResult;\n\n\nbool isAllSame() {\n\tint size;\n\n\tsize = StrNow.size();\n\tfor (int i = 1; i < size; i++) {\n\t\tif (StrNow[0] != StrNow[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool solve() {\n\tint size;\n\tstring strPrev;\n\tqueue<string> CurrentStr;\n\n\tDpResult[InputStr] = 0;\n\tCurrentStr.push(InputStr);\n\n\twhile (!CurrentStr.empty()) {\n\t\tStrNow = strPrev = CurrentStr.front();\n\t\tCurrentStr.pop();\n\n\t\t//cout << \"befor:\" << strPrev << endl;\n\t\tsize = StrNow.size() - 1;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tStrNow = strPrev;\n\t\t\tif ((StrNow[i] == 'r' && StrNow[i + 1] == 'g') || (StrNow[i] == 'g' && StrNow[i + 1] == 'r')) {\n\t\t\t\tStrNow[i] = StrNow[i + 1] = 'b';\n\t\t\t}\n\t\t\telse if ((StrNow[i] == 'r' && StrNow[i + 1] == 'b') || (StrNow[i] == 'b' && StrNow[i + 1] == 'r')) {\n\t\t\t\tStrNow[i] = StrNow[i + 1] = 'g';\n\t\t\t}\n\t\t\telse if ((StrNow[i] == 'g' && StrNow[i + 1] == 'b') || (StrNow[i] == 'b' && StrNow[i + 1] == 'g')) {\n\t\t\t\tStrNow[i] = StrNow[i + 1] = 'r';\n\t\t\t}\n\n\t\t\t//cout << \"after:\" << StrNow << endl;\n\t\t\tif (DpResult.find(StrNow) == DpResult.end()) {\n\t\t\t\tCurrentStr.push(StrNow);\n\t\t\t\tDpResult[StrNow] = DpResult[strPrev] + 1;\n\t\t\t}\n\n\t\t\tif (isAllSame()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\n\twhile (cin >> InputStr, InputStr[0] != '0') {\n\t\t//cout << InputStr << endl;\n\t\tDpResult.clear();\t\t\n\t\tif (solve()) {\n\t\t\tcout << DpResult[StrNow] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool check(string& str)\n{\n\tfor (int i = 1; i < str.size(); i++){\n\t\tif (str[i] != str[0]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tstring str;\n\twhile (cin >> str, str != \"0\"){\n\t\tqueue<pair<string, int> > que;\n\t\tque.push({str, 0});\n\t\tset<string> done;\n\t\tint res = -1;\n\t\twhile (!que.empty()){\n\t\t\tauto p = que.front(); que.pop();\n\t\t\t//cout << p.first << endl;\n\t\t\tif (check(p.first)){\n\t\t\t\tres = p.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (done.count(p.first)) continue;\n\t\t\tdone.insert(p.first);\n\t\t\t\n\t\t\tfor (int i = 1; i < p.first.size(); i++){\n\t\t\t\tif (p.first[i] != p.first[i - 1]){\n\t\t\t\t\tint cnt[256] = {0};\n\t\t\t\t\tcnt[p.first[i]]++;\n\t\t\t\t\tcnt[p.first[i - 1]]++;\n\t\t\t\t\t\n\t\t\t\t\tstring tmp = p.first;\n\t\t\t\t\tif (!cnt['r']){\n\t\t\t\t\t\ttmp[i] = tmp[i - 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if (!cnt['g']){\n\t\t\t\t\t\ttmp[i] = tmp[i - 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmp[i] = tmp[i - 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tque.push({tmp, p.second + 1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res == -1) puts(\"NA\");\n\t\telse printf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint main(){\n\tmap<string,string>q;\n\tq[\"bg\"]=q[\"gb\"]=\"rr\";\n\tq[\"gr\"]=q[\"rg\"]=\"bb\";\n\tq[\"rb\"]=q[\"br\"]=\"gg\";\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tchar qqq=s[0];\n\t\tbool h=true;\n\t\trep(i,s.size())if(s[i]!=qqq)h=false;\n\t\tif(h){cout<<0<<endl;continue;}\n\t\tvector<string>in;\n\t\tmap<string,bool>tmp;\n\t\tin.pb(s);\n\t\tint co=0;\n\t\twhile(1){\n\t\t\tvector<string>out;\n\t\t\tbool h=false;\n\t\t\trep(i,in.size()){\n\t\t\t\tstring s=in[i];\n\t\t\t\ttmp[s]=true;\n\t\t\t\t//h=true;\n\t\t\t\t//char qq=in[i][0];\n\t\t\t\t//rep(j,s.size())if(qq!=in[i][j])h=false;\n\t\t\t\t//if(h)break;\n\t\t\t\trep(j,s.size()-1)if(s[j]!=s[j+1]){\n\t\t\t\t\tstring www=s.substr(j,2);\n\t\t\t\t\tstring w=q[www];\n\t\t\t\t\tstring ww=s;\n\t\t\t\t\tww[j]=w[0];ww[j+1]=w[1];\n\t\t\t\t\th=true;\n\t\t\t\t\tchar qq=ww[0];\n\t\t\t\t\trep(k,ww.size())if(qq!=ww[k])h=false;\n\t\t\t\t\tif(h)break;\n\t\t\t\t\tif(!tmp[ww]){out.pb(ww);tmp[ww]=true;}\n\t\t\t\t}\n\t\t\t\tif(h)break;\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t\t//rep(i,out.size())cout<<out[i]<<endl;\n\t\t\t//cout<<tmp.size()<<endl;\n\t\t\t//cout<<out.size()<<endl;\n\t\t\tif(h)break;\n\t\t\tco++;\n\t\t\tin=out;\n\t\t\t//cout<<\" \"<<in.size()<<endl;\n\t\t\tif(co==100)break;\n\t\t}\n\t\tif(co==100)cout<<\"NA\"<<endl;\n\t\telse cout<<co+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n//map<string,bool > passed;\nmap<string,int> dp;\n\nconst int INF=100000000;\n\n\nint bfs(string str){\n\n\t//passed[str]=true;\n\tset<string> used;\n\tqueue<string> *prv=new queue<string>();\n\tqueue<string> *nxt=new queue<string>();\n\tint cnt=0;\n\tprv->push(str);\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tstring s = prv->front();\n\t\t\tprv->pop();\n\t\t\tchar cl=s[0];\n\t\t\tbool f=false;\n\t\t\tfor(int i = 1; i < s.size(); i++){\n\t\t\t\tif(s[i]!=cl){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f){\n\t\t\t\tdelete prv,nxt;\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t\tbool flag[200];\n\t\t\tint minCnt=INF;\n\t\t\tfor(int i = 0; i < s.size()-1; i++){\n\t\t\t\tflag['r']=false;\n\t\t\t\tflag['g']=false;\n\t\t\t\tflag['b']=false;\n\t\t\t\tif(s[i]!=s[i+1]){\n\t\t\t\t\tflag[s[i]]=true;\n\t\t\t\t\tflag[s[i+1]]=true;\n\t\t\t\t\tif(!flag['r']){\n\t\t\t\t\t\tstring nstr=s;\n\t\t\t\t\t\tnstr[i]='r';\n\t\t\t\t\t\tnstr[i+1]='r';\n\t\t\t\t\t\tif(used.find(nstr)==used.end()){\n\t\t\t\t\t\t\tused.insert(nstr);\n\t\t\t\t\t\t\tnxt->push(nstr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//minCnt=min(minCnt,dfs(nstr)+1);\n//\t\t\t\t\t\tpassed[str]=false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!flag['g']){\n\t\t\t\t\t\tstring nstr=s;\n\t\t\t\t\t\tnstr[i]='g';\n\t\t\t\t\t\tnstr[i+1]='g';\n\t\t\t\t\t\tif(used.find(nstr)==used.end()){\n\t\t\t\t\t\t\tused.insert(nstr);\n\t\t\t\t\t\t\tnxt->push(nstr);\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n//\t\t\t\t\t\tpassed[str]=false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!flag['b']){\n\t\t\t\t\t\tstring nstr=s;\n\t\t\t\t\t\tnstr[i]='b';\n\t\t\t\t\t\tnstr[i+1]='b';\n\t\t\t\t\t\tif(used.find(nstr)==used.end()){\n\t\t\t\t\t\t\tused.insert(nstr);\n\t\t\t\t\t\t\tnxt->push(nstr);\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tpassed[str]=true;\n\t//\t\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n\t//\t\t\t\t\tpassed[str]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t\tcnt++;\n\t}\n\tdelete prv,nxt;\n\treturn INF;\n}\n\n//int dfs(string str){\n//\t//if(dp.find(str)!=dp.end()){\n//\t//\treturn dp[str];\n//\t//}\n//\tif(passed.find(str)!=passed.end()&&passed[str]){\n//\t\treturn INF;\n//\t}\n////\tcout<<str<<endl;\n//\tchar cl=str[0];\n//\tbool f=false;\n//\tfor(int i = 1; i < str.size(); i++){\n//\t\tif(str[i]!=cl){\n//\t\t\tf=true;\n//\t\t\tbreak;\n//\t\t}\n//\t}\n//\tif(!f)\n//\t\treturn 0;\n//\n//\tbool flag[200];\n//\tint minCnt=INF;\n//\tfor(int i = 0; i < str.size()-1; i++){\n//\t\tflag['r']=false;\n//\t\tflag['g']=false;\n//\t\tflag['b']=false;\n//\t\tif(str[i]!=str[i+1]){\n//\t\t\tflag[str[i]]=true;\n//\t\t\tflag[str[i+1]]=true;\n//\t\t\tif(!flag['r']){\n//\t\t\t\tstring nstr=str;\n//\t\t\t\tnstr[i]='r';\n//\t\t\t\tnstr[i+1]='r';\n//\t\t\t\tpassed[str]=true;\n//\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n//\t\t\t\tpassed[str]=false;\n//\t\t\t}\n//\t\t\telse if(!flag['g']){\n//\t\t\t\tstring nstr=str;\n//\t\t\t\tnstr[i]='g';\n//\t\t\t\tnstr[i+1]='g';\n//\t\t\t\tpassed[str]=true;\n//\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n//\t\t\t\tpassed[str]=false;\n//\t\t\t}\n//\t\t\telse if(!flag['b']){\n//\t\t\t\tstring nstr=str;\n//\t\t\t\tnstr[i]='b';\n//\t\t\t\tnstr[i+1]='b';\n//\t\t\t\tpassed[str]=true;\n//\t\t\t\tminCnt=min(minCnt,dfs(nstr)+1);\n//\t\t\t\tpassed[str]=false;\n//\t\t\t}\n//\t\t}\n//\t}\n//\t//if(minCnt!=INF)\n////\tdp[str]=minCnt;\n//\treturn minCnt;\n//}\n\nint main(){\n\n\tstring str;\n\twhile(cin>>str&&str!=\"0\"){\n\t\t//dp.clear();\n\t\t//passed.clear();\n\t\t//int ret=dfs(str);\n\t\tint ret=bfs(str);\n\t\tif(ret!=INF)\n\t\t\tcout<<ret<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define pp(a,b) push(make_pair(a,b))\ntypedef pair<string,int> NODE;\nchar color(char a, char b){\n\tif(a>b)swap(a,b);\n\tif(a==b)return a;\n\tif(a=='b' && b=='r')return 'g';\n\tif(a=='b' && b=='g')return 'r';\n\tif(a=='g' && b=='r')return 'b';\n\tcout << \"unko\" << endl;\n}\nint main(){\n\tstring n;\n\tchar p1,p2;\n\tmap<string,bool> done;\n\twhile(cin >> n && n != \"0\"){\n\t\tbool f = false;\n\t\tqueue<NODE> Q;\n\t\tdone.clear();\n\t\tQ.pp(n,0);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front();\n\t\t\tQ.pop();\n\t\t\tif( count(q.first.begin(),q.first.end(),'r') == q.first.size() || \n\t\t\t    count(q.first.begin(),q.first.end(),'g') == q.first.size() ||\n\t\t\t    count(q.first.begin(),q.first.end(),'b') == q.first.size()\n\t\t\t){\n\t\t\t\tcout << q.second << endl;\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t\tfor(int i=0;i+1<q.first.size();i++){\n\t\t\t\tp1 = q.first[i];p2 = q.first[i+1];\n\t\t\t\tq.first[i] = q.first[i+1] = color(p1,p2);\n\t\t\t\tif(!done[q.first]){\n\t\t\t\t\tQ.pp(q.first,q.second+1);\n\t\t\t\t\tdone[q.first] = true;\n\t\t\t\t}\n\t\t\t\tq.first[i] = p1;\n\t\t\t\tq.first[i+1] = p2;\n\t\t\t}\n\t\t}\n\t\tif(!f)cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nchar derv(char c1, char c2)\n{\n\tstring res(\"rgb\");\n\t\n\tres.erase(res.begin() + res.find(c1));\n\tres.erase(res.begin() + res.find(c2));\n\t\n\treturn res[0];\n}\n\nstring conv(string str, int p, char c)\n{\n\tstr[p + 0] = c;\n\tstr[p + 1] = c;\n\treturn str;\n}\n\nstring answer[16][4];\n\nvoid init()\n{\n\trep(i, 16)\n\t{\n\t\tanswer[i][0] = string().append(i, 'r');\n\t\tanswer[i][1] = string().append(i, 'g');\n\t\tanswer[i][2] = string().append(i, 'b');\n\t}\n}\n\ninline bool check(const string& str)\n{\n\tbool res = false;\n\t\n\trep(i, 3) res |= str == answer[str.size()][i];\n\t\n\treturn \tres;\n}\n\ntemplate<class T>\nstring toString(T sig)\n{\n\tstringstream ss;\n\t\n\tss << sig;\n\t\n\treturn ss.str();\n}\n\nint main()\n{\n\tinit();\n\t\n    for(string worm; cin >> worm && worm != \"0\";)\n\t{\n\t\tint n = worm.size();\n\t\tstring ans(\"NA\");\n\t\tqueue<pair<int, string> > que;\n\t\tmap<string, int> table;\n\t\t\n\t\t\n\t\tfor(que.push(mp(0, worm)); !que.empty(); que.pop())\n\t\t{\n\t\t\tstring sub(que.front().second);\n\t\t\tint times = que.front().first;\n\t\t\t\n\t\t\tif(table[sub] != 0) continue;\n\t\t\telse table[sub] = 1;\n\t\t\t\n\t\t\tif(check(sub))\n\t\t\t{\n\t\t\t\tans = toString(times);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, sub.size() - 1) if(sub[i] != sub[i + 1])\n\t\t\t{\n\t\t\t\tchar d = derv(sub[i], sub[i + 1]);\n\t\t\t\t\n\t\t\t\tque.push(mp(times + 1, conv(sub, i, d)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 100000000\ntypedef pair<string, int>P;\n\nstring S;\n\nint main(){\n\twhile(true){\n\tcin >> S;\n\tif(S == \"0\") return 0;\n\tqueue<P>que;\n\tset<string>st;\n\tque.push(P(S, 0));\n\tint res = INF;\n\twhile(!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tstring s = p.first;\n\t\tif(st.find(s) != st.end()) continue;\n\t\tst.insert(s);\n\t\tbool foo = true;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(s[i] != s[0]) foo = false;\n\t\t}\n\t\tif(foo){\n\t\t\tres = p.second;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < s.size() - 1; i++){\n\t\t\tif(s[i] != s[i + 1]){\n\t\t\t\tif(s[i] == 'g'&&s[i+1] == 'b'){\n\t\t\t\t\ts[i] = s[i+1] = 'r';\n\t\t\t\t\tque.push(P(s, p.second + 1));\n\t\t\t\t\ts[i] = 'g';s[i+1]='b';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'b'&&s[i+1] == 'g'){\n\t\t\t\t\ts[i] = s[i+1] = 'r';\n\t\t\t\t\tque.push(P(s, p.second + 1));\n\t\t\t\t\ts[i] = 'b';s[i+1]='g';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'r'&&s[i+1] == 'g'){\n\t\t\t\t\ts[i] = s[i+1] = 'b';\n\t\t\t\t\tque.push(P(s, p.second + 1));\n\t\t\t\t\ts[i] = 'r';s[i+1]='g';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'g'&&s[i+1] == 'r'){\n\t\t\t\t\ts[i] = s[i+1] = 'b';\n\t\t\t\t\tque.push(P(s, p.second + 1));\n\t\t\t\t\ts[i] = 'g';s[i+1]='r';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'r'&&s[i+1] == 'b'){\n\t\t\t\t\ts[i] = s[i+1] = 'g';\n\t\t\t\t\tque.push(P(s, p.second + 1));\n\t\t\t\t\ts[i] = 'r';s[i+1]='b';\n\t\t\t\t}\n\t\t\t\tif(s[i] == 'b'&&s[i+1] == 'r'){\n\t\t\t\t\ts[i] = s[i+1] = 'g';\n\t\t\t\t\tque.push(P(s, p.second + 1));\n\t\t\t\t\ts[i] = 'b';s[i+1]='r';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(res == INF) cout <<\"NA\" << endl;\n\telse cout << res << endl;\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct nc{\n\tint number;\n\tint count;\n};\nint main() {\n\tmap<string, int> msi;\n\tFOR(i, 2, 11){\n\t\tqueue<string> qs;\n\t\tREP(j, 3){\n\t\t\tstring s2;\n\t\t\tif (j == 0)REP(k, i)s2 += 'r';\n\t\t\tif (j == 1)REP(k, i)s2 += 'g';\n\t\t\tif (j == 2)REP(k, i)s2 += 'b';\n\t\t\tmsi.insert({ s2, 0 });\n\t\t\tqs.push(s2);\n\t\t}\n\t\twhile (!qs.empty()){\n\t\t\tstring s3 = qs.front(); qs.pop();\n\t\t\tREP(j, i - 1){\n\t\t\t\tif (s3[j] == 'r' && s3[j + 1] == 'r'){\n\t\t\t\t\tstring s4 = s3;\n\t\t\t\t\ts4[j] = 'g'; s4[j+1] = 'b';\n\t\t\t\t\tif (msi.find(s4) == msi.end()){\n\t\t\t\t\t\tmsi.insert({ s4, msi[s3] + 1 });\n\t\t\t\t\t\tqs.push(s4);\n\t\t\t\t\t}\n\t\t\t\t\ts4[j] = 'b'; s4[j + 1] = 'g';\n\t\t\t\t\tif (msi.find(s4) == msi.end()){\n\t\t\t\t\t\tmsi.insert({ s4, msi[s3] + 1 });\n\t\t\t\t\t\tqs.push(s4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s3[j] == 'g' && s3[j + 1] == 'g'){\n\t\t\t\t\tstring s4 = s3;\n\t\t\t\t\ts4[j] = 'b'; s4[j + 1] = 'r';\n\t\t\t\t\tif (msi.find(s4) == msi.end()){\n\t\t\t\t\t\tmsi.insert({ s4, msi[s3] + 1 });\n\t\t\t\t\t\tqs.push(s4);\n\t\t\t\t\t}\n\t\t\t\t\ts4[j] = 'r'; s4[j + 1] = 'b';\n\t\t\t\t\tif (msi.find(s4) == msi.end()){\n\t\t\t\t\t\tmsi.insert({ s4, msi[s3] + 1 });\n\t\t\t\t\t\tqs.push(s4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s3[j] == 'b' && s3[j + 1] == 'b'){\n\t\t\t\t\tstring s4 = s3;\n\t\t\t\t\ts4[j] = 'r'; s4[j + 1] = 'g';\n\t\t\t\t\tif (msi.find(s4) == msi.end()){\n\t\t\t\t\t\tmsi.insert({ s4, msi[s3] + 1 });\n\t\t\t\t\t\tqs.push(s4);\n\t\t\t\t\t}\n\t\t\t\t\ts4[j] = 'g'; s4[j + 1] = 'r';\n\t\t\t\t\tif (msi.find(s4) == msi.end()){\n\t\t\t\t\t\tmsi.insert({ s4, msi[s3] + 1 });\n\t\t\t\t\t\tqs.push(s4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstring s;\n\twhile (cin >> s, s != \"0\"){\n\t\tif (msi.find(s) != msi.end()){\n\t\t\tcout << msi[s] << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<map>\nusing namespace std;\n#define INFTY (1<<21)\n\nbool isSameColor( string state ){\n    for ( int i = 1; i < state.size(); i++ ){\n        if ( state[i-1] != state[i] ) return false;\n    }\n    return true;\n}\n\nchar getColor( char c1, char c2 ){\n    if ( c1 == 'g' ) return (c2=='r' ? 'b' : 'r');\n    else if ( c1 == 'b' ) return (c2=='r' ? 'g' : 'r');\n    else if ( c1 == 'r' ) return (c2=='b' ? 'g' : 'b');\n}\n\nint bfs(string s){\n    queue<string> Q;\n    map<string, bool> V;\n    map<string, int> D;\n\n    Q.push(s);\n    V[s] = true;\n    D[s] = 0;\n    string u, v;\n    \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if ( isSameColor(u) ) return D[u];\n        for ( int i = 1; i < u.size(); i++ ){\n            if ( u[i-1] != u[i] ){\n                v = u;\n                v[i-1] = v[i] = getColor(u[i-1], u[i]);\n                if ( !V[v] ){\n                    V[v] = true;\n                    D[v] = D[u] + 1;\n                    Q.push(v);\n                }\n            }\n        }\n    }\n\n    return INFTY;\n}\n\nint main(){\n    string initial;\n    while( cin >> initial ){\n        if ( initial == \"0\" ) break;\n        int cost = bfs( initial );\n        if ( cost == INFTY ) cout << \"NA\" << endl;\n        else cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<string,int> P;\nint main() {\n\tstring str;\n\twhile(cin>>str,str!=\"0\") {\n\t\tqueue<P> Q;\n\t\tQ.push(P(str,0));\n\t\tset<string> S;\n\t\tS.insert(str);\n\t\twhile(!Q.empty()) {\n\t\t\tP p=Q.front(); Q.pop();\n\t\t\tbool Flag=true;\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tif(p.first[i]!=p.first[i+1]) {Flag=false;break;}\n\t\t\t}\n\t\t\tif(Flag) {printf(\"%d\\n\",p.second); break;}\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tstring tmp=p.first;\n\t\t\t\tif((p.first[i]=='r' && p.first[i+1]=='g') || (p.first[i+1]=='r' && p.first[i]=='g')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='b';\n\t\t\t\t}else if((p.first[i]=='r' && p.first[i+1]=='b') || (p.first[i+1]=='r' && p.first[i]=='b')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='g';\n\t\t\t\t}else if((p.first[i]=='b' && p.first[i+1]=='g') || (p.first[i+1]=='b' && p.first[i]=='g')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='r';\n\t\t\t\t}else continue;\n\t\t\t\tif(S.find(tmp)==S.end()) {\n\t\t\t\t\tS.insert(tmp);\n\t\t\t\t\tQ.push(P(tmp,p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nchar hage[] = {'r','g','b'};\nchar hoge(char a, char b) {\n  REP(i,3)\n    if (a != hage[i] && b != hage[i])\n      return hage[i];\n}\ntypedef pair<int, string> pis;\n\nint bfs(string s) {\n  int res = INF;\n  queue<pis> Q;\n  map<string, bool> ma;\n  Q.push(pis(0,s));\n  while(!Q.empty()) {\n    pis p = Q.front(); Q.pop();\n    string ss = p.second;\n    if (ma[ss]) continue;\n    ma[ss] = true;\n//    cout << p.first << \" \" <<ss << endl;\n    bool f = true;\n    REP(i, ss.length()-1)\n      if (ss[i] != ss[i+1])\n        f = false;\n    if (f) return p.first;\n    REP(i, ss.length()-1) {\n      if (ss[i] != ss[i+1]) {\n        string sss = ss;\n        sss[i] = sss[i+1] = hoge(ss[i], ss[i+1]);\n        Q.push(pis(p.first + 1, sss));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  string s;\n  while(cin >> s, s != \"0\") {\n    int ans = bfs(s);\n    if (ans >= 0)\n      cout << ans << endl;\n    else\n      cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\n  string s,str,col[3];\n  queue<string> que;\n  map<string,int> mp;\n  int flag;\n  while(1){\n    cin >> s;\n    if(s == \"0\") break;\n    flag = 1;\n    que.push(s);\n    mp[s] = 0;\n    for(int i=0;i<3;i++) col[i] = \"\";\n    for(int i=0;i<s.size();i++){\n      col[0] += \"r\";\n      col[1] += \"b\";\n      col[2] += \"g\";\n    }\n    while(!que.empty()){\n      if(que.front()==col[0]){\n\tcout << mp[col[0]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[1]){\n\tcout << mp[col[1]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[2]){\n\tcout << mp[col[2]] << endl;\n\tflag--;\n\tbreak;\n      }\n      \n      for(int i=0;i<s.size()-1;i++){\n\tstr = que.front();\n\tif(str[i] != str[i+1]){\n\t  if(str[i] != 'r' && str[i+1] != 'r'){\n\t    str[i] = 'r';\n\t    str[i+1] = 'r';\n\t  } else if(str[i] != 'b' && str[i+1] != 'b'){\n\t    str[i] = 'b';\n\t    str[i+1] = 'b';\n\t  }else if(str[i] != 'g' && str[i+1] != 'g'){\n\t    str[i] = 'g';\n\t    str[i+1] = 'g';\n\t  }\n\t  if(mp.find(str) == mp.end()){\n\t    que.push(str);\n\t    mp[str] = mp[que.front()]+1;\n\t  }\n\t}\n      }\n      que.pop();\n    }\n    while(!que.empty()) que.pop();\n    if(flag) cout << \"NA\" << endl;\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nstruct state {\n    string worm;\n    int count;\n\n    state(string a, int b): worm(a), count(b) {}\n};\n\nchar change_to(char a, char b) {\n    if (a > b) swap(a, b);\n    if (a == 'b' && b == 'g') return 'r';\n    if (a == 'b' && b == 'r') return 'g';\n    return 'b';\n}\n\nint main() {\n    string S;\n    while (true) {\n        cin >> S;\n        if (S == \"0\") break;\n        \n        set<string> visited;\n        queue<state> que;\n\n        int ans = -1;\n\n        que.emplace(S, 0);\n        while (!que.empty()) {\n            state st = que.front(); que.pop();\n\n            if (visited.find(st.worm) != end(visited))\n                continue;\n            visited.insert(st.worm);\n\n            string worm = st.worm;\n\n            bool ok = true;\n            for (int j = 1; j < worm.size(); ++j) {\n                if (worm[j] != worm[0]) {\n                    ok = false; break;\n                }\n            }\n            \n            if (ok) {\n                ans = st.count;\n                break;\n            }\n\n            visited.insert(worm);\n            for (int j = 0; j < worm.size()-1; ++j) {\n                if (worm[j] != worm[j+1]) {\n                    char c1 = worm[j], c2 = worm[j+1];\n                    worm[j] = worm[j+1] = change_to(worm[j], worm[j+1]);\n                    que.emplace(worm, st.count+1);\n                    worm[j] = c1, worm[j+1] = c2;\n                }\n            }\n        }\n\n        if (ans == -1) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<string,int> P;\nint main() {\n\tstring str;\n\twhile(cin>>str,str!=\"0\") {\n\t\tqueue<P> Q;\n\t\tQ.push(P(str,0));\n\t\tset<string> S;\n\t\tS.insert(str);\n\t\twhile(!Q.empty()) {\n\t\t\tP p=Q.front(); Q.pop();\n\t\t\tbool Flag=true;\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tif(p.first[i]!=p.first[i+1]) {Flag=false;break;}\n\t\t\t}\n\t\t\tif(Flag) {printf(\"%d\\n\",p.second); break;}\n\t\t\tfor(int i=0;i<p.first.size()-1;i++) {\n\t\t\t\tstring tmp=p.first;\n\t\t\t\tif((p.first[i]=='r' && p.first[i+1]=='g') || (p.first[i+1]=='r' && p.first[i]=='g')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='b';\n\t\t\t\t}else if((p.first[i]=='r' && p.first[i+1]=='b') || (p.first[i+1]=='r' && p.first[i]=='b')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='g';\n\t\t\t\t}else if((p.first[i]=='b' && p.first[i+1]=='g') || (p.first[i+1]=='b' && p.first[i]=='g')) {\n\t\t\t\t\ttmp[i]=tmp[i+1]='r';\n\t\t\t\t}else continue;\n\t\t\t\tif(S.find(tmp)==S.end()) {\n\t\t\t\t\tS.insert(tmp);\n\t\t\t\t\tQ.push(P(tmp,p.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvoid solve(string s){\n  set<string> app;\n\n  queue<pair<int,string> > q;\n  q.push(mp(0,s));\n  while(!q.empty()){\n    int cc=q.front().F;\n    s=q.front().S;\n    q.pop();\n    if(app.count(s))continue;\n    app.insert(s);\n    bool end=true;\n    rep(i,SZ(s)-1){\n      if(s[i]!=s[i+1]){\n        end=false;\n        break;\n      }\n    }\n\n    if(end){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(s)-1){\n      if(s[i]==s[i+1])continue;\n      string t=s;\n      char a=min(s[i],s[i+1]);\n      char b=max(s[i],s[i+1]);\n\n      if(a!='r' && b!='r')t[i]=t[i+1]='r';\n      else if(a!='g' && a!='g')t[i]=t[i+1]='g';\n      else t[i]=t[i+1]='b';\n      if(app.count(t))continue;\n      q.push(mp(cc+1,t));\n    }\n  }\n  cout<<\"NA\"<<endl;\n}\n\nmain(){\n  string s;\n  while(cin>>s,s!=\"0\")\n    solve(s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 30)\ntypedef pair<int, int> P;\ntypedef pair<int, string> PS;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nchar color(char s, char l){\n\tif(s + l == 'r' + 'g') return 'b';\n\tif(s + l == 'r' + 'b') return 'g';\n\tif(s + l == 'b' + 'g') return 'r';\n\treturn 0;\n}\n\nint main(void){\n\t\n\tstring S;\n\twhile(cin >> S){\n\t\tif(S == \"0\")break;\n\t\tint str_size = S.size();\n\t\tstring R, G, B;\n\t\trep(i, str_size){\n\t\t\tR += 'r';\n\t\t\tG += 'g';\n\t\t\tB += 'b';\n\t\t}\n\t\tbool flag = 0;\n\t\tqueue<PS> que;\n\t\tque.push(PS(0, S));\n\t\tmap<string, bool> state;\n\t\twhile(que.size()){\n\t\t\tPS p = que.front(); que.pop();\n\t\t\tstring str = p.second;\n\t\t\t\n\t\t\tif(str == R || str == G || str == B){\n\t\t\t\tflag = 1;\n\t\t\t\tcout << p.first << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(state[str]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstate[str] = 1;\n\n\t\t\trep(i, str.size()-1){\n\t\t\t\tif(str[i] != str[i+1]){\n\t\t\t\t\tchar L = color(str[i], str[i+1]);\n\t\t\t\t\tstring SS = str;\n\t\t\t\t\tSS[i] = L;\n\t\t\t\t\tSS[i+1] = L;\n\t\t\t\t\tque.push(PS(p.first+1,SS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag) cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\n#include <cstdio>\n#include <complex>\n#include <cstring>\n#include <queue>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n#define pb(a) push_back(a)\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\ntypedef pair<string ,int> P;\n\nint bfs(string s){\n  queue<P> que;\n  que.push(P(s,0));\n  \n  map<string,int> d;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    \n    if(d[p.first])continue;\n    string st = p.first;\n    \n    bool f = false;\n    rep(i,st.size()-1){\n      if(st[i]!=st[i+1]){ // find different words\n\tf = true;\n\tbreak;\n      }\n    }\n\n    if(!f)return p.second;\n    \n    d[p.first] = second;\n    rep(i,st.size()-1){\n      if(st[i] != st[i+1]){\n\tchar t;\n\tstring nx;\n      }\n    }\n    \n  }\n  \n}\n\nint main(void){\n  string s;\n  while(cin>>s,s!=\"0\"){\n    int ret = bfs(s);\n    if(ret>=0)cout<<ret<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <set>\n\nchar change (char c1, char c2);\nbool simple_check(std::string str); \nvoid bfs(std::string str); \n\n\nint main(void) {\n    std::string str; \n\n    std::cin >> str;\n    while (str != \"0\") {\n        bfs(str); \n        std::cin >> str;\n    }\n\n    return 0;\n}\n\nchar change (char c1, char c2) {\n    char new_c;\n    if (c1 != 'r' && c2 != 'r') {\n        new_c = 'r'; \n    } else if (c1 != 'g' && c2 != 'g') {\n        new_c = 'g'; \n    } else if (c1 != 'b' && c2 != 'b') {\n        new_c = 'b'; \n    } else {\n        std::cerr << \"????????????\" << std::endl;\n    }\n    return new_c;\n}\n\nbool simple_check(std::string str) {\n    bool flag = true;\n    for (int i = 0; i < str.size() - 1; i++) {\n        if (str[i] != str[i + 1]) {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\nvoid bfs(std::string str) {\n    std::pair<std::string, int> now;\n    std::queue<std::pair<std::string, int> > que; \n    std::set<std::string> st; \n\n    //use in while loop\n    std::string str_cp;\n    char remained_color;\n\n    que.push(std::make_pair(str, 0));\n    st.insert(str);\n\n\n    while (! que.empty()) {\n        now = que.front();\n        que.pop();\n\n        // ??¨?????????????????????break?????????\n        if (simple_check(now.first) == true) {\n            std::cout << now.second << std::endl; \n            return;\n        }\n\n\n        for (int i = 0; i < str.size() - 1; i++) {\n            str_cp = now.first;\n            if (str_cp[i] != str_cp[i + 1]) {\n                remained_color = change(str_cp[i], str_cp[i + 1]);\n                str_cp[i] = remained_color;\n                str_cp[i + 1] = remained_color;\n            }\n            if (st.count(str_cp) == 0) {\n                que.push(std::make_pair(str_cp,now.second + 1)); \n                st.insert(str_cp);\n            }\n        }\n    }\n\n    std::cout << \"NA\" << std::endl;\n    return; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\n  string s,col[3];\n  queue<string> que;\n  map<string,int> mp;\n  int flag;\n\n  while(1){\n    cin >> s;\n    if(s == \"0\") break;\n    flag = 1;\n    que.push(s);\n    mp[s] = 0;\n    for(int i=0;i<3;i++) col[i] = \"\";\n    for(int i=0;i<s.size();i++){\n      col[0] += \"r\";\n      col[1] += \"b\";\n      col[2] += \"g\";\n    }\n    while(!que.empty()){\n      if(que.front()==col[0]){\n\tcout << mp[col[0]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[1]){\n\tcout << mp[col[1]] << endl;\n\tflag--;\n\tbreak;\n      }\n      if(que.front()==col[2]){\n\tcout << mp[col[2]] << endl;\n\tflag--;\n\tbreak;\n      }\n      for(int i=0;i<s.size()-1;i++){\n\tif(que.front()[i] != que.front()[i+1]){\n\t  s = que.front();\n\t  if(s[i] != 'r' && s[i+1] != 'r'){\n\t    s[i] = 'r';\n\t    s[i+1] = 'r';\n\t  } else if(s[i] != 'b' && s[i+1] != 'b'){\n\t    s[i] = 'b';\n\t    s[i+1] = 'b';\n\t  }else if(s[i] != 'g' && s[i+1] != 'g'){\n\t    s[i] = 'g';\n\t    s[i+1] = 'g';\n\t  }\n\t  if(mp.find(s) == mp.end()){\n\t    que.push(s);\n\t    mp[s] = mp[que.front()]+1;\n\t  }\n\t}\n      }\n      que.pop();\n    }\n    while(!que.empty()) que.pop();\n    if(flag) cout << \"NA\" << endl;\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <stack>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<string, int>;\nusing edge = struct\n{\n    int to;\n    int cost;\n};\n\nint wfs(string worm)\n{\n    queue<P> que;\n    que.push(P(worm, 0));\n\n    map<string, int> mp;\n\n    while (!que.empty())\n    {\n        P p = que.front();\n        que.pop();\n\n        string tmp = p.first;\n\n        //if(mp[p.first]) continue;\n\n        bool flag = true;\n\n        for (int i = 0; i < tmp.size() - 1; i++)\n        {\n            if (tmp[i] != tmp[i + 1])\n            {\n                flag = false;\n                break;\n            }\n        }\n\n        if (flag) return p.second;\n\n        //mp[p.first] = p.second;\n\n        for(int i = 0; i < tmp.size() - 1; i++)\n        {\n            if(tmp[i] == tmp[i + 1]) continue;\n\n            string nworm = tmp;\n\n            if(tmp[i] != 'g' && tmp[i + 1] != 'g')\n            {\n                nworm[i] = 'g';\n                nworm[i + 1] = 'g';\n            }\n            else if(tmp[i] != 'b' && tmp[i + 1] != 'b')\n            {\n                nworm[i] = 'b';\n                nworm[i + 1] = 'b';\n            }\n            else\n            {\n                nworm[i] = 'r';\n                nworm[i + 1] = 'r';\n            }\n\n            que.push(P(nworm, p.second + 1));\n\n        }        \n    }\n    return -1;\n}\n\nint main()\n{\n    string input;\n\n    while(cin >> input && input != \"0\")\n    {\n        cout << (wfs(input) ? to_string(wfs(input)) : \"NA\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair <string, int> P;\n\n#define mp(a, b) make_pair(a, b)\n\nchar diff(char a, char b)\n{\n\tif (a != 'r' && b != 'r') return 'r';\n\tif (a != 'g' && b != 'g') return 'g';\n\tif (a != 'b' && b != 'b') return 'b';\n\treturn 'a';\n}\n\nbool check(string str)\n{\n\tchar c = str[0];\n\tfor (int i = 0; i < str.length(); i++){\n\t\tif (c != str[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tstring str;\n\tmap <string, bool> memo;\n\n\twhile (cin >> str){\n\t\tif (str == \"0\") return 0;\n\n\t\tint ret = -1, a;\n\t\tqueue < P > q;\n\t\tq.push(mp(str, 0));\n\t\twhile (!q.empty()){\n\t\t\tP now = q.front();\n\t\t\tq.pop();\n\t\t\tif (memo[now.first]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemo[now.first] = true;\n\t\t\tif (check(now.first)){\n\t\t\t\tret = now.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < now.first.length()-1; i++){\n\t\t\t\tif (now.first[i] != now.first[i + 1]){\n\t\t\t\t\tstring tmp = now.first;\n\t\t\t\t\ttmp[i] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\ttmp[i + 1] = diff(now.first[i], now.first[i + 1]);\n\t\t\t\t\tq.push(mp(tmp, now.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret >= 0) cout << ret << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nchar hage[] = {'r','g','b'};\nchar hoge(char a, char b) {\n  REP(i,3)\n    if (a != hage[i] && b != hage[i])\n      return hage[i];\n}\ntypedef pair<int, string> pis;\n\nint bfs(string s) {\n  int res = INF;\n  queue<pis> Q;\n  Q.push(pis(0,s));\n  while(!Q.empty()) {\n    pis p = Q.front(); Q.pop();\n    if (p.first > s.length()) continue;\n    string ss = p.second;\n//    cout << p.first << \" \" <<ss << endl;\n    bool f = true;\n    REP(i, ss.length()-1)\n      if (ss[i] != ss[i+1])\n        f = false;\n    if (f) return p.first;\n    REP(i, ss.length()-1) {\n      if (ss[i] != ss[i+1]) {\n        string sss = ss;\n        sss[i] = sss[i+1] = hoge(ss[i], ss[i+1]);\n        Q.push(pis(p.first + 1, sss));\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  string s;\n  while(cin >> s, s != \"0\") {\n    int ans = bfs(s);\n    if (ans >= 0)\n      cout << ans << endl;\n    else\n      cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<string, int> P;\n\nvoid solve()\n{\n\tstring str;\n\twhile(cin >> str)\n\t{\n\t\tif(str == \"0\")\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int j = 0; j < str.size() - 1; ++j)\n\t\t{\n\t\t\tif(str[j] != str[j + 1])\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> Que;\n\t\tQue.push(make_pair(str, 0));\n\t\tqueue<P> NextQue;\n\t\tmap<string, int> Map;\n\t\tint step = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tif(step == str.size())\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < str.size() - 1; ++i)\n\t\t\t\t{\n\t\t\t\t\tstring body = Que.front().first;\n\t\t\t\t\tif(body[i] == 'b' && body[i + 1] == 'g')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'b' && body[i + 1] == 'r')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'g' && body[i + 1] == 'b')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'g' && body[i + 1] == 'r')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'r' && body[i + 1] == 'b')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\telse if(body[i] == 'r' && body[i + 1] == 'g')\n\t\t\t\t\t{\n\t\t\t\t\t\tbody[i] = body[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor(int j = 0; j < str.size() - 1; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(body[j] != body[j + 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << Que.front().second + 1 << endl;\n\t\t\t\t\t\tgoto NEXT;\n\t\t\t\t\t}\n\t\t\t\t\tif(!Map[body])\n\t\t\t\t\t{\n\t\t\t\t\t\tNextQue.push(make_pair(body, Que.front().second + 1));\n\t\t\t\t\t}\n\t\t\t\t\tMap[body]++;\n\t\t\t\t}\n\t\t\t\tQue.pop();\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t\t++step;\n\t\t}\nNEXT:\n\t\t;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n  string s;\n  int c;\n  State(string s, int c) : s(s), c(c){}\n};\n\nbool check(string s){\n  for(int i = 0 ; i < (int)s.size()-1 ; i++){\n    if(s[i] != s[i+1]) return false;\n  }\n  return true;\n}\n\nstring change(string s){\n  sort(s.begin(), s.end());\n  if(s[0] == 'b' && s[1] == 'g') return \"rr\";\n  if(s[0] == 'b' && s[1] == 'r') return \"gg\";\n  if(s[0] == 'g' && s[1] == 'r') return \"bb\";\n}\n\nint bfs(string s){\n  queue<State> que;\n  que.push(State(s, 0));\n  \n  set<string> S;\n  \n  while(!que.empty()){\n    State q = que.front(); que.pop();\n    if( check(q.s) ) return q.c;\n    \n    if(S.find(q.s) != S.end()) continue;\n    S.insert(q.s);\n    \n    for(int i = 0 ; i < (int)q.s.size()-1 ; i++){\n      string t = q.s.substr(i, 2);\n      if(t != \"rr\" && t != \"gg\" && t != \"bb\"){\n\tque.push(State(q.s.substr(0, i) + change(t) + q.s.substr(i+2), q.c+1));\n      }\n    }   \n  }\n  return -1;\n}\n\nint main(){\n  string s;\n  while(cin >> s && s != \"0\"){\n    int ans = bfs(s);\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2013-5\n\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <time.h>\n#define mp make_pair\n#define fs first\n#define sc second\n#define rep(x,n) for(int x = 0;x < n;x ++)\n#define Rep(x,n) for(int x = 1;x <= n;x ++)\nusing namespace std;\n\nchar retcol(char c1,char c2){\n    if((c1 == 'g' && c2== 'r')||(c1 == 'r' && c2== 'g'))\n        return 'b';\n    else if((c1 == 'b' && c2 == 'r')||(c1 == 'r' && c2 == 'b'))\n        return 'g';\n    else\n        return 'r';\n}\n\nint n;\n\nbool issame(string xx){\n    int nu = xx.size();\n    rep(i,nu-1)\n        if(xx[i]!=xx[i+1])\n            return 0;\n    return 1;\n}\n\nint main(){\n\n    bool tf = 0;\n    string str,next;\n    cout << issame(\"asfd\")<<endl;\n    cout << issame(\"aaaa\")<<endl;\n\n    while(cin >> str&&str != \"0\"){\n        queue<string> que;\n        que.push(str);\n        tf = 0;\n        n = str.size();\n        //この時点で判定\n        if(issame(str)){\n            printf(\"0\\n\");\n            continue;\n        }\n        map<string,int> flag;\n        flag.insert(make_pair(str,0));\n        //探索\n        while(!que.empty()&& tf == 0){\n            string str = que.front();\n            que.pop();\n            if(flag.find(str)==flag.end())\n                continue;\n            int num = flag.find(str)->second;\n            rep(i,n-1){\n                if(str[i]!=str[i+1]){\n                    next = str;\n                    next[i]=retcol(str[i],str[i+1]);\n                    next[i+1]=next[i];\n                    if(issame(next)){\n                        tf = 1;\n                        cout << num + 1 << endl;\n                        break;\n                    }\n                    if(flag.find(next)==flag.end()){\n                        que.push(next);\n                        flag.insert(make_pair(next,num+1));\n                    }\n                    \n                }\n            }\n        }\n        if(tf == 0){\n            printf(\"NA\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nbool check(string s){\n    for(int i=0; i< s.size()-1; i++) if(s[i] != s[i+1]) return false;\n    return true;\n}\n\nint main(){\n    string s;\n    while(cin >> s, s!= \"0\"){\n        queue<pair<string, int> > que;\n        que.push(make_pair(s, 0));\n        int ret = 100;\n\n        map<string, int> m;\n        while(que.size()){\n            s = que.front().first; int count = que.front().second; que.pop();\n\n            if(ret < count) continue;\n            if(check(s))ret = count;\n\n            if(m[s] == 0 || count+1 < m[s]){\n                string tmp = s;\n                m[s] = count+1;\n                string t = \"rgb\";\n                vector<int> v(3); v[0] = 0; v[1] = 1; v[2] = 2;\n                map<string, int> mp; mp[\"r\"] = 0; mp[\"g\"] = 1; mp[\"b\"] = 2;\n                do{\n                    for(int i=0; i< s.size(); i++){\n                        s[i] = t[v[mp[s.substr(i, 1)]]];\n                    }\n                    m[s] = count+1;\n                }while(next_permutation(v.begin(), v.end()));\n                s = tmp;\n            }\n            else continue;\n\n            for(int i=0; i< s.size()-1; i++){\n                if(s[i] != s[i+1]){\n                    string t = s.substr(i, 2);\n                    sort(t.begin(),t.end());\n                    if(t == \"br\") t = \"gg\";\n                    else if(t == \"bg\") t = \"rr\";\n                    else if(t == \"gr\") t = \"bb\";\n                    que.push(make_pair(s.substr(0, i)+t+s.substr(i+2), count+1));\n                }\n            }\n        }\n        if(ret == 100) cout << \"NA\" << endl;\n        else cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n  queue<P> que;\n  que.push(P(worm, 0));\n\n  map<string, int>  d;\n\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n\n    if(d[p.first])  continue;\n\n    string str = p.first;\n\n    bool flag = true;\n    for(int i = 0; i < str.size()-1; i++){\n      if(str[i] != str[i+1]){\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag) return p.second;\n\n    d[p.first] = p.second;\n\n    for(int i = 0; i < str.size()-1; i++){\n      if(str[i] != str[i+1]){\n        string next;\n        char tmp;\n        if(str[i] != 'r' && str[i+1] != 'r'){\n          tmp = 'r';\n        }else if(str[i] != 'b' && str[i+1] != 'r'){\n          tmp = 'b';\n        }else{\n          tmp = 'g';\n        }\n\n        next = str;\n        next[i] = next[i+1] = tmp;\n        que.push(P(next, p.second+1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  string worm;\n  while(cin >> worm && worm != \"0\"){\n    int ans = bfs(worm);\n    if(ans >= 0)  cout << ans << endl;\n    else cout << \"NA\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<string, char> rule = { \n\t{\"rb\", 'g'},\n\t{\"br\", 'g'},\n\t{\"rg\", 'b'},\n\t{\"gr\", 'b'},\n\t{\"gb\", 'r'},\n\t{\"bg\", 'r'} };\n\nbool isjudge(string s){\n\tbool r = true;\n\tchar c = s[0];\n\tfor(int i = 0;i < s.length();++i){\n\t\tr &= (c == s[i]);\n\t}\n\treturn r;\n}\n\nint bfs(string s){\n\tqueue<string> q;\n\tmap<string, int> v;\n\tv[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstring t = q.front(), n;\n\t\tchar c;\n\t\tq.pop();\n\t\tif(isjudge(t)) return v[t];\n\t\tfor(int i = 0;i < (t.length() - 1);++i){\n\t\t\tif(t[i] != t[i + 1]){\n\t\t\t\tn = t;\n\t\t\t\tc = rule[t.substr(i, 2)];\n\t\t\t\tn[i] = n[i + 1] = c;\n\t\t\t\tif(v.count(n) == 0){\n\t\t\t\t\tq.push(n);\n\t\t\t\t\tv[n] = v[t] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring s;\n\tint c;\n\twhile(cin >> s){\n\t\tif(s == \"0\") break;\n\t\telse {\n\t\t\tc = bfs(s);\n\t\t\tif(c == -1) cout << \"NA\" << endl;\n\t\t\telse cout << c << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n\n#define Q_MAX 1000000\n#define N 11\n\ntypedef struct {\n\tint cost;\n\tchar color[N];\n} QUEUE;\n\n\nint main(void)\n{\n\tchar bug[N];\n\tint i, j;\n\tstatic QUEUE que[Q_MAX];\n\tint sq, eq;\n\tstatic char used[Q_MAX][N];\n\t\n\tdo {\n\t\tint count = -1;\n\t\tscanf(\"%s\", bug);\n\t\t\n\t\tif (bug[0] == '0') break;\n\t\t\n\t\tsq = 0;\n\t\teq = 1;\n\t\tmemset(que, 0, sizeof(que));\n\t\tmemset(used, 0, sizeof(used));\n\t\tque[sq].cost = 0;\n\t\tstrcpy(que[sq].color, bug);\n\t\t\n\t\twhile (sq != eq){\n\t\t\tchar color[N];\n\t\t\tint cost = que[sq].cost;\n\t\t\t\n\t\t\tstrcpy(color, que[sq].color);\n\t\t\tsq = (sq + 1) % Q_MAX;\n\t\t\t\n\t\t\tif (strncmp(color, \"rrrrrrrrrr\", strlen(color)) == 0 ||\n\t\t\tstrncmp(color, \"gggggggggg\", strlen(color)) == 0 ||\n\t\t\tstrncmp(color, \"bbbbbbbbbb\", strlen(color)) == 0){\n\t\t\t\tcount = (cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; color[i + 1] != '\\0'; i++){\n\t\t\t\tif (color[i] != color[i + 1]){\n\t\t\t\t\tchar buf[N];\n\t\t\t\t\tchar check[3] = {1, 1, 1};\n\t\t\t\t\tchar flag = 1;\n\t\t\t\t\t\n\t\t\t\t\tstrcpy(buf, color);\n\t\t\t\t\tif (buf[i] == 'r' || buf[i + 1] == 'r') check[0] = 0;\n\t\t\t\t\tif (buf[i] == 'g' || buf[i + 1] == 'g') check[1] = 0;\n\t\t\t\t\tif (buf[i] == 'b' || buf[i + 1] == 'b') check[2] = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (check[0] == 1){\n\t\t\t\t\t\tbuf[i] = 'r';\n\t\t\t\t\t\tbuf[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[1] == 1){\n\t\t\t\t\t\tbuf[i] = 'g';\n\t\t\t\t\t\tbuf[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[2] == 1){\n\t\t\t\t\t\tbuf[i] = 'b';\n\t\t\t\t\t\tbuf[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif (flag == 1){\n\t\t\t\t\t\tque[eq].cost = cost + 1;\n\t\t\t\t\t\tstrcpy(que[eq].color, buf);\n\t\t\t\t\t\tstrcpy(used[eq], buf);\n\t\t\t\t\t\teq = (eq + 1) % Q_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != -1){\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\t\n\t} while (1);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint ar[11], ag[11], ab[11];\nbool checked[59049];\nint p3[11];\nint change[9] = {0, 8, 4, 8, 4, 0, 4, 0, 8};\n\nint conv(string s) {\n\tint ret = 0;\n\tfor (int i=0; i<(int)s.size(); ++i) {\n\t\tret *= 3;\n\t\tif (s[i] == 'g') ret += 1;\n\t\tif (s[i] == 'b') ret += 2;\n\t}\n\treturn ret;\n}\n\nint rotate(int x, int n) {\n\tint ret = 0;\n\tfor (int i=0; i<n; ++i) {\n\t\tret = ret * 3 + (x % 3 + 1) % 3;\n\t\tx /= 3;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tp3[0] = 1;\n\tfor (int i=1; i<=10; ++i) {\n\t\tp3[i] = p3[i-1] * 3;\n\t}\n\tar[0] = ag[0] = ab[0] = 0;\n\tfor (int i=1; i<=10; ++i) {\n\t\tar[i] = ar[i-1];\n\t\tag[i] = ag[i-1] * 3 + 1;\n\t\tab[i] = ab[i-1] * 3 + 2;\n\t}\n\tstring s;\n\twhile (cin >> s, s != \"0\") {\n\t\tmemset(checked, false, sizeof checked);\n\t\tint n = s.size();\n\t\tint first = conv(s);\n\t\tqueue<pair<int,int> > q;\n\t\tq.push(make_pair(first, 0));\n\t\tchecked[first] = true;\n\t\tint res = -1;\n\t\twhile ( ! q.empty()) {\n\t\t\tint col = q.front().first;\n\t\t\tint t = q.front().second;\n\t\t\tq.pop();\n\t\t\tif (col == ar[n] || col == ag[n] || col == ab[n]) {\n\t\t\t\tres = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i=0; i<n-1; ++i) {\n\t\t\t\tint replace = change[(col / p3[i]) % 9];\n\t\t\t\tint nx = (col / p3[i+2]) * p3[i+2] + replace * p3[i] + (col % p3[i]);\n\t\t\t\tif ( ! checked[nx]) {\n\t\t\t\t\tq.push(make_pair(nx, t+1));\n\t\t\t\t\tchecked[nx] = true; nx = rotate(nx, n);\n\t\t\t\t\tchecked[nx] = true; nx = rotate(nx, n);\n\t\t\t\t\tchecked[nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res < 0) cout << \"NA\" << endl;\n\t\telse cout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\n\nstatic const char a[] = {'r','g','b'};\n\nbool checkColor(const string& str){\n\n\tbool res = false;\n\tfor(int i=0;i<3;i++){\n\t\tif(count(str.begin(),str.end(),a[i]) == str.size()) res=true;\n\t}\n\n\treturn res;\n}\n\nint changeColor(string str,int cost,map<string,int>& visited){\n\n\tif(checkColor(str)) return 0;\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,str));\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\tstring now = que.top().second;\n\n\t\tque.pop();\n\t\tfor(int i=0;i+1<now.size();i++){\n\t\t\tstring tmp = now;\n\t\t\tif(now[i] != now[i+1]){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(a[j] != now[i] && a[j] != now[i+1]){\n\t\t\t\t\t\ttmp[i] = a[j];\n\t\t\t\t\t\ttmp[i+1] = a[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(visited.find(tmp) == visited.end()) visited[tmp] = cost + 1;\n\t\t\t\telse if(visited[tmp] <= cost+1) continue;\n\n\t\t\t\tif(checkColor(tmp)) return cost+1;\n\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nint main(){\n\tstring str;\n\n\twhile(cin>>str){\n\t\tif(str.size() == 1 && str[0] == '0') break;\n\t\tmap<string,int> visited;\n\t\tvisited[str] = 0;\n\n\t\tint res = changeColor(str,0,visited);\n\n\t\tif(res==-1) printf(\"%s\\n\",\"NA\");\n\t\telse printf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ninline bool ok(const string & v){\n    for (int i = 1; i < v.size(); i++){\n        if (v[i] != v[0]) return false;\n    }\n    return true;\n};\n\ninline char other(char a, char b){\n    if (a>b)swap(a, b);\n    if (a == 'g' && b == 'r'){\n        return 'b';\n    }\n    if (a == 'b' && b == 'g'){\n        return 'r';\n    }\n    if (a == 'b' && b == 'r'){\n        return 'g';\n    }\n    throw \"\";\n}\n\nstruct state {\n    string str;\n    int n;\n};\n\nint main(){\n    string s;\n    while (cin >> s, s != \"0\"){\n        queue<state> q;\n        set<string> dp;\n        q.push({ s, 0 });\n\n        int ans = -1;\n        while (q.size()){\n            state sta = q.front();\n            q.pop();\n            string & sv = sta.str;\n            auto pr = dp.insert(sv);\n            if (!pr.second){\n                continue;\n            }\n            if (ok(sv)){\n                ans = sta.n;\n                break;\n            }\n            for (int i = 1; i < sv.size(); i++){\n                if (sv[i] != sv[i - 1]){\n                    char a = sv[i];\n                    char b = sv[i - 1];\n                    sv[i] = sv[i - 1] = other(a, b);\n                    q.push({ sv, sta.n + 1 });\n                    sv[i] = a;\n                    sv[i - 1] = b;\n                }\n            }\n        }\n        if (ans == -1){\n            cout << \"NA\" << endl;\n        }\n        else{\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<string, char> rule = { \n\t{\"rb\", 'g'},\n\t{\"br\", 'g'},\n\t{\"rg\", 'b'},\n\t{\"gr\", 'b'},\n\t{\"gb\", 'r'},\n\t{\"bg\", 'r'} };\n\nbool isjudge(string s){\n\tbool r = true;\n\tchar c = s[0];\n\tfor(int i = 0;i < s.length();++i){\n\t\tr &= (c == s[i]);\n\t}\n\treturn r;\n}\n\nint bfs(string s){\n\tqueue<string> q;\n\tmap<string, int> v;\n\tv[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tstring t = q.front(), n;\n\t\tchar c;\n\t\tq.pop();\n\t\tif(isjudge(t)) return v[t];\n\t\tfor(int i = 0;i < (t.length() - 1);++i){\n\t\t\tif(t[i] != t[i + 1]){\n\t\t\t\tn = t;\n\t\t\t\tc = rule[t.substr(i, 2)];\n\t\t\t\tn[i] = n[i + 1] = c;\n\t\t\t\tif(v.count(n) == 0){\n\t\t\t\t\tq.push(n);\n\t\t\t\t\tv[n] = v[t] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tstring s;\n\tint c;\n\twhile(cin >> s){\n\t\tif(s == \"0\") break;\n\t\telse {\n\t\t\tc = bfs(s);\n\t\t\tif(c == -1) cout << \"NA\" << endl;\n\t\t\telse cout << c << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint bfs(string worm){\n  queue<P> que;\n  que.push(P(worm, 0));\n\n  map<string, int>  d;\n\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n\n    if(d[p.first])  continue;\n\n    string str = p.first;\n\n    bool flag = true;\n    for(int i = 0; i < str.size()-1; i++){\n      if(str[i] != str[i+1]){\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag) return p.second;\n\n    d[p.first] = p.second;\n\n    for(int i = 0; i < str.size()-1; i++){\n      if(str[i] != str[i+1]){\n        string next;\n        char tmp;\n        if(str[i] != 'b' && str[i+1] != 'b'){\n          tmp = 'b';\n        }else if(str[i] != 'g' && str[i+1] != 'g'){\n          tmp = 'g';\n        }else{\n          tmp = 'r';\n        }\n\n        next = str;\n        next[i] = next[i+1] = tmp;\n        que.push(P(next, p.second+1));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  string worm;\n  while(cin >> worm && worm != \"0\"){\n    int ans = bfs(worm);\n    if(ans >= 0)  cout << ans << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<int,string> pis;\n\nint solve(string s)\n{\n\tset<string> memo;\n\tpriority_queue<pis,vector<pis>,greater<pis> > pq;\n\tpq.push(mp(0,s));\n\twhile(!pq.empty()){\n\t\tpis cur=pq.top(); pq.pop();\n\t\tint curf=cur.first;\n\t\tstring curs=cur.second;\n\t\tif(count(allof(curs),curs[0])==curs.size())\n\t\t\treturn curf;\n\t\tif(memo.find(curs)!=memo.end())\n\t\t\tcontinue;\n\t\tmemo.insert(curs);\n\t\t\n\t\trep(i,curs.size()-1){\n\t\t\tchar a=curs[i],b=curs[i+1];\n\t\t\tif(a==b)\n\t\t\t\tcontinue;\n\t\t\tif(a=='r' && b=='g' || a=='g' && b=='r') curs[i]=curs[i+1]='b';\n\t\t\tif(a=='g' && b=='b' || a=='b' && b=='g') curs[i]=curs[i+1]='r';\n\t\t\tif(a=='b' && b=='r' || a=='r' && b=='b') curs[i]=curs[i+1]='g';\n\t\t\tpq.push(mp(curf+1,curs));\n\t\t\tcurs[i]=a;\n\t\t\tcurs[i+1]=b;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(string s;cin>>s,s[0]!='0';){\n\t\tint res=solve(s);\n\t\tif(res==-1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){\n\tstring s,t;for(int i,n,f;cin>>s,s!=\"0\";){\n\t\tqueue<string>q;\n\t\tmap<string,int>d;d[s]=1;\n\t\tfor(q.push(s);q.size();){\n\t\t\ts=q.front();q.pop();n=s.length();\n\t\t\tfor(f=i=0;i<n-1;i++)if(s[i]!=s[i+1]){\n\t\t\t\tt=s;t[i]=t[i+1]=(char)('r'+'g'+'b'-s[i]-s[i+1]);f++;\n\t\t\t\tif(!d[t])d[t]=d[s]+1,q.push(t);\n\t\t\t}\n\t\t\tif(!f){printf(\"%d\\n\",d[s]-1);goto N;}\n\t\t}\n\t\tputs(\"NA\");N:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <iterator>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<vector<char>, int> VCI;\nbool check(vector<char> worm){\n  for(int i = 1; i < worm.size(); ++i){\n    if(worm[0] != worm[i]){\n      return false;\n    }\n  }\n  return true;\n}\nmap<pair<char, char>, char> table;\nint bfs(string s){\n  vector<char> worm;\n  copy(s.begin(), s.end(), back_inserter(worm));\n  int N = worm.size();\n  queue<VCI> q;\n  set<vector<char> > visited;\n  q.push(make_pair(worm, 0));\n  while(!q.empty()){\n    VCI vci = q.front(); q.pop();\n    vector<char> w = vci.first;\n    int step = vci.second;\n    if(check(w)){\n      return step;\n    }\n    if(visited.find(w) != visited.end()){\n      continue;\n    }\n    visited.insert(w);\n    for(int i = 0; i < N-1; ++i){\n      if(w[i] == w[i+1]){\n        continue;\n      }\n      vector<char> nw;\n      copy(w.begin(), w.end(), back_inserter(nw));\n      nw[i] = nw[i+1] = table[make_pair(nw[i], nw[i+1])];\n      q.push(make_pair(nw, step+1));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  table[make_pair('r', 'b')] = table[make_pair('b', 'r')] = 'g';\n  table[make_pair('r', 'g')] = table[make_pair('g', 'r')] = 'b';\n  table[make_pair('b', 'g')] = table[make_pair('g', 'b')] = 'r';\n  string s;\n  while(true){\n    cin >> s;\n    if(s == \"0\"){\n      break;\n    }\n    int ans = bfs(s);\n    if(ans == -1){\n      cout << \"NA\" << endl;\n    }\n    else{\n      cout << bfs(s) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct s{\n    string worm;\n    int nowans;\n};\nint main(){\n    char dc[6][3]={'r','g','b','g','r','b','r','b','g','b','r','g','g','b','r','b','g','r'};\n    while(1){\n        int che[100000]={0},chenum=0;\n        s IN,now;\n        queue <s> que;\n        cin >> IN.worm;\n        IN.nowans=0;\n        if(IN.worm[0]=='0')\n            break;\n        que.push(IN);\n        while(1){\n            chenum=0;\n            now=que.front(),que.pop();\n            for(int i=0;i<now.worm.size();i++){\n                if(now.worm[i]=='r')\n                    chenum+=pow(3,i);\n                else if(now.worm[i]=='g')\n                    chenum+=pow(3,i)*2;\n                else if(now.worm[i]=='b')\n                    chenum+=pow(3,i)*3;\n            }\n            if(che[chenum])\n                continue;\n            else\n                che[chenum]=1;\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1])\n                    break;\n                if(i==now.worm.size()-1-1){\n                    printf(\"%d\\n\",now.nowans);\n                    goto exit;\n                }\n            }\n            if(now.nowans==20){\n                puts(\"NA\");\n                goto exit;\n            }\n            for(int i=0;i<now.worm.size()-1;i++){\n                if(now.worm[i]!=now.worm[i+1]){\n                    for(int j=0;j<6;j++){\n                        if(now.worm[i]==dc[j][0]&&now.worm[i+1]==dc[j][1]){\n                            now.worm[i]=dc[j][2],now.worm[i+1]=dc[j][2],now.nowans++;\n                            que.push(now);\n                            now.worm[i]=dc[j][0],now.worm[i+1]=dc[j][1],now.nowans--;\n                        }\n                    }\n                }\n            }\n        }\nexit:\n    printf(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reps(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reps(i, 0, n) \n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tchar str[16];\n\twhile(scanf(\"%s\", str), str[0]!='0'){\n\t\tint n = strlen(str);\n\t\tint ans = -1;\n\t\tset<string> visited;\n\t\tqueue<pair<string, int> > Q;\n\t\tQ.push(make_pair(str, 0));\n\t\twhile(!Q.empty()){\n\t\t\tpair<string, int> data = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(visited.count(data.first))\n\t\t\t\tcontinue;\n\t\t\tif(count(data.first.begin(), data.first.end(), data.first[0]) == n){\n\t\t\t\tans = data.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvisited.insert(data.first);\n\t\t\trep(i, n-1){\n\t\t\t\tchar a = min(data.first[i], data.first[i+1]);\n\t\t\t\tchar b = max(data.first[i], data.first[i+1]);\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\tchar nc;\n\t\t\t\tif(a == 'b')\n\t\t\t\t\tnc = b=='g' ? 'r' : 'g';\n\t\t\t\telse\n\t\t\t\t\tnc = 'b';\n\t\t\t\tstring next = data.first;\n\t\t\t\tnext[i] = next[i+1] = nc;\n\t\t\t\tQ.push(make_pair(next, data.second+1));\n\t\t\t}\n\t\t}\n\t\tif(ans == -1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\nusing namespace std;\n\nint main(){\n  int N, M, dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n  while(scanf(\"%d\", &N) && N){\n    int x[32], y[32];\n    rep(i, N) scanf(\"%d%d\", x+i, y+i);\n    scanf(\"%d\", &M);\n    int nx = 10, ny = 10, dis, d;\n    bool field[21][21] = {};\n    field[ny][nx] = true;\n    char com[4];\n    rep(i, M){\n      scanf(\"%s%d\", com, &dis);\n      switch(com[0]){\n      case 'N': d = 0; break;\n      case 'E': d = 1; break;\n      case 'S': d = 2; break;\n      case 'W': d = 3; break;\n      }\n      rep(j, dis){\n\tnx += dx[d]; ny += dy[d];\n\tfield[ny][nx] = true;\n      }\n    }\n    /*    rep(i, 21){\n      rep(j, 21) printf(\"%d \", field[i][j]?1:0);\n      puts(\"\");\n      }*/\n    bool f = true;\n    rep(i, N)\n      if(!field[y[i]][x[i]]) f = false;\n    if(f) puts(\"Yes\");\n    else puts(\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nchar color(char a, char b) {\n    if (a > b) swap(a, b);\n    if (a == 'b') {\n        if (b == 'g') return 'r';\n        if (b == 'r') return 'g';\n    }\n    return 'b';\n}\n\nint main() {\n    for(string worm; cin >> worm, worm != \"0\"; ) {\n        int len = worm.size();\n        queue<string> que;\n        set<string> dist;\n        que.push(worm);\n        for(int time = 0; ; time++) {\n            queue<string> que2;\n            while(!que.empty()) {\n                string w = que.front();\n                que.pop();\n                if (dist.count(w) == 1) continue;\n                dist.insert(w);\n                int cnt = 0;\n                rep(i, len - 1) {\n                    if (w[i] == w[i + 1]) {\n                        cnt++;\n                        continue;\n                    }\n                    char c = color(w[i], w[i + 1]);\n                    string t = w;\n                    t[i] = t[i + 1] = c;\n                    que2.push(t);\n                }\n                if (cnt == len - 1) {\n                    cout << time << endl;\n                    goto end;\n                }\n            }\n            if (que2.empty()) {\n                cout << \"NA\" << endl;\n                goto end;\n            }\n            que = que2;\n        }\nend:;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool check(string s){\n    for(int i=0; i< s.size()-1; i++) if(s[i] != s[i+1]) return false;\n    return true;\n}\n\nint main(){\n    string s;\n    while(cin >> s, s!= \"0\"){\n        queue<pair<string, int> > que;\n        que.push(make_pair(s, 0));\n        int ret = 100;\n\n        map<string, int> m;\n        while(que.size()){\n            s = que.front().first; int count = que.front().second; que.pop();\n\n            if(ret < count) continue;\n            if(check(s))ret = count;\n\n            if(m[s] == 0 || count+1 < m[s]){\n                string tmp = s;\n                m[s] = count+1;\n                string t = \"rgb\";\n                vector<int> v(3); v[0] = 0; v[1] = 1; v[2] = 2;\n                map<string, int> mp; mp[\"r\"] = 0; mp[\"g\"] = 1; mp[\"b\"] = 2;\n                do{\n                    for(int i=0; i< s.size(); i++){\n                        s[i] = t[v[mp[s.substr(i, 1)]]];\n                    }\n                    m[s] = count+1;\n                }while(next_permutation(v.begin(), v.end()));\n                s = tmp;\n            }\n            else continue;\n\n            for(int i=0; i< s.size()-1; i++){\n                if(s[i] != s[i+1]){\n                    string t = s.substr(i, 2);\n                    sort(t.begin(),t.end());\n                    if(t == \"br\") t = \"gg\";\n                    else if(t == \"bg\") t = \"rr\";\n                    else if(t == \"gr\") t = \"bb\";\n                    que.push(make_pair(s.substr(0, i)+t+s.substr(i+2), count+1));\n                }\n            }\n        }\n        if(ret == 100) cout << \"NA\" << endl;\n        else cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TEMP_T template<typename T>\nTEMP_T void sort(T& v){ sort(v.begin(), v.end()); }\nTEMP_T void revs(T& v){ reverse(v.begin(), v.end()); }\nTEMP_T void uniq(T& v){ sort(v); v.erase(unique(v.begin(), v.end())); }\nTEMP_T void show(T& v, char delim=' ', char end='\\n'){ for(int i=0; i<v.size()-1; i++) cout << v[i] << delim; cout << v[v.size()-1] << end; }\nTEMP_T T    cums(T& v){ T r; r.push_back(v[0]); for(int i=1; i<v.size(); i++) r.push_back(r[i-1] + v[i]); return r; }\nTEMP_T void maxe(T& v, T m){ v = max(v, m); }\nTEMP_T void mine(T& v, T m){ v = min(v, m); }\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\n\nstruct Solver {\n  Solver(const string& init) : init(init) {}\n  char getAnotherColor(char a, char b){\n    if (a > b) swap(a, b);\n    if (a == 'b'){\n      if (b == 'g') return 'r';\n      return 'g';\n    }\n    return 'b';\n  }\n  bool is_end(const string& s){\n    for (int i = 1; i < s.size(); i++){\n      if (s[0] != s[i]) return false;\n    }\n    return true;\n  }\n\n  int solve(){\n    queue<string> Q;\n    set<string> vis;\n    int turn = 0;\n    \n    Q.push(init);\n    vis.insert(init);\n    while (!Q.empty()){\n      queue<string> nQ;\n      while (!Q.empty()){\n        string state = Q.front();\n        Q.pop();\n        if (is_end(state)){\n          return turn;\n        }\n        for (int i = 0; i < state.size() - 1; i++){\n          if (state[i] != state[i + 1]){\n            char another = getAnotherColor(state[i], state[i + 1]);\n            string next_state = state;\n            next_state[i + 1] = next_state[i] = another;\n            if (vis.find(next_state) != vis.end()) continue;\n            vis.insert(next_state);\n            nQ.push(next_state);\n          }\n        }\n      }\n      turn++;\n      swap(Q, nQ);\n    }\n    return -1;\n  }\n  string init;\n};\n\nint main()\n{\n  string s;\n  while (cin >> s, s != \"0\"){\n    Solver solver(s);\n    int turn = solver.solve();\n    if (turn == -1) puts(\"NA\");\n    else printf(\"%d\\n\", turn);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nclass wormcheck{\n    public:\n    string Worm;\n    int Val;\n    wormcheck(string W,int V){\n        Worm=W;\n        Val=V;\n    }\n};\n\nint main(){\n    string worm;\n    while(cin>>worm){\n        if(worm==\"0\")break;\n        queue<wormcheck> que;\n        que.push(wormcheck(worm,0));\n        map<string,int> visit;\n        while(1){\n            if(que.empty()){cout<<\"NA\"<<endl;break;}\n            wormcheck w = que.front();\n            que.pop();\n            if(visit[w.Worm]==1)continue;\n            visit[w.Worm]=1;\n            for(int i=1;i<w.Worm.size();i++){\n                if(w.Worm[i]!=w.Worm[i-1]){\n                    goto Skip;\n                }\n            }\n            //printf(\"%s %d\",w.Worm,w.Val);\n            cout<<w.Val<<endl;\n            break;\n            Skip:;\n            string subWorm = w.Worm;\n            for(int i=1;i<w.Worm.size();i++){\n                if(subWorm[i]!=subWorm[i-1]){\n                    if(subWorm[i]!='b'&&subWorm[i-1]!='b'){\n                        subWorm[i]='b';\n                        subWorm[i-1]='b';\n                    }\n                    else if(subWorm[i]!='g'&&subWorm[i-1]!='g'){\n                        subWorm[i]='g';\n                        subWorm[i-1]='g';\n                    }\n                    else if(subWorm[i]!='r'&&subWorm[i-1]!='r'){\n                        subWorm[i]='r';\n                        subWorm[i-1]='r';\n                    }\n                    que.push(wormcheck(subWorm,w.Val+1));\n                    subWorm=w.Worm;\n                }\n            }\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing pii = pair<int, int>; using vi = vector<int>;\nstatic const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nstatic const int MOD = (int)(1e9 + 7);\n\nbool f(string s) {\n\trep(i, 0, s.size() - 1)\n\t\tif (s[i] != s[i + 1])return false;\n\treturn true;\n}\n\nsigned main() {\n\tfor (string s; cin >> s&&s != \"0\";) {\n\t\tunordered_map<string, int> m;\n\t\tm[s] = 0;\n\t\tqueue<string> q;\n\t\tq.emplace(s);\n\t\twhile (!q.empty()) {\n\t\t\tstring t = q.front(); q.pop();\n\t\t\trep(i, 0, t.size() - 1) {\n\t\t\t\tif (t[i] == t[i + 1])continue;\n\t\t\t\tstring tmp = t;\n\t\t\t\tif (t[i] + t[i + 1] == 'r' + 'g')tmp[i] = tmp[i + 1] = 'b';\n\t\t\t\tif (t[i] + t[i + 1] == 'g' + 'b')tmp[i] = tmp[i + 1] = 'r';\n\t\t\t\tif (t[i] + t[i + 1] == 'b' + 'r')tmp[i] = tmp[i + 1] = 'g';\n\n\t\t\t\tif (m.find(tmp) == m.end()) {\n\t\t\t\t\tq.emplace(tmp);\n\t\t\t\t\tm[tmp] = m[t] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (auto itr = m.begin(); itr != m.end(); itr++) {\n\t\t\tif (f(itr->first))ans=min(ans,itr->second);\n\t\t}\n\t\tif (ans == INF)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint main(){\n\tmap<string,string>q;\n\tq[\"bg\"]=q[\"gb\"]=\"rr\";\n\tq[\"gr\"]=q[\"rg\"]=\"bb\";\n\tq[\"rb\"]=q[\"br\"]=\"gg\";\n\tstring s;\n\twhile(cin>>s,s!=\"0\"){\n\t\tvector<string>in;\n\t\tmap<string,bool>tmp;\n\t\tin.pb(s);\n\t\tint co=0;\n\t\twhile(1){\n\t\t\tvector<string>out;\n\t\t\tbool h;\n\t\t\trep(i,in.size()){\n\t\t\t\tstring s=in[i];\n\t\t\t\ttmp[s]=true;\n\t\t\t\th=true;\n\t\t\t\tchar qq=in[i][0];\n\t\t\t\trep(j,s.size())if(qq!=in[i][j])h=false;\n\t\t\t\tif(h)break;\n\t\t\t\trep(j,s.size()-1)if(s[j]!=s[j+1]){\n\t\t\t\t\tstring www=s.substr(j,2);\n\t\t\t\t\tstring w=q[www];\n\t\t\t\t\tstring ww=s;\n\t\t\t\t\tww[j]=w[0];ww[j+1]=w[1];\n\t\t\t\t\tif(tmp[ww]==false)out.pb(ww);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(h)break;\n\t\t\tco++;\n\t\t\tin=out;\n\t\t\t//cout<<\" \"<<in.size()<<endl;\n\t\t\tif(co==10)break;\n\t\t}\n\t\tif(co==11)cout<<\"NA\"<<endl;\n\t\telse cout<<co<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint solve(string taregt, string origin, int count);\nbool checkSameColor(string str);\nbool checkLastColor(vector<string> last_str, string str);\n\nint main(int argc, char const *argv[]){\n    string color;\n    int count;\n\n    while(cin>>color, color != \"0\"){\n        count = 0;\n        int result = solve(color, color, count);\n        if (result == -1) cout<<\"NA\"<<endl;\n        else cout<<result<<endl;\n    }\n    return 0;\n}\n\nbool checkSameColor(string str){\n    char first = str[0];\n\n    for (int i = 0; i < str.size(); i++){\n        if (str[i] != first) return false;\n    }\n\n    return true;\n}\n\nint solve(string target, string origin, int count){   \n    queue<pair<string, int> > que;\n    que.push(make_pair(origin, 0));\n    pair<string, int> worm;\n    map<string, int> d;\n\n    while (!que.empty()){\n        worm = que.front();\n        que.pop();\n        string str = worm.first;\n        \n        if (d[str]) continue;\n\n        if (checkSameColor(str)){\n            return worm.second;\n        }\n\n        d[str] = worm.second;\n\n        for (int i = 0; i < str.size()-1; ++i){\n            string tmp_str = str;\n            if((str[i] == 'r' && str[i+1] == 'b') \n                || (str[i] == 'b' && str[i+1] == 'r')){\n                pair<string, int> tmp = make_pair(tmp_str.replace(i, 2, \"gg\"), worm.second+1);\n                que.push(tmp);\n            }\n            else if((str[i] == 'b' && str[i+1] == 'g') \n                || (str[i] == 'g' && str[i+1] == 'b')){\n                pair<string, int> tmp = make_pair(tmp_str.replace(i, 2, \"rr\"), worm.second+1);\n                que.push(tmp);\n            }\n            else if((str[i] == 'g' && str[i+1] == 'r') \n                || (str[i] == 'r' && str[i+1] == 'g')){\n                pair<string, int> tmp = make_pair(tmp_str.replace(i, 2, \"bb\"), worm.second+1);\n                que.push(tmp);\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint que[60000][10],flg[1050000];\nint main(void){\n\tint p1,p2,i,j,len,time[60000],copy[10],f,x,ans,iro;\n\tchar ca[11];\n\twhile(1){\n\t\tcin>>ca;\n\t\tif(ca[0]=='0') break;\n\t\tlen=strlen(ca);\n\t\tfor(i=0;i<len;i++){\n\t\t\tif(ca[i]=='r') que[0][i]=0;\n\t\t\tif(ca[i]=='g') que[0][i]=1;\n\t\t\tif(ca[i]=='b') que[0][i]=2;\n\t\t}\n\t\tfor(i=0;i<=1050000;i++) flg[i]=0;\n\t\tp1=0; p2=1; time[0]=0; ans=-1;\n\t\twhile(1){\n\t\t\tif(p1==p2){\n//\t\t\t\tcout<<p1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n/*\t\t\tcout<<p1<<' ';\n\t\t\tfor(i=0;i<len;i++) cout<<que[p1][i];\n\t\t\tcout<<' '<<time[p1]<<endl;*/\n\t\t\tf=1;\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tif(que[p1][i]!=que[p1][i+1]){\n\t\t\t\t\tf=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==1){\n\t\t\t\tans=time[p1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\tfor(j=0;j<len;j++) copy[j]=que[p1][j];\n\t\t\t\tif(copy[i]!=copy[i+1]){\n\t\t\t\t\tiro=copy[i]+copy[i+1];\n\t\t\t\t\tif(iro==3){\n\t\t\t\t\t\tcopy[i]=0; copy[i+1]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==2){\n\t\t\t\t\t\tcopy[i]=1; copy[i+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(iro==1){\n\t\t\t\t\t\tcopy[i]=2; copy[i+1]=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=copy[0];\n\t\t\t\tfor(j=1;j<len;j++) x=x*4+copy[j];\n\t\t\t\tif(flg[x]==0){\n\t\t\t\t\tflg[x]=1; time[p2]=time[p1]+1;\n\t\t\t\t\tfor(j=0;j<len;j++) que[p2][j]=copy[j];\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1++;\n\t\t}\n\t\tif(ans==-1) cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nbool Check_Warm_Color(string str) {\n\tchar c = str[0];\n\tfor (int i = 1; i < str.length(); ++i) {\n\t\tif (c != str[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nchar Check_Color(char c1, char c2) {\n\tif (c1 < c2) {\n\t\tswap(c1,c2);\n\t}\n\tif (c1 == 'r') {\n\t\tif (c2 == 'g') {\n\t\t\treturn 'b'; \n\t\t}\n\t\telse {\n\t\t\treturn 'g';\n\t\t}\n\t}\n\treturn 'r';\n}\n\nint main(void) {\n\tstring str,ss;\n\tcin >> str;\n\twhile (str != \"0\") {\n\t\tint len = str.length();\n\t\tmap<string,bool> ob;\n\t\tob[str] = true;\n\n\t\tqueue<string> warm;\n\t\tqueue<int> deep;\n\t\twarm.push(str);\n\t\tdeep.push(0);\n\t\tbool find = false;\n\t\tint d;\n\t\tint ret = -1;\n\t\twhile (!find && !warm.empty()) {\n\t\t\tstr = warm.front();\n\t\t\td = deep.front();\n\t\t\twarm.pop();\n\t\t\tdeep.pop();\n\t\t\tif (Check_Warm_Color(str)) {\n\t\t\t\tret = d;\n\t\t\t\tfind = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < str.length() - 1; ++i) {\n\t\t\t\t\tss = str;\n\t\t\t\t\tif (str[i] != str[i+1]) {\n\t\t\t\t\t\tchar temp = Check_Color(str[i],str[i+1]);\n\t\t\t\t\t\tss[i] = temp;\n\t\t\t\t\t\tss[i+1] = temp;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ob[ss]) {\n\t\t\t\t\t\tob[ss] = true;\n\t\t\t\t\t\twarm.push(ss);\n\t\t\t\t\t\tdeep.push(d+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ret << endl;\n\t\t}\n\n\t\tcin >> str;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef struct {\n\tchar nood[11];\n\tint time;\n} WORM;\n\nunsigned int makeHash(char nood[])\n{\n\tint i = 0;\n\tunsigned int ret = 0;\n\twhile (nood[i] != -1){\n\t\tret += nood[i];\n\t\tret *= 3;\n\t\ti++;\n\t}\n\t\n\treturn (ret);\n}\n\nint add_worm(list<WORM>* lstWorm, list<unsigned>& lstHash)\n{\n\tWORM add;\n\t\n\tadd.time = lstWorm->front().time + 1;\n\t\n\tint i = 0;\n\twhile (lstWorm->front().nood[i + 1] != -1){\n\t\tif (lstWorm->front().nood[i] != lstWorm->front().nood[i + 1]){\n\t\t\tmemcpy(add.nood, lstWorm->front().nood, 11);\n\t\t\tadd.nood[i] = add.nood[i + 1] = 3 - (lstWorm->front().nood[i] + lstWorm->front().nood[i + 1]);\n\t\t\tif (find(lstHash.begin(), lstHash.end(), makeHash(add.nood)) == lstHash.end()){\n\t\t\t\tlstWorm->push_back(add);\n\t\t\t\tlstHash.push_back(makeHash(add.nood));\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (0);\n}\n\nbool checkNood(char nood[])\n{\n\tint i = 1;\n\tint d = nood[0];\n\tbool ret = true;\n\t\n\twhile (nood[i] != -1){\n\t\tif (d != nood[i]){\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\tlist<unsigned int> lstHash;\n\tlist<WORM> lstWorm;\n\tWORM add;\n\t\n\twhile (1){\n\t\tlstHash.clear();\n\t\tlstWorm.clear();\n\t\tscanf(\"%s\", add.nood);\n\t\tif (add.nood[0] == '0'){\n\t\t\tbreak;\n\t\t}\n\t\tint i = 0;\n\t\twhile (add.nood[i] != '\\0'){\n\t\t\tswitch(add.nood[i]){\n\t\t\t  case 'r': add.nood[i] = 0; break;\n\t\t\t  case 'g': add.nood[i] = 1; break;\n\t\t\t  case 'b': add.nood[i] = 2; break;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tadd.nood[i] = -1;\n\t\tadd.time = 0;\n\t\t\n\t\tlstWorm.push_back(add);\n\t\tlstHash.push_back(makeHash(add.nood));\n\t\t\n\t\twhile (lstWorm.empty() == false && checkNood(lstWorm.front().nood) == false){\n\t\t\tadd_worm(&lstWorm, lstHash);\n\t\t\tlstWorm.pop_front();\n\t\t}\n\t\t\n\t\tif (lstWorm.empty() == true){\n\t\t\tputs(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", lstWorm.front().time);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isOneColor(const string &s) {\n  for(int i = 1; i < s.size(); ++i)\n    if(s[0] != s[i]) return false;\n  return true;\n}\n\nint bfs(string src) {\n  if(isOneColor(src)) return 0;\n  const static string color = \"rgb\";\n  map<string,int> cost;\n  queue<string> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const string s = que.front();\n    que.pop();\n    for(int i = 0; i+1 < s.size(); ++i) {\n      if(s[i] == s[i+1]) continue;\n      string t = s;\n      for(int j = 0; j < color.size(); ++j) {\n        if(t[i] != color[j] && t[i+1] != color[j]) {\n          t[i] = t[i+1] = color[j];\n          break;\n        }\n      }\n      if(cost.count(t)) continue;\n      cost[t] = cost[s] + 1;\n      que.push(t);\n      if(isOneColor(t)) return cost[t];\n    }\n  }\n  return -1;\n}\n\nint main() {\n  string s;\n  while(cin >> s && s != \"0\") {\n    int res = bfs(s);\n    if(res == -1) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nint solve(string s)\n{\n    map<string, int> mem;\n    queue<pair<string, int> > q;\n\n    q.push(pair<string, int>(s, 0));\n    mem[s] = 0;\n\n    while (!q.empty()) {\n        pair<string, int> tmp;\n        bool flag = true;\n\n        tmp = q.front();\n        q.pop();\n\n        // Check\n        for (int i = 1; i < tmp.first.size(); i++)\n            if (tmp.first[0] != tmp.first[i]) {\n                flag = false;\n                break;\n            }\n        if (flag) \n            return tmp.second;\n\n        for (int i = 0; i < tmp.first.size() - 1; i++) {\n            if (tmp.first[i] != tmp.first[i + 1]) {\n                string str = tmp.first;\n                int num = (int)(tmp.first[i] + tmp.first[i + 1]);\n\n                if (num == 217) \n                    str[i] = str[i + 1] = 'b';\n                else if (num == 212) \n                    str[i] = str[i + 1] = 'g';\n                else if (num == 201) \n                    str[i] = str[i + 1] = 'r';\n\n                if (mem.count(str) == 0) {\n                    q.push(pair<string, int>(str, tmp.second + 1));\n                    mem[str] = tmp.second + 1;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    string inp;\n\n    while (cin >> inp, inp != \"0\") {\n        int num = solve(inp);\n\n        if (num >= 0)\n            cout << num << endl;\n        else \n            cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define mkp(x, y) (make_pair(x, y))\n\nint main() {\n\tstring in;\n\n\twhile(cin >> in, in != \"0\") {\n\t\tset<string> appeared;\n\t\tqueue<pair<string, int> > q;\n\t\tint loop_flag = -1;\n\n\t\tappeared.insert(in);\n\t\tq.push(mkp(in, 0));\n\n\t\twhile(!q.empty()) {\n\t\t\tstring worm;\n\t\t\tint count;\n\t\t\tpair<string, int> p;\n\t\t\tbool complete_flag = true;\n\t\t\tp = q.front(); q.pop();\n\t\t\tworm = p.first;\n\t\t\tcount = p.second;\n\n\t\t\tfor(int i = 1; i < worm.size(); i++) {\n\t\t\t\tif(worm[i - 1] != worm[i]) {\n\t\t\t\t\tstring tmp(worm);\n\t\t\t\t\ttmp[i - 1] = tmp[i] = 'r' + 'g' + 'b' - worm[i - 1] - worm[i];\n\t\t\t\t\tif(appeared.find(tmp) == appeared.end()) {\n\t\t\t\t\t\tq.push(mkp(tmp, count + 1));\n\t\t\t\t\t\tappeared.insert(tmp);\n\t\t\t\t\t}\n\t\t\t\t\tcomplete_flag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(complete_flag) {\n\t\t\t\tloop_flag = count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(loop_flag != -1)\n\t\t\tcout << loop_flag << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ninline bool ok(const string & v){\n    for (int i = 1; i < v.size(); i++){\n        if (v[i] != v[0]) return false;\n    }\n    return true;\n};\n\ninline char other(char a, char b){\n    if (a>b)swap(a, b);\n    if (a == 'g' && b == 'r'){\n        return 'b';\n    }\n    if (a == 'b' && b == 'g'){\n        return 'r';\n    }\n    if (a == 'b' && b == 'r'){\n        return 'g';\n    }\n    throw \"\";\n}\n\nstruct state {\n    string str;\n    int n;\n};\n\nint main(){\n    string s;\n    while (cin >> s, s != \"0\"){\n        queue<state> q;\n        set<string> dp;\n        q.push({ s, 0 });\n\n        int ans = -1;\n        while (q.size()){\n            state sta = q.front();\n            q.pop();\n            string & sv = sta.str;\n            auto pr = dp.insert(sv);\n            if (!pr.second){\n                continue;\n            }\n            if (ok(sv)){\n                ans = sta.n;\n                break;\n            }\n            for (int i = 1; i < sv.size(); i++){\n                if (sv[i] != sv[i - 1]){\n                    char a = sv[i];\n                    char b = sv[i - 1];\n                    sv[i] = sv[i - 1] = other(a, b);\n                    q.push({ sv, sta.n + 1 });\n                    sv[i] = a;\n                    sv[i - 1] = b;\n                }\n            }\n        }\n        if (ans == -1){\n            cout << \"NA\" << endl;\n        }\n        else{\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Set as S\nimport Debug.Trace\nmain :: IO ()\nmain = do\n  ls <- getLine\n  if ls == \"0\"\n    then return ()\n    else do\n      let ans = solve ls\n      case ans of\n        Nothing -> putStrLn \"NA\"\n        Just n -> print n\n      main\n\nsolve :: String -> Maybe Int\nsolve ls = func [ls] S.empty 0\n  where\n    func :: [String] -> S.Set String -> Int -> Maybe Int\n    --func now visited count | traceShow (length now) False = undefined\n    func now visited count\n      | null now = Nothing\n      | any f now = Just count\n      | otherwise = func now' visited' (count + 1)\n      where f :: String -> Bool\n            f [] = True\n            f (x:xs) = all (x ==) xs\n            visited' = (foldr S.insert visited now)\n            now' = filter (\\x -> S.notMember x visited') (update now visited')\n            update :: [String] -> S.Set String -> [String]\n            update [] v = []\n            update (x:xs) v = (filter (\\x -> S.notMember x v) (g x)) ++ (update xs (foldr S.insert v (g x)))\n              where\n                g :: String -> [String]\n                g (l:ls) = g' [l] ls []\n                  where\n                    g' :: String -> String -> [String] -> [String]\n                    g' _ [] acc = acc\n                    g' (x:xs) (y:ys) acc\n                      | x == y = g' (y:x:xs) ys acc\n                      | otherwise = g' (y:x:xs) ys (((reverse xs) ++ (newColor x y) ++ ys) `append` acc)\n                      where\n                        newColor c1 c2\n                          |c1 /= 'b' && c2 /= 'b' = \"bb\"\n                          |c1 /= 'r' && c2 /= 'r' = \"rr\"\n                          |c1 /= 'g' && c2 /= 'g' = \"gg\"\n                        append x xs = if (elem x xs) then xs else (x:xs)\n                          "
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.Set (Set)\nimport qualified Data.Set as S\n\nmain :: IO ()\nmain = do\n  s <- getLine\n  unless (s == \"0\") $ do\n    putStrLn $ solve s\n    main\n\nsolve :: String -> String\nsolve s = loop 0 (S.singleton s) (S.singleton s)\n  where\n    ln = length s\n    goal = S.fromList $ map (replicate ln) \"rgb\"\n    loop c st hst\n      | S.null st = \"NA\"\n      | not (S.null (S.intersection goal st)) = show c\n      | otherwise = let nst = S.foldl' (\\x s -> S.union x $ S.fromList $ do\n                                           s' <- changeColor ln s\n                                           guard $ S.notMember s' hst\n                                           return s'\n                                       ) S.empty st\n                    in loop (c+1) nst (S.union hst nst)\n\nchangeColor :: Int -> String -> [String]\nchangeColor n s = do\n  i <- [0 .. n-2]\n  let (s1, c1:c2:s2) = splitAt i s\n  guard $ c1 /= c2\n  case (c1, c2) of\n   ('r', 'g') -> return $ s1 ++ \"bb\" ++ s2\n   ('g', 'b') -> return $ s1 ++ \"rr\" ++ s2\n   ('b', 'r') -> return $ s1 ++ \"gg\" ++ s2\n   ('g', 'r') -> return $ s1 ++ \"bb\" ++ s2\n   ('b', 'g') -> return $ s1 ++ \"rr\" ++ s2\n   ('r', 'b') -> return $ s1 ++ \"gg\" ++ s2\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nint d[30][60000]={0};\nvoid f(int n,int a[20]){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int a[20]){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    for(i=0;i<30;i++){\n      for(j=0;j<60000;j++)d[i][j]=0;\n    }\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[0][n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<25;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==0)continue;\n\td[i+1][j]=zMIN(d[i+1][j],d[i][j]);\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[i+1][g(a)]=zMIN(d[i+1][g(a)],d[i][j]+1);\n\t}\n      }\n    }\n    d[25][0]=zMIN(d[25][0],zMIN(d[25][n/2],d[25][n]));\n    if(d[25][0])printf(\"%d\\n\",d[25][0]-1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nstruct list {\n  char str[11];\n  struct list* next;\n} *l;\ntypedef struct list ls;\nstruct node {\n  char str[11];\n  int lev;\n  struct node* next;\n} *qs,*qe;\ntypedef struct node st;\nint add(char* buf)\n{\n  ls *p = l;\n  if (l == NULL) {\n    l = (ls *)(malloc(sizeof(ls)));\n    strcpy(l->str,buf);\n    l->next = NULL;\n    return 1;\n  }\n  while(p->next != NULL){\n    if(strcmp(p->str,buf) == 0) return 0;\n    p = p->next;\n  }\n  if(strcmp(p->str,buf) == 0) return 0;\n  else {\n    p->next = (ls *)(malloc(sizeof(ls)));\n    p = p->next;\n    strcpy(p->str,buf);\n    p->next = NULL;\n    return 1;\n  }\n}\nvoid push(char* buf,int l)\n{\n  if(qe == NULL) {\n    qe = (st *)(malloc(sizeof(st)));\n    qs = qe;\n  } else {\n    qe->next = (st *)(malloc(sizeof(st)));\n    qe = qe->next;\n  }\n  strcpy(qe->str,buf);\n  qe->lev = l;\n  qe->next = NULL;\n}\nstruct node* pop()\n{\n  st* p = qs;\n  if(qs == NULL) return NULL;\n  qs = qs->next;\n  if(qs == NULL) qe = NULL;\n  return p;\n}\nvoid flush()\n{\n  ls* p=l;\n  st* q=qs;\n  while(p!=NULL){\n    l = l->next;\n    free(p);\n    p=l;\n  }\n  while(q!=NULL){\n    qs = qs->next;\n    free(q);\n    q = qs;\n  }\n  qe = NULL;\n}\nint search()\n{\n  int i,l;\n  st *p;\n  char s[11];\n  char c;\n  while((p = pop()) != NULL){\n    l = strlen(p->str);\n    c = (p->str)[0];\n    for(i=1; i<l; i++){\n      if((p->str)[i] != c) break;\n    }\n    if(i==l) return p->lev;\n    for(i=0; i<l-1; i++){\n      strcpy(s,p->str);\n      if((s[i] == 'r' && s[i+1] == 'g')\n\t || (s[i] == 'g' && s[i+1] == 'r')){\n\ts[i] = s[i+1] = 'b';\n\tif(add(s)) push(s,p->lev+1);\n      } else if((s[i] == 'r' && s[i+1] == 'b')\n\t || (s[i] == 'b' && s[i+1] == 'r')){\n\ts[i] = s[i+1] = 'g';\n\tif(add(s)) push(s,p->lev+1);\n      } else if((s[i] == 'b' && s[i+1] == 'g')\n\t || (s[i] == 'g' && s[i+1] == 'b')){\n\ts[i] = s[i+1] = 'r';\n\tif(add(s)) push(s,p->lev+1);\n      }\n    }\n    free(p);\n  }\n  return -1;\n}\nint main()\n{\n  char buf[11];\n  int n;\n  for(;;){\n    scanf(\"%s\",buf);\n    if(strcmp(buf,\"0\") == 0) break;\n    add(buf);\n    push(buf,0);\n    n = search();\n    if(n==-1) printf(\"NA\\n\");\n    else printf(\"%d\\n\",n);\n    flush();\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(h[i=0]=-M;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      if(mi==0||mi==n||mi==n*2)break;\n      if(r==1)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      //if(r==1)break;\n      h[i/2]=k;\n    }//printf(\"%d %d\\n\",h[0],h[1]);\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar a[60000];\ntypedef struct list ls;\nstruct node {\n  char str[11];\n  int lev;\n  struct node* next;\n} *qs,*qe;\ntypedef struct node st;\nint add(char* buf)\n{\n  int l = strlen(buf);\n  int i = 0,j=0;\n  for(i=0;i<l-1;i++){\n    switch(buf[i]){\n    case 'r':\n      j = j*3;\n      break;\n    case 'g':\n      j = j*3+1;\n      break;\n    case 'b':\n      j = j*3+2;\n      break;\n    }\n  }\n  if(a[j] == 1) return 0;\n  a[j] = 1;\n  return 1;\n}\nvoid push(char* buf,int l)\n{\n  if(qe == NULL) {\n    qe = (st *)(malloc(sizeof(st)));\n    qs = qe;\n  } else {\n    qe->next = (st *)(malloc(sizeof(st)));\n    qe = qe->next;\n  }\n  strcpy(qe->str,buf);\n  qe->lev = l;\n  qe->next = NULL;\n}\nstruct node* pop()\n{\n  st* p = qs;\n  if(qs == NULL) return NULL;\n  qs = qs->next;\n  if(qs == NULL) qe = NULL;\n  return p;\n}\nvoid flush()\n{\n  st* q=qs;\n  while(q!=NULL){\n    qs = qs->next;\n    free(q);\n    q = qs;\n  }\n  qe = NULL;\n  memset(a,0,sizeof(a));\n}\nint search()\n{\n  int i,l;\n  st *p;\n  char s[11];\n  char c;\n  while((p = pop()) != NULL){\n    l = strlen(p->str);\n    c = (p->str)[0];\n    for(i=1; i<l; i++){\n      if((p->str)[i] != c) break;\n    }\n    if(i==l) return p->lev;\n    for(i=0; i<l-1; i++){\n      strcpy(s,p->str);\n      if((s[i] == 'r' && s[i+1] == 'g')\n\t || (s[i] == 'g' && s[i+1] == 'r')){\n\ts[i] = s[i+1] = 'b';\n\tif(add(s)) push(s,p->lev+1);\n      } else if((s[i] == 'r' && s[i+1] == 'b')\n\t || (s[i] == 'b' && s[i+1] == 'r')){\n\ts[i] = s[i+1] = 'g';\n\tif(add(s)) push(s,p->lev+1);\n      } else if((s[i] == 'b' && s[i+1] == 'g')\n\t || (s[i] == 'g' && s[i+1] == 'b')){\n\ts[i] = s[i+1] = 'r';\n\tif(add(s)) push(s,p->lev+1);\n      }\n    }\n    free(p);\n  }\n  return -1;\n}\nint main()\n{\n  char buf[11];\n  int n;\n  for(;;){\n    scanf(\"%s\",buf);\n    if(strcmp(buf,\"0\") == 0) break;\n    flush();\n    add(buf);\n    push(buf,0);\n    n = search();\n    if(n==-1) printf(\"NA\\n\");\n    else printf(\"%d\\n\",n);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000];\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(h[i=0]=-M;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      //if(mi==0||mi==n||mi==n*2)break;\n      if(r==1)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      //if(i==1)break;\n      if(r-1)h[i/2]=k;\n    }//printf(\"%d %d\\n\",h[0],h[1]);\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n\n#define Q_MAX 100000\n#define N 11\n\ntypedef struct {\n\tint cost;\n\tchar color[N];\n} QUEUE;\n\n\nint main(void)\n{\n\tchar bug[N];\n\tint i, j;\n\tstatic QUEUE que[Q_MAX];\n\tint sq, eq;\n\tstatic char used[Q_MAX][N];\n\t\n\tdo {\n\t\tint count = -1;\n\t\tscanf(\"%s\", bug);\n\t\t\n\t\tif (bug[0] == '0') break;\n\t\t\n\t\tsq = 0;\n\t\teq = 1;\n\t\tmemset(que, 0, sizeof(que));\n\t\tmemset(used, 0, sizeof(used));\n\t\tque[sq].cost = 0;\n\t\tstrcpy(que[sq].color, bug);\n\t\t\n\t\twhile (sq != eq){\n\t\t\tchar color[N];\n\t\t\tint cost = que[sq].cost;\n\t\t\tchar findR[] = \"rrrrrrrrrr\";\n\t\t\tchar findG[] = \"gggggggggg\";\n\t\t\tchar findB[] = \"bbbbbbbbbb\";\n\t\t\t\n\t\t\tstrcpy(color, que[sq].color);\n\t\t\tsq = (sq + 1) % Q_MAX;\n\t\t\t\n\t\t\tif (strncmp(color, findR, strlen(color)) == 0 ||\n\t\t\tstrncmp(color, findG, strlen(color)) == 0 ||\n\t\t\tstrncmp(color, findB, strlen(color)) == 0){\n\t\t\t\tcount = (cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; color[i + 1] != '\\0'; i++){\n\t\t\t\tif (color[i] != color[i + 1]){\n\t\t\t\t\tchar buf[N];\n\t\t\t\t\tchar check[3] = {1, 1, 1};\n\t\t\t\t\tchar flag = 1;\n\t\t\t\t\t\n\t\t\t\t\tstrcpy(buf, color);\n\t\t\t\t\tif (buf[i] == 'r' || buf[i + 1] == 'r') check[0] = 0;\n\t\t\t\t\tif (buf[i] == 'g' || buf[i + 1] == 'g') check[1] = 0;\n\t\t\t\t\tif (buf[i] == 'b' || buf[i + 1] == 'b') check[2] = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (check[0] == 1){\n\t\t\t\t\t\tbuf[i] = 'r';\n\t\t\t\t\t\tbuf[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[1] == 1){\n\t\t\t\t\t\tbuf[i] = 'g';\n\t\t\t\t\t\tbuf[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[2] == 1){\n\t\t\t\t\t\tbuf[i] = 'b';\n\t\t\t\t\t\tbuf[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < eq; j++){\n\t\t\t\t\t\tif (strcmp(buf, used[j]) == 0){\n\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (flag == 1){\n\t\t\t\t\t\tque[eq].cost = cost + 1;\n\t\t\t\t\t\tstrcpy(que[eq].color, buf);\n\t\t\t\t\t\tstrcpy(used[eq], buf);\n\t\t\t\t\t\teq = (eq + 1) % Q_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != -1){\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\t\n\t} while (1);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar s[1000000][12],c[12];\nint main(){\n  int t,r,i,j,f,a[1000000]={0};\n  while(scanf(\"%s\",s[t=0]),s[0][1]){\n    for(r=1;r-t;t++){\n      for(i=f=1;s[t][i];i++){\n\tif(s[t][i-1]==s[t][i])continue;\n\tf=0;\n\tstrcpy(c,s[t]);\n\tif(s[t][i-1]+s[t][i]=='g'+'r')c[i-1]=c[i]='b';\n\tif(s[t][i-1]+s[t][i]=='g'+'b')c[i-1]=c[i]='r';\n\tif(s[t][i-1]+s[t][i]=='b'+'r')c[i-1]=c[i]='g';\n\tfor(j=0;j<r;j++){\n\t  if(strcmp(c,s[j])==0)break;\n\t}\n\tif(j-r)continue;\n\tstrcpy(s[r],c);\n\ta[r++]=a[t]+1;\n      }\n      if(f)break;\n      if(r>200000)break;\n    }\n    if(f)printf(\"%d\\n\",a[t]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,n,from,to,mark[4][4][4][4][4][4][4][4][4][4],q[2000000][10],ss[10];\nchar sss[15];\n\nvoid check(int k,int cc1,int cc2){\n\tint i,cc;\n\tint *mk;\n\tcc=6-q[from][k]-q[from][k-1];\n\tfor(i=0;i<10;i++)q[to][i]=q[from][i];\n\tq[to][k]=cc1;q[to][k-1]=cc2;\n\n\tmk=&mark[q[to][0]][q[to][1]][q[to][2]][q[to][3]][q[to][4]][q[to][5]][q[to][6]][q[to][7]][q[to][8]][q[to][9]];\n\tcc=mark[q[from][0]][q[from][1]][q[from][2]][q[from][3]][q[from][4]][q[from][5]][q[from][6]][q[from][7]][q[from][8]][q[from][9]]+1;\n\n\tif(*mk==0){\n\t\t*mk=cc;\n\t\tto++;\n\t}else{\n\t\tif(*mk>cc)*mk=cc;\n\t}\n}\n\nint main(){\n\tfor(i=1;i<4;i++){\n\t\tmark[i][i][0][0][0][0][0][0][0][0]=1;\n\t\tmark[i][i][i][0][0][0][0][0][0][0]=1;\n\t\tmark[i][i][i][i][0][0][0][0][0][0]=1;\n\t\tmark[i][i][i][i][i][0][0][0][0][0]=1;\n\t\tmark[i][i][i][i][i][i][0][0][0][0]=1;\n\t\tmark[i][i][i][i][i][i][i][0][0][0]=1;\n\t\tmark[i][i][i][i][i][i][i][i][0][0]=1;\n\t\tmark[i][i][i][i][i][i][i][i][i][0]=1;\n\t\tmark[i][i][i][i][i][i][i][i][i][i]=1;\n\t}\n\tfor(i=0;i<27;i++){\n\t\tfor(j=0;j<2+i/3;j++){\n\t\t\tq[i][j]=i%3+1;\n\t\t}\n\t}\n\n\tfrom=0;to=27;\n\twhile(from<to){\n\t\tfor(i=1;i<10 && q[from][i]>0;i++){\n\t\t\tif(q[from][i]==q[from][i-1]){\n\t\t\t\tcheck(i,(q[from][i])%3+1,(q[from][i]+1)%3+1);\n\t\t\t\tcheck(i,(q[from][i]+1)%3+1,(q[from][i])%3+1);\n\t\t\t}\n\t\t}\n\t\tfrom++;\n\t}\n\n\twhile(scanf(\"%s\",sss)){\n\t\tif(sss[0]=='0')break;\n\t\tfor(i=0;i<10;i++){\n\t\t\tif(sss[i]=='r')ss[i]=1;\n\t\t\telse if(sss[i]=='g')ss[i]=2;\n\t\t\telse if(sss[i]=='b')ss[i]=3;\n\t\t\telse break;\n\t\t\tprintf(\"%d\",ss[i]);\n\t\t}\n\t\tfor(;i<10;i++){\n\t\t\tss[i]=0;\n\t\t\tprintf(\"%d\",ss[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\tj=mark[ss[0]][ss[1]][ss[2]][ss[3]][ss[4]][ss[5]][ss[6]][ss[7]][ss[8]][ss[9]];\n\t\tif(j==0)printf(\"NA\\n\"); else printf(\"%d\\n\",j-1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\nreturn n;\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000];\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(h[i=0]=-M;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n    f(mi,a);\n    //for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n    a[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n    //for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n    j=g(a);//printf(\"%d\\n\",j);\n    //if(j==0||j==n||j==n*2)break;\n    if(c[j]>c[mi]+1){\n      c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n      k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n      for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n      h[j]=k;//printf(\"%d\\n\",j);\n    }\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      //if(mi==0||mi==n||mi==n*2)break;\n      if(r==1)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n    h[i]=h[j=i*2];\n    if(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      //if(i==1)break;\n      if(r-1)h[i/2]=k;\n    }//printf(\"%d %d\\n\",h[0],h[1]);\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(i=0;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      //if(mi==0||mi==n||mi==n*2)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      if(r==1)break;\n      h[i/2]=k;\n    }\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;c=getchar(),~c;)if(c-10)b=b*4+c%3+1,u=u*4+1;else{for(S[q=b]=0;b%u;b=Q[b])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=S[b]+1:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,b=u=0,4<<20);}}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], *top, *end, *qmax = Q + QMAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q, qmax = Q+QMAX;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); goto Done; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n//\t\t\t\ts2 &= mask;\n\t\t\t\tif (chk[s2]) continue;\n\t\t\t\tchk[s2] = 1;\n\t\t\t\t*end = s2; if (++end >= qmax) end = Q;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t\tDone:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], top, end, qmax = QMAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 3, 10, 5, 0, 7, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) + k;\n\t\t}\n\t\tmask = (1 << N) - 1;\n\t\tr = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\tQ[0] = s, Q[1] = -1, chk[s] = 1, top = 0, end = 2, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = Q[top]; if (++top >= qmax) top = 0;\n\t\t\tif (s < 0) { step++, Q[end] = -1; if (++end >= qmax) end = 0; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\ts2 &= mask;\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\tQ[end] = s2; if (++end >= qmax) end = 0;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n\n#define Q_MAX 1000000\n#define N 11\n\ntypedef struct {\n\tint cost;\n\tchar color[N];\n} QUEUE;\n\n\nint main(void)\n{\n\tchar bug[N];\n\tint i, j;\n\tstatic QUEUE que[Q_MAX];\n\tint sq, eq;\n\tstatic char used[Q_MAX][N];\n\t\n\tdo {\n\t\tint count = -1;\n\t\tscanf(\"%s\", bug);\n\t\t\n\t\tif (bug[0] == '0') break;\n\t\t\n\t\tsq = 0;\n\t\teq = 1;\n\t\tmemset(que, 0, sizeof(que));\n\t\tmemset(used, 0, sizeof(used));\n\t\tque[sq].cost = 0;\n\t\tstrcpy(que[sq].color, bug);\n\t\t\n\t\twhile (sq != eq){\n\t\t\tchar color[N];\n\t\t\tint cost = que[sq].cost;\n\t\t\tchar findR[] = \"rrrrrrrrrr\";\n\t\t\tchar findG[] = \"gggggggggg\";\n\t\t\tchar findB[] = \"bbbbbbbbbb\";\n\t\t\t\n\t\t\tstrcpy(color, que[sq].color);\n\t\t\tsq = (sq + 1) % Q_MAX;\n\t\t\t\n\t\t\tif (strncmp(color, findR, strlen(color)) == 0 ||\n\t\t\tstrncmp(color, findG, strlen(color)) == 0 ||\n\t\t\tstrncmp(color, findB, strlen(color)) == 0){\n\t\t\t\tcount = (cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; color[i + 1] != '\\0'; i++){\n\t\t\t\tif (color[i] != color[i + 1]){\n\t\t\t\t\tchar buf[N];\n\t\t\t\t\tchar check[3] = {1, 1, 1};\n\t\t\t\t\tchar flag = 1;\n\t\t\t\t\t\n\t\t\t\t\tstrcpy(buf, color);\n\t\t\t\t\tif (buf[i] == 'r' || buf[i + 1] == 'r') check[0] = 0;\n\t\t\t\t\tif (buf[i] == 'g' || buf[i + 1] == 'g') check[1] = 0;\n\t\t\t\t\tif (buf[i] == 'b' || buf[i + 1] == 'b') check[2] = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (check[0] == 1){\n\t\t\t\t\t\tbuf[i] = 'r';\n\t\t\t\t\t\tbuf[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[1] == 1){\n\t\t\t\t\t\tbuf[i] = 'g';\n\t\t\t\t\t\tbuf[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[2] == 1){\n\t\t\t\t\t\tbuf[i] = 'b';\n\t\t\t\t\t\tbuf[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < eq; j++){\n\t\t\t\t\t\tif (strcmp(buf, used[j]) == 0){\n\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (flag == 1){\n\t\t\t\t\t\tque[eq].cost = cost + 1;\n\t\t\t\t\t\tstrcpy(que[eq].color, buf);\n\t\t\t\t\t\tstrcpy(used[eq], buf);\n\t\t\t\t\t\teq = (eq + 1) % Q_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != -1){\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\t\n\t} while (1);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n}\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(i=0;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    k=-1;\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      if(mi==0||mi==n||mi==n*2)break;\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      if(r==1)break;\n      h[i/2]=k;\n    }\n    if(r-1||k==-1)printf(\"%d\\n\",c[mi]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;read(0,&c,1);)if(c-10)b=b*4+c%3+1,u=u*4+1;else{for(c=S[q=b]=0;b%u;c=S[b=Q[b]]+1)for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=c:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,c=b=u=0,4<<20);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n\n#define Q_MAX 1000000\n#define N 11\n\ntypedef struct {\n\tint cost;\n\tchar color[N];\n} QUEUE;\n\n\nint main(void)\n{\n\tchar bug[N];\n\tint i, j;\n\tstatic QUEUE que[Q_MAX];\n\tint sq, eq;\n\t\n\tdo {\n\t\tint count = -1;\n\t\tscanf(\"%s\", bug);\n\t\t\n\t\tif (bug[0] == '0') break;\n\t\t\n\t\tsq = 0;\n\t\teq = 1;\n\t\tmemset(que, 0, sizeof(que));\n\t\tque[sq].cost = 0;\n\t\tstrcpy(que[sq].color, bug);\n\t\t\n\t\twhile (sq != eq){\n\t\t\tchar color[N];\n\t\t\tint cost = que[sq].cost;\n\t\t\t\n\t\t\tstrcpy(color, que[sq].color);\n\t\t\tsq = (sq + 1) % Q_MAX;\n\t\t\t\n\t\t\tif (strncmp(color, \"rrrrrrrrrr\", strlen(color)) == 0 ||\n\t\t\tstrncmp(color, \"gggggggggg\", strlen(color)) == 0 ||\n\t\t\tstrncmp(color, \"bbbbbbbbbb\", strlen(color)) == 0){\n\t\t\t\tcount = (cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; color[i + 1] != '\\0'; i++){\n\t\t\t\tif (color[i] != color[i + 1]){\n\t\t\t\t\tchar buf[N];\n\t\t\t\t\tchar check[3] = {1, 1, 1};\n\t\t\t\t\tchar flag = 1;\n\t\t\t\t\t\n\t\t\t\t\tstrcpy(buf, color);\n\t\t\t\t\tif (buf[i] == 'r' || buf[i + 1] == 'r') check[0] = 0;\n\t\t\t\t\tif (buf[i] == 'g' || buf[i + 1] == 'g') check[1] = 0;\n\t\t\t\t\tif (buf[i] == 'b' || buf[i + 1] == 'b') check[2] = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (check[0] == 1){\n\t\t\t\t\t\tbuf[i] = 'r';\n\t\t\t\t\t\tbuf[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[1] == 1){\n\t\t\t\t\t\tbuf[i] = 'g';\n\t\t\t\t\t\tbuf[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[2] == 1){\n\t\t\t\t\t\tbuf[i] = 'b';\n\t\t\t\t\t\tbuf[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif (flag == 1){\n\t\t\t\t\t\tque[eq].cost = cost + 1;\n\t\t\t\t\t\tstrcpy(que[eq].color, buf);\n\t\t\t\t\t\teq = (eq + 1) % Q_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != -1){\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\t\n\t} while (1);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nint d[110][60000]={0};\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    for(i=0;i<110;i++){\n      for(j=0;j<60000;j++)d[i][j]=0;\n    }\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[0][n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<100;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==0)continue;\n\td[i+1][j]=zMIN(d[i+1][j],d[i][j]);\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[i+1][g(a)]=zMIN(d[i+1][g(a)],d[i][j]+1);\n\t}\n      }\n    }\n    d[100][0]=zMIN(d[100][0],zMIN(d[100][n/2],d[100][n]));\n    if(d[100][0])printf(\"%d\\n\",d[100][0]-1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint l;\n//char s[60000][12],c[12];\nint g(char a[20]){\n  int n=0,i;\n  for(i=l;i;i--){\n    if(a[i-1]=='r')n=n*3+0;\n    if(a[i-1]=='g')n=n*3+1;\n    if(a[i-1]=='b')n=n*3+2;\n  }\n  return n;\n}\nint main(){\n  int t,r,i,j,f,a[60000];\n  char s[60000][12],c[12];\n  while(scanf(\"%s\",s[0]),s[0][1]){\n    l=strlen(s[0]);\n    int u[60000]={0};\n    u[g(s[0])]=1;\n    a[0]=t=0;\n    for(r=1;r-t;t++){//printf(\"%s\\n\",s[t]);\n      for(i=f=1;s[t][i];i++){//printf(\"%s\\n\",s[t]);\n\tif(s[t][i-1]==s[t][i])continue;\n\tf=0;\n\tstrcpy(c,s[t]);\n\tif(s[t][i-1]+s[t][i]=='g'+'r')c[i-1]=c[i]='b';\n\tif(s[t][i-1]+s[t][i]=='g'+'b')c[i-1]=c[i]='r';\n\tif(s[t][i-1]+s[t][i]=='b'+'r')c[i-1]=c[i]='g';\n\tif(u[g(c)])continue;//printf(\"c%s\\n\",c);\n\tstrcpy(s[r],c);\n\ta[r++]=a[t]+1;\n\tu[g(c)]=1;\n      }\n      if(f)break;\n    }//printf(\"r%d\\n\",r);\n    if(f)printf(\"%d\\n\",a[t]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(h[i=0]=-M;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      //if(mi==0||mi==n||mi==n*2)break;\n      if(r==1)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      //if(r==1)break;\n      h[i/2]=k;\n    }//printf(\"%d %d\\n\",h[0],h[1]);\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;c=~getchar();)if(c+11)b=b*4-c%6,u=u*4+1;else{for(S[q=b]=0;b%u;b=Q[b])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=S[b]+1:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,b=u=0,4<<20);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000];\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(h[i=0]=-M;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    /*if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      //if(mi==0||mi==n||mi==n*2)break;\n      if(r==1)break;\n      k=h[--r];//printf(\"k%d\\n\",k);\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      //if(i==1)break;\n      if(r-1)h[i/2]=k;\n      //prih(h,r);printf(\"%d\\n\",r);\n    }//printf(\"%d %d\\n\",h[0],h[1]);\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct _body{\n\tstruct _body *next;\n\tchar color[11];\n\tint time;\n} BODY;\n\nBODY *head, *tail, *newnode;\n\nint solve_time(char *start);\nvoid change_color(char col, char *before, int i);\nint check(char *str);\nint sansin(char *str);\nvoid erase(void);\n\nint main(void)\n{\n\tBODY *temp;\n\t\n\tchar start[11];\n\tint judge;\n\t\n\tdo {\n\t\tscanf(\"%s\", start);\n\t\tif (start[0] - '0'){\n\t\t\tnewnode = (BODY *)malloc(sizeof(BODY));\n\t\t\thead = tail = newnode;\n\t\t\tnewnode->next = NULL;\n\t\t\tstrcpy(newnode->color, start);\n\t\t\thead->time = 0;\n\t\t\t\n\t\t\tjudge = solve_time(head->color);\n\t\t\t\n\t\t\tif (judge >= 0){\n\t\t\t\tprintf(\"%d\\n\", judge);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t}\n\t\twhile (head != NULL){\n\t\t\ttemp = head;\n\t\t\thead = head->next;\n\t\t\tfree(temp);\n\t\t}\n\t} while (start[0] != '0');\n\t\n\treturn (0);\n}\n\nint solve_time(char *start)\n{\n\tBODY *temp;\n\tint len = strlen(start);\n\tchar change[11];\n\tchar memo[59050] = {0};\n\tint i;\n\t\n\tmemo[sansin(start)] = 1;\n\tif (check(start) == len * 'r' || check(start) == len * 'g' || check(start) == len * 'b') {\n\t\treturn (0);\n\t}\n\t\n\telse {\n\t\twhile (1){\n\t\t\tif (head->time > 20) break;\n\t\t\tfor (i = 0; i < len - 1; i++){\n\t\t\t\tif (head->color[i] != head->color[i + 1] && head->color[i] != 'r' && head->color[i + 1] != 'r'){\n\t\t\t\t\tchange_color('r', head->color, i);\n\t\t\t\t\tif (memo[sansin(tail->color)] == 1) erase();\n\t\t\t\t\telse memo[sansin(tail->color)] = 1;\n\t\t\t\t\ttail->time = head->time + 1;\n\t\t\t\t\tif (check(tail->color) == len * 'r') return (tail->time);\n\t\t\t\t}\n\t\t\t\tif (head->color[i] != head->color[i + 1] && head->color[i] != 'g' && head->color[i + 1] != 'g'){\n\t\t\t\t\tchange_color('g', head->color, i);\n\t\t\t\t\tif (memo[sansin(tail->color)] == 1) erase();\n\t\t\t\t\telse memo[sansin(tail->color)] = 1;\n\t\t\t\t\ttail->time = head->time + 1;\n\t\t\t\t\tif (check(tail->color) == len * 'g') return (tail->time);\n\t\t\t\t}\n\t\t\t\tif (head->color[i] != head->color[i + 1] && head->color[i] != 'b' && head->color[i + 1] != 'b'){\n\t\t\t\t\tchange_color('b', head->color, i);\n\t\t\t\t\tif (memo[sansin(tail->color)] == 1) erase();\n\t\t\t\t\telse memo[sansin(tail->color)] = 1;\n\t\t\t\t\ttail->time = head->time + 1;\n\t\t\t\t\tif (check(tail->color) == len * 'b') return (tail->time);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttemp = head;\n\t\t\thead = head->next;\n\t\t\tfree(temp);\n\t\t}\n\t}\n\treturn (-1);\n}\n\nvoid change_color(char col, char *before, int i)\n{\n\tBODY *temp;\n\t\n\tnewnode = (BODY *)malloc(sizeof(BODY));\n\tstrcpy(newnode->color, before);\n\tnewnode->color[i] = newnode->color[i + 1] = col;\n\ttemp = head;\n\twhile (temp->next != NULL){\n\t\ttemp = temp->next;\n\t}\n\ttemp->next = newnode;\n\tnewnode->next = NULL;\n\ttail = newnode;\n}\n\nint check(char *str)\n{\n\tint sum = 0;\n\tint i = 0;\n\t\n\twhile (str[i] != '\\0'){\n\t\tsum += str[i];\n\t\ti++;\n\t}\n\t\n\treturn (sum);\n}\n\nint sansin(char *str)\n{\n\tint kekka, temp;\n\tint i = 0;\n\tkekka = temp = 0;\n\t\n\twhile (str[i] != '\\0'){\n\t\tif (str[i] == 'r') temp = 0;\n\t\telse if (str[i] == 'g') temp = 1;\n\t\telse temp = 2;\n\t\tkekka = kekka * 3 + temp;\n\t\ti++;\n\t}\n\treturn (kekka);\n}\n\nvoid erase(void)\n{\n\tBODY *temp, *pre;\n\t\n\ttemp = head;\n\twhile (temp->next != NULL){\n\t\tpre = temp;\n\t\ttemp = temp->next;\n\t}\n\tpre->next = NULL;\n\ttail = pre;\n\tfree(temp);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nint d[30][60000]={0};\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    for(i=0;i<30;i++){\n      for(j=0;j<60000;j++)d[i][j]=0;\n    }\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[0][n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<25;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==0)continue;\n\td[i+1][j]=zMIN(d[i+1][j],d[i][j]);\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[i+1][g(a)]=zMIN(d[i+1][g(a)],d[i][j]+1);\n\t}\n      }\n    }\n    d[25][0]=zMIN(d[25][0],zMIN(d[25][n/2],d[25][n]));\n    if(d[25][0])printf(\"%d\\n\",d[25][0]-1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n\n#define Q_MAX 1000000\n#define N 11\n\ntypedef struct {\n\tint cost;\n\tchar color[N];\n} QUEUE;\n\n\nint main(void)\n{\n\tchar bug[N];\n\tint i, j;\n\tstatic QUEUE que[Q_MAX];\n\tint sq, eq;\n\tstatic char used[Q_MAX][N];\n\t\n\tdo {\n\t\tint count = -1;\n\t\tscanf(\"%s\", bug);\n\t\t\n\t\tif (bug[0] == '0') break;\n\t\t\n\t\tsq = 0;\n\t\teq = 1;\n\t\tmemset(que, 0, sizeof(que));\n\t\tmemset(used, 0, sizeof(used));\n\t\tque[sq].cost = 0;\n\t\tstrcpy(que[sq].color, bug);\n\t\t\n\t\twhile (sq != eq){\n\t\t\tchar color[N];\n\t\t\tint cost = que[sq].cost;\n\t\t\tchar findR[] = \"rrrrrrrrrr\";\n\t\t\tchar findG[] = \"gggggggggg\";\n\t\t\tchar findB[] = \"bbbbbbbbbb\";\n\t\t\t\n\t\t\tstrcpy(color, que[sq].color);\n\t\t\tsq = (sq + 1) % Q_MAX;\n\t\t\t\n\t\t\tif (strncmp(color, findR, strlen(color)) == 0 ||\n\t\t\tstrncmp(color, findG, strlen(color)) == 0 ||\n\t\t\tstrncmp(color, findB, strlen(color)) == 0){\n\t\t\t\tcount = (cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = 0; color[i + 1] != '\\0'; i++){\n\t\t\t\tif (color[i] != color[i + 1]){\n\t\t\t\t\tchar buf[N];\n\t\t\t\t\tchar check[3] = {1, 1, 1};\n\t\t\t\t\tchar flag = 1;\n\t\t\t\t\t\n\t\t\t\t\tstrcpy(buf, color);\n\t\t\t\t\tif (buf[i] == 'r' || buf[i + 1] == 'r') check[0] = 0;\n\t\t\t\t\tif (buf[i] == 'g' || buf[i + 1] == 'g') check[1] = 0;\n\t\t\t\t\tif (buf[i] == 'b' || buf[i + 1] == 'b') check[2] = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (check[0] == 1){\n\t\t\t\t\t\tbuf[i] = 'r';\n\t\t\t\t\t\tbuf[i + 1] = 'r';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[1] == 1){\n\t\t\t\t\t\tbuf[i] = 'g';\n\t\t\t\t\t\tbuf[i + 1] = 'g';\n\t\t\t\t\t}\n\t\t\t\t\tif (check[2] == 1){\n\t\t\t\t\t\tbuf[i] = 'b';\n\t\t\t\t\t\tbuf[i + 1] = 'b';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (j = 0; j < eq; j++){\n\t\t\t\t\t\tif (strcmp(buf, used[j]) == 0){\n\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (flag == 1){\n\t\t\t\t\t\tque[eq].cost = cost + 1;\n\t\t\t\t\t\tstrcpy(que[eq].color, buf);\n\t\t\t\t\t\tstrcpy(used[eq], buf);\n\t\t\t\t\t\teq = (eq + 1) % Q_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != -1){\n\t\t\tprintf(\"%d\\n\", count);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\t\n\t} while (1);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;\nc,b,x,i,n,u;\nmain(){\n\tfor(;c=getchar(),c!='0';){\n\t\tif(c!='\\n'){\n\t\t\tb=b<<2|(c%3+1);//eÌßð2bit(1,2,3)Å\\»\n\t\t\tu=u<<2|1;//eÌßª1Ìp^[\n\t\t}else{\n\t\t\tS[b]=0;\n\t\t\tq=b;\n\t\t\tfor(;b%u;){//èØêêÎSÌßª¯¶F(b!=0)AÜ½ÍL[ªó(b==0)\n\t\t\t\tx=b^(b>>2);//×ÌÌßÆÌxor\n\t\t\t\tfor(i=0;x>3;i++,x>>=2){//Å¶Ì2bitÍxor³êÈ©Á½S~ÈÌÅ©È¢\n\t\t\t\t\tif(x&3){//×ÌÌßÆFªÙÈé\n\t\t\t\t\t\tc=(1^2^3)^(x&3);//Ç¿çÆàÙÈéF\n\t\t\t\t\t\tn=b&~(15<<i*2)^((c|c<<2)<<i*2);//Ï»\n\t\t\t\t\t\tif(!Q[n]){\n\t\t\t\t\t\t\tS[n]=S[b]+1;\n\t\t\t\t\t\t\tq=Q[q]=n;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb=Q[b];\n\t\t\t}\n\t\t\tif(b)\n\t\t\t\tprintf(\"%d\\n\",S[b]);\n\t\t\telse\n\t\t\t\tputs(\"NA\");\n\t\t\tb=u=0;\n\t\t\tmemset(Q,0,sizeof(Q));\n\t\t}\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;c=~getchar();)if(c+11)b=b*4-c%6,u=u*4+1;else{for(S[q=b]=0;b%u;b=Q[b])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=S[b]+1:0;b-1?b?printf(\"%d \\n\",S[b]):puts(\"NA\"):0;memset(Q,b=u=0,4<<20);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar s[1000000][12],c[12];\nint main(){\n  int t,r,i,j,f,a[1000000]={0};\n  while(scanf(\"%s\",s[t=0]),s[0][1]){\n    for(r=1;r-t;t++){\n      for(i=f=1;s[t][i];i++){\n\tif(s[t][i-1]==s[t][i])continue;\n\tf=0;\n\tstrcpy(c,s[t]);\n\tif(s[t][i-1]+s[t][i]=='g'+'r')c[i-1]=c[i]='b';\n\tif(s[t][i-1]+s[t][i]=='g'+'b')c[i-1]=c[i]='r';\n\tif(s[t][i-1]+s[t][i]=='b'+'r')c[i-1]=c[i]='g';\n\tfor(j=0;j<r;j++){\n\t  if(strcmp(c,s[j])==0)break;\n\t}\n\tif(j-r)continue;\n\tstrcpy(s[r],c);\n\ta[r++]=a[t]+1;\n      }\n      if(f)break;\n      if(r>500000)break;\n    }\n    if(f)printf(\"%d\\n\",a[t]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;read(0,&c,1);)if(c-10)b=b*4+c%3+1,u=u*4+1;else{for(S[q=b]=0;b%u;b=Q[b])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=S[b]+1:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,b=u=0,4<<20);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar t[3000000];\nint q[99999];\n\nint main(void){\n\tint l, r, n, g, b, c, x, y, i, c1, c2;\n\tchar s[20];\n\tfor(; scanf(\"%s\", s ), *s - '0';){\n\t\tmemset( t, 0, 700000 );\n\t\t*q = 0;\n\t\tfor( n = 0; s[n]; n++ ){\n\t\t\t*q |= ( s[n] == 'b' ? 2 : s[n] == 'g' ) << ( 2 * n );\n\t\t}\n\t\tn *= 2;\n\t\tg = 0x55555 & ( 1 << n ) - 1;\n\t\tb = 0xAAAAA & ( 1 << n ) - 1;\n\n\t\tq[1] = -1;\n\t\tl = c = 0;\n\t\tr = 2;\n\t\tfor(; r - l > 1; ){\n\t\t\tx = q[l++];\n\t\t\tif( !x || x == g || x == b ){ ++r;\tbreak;\t}\n\t\t\tif( x == -1 ){\t++c;\tq[r++] = -1;\t}\n\t\t\telse{\n\t\t\t\tc1 = x & 3;\n\t\t\t\tfor( i = 2; i < n; i += 2 ){\n\t\t\t\t\tc2 = x >> i & 3;\n\t\t\t\t\tif( c1 != c2 ){\n\t\t\t\t\t\ty = x & ~( 15 << i - 2 );\n\t\t\t\t\t\ty |= ( 3 - c1 - c2 ) * 5 << i - 2;\n\t\t\t\t\t\tif( !t[y] ){\n\t\t\t\t\t\t\tt[y] = 1;\n\t\t\t\t\t\t\tq[r++] = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc1 = c2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( r - l > 1 ){\tprintf(\"%d\\n\", c );\t}\n\t\telse{\tputs(\"NA\");\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;read(0,&c,1);)if(c-10)b=b*4+c%3+1,u=u*4+1;else{for(S[q=b]=0;b%u;b=Q[b])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=S[b]+1:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,b=u=0,4<<20);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint l;\nvoid f(int n,int a[20]){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int a[20]){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\nreturn n;\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    int d[60000]={0};\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<100;i++){\n      for(j=0;j<=n;j++){\n    if(d[j]==0)continue;\n    for(k=1;k<l;k++){\n      f(j,a);\n      a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n      d[g(a)]=zMIN(d[g(a)],d[j]+1);\n    }\n      }\n    }\n    d[0]=zMIN(d[0],zMIN(d[n/2],d[n]));\n    if(d[0])printf(\"%d\\n\",d[0]-1);\n    else    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nint d[30][60000]={0};\nvoid f(int n,int a[20]){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int a[20]){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    for(i=0;i<30;i++){\n      for(j=0;j<60000;j++)d[i][j]=0;\n    }\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[0][n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<25;i++){\n      for(j=0;j<=n;j++){\n\tif(d[i][j]==0)continue;\n\td[i+1][j]=zMIN(d[i+1][j],d[i][j]);\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[i+1][g(a)]=zMIN(d[i+1][g(a)],d[i][j]+1);\n\t}\n      }\n    }\n    d[25][0]=zMIN(d[25][0],zMIN(d[25][n/2],d[25][n]));\n    if(d[25][0])printf(\"%d\\n\",d[25][0]-1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], top, end, qmax = QMAX;\nint N, K;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b;\n\tint step;\n\tint i, k, k2;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) + k;\n\t\t}\n\t\tr = 0, g = 0x55555 & ((1 << N) - 1), b = 0xaaaa & ((1 << N) - 1);\n\t\tQ[0] = s, Q[1] = -1, chk[s] = 1, top = 0, end = 2, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = Q[top]; if (++top == qmax) top = 0;\n\t\t\tif (s < 0) { step++, Q[end++] = -1; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\tQ[end] = s2; if (++end == qmax) end = 0;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], top, end, qmax = QMAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b;\n\tint step;\n\tint i, k, k2;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) + k;\n\t\t}\n\t\tmask = (1 << N) - 1;\n\t\tr = 0, g = 0x55555 & mask, b = 0xaaaa & mask;\n\t\tQ[0] = s, Q[1] = -1, chk[s] = 1, top = 0, end = 2, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = Q[top]; if (++top == qmax) top = 0;\n\t\t\tif (s < 0) { step++, Q[end++] = -1; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\ts2 &= mask;\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\tQ[end] = s2; if (++end == qmax) end = 0;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define QSIZE 10000\nchar q[QSIZE][11];\nint qh=0;\nint qt=0;\n\nint enQ(char str[]){\n\tmemcpy(q[qt],str,11);\n\tqt=(qt+1)%QSIZE;\n\treturn (qt-qh+QSIZE)%QSIZE;\n}\n\nint deQ(char str[]){\n\tmemcpy(str,q[qh],11);\n\tqh=(qh+1)%QSIZE;\n\treturn (qt-qh+QSIZE)%QSIZE;\n}\nint Qlen(){\n\treturn (qt-qh+QSIZE)%QSIZE;\n}\n\nint hoge(char str[]){\n\tint i;\n\tfor(i=0;str[i]!='\\0';i++){\n\t\tswitch(str[i]){\n\t\t\tcase 'r':\n\t\t\t\tstr[i]='0';\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tstr[i]='1';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tstr[i]='2';\n\t\t}\n\t}\n\treturn i;\n}\n\nint ato3(char str[]){\n\tint i;\n\tint keta=1;\n\tint r=0;\n\tfor(i=strlen(str)-1;i>=0;i--){\n\t\tr+=(str[i]-'0')*keta;\n\t\tketa*=3;\n\t}\n\treturn r;\n}\n\nmain(){\n\tchar str[11],str2[11];\n\tchar goal[3][11];\n\tchar musi[177147];\n\tint N;\n\tint len;\n\tint sec;\n\tint i,j;\n\twhile(scanf(\"%s\",&str)==1){\n\t\tif(str[0]=='0')\n\t\t\tbreak;\n\t\tqh=qt=0;\n\t\tmemset(musi,-1,177147);\n\t\tlen=hoge(str);\n\t\tN=enQ(str);\n\t\tsec=0;\n\t\tmusi[ato3(str)]=sec;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<len;j++)\n\t\t\t\tgoal[i][j]=i+'0';\n\t\t\tgoal[i][j]='\\0';\n\t\t}\n\t\twhile(1){\n\t\t\tif(musi[ato3(goal[0])]!=-1){\n\t\t\t\t\tprintf(\"%d\\n\",sec);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(musi[ato3(goal[1])]!=-1){\n\t\t\t\t\tprintf(\"%d\\n\",sec);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(musi[ato3(goal[2])]!=-1){\n\t\t\t\t\tprintf(\"%d\\n\",sec);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(N==0){\n\t\t\t\tputs(\"NA\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsec++;\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tdeQ(str);\n\t\t\t\tfor(i=0;i<len-1;i++){\n\t\t\t\t\tif(str[i]!=str[i+1]){\n\t\t\t\t\t\tstrcpy(str2,str);\n\t\t\t\t\t\tstr2[i]=str2[i+1]=3+3*'0'-str[i]-str[i+1];\n\t\t\t\t\t\tif(musi[ato3(str2)]==-1){\n\t\t\t\t\t\t\tmusi[ato3(str2)]=sec;\n\t\t\t\t\t\t\tenQ(str2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tN=Qlen();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], *top, *end, *qmax = Q + QMAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 3, 10, 5, 0, 7, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q, qmax = Q+QMAX;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n//\t\t\t\ts2 &= mask;\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\t*end = s2; if (++end >= qmax) end = Q;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(i=0;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n    }\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      if(mi==0||mi==n||mi==n*2)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      if(r==1)break;\n      h[i/2]=k;\n    }\n    if(r-1)printf(\"%d\\n\",c[mi]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX (2*MAX)\nchar chk[MAX+10];\nint Q[QMAX+10], top, end, qmax = QMAX;\nint N, K;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b;\n\tint step;\n\tint i, k, k2;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) + k;\n\t\t}\n\t\tr = 0, g = 0x55555 & ((1 << N) - 1), b = 0xaaaa & ((1 << N) - 1);\n\t\tQ[0] = s, Q[1] = -1, chk[s] = 1, top = 0, end = 2, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = Q[top]; if (++top == qmax) top = 0;\n\t\t\tif (s < 0) { step++, Q[end++] = -1; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\tQ[end] = s2; if (++end == qmax) end = 0;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct _body{\n\tstruct _body *next;\n\tchar color[11];\n\tint time;\n} BODY;\n\nBODY *head, *tail, *newnode;\n\nint solve_time(char *start);\nvoid change_color(char col, char *before, int i);\nint check(char *str);\nint sansin(char *str);\nvoid erase(void);\n\nint main(void)\n{\n\tBODY *temp;\n\t\n\tchar start[11];\n\tint judge;\n\t\n\tdo {\n\t\tscanf(\"%s\", start);\n\t\tif (start[0] - '0'){\n\t\t\tnewnode = (BODY *)malloc(sizeof(BODY));\n\t\t\thead = tail = newnode;\n\t\t\tnewnode->next = NULL;\n\t\t\tstrcpy(newnode->color, start);\n\t\t\thead->time = 0;\n\t\t\t\n\t\t\tjudge = solve_time(head->color);\n\t\t\t\n\t\t\tif (judge >= 0){\n\t\t\t\tprintf(\"%d\\n\", judge);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t}\n\t\twhile (head != NULL){\n\t\t\ttemp = head;\n\t\t\thead = head->next;\n\t\t\tfree(temp);\n\t\t}\n\t} while (start[0] != '0');\n\t\n\treturn (0);\n}\n\nint solve_time(char *start)\n{\n\tBODY *temp;\n\tint len = strlen(start);\n\tchar change[11];\n\tchar memo[59050] = {0};\n\tint i;\n\t\n\tmemo[sansin(start)] = 1;\n\tif (check(start) == len * 'r' || check(start) == len * 'g' || check(start) == len * 'b') {\n\t\treturn (0);\n\t}\n\t\n\telse {\n\t\twhile (1){\n\t\t\tif (head->time > 30) break;\n\t\t\tfor (i = 0; i < len - 1; i++){\n\t\t\t\tif (head->color[i] != head->color[i + 1] && head->color[i] != 'r' && head->color[i + 1] != 'r'){\n\t\t\t\t\tchange_color('r', head->color, i);\n\t\t\t\t\tif (memo[sansin(tail->color)] == 1) erase();\n\t\t\t\t\telse memo[sansin(tail->color)] = 1;\n\t\t\t\t\ttail->time = head->time + 1;\n\t\t\t\t\tif (check(tail->color) == len * 'r') return (tail->time);\n\t\t\t\t}\n\t\t\t\tif (head->color[i] != head->color[i + 1] && head->color[i] != 'g' && head->color[i + 1] != 'g'){\n\t\t\t\t\tchange_color('g', head->color, i);\n\t\t\t\t\tif (memo[sansin(tail->color)] == 1) erase();\n\t\t\t\t\telse memo[sansin(tail->color)] = 1;\n\t\t\t\t\ttail->time = head->time + 1;\n\t\t\t\t\tif (check(tail->color) == len * 'g') return (tail->time);\n\t\t\t\t}\n\t\t\t\tif (head->color[i] != head->color[i + 1] && head->color[i] != 'b' && head->color[i + 1] != 'b'){\n\t\t\t\t\tchange_color('b', head->color, i);\n\t\t\t\t\tif (memo[sansin(tail->color)] == 1) erase();\n\t\t\t\t\telse memo[sansin(tail->color)] = 1;\n\t\t\t\t\ttail->time = head->time + 1;\n\t\t\t\t\tif (check(tail->color) == len * 'b') return (tail->time);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttemp = head;\n\t\t\tif (head->next == NULL) return (-1);\n\t\t\thead = head->next;\n\t\t\tfree(temp);\n\t\t}\n\t}\n\treturn (-1);\n}\n\nvoid change_color(char col, char *before, int i)\n{\n\tBODY *temp;\n\t\n\tnewnode = (BODY *)malloc(sizeof(BODY));\n\tstrcpy(newnode->color, before);\n\tnewnode->color[i] = newnode->color[i + 1] = col;\n\ttemp = head;\n\twhile (temp->next != NULL){\n\t\ttemp = temp->next;\n\t}\n\ttemp->next = newnode;\n\tnewnode->next = NULL;\n\ttail = newnode;\n}\n\nint check(char *str)\n{\n\tint sum = 0;\n\tint i = 0;\n\t\n\twhile (str[i] != '\\0'){\n\t\tsum += str[i];\n\t\ti++;\n\t}\n\t\n\treturn (sum);\n}\n\nint sansin(char *str)\n{\n\tint kekka, temp;\n\tint i = 0;\n\tkekka = temp = 0;\n\t\n\twhile (str[i] != '\\0'){\n\t\tif (str[i] == 'r') temp = 0;\n\t\telse if (str[i] == 'g') temp = 1;\n\t\telse temp = 2;\n\t\tkekka = kekka * 3 + temp;\n\t\ti++;\n\t}\n\treturn (kekka);\n}\n\nvoid erase(void)\n{\n\tBODY *temp, *pre;\n\t\n\ttemp = head;\n\twhile (temp->next != NULL){\n\t\tpre = temp;\n\t\ttemp = temp->next;\n\t}\n\tpre->next = NULL;\n\ttail = pre;\n\tfree(temp);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint l;\nvoid f(int n,int a[20]){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int a[20]){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    int d[60000]={0};\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<25;i++){\n      for(j=0;j<=n;j++){\n\tif(d[j]==0)continue;\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[g(a)]=zMIN(d[g(a)],d[j]+1);\n\t}\n      }\n    }\n    d[0]=zMIN(d[0],zMIN(d[n/2],d[n]));\n    if(d[0])printf(\"%d\\n\",d[0]-1);\n    else    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,n,from,to,mark[4][4][4][4][4][4][4][4][4][4],q[2000000][10],ss[10];\nchar sss[15];\n\nvoid check(int k,int cc1,int cc2){\n\tint i,cc;\n\tint *mk;\n\tcc=6-q[from][k]-q[from][k-1];\n\tfor(i=0;i<10;i++)q[to][i]=q[from][i];\n\tq[to][k]=cc1;q[to][k-1]=cc2;\n\n\tmk=&mark[q[to][0]][q[to][1]][q[to][2]][q[to][3]][q[to][4]][q[to][5]][q[to][6]][q[to][7]][q[to][8]][q[to][9]];\n\tcc=mark[q[from][0]][q[from][1]][q[from][2]][q[from][3]][q[from][4]][q[from][5]][q[from][6]][q[from][7]][q[from][8]][q[from][9]]+1;\n\n\tif(*mk==0){\n\t\t*mk=cc;\n\t\tto++;\n\t}else{\n\t\tif(*mk>cc)*mk=cc;\n\t}\n}\n\nint main(){\n\tfor(i=1;i<4;i++){\n\t\tmark[i][i][0][0][0][0][0][0][0][0]=1;\n\t\tmark[i][i][i][0][0][0][0][0][0][0]=1;\n\t\tmark[i][i][i][i][0][0][0][0][0][0]=1;\n\t\tmark[i][i][i][i][i][0][0][0][0][0]=1;\n\t\tmark[i][i][i][i][i][i][0][0][0][0]=1;\n\t\tmark[i][i][i][i][i][i][i][0][0][0]=1;\n\t\tmark[i][i][i][i][i][i][i][i][0][0]=1;\n\t\tmark[i][i][i][i][i][i][i][i][i][0]=1;\n\t\tmark[i][i][i][i][i][i][i][i][i][i]=1;\n\t}\n\tfor(i=0;i<27;i++){\n\t\tfor(j=0;j<2+i/3;j++){\n\t\t\tq[i][j]=i%3+1;\n\t\t}\n\t}\n\n\tfrom=0;to=27;\n\twhile(from<to){\n\t\tfor(i=1;i<10 && q[from][i]>0;i++){\n\t\t\tif(q[from][i]==q[from][i-1]){\n\t\t\t\tcheck(i,(q[from][i])%3+1,(q[from][i]+1)%3+1);\n\t\t\t\tcheck(i,(q[from][i]+1)%3+1,(q[from][i])%3+1);\n\t\t\t}\n\t\t}\n\t\tfrom++;\n\t}\n\n\twhile(scanf(\"%s\",sss)){\n\t\tif(sss[0]=='0')break;\n\t\tfor(i=0;i<10;i++){\n\t\t\tif(sss[i]=='r')ss[i]=1;\n\t\t\telse if(sss[i]=='g')ss[i]=2;\n\t\t\telse if(sss[i]=='b')ss[i]=3;\n\t\t\telse break;\n\t\t}\n\t\tfor(;i<10;i++){\n\t\t\tss[i]=0;\n\t\t}\n\n\t\tj=mark[ss[0]][ss[1]][ss[2]][ss[3]][ss[4]][ss[5]][ss[6]][ss[7]][ss[8]][ss[9]];\n\t\tif(j==0)printf(\"NA\\n\"); else printf(\"%d\\n\",j-1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint l;\nvoid f(int n,int a[20]){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int a[20]){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    int d[60000]={0};\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<100;i++){\n      for(j=0;j<=n;j++){\n\tif(d[j]==0)continue;\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[g(a)]=zMIN(d[g(a)],d[j]+1);\n\t}\n      }\n    }\n    d[0]=zMIN(d[0],zMIN(d[n/2],d[n]));\n    if(d[0])printf(\"%d\\n\",d[0]-1);\n    else    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s[10000][12],c[12];\n  int t,r,i,j,f,a[100000]={0};\n  while(scanf(\"%s\",s[t=0]),s[0][1]){\n    for(r=1;r-t;t++){\n      for(i=f=1;s[t][i];i++){\n\tif(s[t][i-1]==s[t][i])continue;\n\tf=0;\n\tstrcpy(c,s[t]);\n\tif(s[t][i-1]+s[t][i]=='g'+'r')c[i-1]=c[i]='b';\n\tif(s[t][i-1]+s[t][i]=='g'+'b')c[i-1]=c[i]='r';\n\tif(s[t][i-1]+s[t][i]=='b'+'r')c[i-1]=c[i]='g';\n\tfor(j=0;j<r;j++){\n\t  if(strcmp(c,s[j])==0)break;\n\t}\n\tif(j-r)continue;\n\tstrcpy(s[r],c);\n\ta[r++]=a[t]+1;\n      }\n      if(f)break;\n    }\n    if(f)printf(\"%d\\n\",a[t]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;read(0,&c,1);)if(c-10)b=b*4+c%3+1,u=u*4+1;else{for(c=S[q=b]=0;b%u;c=S[b=Q[b]])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=c+1:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,c=b=u=0,4<<20);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct NODE {\n\tchar body[11];\n\tint  time;\n\tint  hash;\n\tstruct NODE *next;\n};\n\nstruct NODE *head;\nstruct NODE *tail;\n\nint node_num = 0;\n\nint change_worm(char *worm);\t\nvoid add_node(char *worm, int time);\nint calc_hash(char *worm);\nint change_color(struct NODE *node);\nint check_body(char *worm);\nint check_hash(int hash);\nvoid free_node(void);\n\nint main(void)\n{\n\tchar worm[11];\n\tint time;\n\n\t\n\twhile (1){\n\t\tscanf(\"%s\", worm);\n\t\t\n\t\tif (worm[0] == '0'){\n\t\t\tbreak;\n\t\t}\n\t\ttime = change_worm(worm);\n\t\tif (time == -1){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", time);\n\t\t}\n\t\tnode_num = 0;\n\t\t\n\t\tfree_node();\n\t}\n\treturn (0);\n}\n\nint change_worm(char *worm)\t\n{\n\tstruct NODE *node;\n\tint time;\n\t\n\tadd_node(worm, 0);\n\t\n\tnode = head;\n\t\n\twhile (node != NULL){\n//\t\tprintf(\"-->%d %s\\n\", node->time, node->body);\n\t\ttime = change_color(node);\n\t\tif (time >= 0){\n\t\t\treturn (time);\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn (-1);\n}\n\nvoid add_node(char *worm, int time)\n{\n\tstruct NODE *node;\n\tint hash;\n\tint i;\n\t\n\tnode = malloc(sizeof(struct NODE));\n\t\n\tstrcpy(node->body, worm);\n\tnode->time = time;\n\tnode->hash = calc_hash(node->body);\n\tnode->next = NULL;\n\t\n\tif (head == NULL){\n\t\thead = tail = node;\n\t}\n\telse {\n\t\ttail->next = node;\n\t\ttail = node;\n\t}\n//printf(\"<%d>\\n\", ++node_num);\n//\tprintf(\"[%d  %s]\\n\", time, worm);\n}\n\t\nint calc_hash(char *worm)\n{\n\tint hash;\n\tint i;\n\t\n\thash = 0;\n\ti = 0;\n\twhile (worm[i] != '\\0'){\n\t\thash *= 3;\n\t\tswitch (worm[i]){\n\t\t  case 'r':\n\t\t    break;\n\t\t\t\n\t\t  case 'g':\n\t\t    hash++;\n\t\t\tbreak;\n\t\t\t\n\t\t  case 'b':\n\t\t\thash += 2;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (hash);\n}\n\nint change_color(struct NODE *node)\n{\n\tint i;\n\tchar new_worm[11];\n\tint hash;\n\t\n\tif (check_body(node->body) == 1){\n\t\treturn (node->time);\n\t}\n\n\ti = 0;\n\twhile (node->body[i + 1] != '\\0'){\n\t\tif (node->body[i] != node->body[i + 1]){\n\t\t\tstrcpy(new_worm, node->body);\n\t\t\tif (new_worm[i] != 'r' && new_worm[i + 1] != 'r'){\n\t\t\t\tnew_worm[i] = new_worm[i + 1] = 'r';\n\t\t\t}\n\t\t\telse if (new_worm[i] != 'g' && new_worm[i + 1] != 'g'){\n\t\t\t\tnew_worm[i] = new_worm[i + 1] = 'g';\n\t\t\t}\n\t\t\telse if (new_worm[i] != 'b' && new_worm[i + 1] != 'b'){\n\t\t\t\tnew_worm[i] = new_worm[i + 1] = 'b';\n\t\t\t}\n\t\t\t\n\t\t\tif (check_body(new_worm) == 1){\n\t\t\t\treturn (node->time + 1);\n\t\t\t}\n\t\t\t\n\t\t\tif (check_hash(calc_hash(new_worm)) == 1){\n\t\t\t\tadd_node(new_worm, node->time + 1);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (-1);\n}\n\nint check_body(char *worm)\n{\n\tint i;\n\tchar first;\n\t\n\tfirst = worm[0];\n\ti = 1;\n\twhile (worm[i] != '\\0'){\n\t\tif (worm[i] != first){\n\t\t\treturn (0);\n\t\t}\n\t\ti++;\n\t}\n\t\n\treturn (1);\n}\n\nint check_hash(int hash)\n{\n\tstruct NODE *node;\n\t\n\tnode = head;\n\t\n\twhile (node != NULL){\n\t\tif (node->hash == hash){\n//\t\t\tprintf(\"<<found>>\\n\");\n\t\t\treturn (0);\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn (1);\n}\n\nvoid free_node(void)\n{\n\tstruct NODE *node;\n\tstruct NODE *del_node;\n\t\n\tnode = head;\n\t\n\twhile (node->next != NULL){\n\t\tdel_node = node;\n\t\tnode = node->next;\n\t\tfree(del_node);\n\t}\n\thead = tail = NULL;\n}\n\t\t\n\t\t"
  },
  {
    "language": "C",
    "code": "// AOJ 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n// 2017.11.1 retry\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n\nchar chk[MAX+5];\nint q[MAX+5], *top, *end;\n\nint nxt[16] = { 0,10,5,0,10,5,0,0,5,0,10 };\n\nint main()\n{\n\tint s, r, g, b, step, N, K, mask;\n\tint i, k;\n\tchar buf[16], *bp;\n\n\twhile (fgets(buf, 15, stdin) && *buf != '0') {\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp > ' '; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = q;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top + 1 < end) {\n\t\t\ts = *top++;\n\t\t\tif (s < 0) { step++; *end++ = -1; continue; }\n\t\t\tif (s == r || s == g || s == b) goto done;\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tif ((k2 = nxt[k]) == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) chk[s2] = 1, *end++ = s2;\n\t\t\t}\n\t\t}\n\t\tputs(\"NA\"); continue;\ndone:\tprintf(\"%d\\n\", step);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\nchar chk[MAX+10];\nint Q[MAX+10], *top, *end, *qmax = Q + MAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) { chk[s2] = 1, *end = s2; if (++end >= qmax) end = Q; }\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nvoid prih(int *h,int r){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }printf(\"\\n\");\n  }//*/\nint main(){\n  char s[20];\n  int i,j,k,mi,n,r,a[12],c[60000],h[1000000]={-M};\n  while(scanf(\"%s\",s),s[0]-'0'){\n    for(i=0;i<60000;i++)c[i]=M;\n    for(i=r=1;i<1000000;i++)h[i]=M;\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    c[mi=n]=0;\n    for(i=n=0;i<l;i++)n=n*3+1;//printf(\"%d\\n\",n);\n    if(mi==0||mi==n||mi==n*2){\n      printf(\"0\\n\");\n      continue;\n      }//*/\n    //h[r=1]=c[n]*60000+n;\n    while(1){\n      h[0]=-M;\n      for(i=1;i<l;i++){//printf(\"%d\\n\",mi);\n\tf(mi,a);\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\ta[i-1]=a[i]=(6-a[i-1]-a[i])%3;\n\t//for(j=0;j<l;j++)printf(\"%d\",a[j]);printf(\"\\n\");\n\tj=g(a);//printf(\"%d\\n\",j);\n\t//if(j==0||j==n||j==n*2)break;\n\tif(c[j]>c[mi]+1){\n\t  c[j]=c[mi]+1;//printf(\"%d\\n\",c[j]);\n\t  k=c[j]*60000+j;//printf(\"k%d\\n\",k);\n\t  for(j=r++;h[j/2]>k;j/=2)h[j]=h[j/2];\n\t  h[j]=k;//printf(\"%d\\n\",j);\n\t}\n      }//printf(\"\\n\");prih(h,r);printf(\"%d\\n\",r);\n      //if(l-i)break;\n      mi=h[i=1]%60000;//printf(\"%d\\n\",mi);\n      if(mi==0||mi==n||mi==n*2)break;\n      if(r==1)break;\n      k=h[--r];\n      for(h[r]=M;k>h[i];i=j){\n\th[i]=h[j=i*2];\n\tif(h[i]>h[j+1])h[i]=h[j=j+1];\n      }//printf(\"mi%d\\n\",mi);\n      //if(r==1)break;\n      h[i/2]=k;\n    }//printf(\"%d %d\\n\",h[0],h[1]);\n    if(c[0]>c[n  ])c[0]=c[n  ];\n    if(c[0]>c[n*2])c[0]=c[n*2];\n    if(c[0]-M)printf(\"%d\\n\",c[0]);\n    else      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define M 1000000\nchar s[M][11],*p,*q;\nint r,l,i,n[M],f;\nint main()\n{\n\tfor(;gets(s[0]),s[0][0]!='0';)\n\t{\n\t\tfor(r=n[0]=0,l=1;r<l;r++)\n\t\t{\n\t\t\tfor(i=f=0,p=s[r];p[i+1];i++)\n\t\t\t\tif(p[i]!=p[i+1]&&l<M)\n\t\t\t\t{\n\t\t\t\t\tstrcpy(q=s[l],p);\n\t\t\t\t\tq[i]=q[i+1]=315-q[i]-q[i+1];\n\t\t\t\t\tn[l]=n[r]+1;\n\t\t\t\t\tf=l++;\n\t\t\t\t}\n\t\t\tif(!f&&l<M)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",n[r]);\n\t\t\t\tl=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(l!=-1)puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint l;\nint d[30][60000]={0};\nvoid f(int n,int *a){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int *a){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    for(i=0;i<25;i++){\n      for(j=0;j<60000;j++)d[i][j]=0;\n    }\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[0][n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<25;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==0)continue;\n\td[i+1][j]=zMIN(d[i+1][j],d[i][j]);\n\tfor(k=1;k<l;k++){\n\t  f(j,a);\n\t  a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n\t  d[i+1][g(a)]=zMIN(d[i+1][g(a)],d[i][j]+1);\n\t}\n      }\n    }\n    d[25][0]=zMIN(d[100][0],zMIN(d[100][n/2],d[100][n]));\n    if(d[25][0])printf(\"%d\\n\",d[100][0]-1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "S[1<<20],Q[1<<20],q;b,u,x,i,n;main(c){for(;c=~getchar();)if(c+11)b=b*4-c%6,u=u*4+1;else{for(S[q=b]=0;b%u;b=Q[b])for(x=b^b/4,i=0;x>3;i+=2,x/=4)(n=x&3)&&!Q[n=b&~(15<<i)^n*5<<i]?S[q=Q[q]=n]=S[b]+1:0;b-1?b?printf(\"%d\\n\",S[b]):puts(\"NA\"):0;memset(Q,b=u=0,4<<20);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX (0xaaaaa)\n\nchar color[MAX + 1];\n\nint change_worm(char *color, int len)\n{\n    int i;\n    int change;\n    int code;\n    int j;\n    int flag;\n    \n// printf(\"====\\n\", code);\n\n    flag = 0;\n    for (i = 0; i <= MAX; i++){\n        if (color[i] == 1){\n            color[i] = 2;\n// printf(\"-> %x(%d)\\n\", i, len);\n            for (j = 0; j < len - 1; j++){\n//printf(\"[%x <> %x]\\n\", (i >> (j * 2)) & 3, (i >> (j * 2 + 2)) & 3);\n                // ツ療猟づィツ債つ、ツ色ツつェツ暗。ツつ、ツつゥツ？\n                if (((i >> (j * 2)) & 3) != ((i >> (j * 2 + 2)) & 3)){\n                    change = 3 - ((i >> (j * 2)) & 3) - ((i >> (j * 2 + 2)) & 3);\n                    code = (i & ~(0xf << (j * 2))) | (change << (j * 2)) | (change << (j * 2 + 2));\n// printf(\"%x\", code);\n                    if (color[code] == 0){\n// printf(\"  <== NEW\");\n                        color[code] = -1;\n                        flag = 1;\n                    }\n// printf(\"\\n\", code);\n                }\n            }\n        }\n    }\n    for (i = 0; i <= MAX; i++){\n        if (color[i] == -1){\n            color[i] = 1;\n        }\n    }\n    return (flag);\n}\n\nint color_code(char *worm)\n{\n\tint code;\n\tint i;\n\t\n\tcode = 0;\n\ti = 0;\n\twhile (worm[i] != '\\0'){\n\t\tcode <<= 2;\n\t\tswitch (worm[i]){\n\t\t  case 'r':\n\t\t    break;\n\t\t\t\n\t\t  case 'g':\n\t\t    code += 1;\n\t\t\tbreak;\n\t\t\t\n\t\t  case 'b':\n\t\t\tcode += 2;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (code);\n}\n\n\nint main(void)\n{\n    char worm[11];\n    int worm_len;\n\tint time;\n    int all_red, all_green, all_blue;\n    int i;\n    int change_flg;\n    \n\twhile (1){\n\t\tscanf(\"%s\", worm);\n\t\t\n\t\tif (worm[0] == '0'){\n\t\t\tbreak;\n\t\t}\n        \n        memset(color, 0, sizeof(color));\n        color[color_code(worm)] = 1;\n        worm_len = strlen(worm);\n\n        all_red = all_green = all_blue = 0;\n        for (i = 0; i < worm_len; i++){\n            all_green = (all_green << 2) + 1;\n            all_blue = (all_blue << 2) + 2;\n        }\n\n// printf(\"<%x %x %x>\\n\", all_red, all_green, all_blue);\n\n        time = 0;\n        while (1){\n            if (color[all_red] + color[all_green] + color[all_blue] != 0){\n                printf(\"%d\\n\", time);\n                break;\n            }\n            time++;\n    \t\tchange_flg = change_worm(color, worm_len);\n            if (change_flg == 0){\n\t\t\t    printf(\"NA\\n\");\n                break;\n    \t\t}\n \t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], *top, *end, *qmax = Q + QMAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b, step;\n\tint i, k;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) | k;\n\t\t}\n\t\tmask = (1 << N) - 1, r = 0, g = 0x55555 & mask, b = 0xaaaaa & mask;\n\t\ttop = end = Q, qmax = Q+QMAX;\n\t\t*end++ = s, *end++ = -1, chk[s] = 1, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = *top; if (++top >= qmax) top = Q;\n\t\t\tif (s < 0) { step++, *end = -1; if (++end >= qmax) end = Q; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); goto Done; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2, k2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n//\t\t\t\ts2 &= mask;\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\t*end = s2; if (++end >= qmax) end = Q;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t\tDone:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define M 3000000\nchar s[M][11],*p,*q;\nint r,l,i,n[M],f;\nint main()\n{\n\tfor(;gets(s[0]),s[0][0]!='0';)\n\t{\n\t\tfor(r=n[0]=0,l=1;r<l;r++)\n\t\t{\n\t\t\tfor(i=f=0,p=s[r];p[i+1];i++)\n\t\t\t\tif(p[i]!=p[i+1]&&l<M)\n\t\t\t\t{\n\t\t\t\t\tstrcpy(q=s[l],p);\n\t\t\t\t\tq[i]=q[i+1]=315-q[i]-q[i+1];\n\t\t\t\t\tn[l]=n[r]+1;\n\t\t\t\t\tf=l++;\n\t\t\t\t}\n\t\t\tif(!f&&l<M)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",n[r]);\n\t\t\t\tl=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(l!=-1)puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX 5000000\nchar chk[MAX+10];\nint Q[QMAX+10], top, end, qmax = QMAX;\nint N, K, mask;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b;\n\tint step;\n\tint i, k, k2;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) + k;\n\t\t}\n\t\tmask = (1 << N) - 1;\n\t\tr = 0, g = 0x55555 & mask, b = 0xaaaa & mask;\n\t\tQ[0] = s, Q[1] = -1, chk[s] = 1, top = 0, end = 2, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = Q[top]; if (++top >= qmax) top = 0;\n\t\t\tif (s < 0) { step++, Q[end] = -1; if (++end == qmax) end = 0; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\ts2 &= mask;\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\tQ[end] = s2; if (++end >= qmax) end = 0;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint worm2id(const char *worm) {\n\tint id=0;\n\tint m=1;\n\twhile(*worm!='\\0') {\n\t\tswitch(*worm) {\n\t\t\tcase 'r': id+=m*1;break;\n\t\t\tcase 'g': id+=m*2;break;\n\t\t\tcase 'b': id+=m*3;break;\n\t\t}\n\t\tm*=4;\n\t\tworm++;\n\t}\n\treturn id;\n}\n\nvoid id2worm(char *worm,int id) {\n\twhile(id>0) {\n\t\tif(id%4>0)*(worm++)=\"rgb\"[id%4-1];\n\t\tid/=4;\n\t}\n\t*worm='\\0';\n}\n\nchar get_next(char c1,char c2) {\n\tswitch(c1) {\n\t\tcase 'r':\n\t\t\tswitch(c2) {\n\t\t\t\tcase 'r': return 'r';\n\t\t\t\tcase 'g': return 'b';\n\t\t\t\tcase 'b': return 'g';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tswitch(c2) {\n\t\t\t\tcase 'r': return 'b';\n\t\t\t\tcase 'g': return 'g';\n\t\t\t\tcase 'b': return 'r';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tswitch(c2) {\n\t\t\t\tcase 'r': return 'g';\n\t\t\t\tcase 'g': return 'r';\n\t\t\t\tcase 'b': return 'b';\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn c1;\n}\n\nint is_zenbu_onazi(const char *worm) {\n\tint i;\n\tfor(i=0;worm[i]!='\\0';i++) {\n\t\tif(worm[0]!=worm[i])return 0;\n\t}\n\treturn 1;\n}\n\nint search(const char *input) {\n\tstatic int queue_cost[1048576];\n\tstatic int queue_id[1048576];\n\tstatic char visited[1048576];\n\tint queue_begin,queue_end;\n\tmemset(visited,0,sizeof(visited));\n\tqueue_cost[0]=0;\n\tqueue_id[0]=worm2id(input);\n\tvisited[queue_id[0]]=1;\n\tqueue_begin=0;\n\tqueue_end=1;\n\twhile(queue_begin<queue_end) {\n\t\tint cur_cost=queue_cost[queue_begin];\n\t\tint cur_id=queue_id[queue_begin];\n\t\tchar cur_worm[32];\n\t\tchar bak1,bak2;\n\t\tchar *p;\n\t\tqueue_begin++;\n\t\tid2worm(cur_worm,cur_id);\n\t\tif(is_zenbu_onazi(cur_worm))return cur_cost;\n\t\tfor(p=cur_worm;*(p+1)!='\\0';p++) {\n\t\t\tif(*p!=*(p+1)) {\n\t\t\t\tint next_id;\n\t\t\t\tbak1=*p;\n\t\t\t\tbak2=*(p+1);\n\t\t\t\t*p=*(p+1)=get_next(*p,*(p+1));\n\t\t\t\tnext_id=worm2id(cur_worm);\n\t\t\t\t*p=bak1;\n\t\t\t\t*(p+1)=bak2;\n\t\t\t\tif(!visited[next_id]) {\n\t\t\t\t\tvisited[next_id]=1;\n\t\t\t\t\tqueue_cost[queue_end]=cur_cost+1;\n\t\t\t\t\tqueue_id[queue_end]=next_id;\n\t\t\t\t\tqueue_end++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void) {\n\tchar input[32];\n\twhile(scanf(\"%s\",input)==1 && input[0]!='0') {\n\t\tint ret=search(input);\n\t\tif(ret<0)puts(\"NA\"); else printf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0179: Mysterious Worm\n// 2017.8.22 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 0xaaaaa\n#define QMAX (4*MAX)\nchar chk[MAX+10];\nint Q[QMAX+10], top, end, qmax = QMAX;\nint N, K;\n\nint nxt[16] = { 0, 10, 5, 0, 10, 5, 0, 0, 5, 0, 10 };\n\nint main()\n{\n\tint s, r, g, b;\n\tint step;\n\tint i, k, k2;\n\tchar buf[15], *bp;\n\n\twhile (1) {\n\t\tscanf(\"%s\", buf); if (buf[0] == '0') break;\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor (N = s = 0, bp = buf; *bp; bp++, N += 2) {\n\t\t\tif      (*bp == 'r') k = 0;\n\t\t\telse if (*bp == 'g') k = 1;\n\t\t\telse                 k = 2;\n\t\t\ts = (s << 2) + k;\n\t\t}\n\t\tr = 0, g = 0x55555 & ((1 << N) - 1), b = 0xaaaa & ((1 << N) - 1);\n\t\tQ[0] = s, Q[1] = -1, chk[s] = 1, top = 0, end = 2, step = 0, K = N-4;\n\t\twhile (top < end) {\n\t\t\ts = Q[top]; if (++top == qmax) top = 0;\n\t\t\tif (s < 0) { step++, Q[end++] = -1; continue; }\n\t\t\tif (s == r || s == g || s == b) { printf(\"%d\\n\", step); break; }\n\t\t\tfor (i = 0; i <= K; i += 2) {\n\t\t\t\tint s2;\n\t\t\t\tk = (s >> i) & 0xf;\n\t\t\t\tk2 = nxt[k];\n\t\t\t\tif (k2 == k) continue;\n\t\t\t\ts2 = (s & ~(0xf << i)) | (k2 << i);\n\t\t\t\tif (!chk[s2]) chk[s2] = 1;\n\t\t\t\tQ[end] = s2; if (++end == qmax) end = 0;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar s[1000000][12],c[12];\nint main(){\n  int t,r,i,j,f,a[1000000]={0};\n  while(scanf(\"%s\",s[t=0]),s[0][1]){\n    for(r=1;r-t;t++){\n      for(i=f=1;s[t][i];i++){\n\tif(s[t][i-1]==s[t][i])continue;\n\tf=0;\n\tstrcpy(c,s[t]);\n\tif(s[t][i-1]+s[t][i]=='g'+'r')c[i-1]=c[i]='b';\n\tif(s[t][i-1]+s[t][i]=='g'+'b')c[i-1]=c[i]='r';\n\tif(s[t][i-1]+s[t][i]=='b'+'r')c[i-1]=c[i]='g';\n\tfor(j=0;j<r;j++){\n\t  if(strcmp(c,s[j])==0)break;\n\t}\n\tif(j-r)continue;\n\tstrcpy(s[r],c);\n\ta[r++]=a[t]+1;\n      }\n      if(f)break;\n      if(r>100000)break;\n    }\n    if(f)printf(\"%d\\n\",a[t]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s[10000][12],c[12];\n  int t,r,i,j,f,a[10000]={0};\n  while(scanf(\"%s\",s[t=0]),s[0][1]){\n    for(r=1;r-t;t++){\n      for(i=f=1;s[t][i];i++){\n\tif(s[t][i-1]==s[t][i])continue;\n\tf=0;\n\tstrcpy(c,s[t]);\n\tif(s[t][i-1]+s[t][i]=='g'+'r')c[i-1]=c[i]='b';\n\tif(s[t][i-1]+s[t][i]=='g'+'b')c[i-1]=c[i]='r';\n\tif(s[t][i-1]+s[t][i]=='b'+'r')c[i-1]=c[i]='g';\n\tfor(j=0;j<r;j++){\n\t  if(strcmp(c,s[j])==0)break;\n\t}\n\tif(j-r)continue;\n\tstrcpy(s[r],c);\n\ta[r++]=a[t]+1;\n      }\n      if(f)break;\n      if(r>5000)break;\n    }\n    if(f)printf(\"%d\\n\",a[t]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint l;\nvoid f(int n,int a[20]){//kakunou\n  int i;\n  for(i=0;i<l;n/=3)a[i++]=n%3;\n}\nint g(int a[20]){\n  int n=0,i;\n  for(i=l;i;i--)n=n*3+a[i-1];\nreturn n;\n}\nint zMIN(int a,int b){\n  if(b==0)return a;\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int i,j,k,n,a[20];\n  char s[20];\n  while(scanf(\"%s\",s),s[1]){\n    int d[60000]={0};\n    for(l=n=0;s[l];l++){\n      if(s[l]=='r')n=n*3+0;\n      if(s[l]=='g')n=n*3+1;\n      if(s[l]=='b')n=n*3+2;\n    }\n    d[n]=1;\n    for(i=n=0;i<l;i++)n=n*3+2;//printf(\"%d\\n\",n);\n    for(i=0;i<25;i++){\n      for(j=0;j<=n;j++){\n    if(d[j]==0)continue;\n    for(k=1;k<l;k++){\n      f(j,a);\n      a[k]=a[k-1]=(6-a[k]-a[k-1])%3;\n      d[g(a)]=zMIN(d[g(a)],d[j]+1);\n    }\n      }\n    }\n    d[0]=zMIN(d[0],zMIN(d[n/2],d[n]));\n    if(d[0])printf(\"%d\\n\",d[0]-1);\n    else    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tint allnum = 100;\n    \tchar all[][];\n    \tvoid dfs(int length,int num){\n    \t\tchar c = all[num][0];\n    \t\tint cnt = 0;\n    \t\tfor(int i = 0;i < length;i++){\n    \t\t\tif(c == all[num][i])cnt++;\n//    \t\t\tSystem.out.print(all[num][i]);\n    \t\t}\n//    \t\tSystem.out.println(\" \"+num);\n    \t\tif(cnt == length){\n    \t\t\tallnum = Math.min(allnum, num);\n//    \t\t\tSystem.out.println(num+\" \"+allnum);\n    \t\t}\n    \t\tfor(int i = 0;i < length - 1;i++){\n    \t\t\tif(num < length){\n    \t    \t\tfor(int j = 0;j < length;j++){\n    \t    \t\t\tall[num+1][j] = all[num][j];\n    \t    \t\t}\n    \t\t\t\tif(all[num][i] != 'r' && all[num][i+1] != 'r' && all[num][i] != all[num][i+1]){\n    \t\t\t\t\tall[num+1][i] = 'r';all[num+1][i+1] = 'r';\n    \t\t\t\t\tdfs(length,num+1);\n    \t\t\t\t}else if(all[num][i] != 'b' && all[num][i+1] != 'b' && all[num][i] != all[num][i+1]){\n    \t\t\t\t\tall[num+1][i] = 'b';all[num+1][i+1] = 'b';\n    \t\t\t\t\tdfs(length,num+1);\n    \t\t\t\t}else if(all[num][i] != 'g' && all[num][i+1] != 'g' && all[num][i] != all[num][i+1]){\n    \t\t\t\t\tall[num+1][i] = 'g';all[num+1][i+1] = 'g';\n    \t\t\t\t\tdfs(length,num+1);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tallnum = 100;\n    \t\t\tString str = sc.next();\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tchar ctr[] = str.toCharArray();\n    \t\t\tall = new char [ctr.length+1][ctr.length];\n    \t\t\tfor(int i = 0;i < ctr.length;i++)all[0][i] = ctr[i];\n    \t\t\tdfs(ctr.length,0);\n    \t\t\tif(allnum != 100)System.out.println(allnum);\n    \t\t\telse System.out.println(\"NA\");\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tHashSet<String>HS=new HashSet<String>();\n\t\t\tint ans=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tint flag=1;\n\t\t\tque.add(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tflag=1;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tif(!HS.contains(tmp))\n\t\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t\tHS.add(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tSystem.out.println(flag==1 ? ans:\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tString check(String s){\n    \t\tif(s.equals(\"rb\") || s.equals(\"br\"))return \"gg\";\n    \t\telse if(s.equals(\"rg\") || s.equals(\"gr\"))return \"bb\";\n    \t\treturn \"rr\";\n    \t}\n    \tint ans(String str,int cnt,int length){\n    \t\tArrayList<String> ts = new ArrayList<String>();\n    \t\tts.add(str);\n    \t\twhile(cnt <= length){\n\t\t\t\tcnt++;\n\t\t\t\tint tssize = ts.size();\n\t\t\t\tfor(int i = 0;i < tssize;i++){\n\t\t\t\t\tstr = ts.remove(0);\n//\t\t\t\t\tSystem.out.println(cnt+\" \"+str);\n\t\t\t\t\tboolean out = true;\n\t\t\t\t\tfor(int j=0;j<length-1;j++){\n\t\t\t\t\t\tif(str.charAt(j)!=str.charAt(j+1))out = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(out)return cnt-1;\n\t\t\t\t\tfor(int j = 0;j < length-1;j++)if(str.charAt(j)!=str.charAt(j+1)){\n\t\t\t\t\t\tString str2 = str.substring(0,j)+check(str.substring(j,j+2))+str.substring(j+2,length);\n//\t\t\t\t\t\tSystem.out.println(cnt+\" \"+str+\" \"+str2+\" \"+ts.size());\n\t\t\t\t\t\tif(!ts.contains(str2))ts.add(str2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t\treturn -1;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tString str = sc.next();\t\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tint a = ans(str,0,str.length());\n    \t\t\tSystem.out.println(a == -1 ? \"NA\":a);\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0179();\n\t}\n\t\n\tLinkedList<N0179> open;\n\tTreeSet<String> close;\n\tString r0179, g0179, b0179;\n\tvoid AOJ0179(){\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\tr0179=\"\";\tg0179=\"\";\tb0179=\"\";\n\t\t\tfor(int i=0; i<s.length(); i++){\n\t\t\t\tr0179+=\"r\";\tg0179+=\"g\";\tb0179+=\"b\";\n\t\t\t}\n\t\t\topen=new LinkedList<N0179>();\n\t\t\tclose=new TreeSet<String>();\n\t\t\topen.add(new N0179(s,0));\n\t\t\tclose.add(s);\n\t\t\tint ans=solve0179();\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tint solve0179(){\n\t\tN0179 n=open.getFirst();\n\t\topen.removeFirst();\n\t\t//out.println(\"NOW:\"+n.s+\" \"+n.sec);\n\t\tif(r0179.equals(n.s) || g0179.equals(n.s) || b0179.equals(n.s))\treturn n.sec;\n\t\tfor(int i=0; i<n.s.length()-1; i++){\n\t\t\tchar[] c=n.s.toCharArray();\n\t\t\tif(c[i]!=c[i+1]){\n\t\t\t\tif(c[i]!='r' && c[i+1]!='r'){\n\t\t\t\t\tc[i]='r';\tc[i+1]='r';\n\t\t\t\t}else if(c[i]!='g' && c[i+1]!='g'){\n\t\t\t\t\tc[i]='g';\tc[i+1]='g';\n\t\t\t\t}else if(c[i]!='b' && c[i+1]!='b'){\n\t\t\t\t\tc[i]='b';\tc[i+1]='b';\n\t\t\t\t}\n\t\t\t\tString temp=new String(c);\n\t\t\t\tif(!close.contains(temp)){\n\t\t\t\t\t//out.println(temp);\n\t\t\t\t\topen.add(new N0179(temp, n.sec+1));\n\t\t\t\t\tclose.add(temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(!open.isEmpty())\treturn solve0179();\n\t\treturn -1;\n\t}\n\tclass N0179{\n\t\tString s;\tint sec;\n\t\tN0179(String s, int sec){\n\t\t\tthis.s=s;\tthis.sec=sec;\n\t\t}\n\t}\n\t\n\t// WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[w+2][h+2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t\tint[] vx={1,0,-1,0}, vy={0,1,0,-1};\n\t\t\tint xx=sx, yy=sy, cc=b[sx][sy], v=0, count=0, max=w*h;\n\t\t\tif(cc<1){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif(xx==gx && yy==gy && b[xx][yy]==cc){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif(count>=max){\n\t\t\t\t\tout.println(\"NG\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//b[xx][yy]=6;\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tout.println(\"X\"+xx+\" Y\"+yy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\txx-=vx[v];\tyy-=vy[v];\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\tout.println(\"END : X\"+xx+\" Y\"+yy);\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//debug\n\t\t\tde0207(b,w,h);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ1136(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tsolve1136(n);\n\t\t\tout.println(\"+++++\");\n\t\t}\n\t}\n\tvoid solve1136(int N){\t// N本の折れ線\n\t\t// 元の直線0\n\t\tint a0=sc.nextInt();\n\t\tint[] v0=new int[a0], len0=new int[a0];\n\t\tint lx=sc.nextInt(), ly=sc.nextInt();\n\t\tfor(int i=1; i<a0; i++){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tv0[i]=v1136(x,y,lx,ly);\n\t\t\tlen0[i]=max(abs(y-ly),abs(x-lx));\n\t\t\tlx=x;\tly=y;\n\t\t}\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tint a=sc.nextInt();\n\t\t\t//if(a!=a0)\tcontinue;\n\t\t\t// a!=a0で飛ばした時に読み込みがずれる\n\t\t\tint[] v=new int[a], len=new int[a];\n\t\t\tlx=sc.nextInt();\tly=sc.nextInt();\n\t\t\tfor(int j=1; j<a; j++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt();\n\t\t\t\tv[j]=v1136(x,y,lx,ly);\n\t\t\t\tlen[j]=max(abs(y-ly),abs(x-lx));\n\t\t\t\tlx=x;\tly=y;\n\t\t\t}\n\t\t\tif(a!=a0)\tcontinue;\n\t\t\tif(isSame(v0,len0,v,len))\tout.println(i);\n\t\t\telse if(isSame2(v0,len0,v,len))\tout.println(i);\n\t\t}\n\t}\n\tint v1136(int x, int y, int lx, int ly){\n\t\tif(y>ly)\treturn 1;\n\t\telse if(x>lx)\treturn 2;\n\t\telse if(y<ly)\treturn 3;\n\t\telse if(x<lx)\treturn 4;\n\t\treturn 0;\n\t}\n\tboolean isSame(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<len.length; i++){\n\t\t\tif(len0[i]!=len[i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tboolean isSame2(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tif(len0[i]!=len[v.length-i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[v.length-i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tint[] turn1136(int[] v, int n){\n\t\tif(n==0)\treturn v;\n\t\tint[] ans=new int[v.length];\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tans[i]=v[i]+n>4? 1: v[i]+n;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0141(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==1){\n\t\t\t\tout.println(\"#\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar[][] c=new char[n+1][n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=n; j++)\tc[i][j]=' ';\n\t\t\t}\n\t\t\tfor(int i=n; i>0; i--)\tc[1][i]='#';\n\t\t\tfor(int i=1; i<=n; i++)\tc[i][1]='#';\n\t\t\tif(n>2){\n\t\t\t\tfor(int i=1; i<=n; i++)\tc[n][i]='#';\n\t\t\t}\n\t\t\tif(n>3){\n\t\t\t\tfor(int i=n; i>2; i--)\tc[i][n]='#';\n\t\t\t}\n\t\t\tif(n>4){\n\t\t\t\tint[] vx={0, 1, 0, -1,1,1,-1,-1};\n\t\t\t\tint[] vy={-1, 0, 1, 0,-1,1,-1,1};\n\t\t\t\tc=solve141(3, n-1, n, c, vx, vy, 0);\n\t\t\t}\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tfor(int i=1; i<=n; i++)\tout.print(c[i][j]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tif(I!=N)\tout.println();\t// 最後のデータセットの改行\n\t\t}\n\t}\n\t// 今のx,y　n縦横　c版　vx,vy移動,　f方向\n\tchar[][] solve141(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\twhile(true){\n\t\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\tc[x][y]='#';\n\t\t\t\t//return solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tx=xx;\ty=yy;\n\t\t\t\tf= f+1<4? f+1: 0;\n\t\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\t\t//return solve141(x, y, n,c,vx,vy,f);\n\t\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\t\tbreak;\n\t\t}\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t// 再帰だとスタックオーバーフロー（手元では106まで行けたが）\n\tchar[][] solve141old(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\tboolean flag=true;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\treturn c;\n\t\t}\n\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\tc[x][y]='#';\n\t\t\treturn solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t}else{\n\t\t\tx=xx;\ty=yy;\n\t\t\tf= f+1<4? f+1: 0;\n\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\treturn solve141(x, y, n,c,vx,vy,f);\n\t\t\t}\n\t\t}\n\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t\n\tvoid AOJ0140(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt();\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tif(n>5){\n\t\t\t\tif(m<6){\n\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\tfor(int i=5; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t\t}else{\n\t\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=5; i>=0; i--)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=1; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\telse\tfor(int i=n; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t}\n\t\t\tsb.deleteCharAt(sb.length()-1);\n\t\t\tout.println(sb);\n\t\t}\n\t}\n\t\n\tvoid AOJ1135(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=sc.nextInt(), year=sc.nextInt(), n=sc.nextInt(), ans=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(sc.nextInt()==1)\tans=max(ans, huku(a,year,sc.nextDouble(),sc.nextInt()));\n\t\t\t\telse\tans=max(ans, tan(a,year,sc.nextDouble(), sc.nextInt()));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint huku(int a, int year, double rate, int t){\n\t\tfor(int i=0; i<year; i++){\n\t\t\tint temp=(int) (a*rate);\n\t\t\ta+=temp-t;\n\t\t}\n\t\treturn a;\n\t}\n\tint tan(int a, int year, double rate, int t){\n\t\tint r=0;\n\t\tfor(int i=0; i<year; i++){\n\t\t\tr+=a*rate;\n\t\t\ta-=t;\n\t\t}\n\t\treturn a+r;\n\t}\n\t\n\tvoid AOJ1142(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=1; i<s.length(); i++){\n\t\t\t\tString a=s.substring(0, i), b=s.substring(i);\n\t\t\t\tString aa=new StringBuilder(a).reverse().toString(), bb=new StringBuilder(b).reverse().toString();\n\t\t\t\t//out.println(\"A:\"+a+\" AA:\"+aa+\" B:\"+b+\" BB:\"+bb);\n\t\t\t\tmap.put(a+b,1);\n\t\t\t\tmap.put(aa+b,1);\n\t\t\t\tmap.put(a+bb,1);\n\t\t\t\tmap.put(aa+bb,1);\n\t\t\t\tmap.put(b+a,1);\n\t\t\t\tmap.put(bb+a, 1);\n\t\t\t\tmap.put(b+aa, 1);\n\t\t\t\tmap.put(bb+aa, 1);\n\t\t\t\t//out.println(map);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(map.size());\n\t\t}\n\t}\n\t\n\tvoid AOJ1137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=toInt(sc.next()),b=toInt(sc.next());\n\t\t\t//out.println(\"A:\"+a+\" B:\"+b);\n\t\t\tout.println(toMcxi(a+b));\n\t\t}\n\t}\n\tint toInt(String s){\n\t\tint ans=0,temp=1;\n\t\tchar[] c=s.toCharArray();\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tif(c[i]=='m'){\n\t\t\t\tans+=temp*1000;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='c'){\n\t\t\t\tans+=temp*100;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='x'){\n\t\t\t\tans+=temp*10;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='i'){\n\t\t\t\tans+=temp;\n\t\t\t\ttemp=1;\n\t\t\t}else{\n\t\t\t\ttemp=Character.digit(c[i],10);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tString toMcxi(int n){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tif(n/1000>0){\n\t\t\tsb.append(n/1000==1?\"m\":(n/1000)+\"m\");\n\t\t\tn%=1000;\n\t\t}\n\t\tif(n/100>0){\n\t\t\tsb.append(n/100==1?\"c\":(n/100)+\"c\");\n\t\t\tn%=100;\n\t\t}\n\t\tif(n/10>0){\n\t\t\tsb.append(n/10==1?\"x\":(n/10)+\"x\");\n\t\t\tn%=10;\n\t\t}\n\t\tif(n>0)\tsb.append(n==1?\"i\":n+\"i\");\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tlong s=sc.nextLong();\n\t\t\tout.println(\"Case \"+i+\":\");\n\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\ts*=s;\ts/=100;\ts%=10000;\n\t\t\t\tout.println(s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t    ArrayList<Integer> prime = new ArrayList<Integer>();\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for (int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            prime.add(i);\n\t            for (int j=i+i; j<=N; j+=i)    list[j] = false;\n\t        }\n\t    }\n\t    return prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for(int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            for (int j=i+i; j<=N; j+=i)     list[j] = false;\n\t        }\n\t    }\n\t    return list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t    for(int i=2; i*i<=n; i++){\n\t        if(n%i==0)     return false;\n\t    }\n\t    return true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\t\tint ans=0;\n\t\t\tint flag=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tque.add(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]==ch[j+1])\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tif(map.get(tmp)==null)\n\t\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t\tmap.put(tmp, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t\tif(ans>8)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(ans>8? \"NA\":ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\n\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tsolv();\n\t\twhile(true) {\n\t\t\tString in = sc.next();\n\t\t\tif(in.equals(\"0\")) break;\n\t\t\tif(!map.containsKey(in)) {\n\t\t\t\tout.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(map.get(in));\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tstatic HashMap<String, Integer> map = new HashMap<String, Integer>();\n\tstatic char[] X = new char[] {'r','g','b'};\n\tstatic void solv() {\n\t\tfor(int i = 2; i <= 10; i++) {\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tchar[] str = new char[i];\n\t\t\t\tArrays.fill(str, X[j]);\n\t\t\t\tqueue.add(new Data(str,0));\n\t\t\t\t\n\t\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\t\tbfs(queue.poll());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfs(Data a) {\n\t\tString tmp = String.valueOf(a.data);\n\t\tif(map.containsKey(tmp) && map.get(tmp) <= a.count) return;\n\t\tmap.put(tmp, a.count);\n\t\tchar[] k = a.data;\n\t\tfor(int i = 0; i < k.length-1; i++) {\n\t\t\tif(k[i] == k[i+1]) {\n\t\t\t\tif(k[i] == 'r') {\n\t\t\t\t\tchar[] cpy = Arrays.copyOf(k, k.length);\n\t\t\t\t\tcpy[i] = 'g';\n\t\t\t\t\tcpy[i+1] = 'b';\n\t\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t\t\tcpy = Arrays.copyOf(k, k.length);\n\t\t\t\t\tcpy[i] = 'b';\n\t\t\t\t\tcpy[i+1] = 'g';\n\t\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t\t}\n\t\t\t\tif(k[i] == 'g') {\n\t\t\t\t\tchar[] cpy = Arrays.copyOf(k, k.length);\n\t\t\t\t\tcpy[i] = 'r';\n\t\t\t\t\tcpy[i+1] = 'b';\n\t\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t\t\tcpy = Arrays.copyOf(k, k.length);\n\t\t\t\t\tcpy[i] = 'b';\n\t\t\t\t\tcpy[i+1] = 'r';\n\t\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t\t}\n\t\t\t\tif(k[i] == 'b') {\n\t\t\t\t\tchar[] cpy = Arrays.copyOf(k, k.length);\n\t\t\t\t\tcpy[i] = 'g';\n\t\t\t\t\tcpy[i+1] = 'r';\n\t\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t\t\tcpy = Arrays.copyOf(k, k.length);\n\t\t\t\t\tcpy[i] = 'r';\n\t\t\t\t\tcpy[i+1] = 'g';\n\t\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t\n\n}\n\nclass Data {\n\tchar[] data;\n\tint    count;\n\tData(char[] a, int b) {\n\t\tdata = a;\n\t\tcount = b;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tint ans=0;\n\t\t\tint flag=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tque.push(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]==ch[j+1])\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t\t//System.out.println(que.size());\n\t\t\t\tif(ans>8)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(ans>8? \"NA\":ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new  Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tchar[] s = (cin.next()).toCharArray();\n\t\t\tif(s[0]=='0'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(all(s)){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHashSet<String> map = new HashSet<String>();\n\t\t\tQueue<char[]> q = new LinkedList<char[]>();\n\t\t\tQueue<Integer> depth = new LinkedList<Integer>();\n\t\t\tq.add(s);\n\t\t\tdepth.add(0);\n\t\t\tlabel2:while(!q.isEmpty()){\n\t\t\t\tchar[] ss = q.poll();\n\t\t\t\tint dep = depth.poll();\n\t\t\t\tfor(int i = 0; i < s.length-1;i++){\n\t\t\t\t\tif(ss[i]!=ss[i+1]){\n\t\t\t\t\t\tchar[] next = change(ss,i);\n\t\t\t\t\t\tif(map.contains(String.valueOf(next))){\n\t\t\t\t\t\t\t//System.out.println(\"onaji\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(all(next)){\n\t\t\t\t\t\t\tSystem.out.println(dep+1);\n\t\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap.add(String.valueOf(next));\n\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\tdepth.add(dep+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"NA\");\n\t\t}\n\t}\n\tstatic boolean all(char[] s){\n\t\tfor(int i = 0;i<s.length-1;i++){\n\t\t\tif(s[i]!=s[i+1]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic char[] change(char[] s,int x){\n\t\tchar[] re = s.clone();\n\n\t\tif(re[x]!='r'&&re[x+1]!='r'){\n\t\t\tre[x]='r';\n\t\t\tre[x+1]='r';\n\t\t}\n\t\telse if(re[x]!='g'&&re[x+1]!='g'){\n\t\t\tre[x]='g';\n\t\t\tre[x+1]='g';\n\t\t} \n\t\telse{\n\t\t\tre[x]='b';\n\t\t\tre[x+1]='b';\n\t\t}\n\t\treturn re;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tint [] map;\n    \tint num = 100;\n    \tint color = 'r'+'b'+'g';\n    \tStack<Pair> st = new Stack<Pair>();\n    \tclass Pair{\n    \t\tint x,y;\n    \t\tpublic Pair(int x,int y) {\n    \t\t\tthis.x = x;\n    \t\t\tthis.y = y;\n    \t\t}\n    \t}\n    \tvoid dfs(int cnt,int max){\n    \t\tif(cnt <= max+1){\n//    \t\t\tfor(int i = 0;i < max+1;i++)System.out.print((char)map[i]);\n//    \t\t\tSystem.out.println(\" \"+cnt);\n    \t\t\tint c = 0;\n    \t\t\tfor(int i = 0;i < max;i++){\n    \t\t\t\tif(map[i] == map[i+1])c++;\n    \t\t\t}\n    \t\t\tif(c == max)num = Math.min(num, cnt);\n    \t\t\telse if(cnt < num){\n    \t\t\t\tfor(int i = 0;i < max;i++){\n    \t\t\t\t\tif(map[i] != map[i+1]){\n    \t\t\t\t\t\tst.push(new Pair(map[i],map[i+1]));\n    \t\t\t\t\t\tint color2 = color - (map[i] + map[i+1]);\n    \t\t\t\t\t\tmap[i] = color2;map[i+1] = color2;\n    \t\t\t\t\t\tdfs(cnt+1,max);\n    \t\t\t\t\t\tPair p = st.pop();\n    \t\t\t\t\t\tmap[i] = p.x;\n    \t\t\t\t\t\tmap[i+1] = p.y;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tnum = 100;\n    \t\t\tString str = sc.next();\t\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tchar ctr[] = str.toCharArray();\n    \t\t\tmap = new int [str.length()];\n    \t\t\tfor(int i = 0;i < str.length();i++)map[i] = (int)ctr[i];\n    \t\t\tdfs(0,str.length()-1);\n    \t\t\tif(num != 100)System.out.println(num);\n    \t\t\telse System.out.println(\"NA\");\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n\n    void solve(){\n\tScanner kbd = new Scanner(System.in);\n\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(s.equals(\"0\")) break; \n\t    \n\t    //String[] pattern = new String[60000];\n\t    HashSet<String> set = new HashSet<String>();\n\t    int pcnt = 0;\n\t    //Stack stack = new Stack(s);\n\t    Queue<Worm> que = new LinkedList<Worm>();\n\t    que.add(new Worm(s, 0));\n\t    String a = s;\n\t    set.add(s);\n\t    //pattern[pcnt++] = a;\n\t    int t = 0;\n\t    while(!que.isEmpty() && !color(a)){\n\t\t//System.out.println(a+\" \"+color(a));\n\t\tWorm w = que.poll();\n\t\ta = w.getbody();\n\t\tt = w.getTime();\n\t\tfor(int i=0; i<a.length()-1; i++){\n\t\t    if(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t\tString b = change(a, i, i+1);  \n\t\t\t/*\n\t\t\t  int j=0;\n\t\t\t  while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t\t  if(pattern[j]==null){\n\t\t\t  //System.out.println(b);\n\t\t\t  pattern[j] = b;\n\t\t\t  stack.in(b, t+1);\n\t\t\t  pcnt++;\n\t\t\t  }\n\t\t\t*/\n\t\t\tif(set.contains(b)) continue;\n\t\t\telse{\n\t\t\t    que.add(new Worm(b, t+1));\n\t\t\t    set.add(b);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if(color(a))\n\t\tSystem.out.println(t);\n\t    else\n\t\tSystem.out.println(\"NA\");\n\t}\n    }\n\n    boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    String change(String x, int s, int e){\n\tString ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tans += a+a;\n\t    }\n\t    else{\n\t\tans += x.substring(i, i+1);\n\t    }\n\t}\n\treturn ans;\n    }\n\t\n    String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\n/*\nclass Stack {\n    Worm[] stack = new Worm[60000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tout = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Worm pop(){\n\treturn stack[out++];\n    }\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n*/\n\n class Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private void run() {\n        while (true) {\n            String S = read();\n            if (S.equals(\"0\")) break;\n            if (sameAll(S)) {\n                sysout.println(0);\n                continue;\n            }\n            Queue<State> que = new ArrayDeque<State>();\n            HashSet<String> hist = new HashSet<String>();\n            que.add(new State(S, 0));\n            hist.add(S);\n            int ans = -1;\n            while (!que.isEmpty()) {\n                State state = que.poll();\n//                sysout.println(state.cost + \" \" + state.str);\n                char[] t = state.str.toCharArray();\n                for (int i = 0; i < t.length - 1; i++) {\n                    if (t[i] == t[i + 1]) continue;\n                    char[] tmp = {t[i], t[i + 1]};\n\n                    char n = next(tmp);\n                    t[i] = n; t[i+1] = n;\n\n                    String ts = new String(t);\n                    if (!hist.contains(ts)) {\n                        que.add(new State(ts, state.cost + 1));\n                        hist.add(ts);\n                        if (sameAll(ts) && ans == -1) ans = state.cost + 1;\n                    }\n\n                    t[i] = tmp[0];\n                    t[i + 1] = tmp[1];\n                }\n            }\n            if (ans == -1) sysout.println(\"NA\");\n            else sysout.println(ans);\n        }\n    }\n\n    boolean sameAll(String str) {\n        char c = str.charAt(0);\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) != c) return false;\n        }\n        return true;\n    }\n\n    char next(char[] now) {\n        if (now[0] == 'r' && now[1] == 'g') return 'b';\n        if (now[0] == 'r' && now[1] == 'b') return 'g';\n        if (now[0] == 'g' && now[1] == 'r') return 'b';\n        if (now[0] == 'g' && now[1] == 'b') return 'r';\n        if (now[0] == 'b' && now[1] == 'r') return 'g';\n        if (now[0] == 'b' && now[1] == 'g') return 'r';\n        return '_';\n    }\n\n    class State implements Comparable<State> {\n        public String str;\n        public int cost;\n\n        public State(String str, int cost) {\n            this.str = str;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(State o) {\n            return Integer.compare(cost, o.cost);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    // flush automatically iff you call `println` or `printf` or `format`.\n    PrintWriter sysout = new PrintWriter(System.out, true);\n\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer buffer = null;\n\n    String readLine() {\n        buffer = null;\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    String read() {\n        if (buffer == null || !buffer.hasMoreTokens()) {\n            buffer = new StringTokenizer(readLine());\n        }\n        return buffer.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(read());\n    }\n\n    long readLong() {\n        return Long.parseLong(read());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(read());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main{\n\n\tpublic static void main(String args[]){\n\t\tnew Main().mainrun();\n\t}\n\n\tprivate Scanner scan;\n\n\tprivate void mainrun() {\n\t\tscan = new Scanner(System.in);\n\n\t\tfor(String s = scan.nextLine();!s.equals(\"0\");s = scan.nextLine()){\n\t\t\tlooprun(s);\n\t\t}\n\t}\n\n\tprivate void looprun(String s) {\n\n\t\tint Ans = 0;\n\n\t\tSet<String> history = new HashSet<String>();\n\t\thistory.add(s);\n\n\t\tSet<String> step = new HashSet<String>();\n\t\tstep.add(s);\n\n\t\twhile(!step.isEmpty()) {\n\t\t\tSet<String> nstep = new HashSet<String>();\n\n\t\t\tfor(String str : step) {\n\t\t\t\tString[] warm = str.split(\"\");\n\n\t\t\t\tif(CheckColor(warm)) {\n\t\t\t\t\tSystem.out.println(Ans);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0;i < warm.length -1;i++) {\n\t\t\t\t\tif(!warm[i].equals(warm[i+1])) {\n\t\t\t\t\t\tString color = ChangeColor(warm[i],warm[i+1]);\n\t\t\t\t\t\tString[] cwarm = str.split(\"\");\n\t\t\t\t\t\tcwarm[i] = cwarm[i+1] = color;\n\n\t\t\t\t\t\tString Cwarm = String.join(\"\", cwarm);\n\n\t\t\t\t\t\tif(!history.contains(Cwarm)) {\n\t\t\t\t\t\t\thistory.add(Cwarm);\n\t\t\t\t\t\t\tnstep.add(Cwarm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tAns++;\n\t\t\tstep = nstep;\n\t\t}\n\n\t\tSystem.out.println(\"NA\");\n\t}\n\n\tprivate String ChangeColor(String color1,String color2) {\n\t\tif(!color1.equals(\"r\") && !color2.equals(\"r\")) {\n\t\t\treturn \"r\";\n\t\t}else if(!color1.equals(\"g\") && !color2.equals(\"g\")) {\n\t\t\treturn \"g\";\n\t\t}else {\n\t\t\treturn \"b\";\n\t\t}\n\t}\n\n\tSet<String> check = new HashSet<String>();\n\n\tprivate boolean CheckColor(String[] str) {\n\t\tcheck.clear();\n\t\tfor(String S : str) { check.add(S); }\n\t\treturn check.size() == 1;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\t\tint ans=0;\n\t\t\tint flag=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tque.add(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]==ch[j+1])\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tif(map.get(tmp)==null)\n\t\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t\tmap.put(tmp, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t\tif(ans>100)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(ans>100? \"NA\":ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.compareTo(\"0\")==0) break;\n\t\t\t\n\t\t\tint n = s.length();\n\t\t\tchar[] a = s.toCharArray();\n\t\t\tArrayDeque<char[]> que = new ArrayDeque<char[]>();\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tboolean flag = false;\n\t\t\tboolean check = false;\n\t\t\tString t;\n\t\t\t\n\t\t\tfor(int k=1;k<n;k++){\n\t\t\t\tif(a[k]!=a[0]){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else{\n\t\t\t\tque.offer(a);\n\t\t\t\tlist.add(s);\n\t\t\t\tfor(int z=1;;z++){\n\t\t\t\t\tint y = que.size();\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\t\t\tchar[] b = que.peek();\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j=0;j<n-1;j++){\n\t\t\t\t\t\t\tchar[] c = b.clone();\n\t\t\t\t\t\t\tif(b[j]=='r' && b[j+1]=='g'){\n\t\t\t\t\t\t\t\tc[j] = 'b';\n\t\t\t\t\t\t\t\tc[j+1] = 'b';\n\t\t\t\t\t\t\t}else if(b[j]=='g' && b[j+1]=='r'){\n\t\t\t\t\t\t\t\tc[j] = 'b';\n\t\t\t\t\t\t\t\tc[j+1] = 'b';\n\t\t\t\t\t\t\t}else if(b[j]=='g' && b[j+1]=='b'){\n\t\t\t\t\t\t\t\tc[j] = 'r';\n\t\t\t\t\t\t\t\tc[j+1] = 'r';\n\t\t\t\t\t\t\t}else if(b[j]=='b' && b[j+1]=='g'){\n\t\t\t\t\t\t\t\tc[j] = 'r';\n\t\t\t\t\t\t\t\tc[j+1] = 'r';\n\t\t\t\t\t\t\t}else if(b[j]=='b' && b[j+1]=='r'){\n\t\t\t\t\t\t\t\tc[j] = 'g';\n\t\t\t\t\t\t\t\tc[j+1] = 'g';\n\t\t\t\t\t\t\t}else if(b[j]=='r' && b[j+1]=='b'){\n\t\t\t\t\t\t\t\tc[j] = 'g';\n\t\t\t\t\t\t\t\tc[j+1] = 'g';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\t\t\t\tfor(int k=0;k<n;k++) sb.append(c[k]);\n\t\t\t\t\t\t\tt = sb.toString();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int k=1;k<n;k++){\n\t\t\t\t\t\t\t\tif(c[k]!=c[0]){\n\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(flag==false){\n\t\t\t\t\t\t\t\tSystem.out.println(z);\n\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\tj = n;\n\t\t\t\t\t\t\t\ti = y;\n\t\t\t\t\t\t\t}else if(list.contains(t)==false){\n\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\tlist.add(t);\n\t\t\t\t\t\t\t\tque.offer(c);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(check==false){\n\t\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t\t\ti = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.poll();\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false || check==false) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass History {\n    private int wormHash;\n    private History prev;\n\n    public History(int wormHash, History prev) {\n        this.wormHash = wormHash;\n        this.prev = prev;\n    }\n\n    public int getStep() {\n        int count = 0;\n\n        History h = this;\n        while (h != null) {\n            count++;\n            h = h.prev;\n        }\n\n        return count;\n    }\n\n    public List<Integer> getStepList() {\n        List<Integer> stepList = new ArrayList<Integer>();\n        History h = this;\n\n        while (h != null) {\n            stepList.add(h.wormHash);\n            h = h.prev;\n        }\n\n        Collections.reverse(stepList);\n\n        return stepList;\n    }\n\n    public int getWormHash() {\n        return wormHash;\n    }\n}\n\npublic class MysteriousWormSolver {\n    private static final int R = 1;\n    private static final int G = 2;\n    private static final int B = 4;\n\n    private static final int ALL_COLOR = R | G | B;\n\n    private static Map<String, Integer> STR_TO_RGB = new HashMap<String, Integer>();\n    private static Map<Integer, String> RGB_TO_STR = new HashMap<Integer, String>();\n\n    static {\n        STR_TO_RGB.put(\"r\", R);\n        STR_TO_RGB.put(\"g\", G);\n        STR_TO_RGB.put(\"b\", B);\n\n        for (Map.Entry<String, Integer> e: STR_TO_RGB.entrySet()) {\n            RGB_TO_STR.put(e.getValue(), e.getKey());\n        }\n    }\n\n    private List<Integer> genWormFromString(String wormStr) {\n        List<Integer> worm = new ArrayList<Integer>();\n        for (char c: wormStr.toCharArray()) {\n            worm.add(STR_TO_RGB.get(c + \"\"));\n        }\n        return worm;\n    }\n\n    private int calcWormHash(List<Integer> worm) {\n        int hash = 0;\n\n        for (int w: worm) {\n            hash = (hash << 3) | w;\n        }\n\n        return hash;\n    }\n\n    private List<Integer> wormHashToWorm(int wormHash) {\n        List<Integer> worm = new ArrayList<Integer>();\n\n        while (wormHash > 0) {\n            worm.add(wormHash & ALL_COLOR);\n            wormHash = wormHash >> 3;\n        }\n\n        Collections.reverse(worm);\n\n        return worm;\n    }\n\n    private String dumpWrom(List<Integer> worm) {\n        StringBuilder sb = new StringBuilder();\n\n        for (int w: worm) {\n            sb.append(RGB_TO_STR.get(w));\n        }\n\n        return sb.toString();\n    }\n\n    private boolean isGoal(List<Integer> worm) {\n        int state = 0;\n\n        for (int w: worm) {\n            state |= w;\n        }\n\n        if (state == R || state == G || state == B) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private History solveHelper(String wormStr) {\n        int initialWormHash = calcWormHash(genWormFromString(wormStr));\n\n        Set<Integer> visited = new HashSet<Integer>();\n        visited.add(initialWormHash);\n\n        Queue<History> queue = new LinkedList<History>();\n        queue.add(new History(initialWormHash, null));\n\n        while (!queue.isEmpty()) {\n            History h = queue.poll();\n\n            List<Integer> worm = wormHashToWorm(h.getWormHash());\n            if (isGoal(worm)) {\n                return h;\n            } else {\n                for (int i = 0, j = 1; i < worm.size() - 1; i++, j++) {\n                    int iColor = worm.get(i);\n                    int jColor = worm.get(j);\n                    if (iColor != jColor) {\n                        int newColor = ALL_COLOR ^ (iColor | jColor);\n                        worm.set(i, newColor);\n                        worm.set(j, newColor);\n\n                        int wormHash = calcWormHash(worm);\n                        if (!visited.contains(wormHash)) {\n                            visited.add(wormHash);\n                            queue.add(new History(wormHash, h));\n                        }\n\n                        worm.set(i, iColor);\n                        worm.set(j, jColor);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private void printAnswer(List<Integer> stepList) {\n        for (int wormHash: stepList) {\n            List<Integer> worm = wormHashToWorm(wormHash);\n            System.out.println(dumpWrom(worm));\n        }\n    }\n\n    public void solve(String wormStr) {\n        History h = solveHelper(wormStr);\n\n        if (h == null) {\n            System.out.println(\"NA\");\n        } else {\n            int count = h.getStep() - 1;\n            //printAnswer(h.getStepList());\n            System.out.println(count);\n        }\n    }\n\n    public static void main(String[] args) {\n        MysteriousWormSolver solver = new MysteriousWormSolver();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String wormStr = scanner.nextLine();\n            if (!wormStr.equals(\"0\")) {\n                solver.solve(wormStr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tString worm;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tworm=sc.next();\n\t\t\tif(worm.equals(\"0\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tLinkedList<String> que=new LinkedList<String>();\n\t\tTreeSet<String> set=new TreeSet<String>();\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tque.add(worm);\n\t\tset.add(worm);\n\t\tmap.put(worm, 0);\n\t\tfor(; !que.isEmpty();){\n\t\t\tString s=que.poll();\n\t\t\tboolean f=true;\n\t\t\tfor(int i=0; i<s.length(); i++){\n\t\t\t\tf&=s.charAt(0)==s.charAt(i);\n\t\t\t}\n\t\t\t// debug(s,map.get(s));\n\t\t\tif(f){\n\t\t\t\tprintln(\"\"+map.get(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(String t : next(s)){\n\t\t\t\tif(!set.contains(t)){\n\t\t\t\t\tque.offer(t);\n\t\t\t\t\tset.add(t);\n\t\t\t\t\tmap.put(t, map.get(s)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"NA\");\n\t}\n\n\tLinkedList<String> next(String s){\n\t\tLinkedList<String> list=new LinkedList<String>();\n\t\tfor(int i=0; i<s.length()-1; i++){\n\t\t\tif(s.charAt(i)!=s.charAt(i+1)){\n\t\t\t\tchar c='*';\n\t\t\t\tswitch(s.charAt(i)+s.charAt(i+1)){\n\t\t\t\tcase 'r'+'g':\n\t\t\t\t\tc='b';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g'+'b':\n\t\t\t\t\tc='r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b'+'r':\n\t\t\t\t\tc='g';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlist.add(s.substring(0, i)+c+c\n\t\t\t\t\t\t+(i<s.length()-2?s.substring(i+2, s.length()):\"\"));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic String worm;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic boolean read() {\n\t\tworm = sc.next();\n\t\treturn (worm.equals(\"0\")) ? false : true;\n\t}\n\t\n\tstatic String solve() {\n\t\treturn bfs(worm);\n\t}\n\t\n\tstatic String bfs(String w) {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tQueue<State> que = new LinkedList<State>();\n\t\t\n\t\tque.add(new State(w, 0));\n\t\tset.add(w);\n\t\tState s;\n\t\twhile(!que.isEmpty()) {\n\t\t\ts = que.poll();\n\t\t\tif(same(s.worm)) return new Integer(s.level).toString();\n\t\t\tfor(int i = 0; i < s.worm.length() - 1; i++) {\n\t\t\t\tw = changeColor(s.worm, i);\n\t\t\t\tif(w == null) continue;\n\t\t\t\tif(!set.contains(w)) {\n\t\t\t\t\tset.add(w);\n\t\t\t\t\tque.add(new State(w, s.level + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\t\n\tstatic boolean same(String w) {\n\t\tboolean ans = true;\n\t\tchar c = w.charAt(0);\n\t\tfor(int i = 1; i < w.length(); i++) {\n\t\t\tif(c != w.charAt(i)) {\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic String changeColor(String w, int index) {\n\t\tString c = getColor(w.substring(index, index+1), w.substring(index+1, index+1+1));\n\t\tif(c == null) return null;\n\t\t\n\t\tif(index == 0) {\n\t\t\treturn c + c + w.substring(2);\n\t\t} else if(index == w.length() - 1) {\n\t\t\treturn w.substring(0, w.length() - 2) + c + c; \n\t\t} else {\n\t\t\treturn w.substring(0, 0 + index) + c + c + w.substring(index + 2, w.length());\n\t\t}\n\t}\n\t\n\tstatic String getColor(String c1, String c2) {\n\t\tif(c1.equals(\"r\")) {\n\t\t\tif(c2.equals(\"g\")) {\n\t\t\t\treturn \"b\";\n\t\t\t} else if(c2.equals(\"b\")) {\n\t\t\t\treturn \"g\";\n\t\t\t}\n\t\t} else if(c1.equals(\"g\")) {\n\t\t\tif(c2.equals(\"r\")) {\n\t\t\t\treturn \"b\";\n\t\t\t} else if(c2.equals(\"b\")) {\n\t\t\t\treturn \"r\";\n\t\t\t}\n\t\t} else if(c1.equals(\"b\")) {\n\t\t\tif(c2.equals(\"r\")) {\n\t\t\t\treturn \"g\";\n\t\t\t} else if(c2.equals(\"g\")) {\n\t\t\t\treturn \"r\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\n\t}\n\n}\n\nclass State {\n\tint level;\n\tString worm;\n\t\n\tState(String worm, int level) {\n\t\tthis.worm = worm; this.level = level;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tHashSet<String>HS=new HashSet<String>();\n\t\t\tint ans=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tint flag=1;\n\t\t\tque.add(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tflag=1;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tif(!HS.contains(tmp))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t\t\tHS.add(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tSystem.out.println(flag==1 ? ans:\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tString check(String s){\n    \t\tif(s.equals(\"rb\") || s.equals(\"br\"))return \"gg\";\n    \t\telse if(s.equals(\"rg\") || s.equals(\"gr\"))return \"bb\";\n    \t\treturn \"rr\";\n    \t}\n    \tint ans(String str,int length){\n    \t\tTreeSet<String> ts = new TreeSet<String>();\n    \t\tArrayList<String> array = new ArrayList<String>();\n    \t\tArrayList<Integer> array2 = new ArrayList<Integer>();\n    \t\tts.add(str);array.add(str);array2.add(0);\n    \t\tint num = 0;\n    \t\twhile(array.size() > 0){\n    \t\t\tboolean out = true;\n    \t\t\tstr = array.remove(0);\n    \t\t\tnum = array2.remove(0);\n//    \t\t\tSystem.out.println(str+\" \"+num);\n\t\t\t\tfor(int j=0;j<length-1;j++)if(str.charAt(j)!=str.charAt(j+1))out = false;\n\t\t\t\tif(out)return num;\n\t\t\t\tfor(int j = 0;j < length-1;j++)if(str.charAt(j)!=str.charAt(j+1)){\n\t\t\t\t\tString str2 = str.substring(0,j)+check(str.substring(j,j+2))+str.substring(j+2,length);\n//\t\t\t\t\tSystem.out.println(cnt+\" \"+str+\" \"+str2+\" \"+ts.size());\n\t\t\t\t\tif(ts.add(str2)){\n\t\t\t\t\t\tarray.add(str2);\n\t\t\t\t\t\tarray2.add(num+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t\treturn -1;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tString str = sc.next();\t\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tint a = ans(str,str.length());\n    \t\t\tSystem.out.println(a == -1 ? \"NA\":a);\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tint [] map;\n    \tint num = 100;\n    \tint color = 'r'+'b'+'g';\n    \tStack<Pair> st = new Stack<Pair>();\n    \tclass Pair{\n    \t\tint x,y;\n    \t\tpublic Pair(int x,int y) {\n    \t\t\tthis.x = x;\n    \t\t\tthis.y = y;\n    \t\t}\n    \t}\n    \tvoid dfs(int cnt,int max){\n    \t\tif(cnt <= max+1){\n//    \t\t\tfor(int i = 0;i < max+1;i++)System.out.print((char)map[i]);\n//    \t\t\tSystem.out.println(\" \"+cnt);\n    \t\t\tif(cnt < num){\n    \t\t\t\tint c = 0;\n    \t\t\t\tfor(int i = 0;i < max;i++){\n    \t\t\t\t\tif(map[i] != map[i+1]){\n    \t\t\t\t\t\tc++;\n    \t\t\t\t\t\tst.push(new Pair(map[i],map[i+1]));\n    \t\t\t\t\t\tint color2 = color - (map[i] + map[i+1]);\n    \t\t\t\t\t\tmap[i] = color2;map[i+1] = color2;\n    \t\t\t\t\t\tdfs(cnt+1,max);\n    \t\t\t\t\t\tPair p = st.pop();\n    \t\t\t\t\t\tmap[i] = p.x;\n    \t\t\t\t\t\tmap[i+1] = p.y;\n    \t\t\t\t\t}\n    \t\t\t\t\tif(i == max - 1 && c == 0)num = Math.min(num, cnt);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tnum = 100;\n    \t\t\tString str = sc.next();\t\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tchar ctr[] = str.toCharArray();\n    \t\t\tmap = new int [str.length()];\n    \t\t\tfor(int i = 0;i < str.length();i++)map[i] = (int)ctr[i];\n    \t\t\tdfs(0,str.length()-1);\n    \t\t\tif(num != 100)System.out.println(num);\n    \t\t\telse System.out.println(\"NA\");\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString init = sc.next();\n\t\t\tif (init.equals(\"0\"))\n\t\t\t\tbreak;\n\t\t\tQueue<String> q = new LinkedList<String>();\n\t\t\tMap<String, Integer> nodes = new HashMap<String, Integer>();\n\t\t\tSet<String> visited = new HashSet<String>();\n\t\t\tnodes.put(init, 0);\n\t\t\tq.add(init);\n\t\t\tString anss[] = { init.replaceAll(\".\", \"r\"),\n\t\t\t\t\tinit.replaceAll(\".\", \"g\"), init.replaceAll(\".\", \"b\") };\n\t\t\tString ans = \"\";\n\t\t\tboolean flag = false;\n\t\t\twhile (q.peek() != null) {\n\t\t\t\tString bug = q.poll();\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tif (bug.equals(anss[i])) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = anss[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t\tbreak;\n\t\t\t\tif (visited.contains(bug))\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited.add(bug);\n\n\t\t\t\tfor (int i = 0; i < bug.length() - 1; i++) {\n\t\t\t\t\tchar a = bug.charAt(i);\n\t\t\t\t\tchar b = bug.charAt(i + 1);\n\t\t\t\t\tif (a != b) {\n\t\t\t\t\t\tchar[] cs = bug.toCharArray();\n\t\t\t\t\t\tif (a != 'r' && b != 'r') {\n\t\t\t\t\t\t\tcs[i] = cs[i + 1] = 'r';\n\t\t\t\t\t\t} else if (a != 'g' && b != 'g') {\n\t\t\t\t\t\t\tcs[i] = cs[i + 1] = 'g';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcs[i] = cs[i + 1] = 'b';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString nbug = (new StringBuilder()).append(cs)\n\t\t\t\t\t\t\t\t.toString();\n\t\t\t\t\t\tq.add(nbug);\n\t\t\t\t\t\tnodes.put(nbug, nodes.get(bug) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(flag ? nodes.get(ans) : \"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0179();\n\t}\n\t\n\tLinkedList<N0179> open;\n\tTreeSet<String> close;\n\tString r0179, g0179, b0179;\n\tvoid AOJ0179(){\n\t\twhile(sc.hasNext()){\n\t\t\tString s=sc.next();\n\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\tr0179=\"\";\tg0179=\"\";\tb0179=\"\";\n\t\t\tfor(int i=0; i<s.length(); i++){\n\t\t\t\tr0179+=\"r\";\tg0179+=\"g\";\tb0179+=\"b\";\n\t\t\t}\n\t\t\topen=new LinkedList<N0179>();\n\t\t\tclose=new TreeSet<String>();\n\t\t\topen.add(new N0179(s,0));\n\t\t\tclose.add(s);\n\t\t\tint ans=solve0179();\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tint solve0179(){\n\t\twhile(!open.isEmpty()){\n\t\t\tN0179 n=open.getFirst();\n\t\t\topen.removeFirst();\n\t\t\t//out.println(\"NOW:\"+n.s+\" \"+n.sec);\n\t\t\tif(r0179.equals(n.s) || g0179.equals(n.s) || b0179.equals(n.s))\treturn n.sec;\n\t\t\tfor(int i=0; i<n.s.length()-1; i++){\n\t\t\t\tchar[] c=n.s.toCharArray();\n\t\t\t\tif(c[i]!=c[i+1]){\n\t\t\t\t\tif(c[i]!='r' && c[i+1]!='r'){\n\t\t\t\t\t\tc[i]='r';\tc[i+1]='r';\n\t\t\t\t\t}else if(c[i]!='g' && c[i+1]!='g'){\n\t\t\t\t\t\tc[i]='g';\tc[i+1]='g';\n\t\t\t\t\t}else if(c[i]!='b' && c[i+1]!='b'){\n\t\t\t\t\t\tc[i]='b';\tc[i+1]='b';\n\t\t\t\t\t}\n\t\t\t\t\tString temp=new String(c);\n\t\t\t\t\tif(!close.contains(temp)){\n\t\t\t\t\t\t//out.println(temp);\n\t\t\t\t\t\topen.add(new N0179(temp, n.sec+1));\n\t\t\t\t\t\tclose.add(temp);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if(!open.isEmpty())\treturn solve0179();\n\t\treturn -1;\n\t}\n\tint Oldsolve0179(){\n\t\tN0179 n=open.getFirst();\n\t\topen.removeFirst();\n\t\t//out.println(\"NOW:\"+n.s+\" \"+n.sec);\n\t\tif(r0179.equals(n.s) || g0179.equals(n.s) || b0179.equals(n.s))\treturn n.sec;\n\t\tfor(int i=0; i<n.s.length()-1; i++){\n\t\t\tchar[] c=n.s.toCharArray();\n\t\t\tif(c[i]!=c[i+1]){\n\t\t\t\tif(c[i]!='r' && c[i+1]!='r'){\n\t\t\t\t\tc[i]='r';\tc[i+1]='r';\n\t\t\t\t}else if(c[i]!='g' && c[i+1]!='g'){\n\t\t\t\t\tc[i]='g';\tc[i+1]='g';\n\t\t\t\t}else if(c[i]!='b' && c[i+1]!='b'){\n\t\t\t\t\tc[i]='b';\tc[i+1]='b';\n\t\t\t\t}\n\t\t\t\tString temp=new String(c);\n\t\t\t\tif(!close.contains(temp)){\n\t\t\t\t\t//out.println(temp);\n\t\t\t\t\topen.add(new N0179(temp, n.sec+1));\n\t\t\t\t\tclose.add(temp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(!open.isEmpty())\treturn solve0179();\n\t\treturn -1;\n\t}\n\tclass N0179{\n\t\tString s;\tint sec;\n\t\tN0179(String s, int sec){\n\t\t\tthis.s=s;\tthis.sec=sec;\n\t\t}\n\t}\n\t\n\t// WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[w+2][h+2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t\tint[] vx={1,0,-1,0}, vy={0,1,0,-1};\n\t\t\tint xx=sx, yy=sy, cc=b[sx][sy], v=0, count=0, max=w*h;\n\t\t\tif(cc<1){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif(xx==gx && yy==gy && b[xx][yy]==cc){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif(count>=max){\n\t\t\t\t\tout.println(\"NG\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//b[xx][yy]=6;\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tout.println(\"X\"+xx+\" Y\"+yy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\txx-=vx[v];\tyy-=vy[v];\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\tout.println(\"END : X\"+xx+\" Y\"+yy);\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//debug\n\t\t\tde0207(b,w,h);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ1136(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tsolve1136(n);\n\t\t\tout.println(\"+++++\");\n\t\t}\n\t}\n\tvoid solve1136(int N){\t// N本の折れ線\n\t\t// 元の直線0\n\t\tint a0=sc.nextInt();\n\t\tint[] v0=new int[a0], len0=new int[a0];\n\t\tint lx=sc.nextInt(), ly=sc.nextInt();\n\t\tfor(int i=1; i<a0; i++){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tv0[i]=v1136(x,y,lx,ly);\n\t\t\tlen0[i]=max(abs(y-ly),abs(x-lx));\n\t\t\tlx=x;\tly=y;\n\t\t}\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tint a=sc.nextInt();\n\t\t\t//if(a!=a0)\tcontinue;\n\t\t\t// a!=a0で飛ばした時に読み込みがずれる\n\t\t\tint[] v=new int[a], len=new int[a];\n\t\t\tlx=sc.nextInt();\tly=sc.nextInt();\n\t\t\tfor(int j=1; j<a; j++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt();\n\t\t\t\tv[j]=v1136(x,y,lx,ly);\n\t\t\t\tlen[j]=max(abs(y-ly),abs(x-lx));\n\t\t\t\tlx=x;\tly=y;\n\t\t\t}\n\t\t\tif(a!=a0)\tcontinue;\n\t\t\tif(isSame(v0,len0,v,len))\tout.println(i);\n\t\t\telse if(isSame2(v0,len0,v,len))\tout.println(i);\n\t\t}\n\t}\n\tint v1136(int x, int y, int lx, int ly){\n\t\tif(y>ly)\treturn 1;\n\t\telse if(x>lx)\treturn 2;\n\t\telse if(y<ly)\treturn 3;\n\t\telse if(x<lx)\treturn 4;\n\t\treturn 0;\n\t}\n\tboolean isSame(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<len.length; i++){\n\t\t\tif(len0[i]!=len[i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tboolean isSame2(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tif(len0[i]!=len[v.length-i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[v.length-i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tint[] turn1136(int[] v, int n){\n\t\tif(n==0)\treturn v;\n\t\tint[] ans=new int[v.length];\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tans[i]=v[i]+n>4? 1: v[i]+n;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0141(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==1){\n\t\t\t\tout.println(\"#\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar[][] c=new char[n+1][n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=n; j++)\tc[i][j]=' ';\n\t\t\t}\n\t\t\tfor(int i=n; i>0; i--)\tc[1][i]='#';\n\t\t\tfor(int i=1; i<=n; i++)\tc[i][1]='#';\n\t\t\tif(n>2){\n\t\t\t\tfor(int i=1; i<=n; i++)\tc[n][i]='#';\n\t\t\t}\n\t\t\tif(n>3){\n\t\t\t\tfor(int i=n; i>2; i--)\tc[i][n]='#';\n\t\t\t}\n\t\t\tif(n>4){\n\t\t\t\tint[] vx={0, 1, 0, -1,1,1,-1,-1};\n\t\t\t\tint[] vy={-1, 0, 1, 0,-1,1,-1,1};\n\t\t\t\tc=solve141(3, n-1, n, c, vx, vy, 0);\n\t\t\t}\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tfor(int i=1; i<=n; i++)\tout.print(c[i][j]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tif(I!=N)\tout.println();\t// 最後のデータセットの改行\n\t\t}\n\t}\n\t// 今のx,y　n縦横　c版　vx,vy移動,　f方向\n\tchar[][] solve141(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\twhile(true){\n\t\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\tc[x][y]='#';\n\t\t\t\t//return solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tx=xx;\ty=yy;\n\t\t\t\tf= f+1<4? f+1: 0;\n\t\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\t\t//return solve141(x, y, n,c,vx,vy,f);\n\t\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\t\tbreak;\n\t\t}\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t// 再帰だとスタックオーバーフロー（手元では106まで行けたが）\n\tchar[][] solve141old(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\tboolean flag=true;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\treturn c;\n\t\t}\n\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\tc[x][y]='#';\n\t\t\treturn solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t}else{\n\t\t\tx=xx;\ty=yy;\n\t\t\tf= f+1<4? f+1: 0;\n\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\treturn solve141(x, y, n,c,vx,vy,f);\n\t\t\t}\n\t\t}\n\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t\n\tvoid AOJ0140(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt();\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tif(n>5){\n\t\t\t\tif(m<6){\n\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\tfor(int i=5; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t\t}else{\n\t\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=5; i>=0; i--)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=1; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\telse\tfor(int i=n; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t}\n\t\t\tsb.deleteCharAt(sb.length()-1);\n\t\t\tout.println(sb);\n\t\t}\n\t}\n\t\n\tvoid AOJ1135(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=sc.nextInt(), year=sc.nextInt(), n=sc.nextInt(), ans=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(sc.nextInt()==1)\tans=max(ans, huku(a,year,sc.nextDouble(),sc.nextInt()));\n\t\t\t\telse\tans=max(ans, tan(a,year,sc.nextDouble(), sc.nextInt()));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint huku(int a, int year, double rate, int t){\n\t\tfor(int i=0; i<year; i++){\n\t\t\tint temp=(int) (a*rate);\n\t\t\ta+=temp-t;\n\t\t}\n\t\treturn a;\n\t}\n\tint tan(int a, int year, double rate, int t){\n\t\tint r=0;\n\t\tfor(int i=0; i<year; i++){\n\t\t\tr+=a*rate;\n\t\t\ta-=t;\n\t\t}\n\t\treturn a+r;\n\t}\n\t\n\tvoid AOJ1142(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=1; i<s.length(); i++){\n\t\t\t\tString a=s.substring(0, i), b=s.substring(i);\n\t\t\t\tString aa=new StringBuilder(a).reverse().toString(), bb=new StringBuilder(b).reverse().toString();\n\t\t\t\t//out.println(\"A:\"+a+\" AA:\"+aa+\" B:\"+b+\" BB:\"+bb);\n\t\t\t\tmap.put(a+b,1);\n\t\t\t\tmap.put(aa+b,1);\n\t\t\t\tmap.put(a+bb,1);\n\t\t\t\tmap.put(aa+bb,1);\n\t\t\t\tmap.put(b+a,1);\n\t\t\t\tmap.put(bb+a, 1);\n\t\t\t\tmap.put(b+aa, 1);\n\t\t\t\tmap.put(bb+aa, 1);\n\t\t\t\t//out.println(map);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(map.size());\n\t\t}\n\t}\n\t\n\tvoid AOJ1137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=toInt(sc.next()),b=toInt(sc.next());\n\t\t\t//out.println(\"A:\"+a+\" B:\"+b);\n\t\t\tout.println(toMcxi(a+b));\n\t\t}\n\t}\n\tint toInt(String s){\n\t\tint ans=0,temp=1;\n\t\tchar[] c=s.toCharArray();\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tif(c[i]=='m'){\n\t\t\t\tans+=temp*1000;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='c'){\n\t\t\t\tans+=temp*100;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='x'){\n\t\t\t\tans+=temp*10;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='i'){\n\t\t\t\tans+=temp;\n\t\t\t\ttemp=1;\n\t\t\t}else{\n\t\t\t\ttemp=Character.digit(c[i],10);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tString toMcxi(int n){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tif(n/1000>0){\n\t\t\tsb.append(n/1000==1?\"m\":(n/1000)+\"m\");\n\t\t\tn%=1000;\n\t\t}\n\t\tif(n/100>0){\n\t\t\tsb.append(n/100==1?\"c\":(n/100)+\"c\");\n\t\t\tn%=100;\n\t\t}\n\t\tif(n/10>0){\n\t\t\tsb.append(n/10==1?\"x\":(n/10)+\"x\");\n\t\t\tn%=10;\n\t\t}\n\t\tif(n>0)\tsb.append(n==1?\"i\":n+\"i\");\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tlong s=sc.nextLong();\n\t\t\tout.println(\"Case \"+i+\":\");\n\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\ts*=s;\ts/=100;\ts%=10000;\n\t\t\t\tout.println(s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t    ArrayList<Integer> prime = new ArrayList<Integer>();\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for (int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            prime.add(i);\n\t            for (int j=i+i; j<=N; j+=i)    list[j] = false;\n\t        }\n\t    }\n\t    return prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for(int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            for (int j=i+i; j<=N; j+=i)     list[j] = false;\n\t        }\n\t    }\n\t    return list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t    for(int i=2; i*i<=n; i++){\n\t        if(n%i==0)     return false;\n\t    }\n\t    return true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = scanner.next();\n\t\t\tif (line.equals(\"0\"))\n\t\t\t\tbreak;\n\t\t\tPattern pattern = Pattern.compile(\"^r+$|^g+$|^b+$\");\n\t\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.offer(line);\n\t\t\tboolean flag = false;\n\t\t\tint step = 0;\n\t\t\tloop: while (!deque.isEmpty()) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tString tmp = deque.pop();\n\t\t\t\t\tif (pattern.matcher(tmp).find()) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\tchar[] chs = tmp.toCharArray();\n\t\t\t\t\t\tfor (int j = 0; j < chs.length - 1; j++) {\n\t\t\t\t\t\t\tchar l = chs[j];\n\t\t\t\t\t\t\tchar r = chs[j + 1];\n\t\t\t\t\t\t\tif (l != r) {\n\t\t\t\t\t\t\t\tchar[] tmpchs = Arrays.copyOf(chs, chs.length);\n\t\t\t\t\t\t\t\tif (l != 'r' && r != 'r')\n\t\t\t\t\t\t\t\t\ttmpchs[j] = tmpchs[j + 1] = 'r';\n\t\t\t\t\t\t\t\telse if (l != 'g' && r != 'g')\n\t\t\t\t\t\t\t\t\ttmpchs[j] = tmpchs[j + 1] = 'g';\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ttmpchs[j] = tmpchs[j + 1] = 'b';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdeque.offer(String.valueOf(tmpchs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? step : \"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tint n;\n\tint[] memo = new int[60000];\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.equals(\"0\")) break;\n\t\t\tArrays.fill(memo, -1);\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\tn = s.length();\n\t\t\tQueue<char[]> q = new ArrayDeque<char[]>();\n\t\t\tq.add(s.toCharArray());\n\t\t\tmemo[h(s.toCharArray())] = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tchar[] cur = q.poll();\n\t\t\t\tif (isok(cur)) {\n\t\t\t\t\tans = memo[h(cur)];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint w = memo[h(cur)];\n\t\t\t\tfor (int i = 0; i + 1 < cur.length; i++) {\n\t\t\t\t\tif (cur[i] != cur[i+1]) {\n\t\t\t\t\t\tchar nc = getnc(cur[i], cur[i+1]);\n\t\t\t\t\t\tchar[] nxt = cur.clone();\n\t\t\t\t\t\tnxt[i] = nxt[i+1] = nc;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint h = h(nxt);\n\t\t\t\t\t\tif (memo[h] == -1) {\n\t\t\t\t\t\t\tmemo[h] = w + 1;\n\t\t\t\t\t\t\tq.add(nxt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans < 0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\tchar getnc(char c1, char c2) {\n\t\tif (c1 == 'r' && c2 == 'g') return 'b';\n\t\tif (c1 == 'g' && c2 == 'r') return 'b';\n\t\t\n\t\tif (c1 == 'r' && c2 == 'b') return 'g';\n\t\tif (c1 == 'b' && c2 == 'r') return 'g';\n\t\t\n\t\tif (c1 == 'b' && c2 == 'g') return 'r';\n\t\tif (c1 == 'g' && c2 == 'b') return 'r';\n\t\tthrow new RuntimeException(\"orz\");\n\t}\n\tboolean isok(char[] s) {\n\t\tfor (int i = 0; i + 1 < s.length; i++) {\n\t\t\tif (s[i] != s[i+1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tint h(char[] s) {\n\t\tint h = 0;\n\t\tfor (char c : s) h = h * 3 + \"rgb\".indexOf(c);\n\t\treturn h;\n\t}\n\tchar[] g(int h) {\n\t\tchar[] s = new char[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\ts[i] = \"rgb\".charAt(h % 3);\n\t\t\th /= 3;\n\t\t}\n\t\treturn s;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tclass Node {\n\t\tint cost;//秒数\n\t\tString state;//現在の状態\n\t\tNode(int cost, String state) {\n\t\t\tthis.cost = cost;\n\t\t\tthis.state = state;\n\t\t}\n\t}\n\t\n\tprivate int solve(String start) {\n\t\tint len = start.length();\n\t\tchar[] work = new char[len];\n\t\tfor(int r =0; r < work.length; r++) work[r] = 'r';\n\t\tString r_goal = new String(work);\n\t\tfor(int r = 0; r < work.length; r++) work[r] = 'g';\n\t\tString g_goal = new String(work);\n\t\tfor(int r = 0; r < work.length; r++) work[r] = 'b';\n\t\tString b_goal = new String(work);\n\t\tint color_sum = 'r' + 'g' + 'b';\n\t\tQueue<Node> open = new LinkedList<Node>();\n\t\tTreeSet<String> closed = new TreeSet<String>();\n\t\topen.add(new Node(0, start));\n\t\tclosed.add(start);\n\t\twhile(!open.isEmpty()) {\n\t\t\tNode temp = open.poll();\n\t\t\tint cost = temp.cost;\n\t\t\tString state = temp.state;\n\t\t\tif(state.equals(r_goal) || state.equals(g_goal) || state.equals(b_goal)) {\n\t\t\t\treturn(cost);\n\t\t\t}\n\t\t\tfor(int r = 1; r < len; r++) {\n\t\t\t\tif(state.charAt(r) != state.charAt(r - 1)) {\n\t\t\t\t\tchar color = (char)(color_sum - state.charAt(r) - state.charAt(r - 1));\n\t\t\t\t\tStringBuilder nstate_b = new StringBuilder(state);\n\t\t\t\t\tnstate_b.setCharAt(r, color);\n\t\t\t\t\tnstate_b.setCharAt(r - 1, color);\n\t\t\t\t\tString nstate = new String(nstate_b);\n\t\t\t\t\tif(!closed.contains(nstate)) {\n\t\t\t\t\t\topen.add(new Node(cost + 1, new String(nstate)));\n\t\t\t\t\t\tclosed.add(new String(nstate));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn(-1);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\twhile(true) {\n\t\t\tString worm = stdIn.next();\n\t\t\tif(worm.equals(\"0\")) break;\n\t\t\tint ans = new Main().solve(worm);\n\t\t\tSystem.out.println((ans != -1) ? ans:\"NA\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            String s = sc.next();\n            if (s.equals(\"0\")) break;\n            System.out.println(dfs(convert(s)));\n        }\n    }\n    \n    String dfs(String str) {\n        Set<String> visited = new HashSet<String>();\n        visited.add(str);\n        \n        LinkedList<String> q = new LinkedList<String>();\n        LinkedList<Integer> qi = new LinkedList<Integer>();\n        q.add(str); qi.add(0);\n        \n        while (!q.isEmpty()) {\n            String s = q.removeFirst();\n            int c = qi.removeFirst();  \n            if (ok(s)) return \"\" + c;\n            for (int i = 0; i < s.length() - 1; i++) if (s.charAt(i) != s.charAt(i + 1)) {\n                int n = s.charAt(i) - '0' + s.charAt(i + 1) - '0';\n                n = (3 - n % 3) % 3;\n                String next = s.substring(0, i) + n + n + s.substring(i + 2, s.length());\n                if (!visited.contains(next)) {\n                    q.addLast(next);\n                    qi.addLast(c+1);\n                    visited.add(next);\n                }\n            }\n        }\n        return \"NA\";\n    }\n    \n    String convert(String str) {\n        String ret = \"\";\n        for (int i = 0; i < str.length(); i++) {\n            switch (str.charAt(i)) {\n            case 'r': ret += \"\" + 0; break;\n            case 'g': ret += \"\" + 1; break;\n            case 'b': ret += \"\" + 2; break;\n            }\n        }\n        return ret;\n    }\n    \n    boolean ok(String s) {\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) != s.charAt(i + 1)) return false;\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic String worm;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic boolean read() {\n\t\tworm = sc.next();\n\t\treturn (worm.equals(\"0\")) ? false : true;\n\t}\n\t\n\tstatic String solve() {\n\t\treturn bfs(worm);\n\t}\n\t\n\tstatic String bfs(String w) {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tQueue<State> que = new LinkedList<State>();\n\t\t\n\t\tque.add(new State(w, 0));\n\t\tset.add(w);\n\t\tState s;\n\t\twhile(!que.isEmpty()) {\n\t\t\ts = que.poll();\n\t\t\tif(same(s.worm)) return new Integer(s.level).toString();\n\t\t\tfor(int i = 0; i < s.worm.length() - 1; i++) {\n\t\t\t\tw = changeColor(s.worm, i);\n\t\t\t\tif(w == null) continue;\n\t\t\t\tif(!set.contains(w)) {\n\t\t\t\t\tset.add(w);\n\t\t\t\t\tque.add(new State(w, s.level + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\t\n\tstatic boolean same(String w) {\n\t\tboolean ans = true;\n\t\tchar c = w.charAt(0);\n\t\tfor(int i = 1; i < w.length(); i++) {\n\t\t\tif(c != w.charAt(i)) {\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic String changeColor(String w, int index) {\n\t\tString c = getColor(w.substring(index, index+1), w.substring(index+1, index+1+1));\n\t\tif(c == null) return null;\n\t\t\n\t\tif(index == 0) {\n\t\t\treturn c + c + w.substring(2);\n\t\t} else if(index == w.length() - 1) {\n\t\t\treturn w.substring(0, w.length() - 2) + c + c; \n\t\t} else {\n\t\t\treturn w.substring(0, 0 + index) + c + c + w.substring(index + 2, w.length());\n\t\t}\n\t}\n\t\n\tstatic String getColor(String c1, String c2) {\n\t\tif(c1.equals(\"r\")) {\n\t\t\tif(c2.equals(\"g\")) {\n\t\t\t\treturn \"b\";\n\t\t\t} else if(c2.equals(\"b\")) {\n\t\t\t\treturn \"g\";\n\t\t\t}\n\t\t} else if(c1.equals(\"g\")) {\n\t\t\tif(c2.equals(\"r\")) {\n\t\t\t\treturn \"b\";\n\t\t\t} else if(c2.equals(\"b\")) {\n\t\t\t\treturn \"r\";\n\t\t\t}\n\t\t} else if(c1.equals(\"b\")) {\n\t\t\tif(c2.equals(\"r\")) {\n\t\t\t\treturn \"g\";\n\t\t\t} else if(c2.equals(\"g\")) {\n\t\t\t\treturn \"r\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\n\t}\n\n}\n\nclass State {\n\tint level;\n\tString worm;\n\t\n\tState(String worm, int level) {\n\t\tthis.worm = worm; this.level = level;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tstatic Queue<State> queue=new LinkedList<>();\n\tstatic Set<String> set=new HashSet<>();\n\t\n\tstatic class State{\n\t\tString str1;\n\t\tint minstep;\n\t\tState(String str1, int minstep){\n\t\t\tthis.str1=str1;\n\t\t\tthis.minstep=minstep;\n\t\t}\n\t}\n\t\n\tstatic char change(char a, char b) {\n\t\tif(a=='b'||b=='b') {\n\t\t\tif(a=='r'||b=='r') {\n\t\t\t\treturn 'g';\n\t\t\t}\n\t\t\telse if(a=='g'||b=='g') {\n\t\t\t\treturn 'r';\n\t\t\t}\n\t\t}\n\t\treturn 'b';\n\t}\n\t\n\tstatic String bfs() {\n\t\twhile(! queue.isEmpty()) {\n\t\t\tState state=queue.remove();\n\t\t\tString s=state.str1;\n\t\t\tint step=state.minstep;\n\t\t\tset.add(s);\n\t\t\tString s1=\"\", s2=\"\";\n\t\t\tint count=0;\n\t\t\tfor(int i=0; i<s.length()-1; i++) {\n\t\t\t\tif(s.charAt(i)!=s.charAt(i+1)) {\n\t\t\t\t\ts1=s.substring(0, i);\n\t\t\t\t\ts2=s.substring(i+2, s.length());\n\t\t\t\t\tchar c=change(s.charAt(i), s.charAt(i+1));\n\t\t\t\t\tString sa=s1+String.valueOf(c)+String.valueOf(c)+s2;\n\t\t\t\t\tif(! set.contains(sa)) {\n\t\t\t\t\t\tset.add(sa);\n\t\t\t\t\t\tqueue.add(new State(sa, step+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(s.charAt(0)==s.charAt(i+1)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count==s.length()-1) {\n\t\t\t\tqueue.clear();\n\t\t\t\tset.clear();\n\t\t\t\treturn String.valueOf(step);\n\t\t\t}\n\t\t}\n\t\tset.clear();\n\t\treturn \"NA\";\t\t\n\t\t\n\t}\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tqueue.add(new State(str, 0));\n\t\t\t\tset.add(str);\n\t\t\t\tSystem.out.println(bfs());\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tString check(String s){\n    \t\tif(s.equals(\"rb\") || s.equals(\"br\"))return \"gg\";\n    \t\telse if(s.equals(\"rg\") || s.equals(\"gr\"))return \"bb\";\n    \t\telse if(s.equals(\"gb\") || s.equals(\"bg\"))return \"rr\";\n    \t\treturn s;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tString str = sc.next();\t\n    \t\t\tint length = str.length();\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tArrayList<String> ts = new ArrayList<String>();\n    \t\t\tts.add(str);\n    \t\t\tString r =\"\",g = \"\",b = \"\";\n    \t\t\tfor(int i = 0;i < length;i++){\n    \t\t\t\tr = r + 'r';\n    \t\t\t\tg = g + 'g';\n    \t\t\t\tb = b + 'b';\n    \t\t\t}\n    \t\t\tint cnt = 0;\n    \t\t\tboolean out = false;\n    \t\t\tif(str.equals(r) || str.equals(g) || str.equals(b))out = true;\n    \t\t\telse{\n    \t\t\t\twhile(cnt < length){\n    \t\t\t\t\tif(out)break;\n    \t\t\t\t\tcnt++;\n    \t\t\t\t\tint tssize = ts.size();\n//    \t\t\t\t\tSystem.out.println(tssize);\n    \t\t\t\t\tfor(int i = 0;i < tssize;i++){\n    \t\t\t\t\t\tif(out)break;\n    \t\t\t\t\t\tstr = ts.remove(0);\n    \t\t\t\t\t\tfor(int j = 0;j < length-1;j++){\n    \t\t\t\t\t\t\tString str2 = str.substring(0,j)+check(str.substring(j,j+2))+str.substring(j+2,length);\n    \t\t\t\t\t\t\tif(str2.equals(r) || str2.equals(g) || str2.equals(b)){\n    \t\t\t\t\t\t\t\tout = true;\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n//    \t\t\t\t\t\t\tSystem.out.println(cnt+\" \"+str+\" \"+str2+\" \"+ts.size());\n    \t\t\t\t\t\t\tif(!ts.contains(str2))ts.add(str2);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif(out)System.out.println(cnt);\n    \t\t\t\telse System.out.println(\"NA\");\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = scanner.next();\n\t\t\tif (line.equals(\"0\"))\n\t\t\t\tbreak;\n\t\t\tPattern pattern = Pattern.compile(\"^r+$|^g+$|^b+$\");\n\t\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.offer(line);\n\t\t\tboolean flag = false;\n\t\t\tint step = 0;\n\t\t\tloop: while (!deque.isEmpty()) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tString tmp = deque.pop();\n\t\t\t\t\tif (pattern.matcher(tmp).find()) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\tchar[] chs = tmp.toCharArray();\n\t\t\t\t\t\tfor (int j = 0; j < chs.length - 1; j++) {\n\t\t\t\t\t\t\tchar l = chs[j];\n\t\t\t\t\t\t\tchar r = chs[j + 1];\n\t\t\t\t\t\t\tif (l != r) {\n\t\t\t\t\t\t\t\tif (l != 'r' && r != 'r')\n\t\t\t\t\t\t\t\t\tchs[j] = chs[j + 1] = 'r';\n\t\t\t\t\t\t\t\telse if (l != 'g' && r != 'g')\n\t\t\t\t\t\t\t\t\tchs[j] = chs[j + 1] = 'g';\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tchs[j] = chs[j + 1] = 'b';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdeque.offer(String.valueOf(chs));\n\t\t\t\t\t\t\t\tchs[j] = l;\n\t\t\t\t\t\t\t\tchs[j + 1] = r;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? step : \"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(!s.equals(\"0\")) solve(s);\n\t}\n    }\n\n    static void solve(String s){\n\t//String[] pattern = new String[60000];\n\tHashSet<String> set = new HashSet<String>();\n\tint pcnt = 0;\n\tStack stack = new Stack(s);\n\tString a = s;\n\tset.add(s);\n\t//pattern[pcnt++] = a;\n\tint t = 0;\n\twhile(!stack.isEmpty() && !color(a)){\n\t    //System.out.println(a+\" \"+color(a));\n\t    Worm w = (Worm)stack.pop();\n\t    a = w.getbody();\n\t    t = w.getTime();\n\t    for(int i=0; i<a.length()-1; i++){\n\t\tif(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t    String b = change(a, i, i+1);  \n\t\t    /*\n\t\t    int j=0;\n\t\t    while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t    if(pattern[j]==null){\n\t\t\t//System.out.println(b);\n\t\t\tpattern[j] = b;\n\t\t\tstack.in(b, t+1);\n\t\t\tpcnt++;\n\t\t    }\n\t\t    */\n\t\t    if(set.contains(b)) continue;\n\t\t    else{\n\t\t\tstack.in(b, t+1);\n\t\t\tset.add(b);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif(color(a))\n\t    System.out.println(t);\n\telse\n\t    System.out.println(\"NA\");\n    }\n\n    static boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    static String change(String x, int s, int e){\n\tString ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tans += a+a;\n\t    }\n\t    else{\n\t\tans += x.substring(i, i+1);\n\t    }\n\t}\n\treturn ans;\n    }\n\t\n    static String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\nclass Stack {\n    Object[] stack = new Object[60000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tout = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Object pop(){\n\treturn stack[out++];\n    }\n    /*\n    public String getb(){\n\tWorm a = (Worm)stack[sp-1];\n\treturn a.getbody();\n    }\n    public  int gett(){\n\tWorm a = (Worm)stack[sp-1];\n\tsp--;\n\treturn a.getTime();\n    }\n    */\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n\nclass Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static boolean isEnd (String str) {\n\t\treturn  (str.indexOf(\"r\") == -1 && str.indexOf(\"g\") == -1) ||\n\t\t\t\t(str.indexOf(\"r\") == -1 && str.indexOf(\"b\") == -1) ||\n\t\t\t\t(str.indexOf(\"g\") == -1 && str.indexOf(\"b\") == -1);\n\n\t}\n\n\tpublic static char getColor (char a, char b) {\n\n\t\tif ((a == 'r' && b == 'g') || a == 'g' && b == 'r') return 'b';\n\t\tif ((a == 'r' && b == 'b') || a == 'b' && b == 'r') return 'g';\n\t\treturn 'r';\n\n\t}\n\n\tpublic static String bfs (String str) {\n\n\t\tif (isEnd(str)) return \"0\";\n\n\t\tArrayList<String> pattern = new ArrayList<String>();\n\t\tArrayList<String> memo = new ArrayList<String>();\n\n\t\tint step = 1;\n\n\t\tpattern.add(str);\n\t\tmemo.add(str);\n\n\t\twhile (!pattern.isEmpty()) {\n\n\t\t\tArrayList<String> next = new ArrayList<String>();\n//\t\t\tSystem.out.println(step);\n\t\t\tfor (String p : pattern) {\n\t\t\t\tfor (int i = 1; i < p.length(); i++) {\n\t\t\t\t\tif (p.charAt(i - 1) != p.charAt(i)) {\n\t\t\t\t\t\tchar[] c = p.toCharArray();\n\t\t\t\t\t\tchar rep = getColor(p.charAt(i - 1), p.charAt(i));\n\t\t\t\t\t\tc[i - 1] = (c[i] = rep);\n//\t\t\t\t\t\tSystem.out.println(new String(c));\n\t\t\t\t\t\tif (isEnd(new String(c))) return \"\" + step;\n\t\t\t\t\t\tif (!memo.contains(new String(c))) {\n\t\t\t\t\t\t\tmemo.add(new String(c));\n\t\t\t\t\t\t\tnext.add(new String(c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstep++;\n\t\t\tpattern = next;\n\t\t}\n\n\t\treturn \"NA\";\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tString str = sc.nextLine();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tSystem.out.println(bfs(str));\n\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private void run() {\n        while (true) {\n            String S = read();\n            if (S.equals(\"0\")) break;\n            if (sameAll(S)) {\n                sysout.println(0);\n                continue;\n            }\n            Queue<State> que = new ArrayDeque<State>();\n            HashSet<String> hist = new HashSet<String>();\n            que.add(new State(S, 0));\n            hist.add(S);\n            int ans = -1;\n            while (!que.isEmpty()) {\n                State state = que.poll();\n//                sysout.println(state.cost + \" \" + state.str);\n                char[] t = state.str.toCharArray();\n                for (int i = 0; i < t.length - 1; i++) {\n                    if (t[i] == t[i + 1]) continue;\n                    char[] tmp = {t[i], t[i + 1]};\n\n                    char n = next(tmp);\n                    t[i] = n; t[i+1] = n;\n\n                    String ts = new String(t);\n                    if (!hist.contains(ts)) {\n                        que.add(new State(ts, state.cost + 1));\n                        hist.add(ts);\n                        if (sameAll(ts) && ans == -1) ans = state.cost + 1;\n                    }\n\n                    t[i] = tmp[0];\n                    t[i + 1] = tmp[1];\n                }\n            }\n            if (ans == -1) sysout.println(\"NA\");\n            else sysout.println(ans);\n        }\n    }\n\n    boolean sameAll(String str) {\n        char c = str.charAt(0);\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) != c) return false;\n        }\n        return true;\n    }\n\n    char next(char[] now) {\n        if (now[0] == 'r' && now[1] == 'g') return 'b';\n        if (now[0] == 'r' && now[1] == 'b') return 'g';\n        if (now[0] == 'g' && now[1] == 'r') return 'b';\n        if (now[0] == 'g' && now[1] == 'b') return 'r';\n        if (now[0] == 'b' && now[1] == 'r') return 'g';\n        if (now[0] == 'b' && now[1] == 'g') return 'r';\n        return '_';\n    }\n\n    class State implements Comparable<State> {\n        public String str;\n        public int cost;\n\n        public State(String str, int cost) {\n            this.str = str;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(State o) {\n            return cost - o.cost;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    // flush automatically iff you call `println` or `printf` or `format`.\n    PrintWriter sysout = new PrintWriter(System.out, true);\n\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer buffer = null;\n\n    String readLine() {\n        buffer = null;\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    String read() {\n        if (buffer == null || !buffer.hasMoreTokens()) {\n            buffer = new StringTokenizer(readLine());\n        }\n        return buffer.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(read());\n    }\n\n    long readLong() {\n        return Long.parseLong(read());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(read());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.concurrent.LinkedBlockingDeque;\n\npublic class Main {\n\n\tpublic static class Insect implements Comparable<Insect>{\n\t\tchar[] ch;\n\t\tint sec;\n\t\t\n\t\tpublic Insect(char[] ch, int sec) {\n\t\t\tsuper();\n\t\t\tthis.ch = ch;\n\t\t\tthis.sec = sec;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Insect arg0) {\n\t\t\treturn this.sec - arg0.sec;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\tint hash = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\t\tif(ch[i] == 'r'){\n\t\t\t\t\thash += 1;\n\t\t\t\t}else if(ch[i] == 'g'){\n\t\t\t\t\thash += 2;\n\t\t\t\t}else{\n\t\t\t\t\thash += 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(i != ch.length - 1){\n\t\t\t\t\thash <<= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn hash;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o){\n\t\t\treturn o instanceof Insect && o.hashCode() == this.hashCode();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile (true) {\n\t\t\tString str = sc.next();\n\t\t\t\n\t\t\tif(\"0\".equals(str)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Insect> queue = new PriorityQueue<Insect>();\n\t\t\tHashSet<Insect> visited = new HashSet<Insect>((int) Math.pow(3, str.length()));\n\t\t\t\n\t\t\t\n\t\t\tqueue.add(new Insect(str.toCharArray(), 0));\n\t\t\t\n\t\t\tint min = -1;\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tInsect is = queue.poll();\n\t\t\t\t\n\t\t\t\tif(visited.contains(is)){\n\t\t\t\t\t//System.out.println(\"!!! duplicate !!! \" + Arrays.toString(is.ch) + \" \" + is.hashCode() + \" \" + is.sec);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited.add(is);\n\t\t\t\t\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int i = 0; i < is.ch.length - 1; i++){\n\t\t\t\t\tif(is.ch[i] != is.ch[i+1]){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(flag){\n\t\t\t\t\tmin = is.sec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < is.ch.length - 1; i++){\n\t\t\t\t\tif(is.ch[i] != is.ch[i+1]){\n\t\t\t\t\t\tchar[] tmp = new char[is.ch.length];\n\t\t\t\t\t\tSystem.arraycopy(is.ch, 0, tmp, 0, is.ch.length);\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(is.ch[i] == 'r'){\n\t\t\t\t\t\t\tif(is.ch[i+1] == 'g' ){\n\t\t\t\t\t\t\t\ttmp[i] = tmp[i+1] = 'b';\n\t\t\t\t\t\t\t}else if(is.ch[i+1] == 'b' ){\n\t\t\t\t\t\t\t\ttmp[i] = tmp[i+1] = 'g';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(is.ch[i] == 'g'){\n\t\t\t\t\t\t\tif(is.ch[i+1] == 'r' ){\n\t\t\t\t\t\t\t\ttmp[i] = tmp[i+1] = 'b';\n\t\t\t\t\t\t\t}else if(is.ch[i+1] == 'b' ){\n\t\t\t\t\t\t\t\ttmp[i] = tmp[i+1] = 'r';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(is.ch[i+1] == 'r' ){\n\t\t\t\t\t\t\t\ttmp[i] = tmp[i+1] = 'g';\n\t\t\t\t\t\t\t}else if(is.ch[i+1] == 'g' ){\n\t\t\t\t\t\t\t\ttmp[i] = tmp[i+1] = 'r';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tInsect t = new Insect(tmp,is.sec+1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!visited.contains(t)){\n\t\t\t\t\t\t\tqueue.add(t);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//System.out.println(\"!!! duplicate !!! \" + Arrays.toString(is.ch) + \" \" + is.hashCode() + \" \" + is.sec);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(min != -1){\n\t\t\t\tSystem.out.println(min);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tMainLoop : while(true){\n\t\t\tString text = scan.next();\n\t\t\tint len = text.length();\n\t\t\tint n = wormToInt(text);\n\t\t\tif(n==-1) break;\n\t\t\tboolean[] pattern = new boolean[(int)pow(3,len)];\n\t\t\tLinkedList<int[]> que = new LinkedList<int[]>();\n\t\t\tque.offer(new int[]{n,0});\n\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint[] ary = que.poll();\n\t\t\t\tint worm = ary[0],cnt = ary[1];\n\n\t\t\t\tif(pattern[worm]) continue;\n\t\t\t\tpattern[worm]=true;\n\n\t\t\t\tif(monotonous(worm,len)){\n\t\t\t\t\tout.println(cnt);\n\t\t\t\t\tcontinue MainLoop;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < len-1; i++) {\n\t\t\t\t\tif(worm/(int)pow(3,i)%3!=worm/(int)pow(3,i+1)%3){\n\t\t\t\t\t\tfor (int j = 0; j < 3 ; j++) {\n\t\t\t\t\t\t\tif(worm/(int)pow(3,i)%3!=j && worm/(int)pow(3,i+1)%3!=j) que.offer(new int[]{change(worm,i+1,i,j),cnt+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(\"NA\");\n\t\t}\n\n\t\tout.flush();\n\t}\n\n\tstatic int change(int w,int p1,int p2,int color){\n\t\tint a = (int)pow(3,p1+1);\n\t\tint b = (int)pow(3,p2);\n\t\treturn w/a*a+w%b+color*(int)(pow(3,p1)+pow(3,p2));\n\t}\n\n\tstatic boolean monotonous(int w,int len){\n\t\tint color = w%3;\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\tif(color!=w/(int)pow(3,i)%3) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic int wormToInt(String w){\n\t\tif(w.equals(\"0\")) return -1;\n\t\tint x=0;\n\t\tfor (int i = w.length()-1; i >=0; i--) {\n\t\t\tswitch(w.charAt(i)){\n\t\t\t\tcase 'r' : x=x*3+0; break;\n\t\t\t\tcase 'g' : x=x*3+1; break;\n\t\t\t\tcase 'b' : x=x*3+2; break;\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Mysterious Worm\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.equals(\"0\"))break;\n\t\t\tint n = s.length();\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(s);\n\t\t\tint step = 0;\n\t\t\tboolean ans = false;\n\t\t\tList<String> l = new ArrayList<String>();\n\t\t\tl.add(s);\n\t\t\twhile(!l.isEmpty()){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String u:l){\n\t\t\t\t\tchar[] c = u.toCharArray();\n\t\t\t\t\tchar ch = c[0];\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\t\t\tif(c[i]!=ch){\n\t\t\t\t\t\t\tf = false;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\t\t\tif(c[i]!=c[i+1]){\n\t\t\t\t\t\t\tchar a = c[i];\n\t\t\t\t\t\t\tchar b = c[i+1];\n\t\t\t\t\t\t\tchar v = a!='r'&&b!='r'?'r':a!='g'&&b!='g'?'g':'b';\n\t\t\t\t\t\t\tc[i] = c[i+1] = v;\n\t\t\t\t\t\t\tString st = new String(c);\n\t\t\t\t\t\t\tif(!set.contains(st)){\n\t\t\t\t\t\t\t\tset.add(st);\n\t\t\t\t\t\t\t\tnext.add(st);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[i] = a;\n\t\t\t\t\t\t\tc[i+1] = b;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(ans?--step:\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            String s = sc.next();\n            if (s.equals(\"0\")) break;\n            System.out.println(dfs(convert(s)));\n        }\n    }\n    \n    String dfs(String str) {\n        Set<String> visited = new HashSet<String>();\n        visited.add(str);\n        \n        LinkedList<String> q = new LinkedList<String>();\n        LinkedList<Integer> qi = new LinkedList<Integer>();\n        q.add(str); qi.add(0);\n        \n        while (!q.isEmpty()) {\n            String s = q.removeFirst();\n            int c = qi.removeFirst();  \n            if (ok(s)) return \"\" + c;\n            for (int i = 0; i < s.length() - 1; i++) if (s.charAt(i) != s.charAt(i + 1)) {\n                int n = s.charAt(i) - '0' + s.charAt(i + 1) - '0';\n                n = (3 - n % 3) % 3;\n                String next = s.substring(0, i) + n + n + s.substring(i + 2, s.length());\n                if (!visited.contains(next)) {\n                    q.addLast(next);\n                    qi.addLast(c+1);\n                    visited.add(next);\n                }\n            }\n        }\n        return \"NA\";\n    }\n    \n    String convert(String str) {\n        String ret = \"\";\n        for (int i = 0; i < str.length(); i++) {\n            switch (str.charAt(i)) {\n            case 'r': ret += \"\" + 0; break;\n            case 'g': ret += \"\" + 1; break;\n            case 'b': ret += \"\" + 2; break;\n            }\n        }\n        return ret;\n    }\n    \n    boolean ok(String s) {\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) != s.charAt(i + 1)) return false;\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(!s.equals(\"0\")) solve(s);\n\t}\n    }\n\n    static void solve(String s){\n\t//String[] pattern = new String[60000];\n\tHashSet<String> set = new HashSet<String>();\n\tint pcnt = 0;\n\tStack stack = new Stack(s);\n\tString a = s;\n\tset.add(s);\n\t//pattern[pcnt++] = a;\n\tint t = 0;\n\twhile(!stack.isEmpty() && !color(a)){\n\t    //System.out.println(a+\" \"+color(a));\n\t    Worm w = (Worm)stack.pop();\n\t    a = w.getbody();\n\t    t = w.getTime();\n\t    for(int i=0; i<a.length()-1; i++){\n\t\tif(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t    String b = change(a, i, i+1);  \n\t\t    /*\n\t\t    int j=0;\n\t\t    while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t    if(pattern[j]==null){\n\t\t\t//System.out.println(b);\n\t\t\tpattern[j] = b;\n\t\t\tstack.in(b, t+1);\n\t\t\tpcnt++;\n\t\t    }\n\t\t    */\n\t\t    if(set.contains(b)) continue;\n\t\t    else{\n\t\t\tstack.in(b, t+1);\n\t\t\tset.add(b);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif(color(a))\n\t    System.out.println(t);\n\telse\n\t    System.out.println(\"NA\");\n    }\n\n    static boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    static String change(String x, int s, int e){\n\tString ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tans += a+a;\n\t    }\n\t    else{\n\t\tans += x.substring(i, i+1);\n\t    }\n\t}\n\treturn ans;\n    }\n\t\n    static String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\nclass Stack {\n    Object[] stack = new Object[600000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tout = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Object pop(){\n\treturn stack[out++];\n    }\n    /*\n    public String getb(){\n\tWorm a = (Worm)stack[sp-1];\n\treturn a.getbody();\n    }\n    public  int gett(){\n\tWorm a = (Worm)stack[sp-1];\n\tsp--;\n\treturn a.getTime();\n    }\n    */\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n\nclass Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Queue<Q> queue = new LinkedList<Q>();\n\tstatic LinkedList<String> list = new LinkedList<String>();\n\tstatic int min;\n\n\tstatic class Q {\n\t\tStringBuffer bug;\n\t\tint n;\n\n\t\tQ(StringBuffer bug, int n) {\n\t\t\tthis.bug = new StringBuffer(bug);\n\t\t\tthis.n = n;\n\t\t}\n\t}\n\n\tpublic static void f() {\n\t\twhile (!queue.isEmpty() && min == -1) {\n\t\t\tQ q = queue.poll();\n\t\t\tg(q.bug, q.n);\n\t\t}\n\t}\n\n\tpublic static void g(StringBuffer bug, int n) {\n\t\tif (list.contains(bug.toString())) {\n\t\t\treturn ;\n\t\t}\n\t\tif (check(bug)) {\n\t\t\tmin = n;\n\t\t\treturn ;\n\t\t}\n\t\tlist.add(bug.toString());\n\t\tfor (int i = 0; i < bug.length() - 1; i++) {\n\t\t\tStringBuffer bug2 = new StringBuffer(bug);\n\t\t\tif (bug2.charAt(i) != bug2.charAt(i + 1)) {\n\t\t\t\tint a = 6 - Integer.valueOf(bug2.charAt(i)) - Integer.valueOf(bug2.charAt(i + 1)) + 2 * '0';\n\t\t\t\tbug2.replace(i, i + 1, Integer.toString(a));\n\t\t\t\tbug2.replace(i + 1, i + 2, Integer.toString(a));\n\t\t\t\tqueue.add(new Q(bug2, n + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean check(StringBuffer bug) {\n\t\tfor (int i = 0; i < bug.length() - 1; i++) {\n\t\t\tif (bug.charAt(i) != bug.charAt(i + 1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static String remakeString(StringBuffer bug) {\n\t\tString bug2 = \"\";\n\n\t\tfor (int i = 0; i < bug.length(); i++) {\n\t\t\tint a = bug.charAt(i);\n\t\t\tif (a == 'r') {\n\t\t\t\tbug2 += \"1\";\n\t\t\t} else if (a == 'g') {\n\t\t\t\tbug2 += \"2\";\n\t\t\t} else if (a == 'b') {\n\t\t\t\tbug2 += \"3\";\n\t\t\t}\n\t\t}\n\n\t\treturn bug2;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tStringBuffer bug;\n\n\t\twhile (true) {\n\t\t\tbug = new StringBuffer(sc.next());\n\t\t\tif (bug.toString().equals(\"0\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tlist.clear();\n\t\t\tmin = -1;\n\t\t\tbug = new StringBuffer(remakeString(bug));\n\t\t\tqueue.add(new Q(bug, 0));\n\t\t\tf();\n\n\t\t\tif (min != -1) {\n\t\t\t\tSystem.out.println(min);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tArrayDeque<StringBuffer> q = new ArrayDeque<StringBuffer>();\n\t\t\tHashSet<String> hs = new HashSet<String>();\n\t\t\tString in_str;\n\t\t\tin_str = sc.next();\n\t\t\tStringBuffer sb = new StringBuffer(in_str);\n\t\t\tif(in_str.equals(\"0\"))\n\t\t\t\tbreak;\n\t\t\tq.add(sb);\n\t\t\ths.add(in_str);\n\t\t\tboolean flg_continue = true;\n\t\t\tfor(int t = 0; flg_continue; t++) {\n\t\t\t\tArrayDeque<StringBuffer> nex = new ArrayDeque<StringBuffer>();\n\t\t\t\twhile(q.size() != 0 && flg_continue) {\n\t\t\t\t\tString a = q.poll().toString();\n\t\t\t\t\tboolean flg = true;\n\t\t\t\t\tfor(int i = 1; i < a.length(); i++) {\n\t\t\t\t\t\tif(a.charAt(i-1) != a.charAt(i)) {\n\t\t\t\t\t\t\tStringBuffer push = new StringBuffer(a);\n\t\t\t\t\t\t\tchar c = (char)((int)'r'+(int)'g'+(int)'b'-(int)a.charAt(i-1)-(int)a.charAt(i));\n\t\t\t\t\t\t\tpush.setCharAt(i-1,c);\n\t\t\t\t\t\t\tpush.setCharAt(i,c);\n\t\t\t\t\t\t\tif(!hs.contains(push.toString())) {\n\t\t\t\t\t\t\t\ths.add(push.toString());\n\t\t\t\t\t\t\t\tnex.add(push);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tSystem.out.println(t);\n\t\t\t\t\t\tflg_continue = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq = nex;\n\t\t\t\tif(flg_continue && nex.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\tflg_continue = false;\n\t\t\t\t}\n//\t\t\t\tSystem.out.print(\"t:\");\n//\t\t\t\tSystem.out.print(t);\n//\t\t\t\tSystem.out.print(\" size:\");\n//\t\t\t\tSystem.out.println(q.size());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run(){\n\t\tchar[] wormcolor;\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\twormcolor = sc.next().toCharArray();\n\t\t\tif(wormcolor[0] == '0'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(BFS(wormcolor));\n\t\t}\n\t}\n\n\tString BFS(char[] wc){\n\t\tHashSet<String> used = new HashSet<String>();\n\t\tQueue<Worm> q = new LinkedList<Worm>();\n\t\tWorm wm = new Worm(wc, 0);\n\t\tq.add(wm);\n\t\twhile(!q.isEmpty()){\n\t\t\tWorm cur = q.poll();\n\t\t\tif(cur.isSameColor()){\n\t\t\t\treturn cur.getDepth()+\"\";\n\t\t\t}\n\t\t\tif(used.contains(String.valueOf(cur.getColor()))){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused.add(String.valueOf(cur.getColor()));\n\t\t\tfor(Worm nw: cur.getNext()){\n\t\t\t\tq.add(nw);\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n}\n\nclass Worm{\n\tchar[] color;\n\tint depth;\n\tHashMap<String,Character> table = new HashMap<String,Character>(); \n\tpublic Worm(char[] color, int depth){\n\t\tthis.color = color;\n\t\tthis.depth = depth;\n\t\ttable.put(\"rg\",'b'); table.put(\"gr\",'b');\n\t\ttable.put(\"rb\",'g'); table.put(\"br\",'g');\n\t\ttable.put(\"gb\",'r'); table.put(\"bg\",'r');\n\t}\n\n\tboolean isSameColor(){\n\t\tfor(int i=0; i < color.length - 1; i++){\n\t\t\tif(color[i] != color[i+1]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic int getDepth(){\n\t\treturn depth;\n\t}\n\n\tpublic char[] getColor() {\n\t\treturn color;\n\t}\n\n\tpublic ArrayList<Worm> getNext(){\n\t\tArrayList<Worm> result = new ArrayList<Worm>();\n\t\tfor(int i = 0; i < color.length - 1; i++){\n\t\t\tif(color[i] == color[i+1]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar[] cp = Arrays.copyOf(color, color.length);\n\t\t\tcp[i] = table.get(String.valueOf(color[i]) + color[i+1]);\n\t\t\tcp[i+1] = table.get(\"\" + color[i] + color[i+1]);\n\t\t\tresult.add(new Worm(cp, depth+1));\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(!s.equals(\"0\")) solve(s);\n\t}\n    }\n\n    static void solve(String s){\n\t//String[] pattern = new String[60000];\n\tHashSet<String> set = new HashSet<String>();\n\tint pcnt = 0;\n\tStack stack = new Stack(s);\n\tString a = s;\n\tset.add(s);\n\t//pattern[pcnt++] = a;\n\tint t = 0;\n\twhile(!stack.isEmpty() && !color(a)){\n\t    //System.out.println(a+\" \"+color(a));\n\t    Worm w = stack.pop();\n\t    a = w.getbody();\n\t    t = w.getTime();\n\t    for(int i=0; i<a.length()-1; i++){\n\t\tif(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t    String b = change(a, i, i+1);  \n\t\t    /*\n\t\t    int j=0;\n\t\t    while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t    if(pattern[j]==null){\n\t\t\t//System.out.println(b);\n\t\t\tpattern[j] = b;\n\t\t\tstack.in(b, t+1);\n\t\t\tpcnt++;\n\t\t    }\n\t\t    */\n\t\t    if(set.contains(b)) continue;\n\t\t    else{\n\t\t\tstack.in(b, t+1);\n\t\t\tset.add(b);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif(color(a))\n\t    System.out.println(t);\n\telse\n\t    System.out.println(\"NA\");\n    }\n\n    static boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    static String change(String x, int s, int e){\n\tString ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tans += a+a;\n\t    }\n\t    else{\n\t\tans += x.substring(i, i+1);\n\t    }\n\t}\n\treturn ans;\n    }\n\t\n    static String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\nclass Stack {\n    Worm[] stack = new Worm[60000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tout = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Worm pop(){\n\treturn stack[out++];\n    }\n    /*\n    public String getb(){\n\tWorm a = (Worm)stack[sp-1];\n\treturn a.getbody();\n    }\n    public  int gett(){\n\tWorm a = (Worm)stack[sp-1];\n\tsp--;\n\treturn a.getTime();\n    }\n    */\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n\nclass Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass P implements Comparable<P> {\n\t\tint s;\n\t\tint v;\n\n\t\tP(int s, int v) {\n\t\t\tthis.s = s;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tpublic int compareTo(P t) {\n\t\t\treturn v - t.v;\n\t\t}\n\t}\n\n\tint decode(String buffer) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < buffer.length(); i++) {\n\t\t\tret = ret << 2;\n\t\t\tchar ch = buffer.charAt(i);\n\t\t\tif (ch == 'r') {\n\t\t\t\tret += 3;\n\t\t\t} else if (ch == 'g') {\n\t\t\t\tret += 2;\n\t\t\t} else {\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\t\t\tString buffer = sc.next();\n\t\t\tif (buffer.equals(\"0\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint s = decode(buffer);\n\t\t\tint n = buffer.length();\n\n\t\t\tPriorityQueue<P> q = new PriorityQueue<P>();\n\t\t\tq.add(new P(s, 0));\n\t\t\tboolean used[] = new boolean[1 << (n * 2)];\n\t\t\tint ans = -1;\n\t\t\tint z = 0;\n\t\t\tint type[] = new int[n];\n\t\t\tint d[] = new int[n];\n\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tP v = q.poll();\n\t\t\t\tif (used[v.s]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[v.s] = true;\n\n\t\t\t\tint max = 0;\n\t\t\t\tint s2 = v.s;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\ttype[i] = s2 & 3;\n\t\t\t\t\ts2 = s2 >> 2;\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\td[i - 1] = type[i] ^ type[i - 1];\n\t\t\t\t\t\tmax = (d[i - 1] | max);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (max == 0) {\n\t\t\t\t\tans = v.v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\t\tif (d[i] != 0) {\n\t\t\t\t\t\tint v2 = v.s;\n\t\t\t\t\t\tv2 = v2 & (~(3 << (2 * (i))));\n\t\t\t\t\t\tv2 = v2 & (~(3 << (2 * (i + 1))));\n\n\t\t\t\t\t\tv2 = v2 | (d[i] << (2 * (i)));\n\t\t\t\t\t\tv2 = v2 | (d[i] << (2 * (i + 1)));\n\t\t\t\t\t\tif (!used[v2]) {\n\t\t\t\t\t\t\tq.add(new P(v2, v.v + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans == -1) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\n\twhile ( true ) {\n\n\t    final String input = stdin.nextLine();\n\t    if ( \"0\".equals( input ) ){\n\t\tbreak;\n\t    }\n\n\t    final int ans =  solve( input );\n\t    if ( ans >= 0 ) { \n\t\tSystem.out.println( ans );\n\t    } else {\n\t\tSystem.out.println( \"NA\" );\n\t    }\n\t}\n    }\n\n    static int solve( final String input ){\n\tfinal ArrayList<String> before = new ArrayList<String>();\n\tbefore.add( input );\n\tfinal ArrayList<String> after = new ArrayList<String>();\n\t\n\tfinal Set<String> visited = new HashSet<String>();\n\n\tint count = 0;\n\t\n\twhile ( !before.isEmpty() ) {\n\t    for ( final String str : before ) {\n\t\tif ( allSame( str ) ) {\n\t\t    return count;\n\t\t} else {\n\t\t    for ( int i = 0; i < str.length() - 1; i++ ) {\n\t\t\tif ( str.charAt( i ) != str.charAt( i + 1 ) ) {\n\t\t\t    final char[] array = str.toCharArray();\n\t\t\t    final char dif = getDiffColor( str.charAt( i ), str.charAt( i + 1 ) );\n\t\t\t    array[ i ] = array[ i + 1 ] = dif;\n\t\t\t    final String next = new String( array );\n\t\t\t    if ( !visited.contains( next ) ){\n\t\t\t\tafter.add( next );\n\t\t\t\tvisited.add( next );\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    before.clear();\n\t    before.addAll( after );\n\t    after.clear();\t\t    \n\t    count++;\n\t}\n\treturn -1;\n    }\n\n    static boolean allSame( final String str ) {\n\tfinal char ch = str.charAt( 0 );\n\tfor( final char c : str.toCharArray() ) {\n\t    if ( c != ch ) {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    }\n\n    static char getDiffColor( final char ch1, final char ch2 ) {\n\tif ( ch1 > ch2 ) {\n\t    return getDiffColor( ch2, ch1 );\n\t}\n\n\tif ( ch1 == 'b' && ch2 == 'g' ) {\n\t    return 'r';\n\t} else if ( ch1 == 'b' && ch2 == 'r' ) {\n\t    return 'g';\n\t} else {\n\t    return 'b';\n\t}\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\n\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\tif(in[0] == '0') break;\n\t\t\tint ans = bfs(in);\n\t\t\tif(ans == 10) {\n\t\t\t\tout.println(\"NA\");\n\t\t\t}\n\t\t\telse\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tstatic HashMap<String, Integer> map = new HashMap<String, Integer>();\n\tstatic int min = 10;\n\tpublic static int bfs(char[] a) {\n\t\tmin = 10;\n\t\tmap.clear();\n\t\tqueue.clear();\n\t\tqueue.offer(new Data(a,0));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tsolv(queue.poll());\n\t\t}\n\t\treturn min;\n\t}\n\t\n\tpublic static void solv(Data a) {\n\t\tchar[] t = a.data;\n\t\tboolean c = true;\n\t\tif(a.count >= min) return;\n\t\tif(map.containsKey(String.valueOf(t)) && map.get(String.valueOf(t)) < a.count) {\n\t\t\treturn;\n\t\t}\n\t\tmap.put(String.valueOf(t), a.count);\n\t\tfor(int i = 0; i < t.length-1; i++) {\n\t\t\tif(t[i] != t[i+1]) {\n\t\t\t\tc = false;\n\t\t\t\tchar xx = check(t[i],t[i+1]);\n\t\t\t\tchar[] cpy = Arrays.copyOf(t, t.length);\n\t\t\t\tcpy[i] = xx;\n\t\t\t\tcpy[i+1] = xx;\n\t\t\t\tqueue.addLast(new Data(cpy,a.count+1));\n\t\t\t}\n\t\t}\n\t\tif(min > a.count && c) {\n\t\t\tmin = a.count;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static char check(char a, char b) {\n\t\tboolean[] list = new boolean[3];\n\t\tif(a == 'r' || b == 'r') {\n\t\t\tlist[0] = true;\n\t\t}\n\t\tif(a == 'g' || b == 'g') {\n\t\t\tlist[1] = true;\n\t\t}\n\t\tif(a == 'b' || b == 'b') {\n\t\t\tlist[2] = true;\n\t\t}\n\t\t\n\t\tif(!list[0]) return 'r';\n\t\tif(!list[1]) return 'g';\n\t\treturn 'b';\n\t}\n\t\n\t\n\n}\n\nclass Data {\n\tchar[] data;\n\tint    count;\n\tData(char[] a, int b) {\n\t\tdata = a;\n\t\tcount = b;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tString str;\n\tboolean[] visited;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tstr = sc.next();\n\t\t\tif(str.equals(\"0\")) break;\n\t\t\tn = str.length();\n\t\t\tint max = 1;\n\t\t\tfor(int i=0;i<n;i++) max *= 3;\n\t\t\tvisited = new boolean[max];\n\t\t\tint ans = bfs(new Worm(str));\n\t\t\tif( ans < 0 ) System.out.println(\"NA\");\n\t\t\telse System.out.println(ans);\n\t\t}\n\t}\n\t\n\tint bfs(Worm worm) {\n\t\tLinkedList<Worm> que = new LinkedList<Worm>();\n\t\tque.add(worm);\n\t\tvisited[worm.w] = true;\n\t\tWorm w = new Worm(\"\");\n\t\twhile(true) {\n\t\t\tif(que.isEmpty()) return -1;\n\t\t\tw = que.removeFirst();\n//\t\t\tSystem.out.println(w.w);\n\t\t\tint col = w.w;\n\t\t\tint a = col%3;\n\t\t\tint b = col%3;\n\t\t\tint tmp = 1;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\ta = b;\n\t\t\t\ttmp *= 3;\n\t\t\t\tb = (col/tmp)%3;\n\t\t\t\tif(a != b) {\n\t\t\t\t\tWorm next = new Worm(col - a*tmp/3-b*tmp + (tmp+tmp/3) * (3-a-b), w.cnt+1);\n\t\t\t\t\tif(!visited[next.w]) {\n\t\t\t\t\t\tque.addLast(next);\n\t\t\t\t\t\tvisited[next.w] = true;\n\t\t\t\t\t}\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f) return w.cnt;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Worm {\n\t\tint w, cnt;\n\t\tWorm(String str) {\n\t\t\tint tmp = 1;\n\t\t\tfor(int i=0;i<str.length();i++) {\n\t\t\t\tswitch (str.charAt(i)) {\n\t\t\t\tcase 'r': w += tmp * 0; break;\n\t\t\t\tcase 'g': w += tmp * 1; break;\n\t\t\t\tcase 'b': w += tmp * 2; break;\n\t\t\t\t}\n\t\t\t\ttmp *= 3;\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t}\n\t\t\n\t\tWorm(int w, int cnt) {\n\t\t\tthis.w = w;\n\t\t\tthis.cnt = cnt;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static boolean isEnd (String str) {\n\t\tboolean f = true;\n\t\tfor (int i = 1; i < str.length(); i++)\n\t\t\tf &= str.charAt(i - 1) == str.charAt(i);\n\t\treturn f;\n\t}\n\n\tpublic static char getColor (char a, char b) {\n\n\t\tif ((a == 'r' && b == 'g') || a == 'g' && b == 'r') return 'b';\n\t\tif ((a == 'r' && b == 'b') || a == 'b' && b == 'r') return 'g';\n\t\treturn 'r';\n\n\t}\n\n\tpublic static String bfs (String str) {\n\n\t\tif (isEnd(str)) return \"0\";\n\n\t\tArrayList<String> pattern = new ArrayList<String>();\n\t\tSet<String> memo = new HashSet<String>();\n\n\t\tint step = 1;\n\n\t\tpattern.add(str);\n\t\tmemo.add(str);\n\n\t\twhile (!pattern.isEmpty()) {\n\n\t\t\tArrayList<String> next = new ArrayList<String>();\n\t\t\tfor (String p : pattern) {\n\t\t\t\tfor (int i = 1; i < p.length(); i++) {\n\t\t\t\t\tif (p.charAt(i - 1) != p.charAt(i)) {\n\t\t\t\t\t\tchar[] c = p.toCharArray();\n\t\t\t\t\t\tchar rep = getColor(p.charAt(i - 1), p.charAt(i));\n\t\t\t\t\t\tc[i - 1] = (c[i] = rep);\n\t\t\t\t\t\tif (isEnd(new String(c))) return \"\" + step;\n\t\t\t\t\t\tif (!memo.contains(new String(c))) {\n\t\t\t\t\t\t\tmemo.add(new String(c));\n\t\t\t\t\t\t\tnext.add(new String(c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstep++;\n\t\t\tpattern = next;\n\t\t}\n\n\t\treturn \"NA\";\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tString str = sc.nextLine();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tSystem.out.println(bfs(str));\n\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(!s.equals(\"0\")) solve(s);\n\t}\n    }\n\n    static void solve(String s){\n\tString[] pattern = new String[60000];\n\tint pcnt = 0;\n\tStack stack = new Stack(s);\n\tString a = s;\n\tpattern[pcnt++] = a;\n\tint t = 0;\n\twhile(!stack.isEmpty() && !color(a)){\n\t    //System.out.println(a+\" \"+color(a));\n\t    Worm w = (Worm)stack.pop();\n\t    a = w.getbody();\n\t    t = w.getTime();\n\t    for(int i=0; i<a.length()-1; i++){\n\t\tif(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t    String b = change(a, i, i+1);  \n\t\t    int j=0;\n\t\t    while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t    if(pattern[j]==null){\n\t\t\t//System.out.println(b);\n\t\t\tpattern[j] = b;\n\t\t\tstack.in(b, t+1);\n\t\t\tpcnt++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif(color(a))\n\t    System.out.println(t);\n\telse\n\t    System.out.println(\"NA\");\n    }\n\n    static boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    static String change(String x, int s, int e){\n\tString ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tans += a+a;\n\t    }\n\t    else{\n\t\tans += x.substring(i, i+1);\n\t    }\n\t}\n\treturn ans;\n    }\n\t\n    static String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\nclass Stack {\n    Object[] stack = new Object[600000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tint out = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Object pop(){\n\treturn stack[out++];\n    }\n    /*\n    public String getb(){\n\tWorm a = (Worm)stack[sp-1];\n\treturn a.getbody();\n    }\n    public  int gett(){\n\tWorm a = (Worm)stack[sp-1];\n\tsp--;\n\treturn a.getTime();\n    }\n    */\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n\nclass Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\t\tint ans=0;\n\t\t\tint flag=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tque.add(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]==ch[j+1])\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tif(map.get(tmp)==null)\n\t\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t\tmap.put(tmp, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tSystem.out.println(flag==1 ? ans:\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\n\t\tnew AOJ0179();\n\n\n\t}\n\n\tclass AOJ0179{\n\t\tpublic AOJ0179() {\n\t\t\twhile(true){\n\t\t\t\tString warm = in.next();\n\t\t\t\tif(warm.equals(\"0\"))break;\n\t\t\t\tint ans = get_warm(warm);\n\t\t\t\tSystem.out.println(ans==-1? \"NA\":ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint get_warm(String input){\n\t\t\tQueue<String> warm = new LinkedList<String>();\n\t\t\tQueue<Integer> cnt = new LinkedList<Integer>();\n\t\t\tHashMap<String, Boolean> memo = new HashMap<String, Boolean>();\n\t\t\tmemo.put(input,true);\n\t\t\twarm.add(input);\n\t\t\tcnt.add(0);\n\t\t\twhile(warm.size()>0){\n\t\t\t\tString a = warm.remove();\n\t\t\t\tint step = cnt.remove();\n//\t\t\t\tSystem.out.println(a+\" \"+step);//deba\n\t\t\t\tboolean sw = true;\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1))sw=false;\n\t\t\t\tif(sw)return step;\n\t\t\t\t//ここから\n\t\t\t\tfor(int i=0;i<a.length()-1;i++)if(a.charAt(i)!=a.charAt(i+1)){\n\t\t\t\t\tString b = a.substring(0,i)+getColor(a.charAt(i),a.charAt(i+1))+a.substring(i+2,a.length());\n\t\t\t\t\tif(memo.containsKey(b))continue;\n\t\t\t\t\twarm.add(b);\n\t\t\t\t\tcnt.add(step+1);\n\t\t\t\t\tmemo.put(b, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString getColor(char a, char b){\n\t\t\tif(a=='r'&&b=='b'||a=='b'&&b=='r')return \"gg\";\n\t\t\telse if(a=='r'&&b=='g'||a=='g'&&b=='r')return \"bb\";\n\t\t\telse return \"rr\";\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    public static void main(String[] args) {\n    \tnew Main(); \n    }\n \n    public Main() {\n    \tnew aoj0179().doIt();\n    }\n    class aoj0179{\n    \tchar[] map;\n    \tint num = 100;\n    \tchar alf[] = {'r','b','g'};\n    \tvoid dfs(int cnt,int max){\n    \t\tif(cnt <= max+1){\n//    \t\t\tfor(int i = 0;i < max+1;i++)System.out.print(map[i]);\n//    \t\t\tSystem.out.println(\" \"+cnt);\n    \t\t\tint c = 0;\n    \t\t\tfor(int i = 0;i < max;i++){\n    \t\t\t\tif(map[i] == map[i+1])c++;\n    \t\t\t}\n    \t\t\tif(c == max)num = Math.min(num, cnt);\n    \t\t\telse if(cnt < num){\n    \t\t\t\tfor(int i = 0;i < max;i++){\n    \t\t\t\t\tfor(int j = 0;j < 3;j++){\n    \t\t\t\t\t\tfor(int k = 0;k < 3;k++){\n    \t\t\t\t\t\t\tif(j == k)continue;\n    \t\t\t\t\t\t\tif(map[i] == alf[j] && map[i+1] == alf[k]){\n    \t\t\t\t\t\t\t\tmap[i] = alf[3-(j+k)];map[i+1] = alf[3-(j+k)];\n    \t\t\t\t\t\t\t\tdfs(cnt+1,max);\n    \t\t\t\t\t\t\t\tmap[i] = alf[j];map[i+1] = alf[k];\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tnum = 100;\n    \t\t\tString str = sc.next();\t\n    \t\t\tif(str.equals(\"0\"))break;\n    \t\t\tchar ctr[] = str.toCharArray();\n    \t\t\tmap = new char [str.length()];\n    \t\t\tfor(int i = 0;i < str.length();i++)map[i] = ctr[i];\n    \t\t\tdfs(0,str.length()-1);\n    \t\t\tif(num == 100)System.out.println(num);\n    \t\t\telse System.out.println(\"NA\");\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static boolean isEnd (String str) {\n\t\treturn  (str.indexOf(\"r\") == -1 && str.indexOf(\"g\") == -1) ||\n\t\t\t\t(str.indexOf(\"r\") == -1 && str.indexOf(\"b\") == -1) ||\n\t\t\t\t(str.indexOf(\"g\") == -1 && str.indexOf(\"b\") == -1);\n\n\t}\n\n\tpublic static char getColor (char a, char b) {\n\n\t\tif ((a == 'r' && b == 'g') || a == 'g' && b == 'r') return 'b';\n\t\tif ((a == 'r' && b == 'b') || a == 'b' && b == 'r') return 'g';\n\t\treturn 'r';\n\n\t}\n\n\tpublic static String bfs (String str) {\n\n\t\tif (isEnd(str)) return \"0\";\n\n\t\tArrayList<String> pattern = new ArrayList<String>();\n\t\tArrayList<String> memo = new ArrayList<String>();\n\n\t\tint step = 1;\n\n\t\tpattern.add(str);\n\t\tmemo.add(str);\n\n\t\twhile (!pattern.isEmpty()) {\n\n\t\t\tArrayList<String> next = new ArrayList<String>();\n//\t\t\tSystem.out.println(step);\n\t\t\tfor (String p : pattern) {\n\t\t\t\tfor (int i = 1; i < p.length(); i++) {\n\t\t\t\t\tif (p.charAt(i - 1) != p.charAt(i)) {\n\t\t\t\t\t\tchar[] c = p.toCharArray();\n\t\t\t\t\t\tchar rep = getColor(p.charAt(i - 1), p.charAt(i));\n\t\t\t\t\t\tc[i - 1] = (c[i] = rep);\n\t\t\t\t\t\tif (isEnd(new String(c))) return \"\" + step;\n\t\t\t\t\t\tString rev = new StringBuffer(new String(c)).reverse().toString();\n\t\t\t\t\t\tif (!memo.contains(new String(c)) && !memo.contains(rev)) {\n//\t\t\t\t\t\t\tSystem.out.println(new String(c));\n\t\t\t\t\t\t\tmemo.add(new String(c));\n\t\t\t\t\t\t\tnext.add(new String(c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstep++;\n\t\t\tpattern = next;\n\t\t}\n\t\t\n//\t\tSystem.out.println(\"変化の総数 : \" + memo.size());\n\t\treturn \"NA\";\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tString str = sc.nextLine();\n\t\t\tif (str.equals(\"0\")) break;\n\t\t\tSystem.out.println(bfs(str));\n\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\t\tint ans=0;\n\t\t\tint flag=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tchar ch2[]=new char[10];\n\t\t\tque.add(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]==ch[j+1])\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tif(map.get(tmp)==null)\n\t\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t\tmap.put(tmp, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t\tif(ans>20)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(ans>20 ? \"NA\":ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n\n    void solve(){\n\tScanner kbd = new Scanner(System.in);\n\n\twhile(kbd.hasNext()){\n\t    String s = kbd.nextLine();\n\t    if(s.equals(\"0\")) break; \n\t    \n\t    //String[] pattern = new String[60000];\n\t    HashSet<String> set = new HashSet<String>();\n\t    int pcnt = 0;\n\t    //Stack stack = new Stack(s);\n\t    Queue<Worm> que = new LinkedList<Worm>();\n\t    que.add(new Worm(s, 0));\n\t    String a = s;\n\t    set.add(s);\n\t    //pattern[pcnt++] = a;\n\t    int t = 0;\n\t    while(!que.isEmpty() && !color(a)){\n\t\t//System.out.println(a+\" \"+color(a));\n\t\tWorm w = que.poll();\n\t\ta = w.getbody();\n\t\tt = w.getTime();\n\t\tfor(int i=0; i<a.length()-1; i++){\n\t\t    if(!a.substring(i, i+1).equals(a.substring(i+1, i+2))){\n\t\t\tString b = change(a, i, i+1);  \n\t\t\t/*\n\t\t\t  int j=0;\n\t\t\t  while(j<pcnt && !pattern[j].equals(b)) j++;\n\t\t\t  if(pattern[j]==null){\n\t\t\t  //System.out.println(b);\n\t\t\t  pattern[j] = b;\n\t\t\t  stack.in(b, t+1);\n\t\t\t  pcnt++;\n\t\t\t  }\n\t\t\t*/\n\t\t\tif(set.contains(b)) continue;\n\t\t\telse{\n\t\t\t    que.add(new Worm(b, t+1));\n\t\t\t    set.add(b);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if(color(a))\n\t\tSystem.out.println(t);\n\t    else\n\t\tSystem.out.println(\"NA\");\n\t}\n    }\n\n    boolean color(String x){\n\tString a = x.substring(0, 1);\n\tboolean ans = true;\n\tfor(int i=0; i<x.length(); i++){\n\t    String y = x.substring(i, i+1);\n\t    ans = ans && a.equals(y);\n\t}\n\treturn ans;\n    }\n\n    String change(String x, int s, int e){\n\tStringBuffer sb = new StringBuffer();\n\t//String ans = \"\";\n\tfor(int i=0; i<x.length(); i++){\n\t    if(i==s){\n\t\tString a = x.substring(i, i+1);\n\t\ti++;\n\t\tString b = x.substring(i, i+1);\n\t\ta = select(a, b);\n\t\tsb.append(a+a);\n\t    }\n\t    else{\n\t\tsb.append(x.substring(i, i+1));\n\t    }\n\t}\n\treturn sb.toString();\n    }\n\t\n    String select(String x, String y){\n\tif(x.equals(\"r\") || y.equals(\"r\")){\n\t    if(y.equals(\"b\") || x.equals(\"b\")){\n\t\treturn \"g\";\n\t    }\n\t    else return \"b\";\n\t}\n\telse return \"r\";\n    }\n}\n\n/*\nclass Stack {\n    Worm[] stack = new Worm[60000];\n    int sp;\n    int out;\n    public Stack(String s){\n\tsp = 0;\n\tout = 0;\n\tthis.in(s, 0);\n    }\n\n    public  void in(String s, int t){\n\tWorm w = new Worm(s, t);\n\tstack[sp++] = w;\n    }\n    public Worm pop(){\n\treturn stack[out++];\n    }\n    public boolean isEmpty(){\n\treturn sp==out;\n    }\n}\n*/\n\n class Worm{\n    String body;\n    int time;\n    public  Worm(String s, int t){\n\tbody = s;\n\ttime = t;\n    }\n    public  String getbody(){\n\treturn body;\n    }\n    public int getTime(){\n\treturn time;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass History {\n    private int wormHash;\n    private History prev;\n\n    public History(int wormHash, History prev) {\n        this.wormHash = wormHash;\n        this.prev = prev;\n    }\n\n    public int getStep() {\n        int count = 0;\n\n        History h = this;\n        while (h != null) {\n            count++;\n            h = h.prev;\n        }\n\n        return count;\n    }\n\n    public List<Integer> getStepList() {\n        List<Integer> stepList = new ArrayList<Integer>();\n        History h = this;\n\n        while (h != null) {\n            stepList.add(h.wormHash);\n            h = h.prev;\n        }\n\n        Collections.reverse(stepList);\n\n        return stepList;\n    }\n\n    public int getWormHash() {\n        return wormHash;\n    }\n}\n\npublic class Main {\n    private static final int R = 1;\n    private static final int G = 2;\n    private static final int B = 4;\n\n    private static final int ALL_COLOR = R | G | B;\n\n    private static Map<String, Integer> STR_TO_RGB = new HashMap<String, Integer>();\n    private static Map<Integer, String> RGB_TO_STR = new HashMap<Integer, String>();\n\n    static {\n        STR_TO_RGB.put(\"r\", R);\n        STR_TO_RGB.put(\"g\", G);\n        STR_TO_RGB.put(\"b\", B);\n\n        for (Map.Entry<String, Integer> e: STR_TO_RGB.entrySet()) {\n            RGB_TO_STR.put(e.getValue(), e.getKey());\n        }\n    }\n\n    private List<Integer> genWormFromString(String wormStr) {\n        List<Integer> worm = new ArrayList<Integer>();\n        for (char c: wormStr.toCharArray()) {\n            worm.add(STR_TO_RGB.get(c + \"\"));\n        }\n        return worm;\n    }\n\n    private int calcWormHash(List<Integer> worm) {\n        int hash = 0;\n\n        for (int w: worm) {\n            hash = (hash << 3) | w;\n        }\n\n        return hash;\n    }\n\n    private List<Integer> wormHashToWorm(int wormHash) {\n        List<Integer> worm = new ArrayList<Integer>();\n\n        while (wormHash > 0) {\n            worm.add(wormHash & ALL_COLOR);\n            wormHash = wormHash >> 3;\n        }\n\n        Collections.reverse(worm);\n\n        return worm;\n    }\n\n    private String dumpWrom(List<Integer> worm) {\n        StringBuilder sb = new StringBuilder();\n\n        for (int w: worm) {\n            sb.append(RGB_TO_STR.get(w));\n        }\n\n        return sb.toString();\n    }\n\n    private boolean isGoal(List<Integer> worm) {\n        int state = 0;\n\n        for (int w: worm) {\n            state |= w;\n        }\n\n        if (state == R || state == G || state == B) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private History solveHelper(String wormStr) {\n        int initialWormHash = calcWormHash(genWormFromString(wormStr));\n\n        Set<Integer> visited = new HashSet<Integer>();\n        visited.add(initialWormHash);\n\n        Queue<History> queue = new LinkedList<History>();\n        queue.add(new History(initialWormHash, null));\n\n        while (!queue.isEmpty()) {\n            History h = queue.poll();\n\n            List<Integer> worm = wormHashToWorm(h.getWormHash());\n            if (isGoal(worm)) {\n                return h;\n            } else {\n                for (int i = 0, j = 1; i < worm.size() - 1; i++, j++) {\n                    int iColor = worm.get(i);\n                    int jColor = worm.get(j);\n                    if (iColor != jColor) {\n                        int newColor = ALL_COLOR ^ (iColor | jColor);\n                        worm.set(i, newColor);\n                        worm.set(j, newColor);\n\n                        int wormHash = calcWormHash(worm);\n                        if (!visited.contains(wormHash)) {\n                            visited.add(wormHash);\n                            queue.add(new History(wormHash, h));\n                        }\n\n                        worm.set(i, iColor);\n                        worm.set(j, jColor);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private void printAnswer(List<Integer> stepList) {\n        for (int wormHash: stepList) {\n            List<Integer> worm = wormHashToWorm(wormHash);\n            System.out.println(dumpWrom(worm));\n        }\n    }\n\n    public void solve(String wormStr) {\n        History h = solveHelper(wormStr);\n\n        if (h == null) {\n            System.out.println(\"NA\");\n        } else {\n            int count = h.getStep() - 1;\n            //printAnswer(h.getStepList());\n            System.out.println(count);\n        }\n    }\n\n    public static void main(String[] args) {\n        Main solver = new Main();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String wormStr = scanner.nextLine();\n            if (!wormStr.equals(\"0\")) {\n                solver.solve(wormStr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.equals(\"0\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = s.length();\n\t\t\tint step = -1;\n\t\t\tboolean flag = false;\n\t\t\tLinkedList<String> list = new LinkedList<String>();\n\t\t\tLinkedList<String> next = new LinkedList<String>();\n\t\t\tHashSet<String> set = new HashSet<String>();\n\n\t\t\tlist.add(s);\n\n\t\t\twhile (!list.isEmpty() && !flag) {\n\t\t\t\tstep++;\n\t\t\t\tfor (String t: list) {\n\t\t\t\t\tif (!set.contains(t)) {\n\t\t\t\t\t\tset.add(t);\n\t\t\t\t\t\tchar bug[] = t.toCharArray();\n\t\t\t\t\t\tboolean b = true;\n\t\t\t\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\t\t\t\tif (bug[i] != bug[i + 1]) {\n\t\t\t\t\t\t\t\tb = false;\n\t\t\t\t\t\t\t\tchar le = bug[i];\n\t\t\t\t\t\t\t\tchar ri = bug[i + 1];\n\t\t\t\t\t\t\t\tchar an = le != 'r' && ri != 'r' ? 'r' : le != 'g' && ri != 'g' ? 'g' : 'b';\n\t\t\t\t\t\t\t\tbug[i] = an;\n\t\t\t\t\t\t\t\tbug[i + 1] = an;\n\t\t\t\t\t\t\t\tnext.add(new String(bug));\n\t\t\t\t\t\t\t\tbug[i] = le;\n\t\t\t\t\t\t\t\tbug[i + 1] = ri;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist = next;\n\t\t\t\tnext = new LinkedList<String>();\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? step : \"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tString st=in.next();\n\t\t\tif(st.equals(\"0\"))\n\t\t\t\treturn;\n\t\t\tLinkedList<String> que=new LinkedList<String>();\n\t\t\tint ans=0;\n\t\t\tint flag=0;\n\t\t\tchar ch[]=new char[10];\n\t\t\tque.push(st);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tch=que.poll().toCharArray();\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)//全ての色が同じかチェック\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ch[j]==ch[j+1])\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor(int j=0;j<ch.length-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar ch2[]=new char[ch.length];\n\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\tch2[k]=ch[k];\n\t\t\t\t\t\tif(ch[j]!=ch[j+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString tmp=\"\";\n\t\t\t\t\t\t\tif(ch2[j]!='r'&&ch2[j+1]!='r')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='r';\n\t\t\t\t\t\t\telse if(ch2[j]!='g'&&ch2[j+1]!='g')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='g';\n\t\t\t\t\t\t\telse if(ch2[j]!='b'&&ch2[j+1]!='b')\n\t\t\t\t\t\t\t\tch2[j]=ch2[j+1]='b';\n\t\t\t\t\t\t\tfor(int k=0;k<ch.length;k++)\n\t\t\t\t\t\t\t\ttmp+=ch2[k];\n\t\t\t\t\t\t\tque.add(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==1)\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t\t//System.out.println(ans);\n\t\t\t\tif(ans>8)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(ans>8? \"NA\":ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tclass C {\n\t\tint sec;\n\t\tString color;\n\t\tpublic C(int sec, String color) {\n\t\t\tthis.sec = sec;\n\t\t\tthis.color = color;\n\t\t}\n\t\t\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str = sc.next();\n\t\t\tif(str.equals(\"0\"))\n\t\t\t\tbreak;\n\t\t\t//create a goal\n\t\t\tint len = str.length();\n\t\t\tchar [] c = new char[len];\n\t\t\tString [] goal = new String[3];\n\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\tc[i] = 'r';\n\t\t\t}\n\t\t\tgoal[0] = new String(c);\n\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\tc[i] = 'g';\n\t\t\t}\n\t\t\tgoal[1] = new String(c);\n\t\t\tfor(int i=0; i < len; i++){\n\t\t\t\tc[i] = 'b';\n\t\t\t}\n\t\t\tgoal[2] = new String(c);\n\t\t\t//sum of color\n\t\t\tchar sumColor = 'r' + 'g' + 'b';\n\t\t\t\n\t\t\t//create a open\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\t//create a close\n\t\t\tTreeSet<String> close = new TreeSet<String>();\n\t\t\t\n\t\t\t//set start point\n\t\t\tC startObj = new C(0, str);\n\t\t\topen.add(startObj);\n\t\t\tclose.add(str);\n\t\t\t\n\t\t\tboolean flg = false;\n\t\t\t\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\t//pop a first obj\n\t\t\t\tint nowCost = open.getFirst().sec;\n\t\t\t\tString nowColor = open.getFirst().color;\n\t\t\t\topen.removeFirst();\n\t\t\t\t\n\t\t\t\tfor(int i=0; i < 3; i++){\n\t\t\t\t\tif(nowColor.equals(goal[i])){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tSystem.out.println(nowCost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//get change way\n\t\t\t\tfor(int i=0; i < nowColor.length() - 1 ; i++){\n\t\t\t\t\tchar now = nowColor.charAt(i);\n\t\t\t\t\tchar next = nowColor.charAt(i+1);\n\t\t\t\t\tif(now != next){\n\t\t\t\t\t\t//find a diff color\n\t\t\t\t\t\tchar diffColor =  (char) (sumColor - now - next);\n\t\t\t\t\t\t//set a color\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder(nowColor);\n\t\t\t\t\t\tsb.setCharAt(i, diffColor);\n\t\t\t\t\t\tsb.setCharAt(i+1, diffColor);\n\t\t\t\t\t\tString newColor = sb.toString();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!close.contains(newColor)){\n\t\t\t\t\t\t\t//add a open\n\t\t\t\t\t\t\topen.addLast(new C(nowCost + 1, newColor));\n\t\t\t\t\t\t\tclose.add(newColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\t\n\t\t\t\n\t\t\tif(!flg){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run(){\n\t\tchar[] wormcolor;\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\twormcolor = sc.next().toCharArray();\n\t\t\tif(wormcolor.equals(\"0\")){\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t\tSystem.out.println(BFS(wormcolor));\n\t\t}\n\t}\n\n\tString BFS(char[] wc){\n\t\tHashSet<String> used = new HashSet<String>();\n\t\tQueue<Worm> q = new LinkedList<Worm>();\n\t\tWorm wm = new Worm(wc, 0);\n\t\tq.add(wm);\n\t\twhile(!q.isEmpty()){\n\t\t\tWorm cur = q.poll();\n\t\t\tif(cur.isSameColor()){\n\t\t\t\treturn cur.getDepth()+\"\";\n\t\t\t}\n\t\t\tif(used.contains(String.valueOf(cur.getColor()))){\n\t\t\t\t//System.out.println(\"here\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tSystem.out.println(cur.depth + \":\");\n\t\t\tfor(String c: used){\n\t\t\t\tSystem.out.println(c);\n\t\t\t}\n\t\t\t*/\n\t\t\tused.add(String.valueOf(cur.getColor()));\n\t\t\tfor(Worm nw: cur.getNext()){\n\t\t\t\tq.add(nw);\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n}\n\nclass Worm{\n\tchar[] color;\n\tint depth;\n\tHashMap<String,Character> table = new HashMap<String,Character>(); \n\tpublic Worm(char[] color, int depth){\n\t\tthis.color = color;\n\t\tthis.depth = depth;\n\t\ttable.put(\"rg\",'b'); table.put(\"gr\",'b');\n\t\ttable.put(\"rb\",'g'); table.put(\"br\",'g');\n\t\ttable.put(\"gb\",'r'); table.put(\"bg\",'r');\n\t}\n\n\tboolean isSameColor(){\n\t\tfor(int i=0; i < color.length - 1; i++){\n\t\t\tif(color[i] != color[i+1]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic int getDepth(){\n\t\treturn depth;\n\t}\n\n\tpublic char[] getColor() {\n\t\treturn color;\n\t}\n\n\tpublic ArrayList<Worm> getNext(){\n\t\tArrayList<Worm> result = new ArrayList<Worm>();\n\t\tfor(int i = 0; i < color.length - 1; i++){\n\t\t\tif(color[i] == color[i+1]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar[] cp = Arrays.copyOf(color, color.length);\n\t\t\tcp[i] = table.get(String.valueOf(color[i]) + color[i+1]);\n\t\t\tcp[i+1] = table.get(\"\" + color[i] + color[i+1]);\n\t\t\tresult.add(new Worm(cp, depth+1));\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass History {\n    private int wormHash;\n    private History prev;\n\n    public History(int wormHash, History prev) {\n        this.wormHash = wormHash;\n        this.prev = prev;\n    }\n\n    public int getStep() {\n        int count = 0;\n\n        History h = this;\n        while (h != null) {\n            count++;\n            h = h.prev;\n        }\n\n        return count;\n    }\n\n    public List<Integer> getStepList() {\n        List<Integer> stepList = new ArrayList<Integer>();\n        History h = this;\n\n        while (h != null) {\n            stepList.add(h.wormHash);\n            h = h.prev;\n        }\n\n        Collections.reverse(stepList);\n\n        return stepList;\n    }\n\n    public int getWormHash() {\n        return wormHash;\n    }\n}\n\npublic class Main {\n    private static final int R = 1;\n    private static final int G = 2;\n    private static final int B = 4;\n\n    private static final int ALL_COLOR = R | G | B;\n\n    private static Map<String, Integer> STR_TO_RGB = new HashMap<String, Integer>();\n    private static Map<Integer, String> RGB_TO_STR = new HashMap<Integer, String>();\n\n    static {\n        STR_TO_RGB.put(\"r\", R);\n        STR_TO_RGB.put(\"g\", G);\n        STR_TO_RGB.put(\"b\", B);\n\n        for (Map.Entry<String, Integer> e: STR_TO_RGB.entrySet()) {\n            RGB_TO_STR.put(e.getValue(), e.getKey());\n        }\n    }\n\n    private List<Integer> genWormFromString(String wormStr) {\n        List<Integer> worm = new ArrayList<Integer>();\n        for (char c: wormStr.toCharArray()) {\n            worm.add(STR_TO_RGB.get(c + \"\"));\n        }\n        return worm;\n    }\n\n    private int calcWormHash(List<Integer> worm) {\n        int hash = 0;\n\n        for (int w: worm) {\n            hash = (hash << 3) | w;\n        }\n\n        return hash;\n    }\n\n    private List<Integer> wormHashToWorm(int wormHash) {\n        List<Integer> worm = new ArrayList<Integer>();\n\n        while (wormHash > 0) {\n            worm.add(0, wormHash & ALL_COLOR);\n            wormHash = wormHash >> 3;\n        }\n\n        return worm;\n    }\n\n    private String dumpWrom(List<Integer> worm) {\n        StringBuilder sb = new StringBuilder();\n\n        for (int w: worm) {\n            sb.append(RGB_TO_STR.get(w));\n        }\n\n        return sb.toString();\n    }\n\n    private boolean isGoal(List<Integer> worm) {\n        int state = 0;\n\n        for (int w: worm) {\n            state |= w;\n        }\n\n        if (state == R || state == G || state == B) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private History solveHelper(String wormStr) {\n        int initialWormHash = calcWormHash(genWormFromString(wormStr));\n\n        Set<Integer> visited = new HashSet<Integer>();\n        visited.add(initialWormHash);\n\n        Queue<History> queue = new LinkedList<History>();\n        queue.add(new History(initialWormHash, null));\n\n        while (!queue.isEmpty()) {\n            History h = queue.poll();\n\n            List<Integer> worm = wormHashToWorm(h.getWormHash());\n            if (isGoal(worm)) {\n                return h;\n            } else {\n                for (int i = 0, j = 1; i < worm.size() - 1; i++, j++) {\n                    int iColor = worm.get(i);\n                    int jColor = worm.get(j);\n                    if (iColor != jColor) {\n                        int newColor = ALL_COLOR ^ (iColor | jColor);\n                        worm.set(i, newColor);\n                        worm.set(j, newColor);\n\n                        int wormHash = calcWormHash(worm);\n                        if (!visited.contains(wormHash)) {\n                            visited.add(wormHash);\n                            queue.add(new History(wormHash, h));\n                        }\n\n                        worm.set(i, iColor);\n                        worm.set(j, jColor);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private void printAnswer(List<Integer> stepList) {\n        for (int wormHash: stepList) {\n            List<Integer> worm = wormHashToWorm(wormHash);\n            System.out.println(dumpWrom(worm));\n        }\n    }\n\n    public void solve(String wormStr) {\n        History h = solveHelper(wormStr);\n\n        if (h == null) {\n            System.out.println(\"NA\");\n        } else {\n            int count = h.getStep() - 1;\n            //printAnswer(h.getStepList());\n            System.out.println(count);\n        }\n    }\n\n    public static void main(String[] args) {\n        Main solver = new Main();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String wormStr = scanner.nextLine();\n            if (!wormStr.equals(\"0\")) {\n                solver.solve(wormStr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(char[]x,y;(x=s.next().toCharArray())[0]!='0';){Deque<char[]>q=new ArrayDeque<char[]>();Deque<Long>c=new ArrayDeque<Long>();Set<String>e=new HashSet<String>();for(q.add(x),c.add(0L);q.size()>0;c.poll()){if(new HashSet<String>(Arrays.asList(new String(x=q.poll()).split(\"\"))).size()<3)break;if(e.add(new String(x)))for(int i=0,t;i<x.length-1;++i)if(x[i]!=x[i+1]){(y=x.clone())[i]=y[i+1]=(t=x[i]+x[i+1])==201?'r':t==212?'g':'b';q.add(y.clone());c.add(c.peek()+1);}}System.out.println(c.size()<1?\"NA\":c.poll());}}}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = scanner.next();\n\t\t\tif (line.equals(\"0\"))\n\t\t\t\tbreak;\n\t\t\tPattern pattern = Pattern.compile(\"^r+$|^g+$|^b+$\");\n\t\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.offer(line);\n\t\t\tboolean flag = false;\n\t\t\tint step = 0;\n\t\t\tloop: while (!deque.isEmpty()) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tString tmp = deque.pop();\n\t\t\t\t\tif (pattern.matcher(tmp).find()) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\tchar[] chs = tmp.toCharArray();\n\t\t\t\t\t\tfor (int j = 0; j < chs.length - 1; j++) {\n\t\t\t\t\t\t\tchar l = chs[j];\n\t\t\t\t\t\t\tchar r = chs[j + 1];\n\t\t\t\t\t\t\tif (l != r) {\n\t\t\t\t\t\t\t\tchar[] tmpchs = Arrays.copyOf(chs, chs.length);\n\t\t\t\t\t\t\t\tif (l != 'r' && r != 'r')\n\t\t\t\t\t\t\t\t\ttmpchs[j] = tmpchs[j + 1] = 'r';\n\t\t\t\t\t\t\t\telse if (l != 'g' && r != 'g')\n\t\t\t\t\t\t\t\t\ttmpchs[j] = tmpchs[j + 1] = 'g';\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ttmpchs[j] = tmpchs[j + 1] = 'b';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdeque.offer(String.valueOf(tmpchs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tset.add(tmp);\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? step : \"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\n\nnamespace Test1 {\n\n\n\n\n\n    class ClassMain {\n\n        public static Dictionary<string, int> worm4 = new Dictionary<string, int>();\n\n        public static void initWorm4() {\n            worm4.Add(\"rrrr\", 0);\n            worm4.Add(\"gggg\", 0);\n            worm4.Add(\"bbbb\", 0);\n            worm4.Add(\"rrrrr\", 0);\n            worm4.Add(\"ggggg\", 0);\n            worm4.Add(\"bbbbb\", 0);\n            worm4.Add(\"rrrrrr\", 0);\n            worm4.Add(\"gggggg\", 0);\n            worm4.Add(\"bbbbbb\", 0);\n            worm4.Add(\"rrrrrrr\", 0);//7\n            worm4.Add(\"ggggggg\", 0);\n            worm4.Add(\"bbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrr\", 0);//8\n            worm4.Add(\"gggggggg\", 0);\n            worm4.Add(\"bbbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrrr\", 0);//9\n            worm4.Add(\"ggggggggg\", 0);\n            worm4.Add(\"bbbbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrrrr\", 0);//10\n            worm4.Add(\"gggggggggg\", 0);\n            worm4.Add(\"bbbbbbbbbb\", 0);\n            Queue<string> wormsChale = new Queue<string>();\n            wormsChale.Enqueue(\"rrrr\");\n            wormsChale.Enqueue(\"gggg\");\n            wormsChale.Enqueue(\"bbbb\");\n            wormsChale.Enqueue(\"rrrrr\");\n            wormsChale.Enqueue(\"ggggg\");\n            wormsChale.Enqueue(\"bbbbb\");\n            wormsChale.Enqueue(\"rrrrrr\");\n            wormsChale.Enqueue(\"gggggg\");\n            wormsChale.Enqueue(\"bbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrr\");//7\n            wormsChale.Enqueue(\"ggggggg\");\n            wormsChale.Enqueue(\"bbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrr\");//8\n            wormsChale.Enqueue(\"gggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrrr\");//9\n            wormsChale.Enqueue(\"ggggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrrrr\");//10\n            wormsChale.Enqueue(\"gggggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbbbb\");\n            while (wormsChale.Count != 0) {\n                string aworm = wormsChale.Dequeue();\n                //Console.WriteLine(wormsChale.Count + aworm);\n                int count = worm4[aworm];\n                //transform\n                char[] wormChrs = aworm.ToCharArray(); \n                for (int i = 0; i < aworm.Length-1; i++) {\n                    if (wormChrs[i] == wormChrs[i + 1]) {\n                        char col = wormChrs[i];\n                        char[] copyW1 = new char[aworm.Length];\n                        char[] copyW2 = new char[aworm.Length];\n                        Array.Copy(wormChrs, copyW1, aworm.Length);\n                        Array.Copy(wormChrs, copyW2, aworm.Length);\n                        if (col == 'r') {\n                            copyW1[i] = 'g'; copyW1[i + 1] = 'b';\n                            copyW2[i] = 'b'; copyW2[i + 1] = 'g';\n                        }else if (col == 'g') {\n                            copyW1[i] = 'r'; copyW1[i + 1] = 'b';\n                            copyW2[i] = 'b'; copyW2[i + 1] = 'r';\n                        }else if (col == 'b') {\n                            copyW1[i] = 'g'; copyW1[i + 1] = 'r';\n                            copyW2[i] = 'r'; copyW2[i + 1] = 'g';\n                        }\n                        //Info add.\n                        string w1 = new string(copyW1);\n                        string w2 = new string(copyW2);\n                        //Console.WriteLine(w1 + \",\" + w2);\n                        if (worm4.ContainsKey(w1) == false) {\n                            worm4.Add(w1, count + 1);\n                            wormsChale.Enqueue(w1);\n                        }\n                        if (worm4.ContainsKey(w2) == false) {\n                            worm4.Add(w2, count + 1);\n                            wormsChale.Enqueue(w2);\n                        }\n                    }\n                }//end transform.            \n            }//end dequeue worms.        \n        }\n        \n\n\n        public static void Main(String[] args) {\n            string line;\n            initWorm4();\n            while ((line = Console.ReadLine()) != null) {\n                if (line == \"0\") { break; }\n                if (line.Length == 2) {\n                    if (line.Equals(\"rr\") || line.Equals(\"gg\") || line.Equals(\"bb\")) {\n                        Console.WriteLine(0);\n                    }\n                    else {\n                        Console.WriteLine(\"NA\");\n                    }\n                }\n                else if (line.Length == 3) {\n                    if (line.Equals(\"rrr\") || line.Equals(\"ggg\") || line.Equals(\"bbb\")) {\n                        Console.WriteLine(0);\n                    }\n                    else if (line.Equals(\"rgb\") || line.Equals(\"rbg\") || line.Equals(\"grb\")\n                        || line.Equals(\"gbr\") || line.Equals(\"brg\") || line.Equals(\"bgr\")) {\n                        Console.WriteLine(1);\n                    }\n                    else {\n                        Console.WriteLine(\"NA\");\n                    }\n                }\n                else {// len 4.\n                    if (worm4.ContainsKey(line) == false) {\n                        Console.WriteLine(\"NA\");\n                    }\n                    else {\n                        Console.WriteLine(worm4[line]);\n                    }\n                }\n        \n\n\n            }\n        }\n    \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    // 状態のリスト\n    static Dictionary<string, State> states = new Dictionary<string, State>();\n    // 辿っているQueue\n    static Queue<State> queue = new Queue<State>();\n\n\tpublic static int ToInt(char self)\n    {\n        return self - '0';\n    }\n\n    class State\n    {\n    \tpublic int dist = -1;\n    \tpublic string str = \"\";\n    \tpublic List<string> adjacentStrs = new List<string>();\n    \tpublic State(string str)\n    \t{\n    \t\tthis.str = str;\n    \t\tfor (int i = 0; i < str.Length - 1; i++)\n    \t\t{\n    \t\t\tstring adjacentStr = \"\";\n    \t\t\tint changed = (6 - ToInt(str[i]) - ToInt(str[i+1])) % 3;\n    \t\t\tfor (int j = 0; j < str.Length; j++)\n    \t\t\t{\n    \t\t\t\tif (j == i || j == i + 1)\n    \t\t\t\t{\n    \t\t\t\t\tadjacentStr += changed.ToString();\n    \t\t\t\t}\n    \t\t\t\telse\n    \t\t\t\t{\n\t\t\t\t\t\tadjacentStr += str[j].ToString();\n    \t\t\t\t}\n    \t\t\t}\n\t\t\t\tthis.adjacentStrs.Add(adjacentStr);\n    \t\t}\n    \t}\n    }\n\n    // メイン\n    static void Main(string[] args)\n    {\n    \tvar input = \"0\";\n    \twhile ((input = Console.ReadLine()) != \"0\")\n    \t{\n    \t\tstates.Clear();\n    \t\tqueue.Clear();\n    \t\tState start = new State(ConvertInput(input));\n    \t\tstates.Add(start.str, start);\n        \tBfs(start);\n    \t}\n    }\n\n    // 幅優先探索\n    static void Bfs(State start)\n    {\n    \tstart.dist = 0;\n    \tqueue.Enqueue(start);\n    \twhile (queue.Count() > 0)\n    \t{\n    \t\tState state = queue.Dequeue();\n    \t\tif (CheckIdEnd(state.str))\n    \t\t{\n    \t\t\tSystem.Console.WriteLine(state.dist);\n    \t\t\treturn;\n    \t\t}\n    \t\tforeach (var str in state.adjacentStrs)\n    \t\t{\n    \t\t\tif (!states.ContainsKey(str))\n    \t\t\t{\n    \t\t\t\tState adjacentState = new State(str);\n    \t\t\t\tadjacentState.dist = state.dist + 1;\n    \t\t\t\tstates.Add(str, adjacentState);\n    \t\t\t\tqueue.Enqueue(adjacentState);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tSystem.Console.WriteLine(\"NA\");\n\t}\n\n\tstatic string ConvertInput(string input)\n\t{\n\t\tstring converted = \"\";\n    \tforeach (char s in input)\n\t\t{\n\t\t\tswitch (s)\n\t\t\t{\n\t\t\t\tcase 'r':\n\t\t\t\t\tconverted += \"0\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\tconverted += \"1\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tconverted += \"2\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn converted;\n\t}\n\n\tstatic bool CheckIdEnd(string str)\n\t{\n\t\tchar prevNum = str[0];\n\t\tforeach (char num in str)\n\t\t{\t\n\t\t\tif (prevNum != num)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tprevNum = num;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\n\nnamespace Test1 {\n\n\n\n\n\n    class ClassMain {\n\n        public static Dictionary<string, int> worm4 = new Dictionary<string, int>();\n\n        public static void initWorm4() {\n            worm4.Add(\"rrrr\", 0);\n            worm4.Add(\"gggg\", 0);\n            worm4.Add(\"bbbb\", 0);\n            worm4.Add(\"rrrrr\", 0);\n            worm4.Add(\"ggggg\", 0);\n            worm4.Add(\"bbbbb\", 0);\n            worm4.Add(\"rrrrrr\", 0);\n            worm4.Add(\"gggggg\", 0);\n            worm4.Add(\"bbbbbb\", 0);\n            worm4.Add(\"rrrrrrr\", 0);//7\n            worm4.Add(\"ggggggg\", 0);\n            worm4.Add(\"bbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrr\", 0);//8\n            worm4.Add(\"gggggggg\", 0);\n            worm4.Add(\"bbbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrrr\", 0);//9\n            worm4.Add(\"ggggggggg\", 0);\n            worm4.Add(\"bbbbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrrrr\", 0);//10\n            worm4.Add(\"gggggggggg\", 0);\n            worm4.Add(\"bbbbbbbbbb\", 0);\n            Queue<string> wormsChale = new Queue<string>();\n            wormsChale.Enqueue(\"rrrr\");\n            wormsChale.Enqueue(\"gggg\");\n            wormsChale.Enqueue(\"bbbb\");\n            wormsChale.Enqueue(\"rrrrr\");\n            wormsChale.Enqueue(\"ggggg\");\n            wormsChale.Enqueue(\"bbbbb\");\n            wormsChale.Enqueue(\"rrrrrr\");\n            wormsChale.Enqueue(\"gggggg\");\n            wormsChale.Enqueue(\"bbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrr\");//7\n            wormsChale.Enqueue(\"ggggggg\");\n            wormsChale.Enqueue(\"bbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrr\");//8\n            wormsChale.Enqueue(\"gggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrrr\");//9\n            wormsChale.Enqueue(\"ggggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrrrr\");//10\n            wormsChale.Enqueue(\"gggggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbbbb\");\n            while (wormsChale.Count != 0) {\n                string aworm = wormsChale.Dequeue();\n                //Console.WriteLine(wormsChale.Count + aworm);\n                int count = worm4[aworm];\n                //transform\n                char[] wormChrs = aworm.ToCharArray(); \n                for (int i = 0; i < aworm.Length-1; i++) {\n                    if (wormChrs[i] == wormChrs[i + 1]) {\n                        char col = wormChrs[i];\n                        char[] copyW1 = new char[aworm.Length];\n                        char[] copyW2 = new char[aworm.Length];\n                        Array.Copy(wormChrs, copyW1, aworm.Length);\n                        Array.Copy(wormChrs, copyW2, aworm.Length);\n                        if (col == 'r') {\n                            copyW1[i] = 'g'; copyW1[i + 1] = 'b';\n                            copyW2[i] = 'b'; copyW2[i + 1] = 'g';\n                        }else if (col == 'g') {\n                            copyW1[i] = 'r'; copyW1[i + 1] = 'b';\n                            copyW2[i] = 'b'; copyW2[i + 1] = 'r';\n                        }else if (col == 'b') {\n                            copyW1[i] = 'g'; copyW1[i + 1] = 'r';\n                            copyW2[i] = 'r'; copyW2[i + 1] = 'g';\n                        }\n                        //Info add.\n                        string w1 = new string(copyW1);\n                        string w2 = new string(copyW2);\n                        //Console.WriteLine(w1 + \",\" + w2);\n                        if (worm4.ContainsKey(w1) == false) {\n                            worm4.Add(w1, count + 1);\n                            wormsChale.Enqueue(w1);\n                        }\n                        if (worm4.ContainsKey(w2) == false) {\n                            worm4.Add(w2, count + 1);\n                            wormsChale.Enqueue(w2);\n                        }\n                    }\n                }//end transform.            \n            }//end dequeue worms.        \n        }\n        \n\n\n        public static void Main(String[] args) {\n            string line;\n            initWorm4();\n            while ((line = Console.ReadLine()) != null) {\n                if (line == \"0\") { break; }\n                if (line.Length == 2) {\n                    if (line.Equals(\"rr\") || line.Equals(\"gg\") || line.Equals(\"bb\")) {\n                        Console.WriteLine(0);\n                    }\n                    else {\n                        Console.WriteLine(\"NA\");\n                    }\n                }\n                else if (line.Length == 3) {\n                    if (line.Equals(\"rrr\") || line.Equals(\"ggg\") || line.Equals(\"bbb\")) {\n                        Console.WriteLine(0);\n                    }\n                    else if (line.Equals(\"rgb\") || line.Equals(\"rbg\") || line.Equals(\"grb\")\n                        || line.Equals(\"gbr\") || line.Equals(\"brg\") || line.Equals(\"bgr\")) {\n                        Console.WriteLine(1);\n                    }\n                    else {\n                        Console.WriteLine(\"NA\");\n                    }\n                }\n                else {// len 4.\n                    if (worm4.ContainsKey(line) == false) {\n                        Console.WriteLine(\"NA\");\n                    }\n                    else {\n                        Console.WriteLine(worm4[line]);\n                    }\n                }\n        \n\n\n            }\n        }\n    \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    // 状態のリスト\n    static Dictionary<string, State> states = new Dictionary<string, State>();\n    // 辿っているQueue\n    static Queue<State> queue = new Queue<State>();\n\n\tpublic static int ToInt(char self)\n    {\n        return self - '0';\n    }\n\n    class State\n    {\n    \tpublic int dist = -1;\n    \tpublic string str = \"\";\n    \tpublic List<string> adjacentStrs = new List<string>();\n    \tpublic State(string str)\n    \t{\n    \t\tforeach (char s in str)\n    \t\t{\n    \t\t\tswitch (s)\n    \t\t\t{\n    \t\t\t\tcase 'r':\n    \t\t\t\t\tstr += \"0\";\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase 'g':\n    \t\t\t\t\tstr += \"1\";\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase 'b':\n    \t\t\t\t\tstr += \"2\";\n    \t\t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tfor (int i = 0; i < str.Length - 1; i++)\n    \t\t{\n    \t\t\tstring adjacentStr = \"\";\n    \t\t\tint changed = (ToInt(str[i]) + ToInt(str[i+1])) % 3;\n    \t\t\tfor (int j = 0; j < str.Length; j++)\n    \t\t\t{\n    \t\t\t\tif (j == i || j == i + 1)\n    \t\t\t\t{\n    \t\t\t\t\tadjacentStr += changed.ToString();\n    \t\t\t\t}\n    \t\t\t\telse\n    \t\t\t\t{\n\t\t\t\t\t\tadjacentStr += str[i].ToString();\n    \t\t\t\t}\n    \t\t\t}\n\t\t\t\tthis.adjacentStrs.Add(adjacentStr);\n    \t\t}\n    \t}\n    }\n\n    // メイン\n    static void Main(string[] args)\n    {\n    \tvar input = \"0\";\n    \twhile ((input = Console.ReadLine()) != \"0\")\n    \t{\n    \t\tstates.Clear();\n    \t\tqueue.Clear();\n        \tBfs(new State(input));\n    \t}\n    }\n\n    // 幅優先探索\n    static void Bfs(State start)\n    {\n    \tstart.dist = 0;\n    \tqueue.Enqueue(start);\n    \twhile (queue.Count() > 0)\n    \t{\n    \t\tState state = queue.Dequeue();\n    \t\tif (CheckIdEnd(state.str))\n    \t\t{\n    \t\t\tSystem.Console.WriteLine(state.dist + 1);\n    \t\t\treturn;\n    \t\t}\n    \t\tforeach (var str in state.adjacentStrs)\n    \t\t{\n    \t\t\tif (!states.ContainsKey(str))\n    \t\t\t{\n    \t\t\t\tState adjacentState = new State(str);\n    \t\t\t\tadjacentState.dist = state.dist + 1;\n    \t\t\t\tstates.Add(str, adjacentState);\n    \t\t\t\tqueue.Enqueue(states[str]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tSystem.Console.WriteLine(\"NA\");\n\t}\n\n\tstatic bool CheckIdEnd(string str)\n\t{\n\t\tchar prevNum = str[0];\n\t\tforeach (char num in str)\n\t\t{\n\t\t\tif (prevNum != num)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tprevNum = num;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0179\n{\n    public class Program\n\n    {\n        public static HashSet<char> colors = new HashSet<char>() { 'r', 'g', 'b' };\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                string line = RSt();\n                if (line == \"0\") break;\n\n                Console.WriteLine(GetSameSteps(line));\n            }\n\n        }\n\n        private static string GetSameSteps(string line)\n        {\n\n            Dictionary<string, int> dic = new Dictionary<string, int>();\n            Queue<string> q = new Queue<string>();\n\n            dic.Add(line, 0);\n            q.Enqueue(line);\n\n            while (q.Count() > 0)\n            {\n                string cur = q.Dequeue();\n\n                if (isAllSame(cur))\n                {\n                    return dic[cur].ToString();\n                }\n\n                for (int i = 0 ; i < cur.Length - 1 ; i++)\n                {\n                    if (cur[i] != cur[i + 1])\n                    {\n                        char[] tmp = cur.ToCharArray();\n                        tmp[i] = colors.Except(new char[] { cur[i], cur[i + 1] }).First();\n                        tmp[i + 1] = tmp[i];\n\n                        string next = string.Join(\"\", tmp);\n                        if (!dic.ContainsKey(next))\n                        {\n                            dic.Add(next, dic[cur] + 1);\n                            q.Enqueue(next);\n                        }\n                    }\n                }\n            }\n\n            return \"NA\";\n        }\n\n        private static bool isAllSame(string cur)\n        {\n            foreach (var color in colors) if (cur.All(x => x == color)) return true;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    // 状態のリスト\n    static Dictionary<string, State> states = new Dictionary<string, State>();\n    // 辿っているQueue\n    static Queue<State> queue = new Queue<State>();\n\n    class State\n    {\n    \tpublic int dist = -1;\n    \tpublic string str = \"\";\n    \tpublic List<string> adjacentStrs = new List<string>();\n    \tpublic State(string str)\n    \t{\n    \t\tforeach (char s in str)\n    \t\t{\n    \t\t\tswitch (s)\n    \t\t\t{\n    \t\t\t\tcase 'r':\n    \t\t\t\t\tstr += \"0\";\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase 'g':\n    \t\t\t\t\tstr += \"1\";\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase 'b':\n    \t\t\t\t\tstr += \"2\";\n    \t\t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tfor (int i = 0; i < str.Length - 1; i++)\n    \t\t{\n    \t\t\tstring adjacentStr = \"\";\n    \t\t\tint changed = (int.Parse(str[i].ToString()) + int.Parse(str.ToString())) % 3;\n    \t\t\tfor (int j = 0; j < str.Length; j++)\n    \t\t\t{\n    \t\t\t\tif (j == i || j == i + 1)\n    \t\t\t\t{\n    \t\t\t\t\tadjacentStr += changed.ToString();\n    \t\t\t\t}\n    \t\t\t\telse\n    \t\t\t\t{\n\t\t\t\t\t\tadjacentStr += str[i].ToString();\n    \t\t\t\t}\n    \t\t\t}\n\t\t\t\tthis.adjacentStrs.Add(adjacentStr);\n    \t\t}\n    \t}\n    }\n\n    // メイン\n    static void Main(string[] args)\n    {\n    \tvar input = \"0\";\n    \twhile ((input = Console.ReadLine()) != \"0\")\n    \t{\n    \t\tstates.Clear();\n    \t\tqueue.Clear();\n        \tBfs(new State(input));\n    \t}\n    }\n\n    // 幅優先探索\n    static void Bfs(State start)\n    {\n    \tstart.dist = 0;\n    \tqueue.Enqueue(start);\n    \twhile (queue.Count() > 0)\n    \t{\n    \t\tState state = queue.Dequeue();\n    \t\tif (CheckIdEnd(state.str))\n    \t\t{\n    \t\t\tSystem.Console.WriteLine(state.dist + 1);\n    \t\t\treturn;\n    \t\t}\n    \t\tforeach (var str in state.adjacentStrs)\n    \t\t{\n    \t\t\tif (!states.ContainsKey(str))\n    \t\t\t{\n    \t\t\t\tState adjacentState = new State(str);\n    \t\t\t\tadjacentState.dist = state.dist + 1;\n    \t\t\t\tstates.Add(str, adjacentState);\n    \t\t\t\tqueue.Enqueue(states[str]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tSystem.Console.WriteLine(\"NA\");\n\t}\n\n\tstatic bool CheckIdEnd(string str)\n\t{\n\t\tint prevNum = str[0];\n\t\tforeach (var num in str)\n\t\t{\n\t\t\tif (prevNum != num)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tprevNum = num;\n\t\t}\n\t\treturn true;\n\t}\t\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var d = new Dictionary<string, int>();\n            var q = new Queue<string>();\n            var s = Console.ReadLine().Trim();\n            if (s == \"0\") break;\n            var sL = s.Length;\n            if (IsSame(s)) { Console.WriteLine(0); goto next; }\n            q.Enqueue(s); d[s] = 1;\n            Console.WriteLine(goBfs(d, q, sL));\n            next:;\n        }\n    }\n    public static string goBfs(Dictionary<string, int> d, Queue<string> q, int sL)\n    {\n        while (true)\n        {\n            if (q.Count() == 0) return \"NA\";\n            var s = q.Dequeue();\n            var count = d[s];\n            for (int i = 0; i <= sL - 2; i++)\n            {\n                var ss = s.Substring(i, 2);\n                if (ss[0] != ss[1])\n                {\n                    var ta = changeColor(s, i, ss);\n                    if (IsSame(ta)) return count.ToString();\n                    if (!d.ContainsKey(ta)) { d[ta] = count + 1; q.Enqueue(ta); }\n                }\n            }\n        }\n    }\n    public static bool IsSame(string s)\n    {\n        var c = new string[] { \"r\", \"g\", \"b\" };\n        foreach (var x in c)\n            if (s.Replace(x, \"\").Length == 0) return true;\n        return false;\n    }\n    public static string changeColor(string s, int i, string t)\n    {\n        string a;\n        if (t == \"rg\" | t == \"gr\") a = \"bb\";\n        else if (t == \"gb\" | t == \"bg\") a = \"rr\";\n        else a = \"gg\";\n        return s.Substring(0, i) + a + s.Substring(i + 2);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    // 状態のリスト\n    static Dictionary<string, State> states = new Dictionary<string, State>();\n    // 辿っているQueue\n    static Queue<State> queue = new Queue<State>();\n\n    class State\n    {\n    \tpublic int dist = -1;\n    \tpublic string str = \"\";\n    \tpublic List<string> adjacentStrs = new List<string>();\n    \tpublic State(string str)\n    \t{\n    \t\tforeach (var s in str)\n    \t\t{\n    \t\t\tswitch (s)\n    \t\t\t{\n    \t\t\t\tcase \"r\":\n    \t\t\t\t\tstr += \"0\";\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase \"g\":\n    \t\t\t\t\tstr += \"1\";\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase \"b\":\n    \t\t\t\t\tstr += \"2\";\n    \t\t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tfor (int i = 0; i < str.Length - 1; i++)\n    \t\t{\n    \t\t\tstring adjacentStr = str;\n    \t\t\tchar changed = ((int.Parse(str[i]) + int.Parse(str)) % 3).ToChar();\n    \t\t\tadjacentStr[i] = adjacentStr[i + 1] = changed;\n\t\t\t\tthis.adjacentStrs.Add(adjacentStr);\n    \t\t}\n    \t}\n    }\n\n    // メイン\n    static void Main(string[] args)\n    {\n    \tvar input = \"0\";\n    \twhile (input = Console.ReadLine() != \"0\")\n    \t{\n    \t\tstates.Clear();\n    \t\tqueue.Clear();\n        \tBfs(new State(input));\n    \t}\n    }\n\n    // 幅優先探索\n    static void Bfs(Node start)\n    {\n    \tstart.dist = 0;\n    \tqueue.Enqueue(start);\n    \twhile (queue.Count() > 0)\n    \t{\n    \t\tState state = queue.Dequeue();\n    \t\tif (CheckIdEnd(state.id))\n    \t\t{\n    \t\t\tSystem.Console.WriteLine(states.dist + 1);\n    \t\t\treturn;\n    \t\t}\n    \t\tforeach (var str in state.adjacentStrs)\n    \t\t{\n    \t\t\tif (!states.hasKey(str))\n    \t\t\t{\n    \t\t\t\tState adjacentState = new State(str);\n    \t\t\t\tadjacentState.dist = state.dist + 1;\n    \t\t\t\tstates.Add(str, adjacentState);\n    \t\t\t\tqueue.Enqueue(states[str]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tSystem.Console.WriteLine(\"NA\");\n\t}\n\n\tstatic bool CheckIdEnd(int id)\n\t{\n\t\tint num = id % 10;\n\t\tid /= 10;\n\t\twhile (id > 0)\n\t\t{\n\t\t\tif (num != id % 10)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnum = id % 10;\n\t\t\tid /= 10;\n\t\t}\n\t\treturn true;\n\t}\t\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\n\nnamespace Test1 {\n\n\n\n\n\n    class ClassMain {\n\n        public static Dictionary<string, int> worm4 = new Dictionary<string, int>();\n\n        public static void initWorm4() {\n            worm4.Add(\"rrrr\", 0);\n            worm4.Add(\"gggg\", 0);\n            worm4.Add(\"bbbb\", 0);\n            worm4.Add(\"rrrrr\", 0);\n            worm4.Add(\"ggggg\", 0);\n            worm4.Add(\"bbbbb\", 0);\n            worm4.Add(\"rrrrrr\", 0);\n            worm4.Add(\"gggggg\", 0);\n            worm4.Add(\"bbbbbb\", 0);\n            worm4.Add(\"rrrrrrr\", 0);//7\n            worm4.Add(\"ggggggg\", 0);\n            worm4.Add(\"bbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrr\", 0);//8\n            worm4.Add(\"gggggggg\", 0);\n            worm4.Add(\"bbbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrrr\", 0);//9\n            worm4.Add(\"ggggggggg\", 0);\n            worm4.Add(\"bbbbbbbbb\", 0);\n            worm4.Add(\"rrrrrrrrrr\", 0);//10\n            worm4.Add(\"gggggggggg\", 0);\n            worm4.Add(\"bbbbbbbbbb\", 0);\n            Queue<string> wormsChale = new Queue<string>();\n            wormsChale.Enqueue(\"rrrr\");\n            wormsChale.Enqueue(\"gggg\");\n            wormsChale.Enqueue(\"bbbb\");\n            wormsChale.Enqueue(\"rrrrr\");\n            wormsChale.Enqueue(\"ggggg\");\n            wormsChale.Enqueue(\"bbbbb\");\n            wormsChale.Enqueue(\"rrrrrr\");\n            wormsChale.Enqueue(\"gggggg\");\n            wormsChale.Enqueue(\"bbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrr\");//7\n            wormsChale.Enqueue(\"ggggggg\");\n            wormsChale.Enqueue(\"bbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrr\");//8\n            wormsChale.Enqueue(\"gggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrrr\");//9\n            wormsChale.Enqueue(\"ggggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbbb\");\n            wormsChale.Enqueue(\"rrrrrrrrrr\");//10\n            wormsChale.Enqueue(\"gggggggggg\");\n            wormsChale.Enqueue(\"bbbbbbbbbb\");\n            while (wormsChale.Count != 0) {\n                string aworm = wormsChale.Dequeue();\n                //Console.WriteLine(wormsChale.Count + aworm);\n                int count = worm4[aworm];\n                //transform\n                char[] wormChrs = aworm.ToCharArray(); \n                for (int i = 0; i < aworm.Length-1; i++) {\n                    if (wormChrs[i] == wormChrs[i + 1]) {\n                        char col = wormChrs[i];\n                        char[] copyW1 = new char[aworm.Length];\n                        char[] copyW2 = new char[aworm.Length];\n                        Array.Copy(wormChrs, copyW1, aworm.Length);\n                        Array.Copy(wormChrs, copyW2, aworm.Length);\n                        if (col == 'r') {\n                            copyW1[i] = 'g'; copyW1[i + 1] = 'b';\n                            copyW2[i] = 'b'; copyW2[i + 1] = 'g';\n                        }else if (col == 'g') {\n                            copyW1[i] = 'r'; copyW1[i + 1] = 'b';\n                            copyW2[i] = 'b'; copyW2[i + 1] = 'r';\n                        }else if (col == 'b') {\n                            copyW1[i] = 'g'; copyW1[i + 1] = 'r';\n                            copyW2[i] = 'r'; copyW2[i + 1] = 'g';\n                        }\n                        //Info add.\n                        string w1 = new string(copyW1);\n                        string w2 = new string(copyW2);\n                        //Console.WriteLine(w1 + \",\" + w2);\n                        if (worm4.ContainsKey(w1) == false) {\n                            worm4.Add(w1, count + 1);\n                            wormsChale.Enqueue(w1);\n                        }\n                        if (worm4.ContainsKey(w2) == false) {\n                            worm4.Add(w2, count + 1);\n                            wormsChale.Enqueue(w2);\n                        }\n                    }\n                }//end transform.            \n            }//end dequeue worms.        \n        }\n        \n\n\n        public static void Main(String[] args) {\n            string line;\n            initWorm4();\n            while ((line = Console.ReadLine()) != null) {\n                if (line == \"0\") { break; }\n                if (line.Length == 2) {\n                    if (line.Equals(\"rr\") || line.Equals(\"gg\") || line.Equals(\"bb\")) {\n                        Console.WriteLine(0);\n                    }\n                    else {\n                        Console.WriteLine(0);\n                    }\n                }\n                else if (line.Length == 3) {\n                    if (line.Equals(\"rrr\") || line.Equals(\"ggg\") || line.Equals(\"bbb\")) {\n                        Console.WriteLine(0);\n                    }\n                    else if (line.Equals(\"rgb\") || line.Equals(\"rbg\") || line.Equals(\"grb\")\n                        || line.Equals(\"gbr\") || line.Equals(\"brg\") || line.Equals(\"bgr\")) {\n                        Console.WriteLine(1);\n                    }\n                    else {\n                        Console.WriteLine(\"NA\");\n                    }\n                }\n                else {// len 4.\n                    if (worm4.ContainsKey(line) == false) {\n                        Console.WriteLine(\"NA\");\n                    }\n                    else {\n                        Console.WriteLine(worm4[line]);\n                    }\n                }\n        \n\n\n            }\n        }\n    \n    }\n\n\n\n    \n}"
  },
  {
    "language": "JavaScript",
    "code": "const input = require('fs').readFileSync('/dev/stdin', 'utf8');\nconst inputs = input.trim().split('\\n');\n\nconst COLORS = ['r','g','b'];\nclass Worm {\n  constructor(id, depth) {\n    this.id = id;\n    this.depth = depth;\n    this.colors = id.split('');\n  }\n  getNextWormIds() {\n    const nextWormIds = [];\n    for (let i = 0; i < this.colors.length - 1; i++) {\n      const [ current, next ] = this.colors.slice(i, i + 2);\n      if (current === next) {\n        continue;\n      }\n      const changed = COLORS.filter(s => s !== current && s !== next)[0];\n      const changedColors = this.colors.slice(); // copy\n      changedColors.splice(i, 2, changed, changed); // 置き換え\n      nextWormIds.push(changedColors.join(''));\n    }\n    return nextWormIds;\n  }\n}\n\nclass Graph {\n  constructor() {\n    this.map = new Map();\n  }\n  has(id) {\n    return this.map.has(id);\n  }\n  get(id) {\n    return this.map.get(id);\n  }\n  set(id, depth) {\n    this.map.set(id, new Worm(id, depth));\n  }\n  bfs(wormId) {\n    this.queue = [];\n    this.map.set(wormId, new Worm(wormId, 0));\n    this.queue.push(wormId);\n    while(this.queue.length) {\n      const wormId = this.queue.shift();\n      const worm = this.map.get(wormId);\n      const wormIds = worm.getNextWormIds();\n      if (!wormIds.length) {\n        return worm;\n      }\n      wormIds.forEach(wormId => {\n        if (this.map.has(wormId)) {\n          return;\n        }\n        this.map.set(wormId, new Worm(wormId, worm.depth + 1));\n        this.queue.push(wormId);\n      })\n    }\n  }\n}\n\ninputs.forEach(wormId => {\n  if (wormId === '0') {\n    return;\n  }\n  const graph = new Graph();\n  const worm = graph.bfs(wormId);\n  console.log(worm ? worm.depth : 'NA');\n});\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function BFS(x){\n   var obj={};\n   var bfs=[[x,0]];\n   obj[x]=true;\n   while(true){\n      if(bfs.length==0){ans=\"NA\";break;}\n      var leaf=bfs.shift();\n      var str=leaf[0];\n      var cnt=leaf[1];\n      if(/^0+$|^1+$|^2+$/.test(str)){ans=cnt;break;}\n      for(var i=0;i<str.length-1;i++){\n         if(str[i]==str[i+1])continue;\n         var arr=str.split(\"\");\n         var color=3-(+arr[i])-(+arr[i+1]);\n         arr[i]=color;\n         arr[i+1]=color;\n         var Str=arr.join(\"\");\n         if(obj.hasOwnProperty(Str)==false){\n            bfs.push([Str,cnt+1]);\n            obj[Str]=true;\n         }\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var rgb=Arr.shift();\n   if(rgb==\"0\")break;\n   rgb=rgb.replace(/r/g,\"0\").replace(/g/g,\"1\").replace(/b/g,\"2\")\n   var ans;\n   BFS(rgb);\n   console.log(ans);\n}"
  },
  {
    "language": "JavaScript",
    "code": "const input = require('fs').readFileSync('/dev/stdin', 'utf8');\nconst inputs = input.trim().split('\\n');\n\nconst COLORS = ['r','g','b'];\nclass Worm {\n  constructor(id, depth) {\n    this.id = id;\n    this.depth = depth;\n    this.colors = id.split('');\n  }\n  getNextWormIds() {\n    const nextWormIds = [];\n    for (let i = 0; i < this.colors.length - 1; i++) {\n      const [ current, next ] = this.colors.slice(i, i + 2);\n      if (current === next) {\n        continue;\n      }\n      const changed = COLORS.find(s => s !== current && s !== next);\n      const changedColors = this.colors.slice(); // copy\n      changedColors.splice(i, 2, changed, changed); // 置き換え\n      nextWormIds.push(changedColors.join(''));\n    }\n    return nextWormIds;\n  }\n}\n\nclass Graph {\n  constructor() {\n    this.map = new Map();\n  }\n  bfs(wormId) {\n    this.queue = [];\n    this.map.set(wormId, new Worm(wormId, 0));\n    this.queue.push(wormId);\n    while(this.queue.length) {\n      const wormId = this.queue.shift();\n      const worm = this.map.get(wormId);\n      const wormIds = worm.getNextWormIds();\n      if (!wormIds.length) {\n        return worm;\n      }\n      wormIds.forEach(wormId => {\n        if (this.map.has(wormId)) {\n          return;\n        }\n        this.map.set(wormId, new Worm(wormId, worm.depth + 1));\n        this.queue.push(wormId);\n      })\n    }\n  }\n}\n\ninputs.forEach(wormId => {\n  if (wormId === '0') {\n    return;\n  }\n  const graph = new Graph();\n  const worm = graph.bfs(wormId);\n  console.log(worm ? worm.depth : 'NA');\n});\n\n"
  },
  {
    "language": "JavaScript",
    "code": "const input = require('fs').readFileSync('/dev/stdin', 'utf8');\nconst inputs = input.trim().split('\\n');\n\nconst COLORS = ['r','g','b'];\nclass Worm {\n  constructor(id, depth) {\n    this.id = id;\n    this.depth = depth;\n    this.colors = id.split('');\n  }\n  getNextWormIds() {\n    const nextWormIds = [];\n    for (let i = 0; i < this.colors.length - 1; i++) {\n      const color = this.colors[i];\n      const nextColor = this.colors[i + 1];\n      if (color === nextColor) {\n        continue;\n      }\n      const changedColor = COLORS.filter(s => s !== color && s !== nextColor)[0];\n      const changedColors = this.colors.slice(); // copy\n      changedColors.splice(i, 2, changedColor, changedColor); // 置き換え\n      nextWormIds.push(changedColors.join(''));\n    }\n    return nextWormIds;\n  }\n}\n\nclass Graph {\n  constructor() {\n    this.map = new Map();\n  }\n  has(id) {\n    return this.map.has(id);\n  }\n  get(id) {\n    return this.map.get(id);\n  }\n  set(id, depth) {\n    this.map.set(id, new Worm(id, depth));\n  }\n  bfs(wormId) {\n    this.queue = [];\n    this.set(wormId, 0);\n    this.queue.push(wormId);\n    while(this.queue.length) {\n      const wormId = this.queue.shift();\n      const worm = this.get(wormId);\n      const wormIds = worm.getNextWormIds();\n      if (!wormIds.length) {\n        return worm;\n      }\n      wormIds.forEach(wormId => {\n        if (this.has(wormId)) {\n          return;\n        }\n        this.set(wormId, worm.depth + 1);\n        this.queue.push(wormId);\n      })\n    }\n  }\n  print() {\n    for (let i = 1; i <= this.map.size; i++) {\n      const node = this.map.get(i);\n      console.log(node.toString());\n    }\n  }\n}\n\ninputs.forEach(wormId => {\n  if (wormId === '0') {\n    return;\n  }\n  const graph = new Graph();\n  const worm = graph.bfs(wormId);\n  console.log(worm ? worm.depth : 'NA');\n});\n\n"
  },
  {
    "language": "JavaScript",
    "code": "const input = require('fs').readFileSync('/dev/stdin', 'utf8');\nconst inputs = input.trim().split('\\n');\n\nconst COLORS = ['r','g','b'];\nclass Worm {\n  constructor(id, depth) {\n    this.id = id;\n    this.depth = depth;\n    this.colors = id.split('');\n  }\n  getNextWormIds() {\n    const nextWormIds = [];\n    for (let i = 0; i < this.colors.length - 1; i++) {\n      const [ current, next ] = this.colors.slice(i, i + 2);\n      if (current === next) {\n        continue;\n      }\n      const changed = COLORS.filter(s => s !== current && s !== next)[0];\n      const changedColors = this.colors.slice(); // copy\n      changedColors.splice(i, 2, changed, changed); // 置き換え\n      nextWormIds.push(changedColors.join(''));\n    }\n    return nextWormIds;\n  }\n}\n\nclass Graph {\n  constructor() {\n    this.map = new Map();\n  }\n  bfs(wormId) {\n    this.queue = [];\n    this.map.set(wormId, new Worm(wormId, 0));\n    this.queue.push(wormId);\n    while(this.queue.length) {\n      const wormId = this.queue.shift();\n      const worm = this.map.get(wormId);\n      const wormIds = worm.getNextWormIds();\n      if (!wormIds.length) {\n        return worm;\n      }\n      wormIds.forEach(wormId => {\n        if (this.map.has(wormId)) {\n          return;\n        }\n        this.map.set(wormId, new Worm(wormId, worm.depth + 1));\n        this.queue.push(wormId);\n      })\n    }\n  }\n}\n\ninputs.forEach(wormId => {\n  if (wormId === '0') {\n    return;\n  }\n  const graph = new Graph();\n  const worm = graph.bfs(wormId);\n  console.log(worm ? worm.depth : 'NA');\n});\n\n"
  },
  {
    "language": "JavaScript",
    "code": "const input = require('fs').readFileSync('/dev/stdin', 'utf8');\nconst inputs = input.trim().split('\\n');\n\nconst COLORS = ['r','g','b'];\nclass Worm {\n  constructor(id, seconds) {\n    this.id = id;\n    this.seconds = seconds;\n  }\n  getNextWormIds() {\n    const nextWormIds = [];\n    for (let i = 0; i < this.id.length - 1; i++) {\n      const [ current, next ] = this.id.substr(i, 2);\n      if (current === next) {\n        continue;\n      }\n      const changed = COLORS.find(color => color !== current && color !== next);\n      const changedId = this.id.substr(0, i) + changed.repeat(2) + this.id.substr(i + 2);\n      nextWormIds.push(changedId);\n    }\n    return nextWormIds;\n  }\n}\n\nclass Graph {\n  constructor() {\n    this.map = new Map();\n  }\n  bfs(wormId) {\n    this.queue = [];\n    this.map.set(wormId, new Worm(wormId, 0));\n    this.queue.push(wormId);\n    while(this.queue.length) {\n      const wormId = this.queue.shift();\n      const worm = this.map.get(wormId);\n      const wormIds = worm.getNextWormIds();\n      // 全部同じ色のときwormIdsが存在せず、そのときのwormを返す\n      if (!wormIds.length) {\n        return worm;\n      }\n      wormIds.forEach(wormId => {\n        if (this.map.has(wormId)) {\n          return;\n        }\n        this.map.set(wormId, new Worm(wormId, worm.seconds + 1));\n        this.queue.push(wormId);\n      })\n    }\n  }\n}\n\ninputs.forEach(wormId => {\n  if (wormId === '0') {\n    return;\n  }\n  const graph = new Graph();\n  const worm = graph.bfs(wormId);\n  console.log(worm ? worm.seconds : 'NA');\n});\n\n"
  },
  {
    "language": "Ruby",
    "code": "(h=Hash[q=[[$_.chop,0]]]\nputs (while q[0]\ns,c=q.shift\nbreak c if s.squeeze(\"rgb\").size<2\n(0..s.size-2).map{|i|s[i]!=s[i+1]&&(t=s.dup;t[i,2]=\"rgb\".delete(t[i,2])*2;h[t]||=(q<<[t,c+1];0))}end)||:NA)while gets>?a"
  },
  {
    "language": "Ruby",
    "code": "colors = [?r, ?g, ?b]\n\nloop do\n\ts = gets.chomp\t\n\tbreak if s == ?0\n\ta = s.scan(/./)\n\tqueue = [a]\n\td = 0\n\t\n\tif a.uniq.size == 1\n\t\tputs 0\n\t\tnext\n\tend\n\n\treached = {a => 0}\n\tfound = false\n\tloop do\n\t\tnext_queue = []\n\t\tuntil queue.empty?\n\t\t\ta = queue.pop\n\t\t\tif a.uniq.size == 1\n\t\t\t\tnext_queue = []\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\tend\n\t\t\ta.each_cons(2).with_index do |(x, y), i|\n\t\t\t\tif x != y\n\t\t\t\t\tc = a.dup\n\t\t\t\t\tz = (colors - [x, y])[0]\n\t\t\t\t\tc[i] = c[i+1] = z\n\t\t\t\t\tnext if reached[c]\n\t\t\t\t\treached[c] = 0\n\t\t\t\t\tnext_queue << c\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif next_queue.empty?\n\t\t\tputs found ? d : 'NA'\n\t\t\tbreak\n\t\tend\n\t\td += 1\n\t\tqueue = next_queue\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "require \"set\"\n\ndef other_color(c, d)\n  if c == d\n    return c\n  else\n    diff = %w(r g b) - [c, d]\n    return diff.first\n  end\nend\n\ndef next_worm(worm)\n  pairs = worm.split('').each_cons(2).to_a\n  others = pairs.map { |pr| other_color(*pr)}\n\n  result = others.each_with_object([]).with_index{|(e, a), i|\n    w = worm.dup\n    w[i, 2] = e*2\n    unless $found.include? w\n      $found << w\n      a << w\n    end\n  }\n  result\nend\n\ndef mono_color_time(init)\n  $found = Set.new([init]) # 遷移して初期状態に戻る場合\n  time = 0\n  ws = [init]\n  until ws.empty? or ws.any? { |w| w.split('').uniq.size == 1 }\n    time += 1\n    ws = ws.flat_map { |w| next_worm(w) }.uniq\n  end\n  ws.empty? ? 'NA' : time\nend\n\nloop do\n  ln = gets.chomp\n  break if ln == '0'\n  puts mono_color_time(ln)\nend\n"
  },
  {
    "language": "Ruby",
    "code": "table = {\"rg\"=>\"bb\", \"gr\"=>\"bb\", \"gb\"=>\"rr\", \"bg\"=>\"rr\", \"br\"=>\"gg\", \"rb\"=>\"gg\"}\n\nuntil (worm = $<.gets.chomp) == \"0\"\n  queue = [worm]\n  dist = {worm => 0}\n  n = worm.size\n  catch :jump do\n    while (worm = queue.shift)\n      goal = [\"r\" * n, \"g\" * n, \"b\" * n]\n      if goal.include?(worm)\n        puts dist[worm]\n        throw :jump\n      else\n        (n - 1).times do |i|\n          tmp = worm.dup\n          pair = worm[i, 2]\n          next unless table[pair]\n          tmp[i, 2] = table[pair]\n          next if dist[tmp]\n          dist[tmp] = dist[worm] + 1\n          queue << tmp\n        end\n      end\n    end\n    puts \"NA\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def make_somites(i, a)\n    new_somites = a.dup\n    if new_somites[i] != \"r\" && new_somites[i+1] != \"r\"\n      new_somites[i] = \"r\"\n      new_somites[i+1] = \"r\"\n    elsif new_somites[i] != \"b\" && new_somites[i+1] != \"b\"\n      new_somites[i] = \"b\"\n      new_somites[i+1] = \"b\"\n    else new_somites[i] != \"g\" && new_somites[i+1] != \"g\"\n      new_somites[i] = \"g\"\n      new_somites[i+1] = \"g\"\n    end\n    return new_somites\nend\n\nloop do\n  insect = gets.chomp\n  break if insect == \"0\"\n\n  queue = []\n  time = {count: 0}\n  queue << [insect, time[:count]]\n  len_insect = insect.length\n  found = false\n\n  # 過去に作られたwormであるかの判定、何度も出る場合は全てが同じ色になることはないのでNAを出力する\n  reached = {a: true}\n\n  loop do\n    next_queue = []\n    until queue.empty?\n      target_somites = queue.shift\n      if target_somites[0].split(\"\").uniq.length == 1\n        next_queue = []\n        found = true\n        break\n      end\n\n      (0..len_insect-2).each do |i|\n        if target_somites[0][i] != target_somites[0][i+1]\n          a = target_somites[0].dup\n          new_somites = make_somites(i, a)\n          next if reached[new_somites]\n          reached[new_somites] = true\n          next_queue << [new_somites, target_somites[1]+1]\n        end\n      end\n    end\n    \n    if next_queue.empty?\n      puts found ? target_somites[1] : \"NA\"\n      break\n    end\n    queue = next_queue\n  end\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "def bfs(bug)\n  secs = {bug => 0}\n  q = [bug]\n\n  while b = q.shift\n    return secs[b] if b.split(//).uniq.size == 1\n\n    0.upto(b.size - 2) do |i|\n      next if b[i] == b[i + 1]\n\n      bt = b.dup\n      bt[i, 2] = 'rgb'.delete(b[i, 2]) * 2\n      next if secs[bt]\n\n      secs[bt] = secs[b] + 1\n      q.push bt\n    end\n  end\n\n  'NA'\nend\n\nuntil (bug = gets.chomp) == '0'\n  puts bfs(bug)\nend"
  },
  {
    "language": "Ruby",
    "code": "(h=Hash[q=[[$_.chop,0]]]\nputs (while q[0]\ns,c=q.shift\nbreak c if s=~/^(r+|g+|b+)$/\n(0..s.size-2).map{|i|s[i]!=s[i+1]&&(t=s.dup;t[i,2]=\"rgb\".delete(t[i,2])*2;h[t]||=(q<<[t,c+1];0))}end)||:NA)while gets>?a"
  },
  {
    "language": "Ruby",
    "code": "(h=Hash[q=[[$_.chop,0]]]\nputs (while q[0]\ns,c=q.shift\nbreak c if s=~/^(r+|g+|b+)$/\n(0..s.size-2).map{|i|s[i]!=s[i+1]&&(t=s.dup;t[i,2]=\"rgb\".delete(t[i,2])*2;h[t]||=(q<<[t,c+1];0))}end)||:NA)while gets>?a"
  },
  {
    "language": "Ruby",
    "code": "### global variables\n\n$cmap = {}\n\n### subroutines\n\ndef neighbors(nd)\n  len = nd.length\n\n  nbrs = []\n  c0 = nd[0]\n\n  for i in (1...len)\n    c1 = nd[i]\n    c01 = c0 + c1\n\n    if ! $cmap[c01].nil?\n      nd0 = nd.clone\n      nd0[i - 1, 2] = $cmap[c01]\n      nbrs << nd0\n    end\n    c0 = c1\n  end\n\n  nbrs\nend\n\n### main\n\nfor c0 in ['r', 'g', 'b']\n  for c1 in ['r', 'g', 'b']\n    if c0 != c1\n      $cmap[c0 + c1] =\n        (c0 != 'r' && c1 != 'r') ? 'rr' :\n        (c0 != 'g' && c1 != 'g') ? 'gg' : 'bb'\n    end\n  end\nend\n\nwhile true\n  st = gets.strip\n  break if st == '0'\n\n  queue = [st]\n  dists = {}\n  dists[st] = 0\n  dist = 'NA'\n\n  nst = st.length\n  ens = ['r' * nst, 'g' * nst, 'b' * nst]\n\n  while ! queue.empty?\n    nd = queue.shift\n\n    if ens.include? nd\n      dist = dists[nd]\n      found = true\n      break\n    end\n\n    for nd0 in neighbors(nd)\n      if dists[nd0].nil?\n        dists[nd0] = dists[nd] + 1\n        queue << nd0\n      end\n    end\n  end\n\n  puts dist\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"os\"\n    \"fmt\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\n/**************  Cell  *****************/\ntype Cell struct {\n    item interface{}\n    next *Cell\n    prev *Cell\n}\n\nfunc NewCell(x interface{}, ne *Cell, pr *Cell) *Cell {\n    newCp := new(Cell)\n    newCp.item = x\n    newCp.next = ne\n    newCp.prev = pr\n    return newCp\n}\n/************  End Cell  ***************/\n\n/**************  Queue  ****************/\ntype Queue struct {\n    size int\n    front *Cell\n    rear *Cell\n}\n\nfunc NewQueue() *Queue {\n    return new(Queue)\n}\n\nfunc (q *Queue) Push(x interface{}) {\n    newNode := NewCell(x, nil, nil)\n    if q.size == 0 {\n        q.front = newNode\n        q.rear = newNode\n    } else {\n        newNode.prev = q.rear\n        q.rear.next = newNode\n        q.rear = newNode\n    }\n    q.size++\n}\n\nfunc (q *Queue) PopLeft() interface{} {\n    if q.size == 0 {\n        return nil\n    } else {\n        x := q.front.item\n        if q.size == 1 {\n            q.front = nil\n            q.rear = nil\n        } else {\n            q.front = q.front.next\n            q.front.prev = nil\n        }\n        q.size--\n        return x\n    }\n}\n\nfunc (q *Queue) IsEmpty() bool {\n    return q.size == 0\n}\n\nfunc (q *Queue) Length() int {\n    return q.size\n}\n\ntype State struct {\n    color string\n    cnt int\n}\n\nfunc main() {\n    for {\n        sc.Scan()\n        init := sc.Text()\n        if init == \"0\" {\n            break\n        }\n        bfs(init)\n    }\n}\n\nfunc bfs(init string) {\n    dic := make(map[string]int)\n    que := NewQueue()\n    que.Push(State{init, 0})\n    length := len(init)\n    isSolved := false\n    for !que.IsEmpty() {\n        state := que.PopLeft().(State)\n        _, ok := dic[state.color]\n        if ok {\n            continue\n        } else {\n            dic[state.color] = state.cnt\n        }\n\n        if isSingleColor(state.color) {\n            fmt.Println(state.cnt)\n            isSolved = true\n            break\n        }\n\n        for i := 0;i < length - 1; i++ {\n            color1, color2 := string(state.color[i]), string(state.color[i + 1])\n            if color1 != color2 {\n                color3 := other(color1, color2)\n                if i <= length - 2 {\n                    que.Push(State{state.color[:i] + color3 + state.color[i + 2:], state.cnt + 1})\n                } else {\n                    que.Push(State{state.color[:i] + color3, state.cnt + 1})\n                }\n            }\n        }\n    }\n    if !isSolved {\n        fmt.Println(\"NA\")\n    }\n}\n\nfunc other(color1, color2 string) string {\n    if color1 == \"r\" {\n        if color2 == \"g\" {\n            return \"bb\"\n        } else if color2 == \"b\" {\n            return \"gg\"\n        }\n    } else if color1 == \"g\" {\n        if color2 == \"r\" {\n            return \"bb\"\n        } else if color2 == \"b\" {\n            return \"rr\"\n        }\n    } else if color1 == \"b\" {\n        if color2 == \"r\" {\n            return \"gg\"\n        } else if color2 == \"g\" {\n            return \"rr\"\n        }\n    }\n    return \"\"\n}\n\nfunc isSingleColor(color string) bool {\n    for _, c := range color {\n        if string(c) != string(color[0]) {\n            return false\n        }\n    }\n    return true\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\n\t$queue = array($ary_start);\t\t//スタート地点を$queueに入れて開始\n\twhile (count($queue) > 0) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t\t//配列$queueの頭から１つ取り出す。\n\t   $cur_size = count($cur);\t\t//カレントキューの長さを取得\n\n\t   //終了条件。全ての配列が同じ色なら終了\n\t   for($i=0; $i<$cur_size; $i++){\n\t       if ($cur[$i] !== $cur[0]) break;\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $cur_size) {\n\t       $goal_flag = 1;\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$cur_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n\t    \t\t$new = $cur;\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t}\n\t    \t}\n\t    }\n\t    $sec++;\n\t}\n}\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$ary_start = array();\n\t$goal_flag = 0;\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets(STDIN));\n\t$ary_start = str_split($stdin);\n\t\n\t//終了条件\n\tif ($ary_start === 0){\n\t\tbreak;\n\t}\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n$file_handle = fopen('php://stdin', \"r\");\t//fopen()は同位フォルダにファイルがあればその名前のみでOK\n\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\t//終了条件に使用\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\n\t$queue[0] = $ary_start;\t\t\t//スタートを$queueに入れて開始\n\t$queue_size = count($queue[0]);\t//キューの長さを取得\n\t$queue[0]['sec'] = 0;\t\t\t//スタート時の秒数(階層の深さ)を入れる\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t//配列$queueの頭から１つ取り出す。\n\t   \n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$queue_size; $i++){\n\t       if ($cur[$i] !== $cur[0]){ break; }\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $queue_size) {\n\t       $goal_flag = 1;\n\t       $sec = $cur['sec'];\t//ゴールした時の秒数\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$queue_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n    \t\t\t$new = $cur;\n    \t\t\t$new['sec'] = $cur['sec'] + 1;\t\t//（バグ３に関して）キュー自身に階層情報を持たせるのが一番早い\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t}\n\t    \t\t$str = toString($new);\n\t    \t\tif (empty($visited[$str])){\t//未探索の場合。バグの原因２。この再訪防止処置が無いと同じパターンを何度も辿ることになり効率が非常に悪くなる\n\t\t    \t\tarray_push($queue, $new);\n\t\t\t\t    $visited[$str] = 1;\t\t//pushしたキューを探索済みに追加\n\t\t\t\t}\n\t    \t}\n\t    }\n\t    //$sec++;\n\t    //バグの原因３。一番嵌った場所。位置がNG。階層が進んだところでインクリメントする必要あり。\n\t    //これだとnodeをひとつ調べるたびに秒数が増えていってしまう。\n\t}\n}\n\n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n\t$str = '';\n\tforeach ($ary as $key => $val){\n\t\tif (is_numeric($key)) {\t\t//配列のキーが数値ならば（secがあるので）\n\t\t\t$str = $str.$val;\n\t\t}\n\t}\n\treturn $str;\n}\n\n\nwhile (1){\n\t//変数の初期化\n\t$sec = 0;\n\t$goal_flag = 0;\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets($file_handle));\n\t//終了条件\n\tif ($stdin == '0'){\t\t//バグの原因１。 === とか == 0 だとバグ\n\t\tbreak;\n\t}\n\t$ary_start = str_split($stdin);\n\t\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\n\t$queue = array($ary_start);\t\t//スタート地点を$queueに入れて開始\n\twhile (count($queue) > 0) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t\t//配列$queueの頭から１つ取り出す。\n\t   $cur_size = count($cur);\t\t//カレントキューの長さを取得\n\t   $cnt = 0;\t//カウントの初期化\n\n\t   //終了条件。全ての配列が同じ色なら終了\n\t   for($i=0; $i<$cur_size; $i++){\n\t       if ($cur[$i] !== $cur[0]) break;\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $cur_size) {\n\t       $goal_flag = 1;\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$cur_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n\t    \t\t$new = $cur;\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t}\n\t    \t}\n\t    }\n\t    $sec++;\n\t}\n}\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$ary_start = array();\n\t$goal_flag = 0;\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets(STDIN));\n\t$ary_start = str_split($stdin);\n\t\n\t//終了条件\n\tif ($ary_start === 0){\n\t\tbreak;\n\t}\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n//wfs\nfunction wfs() {\n\tglobal $sec;\n\tglobal $ary_start;\n\n\t$queue = array($ary_start);\t\t//スタート地点を$queueに入れて開始\n\twhile (count($queue) > 0) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t\t//配列$queueの頭から１つ取り出す。\n\t   $cur_size = count($cur);\t\t//カレントキューの長さを取得\n\n\t   //終了条件。全ての配列が同じ色なら終了\n\t   for($i=0; $i<$cur_size; $i++){\n\t       if ($cur[$i] !== $cur[0]) break;\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $cur_size) {\n\t       $goal_flag = 1;\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$cur_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n\t    \t\t$new = $cur;\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t}\n\t    \t}\n\t    }\n\t    $sec++;\n\t}\n}\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$ary_start = array();\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets(STDIN));\n\t$ary_start = str_split($stdin);\n\t\n\t//終了条件\n\tif ($ary_start === 0){\n\t\tbreak;\n\t}\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n$file_handle = fopen('php://stdin', \"r\");\t//fopen()は同位フォルダにファイルがあればその名前のみでOK\n\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\tglobal $queue;\n\n\t$queue[0] = $ary_start;\t\t\t//スタートを$queueに入れて開始\n\t$queue_size = count($queue[0]);\t//キューの長さを取得\n\t$queue[0]['sec'] = 0;\t\t\t//スタート時の秒数(階層の深さ)を入れる\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t//配列$queueの頭から１つ取り出す。\n\t   \n\t   $str = toString($cur);\n\t   if (empty($visited[$str])){\n\t       $visited[$str] = 1;\n\t   } else {\n\t       continue;\n\t   }\n\t   \n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$queue_size; $i++){\n\t       if ($cur[$i] !== $cur[0]){ break; }\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $queue_size) {\n\t       $goal_flag = 1;\n\t       $sec = $cur['sec'];\t//ゴールした時の秒数\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$queue_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n    \t\t\t$new = $cur;\n    \t\t\t$new['sec'] = $cur['sec'] + 1;\t\t//（バグ３に関して）キュー自身に階層情報を持たせるのが一番早い\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t}\n\t    \t\t$str = toString($new);\n\t    \t\tif (empty($visited[$str])){\t//未探索の場合。バグの原因２。この再訪防止処置が無いと同じパターンを何度も辿ることになり効率が非常に悪くなる\n\t\t    \t\tarray_push($queue, $new);\n\t\t\t\t    $visited[$str] = 1;\t\t//pushしたキューを探索済みに追加\n\t\t\t\t}\n\t    \t}\n\t    }\n\t    //$sec++;\n\t    //バグの原因３。一番嵌った場所。位置がNG。階層が進んだところでインクリメントする必要あり。\n\t    //これだとnodeをひとつ調べるたびに秒数が増えていってしまう。\n\t}\n}\n\n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n\t$str = '';\n\tforeach ($ary as $key => $val){\n\t\tif (is_numeric($key)) {\t\t//配列のキーが数値ならば（secがあるので）\n\t\t\t$str = $str.$val;\n\t\t}\n\t}\n\treturn $str;\n}\n\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$goal_flag = 0;\n\t$queue = array();\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets($file_handle));\n\t//終了条件\n\tif ($stdin == '0'){\t\t//バグの原因１。 === とか == 0 だとバグ\n\t\tbreak;\n\t}\n\t$ary_start = str_split($stdin);\n\t\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\n\t$queue = array($ary_start);\t\t//スタート地点を$queueに入れて開始\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t\t//配列$queueの頭から１つ取り出す。\n\t   $cur_size = count($cur);\t\t//カレントキューの長さを取得\n\n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$cur_size; $i++){\n\t       if ($cur[$i] !== $cur[0]) break;\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $cur_size) {\n\t       $goal_flag = 1;\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$cur_size-1; $i++){\n\t    \tif ($cur[$i] != $cur[$i+1]){\t//隣接する体節の色が違う場合\n\t    \t\t$new = $cur;\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t}\n\t    \t}\n\t    }\n\t    $sec++;\n\t}\n}\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$goal_flag = 0;\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets(STDIN));\n\t$ary_start = str_split($stdin);\n\t\n\t//終了条件\n\tif ($ary_start === 0){\n\t\tbreak;\n\t}\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n \n$file_handle = fopen('php://stdin', \"r\");   //fopen()は同位フォルダにファイルがあればその名前のみでOK\n \n \n//wfs\nfunction wfs() {\n    global $cnt;\n    global $sec;\n    global $ary_start;\n    global $goal_flag;\n \n    $queue[0] = $ary_start;         //スタートを$queueに入れて開始\n    $queue_size = count($queue[0]); //キューの長さを取得\n    $queue[0]['sec'] = 0;           //スタート時の秒数(階層の深さ)を入れる\n    while (!empty($queue)) {        //$queueが1つ以上あればループ\n       $cur = array_shift($queue);  //配列$queueの頭から１つ取り出す。\n        \n       //終了条件。全ての配列が同じ色なら終了\n       $cnt = 0;    //カウントの初期化\n       for($i=0; $i<$queue_size; $i++){\n           if ($cur[$i] !== $cur[0]){ break; }\n           $cnt++;\n       }\n       if ($cnt === $queue_size) {\n           $goal_flag = 1;\n           $sec = $cur['sec'];  //ゴールした時の秒数\n           break;   //色がすべて同じならwhileを抜ける\n       }\n        \n       //探索\n        for($i=0; $i<$queue_size-1; $i++){\n            if ($cur[$i] !== $cur[$i+1]){\n                $new = $cur;\n                $new['sec'] = $cur['sec'] + 1;\n                if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){    \n                    $new[$i] = 'r';  $new[$i+1] = 'r';\n                } else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n                    $new[$i] = 'g';  $new[$i+1] = 'g';\n                } else {\n                    $new[$i] = 'b';  $new[$i+1] = 'b';\n                }\n                $str = toString($new);\n                if (empty($visited[$str])){\n                    array_push($queue, $new);\n                    $visited[$str] = 1;\n                }\n            }\n        }\n    }\n}\n \n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n    $str = '';\n    foreach ($ary as $key => $val){\n        if (is_numeric($key)) { \n            $str = $str.$val;\n        }\n    }\n    return $str;\n}\n \n \nwhile (1){\n    //変数の初期化\n    $cnt = 0;   //終了条件に使用\n    $sec = 0;\n    $goal_flag = 0;\n \n    //ファイル読み込み\n    $stdin = trim(fgets($file_handle));\n    //終了条件\n    if ($stdin == '0'){\n        break;\n    }\n    $ary_start = str_split($stdin);\n     \n \n    //探索\n    wfs();\n \n    //出力\n    if ($goal_flag === 1){\n        echo $sec;\n    } else {\n        echo 'NA';\n    }\n    echo PHP_EOL;\n}\n \nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$file_handle = fopen('php://stdin', \"r\");\t\n\n//wfs\nfunction wfs() {\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\n\t$queue[0] = $ary_start;\t\t\t//スタートを$queueに入れて開始\n\t$queue_size = count($queue[0]);\t//キューの長さを取得\n\t$queue[0]['sec'] = 0;\t\t\t//スタート時の秒数(階層の深さ)を入れる\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t//配列$queueの頭から１つ取り出す。\n\t   \n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウント\n\t   for($i=0; $i<$queue_size; $i++){\n\t       if ($cur[$i] !== $cur[0]){ break; }\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $queue_size) {\n\t       $goal_flag = 1;\n\t       $sec = $cur['sec'];\t//ゴールした時の秒数\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$queue_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n    \t\t\t$new = $cur;\n    \t\t\t$new['sec'] = $cur['sec'] + 1;\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t}\n\t    \t\t$str = toString($new);\n\t    \t\tif (empty($visited[$str])){\n\t\t    \t\tarray_push($queue, $new);\n\t\t\t\t    $visited[$str] = 1;\n\t\t\t\t}\n\t    \t}\n\t    }\n\t}\n}\n\n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n\t$str = '';\n\tforeach ($ary as $key => $val){\n\t\tif (is_numeric($key)) {\t\t//配列のキーが数値ならば（secがあるので）\n\t\t\t$str = $str.$val;\n\t\t}\n\t}\n\treturn $str;\n}\n\n\nwhile (1){\n\t//変数の初期化\n\t$sec = 0;\n\t$goal_flag = 0;\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets($file_handle));\n\t//終了条件\n\tif ($stdin == '0'){\n\t\tbreak;\n\t}\n\t$ary_start = str_split($stdin);\n\t\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nclass Queue {\n    private $arr = [];\n    private $size = 0;\n    \n    public function push($item) {\n        $this->size++;\n        array_push($this->arr, $item);\n    }\n    \n    public function pop() {\n        $this->size--;\n        return array_shift($this->arr);\n    }\n    \n    public function isEmpty() {\n        return $this->size === 0;\n    }\n}\nwhile (true) {\n    $s = trim(fgets(STDIN));\n    if ($s === \"0\") {\n        break;\n    }\n    search($s);\n}\n\nfunction search($s) {\n    $length = strlen($s);\n    $que = new Queue();\n    $que->push([0, $s]);\n    $dic = [];\n    $r = \"\";\n    $g = \"\";\n    $b = \"\";\n    for ($i = 0; $i < $length; $i++) {\n        $r .= \"r\";\n        $g .= \"g\";\n        $b .= \"b\";\n    }\n    $singles = [$r, $g, $b];\n    $ok = false;\n    while (!$que->isEmpty()) {\n        list($score, $state) = $que->pop();\n        if (isSingleColor($state, $singles)) {\n            echo $score . \"\\n\";\n            $ok = true;\n            break;\n        }\n        for ($i = 0; $i < $length - 1; $i++) {\n            $c1 = $state[$i];\n            $c2 = $state[$i + 1];\n            if ($c1 != $c2) {\n                $c3 = other($c1, $c2);\n                $newState = substr_replace($state, $c3, $i, 2);\n                if (!array_key_exists($newState, $dic)) {\n                    $dic[$newState] = $score + 1;\n                    $que->push([$score + 1, $newState]);\n                }\n            }\n        }\n    }\n    if (!$ok) {\n        echo \"NA\\n\";\n    }\n}\n\n\n\nfunction isSingleColor($s, $singles) {\n    foreach ($singles as $single) {\n        if ($s === $single) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction other($c1, $c2) {\n    if ($c1 === \"r\") {\n        if ($c2 === \"g\") {\n            return \"bb\";\n        } elseif ($c2 === \"b\") {\n            return \"gg\";\n        }\n    } elseif ($c1 === \"g\") {\n        if ($c2 === \"r\") {\n            return \"bb\";\n        } elseif ($c2 === \"b\") {\n            return \"rr\";\n        }\n    } elseif ($c1 === \"b\") {\n        if ($c2 === \"r\") {\n            return \"gg\";\n        } elseif ($c2 === \"g\") {\n            return \"rr\";\n        }\n    }\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n$file_handle = fopen('php://stdin', \"r\");\t//fopen()は同位フォルダにファイルがあればその名前のみでOK\n\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\tglobal $queue;\n\n\t$queue[0] = $ary_start;\t\t\t//スタートを$queueに入れて開始\n\t$queue_size = count($queue[0]);\t//キューの長さを取得\n\t$queue[0]['sec'] = 0;\t\t\t//スタート時の秒数(階層の深さ)を入れる\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t//配列$queueの頭から１つ取り出す。\n\t   \n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$queue_size; $i++){\n\t       if ($cur[$i] !== $cur[0]){ break; }\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $queue_size) {\n\t       $goal_flag = 1;\n\t       $sec = $cur['sec'];\t//ゴールした時の秒数\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$queue_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n    \t\t\t$new = $cur;\n    \t\t\t$new['sec'] = $cur['sec'] + 1;\t\t//（バグ３に関して）キュー自身に階層情報を持たせるのが一番早い\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t}\n\t    \t\t$str = toString($new);\n\t    \t\tif (empty($visited[$str])){\t//未探索の場合。バグの原因２。この再訪防止処置が無いと同じパターンを何度も辿ることになり効率が非常に悪くなる\n\t\t    \t\tarray_push($queue, $new);\n\t\t\t\t    $visited[$str] = 1;\t\t//pushしたキューを探索済みに追加\n\t\t\t\t}\n\t    \t}\n\t    }\n\t    //$sec++;\n\t    //バグの原因３。一番嵌った場所。位置がNG。階層が進んだところでインクリメントする必要あり。\n\t    //これだとnodeをひとつ調べるたびに秒数が増えていってしまう。\n\t}\n}\n\n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n\t$str = '';\n\tforeach ($ary as $key => $val){\n\t\tif (is_numeric($key)) {\t\t//配列のキーが数値ならば（secがあるので）\n\t\t\t$str = $str.$val;\n\t\t}\n\t}\n\treturn $str;\n}\n\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$goal_flag = 0;\n\t$queue = array();\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets($file_handle));\n\t//終了条件\n\tif ($stdin == '0'){\t\t//バグの原因１。 === とか == 0 だとバグ\n\t\tbreak;\n\t}\n\t$ary_start = str_split($stdin);\n\t\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n$file_handle = fopen('php://stdin', \"r\");\t//fopen()は同位フォルダにファイルがあればその名前のみでOK\n\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\tglobal $queue;\n\n\t$queue[0] = $ary_start;\t\t\t//スタートを$queueに入れて開始\n\t$queue_size = count($queue[0]);\t//キューの長さを取得\n\t$queue[0]['sec'] = 0;\t\t\t//スタート時の秒数(階層の深さ)を入れる\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t//配列$queueの頭から１つ取り出す。\n\t   \n\t   $str = toString($cur)\n\t   if (empty($visited[$str])){\n\t       $visited[$str] = 1;\n\t   } else {\n\t       continue;\n\t   }\n\t   \n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$queue_size; $i++){\n\t       if ($cur[$i] !== $cur[0]){ break; }\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $queue_size) {\n\t       $goal_flag = 1;\n\t       $sec = $cur['sec'];\t//ゴールした時の秒数\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$queue_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n    \t\t\t$new = $cur;\n    \t\t\t$new['sec'] = $cur['sec'] + 1;\t\t//（バグ３に関して）キュー自身に階層情報を持たせるのが一番早い\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t}\n\t    \t\t$str = toString($new);\n\t    \t\tif (empty($visited[$str])){\t//未探索の場合。バグの原因２。この再訪防止処置が無いと同じパターンを何度も辿ることになり効率が非常に悪くなる\n\t\t    \t\tarray_push($queue, $new);\n\t\t\t\t    $visited[$str] = 1;\t\t//pushしたキューを探索済みに追加\n\t\t\t\t}\n\t    \t}\n\t    }\n\t    //$sec++;\n\t    //バグの原因３。一番嵌った場所。位置がNG。階層が進んだところでインクリメントする必要あり。\n\t    //これだとnodeをひとつ調べるたびに秒数が増えていってしまう。\n\t}\n}\n\n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n\t$str = '';\n\tforeach ($ary as $key => $val){\n\t\tif (is_numeric($key)) {\t\t//配列のキーが数値ならば（secがあるので）\n\t\t\t$str = $str.$val;\n\t\t}\n\t}\n\treturn $str;\n}\n\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$goal_flag = 0;\n\t$queue = array();\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets($file_handle));\n\t//終了条件\n\tif ($stdin == '0'){\t\t//バグの原因１。 === とか == 0 だとバグ\n\t\tbreak;\n\t}\n\t$ary_start = str_split($stdin);\n\t\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\n\t$queue = array($ary_start);\t\t//スタート地点を$queueに入れて開始\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t\t//配列$queueの頭から１つ取り出す。\n\t   $cur_size = count($cur);\t\t//カレントキューの長さを取得\n\n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$cur_size; $i++){\n\t       if ($cur[$i] !== $cur[0]) break;\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $cur_size) {\n\t       $goal_flag = 1;\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$cur_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\t//隣接する体節の色が違う場合\n\t    \t\t$new = $cur;\n\t    \t\t//変化する色ごとに場合分け\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t//次の階層で赤になる場合\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t\tarray_push($queue, $new);\n\t    \t\t}\n\t    \t}\n\t    }\n\t    $sec++;\n\t}\n}\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$ary_start = array();\n\t$goal_flag = 0;\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets(STDIN));\n\t$ary_start = str_split($stdin);\n\t\n\t//終了条件\n\tif ($ary_start === 0){\n\t\tbreak;\n\t}\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n \n$file_handle = fopen('php://stdin', \"r\");   //fopen()は同位フォルダにファイルがあればその名前のみでOK\n \n \n//wfs\nfunction wfs() {\n    global $cnt;\n    global $sec;\n    global $ary_start;\n    global $goal_flag;\n    global $queue;\n \n    $queue[0] = $ary_start;         //スタートを$queueに入れて開始\n    $queue_size = count($queue[0]); //キューの長さを取得\n    $queue[0]['sec'] = 0;           //スタート時の秒数(階層の深さ)を入れる\n    while (!empty($queue)) {        //$queueが1つ以上あればループ\n       $cur = array_shift($queue);  //配列$queueの頭から１つ取り出す。\n        \n       //終了条件。全ての配列が同じ色なら終了\n       $cnt = 0;    //カウントの初期化\n       for($i=0; $i<$queue_size; $i++){\n           if ($cur[$i] !== $cur[0]){ break; }\n           $cnt++;\n       }\n       if ($cnt === $queue_size) {\n           $goal_flag = 1;\n           $sec = $cur['sec'];  //ゴールした時の秒数\n           break;   //色がすべて同じならwhileを抜ける\n       }\n        \n       //探索\n        for($i=0; $i<$queue_size-1; $i++){\n            if ($cur[$i] !== $cur[$i+1]){\n                $new = $cur;\n                $new['sec'] = $cur['sec'] + 1;\n                if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){    \n                    $new[$i] = 'r';  $new[$i+1] = 'r';\n                } else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n                    $new[$i] = 'g';  $new[$i+1] = 'g';\n                } else {\n                    $new[$i] = 'b';  $new[$i+1] = 'b';\n                }\n                $str = toString($new);\n                if (empty($visited[$str])){\n                    array_push($queue, $new);\n                    $visited[$str] = 1;\n                }\n            }\n        }\n    }\n}\n \n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n    $str = '';\n    foreach ($ary as $key => $val){\n        if (is_numeric($key)) { \n            $str = $str.$val;\n        }\n    }\n    return $str;\n}\n \n \nwhile (1){\n    //変数の初期化\n    $cnt = 0;   //終了条件に使用\n    $sec = 0;\n    $goal_flag = 0;\n    $queue = array();\n \n    //ファイル読み込み\n    $stdin = trim(fgets($file_handle));\n    //終了条件\n    if ($stdin == 0){\n        break;\n    }\n    $ary_start = str_split($stdin);\n     \n \n    //探索\n    wfs();\n \n    //出力\n    if ($goal_flag === 1){\n        echo $sec;\n    } else {\n        echo 'NA';\n    }\n    echo PHP_EOL;\n}\n \nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//$queueからarray_shift()でひとつ頭を取り出す。\n//$ary[]に体節の並びを保持。体節の長さ分だけfor(foreach)でまわして $ary[$i] と $ary[$i+1] とを比較\n//もし、色が違えば$queueに次階層の状態を追加($array_push)\n//体節の色がすべて同じなら終了する。\n\n$file_handle = fopen('php://stdin', \"r\");\t//fopen()は同位フォルダにファイルがあればその名前のみでOK\n\n\n//wfs\nfunction wfs() {\n\tglobal $cnt;\n\tglobal $sec;\n\tglobal $ary_start;\n\tglobal $goal_flag;\n\tglobal $queue;\n\n\t$queue[0] = $ary_start;\t\t\t//スタートを$queueに入れて開始\n\t$queue_size = count($queue[0]);\t//キューの長さを取得\n\t$queue[0]['sec'] = 0;\t\t\t//スタート時の秒数(階層の深さ)を入れる\n\twhile (!empty($queue)) {\t\t//$queueが1つ以上あればループ\n\t   $cur = array_shift($queue);\t//配列$queueの頭から１つ取り出す。\n\t   \n\t   //終了条件。全ての配列が同じ色なら終了\n\t   $cnt = 0;\t//カウントの初期化\n\t   for($i=0; $i<$queue_size; $i++){\n\t       if ($cur[$i] !== $cur[0]){ break; }\n\t       $cnt++;\n\t   }\n\t   if ($cnt === $queue_size) {\n\t       $goal_flag = 1;\n\t       $sec = $cur['sec'];\t//ゴールした時の秒数\n\t       break;\t//色がすべて同じならwhileを抜ける\n\t   }\n\t   \n\t   //探索\n\t    for($i=0; $i<$queue_size-1; $i++){\n\t    \tif ($cur[$i] !== $cur[$i+1]){\n    \t\t\t$new = $cur;\n    \t\t\t$new['sec'] = $cur['sec'] + 1;\n\t    \t\tif ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){\t\n\t    \t\t\t$new[$i] = 'r';  $new[$i+1] = 'r';\n\t    \t\t} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){\n\t    \t\t\t$new[$i] = 'g';  $new[$i+1] = 'g';\n\t    \t\t} else {\n\t    \t\t\t$new[$i] = 'b';  $new[$i+1] = 'b';\n\t    \t\t}\n\t    \t\t$str = toString($new);\n\t    \t\tif (empty($visited[$str])){\n\t\t    \t\tarray_push($queue, $new);\n\t\t\t\t    $visited[$str] = 1;\n\t\t\t\t}\n\t    \t}\n\t    }\n\t}\n}\n\n//再訪防止用。配列のキーに文字列を設定するために使用\nfunction toString($ary){\n\t$str = '';\n\tforeach ($ary as $key => $val){\n\t\tif (is_numeric($key)) {\t\n\t\t\t$str = $str.$val;\n\t\t}\n\t}\n\treturn $str;\n}\n\n\nwhile (1){\n\t//変数の初期化\n\t$cnt = 0;\t//終了条件に使用\n\t$sec = 0;\n\t$goal_flag = 0;\n\t$queue = array();\n\n\t//ファイル読み込み\n\t$stdin = trim(fgets($file_handle));\n\t//終了条件\n\tif ($stdin == '0'){\n\t\tbreak;\n\t}\n\t$ary_start = str_split($stdin);\n\t\n\n\t//探索\n\twfs();\n\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo $sec;\n\t} else {\n\t\techo 'NA';\n\t}\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                    char[] tmp = s.dup;\n                    q.insert(tuple(v+1, tmp.idup));\n                      \n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                    char[] tmp = s.dup;\n                    q.insert(tuple(v+1, tmp.idup));\n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\nreturn -1;\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n//                    char[] tmp = s.dup;\n//                    q.insert(tuple(v+1, tmp.idup));\n                      \n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\nreturn -1;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if((s in memo) !is null) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.chomp();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        if(memo.length > 0) {\nreturn -1;\n}\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if((s in memo) !is null) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\nreturn -1;\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\nchar[] tmp = s.dup;\n                if(s[i] != 'r' && s[i+1] != 'r') {\ntmp[i..i+2] = \"rr\";\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\ntmp[i..i+2] = \"gg\";\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\ntmp[i..i+2] = \"bb\";\n                }\n                    q.insert(tuple(v+1, string(tmp)));\n\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    BinaryHeap(Array!(Tuple!(long, string)), \"a > b\") q;\n    q.insert(tuple(0L, l));\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\nchar[] tmp = s.dup;\n                if(s[i] != 'r' && s[i+1] != 'r') {\ntmp[i..i+2] = \"rr\";\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\ntmp[i..i+2] = \"gg\";\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\ntmp[i..i+2] = \"bb\";\n                }\n                    q.insert(tuple(v+1, tmp.idup));\n \n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    BinaryHeap!(Array!(Tuple!(long, string)), \"a > b\") q;\n    q.insert(tuple(0L, l));\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        if(q.length > 1000) {\n            return -1;\n        }\n        if(memo.length > 1000) {\n            return -1;\n        }\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if((s in memo) !is null) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.chomp();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                    char[] tmp = s.dup;\n                    q.insert(tuple(v+1, s));\n                      \n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\nreturn -1;\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\nchar[] tmp = s.dup;\n                    q.insert(tuple(v+1, tmp.idup));\n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n//                    char[] tmp = s.dup;\n//                    q.insert(tuple(v+1, tmp.idup));\n                      return -1;\n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n \nauto readInts() {\n    return array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n    return readInts()[0];\n}\nauto readLongs() {\n    return array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n    return readLongs()[0];\n}\n \nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n \nconst real eps = 1e-10;\n \nconst long p = 1_000_000_000 + 7;\n \nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n//                    char[] tmp = s.dup;\n                    q.insert(tuple(v+1, tmp.idup));\n                      \n            }\n        }\n    }\n    return -1;\n}\n \nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        if(q.length > 1000000) {\n            return -1;\n        }\n        if(memo.length > 1000000) {\n            return -1;\n        }\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if((s in memo) !is null) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.chomp();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)].array);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.string;\n\nchar[3] type = ['r', 'g', 'b'];\nstring s;\nint n;\nbool f;\n\nvoid main(){\n\twhile (s = chomp(readln()), s != \"0\") {\n\t\tbool[string] memo;\n\t\tstring[] queue;\n\t\tint[] depth;\n\t\tqueue ~= s;\n\t\tdepth ~= 0;\n\t\tf = false;\n\t\twhile (queue.length) {\n\t\t\ts = queue.front;\n\t\t\tn = depth.front;\n\t\t\tqueue.popFront();\n\t\t\tdepth.popFront();\n\t\t\tif (s in memo) continue;\n\t\t\tmemo[s] = true;\n\n\t\t\t// check answer\n\t\t\tforeach (ch; type) if (replace(s, ch ~ \"\", \"\") == \"\") f = true;\n\t\t\tif (f) break;\n\n\t\t\t// bfs\n\t\t\tfor (int i = 0; i < s.length-1; i++) {\n\t\t\t\tif (s[i] != s[i+1]) {\n\t\t\t\t\tchar rest;\n\t\t\t\t\tforeach (ch; type)\n\t\t\t\t\t\tif (s[i] != ch && s[i+1] != ch) rest = ch;\n\t\t\t\t\tchar[] cs = s.dup;\n\t\t\t\t\tcs[i] = cs[i+1] = rest;\n\t\t\t\t\tqueue ~= cs.idup;\n\t\t\t\t\tdepth ~= n+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) writeln(n);\n\t\telse writeln(\"NA\");\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\nreturn -1;\n\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    BinaryHeap!(Tuple!(long, string), \"a > b\") q;\n    q.insert(tuple(0L, l));\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if(s in memo) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if((s in memo) !is null) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    auto l = readln.chomp();\n    if(l == \"0\") {\n        return;\n    }\n    auto ans = solve(l);\n    writeln(ans >= 0 ? ans.to!string: \"NA\");\n    main();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nlong solve(string l) {\n    long[string] memo;\n    auto q = heapify!(\"a > b\")([tuple(0L, l)]);\n    while(!q.empty()) {\n        auto t = q.front();\n        q.popFront();\n        auto s = t[1];\n        if((s in memo) !is null) {\n            continue;\n        }\n        auto v = t[0];\n        if(s.uniq.count == 1) {\n            return v;\n        }\n        if(memo.length > 100) {\n            return -1;\n        }\n        memo[s] = v;\n        foreach(i; iota(s.length-1)) {\n            if(s[i] != s[i+1]) {\n                if(s[i] != 'r' && s[i+1] != 'r') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"rr\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'g' && s[i+1] != 'g') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"gg\" ~ s[i+2..$]));\n                }\n                if(s[i] != 'b' && s[i+1] != 'b') {\n                    q.insert(tuple(v+1, s[0..i] ~ \"bb\" ~ s[i+2..$]));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nvoid main(){\n    while(true) {\n        auto l = readln.strip();\n        if(l == \"0\") {\n            return;\n        }\n        auto ans = solve(l);\n        writeln(ans >= 0 ? ans.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "Python",
    "code": "q = []\nlst = {}\n\ndef checker(letter, st):\n  for i in xrange(len(st)):\n    if letter != st[i]:\n      return False\n  return True\n\nwhile True:\n  q = []\n  lst = {}\n  st = raw_input()\n  deep = 0\n  if st == \"0\":\n    break\n  while True:\n    # checked\n    if st in lst:\n      if len(q) == 0:\n        print \"NA\"\n        break\n      st = q[0][0]\n      deep = q[0][1]\n      q = q[1:]\n      continue\n    # add checked list\n    lst[st] = deep\n    # check completed\n    if checker(st[0], st):\n      print deep\n      break\n    # que next pattern\n    for i in xrange(len(st)-1):\n      if st[i] == st[i+1]:\n        continue\n      if (st[i] == 'r' and st[i+1] == 'g') or (st[i] == 'g' and st[i+1] == 'r'):\n        q.append([st[:i] + \"bb\" + st[i+2:], deep+1])\n      elif (st[i] == 'r' and st[i+1] == 'b') or (st[i] == 'b' and st[i+1] == 'r'):\n        q.append([st[:i] + \"gg\" + st[i+2:], deep+1])\n      elif (st[i] == 'b' and st[i+1] == 'g') or (st[i] == 'g' and st[i+1] == 'b'):\n        q.append([st[:i] + \"rr\" + st[i+2:], deep+1])\n    # print NA if has no pattern in queue\n    if len(q) == 0:\n      print \"NA\"\n      break\n    # get next pattern from queue\n    st = q[0][0]\n    deep = q[0][1]\n    q = q[1:]"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef new_color(s, i, rgb):\n  for color in rgb:\n    if color != s[i] and color != s[i + 1]:\n      break\n  return s[:i] + color * 2 + s[i + 2:]\n\ndef solve(s):\n  length = len(s)\n  monos = [\"r\" * length, \"g\" * length, \"b\" * length]\n  if s in monos:\n    print(0)\n    return\n  dic = {s:0}\n  rgb = \"rgb\"\n  que = deque()\n  app = que.append\n  pop = que.popleft\n  que.append((s, 0))\n\n  while que:\n    colors, score = pop()\n    score += 1\n    temp = colors[0]\n\n    for i in range(1, length):\n      ci = colors[i]\n      if ci != temp:\n        new = new_color(colors, i - 1, rgb)\n\n        if new in monos:\n          print(score)\n          return\n\n        if new not in dic:\n          dic[new] = score\n          app((new, score))\n\n      temp = ci\n\n  print(\"NA\")\n\ndef main():\n  while True:\n    s = input()\n    if s == \"0\":\n      break\n    solve(s)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef only_color(s):\n  temp = s[0]\n  for i in range(1, len(s)):\n    c = s[i]\n    if temp != c:\n      return False\n    temp = c\n\n  return True\n\ndef new_color(s, i):\n  color = [c for c in (\"r\", \"g\", \"b\") if c not in (s[i], s[i + 1])][0]\n  return s[:i] + color * 2 + s[i + 2:]\n\ndef solve(s):\n  if only_color(s):\n    print(0)\n    return\n  length = len(s)\n  dic = {}\n  que = deque()\n  que.append((s, 0))\n\n  while que:\n    colors, score = que.popleft()\n    score += 1\n    temp = colors[0]\n    for i in range(1, length):\n      ci = colors[i]\n      if ci != temp:\n        new = new_color(colors, i - 1)\n        if only_color(new):\n          print(score)\n          return\n        if new not in dic:\n          dic[new] = score\n          que.append((new, score))\n      temp = ci\n  else:\n    print(\"NA\")\n\ndef main():\n  while True:\n    s = input()\n    if s == \"0\":\n      break\n    solve(s)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef change(x,y):\n    if [x,y] == [\"r\",\"g\"] or [y,x] == [\"r\",\"g\"]:\n        return \"b\"\n    elif [x,y] == [\"g\",\"b\"] or [y,x] == [\"g\",\"b\"]:\n        return \"r\"\n    elif [x,y] == [\"r\",\"b\"] or [y,x] == [\"r\",\"b\"]:\n        return \"g\"\n\n\n\nrgb = ['r','g','b']\nwhile True:\n    time = 0\n    W_dic = {}\n    W_que = deque([])\n    worm = tuple(str(input()))\n    if worm == ('0',):\n        break\n    else:\n        W_que.append([time,worm])\n        W_dic[worm] = time\n    while True:\n        now_list = W_que.popleft()\n        now_time = now_list[0]\n        now_worm = now_list[1]\n        if now_worm.count('r') == len(now_worm) or now_worm.count('g') == len(now_worm) or now_worm.count('b') == len(now_worm):\n            print(now_time)\n            break\n        a_0 = now_worm[0]\n        for i in range(1,len(now_worm)):\n            a_1 = now_worm[i]\n            rgb_c = rgb\n            worm_c = list(now_worm)\n            if a_0 != a_1:\n                coll = change(a_0,a_1)\n                worm_c[i - 1] = coll\n                worm_c[i] = coll\n                if not tuple(worm_c) in W_dic:\n                    W_dic[tuple(worm_c)] = now_time + 1\n                    W_que.append([now_time + 1,worm_c])\n            a_0 = a_1\n        \n        if len(W_que) == 0:\n            print(\"NA\")\n            break"
  },
  {
    "language": "Python",
    "code": "import Queue\ndic = {\n        'rg':'b', 'gr':'b',\n        'gb':'r', 'bg':'r',\n        'br':'g', 'rb':'g',\n        }\nwhile True:\n    s = raw_input()\n    if s=='0':\n        break\n    que = Queue.PriorityQueue()\n    l = len(s)\n    cost = {}\n    cost[s] = 0\n    que.put((0, s))\n    ans = -1\n    while not que.empty():\n        nn, ss = que.get()\n        if all(e == ss[0] for e in ss):\n            ans = nn\n            break\n        if cost[ss] < nn:\n            continue\n        for i in xrange(l-1):\n            cc = ss[i:i+2]\n            if cc[0]!=cc[1]:\n                code = dic[cc]\n                sa = ss[:i] + code*2 + ss[i+2:]\n                if sa not in cost or nn+1 < cost[sa]:\n                    cost[sa] = nn+1\n                    que.put((nn+1, sa))\n    print \"NA\" if ans<0 else ans"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000)\n\nfrom collections import deque\nimport copy\n\ndef another_color(a, b):\n    if not a == 'r' and not b == 'r':\n        return 'r'\n    if not a == 'g' and not b == 'g':\n        return 'g'\n    return 'b'\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def print(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.print()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef another_color(a, b):\n    if a == 'r' and b == 'g' or a == 'g' and b == 'r':\n        return 'b'\n    if a == 'r' and b == 'b' or a == 'b' and b == 'r':\n        return 'g'\n    if a == 'g' and b == 'b' or a == 'b' and b == 'g':\n        return 'r'\n    return None\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                if c is None:\n                    continue\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def print(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.print()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom collections import deque\n\n\nclass Bug:\n    __convert = {\"r\": 1, \"g\": 2, \"b\": 3}\n    __weight = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000]\n\n    def __init__(self, state, time):\n        self.state = list(state)\n        self.time = time\n\n    def color_change(self):\n        box = []\n\n        for item1, item2, index in zip(self.state[:-1], self.state[1:], range(len(self.state))):\n            if item1 != item2:\n\n                if item1 == \"r\" and item2 == \"g\" or item1 == \"g\" and item2 == \"r\":\n                    color = \"b\"\n                elif item1 == \"r\" and item2 == \"b\" or item1 == \"b\" and item2 == \"r\":\n                    color = \"g\"\n                else:\n                    color = \"r\"\n\n                copy_state = deepcopy(self.state)\n\n                copy_state[index] = color\n                copy_state[index + 1] = color\n\n                box.append(copy_state)\n\n        return box\n\n    def is_same_color(self):\n        first = self.state[0]\n        return all([item == first for item in self.state])\n\n    def __hash__(self):\n        tmp = [self.__convert[item] * w for item, w in zip(self.state, self.__weight)]\n        return sum(tmp)\n\n    def __eq__(self, other):\n        return all([item1 == item2 for item1, item2 in zip(self.state, other.state)])\n\n\nwhile True:\n\n    input_data = input()\n\n    if input_data[0] == \"0\":\n        break\n\n    state_queue = deque()\n    pattern = set()\n\n    first = Bug(input_data, 0)\n\n    if first.is_same_color():\n        answer = 0\n    else:\n        answer = \"NA\"\n        state_queue.appendleft(first)\n        pattern.add(first)\n\n    while len(state_queue) != 0:\n\n        original = state_queue.pop()\n        boxes = original.color_change()\n\n        for state in boxes:\n\n            item = Bug(state, original.time + 1)\n\n            if item.is_same_color():\n                answer = item.time\n\n                state_queue.clear()\n                break\n            else:\n                if item not in pattern:\n                    pattern.add(item)\n                    state_queue.appendleft(item)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\tref = set()\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor Worm in que:\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = list(rgb-set(Worm[i:i+2]))[0]\n\t\t\t\t\tworm = Worm[:i] + 2*nextclr + Worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tqueset = queset - ref\n\t\tref = ref|queset\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 15: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nused = [0]*(3**10)\n\n\nwhile True:\n\ts = raw_input()\n\tif s==\"0\":\n\t\tbreak\n\tn=len(s)\n\tt=0\n\tfor i in range(len(s)):\n\t\tt*=3\n\t\tif s[i]==\"r\":\n\t\t\tt+=0\n\t\tif s[i]==\"g\":\n\t\t\tt+=1\n\t\tif s[i]==\"b\":\n\t\t\tt+=2\n\tf=0\n\tfor i in range(3**n):\n\t\tused[i]=0\n\ttq=[t]\n\tq=deque(tq)\n\tused[t]=1\n\tans=-1\n\tcnt=0\n\twhile len(q)>0:\n\t\tqs=len(q)\n\t\tfor o in range(qs):\n\t\t\ttop=q.popleft()\n\t\t\tv=[0]\n\t\t\tv.pop()\n\t\t\tfor i in range(n):\n\t\t\t\tv.append(top%3)\n\t\t\t\ttop/=3\n\t\t\tok=1\n\t\t\ta=v[0]\n\t\t\tfor i in range(n):\n\t\t\t\tif v[i]!=a:\n\t\t\t\t\tok=0\n\t\t\tif ok==1:\n\t\t\t\tf=1\n\t\t\t\tans=cnt\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif v[i]!=v[i+1]:\n\t\t\t\t\tt1=v[i]\n\t\t\t\t\tt2=v[i+1]\n\t\t\t\t\tv[i]=3-t1-t2\n\t\t\t\t\tv[i+1]=3-t1-t2\n\t\t\t\t\ttmp=0\n\t\t\t\t\tfor j in range(n):\n\t\t\t\t\t\ttmp*=3\n\t\t\t\t\t\ttmp+=v[j]\n\t\t\t\t\tif used[tmp]==0:\n\t\t\t\t\t\tq.append(tmp)\n\t\t\t\t\t\tused[tmp]=1\n\t\t\t\t\tv[i]=t1\n\t\t\t\t\tv[i+1]=t2\n\t\tif f==1:\n\t\t\tbreak\n\t\telse:\n\t\t\tcnt+=1\n\tif ans==-1:\n\t\tprint \"NA\"\n\telse:\n\t\tprint ans"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef new_color(s, i, color):\n  return s[:i] + color * 2 + s[i + 2:]\n\ndef solve(s):\n  length = len(s)\n  monos = [\"r\" * length, \"g\" * length, \"b\" * length]\n  if s in monos:\n    print(0)\n    return\n\n  another = {(\"r\", \"g\"):\"b\", (\"g\", \"r\"):\"b\", \n             (\"r\", \"b\"):\"g\", (\"b\", \"r\"):\"g\",\n             (\"g\", \"b\"):\"r\", (\"b\", \"g\"):\"r\"}\n  visited = {s:0}\n  que = deque()\n  app = que.append\n  pop = que.popleft\n  que.append((s, 0))\n\n  while que:\n    colors, score = pop()\n    score += 1\n    temp = colors[0]\n\n    for i in range(1, length):\n      ci = colors[i]\n      if ci != temp:\n        new = new_color(colors, i - 1, another[(ci, temp)])\n        if new in monos:\n          print(score)\n          return\n\n        if new not in visited:\n          visited[new] = score\n          app((new, score))\n\n      temp = ci\n\n  print(\"NA\")\n\ndef main():\n  while True:\n    s = input()\n    if s == \"0\":\n      break\n    solve(s)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "dic = {\"r\":1,\"g\":2,\"b\":3}\nrgb = [\"r\",\"g\",\"b\"]\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tref = [\"r\"*n,\"g\"*n,\"b\"*n]\n\tcnt = flag = 0\n\tqueset = set([worm])\n\tdone = set()\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor Worm in que:\n\t\t\tif Worm in ref:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = rgb[5-dic[Worm[i]]-dic[Worm[i+1]]]\n\t\t\t\t\tqueset.add(Worm[:i] + 2*nextclr + Worm[i+2:])\n\t\tif flag or cnt > 14: break\n\t\tcnt += 1\n\t\tqueset -= done\n\t\tdone |= queset\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "def solve():\n    while True:\n        worm = input()\n        if worm == '0':\n            break\n        \n        q = [worm]\n        m = {('r', 'g'): 'bb', ('g', 'r'): 'bb', ('r', 'b'): 'gg',\n             ('b', 'r'): 'gg', ('g', 'b'): 'rr', ('b', 'g'): 'rr'}\n        d = {worm: True}\n        ans = 0\n        \n        while q:\n            nq = []\n            for w in q:\n                flag = True\n                for i, t in enumerate(zip(w, w[1:])):\n                    s1, s2 = t\n                    if s1 != s2:\n                        flag = False\n                        nw = w[:i] + m[t] + w[i+2:]\n                        if nw not in d:\n                            d[nw] = True\n                            nq.append(nw)\n                if flag:\n                    print(ans)\n                    break\n            else:\n                q = nq[:]\n                ans += 1\n                continue\n            break\n        else:\n            print('NA')\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tque = [worm]\n\tref = set(worm)\n\tL = 1\n\tcnt = flag = 0\n\twhile 1:\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif Worm in ref: continue\n\t\t\telse: ref.add(Worm)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tworm = Worm[:]\n\t\t\t\t\tnextclr = list(rgb-set(worm[i:i+2]))[0]\n\t\t\t\t\tworm = worm[:i] + 2*nextclr + worm[i+2:]\n\t\t\t\t\tif worm not in que: que.append(worm)\n\t\tL = len(que)\n\t\tif flag or L == 0: break\n\t\tcnt += 1\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\tref = set()\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor Worm in que:\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = list(rgb-set(Worm[i:i+2]))[0]\n\t\t\t\t\tworm = Worm[:i] + 2*nextclr + Worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tqueset = queset - ref\n\t\tref = ref|queset\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 13: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tworm = Worm[:]\n\t\t\t\t\tnextclr = list(rgb-set(worm[i:i+2]))[0]\n\t\t\t\t\tworm = worm[:i] + 2*nextclr + worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 10: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tque = [worm]\n\tref = set(worm)\n\tL = 1\n\tcnt = flag = 0\n\twhile 1:\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif Worm in ref: continue\n\t\t\telse: ref.add(Worm)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tworm = Worm[:]\n\t\t\t\t\tnextclr = list(rgb-set(worm[i:i+2]))[0]\n\t\t\t\t\tworm = worm[:i] + 2*nextclr + worm[i+2:]\n\t\t\t\t\tif worm not in que: que.append(worm)\n\t\tL = len(que)\n\t\tif flag or L == 0: break\n\t\tcnt += 1\n\t\tif cnt > 15: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "import Queue\nque = Queue.PriorityQueue()\ndic = {\n        ord('r')+ord('g'): 'b',\n        ord('g')+ord('b'): 'r',\n        ord('b')+ord('r'): 'g',\n        }\nwhile True:\n    s = raw_input()\n    if s=='0':\n        break\n    while not que.empty():\n        que.get()\n    cost = {}\n    cost[s] = 0\n    que.put((0, s))\n    ans = -1\n    while not que.empty():\n        nn, ss = que.get()\n        if all(e == ss[0] for e in ss):\n            ans = nn\n            break\n        if cost[ss] < nn:\n            continue\n        for i in xrange(len(ss)-1):\n            c0, c1 = ss[i], ss[i+1]\n            if c0 != c1:\n                code = dic[ord(c0)+ord(c1)]\n                sa = ss[:i] + code*2 + ss[i+2:]\n                if sa not in cost or nn+1 < cost[sa]:\n                    cost[sa] = nn+1\n                    que.put((nn+1, sa))\n    print \"NA\" if ans<0 else ans"
  },
  {
    "language": "Python",
    "code": "dic = {\"0\":0,\"1\":1,\"2\":2}\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tworm = worm.replace(\"r\",\"0\").replace(\"g\",\"1\").replace(\"b\",\"2\")\n\tn = len(worm)\n\tref = [\"0\"*n,\"1\"*n,\"2\"*n]\n\tdone = [1]*(3**n)\n\tdone[int(worm,3)] = 0\n\tcnt = flag = 0\n\tnxtque = [worm]\n\twhile 1:\n\t\tque = nxtque\n\t\tnxtque = []\n\t\tfor Worm in que:\n\t\t\tif Worm in ref:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = \"012\"[3-dic[Worm[i]]-dic[Worm[i+1]]]\n\t\t\t\t\tworm = Worm[:i] + 2*nextclr + Worm[i+2:]\n\t\t\t\t\tnum = int(worm,3)\n\t\t\t\t\tif done[num]:\n\t\t\t\t\t\tdone[num] = 0\n\t\t\t\t\t\tnxtque.append(worm)\n\t\tif flag or len(nxtque) == 0: break\n\t\tcnt += 1\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef another_color(a, b):\n    if not a == 'r' and not b == 'r':\n        return 'r'\n    if not a == 'g' and not b == 'g':\n        return 'g'\n    return 'b'\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def print(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.print()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef isOneColor(w):\n    sw = sorted(w)\n    if sw[0] == sw[-1]:\n        return True\n    else:\n        return False\n\ndef nextColor(c1, c2):\n    cs = ['r', 'g', 'b']\n    cs.remove(c1)\n    cs.remove(c2)\n    return cs[0]\n\ndef bfs(iw):\n    q = deque()\n    s = set()\n\n    s.add(str(iw))\n    q.append([iw, 0])\n    while q:\n        w, t = q.popleft()\n        if isOneColor(w):\n            return t\n        else:\n            for i in range(len(w)-1):\n                if w[i] != w[i+1]:\n                    nw = w.copy()\n                    nc = nextColor(nw[i], nw[i+1])\n                    nw[i], nw[i+1] = nc, nc\n                    if str(nw) not in s:\n                        s.add(str(nw))\n                        q.append([nw, t+1])\n\n    return -1\n\nif __name__ == '__main__':\n    while True:\n        w = list(input())\n        if w == ['0']:\n            break\n\n        t = bfs(w)\n        if t == -1:\n            print('NA')\n        else:\n            print(t)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef new_color(s, i, color):\n  return s[:i - 1] + color * 2 + s[i + 1:]\n\ndef solve(s):\n  length = len(s)\n  monos = [\"r\" * length, \"g\" * length, \"b\" * length]\n  if s in monos:\n    print(0)\n    return\n\n  another = {(\"r\", \"g\"):\"b\", (\"g\", \"r\"):\"b\", \n             (\"r\", \"b\"):\"g\", (\"b\", \"r\"):\"g\",\n             (\"g\", \"b\"):\"r\", (\"b\", \"g\"):\"r\"}\n  visited = {s:True}\n  que = deque()\n  app = que.append\n  pop = que.popleft\n  que.append((s, 0))\n\n  while que:\n    colors, score = pop()\n    score += 1\n    temp = colors[0]\n\n    for i in range(1, length):\n      ci = colors[i]\n      if ci != temp:\n        new = new_color(colors, i, another[(ci, temp)])\n        if new in monos:\n          print(score)\n          return\n\n        if new not in visited:\n          visited[new] = True\n          app((new, score))\n\n      temp = ci\n\n  print(\"NA\")\n\ndef main():\n  while True:\n    s = input()\n    if s == \"0\":\n      break\n    solve(s)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef another_color(a, b):\n    if not a == 'r' and not b == 'r':\n        return 'r'\n    if not a == 'g' and not b == 'g':\n        return 'g'\n    return 'b'\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def print(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.print()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n\n"
  },
  {
    "language": "Python",
    "code": "import Queue\n\ndef solve(worm):\n    dic = {\n        \"br\" : \"g\",\n        \"bg\" : \"r\",\n        \"gr\" : \"b\"\n    }\n    Q = Queue.Queue()\n    Q.put(worm)\n    dist = {}\n    dist[worm] = 0\n    ans = -1\n    while not Q.empty():\n        cur = Q.get()\n        if len(set(cur)) == 1:\n            ans = dist[cur]\n            break\n        for i in range(len(cur)-1):\n            if cur[i] != cur[i+1]:\n                nxt = list(cur)\n                color = dic[\"\".join(sorted(nxt[i:i+2]))]\n                nxt[i] = color\n                nxt[i+1] = color\n                nxt = \"\".join(nxt)\n                if not nxt in dist:\n                    dist[nxt] = dist[cur] + 1\n                    Q.put(nxt)\n    if ans == -1:\n        print \"NA\"\n    else:\n        print ans\n\ndef main():\n    while True:\n        s = raw_input()\n        if s == \"0\":\n            break\n        solve(s)\nmain()"
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = list(rgb-set(Worm[i:i+2]))[0]\n\t\t\t\t\tworm = Worm[:i] + 2*nextclr + Worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 15: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tque = [worm]\n\tref = set(worm)\n\tL = 1\n\tcnt = flag = 0\n\twhile 1:\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif Worm in ref: continue\n\t\t\telse: ref.add(Worm)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tworm = Worm[:]\n\t\t\t\t\tnextclr = list(rgb-set(worm[i:i+2]))[0]\n\t\t\t\t\tworm = worm[:i] + 2*nextclr + worm[i+2:]\n\t\t\t\t\tif worm not in que: que.append(worm)\n\t\tL = len(que)\n\t\tif flag or L == 0: break\n\t\tcnt += 1\n\t\tif cnt > 15: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef another_color(a, b):\n    if not a == 'r' and not b == 'r':\n        return 'r'\n    if not a == 'g' and not b == 'g':\n        return 'g'\n    return 'b'\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def show(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.show()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque,defaultdict\nT = {\"rg\":\"bb\",\"gr\":\"bb\",\n     \"rb\":\"gg\",\"br\":\"gg\",\n     \"gb\":\"rr\",\"bg\":\"rr\"}\ndef change(s):\n    for i in xrange(len(s)-1):\n        if s[i:i+2] in T:\n            yield \"\".join((s[:i],T[s[i:i+2]],s[i+2:]))\n\ndef BFS(s):\n    d = deque()\n    d.append((s,0))\n    visited = defaultdict(bool)\n    A = map(lambda c:len(s)*c, (\"r\",\"g\",\"b\"))\n    while len(d) > 0:\n        s,n = d.popleft()\n        if s in A:\n            return n\n        for ns in change(s):\n            if not visited[ns]:\n                d.append((ns,n+1))\n                visited[ns] = True\n    return \"NA\"\n\nwhile True:\n    s = raw_input()\n    if s == \"0\":\n        break\n    print BFS(s)"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\nwhile True:\n    s=raw_input()\n    if s==\"0\":break\n    s=s.replace(\"r\",\"0\")\n    s=s.replace(\"b\",\"1\")\n    s=s.replace(\"g\",\"2\")\n    Q=Queue()\n    visited=set()\n    visited.add(s)\n    Q.put((s,0))\n    while not Q.empty():\n        ptn,tim=Q.get()\n        if len(set(ptn))==1:\n            print tim\n            break\n        for i in range(len(ptn)-1):\n            if ptn[i]==ptn[i+1]:\n                continue\n            col1,col2=int(ptn[i]),int(ptn[i+1])\n            s=list(ptn)\n            if col1+col2==1:\n                s[i]=s[i+1]=\"2\"\n            elif col1+col2==2:\n                s[i]=s[i+1]=\"1\"\n            elif col1+col2==3:\n                s[i]=s[i+1]=\"0\"\n            s=\"\".join(s)\n            if s not in visited:\n                Q.put((s,tim+1))\n                visited.add(s)\n    else:\n        print \"NA\""
  },
  {
    "language": "Python",
    "code": "import Queue\ndic = {\n        'rg':'bb', 'gr':'bb',\n        'gb':'rr', 'bg':'rr',\n        'br':'gg', 'rb':'gg',\n        }\nwhile True:\n    s = raw_input()\n    if s=='0':\n        break\n    que = Queue.PriorityQueue()\n    l = len(s)\n    cost = {s: 0}\n    que.put((0, s))\n    aa = ['r'*l, 'g'*l, 'b'*l]\n    ans = -1\n    while not que.empty():\n        nn, ss = que.get()\n        if ss in aa:\n            ans = nn\n            break\n        if cost[ss] < nn:\n            continue\n        for i in xrange(l-1):\n            cc = ss[i:i+2]\n            if cc[0]!=cc[1]:\n                sa = ss[:i] + dic[cc] + ss[i+2:]\n                if sa not in cost or nn+1 < cost[sa]:\n                    cost[sa] = nn+1\n                    que.put((nn+1, sa))\n    print \"NA\" if ans<0 else ans"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef another_color(a, b):\n    if not a == 'r' and not b == 'r':\n        return 'r'\n    if not a == 'g' and not b == 'g':\n        return 'g'\n    return 'b'\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def show(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.show()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n\n"
  },
  {
    "language": "Python",
    "code": "rgb = set([\"r\",\"g\",\"b\"])\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tL = 1\n\tcnt = flag = 0\n\tqueset = set([worm])\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor r in range(L):\n\t\t\tWorm = que.pop(0)\n\t\t\tif len(set(Worm)) == 1:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tworm = Worm[:]\n\t\t\t\t\tnextclr = list(rgb-set(worm[i:i+2]))[0]\n\t\t\t\t\tworm = worm[:i] + 2*nextclr + worm[i+2:]\n\t\t\t\t\tqueset.add(worm)\n\t\tL = len(queset)\n\t\tif flag: break\n\t\tcnt += 1\n\t\tif cnt > 11: break\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef new_color(s, i, color):\n  return s[:i] + color * 2 + s[i + 2:]\n\ndef solve(s):\n  length = len(s)\n  monos = [\"r\" * length, \"g\" * length, \"b\" * length]\n  if s in monos:\n    print(0)\n    return\n  rgb = \"rgb\"\n  another = {(\"r\", \"g\"):\"b\", (\"g\", \"r\"):\"b\", \n             (\"r\", \"b\"):\"g\", (\"b\", \"r\"):\"g\",\n             (\"g\", \"b\"):\"r\", (\"b\", \"g\"):\"r\"}\n  dic = {s:0}\n  que = deque()\n  app = que.append\n  pop = que.popleft\n  que.append((s, 0))\n\n  while que:\n    colors, score = pop()\n    score += 1\n    temp = colors[0]\n\n    for i in range(1, length):\n      ci = colors[i]\n      if ci != temp:\n        new = new_color(colors, i - 1, another[(ci, temp)])\n\n        if new in monos:\n          print(score)\n          return\n\n        if new not in dic:\n          dic[new] = score\n          app((new, score))\n\n      temp = ci\n\n  print(\"NA\")\n\ndef main():\n  while True:\n    s = input()\n    if s == \"0\":\n      break\n    solve(s)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\ndef another_color(a, b):\n    if not a == 'r' and not b == 'r':\n        return 'r'\n    if not a == 'g' and not b == 'g':\n        return 'g'\n    return 'b'\n\n\ndef is_all_same_elements(es):\n    return all([e == es[0] for e in es[1:]]) if es else False\n\nclass State:\n    def __init__(self, sequence):\n        self.colors = list(sequence)\n        self.label = sequence\n        self.depth = 0\n\n    def nextStates(self):\n        nextStates = []\n        for i in range(1, len(self.colors)):\n            if self.colors[i] != self.colors[i - 1]:\n                c = another_color(self.colors[i], self.colors[i - 1])\n                newColors = copy.copy(self.colors)\n                newColors[i] = c\n                newColors[i - 1] = c\n                nextStates.append(State(''.join(newColors)))\n        return nextStates\n\n    def show(self):\n        print(self.depth)\n        # for debug\n#         print(\"{} {}\".format(self.label, self.depth))\n\n\nsequence = input()\nwhile sequence != '0':\n    root = State(sequence)\n    printed = False\n    visited = [root.label]\n    queue = deque([])\n    queue.append(root)\n    # BFS\n    while queue:\n        state = queue.popleft()\n        if is_all_same_elements(state.colors):\n            state.show()\n            printed = True\n            break\n        for nextState in state.nextStates():\n            if not nextState.label in visited:\n                visited.append(nextState.label)\n                nextState.depth = state.depth + 1\n                queue.append(nextState)\n\n    if not printed:\n        print(\"NA\")\n    # 次の行へ\n    sequence = input()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef only_color(s, monos):\n  if s in monos:\n    return True\n  else:\n    return False\n\ndef new_color(s, i, rgb):\n  for color in rgb:\n    if color != s[i] and color != s[i + 1]:\n      break\n  return s[:i] + color * 2 + s[i + 2:]\n\ndef solve(s):\n  length = len(s)\n  monos = [\"r\" * length, \"g\" * length, \"b\" * length]\n  if s in monos:\n    print(0)\n    return\n  dic = {s:0}\n  rgb = \"rgb\"\n  que = deque()\n  que.append((s, 0))\n\n  while que:\n    colors, score = que.popleft()\n    score += 1\n    temp = colors[0]\n    for i in range(1, length):\n      ci = colors[i]\n      if ci != temp:\n        new = new_color(colors, i - 1, rgb)\n\n        if new in monos:\n          print(score)\n          return\n\n        if new not in dic:\n          dic[new] = score\n          que.append((new, score))\n\n      temp = ci\n\n  print(\"NA\")\n\ndef main():\n  while True:\n    s = input()\n    if s == \"0\":\n      break\n    solve(s)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "dic = {\"r\":1,\"g\":2,\"b\":3}\nwhile 1:\n\tworm = raw_input()\n\tif worm == \"0\": break\n\tn = len(worm)\n\tref = [\"r\"*n,\"g\"*n,\"b\"*n]\n\tcnt = flag = 0\n\tqueset = set([worm])\n\tdone = set()\n\twhile 1:\n\t\tque = list(queset)\n\t\tqueset = set()\n\t\tfor Worm in que:\n\t\t\tif Worm in ref:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tfor i in range(n-1):\n\t\t\t\tif Worm[i] != Worm[i+1]:\n\t\t\t\t\tnextclr = \"rgb\"[5-dic[Worm[i]]-dic[Worm[i+1]]]\n\t\t\t\t\tqueset.add(Worm[:i] + 2*nextclr + Worm[i+2:])\n\t\tif flag or cnt > 14: break\n\t\tcnt += 1\n\t\tqueset -= done\n\t\tdone |= queset\n\tprint cnt if flag else \"NA\""
  },
  {
    "language": "Python",
    "code": "def change(s, n):\n  c = ['r', 'g', 'b']\n  a, b = s[n], s[n + 1]\n  if a == b:\n    return s\n  s = list(s)\n  c.remove(a)\n  c.remove(b)\n  s[n], s[n + 1] = c[0], c[0]\n  return ''.join(s)\n\nwhile True:\n  s = raw_input()\n  if s == '0':\n    break\n  \n  q = [(s, 0)]\n  mem = []\n  while len(q) > 0:\n    v, n = q.pop(0)\n    if v in mem:\n      continue\n    if v.count(v[0]) == len(v):\n      print(n)\n      break\n    mem.append(v)\n    for i in range(len(v) - 1):\n      vv = change(v, i)\n      if vv != v:\n        q.append((vv, n + 1))\n  else:\n    print('NA')"
  }
]