[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LEN 1000\n\nbool is_all_same(char *s, int len) {\n    for (int i = 1; i < len; i++) {\n        if (s[i] != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint simulate(char *s, int len) {\n    if (is_all_same(s, len)) {\n        return 0;\n    }\n\n    int time = 0;\n    char temp[MAX_LEN];\n    while (true) {\n        bool changed = false;\n        for (int i = 0; i < len; i++) {\n            int left = (i - 1 + len) % len;\n            int right = (i + 1) % len;\n            if (s[left] != s[right]) {\n                if (s[left] == 'r' && s[right] == 'g' || s[left] == 'g' && s[right] == 'r') {\n                    temp[i] = 'b';\n                } else if (s[left] == 'r' && s[right] == 'b' || s[left] == 'b' && s[right] == 'r') {\n                    temp[i] = 'g';\n                } else if (s[left] == 'g' && s[right] == 'b' || s[left] == 'b' && s[right] == 'g') {\n                    temp[i] = 'r';\n                }\n                changed = true;\n            } else {\n                temp[i] = s[i];\n            }\n        }\n        if (!changed) {\n            return -1;\n        }\n        time++;\n        strncpy(s, temp, len);\n        if (is_all_same(s, len)) {\n            return time;\n        }\n        if (time > MAX_LEN) {  // Prevent infinite loop\n            return -1;\n        }\n    }\n}\n\nint main() {\n    char s[MAX_LEN];\n    while (scanf(\"%s\", s) == 1) {\n        if (strcmp(s, \"0\") == 0) {\n            break;\n        }\n        int len = strlen(s);\n        char copy[MAX_LEN];\n        strncpy(copy, s, len);\n        int time = simulate(copy, len);\n        if (time == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", time);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CaterpillarColorChange {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            String segments = scanner.nextLine();\n            \n            if (segments.equals(\"0\")) {\n                break;\n            }\n            \n            int result = minimumColorChangeTime(segments);\n            \n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    public static int minimumColorChangeTime(String segments) {\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(segments);\n        visited.add(segments);\n        \n        int time = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            \n            for (int i = 0; i < size; i++) {\n                String current = queue.poll();\n                \n                if (isUniformColor(current)) {\n                    return time;\n                }\n                \n                for (int j = 0; j < current.length() - 1; j++) {\n                    if (current.charAt(j) != current.charAt(j + 1)) {\n                        String newSegments = changeAdjacentColors(current, j);\n                        \n                        if (!visited.contains(newSegments)) {\n                            queue.offer(newSegments);\n                            visited.add(newSegments);\n                        }\n                    }\n                }\n            }\n            \n            time++;\n        }\n        \n        return -1;\n    }\n    \n    public static boolean isUniformColor(String segments) {\n        char firstColor = segments.charAt(0);\n        \n        for (char color : segments.toCharArray()) {\n            if (color != firstColor) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public static String changeAdjacentColors(String segments, int index) {\n        char[] segmentArray = segments.toCharArray();\n        \n        if (segmentArray[index] == 'r' && segmentArray[index + 1] == 'g') {\n            segmentArray[index] = 'b';\n            segmentArray[index + 1] = 'b';\n        } else if (segmentArray[index] == 'r' && segmentArray[index + 1] == 'b') {\n            segmentArray[index] = 'g';\n            segmentArray[index + 1] = 'g';\n        } else if (segmentArray[index] == 'g' && segmentArray[index + 1] == 'r') {\n            segmentArray[index] = 'b';\n            segmentArray[index + 1] = 'b';\n        } else if (segmentArray[index] == 'g' && segmentArray[index + 1] == 'b') {\n            segmentArray[index] = 'r';\n            segmentArray[index + 1] = 'r';\n        } else if (segmentArray[index] == 'b' && segmentArray[index + 1] == 'r') {\n            segmentArray[index] = 'g';\n            segmentArray[index + 1] = 'g';\n        } else if (segmentArray[index] == 'b' && segmentArray[index + 1] == 'g') {\n            segmentArray[index] = 'r';\n            segmentArray[index + 1] = 'r';\n        }\n        \n        return new String(segmentArray);\n    }\n}",
    "timestamp": "2025-08-05 18:34:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstruct State {\n    string segments;\n    int time;\n};\n\nbool isUniform(const string& s) {\n    if (s.empty()) return true;\n    char first = s[0];\n    for (char c : s) {\n        if (c != first) return false;\n    }\n    return true;\n}\n\nstring transition(const string& s) {\n    string next;\n    int n = s.size();\n    for (int i = 0; i < n; ++i) {\n        char left = s[(i - 1 + n) % n];\n        char right = s[(i + 1) % n];\n        if (left != right) {\n            if (left != 'r' && right != 'r') next += 'r';\n            else if (left != 'g' && right != 'g') next += 'g';\n            else if (left != 'b' && right != 'b') next += 'b';\n        } else {\n            next += s[i];\n        }\n    }\n    return next;\n}\n\nint solve(const string& initial) {\n    if (isUniform(initial)) return 0;\n\n    queue<State> q;\n    set<string> visited;\n\n    q.push({initial, 0});\n    visited.insert(initial);\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        string next = transition(current.segments);\n        if (isUniform(next)) {\n            return current.time + 1;\n        }\n\n        if (visited.find(next) == visited.end()) {\n            visited.insert(next);\n            q.push({next, current.time + 1});\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    string s;\n    while (cin >> s) {\n        if (s == \"0\") break;\n        int res = solve(s);\n        if (res == -1) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SEGMENTS 100\n\nint min_color_time(char* segments) {\n    int len = strlen(segments);\n    int min_time = INT_MAX;\n    char colors[] = {'r', 'g', 'b'};\n\n    for (int target_color = 0; target_color < 3; target_color++) {\n        int curr_time = 0;\n        char temp[MAX_SEGMENTS + 1];\n        strcpy(temp, segments);\n\n        for (int i = 0; i < len; i++) {\n            if (temp[i] != colors[target_color]) {\n                curr_time++;\n                if (i > 0 && temp[i-1] != colors[target_color]) {\n                    temp[i-1] = colors[target_color];\n                }\n                temp[i] = colors[target_color];\n            }\n        }\n\n        int all_same = 1;\n        for (int i = 0; i < len; i++) {\n            if (temp[i] != colors[target_color]) {\n                all_same = 0;\n                break;\n            }\n        }\n\n        if (all_same && curr_time < min_time) {\n            min_time = curr_time;\n        }\n    }\n\n    return min_time == INT_MAX ? -1 : min_time;\n}\n\nint main() {\n    char segments[MAX_SEGMENTS + 1];\n\n    while (1) {\n        scanf(\"%s\", segments);\n        \n        if (strcmp(segments, \"0\") == 0) {\n            break;\n        }\n\n        int result = min_color_time(segments);\n        \n        if (result == -1) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nint solve(string segments) {\n    queue<pair<string, int>> q;\n    unordered_set<string> visited;\n    q.push({segments, 0});\n    \n    while (!q.empty()) {\n        string current = q.front().first;\n        int time = q.front().second;\n        q.pop();\n        \n        bool allSame = true;\n        for (char c : current) {\n            if (c != current[0]) {\n                allSame = false;\n                break;\n            }\n        }\n        \n        if (allSame) return time;\n        \n        if (visited.count(current)) continue;\n        visited.insert(current);\n        \n        for (int i = 0; i < current.length() - 1; ++i) {\n            if (current[i] != current[i+1]) {\n                string next = current;\n                next[i] = next[i+1] = (current[i] == 'r' ? \n                    (current[i+1] == 'g' ? 'b' : 'g') : \n                    (current[i] == 'g' ? \n                    (current[i+1] == 'r' ? 'b' : 'r') : \n                    (current[i+1] == 'g' ? 'r' : 'g')));\n                \n                q.push({next, time + 1});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    string input;\n    while (cin >> input && input != \"0\") {\n        int result = solve(input);\n        if (result == -1) \n            cout << \"NA\" << endl;\n        else \n            cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CaterpillarColor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String s = scanner.next();\n            if (s.equals(\"0\")) {\n                break;\n            }\n            System.out.println(computeMinTime(s));\n        }\n        scanner.close();\n    }\n\n    private static String computeMinTime(String s) {\n        Set<Character> uniqueColors = new HashSet<>();\n        for (char c : s.toCharArray()) {\n            uniqueColors.add(c);\n        }\n        if (uniqueColors.size() == 1) {\n            return \"0\";\n        }\n        if (uniqueColors.size() == 2) {\n            char[] colors = new char[2];\n            int index = 0;\n            for (char c : uniqueColors) {\n                colors[index++] = c;\n            }\n            int time1 = simulate(s, colors[0]);\n            int time2 = simulate(s, colors[1]);\n            if (time1 == -1 && time2 == -1) {\n                return \"NA\";\n            } else if (time1 == -1) {\n                return Integer.toString(time2);\n            } else if (time2 == -1) {\n                return Integer.toString(time1);\n            } else {\n                return Integer.toString(Math.min(time1, time2));\n            }\n        } else {\n            int timeR = simulate(s, 'r');\n            int timeG = simulate(s, 'g');\n            int timeB = simulate(s, 'b');\n            int minTime = Integer.MAX_VALUE;\n            if (timeR != -1) {\n                minTime = Math.min(minTime, timeR);\n            }\n            if (timeG != -1) {\n                minTime = Math.min(minTime, timeG);\n            }\n            if (timeB != -1) {\n                minTime = Math.min(minTime, timeB);\n            }\n            if (minTime == Integer.MAX_VALUE) {\n                return \"NA\";\n            } else {\n                return Integer.toString(minTime);\n            }\n        }\n    }\n\n    private static int simulate(String s, char target) {\n        String current = s;\n        int time = 0;\n        while (true) {\n            if (allSame(current, target)) {\n                return time;\n            }\n            StringBuilder next = new StringBuilder();\n            for (int i = 0; i < current.length() - 1; i++) {\n                char left = current.charAt(i);\n                char right = current.charAt(i + 1);\n                if (left == right) {\n                    next.append(left);\n                } else {\n                    next.append(getNewColor(left, right));\n                }\n            }\n            if (current.equals(next.toString())) {\n                return -1;\n            }\n            current = next.toString();\n            time++;\n        }\n    }\n\n    private static boolean allSame(String s, char target) {\n        for (char c : s.toCharArray()) {\n            if (c != target) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static char getNewColor(char left, char right) {\n        if ((left == 'r' && right == 'g') || (left == 'g' && right == 'r')) {\n            return 'b';\n        } else if ((left == 'r' && right == 'b') || (left == 'b' && right == 'r')) {\n            return 'g';\n        } else {\n            return 'r';\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:35:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_time_to_same_color(caterpillar):\n    # Define the order of colors for transformation\n    color_order = 'rgb'\n    \n    # Check all possible target colors\n    min_time = float('inf')\n    for target in color_order:\n        time = 0\n        for i in range(1, len(caterpillar)):\n            if caterpillar[i] != target:\n                if caterpillar[i] == caterpillar[i-1]:\n                    return 'NA'\n                time += 1\n        min_time = min(min_time, time)\n    \n    return min_time if min_time != float('inf') else 'NA'\n\n\ndef process_datasets():\n    import sys\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    results = []\n    for line in data:\n        if line == '0':\n            break\n        if line:\n            result = min_time_to_same_color(line)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nprocess_datasets()",
    "timestamp": "2025-08-12 23:52:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CaterpillarColorChange {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String input = scanner.nextLine().trim();\n            if (input.equals(\"0\")) {\n                break;\n            }\n            System.out.println(minimumTimeToSameColor(input));\n        }\n        scanner.close();\n    }\n\n    private static String minimumTimeToSameColor(String configuration) {\n        int n = configuration.length();\n        int[][] dp = new int[n][3];\n        int maxTime = n * n;\n        \n        // Initialize dp array\n        for (int i = 0; i < n; i++) {\n            char c = configuration.charAt(i);\n            dp[i][0] = (c == 'r') ? 0 : maxTime;\n            dp[i][1] = (c == 'g') ? 0 : maxTime;\n            dp[i][2] = (c == 'b') ? 0 : maxTime;\n        }\n\n        for (int k = 0; k < maxTime; k++) {\n            int[][] tempDp = new int[n][3];\n            boolean changed = false;\n            for (int i = 0; i < n; i++) {\n                tempDp[i][0] = dp[i][0];\n                tempDp[i][1] = dp[i][1];\n                tempDp[i][2] = dp[i][2];\n\n                if (i > 0) {\n                    tempDp[i][0] = Math.min(tempDp[i][0], 1 + Math.min(dp[i - 1][1], dp[i - 1][2]));\n                    tempDp[i][1] = Math.min(tempDp[i][1], 1 + Math.min(dp[i - 1][0], dp[i - 1][2]));\n                    tempDp[i][2] = Math.min(tempDp[i][2], 1 + Math.min(dp[i - 1][0], dp[i - 1][1]));\n                }\n                if (i < n - 1) {\n                    tempDp[i][0] = Math.min(tempDp[i][0], 1 + Math.min(dp[i + 1][1], dp[i + 1][2]));\n                    tempDp[i][1] = Math.min(tempDp[i][1], 1 + Math.min(dp[i + 1][0], dp[i + 1][2]));\n                    tempDp[i][2] = Math.min(tempDp[i][2], 1 + Math.min(dp[i + 1][0], dp[i + 1][1]));\n                }\n\n                if (tempDp[i][0] != dp[i][0] || tempDp[i][1] != dp[i][1] || tempDp[i][2] != dp[i][2]) {\n                    changed = true;\n                }\n            }\n            dp = tempDp;\n            if (!changed) {\n                break;\n            }\n        }\n\n        int minTime = Math.min(dp[0][0], Math.min(dp[0][1], dp[0][2]));\n        for (int i = 1; i < n; i++) {\n            minTime = Math.min(minTime, dp[i][0]);\n            minTime = Math.min(minTime, dp[i][1]);\n            minTime = Math.min(minTime, dp[i][2]);\n        }\n\n        return minTime == maxTime ? \"NA\" : String.valueOf(minTime);\n    }\n}",
    "timestamp": "2025-08-12 23:53:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool canBecomeUniform(const char *config) {\n    int countR = 0, countG = 0, countB = 0;\n    int n = strlen(config);\n    \n    for (int i = 0; i < n; i++) {\n        if (config[i] == 'r') countR++;\n        else if (config[i] == 'g') countG++;\n        else if (config[i] == 'b') countB++;\n    }\n    \n    return countR == n || countG == n || countB == n || countR == countG && countR + countG == n || \n           countR == countB && countR + countB == n || countG == countB && countG + countB == n;\n}\n\nint minTimeToUniform(const char *config) {\n    int n = strlen(config);\n    if (n <= 1) return 0;\n    \n    if (!canBecomeUniform(config)) return -1;\n    \n    int time = 0;\n    char temp[n + 1];\n    strcpy(temp, config);\n    \n    while (!canBecomeUniform(temp)) {\n        char next[n + 1];\n        for (int i = 0; i < n; i++) {\n            if (temp[i] == temp[(i + 1) % n]) next[i] = temp[i];\n            else {\n                if ((temp[i] == 'r' && temp[(i + 1) % n] == 'g') || (temp[i] == 'g' && temp[(i + 1) % n] == 'r')) next[i] = 'b';\n                else if ((temp[i] == 'r' && temp[(i + 1) % n] == 'b') || (temp[i] == 'b' && temp[(i + 1) % n] == 'r')) next[i] = 'g';\n                else if ((temp[i] == 'g' && temp[(i + 1) % n] == 'b') || (temp[i] == 'b' && temp[(i + 1) % n] == 'g')) next[i] = 'r';\n            }\n        }\n        strcpy(temp, next);\n        time++;\n    }\n    \n    return time;\n}\n\nint main() {\n    char caterpillar[100];\n    \n    while (scanf(\"%s\", caterpillar) && strcmp(caterpillar, \"0\") != 0) {\n        int result = minTimeToUniform(caterpillar);\n        if (result == -1) printf(\"NA\\n\");\n        else printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-12 23:53:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_caterpillar(colors):\n    n = len(colors)\n    if n == 1:\n        return 0\n    \n    min_time = float('inf')\n    \n    for target_color in ['r', 'g', 'b']:\n        time = 0\n        current = list(colors)\n        \n        for i in range(n):\n            if current[i] != target_color:\n                time += 1\n                \n                if i > 0 and current[i-1] != target_color:\n                    current[i-1] = target_color\n                \n                if i < n-1 and current[i+1] != target_color:\n                    current[i+1] = target_color\n                \n                current[i] = target_color\n        \n        if all(color == target_color for color in current):\n            min_time = min(min_time, time)\n    \n    return min_time if min_time != float('inf') else 'NA'\n\ndef main():\n    while True:\n        colors = input().strip()\n        \n        if colors == '0':\n            break\n        \n        result = solve_caterpillar(colors)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:53:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    while True:\n        s = input().strip()\n        if s == '0':\n            break\n        visited = set()\n        queue = deque()\n        queue.append((s, 0))\n        visited.add(s)\n        found = False\n        while queue:\n            current, time = queue.popleft()\n            if all(c == current[0] for c in current):\n                print(time)\n                found = True\n                break\n            next_state = []\n            for i in range(len(current)):\n                left = current[i-1] if i > 0 else None\n                right = current[i+1] if i < len(current)-1 else None\n                if left is not None and right is not None and left != right:\n                    # Determine the new color\n                    colors = {'r', 'g', 'b'}\n                    colors.discard(left)\n                    colors.discard(right)\n                    new_color = colors.pop() if len(colors) == 1 else None\n                    if new_color:\n                        next_state.append(new_color)\n                    else:\n                        next_state.append(current[i])\n                else:\n                    next_state.append(current[i])\n            next_str = ''.join(next_state)\n            if next_str not in visited:\n                visited.add(next_str)\n                queue.append((next_str, time + 1))\n        if not found:\n            print(\"NA\")\n\nsolve()",
    "timestamp": "2025-08-12 23:53:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint minTimeToSameColor(string segments) {\n    auto isUniform = [&](const string &s) {\n        return all_of(s.begin(), s.end(), [&](char c) { return c == s.front(); });\n    };\n\n    int n = segments.size();\n    vector<int> curr(n), next(n);\n\n    for (int i = 0; i < n; ++i) {\n        curr[i] = segments[i] == 'r' ? 0 : segments[i] == 'g' ? 1 : 2;\n    }\n\n    int time = 0;\n    while (!isUniform(segments)) {\n        for (int i = 0; i < n; ++i) {\n            next[i] = curr[i];\n            if (i > 0 && curr[i] != curr[i - 1]) {\n                next[i] = (curr[i] + 1) % 3;\n            }\n            if (i < n - 1 && curr[i] != curr[i + 1]) {\n                next[i] = (curr[i] + 1) % 3;\n            }\n        }\n\n        if (next == curr) {\n            return -1;  // If no change happens, it's impossible to become uniform\n        }\n\n        curr = next;\n        ++time;\n    }\n\n    return time;\n}\n\nint main() {\n    string segments;\n    \n    while (true) {\n        getline(cin, segments);\n        if (segments == \"0\") break;\n\n        int result = minTimeToSameColor(segments);\n        if (result == -1) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:51:41"
  }
]