[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_HEROES 1000\n\ntypedef struct {\n    double x, y;\n} Hero;\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n}\n\nint can_cover_all_heroes(Hero heroes[], int n, double radius, int m) {\n    int covered[MAX_HEROES] = {0};\n    int spells_used = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!covered[i]) {\n            if (spells_used >= m) return 0;\n            \n            spells_used++;\n            for (int j = 0; j < n; j++) {\n                if (distance(heroes[i].x, heroes[i].y, heroes[j].x, heroes[j].y) <= radius) {\n                    covered[j] = 1;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\ndouble find_minimum_radius(Hero heroes[], int n, int m) {\n    double low = 0, high = 10000;\n    \n    while (high - low > 1e-6) {\n        double mid = (low + high) / 2;\n        \n        if (can_cover_all_heroes(heroes, n, mid, m)) {\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n    \n    return low;\n}\n\nint main() {\n    int n, m;\n    Hero heroes[MAX_HEROES];\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &heroes[i].x, &heroes[i].y);\n    }\n    \n    double min_radius = find_minimum_radius(heroes, n, m);\n    \n    printf(\"%.6f\\n\", min_radius);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nPoint heroes[100000];\nint N, M;\n\ndouble distance(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nint canCover(double r) {\n    int used = 0;\n    Point center;\n    for (int i = 0; i < N; ++i) {\n        if (used == 0 || distance(center, heroes[i]) > r) {\n            center = heroes[i];\n            used++;\n            if (used > M) return 0;\n        }\n    }\n    return 1;\n}\n\ndouble solve() {\n    double left = 0.0;\n    double right = 1e9;\n    for (int iter = 0; iter < 100; ++iter) {\n        double mid = (left + right) / 2;\n        if (canCover(mid)) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n    return left;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%lf %lf\", &heroes[i].x, &heroes[i].y);\n    }\n    printf(\"%.6f\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> point;\n\nll squared_distance(point a, point b) {\n    ll dx = a.first - b.first;\n    ll dy = a.second - b.second;\n    return dx * dx + dy * dy;\n}\n\nbool is_possible(vector<point>& heroes, int m, ll r_squared) {\n    vector<bool> covered(heroes.size(), false);\n    int remaining = heroes.size();\n    \n    for (int i = 0; i < m && remaining > 0; ++i) {\n        point best_point;\n        int best_count = 0;\n        \n        for (int j = 0; j < heroes.size(); ++j) {\n            if (covered[j]) continue;\n            point center = heroes[j];\n            int count = 0;\n            for (int k = 0; k < heroes.size(); ++k) {\n                if (covered[k]) continue;\n                if (squared_distance(center, heroes[k]) <= r_squared) {\n                    count++;\n                }\n            }\n            if (count > best_count) {\n                best_count = count;\n                best_point = center;\n            }\n        }\n        \n        for (int j = 0; j < heroes.size(); ++j) {\n            if (!covered[j] && squared_distance(best_point, heroes[j]) <= r_squared) {\n                covered[j] = true;\n                remaining--;\n            }\n        }\n    }\n    \n    return remaining == 0;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<point> heroes(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> heroes[i].first >> heroes[i].second;\n    }\n    \n    ll left = 0;\n    ll right = 1LL << 62;\n    ll answer = right;\n    \n    while (left <= right) {\n        ll mid = left + (right - left) / 2;\n        if (is_possible(heroes, m, mid)) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    cout << answer << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int[][] heroes = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            heroes[i][0] = sc.nextInt();\n            heroes[i][1] = sc.nextInt();\n        }\n\n        long left = 0;\n        long right = (long) 2e18;\n        long answer = right;\n\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            if (canCoverAll(heroes, M, mid)) {\n                answer = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        System.out.println(answer);\n    }\n\n    private static boolean canCoverAll(int[][] heroes, int M, long r) {\n        int N = heroes.length;\n        boolean[] covered = new boolean[N];\n        int count = 0;\n\n        for (int i = 0; i < N; i++) {\n            if (!covered[i]) {\n                count++;\n                if (count > M) {\n                    return false;\n                }\n                long x = heroes[i][0];\n                long y = heroes[i][1];\n                for (int j = 0; j < N; j++) {\n                    long dx = heroes[j][0] - x;\n                    long dy = heroes[j][1] - y;\n                    if (dx * dx + dy * dy <= r) {\n                        covered[j] = true;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 22:08:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static double minRadius(int[][] heroes, int M) {\n        int N = heroes.length;\n        if (M >= N) return 0.0;\n        \n        List<Point> points = new ArrayList<>();\n        for (int[] hero : heroes) {\n            points.add(new Point(hero[0], hero[1]));\n        }\n        \n        double low = 0, high = 2000;\n        while (high - low > 1e-6) {\n            double mid = (low + high) / 2;\n            if (canCoverAll(points, mid, M)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        \n        return low;\n    }\n    \n    private static boolean canCoverAll(List<Point> points, double radius, int M) {\n        boolean[] covered = new boolean[points.size()];\n        return backtrack(points, covered, radius, M, 0);\n    }\n    \n    private static boolean backtrack(List<Point> points, boolean[] covered, double radius, int M, int count) {\n        if (count == points.size()) return true;\n        \n        if (M == 0) return false;\n        \n        for (int i = 0; i < points.size(); i++) {\n            if (covered[i]) continue;\n            \n            List<Integer> toCover = new ArrayList<>();\n            for (int j = 0; j < points.size(); j++) {\n                if (!covered[j] && dist(points.get(i), points.get(j)) <= radius) {\n                    toCover.add(j);\n                }\n            }\n            \n            for (int idx : toCover) {\n                covered[idx] = true;\n            }\n            \n            if (backtrack(points, covered, radius, M - 1, count + tocover.size())) {\n                return true;\n            }\n            \n            for (int idx : tocover) {\n                covered[idx] = false;\n            }\n        }\n        \n        return false;\n    }\n    \n    private static double dist(Point a, Point b) {\n        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    \n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[][] heroes = {{1,2}, {3,4}, {5,6}};\n        int M = 2;\n        System.out.println(minRadius(heroes, M));\n    }\n}",
    "timestamp": "2025-08-05 22:08:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nbool can_eliminate_all(const vector<Point>& heroes, double radius, int m) {\n    int n = heroes.size();\n    vector<bool> eliminated(n, false);\n    int eliminated_count = 0;\n\n    for (int i = 0; i < n && m > 0; ++i) {\n        if (eliminated[i]) continue;\n\n        for (int j = 0; j < n; ++j) {\n            if (!eliminated[j] && distance(heroes[i], heroes[j]) <= radius) {\n                eliminated[j] = true;\n                eliminated_count++;\n            }\n        }\n\n        m--;\n    }\n\n    return eliminated_count == n;\n}\n\ndouble find_minimum_radius(const vector<Point>& heroes, int m) {\n    double left = 0, right = 2000.0;\n    \n    while (right - left > 1e-6) {\n        double mid = (left + right) / 2.0;\n        \n        if (can_eliminate_all(heroes, mid, m)) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n    \n    return left;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Point> heroes(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> heroes[i].x >> heroes[i].y;\n    }\n    \n    cout << fixed << setprecision(10) << find_minimum_radius(heroes, m) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_eliminate_all_heroes_with_radius(heroes, M, radius):\n    import math\n    remaining_heroes = set(heroes)\n    while M > 0 and remaining_heroes:\n        max_count = 0\n        best_center = None\n        for hx, hy in remaining_heroes:\n            count = 0\n            for x, y in remaining_heroes:\n                if math.sqrt((hx - x) ** 2 + (hy - y) ** 2) <= radius:\n                    count += 1\n            if count > max_count:\n                max_count = count\n                best_center = (hx, hy)\n\n        if best_center:\n            cx, cy = best_center\n            new_remaining_heroes = set()\n            for x, y in remaining_heroes:\n                if math.sqrt((cx - x) ** 2 + (cy - y) ** 2) > radius:\n                    new_remaining_heroes.add((x, y))\n            remaining_heroes = new_remaining_heroes\n        \n        M -= 1\n\n    return not remaining_heroes\n\ndef find_minimum_radius(heroes, M):\n    import math\n    \n    low, high = 0.0, max(math.dist((hx, hy), (0, 0)) for hx, hy in heroes)\n    tolerance = 1e-7\n    \n    while high - low > tolerance:\n        mid = (low + high) / 2.0\n        if can_eliminate_all_heroes_with_radius(heroes, M, mid):\n            high = mid\n        else:\n            low = mid\n    \n    return high\n\n# Input example: (N = number of heroes, M = number of spells)\nN = 4\nM = 2\nheroes = [(1, 3), (2, 8), (5, 4), (6, 9)]\n\n# Output radius\nprint(find_minimum_radius(heroes, M))",
    "timestamp": "2025-08-13 09:03:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class DemonKing {\n    static class Hero {\n        int x, y;\n        Hero(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt(); // number of heroes\n        int M = scanner.nextInt(); // number of explosion spells\n        Hero[] heroes = new Hero[N];\n        \n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            heroes[i] = new Hero(x, y);\n        }\n        \n        double left = 0;\n        double right = 2000000; // an upper bound for the binary search\n        \n        // Binary search for the minimum radius\n        while (right - left > 1e-6) {\n            double mid = (left + right) / 2.0;\n            if (canEliminateAllHeroes(heroes, N, M, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        \n        System.out.printf(\"%.6f\\n\", right);\n        scanner.close();\n    }\n    \n    private static boolean canEliminateAllHeroes(Hero[] heroes, int N, int M, double r) {\n        boolean[] eliminated = new boolean[N];\n        int eliminatedCount = 0;\n        \n        for (int i = 0; i < M; i++) {\n            if (eliminatedCount >= N) {\n                return true;\n            }\n            \n            int nextIndex = -1;\n            for (int j = 0; j < N; j++) {\n                if (!eliminated[j]) {\n                    nextIndex = j;\n                    break;\n                }\n            }\n            \n            Hero center = heroes[nextIndex];\n            for (int j = 0; j < N; j++) {\n                if (!eliminated[j] && distance(center, heroes[j]) <= r) {\n                    eliminated[j] = true;\n                    eliminatedCount++;\n                }\n            }\n        }\n        \n        return eliminatedCount >= N;\n    }\n    \n    private static double distance(Hero a, Hero b) {\n        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n}",
    "timestamp": "2025-08-13 09:03:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n// Structure to represent a hero's position\ntypedef struct {\n    int x, y;\n} Hero;\n\n// Function to calculate square of the distance between two points\ndouble distance_sqr(Hero a, Hero b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\n// Check if with radius 'r' and 'm' explosions we can cover all heroes\nint can_cover_all(Hero heroes[], int n, int m, double r) {\n    int covered[n];\n    for (int i = 0; i < n; i++) {\n        covered[i] = 0;\n    }\n    \n    for (int count = 0; count < m; count++) {\n        int best = -1;\n        for (int i = 0; i < n; i++) {\n            if (!covered[i]) {\n                int current_covered = 0;\n                for (int j = 0; j < n; j++) {\n                    if (!covered[j] && distance_sqr(heroes[i], heroes[j]) <= r) {\n                        current_covered++;\n                    }\n                }\n                if (best == -1 || current_covered > covered[best]) {\n                    best = i;\n                    covered[best] = current_covered;\n                }\n            }\n        }\n        \n        if (best == -1) break;\n        \n        for (int i = 0; i < n; i++) {\n            if (!covered[i] && distance_sqr(heroes[best], heroes[i]) <= r) {\n                covered[i] = 1;\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!covered[i]) return 0;\n    }\n    return 1;\n}\n\n// Function to find the smallest possible radius\ndouble find_smallest_radius(Hero heroes[], int n, int m) {\n    double low = 0.0, high = 100000.0;\n    while (high - low > 1e-6) {\n        double mid = (low + high) / 2.0;\n        if (can_cover_all(heroes, n, m, mid * mid)) { // Check the square of the radius\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n    return high;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Hero heroes[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &heroes[i].x, &heroes[i].y);\n    }\n    \n    double result = find_smallest_radius(heroes, n, m);\n    printf(\"%lf\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:03:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_explosion_radius(heroes, M):\n    def count_heroes_covered(center, radius):\n        return sum(1 for hero in heroes if ((hero[0] - center[0])**2 + (hero[1] - center[1])**2) <= radius**2)\n    \n    def can_cover_all_heroes(radius):\n        from itertools import combinations\n        \n        if M == 1:\n            return any(count_heroes_covered(hero, radius) == len(heroes) for hero in heroes)\n        \n        if M == 2:\n            for hero1, hero2 in combinations(heroes, 2):\n                center_x = (hero1[0] + hero2[0]) / 2\n                center_y = (hero1[1] + hero2[1]) / 2\n                \n                if count_heroes_covered((center_x, center_y), radius) == len(heroes):\n                    return True\n        \n        return False\n    \n    left, right = 0, 10**9\n    while left < right:\n        mid = (left + right) / 2\n        \n        if can_cover_all_heroes(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Input parsing\nN, M = map(int, input().split())\nheroes = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Output solution\nprint(\"{:.5f}\".format(solve_explosion_radius(heroes, M)))",
    "timestamp": "2025-08-13 09:03:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef can_eliminate_all(heroes, m, r):\n    used = 0\n    i = 0\n    n = len(heroes)\n    while i < n:\n        used += 1\n        if used > m:\n            return False\n        pos = heroes[i] + r\n        while i < n and heroes[i] <= pos + r:\n            i += 1\n    return True\n\ndef minimal_explosion_radius():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    heroes = list(map(int, data[2:2+n]))\n    heroes.sort()\n    \n    left = 0\n    right = heroes[-1] - heroes[0]\n    answer = right\n    \n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if can_eliminate_all(heroes, m, mid):\n            answer = mid\n            right = mid\n        else:\n            left = mid\n    \n    print(\"{0:.6f}\".format(answer))\n\nminimal_explosion_radius()",
    "timestamp": "2025-08-13 09:04:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nbool canEliminateAll(const vector<pair<int, int>>& heroes, int M, double r) {\n    int n = heroes.size();\n    vector<bool> eliminated(n, false);\n    int eliminatedCount = 0, spellsUsed = 0;\n\n    while(eliminatedCount < n && spellsUsed < M) {\n        double maxReach = -1;\n        int nextHero = -1;\n\n        for(int i = 0; i < n; ++i) {\n            if(!eliminated[i]) {\n                double reachCount = 0;\n                for(int j = 0; j < n; ++j) {\n                    if(!eliminated[j]) {\n                        double dist = hypot(heroes[i].first - heroes[j].first, \n                                            heroes[i].second - heroes[j].second);\n                        if(dist <= r) ++reachCount;\n                    }\n                }\n                if(reachCount > maxReach) {\n                    maxReach = reachCount;\n                    nextHero = i;\n                }\n            }\n        }\n\n        if(nextHero == -1) break;\n\n        for(int i = 0; i < n; ++i) {\n            if(!eliminated[i]) {\n                double dist = hypot(heroes[nextHero].first - heroes[i].first, \n                                    heroes[nextHero].second - heroes[i].second);\n                if(dist <= r) {\n                    eliminated[i] = true;\n                    ++eliminatedCount;\n                }\n            }\n        }\n        ++spellsUsed;\n    }\n\n    return eliminatedCount == n;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> heroes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> heroes[i].first >> heroes[i].second;\n    }\n\n    double low = 0.0, high = 2e6;\n    for(int iter = 0; iter < 100; ++iter) {\n        double mid = (low + high) / 2;\n        if(canEliminateAll(heroes, M, mid)) {\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n    \n    cout.precision(10);\n    cout << fixed << low << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:23"
  }
]