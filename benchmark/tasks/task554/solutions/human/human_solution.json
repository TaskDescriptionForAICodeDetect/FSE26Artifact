[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist(double px, double py, double qx, double qy) {\n  return sqrt((px - qx) * (px - qx) + (py - qy) * (py - qy));\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] / 100000000;\n    Y[i] = P[i] % 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n    ll cnt = 0;\n    REP(i, 0, N) if(s & (1LL << i)) cnt++;\n    if(cnt < 2) {\n      radius[s] = 0.0;\n      continue;\n    }\n\n    double minr = 1e20;\n    REP(i, 0, N) REP(j, i + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)))) continue;\n\n      double d = dist(X[i], Y[i], X[j], Y[j]) / 2.0;\n      double dx = +(Y[i] - Y[j]) / (d * 2.0);\n      double dy = -(X[i] - X[j]) / (d * 2.0);\n      double mx = (X[i] + X[j]) / 2.0;\n      double my = (Y[i] + Y[j]) / 2.0;\n\n      bool ok = true;\n      REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], mx, my) > d + EPS) ok = false;\n      if(ok) {\n        minr = min(minr, d);\n        continue;\n      }\n\n      double l1 = d, h1 = 1e20;\n      REP(_, 0, 50) {\n        double m = (l1 + h1) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c1x = mx + dx * t;\n        double c1y = my + dy * t;\n        bool ok1 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c1x, c1y) > m + EPS) ok1 = false;\n\n        (ok1 ? h1 : l1) = m;\n      }\n\n      double l2 = d, h2 = 1e20;\n      REP(_, 0, 50) {\n        double m = (l2 + h2) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c2x = mx - dx * t;\n        double c2y = my - dy * t;\n        bool ok2 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c2x, c2y) > m + EPS) ok2 = false;\n\n        (ok2 ? h2 : l2) = m;\n      }\n\n      minr = min(minr, min(h1, h2));\n    }\n    radius[s] = minr;\n  }\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e20));\n  dp[0][0] = 0.0;\n  REP(s, 0, 1LL << N) REP(i, 0, M) {\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e20;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 円の内外判定\n//  2 => out : 0 => on : 1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n// 凸包 : 凸多角形のある一辺上にある点を含まない\n/*\n Polygon convex_hull(vector<Point> ps) {\n int n = ps.size();\n int k = 0;\n sort(ps.begin(), ps.end());\n Polygon ch(2 * n);\n for (int i = 0; i < n; ch[k++] = ps[i++])\n while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n ch.resize(k - 1);\n return ch;\n }\n */\n// 凸多角形の直径\nld convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    ld res = abs(poly[ii] - poly[jj]);\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    do{\n        if(cross(poly[(i+1)%n] - poly[i],poly[(j+1)%n] - poly[j]) >= 0) j = (j+1)%n;\n        else i = (i+1)%n;\n        if(abs(poly[i] - poly[j]) > res){\n            res = abs(poly[i] - poly[j]);\n            maxi = i; maxj = j;\n        }\n    }while(i != ii || j != jj);\n    return res;\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\ntypedef Point P;\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right, int seed = 1333) {\n    const int n = right - left;\n    \n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n    \n    std::mt19937 mt(seed);\n    std::shuffle(left, right, mt);\n    // std::random_shuffle(left, right); // simple but deprecated\n    \n    iter ps = left;\n    using circle = std::pair<P, ld>;\n    \n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n        S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n    \n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n    \n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n    \n    circle c = make_circle_2(ps[0], ps[1]);\n    \n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\n#define MAX_N 15\n#define MAX_M 15\nll N,M;\nPoint p[MAX_N];\n\n// dp[S][cnt] := 死んでいる勇者がSでcnt回爆発を行なっている時の最小半径\nld dp[1<<MAX_N][MAX_M];\n\n\nvector<pair<ld,ll>> St;\nvoid init(){\n    for(int i = 0;i < (1<<MAX_N);i++)for(int j = 0;j < MAX_M;j++) dp[i][j] = -1;\n}\n\nld rec(ll S,ll cnt){\n    ld& res = dp[S][cnt];\n    if(S==((1<<N)-1)) return 0;\n    if(cnt==M) return LINF;\n    if(!(res < 0)) return res;\n    res = LINF;\n    for(int i = 0; i < St.size();i++){\n        if(S == (S|St[i].second)) continue;\n        res = min(res,max(St[i].first,rec(S|St[i].second,cnt+1)));\n    }\n    return res;\n}\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cin >> N >> M;\n    for(int i = 0; i < N;i++) p[i] = input_point();\n    \n    // 最小包含円\n    for(int i = 1; i < (1<<N);i++){\n        vector<P> tp;\n        for(int j = 0; j < N;j++){\n            if((i>>j)&1){\n                tp.push_back(p[j]);\n            }\n        }\n        auto c = min_ball(tp.begin(),tp.end());\n//        cout << bitset<10>(i) << \" \" << c << endl;\n        St.push_back({sqrt(c.second),i});\n    }\n    \n    cout << fixed << setprecision(12) << rec(0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n\nconst int MAX_V = 2000; /////////////////////////////////////////////////////////////\n\nstruct Edge{ int to,cap,rev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((Edge){to,cap,(int)G[to].size()});\n  G[to].push_back((Edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INT_MAX);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(); }\n\n\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\n\n\n\n\n\nint N,M;\nPoint ps[111];\n\nint dp[20*20*20][1<<14];\nint calc(int n,double r) {\n  vector<int> vec;\n\n  rep(i,n) {\n    int bits = 0;\n    rep(j,n) {\n      if( LTE(abs(ps[i]-ps[j]),r) ) {\n\tbits |= (1<<j);\n      }\n    }\n    vec.push_back(bits);\n  }\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j)continue;\n      Point Rr = ps[i]-ps[j];\n      if(abs(Rr) <= r*2+EPS || 1){\n\tPoint UKPC,U,P1,P2;\n\tUKPC = (ps[i]+ps[j])*0.5;\n\tdouble l = abs(ps[i]-ps[j]) * 0.5;\n\tif( LTE(r * r - l * l,0)  ) continue;\n\tdouble T = sqrt(r*r-l*l);\n\t\n\tUKPC = (ps[i]+ps[j])*0.5;\n\t//P1 = UKPC + (ps[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\tPoint uni = (ps[i] - ps[j]) / abs(ps[i]-ps[j]);\n\t//cout << \"uni = \" << uni <<endl;\n\t//P1 = UKPC + (T*((ps[i]-ps[j])/abs(ps[i]-ps[j])))*\n\tP1 = UKPC + rotate(uni,M_PI/2.0) * T;\n\t//P2 = UKPC + (ps[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t//P2 = UKPC + (ps[i]-ps[j])/abs(ps[i]-ps[j])*rotate(T,-M_PI/2.0);\n\tP2 = UKPC + rotate(uni,-M_PI/2.0) * T;\n\t/*\n\tputs(\"\");\n\tcout << ps[i] << \" and \" << ps[j] << endl;\n\tcout << \"UKPC = \" << UKPC << endl;\n\tcout << \"T = \" << T << endl;\n\tcout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t*/\n\t//cout << ps[i] << \" and \" << ps[j] <<endl;;\n\tdouble Calc;\n\tint bits = 0;\n\tfor(int k=0;k<n;k++){\n\t  Calc = abs(P1-ps[k]);\n\t  if(fabs(Calc) < r+EPS){\n\t    bits |= (1<<k);\n\t  }\n\t}\n\t//bitset<5> BIT(bits);\n\t//cout << BIT << endl;\n\tvec.push_back(bits);\n\tbits = 0;\n\tfor(int k=0;k<n;k++){\n\t  Calc = abs(P2-ps[k]);\n\t  if(fabs(Calc) < r+EPS){\n\t    bits |= (1<<k);\n\t  }\n\t}\n\t//BIT = bits;\n\t//cout << BIT << endl;\n\tvec.push_back(bits);\n \n      }\n \n    }\n  }\n  assert(vec.size()<20*20*20);\n  int len = vec.size();\n  rep(i,len+1) rep(j,(1<<n)) {\n    dp[i][j] = INT_MAX;\n  }\n  dp[0][0] = 0;\n\n  rep(i,len) {\n    rep(j,(1<<n)) {\n      int bits = vec[i];\n      dp[i+1][j] = min(dp[i+1][j|bits],dp[i][j]);\n      if( dp[i][j] == INT_MAX ) continue;\n      dp[i+1][j|bits] = min(dp[i+1][j|bits],dp[i][j]+1);\n\n    }\n  }\n  int resp = dp[len][(1<<n)-1];\n  return resp;\n}\n\nbool check(double r) {\n  return calc(N,r) <= M;\n}\n\nvoid compute() {\n  double L=0,R=100000000;//fewopajfeaw\n  rep(_,100) {//feoajfewao\n    double _M = ( L + R ) * 0.5;\n    if( check(_M) ) {\n       R = _M;\n    } else {\n      L = _M;\n    }\n  }\n  printf(\"%.10f\\n\",L);\n}\n\nint main() {\n  cin >> N >> M;\n  rep(i,N) cin >> ps[i].x >> ps[i].y;\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr long double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(long double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<long double>(long double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\n\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return mysqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\n\tfriend std::istream &operator>>(std::istream &is, pvec &o) {\n\t\tdouble x_, y_;is >> x_ >> y_;o = pvec(x_, y_);return (is);\n\t}\nprivate:\n\tstatic const double mysqrt(const double &x) {\n\t\tdouble h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tdouble r = *(double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\nvoid scan(pvec &d) { scan(d.x, d.y); }\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x);\n\tstd::vector<long double> t(siz, -0.00001);\n\tfor (uint32 i = 1;i < siz;++i) {\n\t\tdouble mix = 200000, max = 0, miy = 200000, may = 0;\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tbmini(mix, d[k].x);bmaxi(max, d[k].x);\n\t\t\t\tbmini(miy, d[k].y);bmaxi(may, d[k].y);\n\t\t\t}\n\t\t}\n\t\tpvec cent((max + mix) / 2, (may + miy) / 2);\n\t\tdouble dist = std::max((max - mix) / 2, (may - miy) / 2);\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tif ((d[k] - cent).abs() > dist) {\n\t\t\t\t\tpvec temp = (d[k] - cent)*dist / ((d[k] - cent).abs());\n\t\t\t\t\ttemp = cent - temp;\n\t\t\t\t\tcent = (temp + d[k]) / 2;\n\t\t\t\t\tdist = (d[k] - cent).abs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt[i] = dist;\n\t}\n\tlong double low = 0, high = 100000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 100;++bs) {\n\t\tconst long double mid = (low + high) / 2;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tlong double ans = high;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\n#define double long double\n\nconst double EPS = 1e-12;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    // REP(i,n){\n    //     p[i].first += (rand() % 1000000) / 10000000000.0;\n    //     p[i].second += (rand() % 1000000) / 10000000000.0;\n    // }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10Lf\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nusing P = complex<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn(abs(a-b)); }\nD mabs(P p) { return abs(p.real()) + abs(p.imag()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.real()-l.real())) return l.real() < r.real();\n    if (sgn(r.imag()-l.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nD cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nD dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgn(cross(b, c) / mabs(b));\n    if (s) return s;\n    if (!sgn(mabs(c)) || !sgn(mabs(c-b))) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P x, y;\n    L() {}\n    L(P x, P y) :x(x), y(y) {}\n    P vec() const { return y-x; }\n};\nD abs(const L &l) { return abs(l.vec()); }\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.x)/abs(l.vec()));\n}\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec()*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\n\n\nusing Pol = V<P>;\nusing Tri = array<P, 3>;\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nC circumCircle(P a, P b, P c) {\n    b -= a; c -= a;\n    D s = 2*cross(b, c);\n    D x = norm(b-c), y = norm(c), z = norm(b);\n    D S = x+y+z;\n    P r = (y*(S-2*y)*b+z*(S-2*z)*c)/(s*s);\n    return C(r + a, abs(r));\n}\n\nC smallestEnclosingCircle(Pol &p, int ps = 0, Tri q = Tri(), int qs = 0) {\n    if (ps == p.size()) {\n        switch (qs) {\n            case 0:\n                return C(P(0, 0), -1);\n            case 1:\n                return C(q[0], 0);\n            case 2:\n                return C((q[0]+q[1])/D(2.0), abs(q[0]-q[1])/D(2.0));\n            case 3:\n                return circumCircle(q[0], q[1], q[2]);\n        }\n        assert(false);\n    }\n    C c = smallestEnclosingCircle(p, ps+1, q, qs);\n    if (sgn(abs(p[ps]-c.p) - c.r) == 1) {\n        q[qs] = p[ps];\n        return smallestEnclosingCircle(p, ps+1, q, qs+1);\n    }\n    return c;\n}\n\n\n\n\n\nconst int MN = 14;\nconst int MM = 14;\nint n, m;\nP p[MN];\nD pre[1<<MN];\nD dp[MM+1][1<<MN];\nbool vis[MM+1][1<<MN];\n\nD solve(int f, int m) {\n    if (f == 0) return 0;\n    if (m == 0) return 1e100;\n    if (vis[m][f]) return dp[m][f];\n    vis[m][f] = true;\n    D ans = 1e100;\n    int g = 0;\n    do {\n        ans = min(ans, max(pre[g], solve(f^g, m-1)));\n        g = ((g|~f)+1) & f;\n    } while (g);\n    return dp[m][f] = ans;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int f = 0; f < (1<<n); f++) {\n        V<P> v;\n        for (int i = 0; i < n; i++) {\n            if (!(f & (1<<i))) continue;\n            v.push_back(p[i]);\n        }\n        shuffle(begin(v), end(v), mt19937(random_device()()));\n        pre[f] = smallestEnclosingCircle(v).r;\n\n//        cout << f << \" \" << pre[f] << endl;\n    }\n\n    cout << solve((1<<n) - 1, m) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-5;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nReal smallest_enclosing_circle(Points &ps) {\n  if(ps.size() == 1) return 0;\n\n  mt19937 mt;\n  mt.seed(random_device()());\n  shuffle(begin(ps), end(ps), mt);\n\n  auto make_circle3 = [](const Point &a, const Point &b, const Point &c) {\n    auto A = norm(b - c), B = norm(c - a), C = norm(a - b);\n    auto S = abs(cross(b - a, c - a));\n    auto p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) * 0.25 / S / S;\n    return Circle(p, abs(p - a));\n  };\n\n  auto make_circle2 = [](const Point &a, const Point &b) {\n    Point c = (a + b) * 0.5;\n    return Circle(c, abs(a - c));\n  };\n\n  auto in_circle = [](const Point &a, const Circle &c) {\n    return norm(a - c.p) < c.r * c.r + EPS;\n  };\n\n  Circle c = make_circle2(ps[0], ps[1]);\n  for(int i = 2; i < ps.size(); ++i) {\n    if(!in_circle(ps[i], c)) {\n      c = make_circle2(ps[0], ps[i]);\n      for(int j = 1; j < i; ++j) {\n        if(!in_circle(ps[j], c)) {\n          c = make_circle2(ps[j], ps[i]);\n          for(int k = 0; k < j; ++k) {\n            if(!in_circle(ps[k], c)) {\n              c = make_circle3(ps[i], ps[j], ps[k]);\n            }\n          }\n        }\n      }\n    }\n  }\n  return c.r;\n}\n\ndouble cover[1 << 14];\ndouble dp[1 << 14][15];\nbool memo[1 << 14][15];\n\ndouble rec(int bit, int sum) {\n  if(sum == 1) return cover[bit];\n  if(memo[bit][sum]) return dp[bit][sum];\n  double ret = 1e9;\n  for(int i = bit & (bit - 1); i > 0; i = (i - 1) & bit) {\n    int other = i ^bit;\n    ret = min(ret, max(rec(other, sum - 1), cover[i]));\n  }\n  memo[bit][sum] = true;\n  return dp[bit][sum] = ret;\n}\n\nint main() {\n  int N, M;\n  Point p[14];\n\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) {\n    cin >> p[i];\n  }\n  for(int i = 1; i < (1 << N); i++) {\n    Points ps;\n    for(int j = 0; j < N; j++) {\n      if((i >> j) & 1) ps.emplace_back(p[j]);\n    }\n    cover[i] = smallest_enclosing_circle(ps);\n  }\n  cout << fixed << setprecision(10) << rec((1 << N) - 1, M) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nusing P = complex<double>;\nusing G = vector<P>;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nstruct L {\n    P a, b, v, h;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a), h(v / abs(v) * P(0, 1)) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void trans(double d) {\n        a += d * h;\n        b += d * h;\n    }\n    void print() {\n        cerr << \"{(\" << a.real() << \", \" << a.imag() << \"), (\" << b.real() << \", \" << b.imag() << \")}\" << endl;\n    }\n};\nusing S = L;\n\nstruct Cir {\n    P p;\n    double r;\n    Cir(){}\n    Cir(P _p, double _r) : p(_p), r(_r) {}\n    Cir(double _x, double _y, double _r) : p(_x, _y), r(_r) {}\n    void print() {\n        cerr << p.real() << \" \" << p.imag() << \" \" << r << endl;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.;\n    P d = (q - p) / 2.;\n    P h = d * P(0, 1);\n    return L(c + h, c - h);\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nCir Circle(P a, P b, P c) {\n  Cir C;\n  if (sgn(cross(a - b, a - c)) == 0) {\n    // on the line\n    C.r = 0;\n    if (sgn(C.r, abs(a - b) / 2.) == -1) {\n      C.r = abs(a - b) / 2.;\n      C.p = (a + b) / 2.;\n    }\n    if (sgn(C.r, abs(b - c) / 2.) == -1) {\n      C.r = abs(b - c) / 2.;\n      C.p = (b + c) / 2.;\n    }\n    if (sgn(C.r, abs(c - a) / 2.) == -1) {\n      C.r = abs(c - a) / 2.;\n      C.p = (c + a) / 2.;\n    }\n  }\n  else {\n    L l1 = PerpendicularBisector(a, b);\n    L l2 = PerpendicularBisector(a, c);\n    C.p = crosspointLL(l1, l2);\n    C.r = abs(a - C.p);\n    // double cosine = cross(b - a, c - a) / abs(b - a) / abs(c - a);\n    // double sine = sqrt(1 - cosine * cosine);\n    // double R = abs(c - b) / sine / 2.;\n    // return R;\n  }\n\n  return C;\n}\n\ndouble radiusOfCircle(P a, P b, P c) {\n  if (sgn(cross(a - b, a - c)) == 0) {\n    // on the line\n    double ret = 0.;\n    ret = max(ret, abs(a - b) / 2.);\n    ret = max(ret, abs(b - c) / 2.);\n    ret = max(ret, abs(c - a) / 2.);\n    return ret;\n  }\n  else {\n    double cosine = cross(b - a, c - a) / abs(b - a) / abs(c - a);\n    double sine = sqrt(1 - cosine * cosine);\n    double R = abs(c - b) / sine / 2.;\n    return R;\n  }\n}\n\nbool allContained(const vector<P>& vp, int S, Cir C) {\n  rep(i, vp.size()) {\n    if ((S >> i) & 1) {\n      if (sgn(abs(vp[i] - C.p), C.r) == 1) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n  vector<P> vp;\n  rep(i, n) {\n    vp.push_back(readP());\n  }\n\n  vector<double> rad(1 << n, INF);\n  rep(S, 1 << n) {\n    if (__builtin_popcount(S) <= 1) {\n      rad[S] = 0.;\n    }\n    else if (__builtin_popcount(S) == 2) {\n      int i = -1, j = -1;\n      rep(k, n) {\n        if ((S >> k) & 1) {\n          if (i == -1) i = k;\n          else j = k;\n        }\n      }\n      rad[S] = abs(vp[i] - vp[j]) / 2.;\n    }\n    else {\n      rep(i, n) {\n        if (!((S >> i) & 1)) continue;\n        rep2(j, i + 1, n) {\n          if (!((S >> j) & 1)) continue;\n          rep2(k, j + 1, n) {\n            if (!((S >> k) & 1)) continue;\n            // 円がすべての点を包含していることの確認！\n            // P center = centerOfCircle(vp[i], vp[j], vp[k]);\n            // double radius = radiusOfCircle(vp[i], vp[j], vp[k]);\n            Cir C = Circle(vp[i], vp[j], vp[k]);\n            if (allContained(vp, S, C)) {\n              rad[S] = min(rad[S], C.r);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // rep(S, 1 << n) {\n  //   cerr << bitset<5>(S) << \": \" << rad[S] << endl;\n  // }\n\n  vector<vector<double>> dp(1 << n, vector<double>(m + 1, INF));\n  dp[0][0] = 0.;\n  rep2(k, 1, m + 1) {\n    rep(T, 1 << n) {\n      int U = T;\n      do {\n        dp[T][k] = min(dp[T][k], max(dp[T - U][k - 1], rad[U]));\n        U = (U - 1) & T;\n      } while (U != T);\n    }\n  }\n\n  // rep(T, 1 << n) {\n  //   cerr << bitset<5>(T) << \":\";\n  //   rep(k, m + 1) {\n  //     cerr << \" \" << dp[T][k];\n  //   }\n  //   cerr << endl;\n  // }\n\n  double ans = *min_element(all(dp[(1 << n) - 1]));\n  cout << fixed << setprecision(10) << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\n#define double long double\n\nconst double EPS = 1e-5;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    // REP(i,n){\n    //     p[i].first += (rand() % 1000000) / 10000000000.0;\n    //     p[i].second += (rand() % 1000000) / 10000000000.0;\n    // }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10Lf\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-6;\n\ndouble dist(double px, double py, double qx, double qy) {\n  return sqrt((px - qx) * (px - qx) + (py - qy) * (py - qy));\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] / 100000000;\n    Y[i] = P[i] % 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n    ll cnt = 0;\n    REP(i, 0, N) if(s & (1LL << i)) cnt++;\n    if(cnt < 2) {\n      radius[s] = 0.0;\n      continue;\n    }\n\n    double minr = 1e10;\n    REP(i, 0, N) REP(j, i + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)))) continue;\n\n      double d = dist(X[i], Y[i], X[j], Y[j]) / 2.0;\n      double dx = +(Y[i] - Y[j]) / (d * 2.0);\n      double dy = -(X[i] - X[j]) / (d * 2.0);\n      double mx = (X[i] + X[j]) / 2.0;\n      double my = (Y[i] + Y[j]) / 2.0;\n\n      bool ok = true;\n      REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], mx, my) > d + EPS) ok = false;\n      if(ok) {\n        minr = min(minr, d);\n        continue;\n      }\n\n      double l1 = d, h1 = 1e10;\n      REP(_, 0, 100) {\n        double m = (l1 + h1) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c1x = mx + dx * t;\n        double c1y = my + dy * t;\n        bool ok1 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c1x, c1y) > m + EPS) ok1 = false;\n\n        (ok1 ? h1 : l1) = m;\n      }\n\n      double l2 = d, h2 = 1e10;\n      REP(_, 0, 100) {\n        double m = (l2 + h2) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c2x = mx - dx * t;\n        double c2y = my - dy * t;\n        bool ok2 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c2x, c2y) > m + EPS) ok2 = false;\n\n        (ok2 ? h2 : l2) = m;\n      }\n\n      minr = min(minr, min(h1, h2));\n    }\n    radius[s] = minr;\n  }\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e10));\n  dp[0][0] = 0.0;\n  REP(s, 0, 1LL << N) REP(i, 0, M) {\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e10;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-10;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    REP(i,n){\n        p[i].first += (rand() % 1000000) / 10000000000.0;\n        p[i].second += (rand() % 1000000) / 10000000000.0;\n    }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\ntypedef complex<double> P;\n\nint n,m;\nP pos[25];\n\ndouble R[1<<14];\n\ndouble f(int msk, double x, double y){\n  P p(x,y);\n  double ret = 1e-14;\n  REP(i,n)if((msk>>i)&1)CHMAX(ret, abs(pos[i]-p));\n  return ret;\n}\n\ndouble calc(int msk, double x){\n  double ylow = -1, yhigh = 1e5+1;\n  REP(_,50){\n    double ylolo = (6.0*ylow + 5.0*yhigh) / 11.0;\n    double yhihi = (5.0*ylow + 6.0*yhigh) / 11.0;\n    if(f(msk, x, ylolo) < f(msk, x, yhihi)){\n      yhigh = yhihi;\n    }else{\n      ylow = ylolo;\n    }\n  }\n  return (yhigh + ylow) / 2.0;\n}\n\ndouble dp[25][1<<14];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,n){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    pos[i] = P(x,y);\n  }\n  R[0] = 0;\n  FOR(i,1,1<<n){\n    double xlow = -1, xhigh = 1e5+1;\n    REP(_,50){\n      double xlolo = (6.0*xlow + 5.0*xhigh) / 11.0;\n      double xhihi = (5.0*xlow + 6.0*xhigh) / 11.0;\n      double ylolo = calc(i, xlolo);\n      double yhihi = calc(i, xhihi);\n      if(f(i, xlolo, ylolo) < f(i, xhihi, yhihi)){\n        xhigh = xhihi;\n      }else{\n        xlow = xlolo;\n      }\n    }\n    double x = (xlow + xhigh) / 2.0;\n    double y = calc(i, x);\n    R[i] = f(i, x, y);\n  }\n\n  REP(i,m+1)REP(msk,1<<n)dp[i][msk] = 1e18;\n  dp[0][0] = 1e-14;\n  REP(i,m)REP(msk,1<<n){\n    int submsk = ((1<<n)-1) - msk;\n    for(int T=submsk; ; T=(T-1)&submsk){\n      CHMIN(dp[i+1][msk|T], max(dp[i][msk], R[T]));\n      if(T==0)break;\n    }\n  }\n  printf(\"%.9f\\n\",dp[m][(1<<n)-1]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\n\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return std::sqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\nprivate:\n};\nvoid scan(pvec &d) { scan(d.x, d.y); }\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x);\n\tstd::vector<double> t(siz, -0.00001);\n\tfor (uint32 i = 1;i < siz;++i) {\n\t\tdouble mix = 200000, max = 0, miy = 200000, may = 0;\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tbmini(mix, d[k].x);bmaxi(max, d[k].x);\n\t\t\t\tbmini(miy, d[k].y);bmaxi(may, d[k].y);\n\t\t\t}\n\t\t}\n\t\tpvec cent((max + mix) / 2, (may + miy) / 2);\n\t\tdouble dist = std::max((max - mix) / 2, (may - miy) / 2);\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tif ((d[k] - cent).abs() > dist) {\n\t\t\t\t\tpvec temp = (d[k] - cent)*dist / ((d[k] - cent).abs());\n\t\t\t\t\ttemp = cent - temp;\n\t\t\t\t\tcent = (temp + d[k]) / 2;\n\t\t\t\t\tdist = (d[k] - cent).abs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt[i] = dist;\n\t}\n\tdouble low = 0, high = 100000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 100;++bs) {\n\t\tconst double mid = (low + high) / 2;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tdouble ans = high;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld = double;\nusing P = std::complex<ld>;\nusing G = std::vector<P>;\nconst ld pi = std::acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P &a, const P &b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(const P &a, const P &b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\n/*\n                    CCW\n\n -- BEHIND -- [a -- ON -- b] --- FRONT --\n\n                    CW\n */\nenum CCW_RESULT { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps) return CCW;    // counter clockwise\n    if (cross(b, c) < -eps) return CW;    // clockwise\n    if (dot(b, c) < 0) return BEHIND;     // c--a--b on line\n    if (norm(b) < norm(c)) return FRONT;  // a--b--c on line\n    return ON;\n}\n\nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return std::abs(real(a) - real(b)) > eps ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public std::vector<P> {\n    L(const P &a = P(), const P &b = P()) : std::vector<P>(2) {\n        begin()[0] = a;\n        begin()[1] = b;\n    }\n\n    // Ax + By + C = 0\n    L(ld A, ld B, ld C) {\n        if (std::abs(A) < eps && std::abs(B) < eps) {\n            abort();\n        } else if (std::abs(A) < eps) {\n            *this = L(P(0, -C / B), P(1, -C / B));\n        } else if (std::abs(B) < eps) {\n            *this = L(P(-C / A, 0), P(-C / A, 1));\n        } else {\n            *this = L(P(0, -C / B), P(-C / A, 0));\n        }\n    }\n};\n\nstruct C {\n    P p;\n    ld r;\n    C(const P &p = 0, ld r = 0) : p(p), r(r) {}\n};\n\n\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right) {\n    int n = right - left;\n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n\n    random_shuffle(left, right);\n    iter ps = left;\n    using circle = std::pair<P, ld>;\n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n           S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n\n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n\n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n\n    circle c = make_circle_2(ps[0], ps[1]);\n    n = right - left;\n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    if (n == m) {\n        cout << \"0\\n\";\n        return 0;\n    }\n    G p(n);\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    vector<ld> r(1 << n);\n    set<ld> rs;\n    rs.insert(0);\n    for (int i = 1; i < (1 << n); ++i) {\n        G pt;\n        for (int j = 0; j < n; ++j) {\n            if ((i >> j) & 1) {\n                pt.push_back(p[j]);\n            }\n        }\n        if (pt.size() <= 1) {\n            r[i] = 0;\n        }\n        else {\n            r[i] = sqrt(min_ball(pt.begin(), pt.end()).second);\n            rs.insert(r[i]);\n        }\n    }\n    vector<ld> rv;\n    rv.push_back(-1e-9);\n    for (ld i : rs) {\n        rv.push_back(i + 1e-9);\n    }\n    rv.push_back(r[(1 << n) - 1] + 1e-9);\n    int ng = 0, ok = (int)rv.size() - 1;\n    while (ok > ng + 1) {\n        int mid = (ok + ng) / 2;\n        ld rm = rv[mid];\n        vector<int> dp(1 << n, n);\n        dp[0] = 0;\n        vector<int> pl;\n        for (int i = 1; i < (1 << n); ++i) {\n            if (r[i] < rm) {\n                pl.push_back(i);\n            }\n        }\n        for (int i = 1; i < (1 << n); ++i) {\n            for (int j : pl) {\n                dp[i] = min(dp[i], dp[i & ~j] + 1);\n            }\n        }\n        if (dp[(1 << n) - 1] <= m) {\n            ok = mid;\n        }\n        else {\n            ng = mid;\n        }\n    }\n    printf(\"%.9lf\\n\", rv[ok]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < n; ++i)\nusing namespace std;\ntemplate <typename T> using vec = vector<T>;\nusing V = vec<int>;\n\nusing ld = long double;\nusing P = std::complex<ld>;\nusing G = std::vector<P>;\nconst ld pi = std::acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P &a, const P &b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(const P &a, const P &b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\n/*\n                    CCW\n\n -- BEHIND -- [a -- ON -- b] --- FRONT --\n\n                    CW\n */\nenum CCW_RESULT { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps) return CCW;    // counter clockwise\n    if (cross(b, c) < -eps) return CW;    // clockwise\n    if (dot(b, c) < 0) return BEHIND;     // c--a--b on line\n    if (norm(b) < norm(c)) return FRONT;  // a--b--c on line\n    return ON;\n}\n\nnamespace std {\nbool operator<(const P &a, const P &b) {\n    return std::abs(real(a) - real(b)) > eps ? real(a) < real(b) : imag(a) < imag(b);\n}\n}\n\nstruct L : public std::vector<P> {\n    L(const P &a = P(), const P &b = P()) : std::vector<P>(2) {\n        begin()[0] = a;\n        begin()[1] = b;\n    }\n\n    // Ax + By + C = 0\n    L(ld A, ld B, ld C) {\n        if (std::abs(A) < eps && std::abs(B) < eps) {\n            abort();\n        } else if (std::abs(A) < eps) {\n            *this = L(P(0, -C / B), P(1, -C / B));\n        } else if (std::abs(B) < eps) {\n            *this = L(P(-C / A, 0), P(-C / A, 1));\n        } else {\n            *this = L(P(0, -C / B), P(-C / A, 0));\n        }\n    }\n};\n\nstruct C {\n    P p;\n    ld r;\n    C(const P &p = 0, ld r = 0) : p(p), r(r) {}\n};\n\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right) {\n    int n = right - left;\n    // if (n == 0) return { 0, 0 };\n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n\n    random_shuffle(left, right);\n    iter ps = left;\n    using circle = std::pair<P, ld>;\n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n           S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n\n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n\n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n\n    circle c = make_circle_2(ps[0], ps[1]);\n\n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\nusing namespace std;\n\ndouble dp[1 << 14][15];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m && n) {\n        // using B = bitset<5>;\n\n        vector<P> ps(n);\n        rep(i, n) {\n            int x, y;\n            cin >> x >> y;\n            ps[i] = P(x, y);\n        }\n        fill((double*)begin(dp), (double*)end(dp), inf);\n\n        dp[0][0] = 0;\n\n        int Mask = (1 << n) - 1;\n        for (int S = 0; S < (1 << n); ++S) {\n            for (int T = ~S & Mask; T >= 0; --T) {\n                T &= ~S & Mask;\n                if (T == 0) continue;\n\n                // cout << B(S) << ' ' << B(T) << endl;\n                static vec<P> sub;\n                sub.clear();\n                rep(i, n) if (T >> i & 1) {\n                    sub.push_back(ps[i]);\n                }\n                double r = sqrt(min_ball(sub.begin(), sub.end()).second);\n                rep(j, m) {\n                    dp[S | T][j + 1] = min(dp[S | T][j + 1],\n                                           max(dp[S][j], r));\n                }\n            }\n        }\n\n        double res = inf;\n        rep(i, m + 1) {\n            //cout << dp[Mask][i] << endl;\n            res = min(res, dp[Mask][i]);\n        }\n        printf(\"%.20f\\n\", res);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, M;\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\ndouble solve(vector<int> x, vector<int> y) {\n\tint n = x.size();\n\tdouble ret = 0.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tret = max(ret, hypot(x[i] - x[j], y[i] - y[j]) * 0.5);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\tdouble a = hypot(x[i] - x[j], y[i] - y[j]);\n\t\t\t\tdouble b = hypot(x[j] - x[k], y[j] - y[k]);\n\t\t\t\tdouble c = hypot(x[k] - x[i], y[k] - y[i]);\n\t\t\t\tdouble s = (a + b + c) * 0.5;\n\t\t\t\tif (a + b <= c + 1.0e-7 || b + c <= a + 1.0e-7 || c + a <= b + 1.0e-7) continue;\n\t\t\t\tdouble res = a * b * c / (4 * sqrt(s * (s - a) * (s - b) * (s - c)));\n\t\t\t\tif (a * a + b * b < c * c || b * b + c * c < a * a || c * c + a * a < b * b) res = max({ a, b, c }) * 0.5;\n\t\t\t\tret = max(ret, res);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> N >> M;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; i++) cin >> x[i] >> y[i];\n\tvector<double> v(1 << N);\n\tfor (int i = 1; i < 1 << N; i++) {\n\t\tvector<int> cx, cy;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcx.push_back(x[j]);\n\t\t\t\tcy.push_back(y[j]);\n\t\t\t}\n\t\t}\n\t\tv[i] = solve(cx, cy);\n\t}\n\tdouble l = 0.0, r = 2.0e+5;\n\tfor (int i = 0; i < 70; i++) {\n\t\tdouble m = (l + r) * 0.5;\n\t\tvector<int> dp(1 << N, 1 << 30); dp[0] = 0;\n\t\tfor (int j = 1; j < 1 << N; j++) {\n\t\t\tfor (int k = j; k > 0; k = (k - 1) & j) {\n\t\t\t\tif(v[k] <= m) dp[j] = min(dp[j], dp[j - k] + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[(1 << N) - 1] <= M) r = m;\n\t\telse l = m;\n\t}\n\tcout << fixed << setprecision(15) << l << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n#define EPS 1e-7\n\nint n,m;\ndouble x[15],y[15];\nint dp[1<<15];\n\nbool ok(double r){\n  rep(i,1<<n)dp[i]=INF;\n  dp[(1<<n)-1]=0;\n  for(int S=(1<<n)-1;S>0;S--){\n    rep(i,n){\n      if(((S>>i)&1)==0)continue;\n      minch(dp[S^(1<<i)],dp[S]+1);\n      rep(j,i){\n        if(((S>>j)&1)==0)continue;\n        double dx=x[i]-x[j],dy=y[i]-y[j];\n        double d=sqrt(dx*dx+dy*dy)/2.0;\n        if(d>r)continue;\n        double mx=(x[i]+x[j])/2.0;\n        double my=(y[i]+y[j])/2.0;\n        double h=sqrt(r*r-d*d);\n        double ex=-dy,ey=dx;\n        double l=sqrt(ex*ex+ey*ey);\n\n        if(l>0){\n          ex/=l; ey/=l;\n        }\n\n        {\n          double cx=mx+ex*h,cy=my+ey*h;\n          int T=S^(1<<i)^(1<<j);\n          rep(k,n){\n            if(k==i||k==j)continue;\n            if(((S>>k)&1)==0)continue;\n            double ddx=x[k]-cx;\n            double ddy=y[k]-cy;\n            if(ddx*ddx+ddy*ddy<r*r+EPS){\n              T^=(1<<k);\n            }\n          }\n          minch(dp[T],dp[S]+1);\n        }\n        {\n          double cx=mx-ex*h,cy=my-ey*h;\n          int T=S^(1<<i)^(1<<j);\n          rep(k,n){\n            if(k==i||k==j)continue;\n            if(((S>>k)&1)==0)continue;\n            double ddx=x[k]-cx;\n            double ddy=y[k]-cy;\n            if(ddx*ddx+ddy*ddy<r*r+EPS){\n              T^=(1<<k);\n            }\n          }\n          minch(dp[T],dp[S]+1);\n        }\n      }\n    }\n  }\n  return dp[0]<=m;\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)cin>>x[i]>>y[i];\n  double lb=1e-6,ub=1e7;\n  rep(hoge,50){\n    double mid=(ub+lb)/2.0;\n    if(ok(mid))ub=mid;\n    else lb=mid;\n  }\n  printf(\"%.10f\\n\", (lb+ub)/2.0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\n\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return std::sqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\n\tfriend std::istream &operator>>(std::istream &is, pvec &o) {\n\t\tdouble x_, y_;is >> x_ >> y_;o = pvec(x_, y_);return (is);\n\t}\nprivate:\n};\nvoid scan(pvec &d) { scan(d.x, d.y); }\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x);\n\tstd::vector<double> t(siz, -0.00001);\n\tfor (uint32 i = 1;i < siz;++i) {\n\t\tdouble mix = 200000, max = 0, miy = 200000, may = 0;\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tbmini(mix, d[k].x);bmaxi(max, d[k].x);\n\t\t\t\tbmini(miy, d[k].y);bmaxi(may, d[k].y);\n\t\t\t}\n\t\t}\n\t\tpvec cent((max + mix) / 2, (may + miy) / 2);\n\t\tdouble dist = std::max((max - mix) / 2, (may - miy) / 2);\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tif ((d[k] - cent).abs() > dist) {\n\t\t\t\t\tpvec temp = (d[k] - cent)*dist / ((d[k] - cent).abs());\n\t\t\t\t\ttemp = cent - temp;\n\t\t\t\t\tcent = (temp + d[k]) / 2;\n\t\t\t\t\tdist = (d[k] - cent).abs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt[i] = dist;\n\t}\n\tdouble low = 0, high = 100000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 100;++bs) {\n\t\tconst double mid = (low + high) / 2;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tdouble ans = high;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist2(double px, double py, double qx, double qy) {\n  return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] % 100000000;\n    Y[i] = P[i] / 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n\n    // cerr << \"s: \" << s << endl;\n\n    double minr2 = 1e20;\n    REP(i, 0, N) REP(j, i + 1, N) REP(k, j + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)) && (s & (1LL << k)))) continue;\n\n      // cerr << \"  i, j, k: \" << i << \" \" << j << \" \" << k << endl;\n\n      double d1x = +(Y[i] - Y[j]);\n      double d1y = -(X[i] - X[j]);\n      double m1x = (X[i] + X[j]) / 2.0;\n      double m1y = (Y[i] + Y[j]) / 2.0;\n      double d2x = +(Y[j] - Y[k]);\n      double d2y = -(X[j] - X[k]);\n      double m2x = (X[j] + X[k]) / 2.0;\n      double m2y = (Y[j] + Y[k]) / 2.0;\n\n      double x, y, r2;\n      if((d1y * d2x) - (d1x * d2y) < EPS) {\n        double di = dist2(X[j], Y[j], X[k], Y[k]);\n        double dj = dist2(X[k], Y[k], X[i], Y[i]);\n        double dk = dist2(X[i], Y[i], X[j], Y[j]);\n\n        // cerr << \"    di: \" << di << \", dj: \" << dj << \", dk: \" << dk << endl;\n\n        if(di > dj && di > dk) { x = (X[j] + X[k]) / 2.0; y = (Y[j] + Y[k]) / 2.0; r2 = pow(sqrt(di) / 2.0, 2); };\n        if(dj > dk && dj > di) { x = (X[k] + X[i]) / 2.0; y = (Y[k] + Y[i]) / 2.0; r2 = pow(sqrt(dj) / 2.0, 2); };\n        if(dk > di && dk > dj) { x = (X[i] + X[j]) / 2.0; y = (Y[i] + Y[j]) / 2.0; r2 = pow(sqrt(dk) / 2.0, 2); };\n      } else {\n\n        // cerr << \"    d1: (\" << d1x << \", \" << d1y << \"), m1: :(\" << m1x << \", \" << m1y << \")\" << endl;\n        // cerr << \"    d2: (\" << d2x << \", \" << d2y << \"), m2: :(\" << m2x << \", \" << m2y << \")\" << endl;\n\n        double a = d1x, b = -d2x, c = m2x - m1x;\n        double d = d1y, e = -d2y, f = m2y - m1y;\n\n        // cerr << \"    a: \" << a << \", b: \" << b << \", c: \" << c << endl;\n        // cerr << \"    d: \" << d << \", e: \" << e << \", f: \" << f << endl;\n\n        double t1 = (c * e - b * f) / (a * e - b * d);\n        double t2 = (c * d - a * f) / (b * d - a * e);\n        if(-EPS < t1 && t1 < EPS) t1 = 0;\n        if(-EPS < t2 && t2 < EPS) t2 = 0;\n\n        // cerr << \"    t1: \" << t1 << \", t2: \" << t2 << endl;\n\n        x = d1x * t1 + m1x;\n        y = d1y * t1 + m1y;\n        r2 = (X[i] - x) * (X[i] - x) + (Y[i] - y) * (Y[i] - y);\n      }\n\n      // cerr << \"    (x, y): (\" << x << \", \" << y << \"), r: \" << sqrt(r2) << endl;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r2 + EPS) ok = false;\n      if(ok) minr2 = min(minr2, r2);\n\n      // cerr << \"    ok: \" << ok << endl;\n    }\n    radius[s] = sqrt(minr2);\n\n    // cerr << s << \": \" << radius[s] << endl;\n  }\n\n  REP(i, 0, N) radius[1LL << i] = 0.0;\n  REP(i, 0, N) REP(j, 0, N) radius[(1LL << i) | (1LL << j)] = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n  radius[0] = 0.0;\n\n  // cerr << radius[0] << endl;\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e20));\n  dp[0][0] = 0.0;\n  REP(i, 0, M) REP(s, 0, 1LL << N) {\n    // cerr << s << \", \" << i << \": \" << dp[s][i] << endl;\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e20;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\n\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return mysqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\n\tfriend std::istream &operator>>(std::istream &is, pvec &o) {\n\t\tdouble x_, y_;is >> x_ >> y_;o = pvec(x_, y_);return (is);\n\t}\nprivate:\n\tstatic const double mysqrt(const double &x) {\n\t\tdouble h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tdouble r = *(double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\nvoid scan(pvec &d) { scan(d.x, d.y); }\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x);\n\tstd::vector<double> t(siz, -0.00001);\n\tfor (uint32 i = 1;i < siz;++i) {\n\t\tdouble mix = 200000, max = 0, miy = 200000, may = 0;\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tbmini(mix, d[k].x);bmaxi(max, d[k].x);\n\t\t\t\tbmini(miy, d[k].y);bmaxi(may, d[k].y);\n\t\t\t}\n\t\t}\n\t\tpvec cent((max + mix) / 2, (may + miy) / 2);\n\t\tdouble dist = std::max((max - mix) / 2, (may - miy) / 2);\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tif ((d[k] - cent).abs() > dist) {\n\t\t\t\t\tpvec temp = (d[k] - cent)*dist / ((d[k] - cent).abs());\n\t\t\t\t\ttemp = cent - temp;\n\t\t\t\t\tcent = (temp + d[k]) / 2;\n\t\t\t\t\tdist = (d[k] - cent).abs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt[i] = dist;\n\t}\n\tdouble low = 0, high = 100000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 100;++bs) {\n\t\tconst double mid = (low + high) / 2;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tdouble ans = high;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double PI=acos(-1);\nconst double EPS=1e-6;\n\nint N,M;\ndouble x[22],y[22];\n\nbool check(double mid){\n\tvector<int> m_list;\n\t\n\tREP(i,N){\n\t\tm_list.PB(1<<i);\n\t}\n\t\n\tREP(i,N)REP(j,N){\n\t\tif(i==j)continue;\n\t\tdouble dx=x[i]-x[j],dy=y[i]-y[j];\n\t\tdouble d=sqrt(dx*dx+dy*dy);\n\t\tif(d>mid*2+EPS)continue;\n\t\tdouble r=sqrt(mid*mid-d*d/4);\n\t\tdouble vx=-dy/d*r;\n\t\tdouble vy=dx/d*r;\n\n\t\tdouble xx=(x[i]+x[j])/2+vx;\n\t\tdouble yy=(y[i]+y[j])/2+vy;\n\t\tint cnt=0;\n\t\tREP(k,N){\n\t\t\tif((x[k]-xx)*(x[k]-xx)+(y[k]-yy)*(y[k]-yy)<mid*mid+EPS)cnt |= (1<<k);\n\t\t}\n\t\tm_list.PB(cnt);\n\t}\n\n\t/*\n\tREP(i,m_list.size()){\n\t\tcout << (static_cast<bitset<(unsigned)(10)>>(m_list[i])) << endl;\n\t}\n*/\t\n\t\n\tvector<int> dp(1 << N,INF);\n\tdp[0] = 0;\n\tREP(i,dp.size()){\n\t\tREP(j,m_list.size()){\n\t\t\tdp[i | m_list[j]] = min(dp[i] + 1 , dp[i | m_list[j]]);\n\t\t}\n\t}\n\t\n\tif(dp[(1 << N )- 1] == INF){\n\t\tREP(i,dp.size()){\n\t\t\tcout << (static_cast<bitset<(unsigned)(10)>>(dp[i])) << ' ' << dp[i] << endl;\n\t\t}\n\t}\n\t\n\t//cout << dp[(1 << N)-1] << endl;\n\treturn (dp[(1 << N)-1] <= M);\n}\n\nint main()\n{\n\tcin >> N >> M;\n\tvector<pair<int,int>> v;\n\tREP(i,N){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tv.erase(unique(ALL(v)),v.end());\n\t\n\tREP(i,v.size()){\n\t\tx[i] = v[i].FI;\n\t\ty[i] = v[i].SE;\n\t}\n\t\n\tN = v.size();\n\t\n\tdouble top = 1000000;\n\tdouble under = 0;\n\t\t\n\tREP(i,100){\n\t\tdouble mid = (top + under) / 2;\n\t//\tcout << mid << endl;\n\t\tif(check(mid))top = mid;\n\t\telse under = mid;\n\t}\n\t\n\tcout << Decimal << top << endl;\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-13;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n/* 幾何ライブラリ */\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acosl(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)、0：一直線上\nint simple_ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    return 0;\n}\n\n// 円や直線の交点\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\n\n// 外心\nPoint gaisin(Point a, Point b, Point c) {\n    Line ab((a+b)/2, (a+b)/2 + rot90(a-b));\n    Line bc((b+c)/2, (b+c)/2 + rot90(b-c));\n    return crosspoint(ab, bc)[0];\n}\n\n// 最小包含円\nDD mic(const vector<Point> &v) {\n    int N = (int)v.size();\n    if (N <= 1) return 0;\n\n    // 候補\n    vector<Point> alt;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            alt.push_back( (v[i] + v[j]) / 2 );\n            for (int k = j+1; k < N; ++k) {\n                if (simple_ccw(v[i], v[j], v[k]) == 0) continue;\n                auto r = gaisin(v[i], v[j], v[k]);\n                alt.push_back(r);\n            }\n        }\n    }\n\n    // 調べる\n    DD res = INF;\n    for (auto r : alt) {\n        DD tmp = 0;\n        for (auto p : v) chmax(tmp, abs(p - r));\n        chmin(res, tmp);\n    }\n    return res;\n}\n\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<Point> v(N);\n    for (int i = 0; i < N; ++i) cin >> v[i].x >> v[i].y;\n\n    // pre\n    vector<DD> need(1<<N, 0);\n    for (int bit = 0; bit < (1<<N); ++bit) {\n        vector<Point> part;\n        for (int i = 0; i < N; ++i) {\n            if (bit & (1<<i)) part.push_back(v[i]);\n        }\n        need[bit] = mic(part);\n\n        //cout << bit << \": \" << need[bit] << endl;\n    }\n        \n    // bitDP\n    vector<vector<DD>> dp(M+1, vector<DD>(1<<N,INF));\n    dp[0][0] = 0;\n    for (int m = 0; m < M; ++m) {\n        for (int bit = 0; bit < (1<<N); ++bit) {\n            int rem = ((1<<N)-1) - bit;\n            for (int bit2 = rem; ; bit2 = (bit2-1) & rem) {\n                chmin(dp[m+1][bit|bit2], max(dp[m][bit], need[bit2]));\n                if (!bit2) break;\n            }\n        }\n    }\n    \n    cout << fixed << setprecision(10) << dp[M][(1<<N)-1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nusing P = complex<double>;\nusing G = vector<P>;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nstruct L {\n    P a, b, v, h;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a), h(v / abs(v) * P(0, 1)) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void trans(double d) {\n        a += d * h;\n        b += d * h;\n    }\n    void print() {\n        cerr << \"{(\" << a.real() << \", \" << a.imag() << \"), (\" << b.real() << \", \" << b.imag() << \")}\" << endl;\n    }\n};\nusing S = L;\n\nstruct Cir {\n    P p;\n    double r;\n    Cir(){}\n    Cir(P _p, double _r) : p(_p), r(_r) {}\n    Cir(double _x, double _y, double _r) : p(_x, _y), r(_r) {}\n    void print() {\n        cerr << p.real() << \" \" << p.imag() << \" \" << r << endl;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.;\n    P d = (q - p) / 2.;\n    P h = d * P(0, 1);\n    return L(c + h, c - h);\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nCir Circle(P a, P b, P c) {\n  Cir C;\n  if (sgn(cross(a - b, a - c)) == 0) {\n    // on the line\n    C.r = 0;\n    if (C.r < abs(a - b) / 2.) {\n      C.r = abs(a - b) / 2.;\n      C.p = (a + b) / 2.;\n    }\n    if (C.r < abs(b - c) / 2.) {\n      C.r = abs(b - c) / 2.;\n      C.p = (b + c) / 2.;\n    }\n    if (C.r < abs(c - a) / 2.) {\n      C.r = abs(c - a) / 2.;\n      C.p = (c + a) / 2.;\n    }\n  }\n  else {\n    L l1 = PerpendicularBisector(a, b);\n    L l2 = PerpendicularBisector(a, c);\n    C.p = crosspointLL(l1, l2);\n    C.r = abs(a - C.p);\n    // double cosine = cross(b - a, c - a) / abs(b - a) / abs(c - a);\n    // double sine = sqrt(1 - cosine * cosine);\n    // double R = abs(c - b) / sine / 2.;\n    // return R;\n  }\n\n  return C;\n}\n\ndouble radiusOfCircle(P a, P b, P c) {\n  if (sgn(cross(a - b, a - c)) == 0) {\n    // on the line\n    double ret = 0.;\n    ret = max(ret, abs(a - b) / 2.);\n    ret = max(ret, abs(b - c) / 2.);\n    ret = max(ret, abs(c - a) / 2.);\n    return ret;\n  }\n  else {\n    double cosine = cross(b - a, c - a) / abs(b - a) / abs(c - a);\n    double sine = sqrt(1 - cosine * cosine);\n    double R = abs(c - b) / sine / 2.;\n    return R;\n  }\n}\n\nbool allContained(const vector<P>& vp, int S, Cir C) {\n  rep(i, vp.size()) {\n    if ((S >> i) & 1) {\n      if (sgn(abs(vp[i] - C.p), C.r) == 1) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n  vector<P> vp;\n  rep(i, n) {\n    vp.push_back(readP());\n  }\n\n  vector<double> rad(1 << n, INF);\n  rep(S, 1 << n) {\n    if (__builtin_popcount(S) <= 1) {\n      rad[S] = 0.;\n    }\n    else if (__builtin_popcount(S) == 2) {\n      int i = -1, j = -1;\n      rep(k, n) {\n        if ((S >> k) & 1) {\n          if (i == -1) i = k;\n          else j = k;\n        }\n      }\n      rad[S] = abs(vp[i] - vp[j]) / 2.;\n    }\n    else {\n      rep(i, n) {\n        if (!((S >> i) & 1)) continue;\n        rep2(j, i + 1, n) {\n          if (!((S >> j) & 1)) continue;\n          rep2(k, j + 1, n) {\n            if (!((S >> k) & 1)) continue;\n            // 円がすべての点を包含していることの確認！\n            // P center = centerOfCircle(vp[i], vp[j], vp[k]);\n            // double radius = radiusOfCircle(vp[i], vp[j], vp[k]);\n            Cir C = Circle(vp[i], vp[j], vp[k]);\n            if (allContained(vp, S, C)) {\n              rad[S] = min(rad[S], C.r);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // rep(S, 1 << n) {\n  //   cerr << bitset<5>(S) << \": \" << rad[S] << endl;\n  // }\n\n  vector<vector<double>> dp(1 << n, vector<double>(m + 1, INF));\n  dp[0][0] = 0.;\n  rep2(k, 1, m + 1) {\n    rep(T, 1 << n) {\n      int U = T;\n      do {\n        dp[T][k] = min(dp[T][k], max(dp[T - U][k - 1], rad[U]));\n        U = (U - 1) & T;\n      } while (U != T);\n    }\n  }\n\n  // rep(T, 1 << n) {\n  //   cerr << bitset<5>(T) << \":\";\n  //   rep(k, m + 1) {\n  //     cerr << \" \" << dp[T][k];\n  //   }\n  //   cerr << endl;\n  // }\n\n  double ans = *min_element(all(dp[(1 << n) - 1]));\n  cout << fixed << setprecision(10) << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n#define EPS 1e-7\n\nint n,m;\ndouble x[15],y[15];\nint dp[1<<15];\n\nbool ok(double r){\n  rep(i,1<<n)dp[i]=INF;\n  dp[(1<<n)-1]=0;\n  for(int S=(1<<n)-1;S>0;S--){\n    rep(i,n){\n      if(((S>>i)&1)==0)continue;\n      rep(j,n){\n        if(i==j)continue;\n        if(((S>>j)&1)==0)continue;\n        minch(dp[S^(1<<i)],dp[S]+1);\n      }\n      rep(j,i){\n        if(((S>>j)&1)==0)continue;\n        double dx=x[i]-x[j],dy=y[i]-y[j];\n        double d=sqrt(dx*dx+dy*dy)/2.0;\n        if(d>r)continue;\n        double mx=(x[i]+x[j])/2.0;\n        double my=(y[i]+y[j])/2.0;\n        double h=sqrt(r*r-d*d);\n        double ex=-dy,ey=dx;\n        double l=sqrt(ex*ex+ey*ey);\n\n        if(l>0){\n          ex/=l; ey/=l;\n        }\n\n        {\n          double cx=mx+ex*h,cy=my+ey*h;\n          int T=S^(1<<i)^(1<<j);\n          rep(k,n){\n            if(k==i||k==j)continue;\n            if(((S>>k)&1)==0)continue;\n            double ddx=x[k]-cx;\n            double ddy=y[k]-cy;\n            if(ddx*ddx+ddy*ddy<r*r+EPS){\n              T^=(1<<k);\n            }\n          }\n          minch(dp[T],dp[S]+1);\n        }\n        {\n          double cx=mx-ex*h,cy=my-ey*h;\n          int T=S^(1<<i)^(1<<j);\n          rep(k,n){\n            if(k==i||k==j)continue;\n            if(((S>>k)&1)==0)continue;\n            double ddx=x[k]-cx;\n            double ddy=y[k]-cy;\n            if(ddx*ddx+ddy*ddy<r*r+EPS){\n              T^=(1<<k);\n            }\n          }\n          minch(dp[T],dp[S]+1);\n        }\n      }\n    }\n  }\n  return dp[0]<=m;\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)cin>>x[i]>>y[i];\n  double lb=1e-6,ub=1e7;\n  rep(hoge,50){\n    double mid=(ub+lb)/2.0;\n    if(ok(mid))ub=mid;\n    else lb=mid;\n  }\n  printf(\"%.10f\\n\", (lb+ub)/2.0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double PI=acos(-1);\nconst double EPS=1e-6;\n\nint N,M;\ndouble x[22],y[22];\n\nbool check(double mid){\n\tvector<int> m_list;\n\t\n\tREP(i,N){\n\t\tm_list.PB(1<<i);\n\t}\n\t\n\tREP(i,N)REP(j,N){\n\t\tif(i==j)continue;\n\t\tdouble dx=x[i]-x[j],dy=y[i]-y[j];\n\t\tdouble d=sqrt(dx*dx+dy*dy);\n\t\tif(d>mid*2+EPS)continue;\n\t\tdouble r=sqrt(mid*mid-d*d/4);\n\t\tdouble vx=-dy/d*r;\n\t\tdouble vy=dx/d*r;\n\n\t\tdouble xx=(x[i]+x[j])/2+vx;\n\t\tdouble yy=(y[i]+y[j])/2+vy;\n\t\tint cnt=0;\n\t\tREP(k,N){\n\t\t\tif((x[k]-xx)*(x[k]-xx)+(y[k]-yy)*(y[k]-yy)<mid*mid+EPS)cnt |= (1<<k);\n\t\t}\n\t\tm_list.PB(cnt);\n\t}\n\n\t/*\n\tREP(i,m_list.size()){\n\t\tcout << (static_cast<bitset<(unsigned)(10)>>(m_list[i])) << endl;\n\t}\n*/\t\n\t\n\tvector<int> dp(1 << N,INF);\n\tdp[0] = 0;\n\tREP(i,dp.size()){\n\t\tREP(j,m_list.size()){\n\t\t\tdp[i | m_list[j]] = min(dp[i] + 1 , dp[i | m_list[j]]);\n\t\t}\n\t}\n\t\n\tif(dp[(1 << N )- 1] == INF){\n\t\tREP(i,dp.size()){\n\t\t\tcout << (static_cast<bitset<(unsigned)(10)>>(dp[i])) << ' ' << dp[i] << endl;\n\t\t}\n\t}\n\t\n\t//cout << dp[(1 << N)-1] << endl;\n\treturn (dp[(1 << N)-1] <= M);\n}\n\nint main()\n{\n\tcin >> N >> M;\n\tvector<pair<int,int>> v;\n\tREP(i,N){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tv.erase(unique(ALL(v)),v.end());\n\t\n\tREP(i,v.size()){\n\t\tx[i] = v[i].FI;\n\t\ty[i] = v[i].SE;\n\t}\n\t\n\tN = v.size();\n\t\n\tdouble top = 1000000;\n\tdouble under = 0;\n\t\t\n\tREP(i,100){\n\t\tdouble mid = (top + under) / 2;\n\t//\tcout << mid << endl;\n\t\tif(check(mid))top = mid;\n\t\telse under = mid;\n\t}\n\t\n\tcout << Decimal << top << endl;\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\n\n\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<double> d(n),e(n);\n\tfor (uint32 i = 0;i < n;++i)  scan(d[i], e[i]); \n\tstd::vector<double> t(siz, -0.00001);\n\tfor (uint32 i = 0;i < siz;++i) {\n\t\tfor (uint32 j = 0;j < n;++j) {\n\t\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif ((i >> j & 1) && (i >> k & 1)) {\n\t\t\t\t\tbmaxi(t[i], (d[j] - d[k])*(d[j] - d[k]) + (e[j] - e[k])*(e[j] - e[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble low = 0, high = 200000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 500;++bs) {\n\t\tconst double mid = (low + high) / 2;\n\t\tconst double ch = mid*mid;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= ch) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tdouble ans = high / 2;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nconst double EPS = 1e-8, INF = 1e12, PI = 2 * acos(0.0);\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); } \n    bool operator == (const P& a, const P& b) { return abs(real(a) - real(b)) < EPS && abs(imag(a) - imag(b)) < EPS; }\n    P operator / (const P& a, const double& b) { return P(real(a) / b, imag(a) / b); }\n    P operator * (const P& a, const double& b) { return P(real(a) * b, imag(a) * b); }\n}\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nstruct L : public vector<P> { L() {} L(const P &a, const P &b) { push_back(a); push_back(b); } };\ntypedef vector<P> G;\nstruct C { P p; double r; C() {} C(const P &p, double r) : p(p), r(r) {} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return 0;       // counter clockwise\n\tif (cross(b, c) < 0)   return 1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nP rotate(P vec, double ang) {\n    double x = real(vec), y = imag(vec);\n    return P(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));\n}\nbool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n        abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n        cross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\nbool intersectSSwithoutPoint(const L &s, const L &t) { // not verified\n    return ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) < 0 &&\n        ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) < 0;\n}\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\ndouble argument(const P &a, const P &b) { // argument for A->B[-PI,PI]\n    double ax = real(a), ay = imag(a), bx = real(b), by = imag(b);\n    return atan2(by - ay, bx - ax);\n}\n// A->B->C時計回りの時の外角\n// argument for A->B->C\ndouble threePointArgumentTokei(const P &a, const P &b, const P &c) {\n    P ba = b - a;\n    P cb = c - b;\n\n    double r1 = atan2(real(ba), imag(ba)) - PI / 2.0;\n    while (r1<-PI) r1 += 2 * PI;\n    while (PI<r1) r1 -= 2 * PI;\n    double r2 = atan2(real(cb), imag(cb)) - PI / 2.0;\n    while (r2<-PI) r2 += 2 * PI;\n    while (PI<r2) r2 -= 2 * PI;\n\n    //cout << id << \"\\t\" << r1 << \"\\t\" << r2 << endl;\n\n    double range = 0;\n    if (r1 >= 0 && r2>0) range = r2 - r1;\n    else if (r1<0 && r2 >= 0) range = -r1 + r2;\n    else if (r1 >= 0 && r2<0) range = (PI - r1) + (PI + r2);\n    else range = r2 - r1;\n\n    return range;\n}\n// A-B-Cの成す各のうち小さい方\ndouble threePointArgument(const P &a, const P &b, const P &c) {\n    double x = argument(b, a);\n    double y = argument(b, c);\n\n    double res = x - y;\n    while (res < 0) res += PI * 2;\n    while (PI * 2 <= res) res -= PI * 2;\n\n    return min(res, 2 * PI - res);\n}\n// 三点より中心導出\nP three_point_circle(const P& a, const P& b, const P& c) {\n    P x = 1.0 / conj(b - a), y = 1.0 / conj(c - a);\n    return (y - x) / (conj(x)*y - x * conj(y)) + a;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M;\nP xy[14];\ndouble dp[1 << 14], dp2[14][1<<14];\n//---------------------------------------------------------------------------------------------------\nusing ld = double;\ndouble smallestEnclosingCircle(vector<P> &v) {\n    if (v.size() <= 1) return 0;\n\n    auto c3 = [](const P &a, const P &b, const P &c) {\n        ld A = norm(b - c);\n        ld B = norm(c - a);\n        ld Co = norm(a - b);\n        ld S = abs(cross(b - a, c - a));\n        P p = (A*(B + Co - A)*a + B * (Co + A - B)*b + Co * (A + B - Co)*c) / (4 * S*S);\n        ld r = abs(p - a);\n        return C(p, r);\n    };\n\n    auto c2 = [](const P &a, const P &b) {\n        P c = (a + b) / (ld)2;\n        ld r = abs(a - c);\n        return C(c, r);\n    };\n\n    auto in_circle = [](const P &a, const C &c) {\n        return norm(a - c.p) <= c.r *c.r + EPS;\n    };\n\n    int n = v.size();\n    random_shuffle(v.begin(), v.end());\n    C c = c2(v[0], v[1]);\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(v[i], c)) {\n            c = c2(v[0], v[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(v[j], c)) {\n                    c = c2(v[j], v[i]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(v[k], c)) {\n                            c = c3(v[i], v[j], v[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c.r;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n    rep(i, 0, N) {\n        double x, y;\n        cin >> x >> y;\n        xy[i] = P(x, y);\n    }\n\n    rep(msk, 0, 1 << N) {\n        vector<P> v;\n        rep(i, 0, N) if (msk & (1 << i)) v.push_back(xy[i]);\n\n        dp[msk] = smallestEnclosingCircle(v);\n    }\n\n    //rep(msk, 0, 1 << N) printf(\"dp[%d] = %.10f\\n\", msk, dp[msk]);\n\n    rep(i, 0, M + 1) rep(msk, 0, 1 << N) dp2[i][msk] = INF;\n    dp2[0][0] = 0;\n    rep(i, 1, M + 1) rep(msk, 0, 1 << N) {\n        for (int j = msk; j>0; j = (j - 1)&msk) {\n            chmin(dp2[i][msk], max(dp2[i - 1][msk - j], dp[j]));\n        }\n    }\n\n    double ans = INF;\n    rep(i, 0, M + 1) chmin(ans, dp2[i][(1 << N) - 1]);\n    printf(\"%.12f\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist2(double px, double py, double qx, double qy) {\n  return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] % 100000000;\n    Y[i] = P[i] / 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n\n    // cerr << \"s: \" << s << endl;\n\n    double minr2 = 1e20;\n    REP(i, 0, N) REP(j, i + 1, N) REP(k, j + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)) && (s & (1LL << k)))) continue;\n\n      // cerr << \"  i, j, k: \" << i << \" \" << j << \" \" << k << endl;\n\n      double d1x = +(Y[i] - Y[j]);\n      double d1y = -(X[i] - X[j]);\n      double m1x = (X[i] + X[j]) / 2.0;\n      double m1y = (Y[i] + Y[j]) / 2.0;\n      double d2x = +(Y[j] - Y[k]);\n      double d2y = -(X[j] - X[k]);\n      double m2x = (X[j] + X[k]) / 2.0;\n      double m2y = (Y[j] + Y[k]) / 2.0;\n\n      double x, y, r2;\n      if((d1y * d2x) - (d1x * d2y) < EPS) {\n        double di = dist2(X[j], Y[j], X[k], Y[k]);\n        double dj = dist2(X[k], Y[k], X[i], Y[i]);\n        double dk = dist2(X[i], Y[i], X[j], Y[j]);\n\n        // cerr << \"    di: \" << di << \", dj: \" << dj << \", dk: \" << dk << endl;\n\n        if(di > dj && di > dk) { x = (X[j] + X[k]) / 2.0; y = (Y[j] + Y[k]) / 2.0; r2 = pow(sqrt(di) / 2.0, 2); };\n        if(dj > dk && dj > di) { x = (X[k] + X[i]) / 2.0; y = (Y[k] + Y[i]) / 2.0; r2 = pow(sqrt(dj) / 2.0, 2); };\n        if(dk > di && dk > dj) { x = (X[i] + X[j]) / 2.0; y = (Y[i] + Y[j]) / 2.0; r2 = pow(sqrt(dk) / 2.0, 2); };\n      } else {\n\n        // cerr << \"    d1: (\" << d1x << \", \" << d1y << \"), m1: :(\" << m1x << \", \" << m1y << \")\" << endl;\n        // cerr << \"    d2: (\" << d2x << \", \" << d2y << \"), m2: :(\" << m2x << \", \" << m2y << \")\" << endl;\n\n        double a = d1x, b = -d2x, c = m2x - m1x;\n        double d = d1y, e = -d2y, f = m2y - m1y;\n\n        // cerr << \"    a: \" << a << \", b: \" << b << \", c: \" << c << endl;\n        // cerr << \"    d: \" << d << \", e: \" << e << \", f: \" << f << endl;\n\n        double t1 = (c * e - b * f) / (a * e - b * d);\n        double t2 = (c * d - a * f) / (b * d - a * e);\n        if(-EPS < t1 && t1 < EPS) t1 = 0;\n        if(-EPS < t2 && t2 < EPS) t2 = 0;\n\n        // cerr << \"    t1: \" << t1 << \", t2: \" << t2 << endl;\n\n        x = d1x * t1 + m1x;\n        y = d1y * t1 + m1y;\n        r2 = (X[i] - x) * (X[i] - x) + (Y[i] - y) * (Y[i] - y);\n      }\n\n      // cerr << \"    (x, y): (\" << x << \", \" << y << \"), r: \" << sqrt(r2) << endl;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r2 + EPS) ok = false;\n      if(ok) minr2 = min(minr2, r2);\n\n      // cerr << \"    ok: \" << ok << endl;\n    }\n    radius[s] = sqrt(minr2);\n\n    // cerr << s << \": \" << radius[s] << endl;\n  }\n\n  REP(i, 0, N) radius[1LL << i] = 0.0;\n  REP(i, 0, N) REP(j, 0, N) radius[(1LL << i) | (1LL << j)] = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e20));\n  dp[0][0] = 0.0;\n  REP(s, 0, 1LL << N) REP(i, 0, M) {\n    // cerr << s << \", \" << i << \": \" << dp[s][i] << endl;\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e20;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\n#define double long double\n\nconst double EPS = 1e-8;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD &ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    // REP(i,n){\n    //     p[i].first += (rand() % 1000000) / 10000000000.0;\n    //     p[i].second += (rand() % 1000000) / 10000000000.0;\n    // }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10Lf\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n\nusing R = long double;\nusing P = complex<R>;\n\nconst R EPS = 1e-10;\nconst R PI = acos(R(-1));\n\nint sgn(R a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(P l, P r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/*\n  1->cclock\n -1->clock\n  0->on\n  2->back\n -2->front\n */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {}\n    L(P x, P y) :x(x), y(y) {}\n    P vec() { return y-x; }\n};\n\nstruct T {\n    P d[3];\n    T() {}\n    T(P x, P y, P z) {\n        d[0] = x; d[1] = y; d[2] = z;\n    }\n    P& operator[](int p) {\n        return d[p];\n    }\n    const P& operator[](int p) const {\n        return d[p];\n    }\n    int size() const {\n        return 3;\n    }\n};\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\nC circumCircle(T t) {\n    P a = t.d[0], b = t.d[1], c = t.d[2];\n    b -= a; c -= a;\n    R s = 2*cross(b, c);\n    R x = norm(b-c), y = norm(c), z = norm(b);\n    R S = x+y+z;\n    P r = (y*(S-2*y)*b+z*(S-2*z)*c)/(s*s);\n    return C(r + a, abs(r));\n}\n\nC smallestEnclosingCircle(Pol &p, int ps, T q = T(), int qs = 0) {\n    if (!ps) {\n        switch (qs) {\n            case 0:\n                return C(P(0, 0), -1);\n            case 1:\n                return C(q.d[0], 0);\n            case 2:\n                return C((q.d[0]+q.d[1])/R(2.0), abs(q.d[0]-q.d[1])/R(2.0));\n            case 3:\n                return circumCircle(q);\n        }\n        assert(false);\n    }\n    C c = smallestEnclosingCircle(p, ps-1, q, qs);\n    if (sgn(c.r, abs(p[ps-1]-c.p)) == 1) {\n        q.d[qs] = p[ps-1];\n        return smallestEnclosingCircle(p, ps-1, q, qs+1);\n    }\n    return c;\n}\n\nconst int MN = 14;\nconst int MM = 14;\nint n, m;\nP p[MN];\nR pre[1<<MN];\nR dp[MM+1][1<<MN];\nbool vis[MM+1][1<<MN];\n\nR solve(int f, int m) {\n    if (f == 0) return 0;\n    if (m == 0) return 1e100;\n    if (vis[m][f]) return dp[m][f];\n    vis[m][f] = true;\n    R ans = 1e100;\n    int g = 0;\n    do {\n        ans = min(ans, max(pre[g], solve(f^g, m-1)));\n        g = ((g|~f)+1) & f;\n    } while (g);\n    return dp[m][f] = ans;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int f = 0; f < (1<<n); f++) {\n        V<P> v;\n        for (int i = 0; i < n; i++) {\n            if (!(f & (1<<i))) continue;\n            v.push_back(p[i]);\n        }\n        pre[f] = smallestEnclosingCircle(v, int(v.size())).r;\n\n//        cout << f << \" \" << pre[f] << endl;\n    }\n\n    cout << solve((1<<n) - 1, m) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\n#define double long double\n\nconst double EPS = 1e-8;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    // REP(i,n){\n    //     p[i].first += (rand() % 1000000) / 10000000000.0;\n    //     p[i].second += (rand() % 1000000) / 10000000000.0;\n    // }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10Lf\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n//#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define EPS 0.0000001\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(){\n\n\t}\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nint N,M;\nint POW[15];\ndouble dp[15][1 << 15];\ndouble NUM = 20000000;\nPoint point[15];\n\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\n\ndouble calc_slope(Line A){\n\n\tif(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n\t\treturn DBL_MAX;\n\n\t}else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n\t\treturn 0;\n\n\t}else{\n\n\t\treturn (A.p[1].y-A.p[0].y)/(A.p[1].x-A.p[0].x);\n\t}\n}\n\n//交点を求める関数\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n//線分ではなく直線と点の距離\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\n//点と線分の距離\ndouble getDistanceSP(Line l,Point p){\n\tif(dot(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0])) < 0.0)return calc_len(calc_minus(p,l.p[0]));\n\tif(dot(calc_minus(l.p[0],l.p[1]),calc_minus(p,l.p[1])) < 0.0)return calc_len(calc_minus(p,l.p[1]));\n\treturn getDistanceLP(l,p);\n}\n\n//線分と線分の距離\ndouble getDistance(Line A,Line B){\n\tif(is_Cross(A,B))return 0.0;\n\treturn min(min(getDistanceSP(A,B.p[0]),getDistanceSP(A,B.p[1])),\n\t\t\tmin(getDistanceSP(B,A.p[0]),getDistanceSP(B,A.p[1])));\n}\n\nPoint calc_Cross_Point(Line A,Line B){\n\n\tif(getDistanceSP(B,A.p[0]) < EPS){\n\n\t\treturn A.p[0];\n\n\t}else if(getDistanceSP(B,A.p[1]) < EPS){\n\n\t\treturn A.p[1];\n\n\t}else if(getDistanceSP(A,B.p[0]) < EPS){\n\n\t\treturn B.p[0];\n\n\t}else if(getDistanceSP(A,B.p[1]) < EPS){\n\n\t\treturn B.p[1];\n\t}\n\n\treturn calc_Cross_Point(A.p[0],A.p[1],B.p[0],B.p[1]);\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < 15; i++){\n\n\t\tPOW[i] = POW[i-1]*2;\n\t}\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tfor(int i = 0; i <= M; i++){\n\t\tfor(int state = 0; state < POW[N]; state++){\n\n\t\t\tdp[i][state] = BIG_NUM;\n\t\t}\n\t}\n\n\tvector<int> V;\n\n\n\tLine line1,line2;\n\tPoint center;\n\n\tfor(int state = 1; state < POW[N]; state++){\n\n\t\tV.clear();\n\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tif(state & POW[loop]){\n\n\t\t\t\tV.push_back(loop);\n\t\t\t}\n\t\t}\n\n\t\tif(V.size() == 1){\n\n\t\t\tdp[1][state] = 0;\n\t\t\t//printf(\"dp[1][%d]:%.3lf\\n\",state,dp[1][state]);\n\t\t\tcontinue;\n\n\t\t}else if(V.size() == 2){\n\n\t\t\tdp[1][state] = calc_dist(point[V[0]],point[V[1]])/2;\n\n\t\t\tint work_state = state;\n\n\t\t\tcenter = Point((point[V[0]].x+point[V[1]].x)/2,(point[V[0]].y+point[V[1]].y)/2);\n\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tif(k == V[0] || k == V[1])continue;\n\n\t\t\t\tif(calc_dist(center,point[k]) <= dp[1][state]){\n\n\t\t\t\t\twork_state += POW[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[1][work_state] = min(dp[1][work_state],dp[1][state]);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//3点以上\n\n\t\t//2点を直径とする\n\t\tfor(int a = 0; a < V.size()-1; a++){\n\t\t\tfor(int b = a+1; b < V.size(); b++){\n\n\t\t\t\tcenter = Point((point[V[a]].x+point[V[b]].x)/2,(point[V[a]].y+point[V[b]].y)/2);\n\n\t\t\t\tdouble tmp_dist = calc_dist(point[V[a]],point[V[b]])/2;\n\n\t\t\t\tbool FLG = true;\n\t\t\t\tfor(int k = 0; k < V.size(); k++){\n\n\t\t\t\t\tif(k == a || k == b)continue;\n\n\t\t\t\t\tif(calc_dist(center,point[V[k]]) > tmp_dist){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(FLG){\n\n\t\t\t\t\tdp[1][state] = min(dp[1][state],tmp_dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//3点を通る\n\t\tfor(int a = 0; a < V.size()-2; a++){\n\t\t\tfor(int b = a+1; b < V.size()-1; b++){\n\t\t\t\tfor(int c = b+1; c < V.size(); c++){\n\n\t\t\t\t\tdouble slope1 = calc_slope(Line(point[V[a]],point[V[b]]));\n\t\t\t\t\tdouble slope2 = calc_slope(Line(point[V[b]],point[V[c]]));\n\n\t\t\t\t\tif(fabs(slope1-slope2) < EPS){ //一直線上\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tPoint mid1 = Point((point[V[a]].x+point[V[b]].x)/2,(point[V[a]].y+point[V[b]].y)/2);\n\t\t\t\t\t\tPoint mid2 = Point((point[V[b]].x+point[V[c]].x)/2,(point[V[b]].y+point[V[c]].y)/2);\n\n\t\t\t\t\t\tif(fabs(slope1-DBL_MAX) < EPS){ //垂直\n\n\t\t\t\t\t\t\tline1.p[0] = Point(-NUM,mid1.y);\n\t\t\t\t\t\t\tline1.p[1] = Point(NUM,mid1.y);\n\n\t\t\t\t\t\t}else if(fabs(slope1) < EPS){ //水平\n\n\t\t\t\t\t\t\tline1.p[0] = Point(mid1.x,NUM);\n\t\t\t\t\t\t\tline1.p[1] = Point(mid1.x,-NUM);\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tslope1 = (-1.0)/slope1;\n\n\t\t\t\t\t\t\tline1.p[0] = Point(mid1.x-NUM,mid1.y-NUM*slope1);\n\t\t\t\t\t\t\tline1.p[1] = Point(mid1.x+NUM,mid1.y+NUM*slope1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(fabs(slope2-DBL_MAX) < EPS){ //垂直\n\n\t\t\t\t\t\t\tline2.p[0] = Point(-NUM,mid2.y);\n\t\t\t\t\t\t\tline2.p[1] = Point(NUM,mid2.y);\n\n\t\t\t\t\t\t}else if(fabs(slope2) < EPS){ //水平\n\n\t\t\t\t\t\t\tline2.p[0] = Point(mid2.x,NUM);\n\t\t\t\t\t\t\tline2.p[1] = Point(mid2.x,-NUM);\n\n\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\tslope2 = (-1.0)/slope2;\n\n\t\t\t\t\t\t\tline2.p[0] = Point(mid2.x-NUM,mid2.y-NUM*slope2);\n\t\t\t\t\t\t\tline2.p[1] = Point(mid2.x+NUM,mid2.y+NUM*slope2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcenter =  calc_Cross_Point(line1,line2);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tdouble tmp_dist = calc_dist(center,point[V[a]]);\n\n\t\t\t\t\tbool FLG = true;\n\t\t\t\t\tfor(int k = 0; k < V.size(); k++){\n\n\t\t\t\t\t\tif(k == a || k == b || k == c)continue;\n\n\t\t\t\t\t\tif(calc_dist(center,point[V[k]]) > tmp_dist){\n\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(FLG){\n\n\t\t\t\t\t\tdp[1][state] = min(dp[1][state],tmp_dist);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\tint tmp_state;\n\n\tfor(int state = 1; state < POW[N]-1; state++){\n\n\t\tV.clear();\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tif(state & POW[loop]){\n\n\t\t\t\t//Do nothing\n\n\t\t\t}else{\n\n\t\t\t\tV.push_back(loop);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= M-1; i++){\n\t\t\tif(fabs(dp[i][state]-BIG_NUM) < EPS)continue;\n\n\t\t\tfor(int a = 1; a < POW[V.size()]; a++){ //足し合わせる状態\n\n\t\t\t\ttmp_state = 0;\n\n\t\t\t\tfor(int loop = 0; loop < V.size(); loop++){\n\t\t\t\t\tif(a & POW[loop]){\n\n\t\t\t\t\t\ttmp_state += POW[V[loop]];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdp[i+1][state+tmp_state] = min(dp[i+1][state+tmp_state],max(dp[i][state],dp[1][tmp_state]));\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = BIG_NUM;\n\tfor(int i = 1; i <= M; i++){\n\n\t\tans = min(ans,dp[i][POW[N]-1]);\n\t}\n\n\tprintf(\"%.10lf\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return mysqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\nprivate:\n\tstatic const double mysqrt(const double &x) {\n\t\tdouble h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tdouble r = *(double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\n\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x.x, x.y);\n\tstd::vector<double> t(siz, -0.00001);\n\tfor (uint32 i = 0;i < siz;++i) {\n\t\tfor (uint32 j = 0;j < n;++j) {\n\t\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif ((i >> j & 1) && (i >> k & 1)) {\n\t\t\t\t\tbmaxi(t[i], (d[j] - d[k]).abs2());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble low = 0, high = 200000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 50;++bs) {\n\t\tdouble mid = (low + high) / 2;\n\t\tconst double ch = mid*mid;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= ch) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tprintln(high/2.0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//典型的な前処理O(N * 2^N) + O(M * 3^N)のDPで、最小包含円を求めるのが本質。O(N^3)かけても間に合うのが\n//優しいけど、ちょっとライブラリを探してきた。\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nvoid chmin(double &a, double b) { a = min(a, b); }\n\n//BEGIN: https://tubo28.me/algorithm/minball/\nusing ld = double;\nusing P = complex<ld>;\ndouble eps = 1e-12;\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right, int seed = 1333) {\n    const int n = right - left;\n\n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n\n    std::mt19937 mt(seed);\n    std::shuffle(left, right, mt);\n    // std::random_shuffle(left, right); // simple but deprecated\n\n    iter ps = left;\n    using circle = std::pair<P, ld>;\n\n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n           S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n\n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n\n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n\n    circle c = make_circle_2(ps[0], ps[1]);\n\n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n//END\n\nint n, m;\nP p[14];\ndouble radius[1 << 14];\ndouble dp[15][1 << 14];\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\trep(i, n) {\n\t\tdouble x, y; cin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\t\n\trep(i, (1 << n)) {\n\t\tif (i == 0) continue;\n\t\tvector<P> ps;\n\t\trep(j, n) {\n\t\t\tif ((i >> j) % 2 == 1) {\n\t\t\t\tps.push_back(p[j]);\n\t\t\t}\n\t\t}\n\t\tradius[i] = min_ball(ps.begin(), ps.end()).second;\n\t\tradius[i] = sqrt(radius[i]);\n\t}\n\n\tdouble INF = 1e+9;\n\trep(i, n + 1) rep(j, (1 << n)) dp[i][j] = INF;\n\t\n\tdp[0][0] = 0;\n\trep(i, m) {\n\t\trep(j, (1 << n)) {\n\t\t\t//参考：https://kimiyuki.net/blog/2017/07/16/enumerate-sets-with-bit-manipulation/\n\t\t\tint z = (1 << n) - 1 - j;\n\t\t\tfor (int y = 0; ; y = (y - z) & z) {\n\t\t\t\tchmin(dp[i + 1][j + y], max(dp[i][j], radius[y]));\n\t\t\t\tif (y == z) break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = INF;\n\trep(i, m + 1) {\n\t\tchmin(ans, dp[i][(1 << n) - 1]);\n\t}\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.l);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0l, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\nbool solve(vector<pair<ld, vector<int>>>bombs, int N, int M, ld len) {\n\t{\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (int i = 0; i < bombs.size(); ++i) {\n\t\t\tld r=bombs[i].first;\n\t\t\tif(r<len)n_bombs.emplace_back(bombs[i]);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tvector<vector<int>>memo(M+1,vector<int>(1<<N));\n\tmemo[0][0]=true;\n\tfor (int b_use = 0; b_use < M; ++b_use) {\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tif(!memo[b_use][i])continue;\n\n\t\t\tfor (auto&& now_b : bombs) {\n\n\t\t\t\tbitset<14>bs(i);\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif(now_b.second[j])bs[j]=true;\n\t\t\t\t}\n\t\t\t\tmemo[b_use+1][bs.to_ulong()]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[M][(1<<N)-1];\n}\n\n\n\nint main() {\n\tint N,M;cin>>N>>M;\n\tvector<Point>pos;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x,y;cin>>x>>y;\n\t\tpos.push_back(Point(x,y));\n\t}\n\n\tvector<pair<ld,vector<int>>>bombs;\n\t{\n\t\tvector<int>v(3);\n\t\tfor (v[0] = 0; v[0] < N; ++v[0]) {\n\t\t\t{\n\t\t\t\tld r=1e-8;\n\t\t\t\tCircle c(pos[v[0]], r);\n\n\t\t\t\tvector<int>oks(N);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t}\n\t\t\tfor ( v[1] = v[0] + 1; v[1] < N; ++v[1]) {\n\t\t\t\t{\n\t\t\t\t\tPoint p((pos[v[0]]+pos[v[1]])/2.0l);\n\t\t\t\t\tconst ld r = abs(p - pos[v[0]]);\n\t\t\t\t\tCircle c(p, r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (v[2] = v[1] + 1; v[2] < N; ++v[2]) {\n\t\t\t\t\tvector<Point>ci_pos(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tci_pos[i]=pos[v[i]];\n\t\t\t\t\t}\n\t\t\t\t\tLine l1 = point_bisection(ci_pos[0], ci_pos[1]);\n\t\t\t\t\tLine l2 = point_bisection(ci_pos[1], ci_pos[2]);\n\t\t\t\t\tPoint sv = l1.b - l1.a, tv = l2.b - l2.a;\n\t\t\t\t\tif (abs(cross(sv, tv)) < eps) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tPoint p(outer_center(ci_pos));\n\t\t\t\t\tconst ld r=abs(p-ci_pos[0]);\n\t\t\t\t\tCircle c(p,r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r,oks));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tmap<int, ld>mp;\n\t\tfor (auto&& bomb : bombs) {\n\t\t\tbitset<14>bs;\n\t\t\tfor (int i = 0; i < bomb.second.size(); ++i) {\n\t\t\t\tif(bomb.second[i])bs[i]=true;\n\t\t\t}\n\t\t\tif (mp.find(bs.to_ulong()) == mp.end()) {\n\t\t\t\tmp[bs.to_ulong()]=bomb.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[bs.to_ulong()]=min(bomb.first,mp[bs.to_ulong()]);\n\t\t\t}\n\t\t}\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (auto m : mp) {\n\t\t\tbitset<14>bs(m.first);\n\t\t\tvector<int>v(N);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif(bs[i])v[i]=true;\n\t\t\t}\n\t\t\tn_bombs.emplace_back(m.second,v);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tld l=0,r=1e9;\n\tint time=50;\n\twhile (time--) {\n\t\tld m=(l+r)/2;\n\t\tif (solve(bombs, N, M, m)) {\n\t\t\tr=m;\n\t\t}\n\t\telse {\n\t\t\tl=m;\n\t\t}\n\t}\n\tcout<<setprecision(10)<<fixed;\n\tcout<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//典型的な前処理O(N * 2^N) + O(M * 3^N)のDPで、最小包含円を求めるのが本質。O(N^3)かけても間に合うのが\n//優しいけど、ちょっとライブラリを探してきた。\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nvoid chmin(double &a, double b) { a = min(a, b); }\n\n//BEGIN: https://tubo28.me/algorithm/minball/\nusing ld = double;\nusing P = complex<ld>;\ndouble eps = 1e-12;\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right, int seed = 1333) {\n    const int n = right - left;\n\n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n\n    std::mt19937 mt(seed);\n    std::shuffle(left, right, mt);\n    // std::random_shuffle(left, right); // simple but deprecated\n\n    iter ps = left;\n    using circle = std::pair<P, ld>;\n\n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n           S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n\n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n\n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n\n    circle c = make_circle_2(ps[0], ps[1]);\n\n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n//END\n\nint n, m;\nP p[14];\ndouble radius[1 << 14];\ndouble dp[15][1 << 14];\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\trep(i, n) {\n\t\tdouble x, y; cin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\t\n\trep(i, (1 << n)) {\n\t\tif (i == 0) continue;\n\t\tvector<P> ps;\n\t\trep(j, n) {\n\t\t\tif ((i >> j) % 2 == 1) {\n\t\t\t\tps.push_back(p[j]);\n\t\t\t}\n\t\t}\n\t\tradius[i] = min_ball(ps.begin(), ps.end()).second;\n\t\tradius[i] = sqrt(radius[i]);\n\t}\n\n\tdouble INF = 1e+9;\n\trep(i, n + 1) rep(j, (1 << n)) dp[i][j] = INF;\n\t\n\tdp[0][0] = 0;\n\trep(i, m) {\n\t\trep(j, (1 << n)) {\n\t\t\t//参考：https://kimiyuki.net/blog/2017/07/16/enumerate-sets-with-bit-manipulation/\n\t\t\tint z = (1 << n) - 1 - j;\n\t\t\tfor (int y = 0; ; y = (y - z) & z) {\n\t\t\t\tchmin(dp[i + 1][j + y], max(dp[i][j], radius[y]));\n\t\t\t\tif (y == z) break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = INF;\n\trep(i, m + 1) {\n\t\tchmin(ans, dp[i][(1 << n) - 1]);\n\t}\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-13;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    REP(i,n){\n        p[i].first += (rand() % 1000000) / 1000000000.0;\n        p[i].second += (rand() % 1000000) / 1000000000.0;\n    }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\n#define double long double\n\nconst double EPS = 1e-16;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    // REP(i,n){\n    //     p[i].first += (rand() % 1000000) / 10000000000.0;\n    //     p[i].second += (rand() % 1000000) / 10000000000.0;\n    // }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10Lf\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double PI = acos(-1);\nconst double EPS = 1e-9; // 許容誤差^2\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) - (m) < EPS)\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 点集合を含む最小の円の中心\nPoint minEnclosingCircle(const VP& ps) {\n  Point c;\n  double move = 0.5;\n  rep(i,30) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,30) {\n      double max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n\nPoint READ(){\n    int x,y;\n    cin >>x >>y;\n    return Point(x,y);\n}\n\nconst int N = 14;\nconst int INF = 19191919;\nint dp[1<<N];\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    VP p(n);\n    rep(i,n) p[i] = READ();\n\n    vector<double> r(1<<n);\n    for(int mask=1; mask<(1<<n); ++mask){\n        VP pts;\n        rep(i,n)if(mask>>i&1) pts.pb(p[i]);\n\n        Point c = minEnclosingCircle(pts);\n        for(Point pp:pts) r[mask] = max(r[mask], abs(pp-c));\n    }\n\n    auto check = [&](double lim){\n        rep(i,1<<n) dp[i] = INF;\n        dp[(1<<n)-1] = 0;\n\n        for(int mask = (1<<n)-1; mask>0; --mask){\n            int sub = mask;\n            do{\n                sub = sub-1;\n                sub &= mask;\n                int tgt = mask^sub;\n                if(r[tgt] <= lim) dp[sub] = min(dp[sub], dp[mask]+1);\n            }while(sub>0);\n        }\n\n        return dp[0]<=m;\n    };\n\n    double ng=0, ok = 500000;\n    rep(loop,100){\n        double mid = (ng+ok)/2;\n        if(check(mid)) ok = mid;\n        else ng = mid;\n    }\n    printf(\"%.10f\\n\", ok);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr long double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(long double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<long double>(long double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\n\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return mysqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\n\tfriend std::istream &operator>>(std::istream &is, pvec &o) {\n\t\tdouble x_, y_;is >> x_ >> y_;o = pvec(x_, y_);return (is);\n\t}\nprivate:\n\tstatic const double mysqrt(const double &x) {\n\t\tdouble h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tdouble r = *(double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\nvoid scan(pvec &d) { scan(d.x, d.y); }\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x);\n\tstd::vector<long double> t(siz, -0.00001);\n\tfor (uint32 i = 1;i < siz;++i) {\n\t\tdouble mix = 200000, max = 0, miy = 200000, may = 0;\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tbmini(mix, d[k].x);bmaxi(max, d[k].x);\n\t\t\t\tbmini(miy, d[k].y);bmaxi(may, d[k].y);\n\t\t\t}\n\t\t}\n\t\tpvec cent((max + mix) / 2, (may + miy) / 2);\n\t\tdouble dist = std::max((max - mix) / 2, (may - miy) / 2);\n\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\tif (i >> k & 1) {\n\t\t\t\tif ((d[k] - cent).abs() > dist) {\n\t\t\t\t\tpvec temp = (d[k] - cent)*dist / ((d[k] - cent).abs());\n\t\t\t\t\ttemp = cent - temp;\n\t\t\t\t\tcent = (temp + d[k]) / 2;\n\t\t\t\t\tdist = (d[k] - cent).abs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt[i] = dist;\n\t}\n\tlong double low = 0, high = 100000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 100;++bs) {\n\t\tconst long double mid = (low + high) / 2;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tlong double ans = high;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.l);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0l, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\nbool solve(vector<pair<ld, vector<int>>>bombs, int N, int M, ld len) {\n\t{\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (int i = 0; i < bombs.size(); ++i) {\n\t\t\tld r=bombs[i].first;\n\t\t\tif(r<len)n_bombs.emplace_back(bombs[i]);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tvector<vector<int>>memo(M+1,vector<int>(1<<N));\n\tmemo[0][0]=true;\n\tfor (int b_use = 0; b_use < M; ++b_use) {\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tif(!memo[b_use][i])continue;\n\n\t\t\tfor (auto&& now_b : bombs) {\n\n\t\t\t\tbitset<14>bs(i);\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif(now_b.second[j])bs[j]=true;\n\t\t\t\t}\n\t\t\t\tmemo[b_use+1][bs.to_ulong()]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[M][(1<<N)-1];\n}\n\n\n\nint main() {\n\tint N,M;cin>>N>>M;\n\tvector<Point>pos;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x,y;cin>>x>>y;\n\t\tpos.push_back(Point(x,y));\n\t}\n\n\tvector<pair<ld,vector<int>>>bombs;\n\t{\n\t\tvector<int>v(3);\n\t\tfor (v[0] = 0; v[0] < N; ++v[0]) {\n\t\t\t{\n\t\t\t\tld r=1e-8;\n\t\t\t\tCircle c(pos[v[0]], r);\n\n\t\t\t\tvector<int>oks(N);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t}\n\t\t\tfor ( v[1] = v[0] + 1; v[1] < N; ++v[1]) {\n\t\t\t\t{\n\t\t\t\t\tPoint p((pos[v[0]]+pos[v[1]])/2.0l);\n\t\t\t\t\tconst ld r = abs(p - pos[v[0]]);\n\t\t\t\t\tCircle c(p, r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (v[2] = v[1] + 1; v[2] < N; ++v[2]) {\n\t\t\t\t\tvector<Point>ci_pos(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tci_pos[i]=pos[v[i]];\n\t\t\t\t\t}\n\t\t\t\t\tLine l1 = point_bisection(ci_pos[0], ci_pos[1]);\n\t\t\t\t\tLine l2 = point_bisection(ci_pos[1], ci_pos[2]);\n\t\t\t\t\tPoint sv = l1.b - l1.a, tv = l2.b - l2.a;\n\t\t\t\t\tif (abs(cross(sv, tv)) < eps) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tPoint p(outer_center(ci_pos));\n\t\t\t\t\tconst ld r=abs(p-ci_pos[0]);\n\t\t\t\t\tCircle c(p,r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r,oks));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tld l=0,r=1e9;\n\tint time=50;\n\twhile (time--) {\n\t\tld m=(l+r)/2;\n\t\tif (solve(bombs, N, M, m)) {\n\t\t\tr=m;\n\t\t}\n\t\telse {\n\t\t\tl=m;\n\t\t}\n\t}\n\tcout<<setprecision(10)<<fixed;\n\tcout<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\n#define double long double\n\nconst double EPS = 1e-12;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    REP(i,n){\n        p[i].first += (rand() % 1000000) / 10000000000.0;\n        p[i].second += (rand() % 1000000) / 10000000000.0;\n    }\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10Lf\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <assert.h>\n#include <algorithm>\n#include <iomanip>\n#include <bitset>\n#include <cmath>\nusing namespace std;\n\nusing ld = long double;\nusing P = std::complex<ld>;\nusing G = std::vector<P>;\nconst ld pi = std::acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P &a, const P &b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(const P &a, const P &b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\n/*\n                    CCW\n\n -- BEHIND -- [a -- ON -- b] --- FRONT --\n\n                    CW\n */\nenum CCW_RESULT { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps) return CCW;    // counter clockwise\n    if (cross(b, c) < -eps) return CW;    // clockwise\n    if (dot(b, c) < 0) return BEHIND;     // c--a--b on line\n    if (norm(b) < norm(c)) return FRONT;  // a--b--c on line\n    return ON;\n}\n\nnamespace std {\nbool operator<(const P &a, const P &b) {\n    return std::abs(real(a) - real(b)) > eps ? real(a) < real(b) : imag(a) < imag(b);\n}\n}\n\nstruct L : public std::vector<P> {\n    L(const P &a = P(), const P &b = P()) : std::vector<P>(2) {\n        begin()[0] = a;\n        begin()[1] = b;\n    }\n\n    // Ax + By + C = 0\n    L(ld A, ld B, ld C) {\n        if (std::abs(A) < eps && std::abs(B) < eps) {\n            abort();\n        } else if (std::abs(A) < eps) {\n            *this = L(P(0, -C / B), P(1, -C / B));\n        } else if (std::abs(B) < eps) {\n            *this = L(P(-C / A, 0), P(-C / A, 1));\n        } else {\n            *this = L(P(0, -C / B), P(-C / A, 0));\n        }\n    }\n};\n\nstruct C {\n    P p;\n    ld r;\n    C(const P &p = 0, ld r = 0) : p(p), r(r) {}\n};\n\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right) {\n    int n = right - left;\n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n\n    random_shuffle(left, right);\n    iter ps = left;\n    using circle = std::pair<P, ld>;\n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n           S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n\n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n\n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n\n    circle c = make_circle_2(ps[0], ps[1]);\n    // int n = right - left;\n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\nconst double INF = 1e30;\n\ndouble minr[1 << 14];\ndouble dp[15][1 << 14];\ndouble x[14], y[14];\n\ndouble f(int remexp, int hero) {\n    if (dp[remexp][hero] >= 0) {\n        return dp[remexp][hero];\n    }\n\n    if (remexp == 0) {\n        if (hero == 0) return 0;\n        else return INF;\n    }\n\n    double ret = (hero == 0) ? 0 : INF;\n\n    int comb = hero;\n    do {\n        ret = min(ret, max(minr[comb], f(remexp - 1, hero & ~comb)));\n        comb = (comb - 1) & hero;\n    } while (comb != hero);\n    return dp[remexp][hero] = ret;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // 初期化\n    for (int i = 0; i <= M; i++) {\n        for (int mask = 0; mask < (1 << N); mask++) {\n            dp[i][mask] = -1;\n        }\n    }\n    minr[0] = 0;\n    for (int mask = 1; mask < (1 << N); mask++) {\n        vector<P> points;\n        for (int i = 0; i < N; i++) {\n            if ((mask >> i) & 1) points.push_back(P(x[i], y[i]));\n        }\n        minr[mask] = sqrt(min_ball(points.begin(), points.end()).second);\n\n        // cerr << bitset<8>(mask) << \" : \" << minr[mask] << endl; \n    }\n\n    cout << fixed << setprecision(10) << f(M, (1 << N) - 1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG g(n);\n\trep(i,n)g[i]=pin();\n\t\n\tdouble l=0,r=100000;\n\twhile(r-l>1e-5){\n\t\tdouble h=(l+r)/2;\n\t\tvd dp(1<<n,inf);\n\t\tdp[0]=0;\n\t\trep(i,1<<n)rep(j,n)if((i&1<<j)==0){\n\t\t\trep(k,n)if((i&1<<k)==0&&abs(g[j]-g[k])<EPS+2*h)rep(q,2){\n\t\t\t\tint t=i;\n\t\t\t\tt|=1<<j;\n\t\t\t\tt|=1<<k;\n\t\t\t\tP tmp=g[k]-g[j];\n\t\t\t\tP p=g[j]+tmp/2.+tmp*P(0,q?1:-1)/abs(tmp)*sqrt(h*h-abs(tmp)*abs(tmp)/4);\n\t\t\t\trep(l,n){\n\t\t\t\t\tif(abs(g[l]-p)<EPS+h){\n\t\t\t\t\t\tt|=1<<l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[t]=min(dp[t],dp[i]+1);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"! \"<<dp[\n\t\tint c=dp[(1<<n)-1];\n//\t\tcout<<c<<\" \"<<shosu(6)<<h<<endl;\n\t\tif(c<=m)r=h;\n\t\telse l=h;\n\t}\n\tcout<<shosu(7)<<r<<endl;\n}\n/*\n5 2\n0 0 5 5 10 10 100 100 200 200\n5 2\n0 0 5 5 10 10 100 100 200 200\n*/\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG g(n);\n\trep(i,n)g[i]=pin();\n\t\n\tdouble l=0,r=100000;\n\twhile(r-l>1e-5){\n\t\tdouble h=(l+r)/2;\n\t\tvd dp(1<<n,inf);\n\t\tdp[0]=0;\n\t\trep(i,1<<n)rep(j,n)if((i&1<<j)==0){\n\t\t\trep(k,n)if((i&1<<k)==0&&abs(g[j]-g[k])<EPS+2*h)rep(q,2){\n\t\t\t\tint t=i;\n\t\t\t\tt|=1<<j;\n\t\t\t\tt|=1<<k;\n\t\t\t\tP tmp=g[k]-g[j];\n\t\t\t\tP p=g[j]+tmp/2.+tmp*P(0,q?1:-1)/abs(tmp)*sqrt(h*h-abs(tmp)*abs(tmp));\n\t\t\t\trep(l,n){\n\t\t\t\t\tif(abs(g[l]-p)<EPS+h){\n\t\t\t\t\t\tt|=1<<l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[t]=min(dp[t],dp[i]+1);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"! \"<<dp[\n\t\tint c=dp[(1<<n)-1];\n//\t\tcout<<c<<\" \"<<shosu(6)<<h<<endl;\n\t\tif(c<=m)r=h;\n\t\telse l=h;\n\t}\n\tcout<<shosu(7)<<r<<endl;\n}\n/*\n5 2\n0 0 5 5 10 10 100 100 200 200\n5 2\n0 0 5 5 10 10 100 100 200 200\n*/\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint n, m;\nld x[14], y[14];\nld d[14][14];\nld rd[1 << 14];\nbool can(int s,ld r) {\n\tvector<int> v;\n\trep(i, n) {\n\t\tif (s&(1 << i))v.push_back(i);\n\t}\n\tif (v.size() <= 1)return true;\n\tint len = v.size();\n\trep(i, len) {\n\t\tRep(j, i + 1, len) {\n\t\t\tint id = v[i], jd = v[j];\n\t\t\tif (2*r < d[id][jd])return false;\n\t\t\tld X = (x[jd] - x[id]) / 2.0;\n\t\t\tld Y = (y[jd] - y[id]) / 2.0;\n\t\t\tld dist = sqrt(pow(r, 2) - pow(d[id][jd] / 2.0, 2));\n\t\t\tld sr = d[id][jd] / 2.0;\n\t\t\tld x3 = Y * dist / sr; ld y3 = -X * dist / sr;\n\t\t\tld midx = (x[id] + x[jd]) / 2.0, midy = (y[id] + y[jd]) / 2.0;\n\t\t\tld cx = x3 + midx, cy = y3 + midy;\n\t\t\tbool valid = true;\n\t\t\trep(k, len) {\n\t\t\t\tint kd = v[k];\n\t\t\t\tld dis = sqrt(pow(cx - x[kd], 2) + pow(cy - y[kd], 2));\n\t\t\t\tif (dis > r+eps) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid)return true;\n\t\t\tvalid = true;\n\t\t\tcx = -x3 + midx, cy = -y3 + midy;\n\t\t\trep(k, len) {\n\t\t\t\tint kd = v[k];\n\t\t\t\tld dis = sqrt(pow(cx - x[kd], 2) + pow(cy - y[kd], 2));\n\t\t\t\tif (dis > r+eps) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid)return true;\n\t\t}\n\t}\n\treturn false;\n}\nld dp[1 << 14], cop[1 << 14];\nint main() {\n\tcin >> n >> m;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\td[i][j] = sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2));\n\t\t}\n\t}\n\trep(i, (1 << n)) {\n\t\tld le = 0, ri = 200000;\n\t\twhile (ri - le > eps) {\n\t\t\tld r = (ri + le) / 2;\n\t\t\tif (can(i, r))ri = r;\n\t\t\telse le = r;\n\t\t}\n\t\trd[i] = ri;\n\t}\n\tfill(dp, dp + (1 << n), mod);\n\tdp[0] = 0;\n\trep(aa, m) {\n\t\trep(j, (1 << n)) {\n\t\t\tcop[j] = dp[j];\n\t\t}\n\t\trep(j, (1 << n)) {\n\t\t\tvector<int> v;\n\t\t\trep(i, n) {\n\t\t\t\tif (j&(1 << i))continue;\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t\tint len = v.size();\n\t\t\trep(i, (1 << len)) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(k, len) {\n\t\t\t\t\tif (i&(1 << k))s += (1 << v[k]);\n\t\t\t\t}\n\t\t\t\tcop[j + s] = min(cop[j + s], max(dp[j], rd[s]));\n\t\t\t}\n\t\t}\n\t\trep(j, (1 << n)) {\n\t\t\tdp[j] = cop[j];\n\t\t}\n\t}\n\tcout << fixed << setprecision(5);\n\tcout << dp[(1 << n) - 1] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double PI=acos(-1);\nconst double EPS=1e-4;\n\nint N,M;\ndouble x[22],y[22];\n\nbool check(double mid){\n\tvector<int> m_list;\n\t\n\tREP(i,N){\n\t\tm_list.PB(1<<i);\n\t}\n\t\n\tREP(i,N)REP(j,N){\n\t\tif(i==j)continue;\n\t\tdouble dx=x[i]-x[j],dy=y[i]-y[j];\n\t\tdouble d=sqrt(dx*dx+dy*dy);\n\t\tif(d>mid*2+EPS)continue;\n\t\tdouble r=sqrt(mid*mid-d*d/4);\n\t\tdouble vx=-dy/d*r;\n\t\tdouble vy=dx/d*r;\n\n\t\tdouble xx=(x[i]+x[j])/2+vx;\n\t\tdouble yy=(y[i]+y[j])/2+vy;\n\t\tint cnt=0;\n\t\tREP(k,N){\n\t\t\tif((x[k]-xx)*(x[k]-xx)+(y[k]-yy)*(y[k]-yy)<mid*mid+EPS)cnt |= (1<<k);\n\t\t}\n\t\tm_list.PB(cnt);\n\t}\n\n\t/*\n\tREP(i,m_list.size()){\n\t\tcout << (static_cast<bitset<(unsigned)(10)>>(m_list[i])) << endl;\n\t}\n*/\t\n\t\n\tvector<int> dp(1 << N,INF);\n\tdp[0] = 0;\n\tREP(i,dp.size()){\n\t\tREP(j,m_list.size()){\n\t\t\tdp[i | m_list[j]] = min(dp[i] + 1 , dp[i | m_list[j]]);\n\t\t}\n\t}\n\t\n\tif(dp[(1 << N )- 1] == INF){\n\t\tREP(i,dp.size()){\n\t\t\tcout << (static_cast<bitset<(unsigned)(10)>>(dp[i])) << ' ' << dp[i] << endl;\n\t\t}\n\t}\n\t\n\t//cout << dp[(1 << N)-1] << endl;\n\treturn (dp[(1 << N)-1] <= M);\n}\n\nint main()\n{\n\tcin >> N >> M;\n\tvector<pair<int,int>> v;\n\tREP(i,N){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tv.erase(unique(ALL(v)),v.end());\n\t\n\tREP(i,v.size()){\n\t\tx[i] = v[i].FI;\n\t\ty[i] = v[i].SE;\n\t}\n\t\n\tN = v.size();\n\t\n\tdouble top = 1000000;\n\tdouble under = 0;\n\t\t\n\tREP(i,100){\n\t\tdouble mid = (top + under) / 2;\n\t//\tcout << mid << endl;\n\t\tif(check(mid))top = mid;\n\t\telse under = mid;\n\t}\n\t\n\tcout << Decimal << top << endl;\t\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n \nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nusing C = pair<ld, P>;\n#define rad first\n#define pnt second\n \nC smallest_enclosing_disc(vector<P> ps){\n    auto c3 = [](const P &a, const P &b, const P &c){\n        ld A = norm(b - c);\n        ld B = norm(c - a);\n        ld C = norm(a - b);\n        ld S = abs(cross(b - a, c - a));\n        P p = (A*(B+C-A)*a + B*(C+A-B)*b + C*(A+B-C)*c) / (4*S*S);\n        ld r = abs(p - a);\n        return make_pair(r, p);\n    };\n \n    auto c2 = [](const P &a, const P &b){\n        P c = (a + b) / (ld)2;\n        ld r = abs(a - c);\n        return make_pair(r, c);\n    };\n \n    auto in_circle = [](const P &a, const C &c){\n        return norm(a - c.pnt) <= c.rad*c.rad + eps;\n    };\n \n    int n = ps.size();\n    if(n == 1) return make_pair(0, ps[0]);\n    random_shuffle(ps.begin(), ps.end());\n    C c = c2(ps[0], ps[1]);\n    for(int i = 2; i < n; ++i){\n        if(!in_circle(ps[i], c)){\n            c = c2(ps[0], ps[i]);\n            for(int j = 1; j < i; ++j){\n                if(!in_circle(ps[j], c)){\n                    c = c2(ps[j], ps[i]);\n                    for(int k = 0; k < j; ++k){\n                        if(!in_circle(ps[k], c)){\n                            c = c3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\ndouble circle_r[1 << 14];\ndouble dp[1 << 14][20];\n \nsigned main() {\n    int N, M; cin >> N >> M;\n    vector<P> ps;\n    for(int i=0; i<N; i++) {\n        double x, y; cin >> x >> y;\n        ps.push_back(P(x, y));\n    }\n\n    for(int bit=1; bit<(1<<N); bit++) {\n        vector<P> tmp;\n        for(int i=0; i<N; i++) {\n            if(bit >> i & 1) tmp.push_back(ps[i]);\n        }\n        circle_r[bit] = smallest_enclosing_disc(tmp).first;\n        // printf(\"circle_r[%lld] = %.12f\\n\", bit, circle_r[bit]);\n    }\n\n    for(int i=0; i<(1 << N); i++) {\n        fill(dp[i], dp[i] + 20, inf);\n    }\n    \n    double ans = inf;\n    dp[0][0] = 0;\n    for(int k=0; k<M; k++) {\n        for(int bit=0; bit<(1<<N); bit++) {\n            int rest = (bit ^ ((1 << N) - 1));\n            for(int nxt=rest; nxt>0; nxt=(nxt-1)&rest) {\n                int nbit = bit | nxt;\n                chmin(dp[nbit][k+1], max(dp[bit][k], circle_r[nxt]));\n                if(nbit == (1 << N) - 1) chmin(ans, dp[nbit][k+1]);\n            }\n        }\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nusing P = complex<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn(abs(a-b)); }\nD mabs(P p) { return abs(p.real()) + abs(p.imag()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.real()-l.real())) return l.real() < r.real();\n    if (sgn(r.imag()-l.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nD cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nD dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgn(cross(b, c) / mabs(b));\n    if (s) return s;\n    if (!sgn(mabs(c)) || !sgn(mabs(c-b))) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P x, y;\n    L() {}\n    L(P x, P y) :x(x), y(y) {}\n    P vec() const { return y-x; }\n};\nD abs(const L &l) { return abs(l.vec()); }\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.x)/abs(l.vec()));\n}\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec()*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\n\n\nusing Pol = V<P>;\nusing Tri = array<P, 3>;\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nC circumCircle(P a, P b, P c) {\n    b -= a; c -= a;\n    D s = 2*cross(b, c);\n    D x = norm(b-c), y = norm(c), z = norm(b);\n    D S = x+y+z;\n    P r = (y*(S-2*y)*b+z*(S-2*z)*c)/(s*s);\n    return C(r + a, abs(r));\n}\n\nC smallestEnclosingCircle(Pol &p, int ps = 0, Tri q = Tri(), int qs = 0) {\n    if (ps == p.size()) {\n        switch (qs) {\n            case 0:\n                return C(P(0, 0), -1);\n            case 1:\n                return C(q[0], 0);\n            case 2:\n                return C((q[0]+q[1])/D(2.0), abs(q[0]-q[1])/D(2.0));\n            case 3:\n                return circumCircle(q[0], q[1], q[2]);\n        }\n        assert(false);\n    }\n    C c = smallestEnclosingCircle(p, ps+1, q, qs);\n    if (sgn(abs(p[ps]-c.p) - c.r) == 1) {\n        q[qs] = p[ps];\n        return smallestEnclosingCircle(p, ps+1, q, qs+1);\n    }\n    return c;\n}\n\n\n\n\n\nconst int MN = 14;\nconst int MM = 14;\nint n, m;\nP p[MN];\nD pre[1<<MN];\nD dp[MM+1][1<<MN];\nbool vis[MM+1][1<<MN];\n\nD solve(int f, int m) {\n    if (f == 0) return 0;\n    if (m == 0) return 1e100;\n    if (vis[m][f]) return dp[m][f];\n    vis[m][f] = true;\n    D ans = 1e100;\n    int g = 0;\n    do {\n        ans = min(ans, max(pre[g], solve(f^g, m-1)));\n        g = ((g|~f)+1) & f;\n    } while (g);\n    return dp[m][f] = ans;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    auto mt = mt19937(random_device()());\n\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int f = 0; f < (1<<n); f++) {\n        V<P> v;\n        for (int i = 0; i < n; i++) {\n            if (!(f & (1<<i))) continue;\n            v.push_back(p[i]);\n        }\n        shuffle(begin(v), end(v), mt);\n        pre[f] = smallestEnclosingCircle(v).r;\n\n//        cout << f << \" \" << pre[f] << endl;\n    }\n\n    cout << solve((1<<n) - 1, m) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.l);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0l, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\nbool solve(vector<pair<ld, vector<int>>>bombs, int N, int M, ld len) {\n\t{\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (int i = 0; i < bombs.size(); ++i) {\n\t\t\tld r=bombs[i].first;\n\t\t\tif(r<len)n_bombs.emplace_back(bombs[i]);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tvector<vector<int>>memo(M+1,vector<int>(1<<N));\n\tmemo[0][0]=true;\n\tfor (int b_use = 0; b_use < M; ++b_use) {\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tif(!memo[b_use][i])continue;\n\n\t\t\tfor (auto&& now_b : bombs) {\n\n\t\t\t\tbitset<14>bs(i);\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif(now_b.second[j])bs[j]=true;\n\t\t\t\t}\n\t\t\t\tmemo[b_use+1][bs.to_ulong()]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[M][(1<<N)-1];\n}\n\n\n\nint main() {\n\tint N,M;cin>>N>>M;\n\tvector<Point>pos;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x,y;cin>>x>>y;\n\t\tpos.push_back(Point(x,y));\n\t}\n\n\tvector<pair<ld,vector<int>>>bombs;\n\t{\n\t\tvector<int>v(3);\n\t\tfor (v[0] = 0; v[0] < N; ++v[0]) {\n\t\t\t{\n\t\t\t\tld r=1e-8;\n\t\t\t\tCircle c(pos[v[0]], r);\n\n\t\t\t\tvector<int>oks(N);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t}\n\t\t\tfor ( v[1] = v[0] + 1; v[1] < N; ++v[1]) {\n\t\t\t\t{\n\t\t\t\t\tPoint p((pos[v[0]]+pos[v[1]])/2.0l);\n\t\t\t\t\tconst ld r = abs(p - pos[v[0]]);\n\t\t\t\t\tCircle c(p, r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (v[2] = v[1] + 1; v[2] < N; ++v[2]) {\n\t\t\t\t\tvector<Point>ci_pos(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tci_pos[i]=pos[v[i]];\n\t\t\t\t\t}\n\t\t\t\t\tLine l1 = point_bisection(ci_pos[0], ci_pos[1]);\n\t\t\t\t\tLine l2 = point_bisection(ci_pos[1], ci_pos[2]);\n\t\t\t\t\tPoint sv = l1.b - l1.a, tv = l2.b - l2.a;\n\t\t\t\t\tif (abs(cross(sv, tv)) < eps) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tPoint p(outer_center(ci_pos));\n\t\t\t\t\tconst ld r=abs(p-ci_pos[0]);\n\t\t\t\t\tCircle c(p,r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r,oks));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tmap<int, ld>mp;\n\t\tfor (auto&& bomb : bombs) {\n\t\t\tbitset<14>bs;\n\t\t\tfor (int i = 0; i < bomb.second.size(); ++i) {\n\t\t\t\tif(bomb.second[i])bs[i]=true;\n\t\t\t}\n\t\t\tif (mp.find(bs.to_ulong()) == mp.end()) {\n\t\t\t\tmp[bs.to_ulong()]=bomb.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[bs.to_ulong()]=min(bomb.first,mp[bs.to_ulong()]);\n\t\t\t}\n\t\t}\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (auto m : mp) {\n\t\t\tbitset<14>bs(m.first);\n\t\t\tvector<int>v(N);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif(bs[i])v[i]=true;\n\t\t\t}\n\t\t\tn_bombs.emplace_back(m.second,v);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tld l=0,r=1e5;\n\tint time=30;\n\twhile (time--) {\n\t\tld m=(l+r)/2;\n\t\tif (solve(bombs, N, M, m)) {\n\t\t\tr=m;\n\t\t}\n\t\telse {\n\t\t\tl=m;\n\t\t}\n\t}\n\tcout<<setprecision(10)<<fixed;\n\tcout<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return mysqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\nprivate:\n\tstatic const double mysqrt(const double &x) {\n\t\tdouble h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tdouble r = *(double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\n\nint main(void) {\n\tuint32 n, m;\n\tscan(n, m);\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x.x, x.y);\n\tstd::vector<double> t((uint32)1 << n, -0.00001);\n\tfor (uint32 i = 0;i < (uint32)1 << n;++i) {\n\t\tfor (uint32 j = 0;j < n;++j) {\n\t\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif ((i >> j & 1) && (i >> k & 1)) {\n\t\t\t\t\tbmaxi(t[i], (d[j] - d[k]).abs2());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble low = 0, high = 30000000000;\n\tfor (uint32 bs = 0;bs < 50;++bs) {\n\t\tdouble mid = (low + high) / 2;\n\t\tstd::vector<uint32> dp((uint32)1 << n, 1000);\n\t\tfor (uint32 i = 1;i < (uint32)1 << n;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\thigh /= 4.0;\n\tprintln(std::sqrt(high));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG g(n);\n\trep(i,n)g[i]=pin();\n\t\n\tdouble l=0,r=100000;\n\tint co=100;\n\twhile(co--){\n\t\tdouble h=(l+r)/2;\n\t\tvd dp(1<<n,inf);\n\t\tdp[0]=0;\n\t\trep(i,1<<n)rep(j,n)if((i&1<<j)==0){\n\t\t\trep(k,n)if((i&1<<k)==0&&abs(g[j]-g[k])<EPS+2*h){\n\t\t\t\tint t=i;\n\t\t\t\tt|=1<<j;\n\t\t\t\tt|=1<<k;\n\t\t\t\trep(l,n){\n\t\t\t\t\tif(abs(g[l]-g[k])<EPS+h&&abs(g[l]-g[j])<EPS+h){\n//\t\t\t\t\t\tif(i==7&&j==3)cout<<k<<\" \"<<l<<endl;\n\t\t\t\t\t\tt|=1<<l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[t]=min(dp[t],dp[i]+1);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"! \"<<dp[\n\t\tint c=dp[(1<<n)-1];\n//\t\tcout<<c<<\" \"<<shosu(6)<<h<<endl;\n\t\tif(c<=m)r=h;\n\t\telse l=h;\n\t}\n\tcout<<shosu(7)<<r<<endl;\n}\n/*\n5 2\n0 0 5 5 10 10 100 100 200 200\n5 2\n0 0 5 5 10 10 100 100 200 200\n*/\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG g(n);\n\trep(i,n)g[i]=pin();\n\t\n\tdouble l=0,r=100000;\n\twhile(r-l>1e-5){\n\t\tdouble h=(l+r)/2;\n\t\tvd dp(1<<n,inf);\n\t\tdp[0]=0;\n\t\trep(i,1<<n)rep(j,n)if((i&1<<j)==0){\n\t\t\trep(k,n)if((i&1<<k)==0&&abs(g[j]-g[k])<EPS+2*h)rep(q,2){\n\t\t\t\tint t=i;\n\t\t\t\tt|=1<<j;\n\t\t\t\tt|=1<<k;\n\t\t\t\tP tmp=g[k]-g[j];\n\t\t\t\tP p;\n\t\t\t\tif(abs(tmp)<EPS)p=g[k];\n\t\t\t\telse p=g[j]+tmp/2.+tmp*P(0,q?1:-1)/abs(tmp)*sqrt(h*h-abs(tmp)*abs(tmp)/4);\n\t\t\t\trep(l,n){\n\t\t\t\t\tif(abs(g[l]-p)<EPS+h){\n\t\t\t\t\t\tt|=1<<l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[t]=min(dp[t],dp[i]+1);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"! \"<<dp[\n\t\tint c=dp[(1<<n)-1];\n//\t\tcout<<c<<\" \"<<shosu(6)<<h<<endl;\n\t\tif(c<=m)r=h;\n\t\telse l=h;\n\t}\n\tcout<<shosu(7)<<r<<endl;\n}\n/*\n5 2\n0 0 5 5 10 10 100 100 200 200\n5 2\n0 0 5 5 10 10 100 100 200 200\n*/\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\ntypedef complex<double> P;\n\nint n,m;\nP pos[25];\n\ndouble R[1<<14];\n\ndouble f(int msk, double x, double y){\n  P p(x,y);\n  double ret = 1e-14;\n  REP(i,n)if((msk>>i)&1)CHMAX(ret, abs(pos[i]-p));\n  return ret;\n}\n\nconst double ppp = 100.0;\nconst double qqq = 101.0;\n\ndouble calc(int msk, double x){\n  double ylow = -1, yhigh = 1e5+1;\n  REP(_,40){\n    double ylolo = (qqq*ylow + ppp*yhigh) / (ppp+qqq);\n    double yhihi = (ppp*ylow + qqq*yhigh) / (ppp+qqq);\n    if(f(msk, x, ylolo) < f(msk, x, yhihi)){\n      yhigh = yhihi;\n    }else{\n      ylow = ylolo;\n    }\n  }\n  return (yhigh + ylow) / 2.0;\n}\n\ndouble dp[25][1<<14];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,n){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    pos[i] = P(x,y);\n  }\n  R[0] = 0;\n  FOR(i,1,1<<n){\n    double xlow = -1, xhigh = 1e5+1;\n    REP(_,40){\n      double xlolo = (qqq*xlow + ppp*xhigh) / (ppp+qqq);\n      double xhihi = (ppp*xlow + qqq*xhigh) / (ppp+qqq);\n      double ylolo = calc(i, xlolo);\n      double yhihi = calc(i, xhihi);\n      if(f(i, xlolo, ylolo) < f(i, xhihi, yhihi)){\n        xhigh = xhihi;\n      }else{\n        xlow = xlolo;\n      }\n    }\n    double x = (xlow + xhigh) / 2.0;\n    double y = calc(i, x);\n    R[i] = f(i, x, y);\n  }\n\n  REP(i,m+1)REP(msk,1<<n)dp[i][msk] = 1e18;\n  dp[0][0] = 1e-14;\n  REP(i,m)REP(msk,1<<n){\n    int submsk = ((1<<n)-1) - msk;\n    for(int T=submsk; ; T=(T-1)&submsk){\n      CHMIN(dp[i+1][msk|T], max(dp[i][msk], R[T]));\n      if(T==0)break;\n    }\n  }\n  printf(\"%.9f\\n\",dp[m][(1<<n)-1]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist(double px, double py, double qx, double qy) {\n  return sqrt((px - qx) * (px - qx) + (py - qy) * (py - qy));\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] / 100000000;\n    Y[i] = P[i] % 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n    ll cnt = 0;\n    REP(i, 0, N) if(s & (1LL << i)) cnt++;\n    if(cnt < 2) {\n      radius[s] = 0.0;\n      continue;\n    }\n\n    double minr = 1e10;\n    REP(i, 0, N) REP(j, i + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)))) continue;\n\n      double d = dist(X[i], Y[i], X[j], Y[j]) / 2.0;\n      double dx = +(Y[i] - Y[j]) / (d * 2.0);\n      double dy = -(X[i] - X[j]) / (d * 2.0);\n      double mx = (X[i] + X[j]) / 2.0;\n      double my = (Y[i] + Y[j]) / 2.0;\n\n      bool ok = true;\n      REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], mx, my) > d + EPS) ok = false;\n      if(ok) {\n        minr = min(minr, d);\n        continue;\n      }\n\n      double l1 = d, h1 = 1e10;\n      REP(_, 0, 50) {\n        double m = (l1 + h1) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c1x = mx + dx * t;\n        double c1y = my + dy * t;\n        bool ok1 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c1x, c1y) > m + EPS) ok1 = false;\n\n        (ok1 ? h1 : l1) = m;\n      }\n\n      double l2 = d, h2 = 1e10;\n      REP(_, 0, 50) {\n        double m = (l2 + h2) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c2x = mx - dx * t;\n        double c2y = my - dy * t;\n        bool ok2 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c2x, c2y) > m + EPS) ok2 = false;\n\n        (ok2 ? h2 : l2) = m;\n      }\n\n      minr = min(minr, min(h1, h2));\n    }\n    radius[s] = minr;\n  }\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e10));\n  dp[0][0] = 0.0;\n  REP(s, 0, 1LL << N) REP(i, 0, M) {\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e10;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-13;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        if (d < 0) ok = false;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\n// https://drken1215.hatenablog.com/entry/2020/01/13/230900\n\n/* 幾何ライブラリ */\nusing DD = double;\nconst DD EPS = 1e-10;        // to be set appropriately\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)、0：一直線上\nint simple_ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    return 0;\n}\n\n// 円や直線の交点\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\n\n// 外心\nPoint gaisin(Point a, Point b, Point c) {\n    Line ab((a+b)/2, (a+b)/2 + rot90(a-b));\n    Line bc((b+c)/2, (b+c)/2 + rot90(b-c));\n    return crosspoint(ab, bc)[0];\n}\n\n// 最小包含円\ndouble minimum_bounding_circle(vector<Point>& v){\n  ll n=v.size();\n  if(n<=1) return 0;\n  \n  vector<Point> cond; // 候補\n  rep(i,n) irep(j,i+1,n){\n    cond.push_back((v[i]+v[j])/2);\n    irep(k,j+1,n){\n      if(simple_ccw(v[i],v[j],v[k])==0) continue;\n      auto p=gaisin(v[i],v[j],v[k]);\n      cond.push_back(p);\n    }\n  }\n  \n  double res=INF;\n  for(auto e: cond){\n    double tmp=0;\n    rep(i,n) chmax(tmp,abs(e-v[i]));\n    chmin(res,tmp);\n  }\n  \n  return res;\n}\n\nconst ll maxn=1<<14;\ndouble dp1[maxn];     // 最小包含円の半径\ndouble dp2[15][maxn]; // i個の円で集合sを包含するときの最大の円の半径の最小値\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  \n  ll n,m; cin>>n>>m;\n  vector<Point> v;\n  set<Point> exist;\n  rep(i,n){\n    ll x,y; cin>>x>>y;\n    Point p=Point(x,y);\n    if(exist.count(p)) continue;\n    v.push_back(p);\n    exist.insert(p);\n  }\n  n=v.size();\n  \n  if(n<=m){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  rep(s,1<<n){\n    vector<Point> points;\n    rep(i,n) if(s>>i&1) points.push_back(v[i]);\n    double r=minimum_bounding_circle(points);\n    dp1[s]=r;\n  }\n  \n  // NOTE: ここでINF初期化する理由\n  // 以下のループの中で、以下の様にdp2の遷移を行っている\n  // dp[i][_]が求まっているとして、i+1個の円で集合sを包含するときの円の最小値は、\n  // sをbitとbit2の2つの集合に分けて、bitはi個の円、bit2は1個の円で包含することを考える\n  // すると遷移は、chmin(dp2[i+1][s],max(dp2[i][bit],dp1[bit2])) と表される\n  // このとき、i=0の場合において遷移の過程でdp2[i][bit]が未定義の場合が有り得る\n  // dp2[0][1]は0個の円で1個の点を包含する訳だが不可能である(そもそもdp2[0][_]には遷移元が存在しない)\n  // この場合dpテーブルを更新しないためにINF初期化する必要がある\n  // memo: 一方、dp2[2][1]など、点より多い円で包含する場合は遷移の過程でテーブルが埋められるので問題ない\n  // 例えば、dp2[2][1]はmax(dp2[1][0],dp1[1])から更新されるが、dp2[1][0]はmax(dp2[0][0],dp1[0])から0と初期化されるはずである\n  rep(i,m+1) rep(s,1<<n) dp2[i][s]=INF;\n  dp2[0][0]=0;\n  rep(i,m){\n    rep(bit,1<<n){\n      ll rem=((1<<n)-1)-bit; // 2^n における、集合bitの補集合\n      \n      // bitの補集合remの、部分集合全てについてのループ\n      for(ll bit2=rem; bit2>=0 ;bit2--){\n        bit2&=rem;\n        \n        // NOTE: ここでやっていること\n        // まず、max(dp2[i][bit],dp1[bit2])について\n        // dp2[i][bit]はi個の円で集合bitを覆うとき、その円の中でも最大のものが最小となるときの半径が格納されている\n        // dp1[bit2]は集合bit2の最小包含円の半径である\n        // よってmax()は、i+1個の円でbit, bit2を覆うときの最大の円の半径を取ってきている\n        // 上記で求めた最大の半径をmax_valueとして、素直にdp2の遷移を実装した結果が以下となる\n        // chmin(dp2[i+1][bit|bit2],max_value)\n        chmin(dp2[i+1][bit|bit2], max(dp2[i][bit],dp1[bit2]));\n      }\n    }\n  }\n  \n  // rep(s,1<<n) cout<<std::setprecision(10)<<dp1[s]<<endl;\n  // rep(s,1<<n) cout<<std::setprecision(10)<<dp2[m][s]<<endl;\n  \n  cout<<std::setprecision(10)<<dp2[m][(1<<n)-1]<<endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n \nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nusing C = pair<ld, P>;\n#define rad first\n#define pnt second\n \nC smallest_enclosing_disc(vector<P> ps){\n    auto c3 = [](const P &a, const P &b, const P &c){\n        ld A = norm(b - c);\n        ld B = norm(c - a);\n        ld C = norm(a - b);\n        ld S = abs(cross(b - a, c - a));\n        P p = (A*(B+C-A)*a + B*(C+A-B)*b + C*(A+B-C)*c) / (4*S*S);\n        ld r = abs(p - a);\n        return make_pair(r, p);\n    };\n \n    auto c2 = [](const P &a, const P &b){\n        P c = (a + b) / (ld)2;\n        ld r = abs(a - c);\n        return make_pair(r, c);\n    };\n \n    auto in_circle = [](const P &a, const C &c){\n        return norm(a - c.pnt) <= c.rad*c.rad + eps;\n    };\n \n    int n = ps.size();\n    if(n == 1) return make_pair(0, ps[0]);\n    random_shuffle(ps.begin(), ps.end());\n    C c = c2(ps[0], ps[1]);\n    for(int i = 2; i < n; ++i){\n        if(!in_circle(ps[i], c)){\n            c = c2(ps[0], ps[i]);\n            for(int j = 1; j < i; ++j){\n                if(!in_circle(ps[j], c)){\n                    c = c2(ps[j], ps[i]);\n                    for(int k = 0; k < j; ++k){\n                        if(!in_circle(ps[k], c)){\n                            c = c3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\ndouble circle_r[1 << 14];\ndouble dp[1 << 14][20];\ndouble solve(int bit, int k) {\n    if(dp[bit][k] >= 0) return dp[bit][k];\n    if(k == 1) return dp[bit][k] = circle_r[bit];\n    \n    dp[bit][k] = inf;\n    for(int part=bit; part>0; part=(part-1)&bit) {\n        int nbit = bit ^ part;\n        chmin(dp[bit][k], max(solve(nbit, k-1), circle_r[part]));\n        // printf(\"lhs(%lld, %lld) = %.12f, rhs(%lld) = %.12f\\n\", nbit, k-1, dp[nbit][k-1], part, circle_r[part]);\n    }\n    // printf(\"dp[%lld][%lld] = %.12f\\n\", bit, k, dp[bit][k]);\n    return dp[bit][k];\n}\n \nsigned main() {\n    int N, M; cin >> N >> M;\n    vector<P> ps;\n    for(int i=0; i<N; i++) {\n        double x, y; cin >> x >> y;\n        ps.push_back(P(x, y));\n    }\n\n    for(int bit=1; bit<(1<<N); bit++) {\n        vector<P> tmp;\n        for(int i=0; i<N; i++) {\n            if(bit >> i & 1) tmp.push_back(ps[i]);\n        }\n        circle_r[bit] = smallest_enclosing_disc(tmp).first;\n        // printf(\"circle_r[%lld] = %.12f\\n\", bit, circle_r[bit]);\n    }\n\n    for(int i=0; i<(1 << N); i++) {\n        fill(dp[i], dp[i] + 20, -1);\n    }\n    printf(\"%.12f\\n\", solve((1 << N) - 1, M));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n \nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nusing C = pair<ld, P>;\n#define rad first\n#define pnt second\n \nC smallest_enclosing_disc(vector<P> ps){\n    auto c3 = [](const P &a, const P &b, const P &c){\n        ld A = norm(b - c);\n        ld B = norm(c - a);\n        ld C = norm(a - b);\n        ld S = abs(cross(b - a, c - a));\n        P p = (A*(B+C-A)*a + B*(C+A-B)*b + C*(A+B-C)*c) / (4*S*S);\n        ld r = abs(p - a);\n        return make_pair(r, p);\n    };\n \n    auto c2 = [](const P &a, const P &b){\n        P c = (a + b) / (ld)2;\n        ld r = abs(a - c);\n        return make_pair(r, c);\n    };\n \n    auto in_circle = [](const P &a, const C &c){\n        return norm(a - c.pnt) <= c.rad*c.rad + eps;\n    };\n \n    int n = ps.size();\n    if(n == 1) return make_pair(0, ps[0]);\n    random_shuffle(ps.begin(), ps.end());\n    C c = c2(ps[0], ps[1]);\n    for(int i = 2; i < n; ++i){\n        if(!in_circle(ps[i], c)){\n            c = c2(ps[0], ps[i]);\n            for(int j = 1; j < i; ++j){\n                if(!in_circle(ps[j], c)){\n                    c = c2(ps[j], ps[i]);\n                    for(int k = 0; k < j; ++k){\n                        if(!in_circle(ps[k], c)){\n                            c = c3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\ndouble circle_r[1 << 14];\ndouble dp[1 << 14][20];\ndouble solve(int bit, int k) {\n    if(dp[bit][k] >= 0) return dp[bit][k];\n    if(k == 1) return dp[bit][k] = circle_r[bit];\n    \n    dp[bit][k] = inf;\n    for(int part=bit; part>0; part=(part-1)&bit) {\n        int nbit = bit ^ part;\n        chmin(dp[bit][k], max(solve(nbit, k-1), circle_r[part]));\n        // printf(\"lhs(%lld, %lld) = %.12f, rhs(%lld) = %.12f\\n\", nbit, k-1, dp[nbit][k-1], part, circle_r[part]);\n    }\n    // printf(\"dp[%lld][%lld] = %.12f\\n\", bit, k, dp[bit][k]);\n    return dp[bit][k];\n}\n \nsigned main() {\n    int N, M; cin >> N >> M;\n    vector<P> ps;\n    for(int i=0; i<N; i++) {\n        double x, y; cin >> x >> y;\n        ps.push_back(P(x, y));\n    }\n\n    for(int bit=1; bit<(1<<N); bit++) {\n        vector<P> tmp;\n        for(int i=0; i<N; i++) {\n            if(bit >> i & 1) tmp.push_back(ps[i]);\n        }\n        circle_r[bit] = smallest_enclosing_disc(tmp).first;\n        // printf(\"circle_r[%lld] = %.12f\\n\", bit, circle_r[bit]);\n    }\n\n    for(int i=0; i<(1 << N); i++) {\n        fill(dp[i], dp[i] + 20, -1);\n    }\n    printf(\"%.12f\\n\", solve((1 << N) - 1, M));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-10;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist2(double px, double py, double qx, double qy) {\n  return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] % 100000000;\n    Y[i] = P[i] / 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n\n    // cerr << \"s: \" << s << endl;\n\n    double minr2 = 1e20;\n    REP(i, 0, N) REP(j, i + 1, N) REP(k, j + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)) && (s & (1LL << k)))) continue;\n\n      // cerr << \"  i, j, k: \" << i << \" \" << j << \" \" << k << endl;\n\n      double d1x = +(Y[i] - Y[j]);\n      double d1y = -(X[i] - X[j]);\n      double m1x = (X[i] + X[j]) / 2.0;\n      double m1y = (Y[i] + Y[j]) / 2.0;\n      double d2x = +(Y[j] - Y[k]);\n      double d2y = -(X[j] - X[k]);\n      double m2x = (X[j] + X[k]) / 2.0;\n      double m2y = (Y[j] + Y[k]) / 2.0;\n\n      double x, y, r2;\n      if((d1y * d2x) - (d1x * d2y) < EPS) {\n        double di = dist2(X[j], Y[j], X[k], Y[k]);\n        double dj = dist2(X[k], Y[k], X[i], Y[i]);\n        double dk = dist2(X[i], Y[i], X[j], Y[j]);\n\n        // cerr << \"    di: \" << di << \", dj: \" << dj << \", dk: \" << dk << endl;\n\n        if(di > dj && di > dk) { x = (X[j] + X[k]) / 2.0; y = (Y[j] + Y[k]) / 2.0; r2 = pow(sqrt(di) / 2.0, 2); };\n        if(dj > dk && dj > di) { x = (X[k] + X[i]) / 2.0; y = (Y[k] + Y[i]) / 2.0; r2 = pow(sqrt(dj) / 2.0, 2); };\n        if(dk > di && dk > dj) { x = (X[i] + X[j]) / 2.0; y = (Y[i] + Y[j]) / 2.0; r2 = pow(sqrt(dk) / 2.0, 2); };\n      } else {\n\n        // cerr << \"    d1: (\" << d1x << \", \" << d1y << \"), m1: :(\" << m1x << \", \" << m1y << \")\" << endl;\n        // cerr << \"    d2: (\" << d2x << \", \" << d2y << \"), m2: :(\" << m2x << \", \" << m2y << \")\" << endl;\n\n        double a = d1x, b = -d2x, c = m2x - m1x;\n        double d = d1y, e = -d2y, f = m2y - m1y;\n\n        // cerr << \"    a: \" << a << \", b: \" << b << \", c: \" << c << endl;\n        // cerr << \"    d: \" << d << \", e: \" << e << \", f: \" << f << endl;\n\n        double t1 = (c * e - b * f) / (a * e - b * d);\n        double t2 = (c * d - a * f) / (b * d - a * e);\n        if(-EPS < t1 && t1 < EPS) t1 = 0;\n        if(-EPS < t2 && t2 < EPS) t2 = 0;\n\n        // cerr << \"    t1: \" << t1 << \", t2: \" << t2 << endl;\n\n        x = d1x * t1 + m1x;\n        y = d1y * t1 + m1y;\n        r2 = (X[i] - x) * (X[i] - x) + (Y[i] - y) * (Y[i] - y);\n      }\n\n      // cerr << \"    (x, y): (\" << x << \", \" << y << \"), r: \" << sqrt(r2) << endl;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r2 + EPS) ok = false;\n      if(ok) minr2 = min(minr2, r2);\n\n      // cerr << \"    ok: \" << ok << endl;\n    }\n    radius[s] = sqrt(minr2);\n\n    // cerr << s << \": \" << radius[s] << endl;\n  }\n\n  REP(i, 0, N) radius[1LL << i] = 0.0;\n  REP(i, 0, N) REP(j, 0, N) radius[(1LL << i) | (1LL << j)] = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e20));\n  dp[0][0] = 0.0;\n  REP(i, 0, M) REP(s, 0, 1LL << N) {\n    // cerr << s << \", \" << i << \": \" << dp[s][i] << endl;\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e20;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint n, m;\nld x[14], y[14];\nld d[14][14];\nld rd[1 << 14];\nbool can(int s,ld r) {\n\tvector<int> v;\n\trep(i, n) {\n\t\tif (s&(1 << i))v.push_back(i);\n\t}\n\tif (v.size() <= 1)return true;\n\tint len = v.size();\n\trep(i, len) {\n\t\tRep(j, i + 1, len) {\n\t\t\tint id = v[i], jd = v[j];\n\t\t\tif (2*r < d[id][jd])return false;\n\t\t\tld X = (x[jd] - x[id]) / 2.0;\n\t\t\tld Y = (y[jd] - y[id]) / 2.0;\n\t\t\tld dist = sqrt(pow(r, 2) - pow(d[id][jd] / 2.0, 2));\n\t\t\tld sr = d[id][jd] / 2.0;\n\t\t\tld x3 = Y * dist / sr; ld y3 = -X * dist / sr;\n\t\t\tld midx = (x[id] + x[jd]) / 2.0, midy = (y[id] + y[jd]) / 2.0;\n\t\t\tld cx = x3 + midx, cy = y3 + midy;\n\t\t\tbool valid = true;\n\t\t\trep(k, len) {\n\t\t\t\tint kd = v[k];\n\t\t\t\tld dis = sqrt(pow(cx - x[kd], 2) + pow(cy - y[kd], 2));\n\t\t\t\tif (dis > r+eps) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid)return true;\n\t\t\tvalid = true;\n\t\t\tcx = -x3 + midx, cy = -y3 + midy;\n\t\t\trep(k, len) {\n\t\t\t\tint kd = v[k];\n\t\t\t\tld dis = sqrt(pow(cx - x[kd], 2) + pow(cy - y[kd], 2));\n\t\t\t\tif (dis > r+eps) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid)return true;\n\t\t}\n\t}\n\treturn false;\n}\nld dp[1 << 14], cop[1 << 14];\nint main() {\n\tcin >> n >> m;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\td[i][j] = sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2));\n\t\t}\n\t}\n\trep(i, (1 << n)) {\n\t\tld le = 0, ri = 200000;\n\t\twhile (ri - le > eps) {\n\t\t\tld r = (ri + le) / 2;\n\t\t\tif (can(i, r))ri = r;\n\t\t\telse le = r;\n\t\t}\n\t\trd[i] = ri;\n\t}\n\tfill(dp, dp + (1 << n), mod);\n\tdp[0] = 0;\n\trep(aa, m) {\n\t\trep(j, (1 << n)) {\n\t\t\tcop[j] = dp[j];\n\t\t}\n\t\trep(j, (1 << n)) {\n\t\t\tvector<int> v;\n\t\t\trep(i, n) {\n\t\t\t\tif (j&(1 << i))continue;\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t\tint len = v.size();\n\t\t\trep(i, (1 << len)) {\n\t\t\t\tint s = 0;\n\t\t\t\trep(k, len) {\n\t\t\t\t\tif (i&(1 << k))s += (1 << v[k]);\n\t\t\t\t}\n\t\t\t\tcop[j + s] = min(cop[j + s], max(dp[j], rd[s]));\n\t\t\t}\n\t\t}\n\t\trep(j, (1 << n)) {\n\t\t\tdp[j] = cop[j];\n\t\t}\n\t}\n\tcout << fixed << setprecision(5);\n\tcout << dp[(1 << n) - 1] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG g(n);\n\trep(i,n)g[i]=pin();\n\t\n\tdouble l=0,r=100000;\n\twhile(r-l>1e-5){\n\t\tdouble h=(l+r)/2;\n\t\tvd dp(1<<n,inf);\n\t\tdp[0]=0;\n\t\trep(i,1<<n)rep(j,n)if((i&1<<j)==0){\n\t\t\trep(k,n)if((i&1<<k)==0&&abs(g[j]-g[k])<EPS+2*h){\n\t\t\t\tint t=i;\n\t\t\t\tt|=1<<j;\n\t\t\t\tt|=1<<k;\n\t\t\t\trep(l,n){\n\t\t\t\t\tif(abs(g[l]-g[k])<EPS+h&&abs(g[l]-g[j])<EPS+h){\n//\t\t\t\t\t\tif(i==7&&j==3)cout<<k<<\" \"<<l<<endl;\n\t\t\t\t\t\tt|=1<<l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[t]=min(dp[t],dp[i]+1);\n\t\t\t}\n\t\t}\n//\t\tcout<<\"! \"<<dp[\n\t\tint c=dp[(1<<n)-1];\n//\t\tcout<<c<<\" \"<<shosu(6)<<h<<endl;\n\t\tif(c<=m)r=h;\n\t\telse l=h;\n\t}\n\tcout<<shosu(7)<<r<<endl;\n}\n/*\n5 2\n0 0 5 5 10 10 100 100 200 200\n5 2\n0 0 5 5 10 10 100 100 200 200\n*/\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n#define EPS 1e-4\n\nint n,m;\ndouble x[15],y[15];\nint dp[1<<14];\n\nbool ok(double r){\n  rep(i,1<<n)dp[i]=INF;\n  dp[(1<<n)-1]=0;\n  for(int S=(1<<n)-1;S>0;S--){\n    rep(i,n){\n      if(((S>>i)&1)==0)continue;\n      rep(j,n){\n        if(i==j)continue;\n        if(((S>>j)&1)==0)continue;\n        minch(dp[S^(1<<i)],dp[S]+1);\n      }\n      rep(j,i){\n        if(((S>>j)&1)==0)continue;\n        double dx=x[i]-x[j],dy=y[i]-y[j];\n        double d=sqrt(dx*dx+dy*dy)/2.0;\n        if(d>r+EPS)continue;\n        double mx=(x[i]+x[j])/2.0;\n        double my=(y[i]+y[j])/2.0;\n        double h=sqrt(r*r-d*d);\n        double ex=-dy,ey=dx;\n        double l=sqrt(ex*ex+ey*ey);\n\n        if(l>0){\n          ex/=l; ey/=l;\n        }\n\n        {\n          double cx=mx+ex*h,cy=my+ey*h;\n          int T=S^(1<<i)^(1<<j);\n          rep(k,n){\n            if(k==i||k==j)continue;\n            if(((S>>k)&1)==0)continue;\n            double ddx=x[k]-cx;\n            double ddy=y[k]-cy;\n            if(ddx*ddx+ddy*ddy<r*r+EPS){\n              T^=(1<<k);\n            }\n          }\n          minch(dp[T],dp[S]+1);\n        }\n        {\n          double cx=mx-ex*h,cy=my-ey*h;\n          int T=S^(1<<i)^(1<<j);\n          rep(k,n){\n            if(k==i||k==j)continue;\n            if(((S>>k)&1)==0)continue;\n            double ddx=x[k]-cx;\n            double ddy=y[k]-cy;\n            if(ddx*ddx+ddy*ddy<r*r+EPS){\n              T^=(1<<k);\n            }\n          }\n          minch(dp[T],dp[S]+1);\n        }\n      }\n    }\n  }\n  return dp[0]<=m;\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)cin>>x[i]>>y[i];\n  double lb=1e-6,ub=1e7;\n  rep(hoge,40){\n    double mid=(ub+lb)/2.0;\n    if(ok(mid))ub=mid;\n    else lb=mid;\n  }\n  printf(\"%.10f\\n\", (lb+ub)/2.0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-8)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tpa2 operator * (int a) {return pa2(x*a,y*a);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n             /*               \n            int pr[1000010];\n            int inv[1000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<=ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n           \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n            */ \n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n/*\nstruct Segmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=1;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first<vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse if(vec[2*i].first>vec[2*i+1].first)vec[i]=vec[2*i+1];\n\t\t\t\telse vec[i]=mp(vec[2*i].first,vec[2*i].second+vec[2*i+1].second);\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x ���ڂ� w���Z\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x���ڂ�w�ɕύX\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmin(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp((1ll<<31)-1,-1);\n\t\t}\n\t\t\n\t\tpa v1=segmin(a,b,k*2,l,(l+r)/2),v2=segmin(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first<v2.first)return v1;\n\t\telse if(v1.first>v2.first) return v2;\n\t\telse return mp(v1.first,v1.second+v2.second);\n\t}\n\t\n};\n\n\n\nstruct Segmax{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=1;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first>vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse if(vec[2*i].first<vec[2*i+1].first)vec[i]=vec[2*i+1];\n\t\t\t\telse vec[i]=mp(vec[2*i].first,vec[2*i].second+vec[2*i+1].second);\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x ���ڂ� w���Z\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x���ڂ�w�ɕύX\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmax(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp(-(1ll<<31),-1);\n\t\t}\n\t\t\n\t\tpa v1=segmax(a,b,k*2,l,(l+r)/2),v2=segmax(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first>v2.first)return v1;\n\t\telse if(v1.first<v2.first) return v2;\n\t\telse return mp(v1.first,v1.second+v2.second);\n\t}\n\t\n};\n*/\nset<pa> se;\nPoint p[30];\ndouble dp[1<<14][15];\nbool sumi[1<<14]={0};\ndouble rd[1<<14];\nint n;\n\nbool icc(int i,int j,int k){\n\treturn abs(cross(p[i]-p[j],p[i]-p[k]))<EPS; \n}\n\nPoint kai(Point v){\n\treturn (Point){-v.y,v.x};\n}\n\ndouble solve(int r){\n\t\n\tif(sumi[r] )return rd[r];\n\tint d= __builtin_popcount(r);\n\tif(d==1) {\n\t\tsumi[r]=1;\n\t\trd[r]=0;\n\t\treturn 0;\n\t}\n\t\tvector<int> ve;\n\tif(d==2){\n\t\n\t\tfor(int i=0;i<n;i++)if(r&(1<<i)) ve.pb(i);\n\t\trd[r]=(p[ve[0]]-p[ve[1]]).absv()/2.0;\n\t\tsumi[r]=1;\n\t\treturn rd[r];\n\t}\n\t\n\tfor(int i=0;i<n;i++)if(r&(1<<i)) ve.pb(i);\n\tdouble ans=1000000000;\n\tfor(int i=0;i<d;i++)for(int j=i+1;j<d;j++){\n\t\tPoint c=(p[ve[i]]+p[ve[j]])/2.0;\n\t\tdouble rr=(c-p[ve[i]]).absv();\n\t\t\n\t\tfor(int k=0;k<d;k++)if((p[ve[k]]-c).absv()>rr+EPS) goto lll;\n\t\t\n\t\t//if(r==7) cout<<\"d\"<<endl;\n\t\tans=min(ans,rr);\n\t\t\n\t\tlll:;\n\t}\n\t\n\tfor(int i=0;i<d;i++)for(int j=i+1;j<d;j++)for(int k=j+1;k<d;k++){\n\t\tif(icc(ve[i],ve[j],ve[k])) continue;\n\t\t\n\t\tPoint x1,x2,v1,v2;\n\t\tx1=(p[ve[i]]+p[ve[j]])/2.0;\n\t\tx2=(p[ve[i]]+p[ve[k]])/2.0;\n\t\tv1=kai(p[ve[i]]-p[ve[j]]);\n\t\tv2=kai(p[ve[i]]-p[ve[k]]);\n\t\n\t\tdouble det=1.0/(v2.x*v1.y-v1.x*v2.y);\n\t\tdouble t,s;\n\t\tt=-v2.y*(x2.x-x1.x)+v2.x*(x2.y-x1.y);\n\t\ts=-v1.y*(x2.x-x1.x)+v1.x*(x2.y-x1.y);\n\t\tt*=det;\n\t\ts*=det;\n\t\tPoint c=x1+v1*t;\n\t\tdouble rr=(c-p[ve[i]]).absv();\n\t\tfor(int kk=0;kk<d;kk++)if((p[ve[kk]]-c).absv()>rr+EPS) goto lll2;\n\t\tans=min(ans,rr);\n\t\t\n\t\tlll2:;\n\t\t\n\t}\n\t\n\trd[r]=ans;\n\tsumi[r]=1;\n//\tcout<<bitset<10>(r)<<\" \"<<ans<<endl;\n\treturn ans;\n}\n\n\nsigned main(){\n\t\nint m;\n\tfor(int i=0;i<(1<<14);i++)for(int j=0;j<15;j++)dp[i][j]=1000000000.0;\n\t\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\tse.insert(mp(y,yy));\n\t}\n\t\n\tint cn=0;\n\tfor(auto it=se.begin();it!=se.end();it++){\n\t\tp[cn].x=(*it).first;\n\t\tp[cn].y=(*it).second;\n\t\tcn++;\n\t\t\n\t}\n\t\n\tn=cn;\n\t\n\tif(n<=m){\n\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tif(n==2){\n\t\tprintf(\"%.10lf\\n\",((p[0]-p[1]).absv())/2.0);\n\t\treturn 0;\n\t\n\t}\n\tdp[0][0]=0.0;\n\t\n\tfor(int i=1;i<(1<<n);i++)for(int j=1;j<=m;j++){\n\t\t\n\t\tfor(int jj=i;jj>0;jj=(jj-1)&i){\n\t\t\tdp[i][j]=min(dp[i][j],max(dp[i^jj][j-1],solve(jj)));\n\t\t\t//cout<<solve(j)<<endl;\n\t\t}\n\t//\tcout<<bitset<5>(i)<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t}\n\tprintf(\"%.10lf\\n\",dp[-1+(1<<n)][m]);\n\t\n\treturn 0;\n\t\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n\nconst int MAX_V = 2000; /////////////////////////////////////////////////////////////\n\nstruct Edge{ int to,cap,rev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((Edge){to,cap,(int)G[to].size()});\n  G[to].push_back((Edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INT_MAX);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(); }\n\n\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\n\n\n\n\n\nint N,M;\nPoint ps[111];\n\nint dp[20*20*20][1<<14];\nint calc(int n,double r) {\n  vector<int> vec;\n\n  rep(i,n) {\n    int bits = 0;\n    rep(j,n) {\n      if( LTE(abs(ps[i]-ps[j]),r) ) {\n\tbits |= (1<<j);\n      }\n    }\n    vec.push_back(bits);\n  }\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j)continue;\n      Point Rr = ps[i]-ps[j];\n      if(abs(Rr) <= r*2+EPS || 1){\n\tPoint UKPC,U,P1,P2;\n\tUKPC = (ps[i]+ps[j])*0.5;\n\tdouble l = abs(ps[i]-ps[j]) * 0.5;\n\tif( LTE(r * r - l * l,0)  ) continue;\n\tdouble T = sqrt(r*r-l*l);\n\t\n\tUKPC = (ps[i]+ps[j])*0.5;\n\t//P1 = UKPC + (ps[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\tPoint uni = (ps[i] - ps[j]) / abs(ps[i]-ps[j]);\n\t//cout << \"uni = \" << uni <<endl;\n\t//P1 = UKPC + (T*((ps[i]-ps[j])/abs(ps[i]-ps[j])))*\n\tP1 = UKPC + rotate(uni,M_PI/2.0) * T;\n\t//P2 = UKPC + (ps[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t//P2 = UKPC + (ps[i]-ps[j])/abs(ps[i]-ps[j])*rotate(T,-M_PI/2.0);\n\tP2 = UKPC + rotate(uni,-M_PI/2.0) * T;\n\t/*\n\tputs(\"\");\n\tcout << ps[i] << \" and \" << ps[j] << endl;\n\tcout << \"UKPC = \" << UKPC << endl;\n\tcout << \"T = \" << T << endl;\n\tcout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t*/\n\t//cout << ps[i] << \" and \" << ps[j] <<endl;;\n\tdouble Calc;\n\tint bits = 0;\n\tfor(int k=0;k<n;k++){\n\t  Calc = abs(P1-ps[k]);\n\t  if(fabs(Calc) < r+EPS){\n\t    bits |= (1<<k);\n\t  }\n\t}\n\t//bitset<5> BIT(bits);\n\t//cout << BIT << endl;\n\tvec.push_back(bits);\n\tbits = 0;\n\tfor(int k=0;k<n;k++){\n\t  Calc = abs(P2-ps[k]);\n\t  if(fabs(Calc) < r+EPS){\n\t    bits |= (1<<k);\n\t  }\n\t}\n\t//BIT = bits;\n\t//cout << BIT << endl;\n\tvec.push_back(bits);\n \n      }\n \n    }\n  }\n  assert(vec.size()<20*20*20);\n  int len = vec.size();\n  rep(i,len+1) rep(j,(1<<n)) {\n    dp[i][j] = INT_MAX;\n  }\n  dp[0][0] = 0;\n\n  rep(i,len) {\n    rep(j,(1<<n)) {\n      int bits = vec[i];\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,cが反時計周りの順に並ぶ\n//-1: a,b,cが時計周りの順に並ぶ\n// 2: c,a,bの順に直線に並ぶ\n//-2: a,b,cの順に直線に並ぶ\n// 0: a,c,bの順に直線に並ぶ\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//線対象の位置にある点\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// 直線と直線の交点\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//先にisis_ssしてね\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// 線分と線分の交点\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine line_bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n//点と点の垂直二等分線　aを左に見ながら\nLine point_bisection(const Point&a, const Point&b) {\n\tconst Point cen((a + b) / 2.l);\n\tconst Point vec = (b - a)*Point(0, 1);\n\treturn Line(cen, cen + vec);\n}\n\n//三つの点からなる外心\nPoint outer_center(const vector<Point>&ps) {\n\tassert(ps.size() == 3);\n\tLine l1 = point_bisection(ps[0], ps[1]);\n\tLine l2 = point_bisection(ps[1], ps[2]);\n\n\treturn is_ll(l1, l2);\n}\n\n\n//三つの直線からなる内心\n//三つの直線が並行でないことは確かめといてね\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(line_bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(line_bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//三つの直線からなる傍心\n//三つの直線が並行でないことは確かめといてね\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(line_bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(line_bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:並行\n//c:並行でない\n//三つの直線から同距離の位置を求める。\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(line_bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(line_bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(line_bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n/*\n点が円の中にいるか\n0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const  Point& p, const Circle &cir) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n/*\n円lcが円rcの中にいるか\n0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//二つの円の重なり面積\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n\n\n//多角形(複数の点)の最小包含円をO(N=頂点数)で求めるアルゴリズム\n//同一直線上に三つの点がないこと\n#include<random>\nCircle welzl(vector<Point>ps) {\n\tstruct solver {\n\t\tCircle solve(vector<Point>&ps, vector<Point>&rs) {\n\t\t\tif (ps.empty() || rs.size() == 3) {\n\t\t\t\tif (rs.size() == 1) {\n\t\t\t\t\treturn Circle(Point(rs[0]), 0);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 2) {\n\t\t\t\t\treturn Circle((rs[0] + rs[1]) / 2.0l, abs(rs[1] - rs[0]) / 2);\n\t\t\t\t}\n\t\t\t\telse if (rs.size() == 3) {\n\t\t\t\t\tvector<Line> ls(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tls[i] = Line(rs[i], rs[(i + 1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t\tPoint center = outer_center(rs);\n\t\t\t\t\treturn Circle(center, abs(center - rs[0]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Circle(Point(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tPoint p_ba = ps.back();\n\t\t\t\tps.pop_back();\n\t\t\t\tCircle d = solve(ps, rs);\n\t\t\t\tps.push_back(p_ba);\n\t\t\t\tif (is_in_Circle(d, p_ba)) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trs.push_back(p_ba);\n\t\t\t\t\tps.pop_back();\n\t\t\t\t\tauto ans = solve(ps, rs);\n\t\t\t\t\tps.push_back(p_ba);\n\t\t\t\t\trs.pop_back();\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}so;\n\tstd::random_device rd;\n\tstd::mt19937 mt(rd());\n\tshuffle(ps.begin(), ps.end(), mt);\n\tvector<Point>rs;\n\tCircle ans = so.solve(ps, rs);\n\treturn ans;\n}\n// 面積\nld get_area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0; j<n; ++j) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n//点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\tfor(int i=0;i<n;++i) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\nbool solve(vector<pair<ld, vector<int>>>bombs, int N, int M, ld len) {\n\t{\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (int i = 0; i < bombs.size(); ++i) {\n\t\t\tld r=bombs[i].first;\n\t\t\tif(r<len)n_bombs.emplace_back(bombs[i]);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tvector<vector<int>>memo(M+1,vector<int>(1<<N));\n\tmemo[0][0]=true;\n\tfor (int b_use = 0; b_use < M; ++b_use) {\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tif(!memo[b_use][i])continue;\n\n\t\t\tfor (auto&& now_b : bombs) {\n\n\t\t\t\tbitset<14>bs(i);\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif(now_b.second[j])bs[j]=true;\n\t\t\t\t}\n\t\t\t\tmemo[b_use+1][bs.to_ulong()]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[M][(1<<N)-1];\n}\n\n\n\nint main() {\n\tint N,M;cin>>N>>M;\n\tvector<Point>pos;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x,y;cin>>x>>y;\n\t\tpos.push_back(Point(x,y));\n\t}\n\n\tvector<pair<ld,vector<int>>>bombs;\n\t{\n\t\tvector<int>v(3);\n\t\tfor (v[0] = 0; v[0] < N; ++v[0]) {\n\t\t\t{\n\t\t\t\tld r=1e-8;\n\t\t\t\tCircle c(pos[v[0]], r);\n\n\t\t\t\tvector<int>oks(N);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t}\n\t\t\tfor ( v[1] = v[0] + 1; v[1] < N; ++v[1]) {\n\t\t\t\t{\n\t\t\t\t\tPoint p((pos[v[0]]+pos[v[1]])/2.0l);\n\t\t\t\t\tconst ld r = abs(p - pos[v[0]]);\n\t\t\t\t\tCircle c(p, r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r, oks));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (v[2] = v[1] + 1; v[2] < N; ++v[2]) {\n\t\t\t\t\tvector<Point>ci_pos(3);\n\t\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\t\tci_pos[i]=pos[v[i]];\n\t\t\t\t\t}\n\t\t\t\t\tLine l1 = point_bisection(ci_pos[0], ci_pos[1]);\n\t\t\t\t\tLine l2 = point_bisection(ci_pos[1], ci_pos[2]);\n\t\t\t\t\tPoint sv = l1.b - l1.a, tv = l2.b - l2.a;\n\t\t\t\t\tif (abs(cross(sv, tv)) < eps) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tPoint p(outer_center(ci_pos));\n\t\t\t\t\tconst ld r=abs(p-ci_pos[0]);\n\t\t\t\t\tCircle c(p,r);\n\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (is_in_Circle(c, pos[i])) {\n\t\t\t\t\t\t\toks[i]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbombs.push_back(make_pair(r,oks));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tmap<int, ld>mp;\n\t\tfor (auto&& bomb : bombs) {\n\t\t\tbitset<14>bs;\n\t\t\tfor (int i = 0; i < bomb.second.size(); ++i) {\n\t\t\t\tif(bomb.second[i])bs[i]=true;\n\t\t\t}\n\t\t\tif (mp.find(bs.to_ulong()) == mp.end()) {\n\t\t\t\tmp[bs.to_ulong()]=bomb.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[bs.to_ulong()]=min(bomb.first,mp[bs.to_ulong()]);\n\t\t\t}\n\t\t}\n\t\tauto n_bombs(bombs);\n\t\tn_bombs.clear();\n\t\tfor (auto m : mp) {\n\t\t\tbitset<14>bs(m.first);\n\t\t\tvector<int>v(N);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif(bs[i])v[i]=true;\n\t\t\t}\n\t\t\tn_bombs.emplace_back(m.second,v);\n\t\t}\n\t\tbombs=n_bombs;\n\t}\n\n\tld l=0,r=1e9;\n\tint time=30;\n\twhile (time--) {\n\t\tld m=(l+r)/2;\n\t\tif (solve(bombs, N, M, m)) {\n\t\t\tr=m;\n\t\t}\n\t\telse {\n\t\t\tl=m;\n\t\t}\n\t}\n\tcout<<setprecision(10)<<fixed;\n\tcout<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define D long double\nusing namespace std;\n//typedef long double D;\ntypedef complex<long double> P;\ntypedef vector<P> VP;\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  long double d1 = cross(b2-b1, b1-a1);\n  long double d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*(long double)0.5;\n  b = (b-c)*(long double)0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\nint dp[1<<14],n,m;\nD min_s[1<<14];\nVP v;\nvoid Mae_syori(){\n  r(i,(1<<n))min_s[i]=1e15;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      for(int k=j+1;k<n;k++){\n        if(isecSP(v[i],v[j],v[k]))continue;\n        if(isecSP(v[i],v[k],v[j]))continue;\n        if(isecSP(v[k],v[j],v[i]))continue;\n        P c=circumcenter(v[i],v[j],v[k]);\n        D ans=0;\n        ans=max(ans,abs(v[i]-c));\n        ans=max(ans,abs(v[j]-c));\n        ans=max(ans,abs(v[k]-c));\n        int mask=0;\n        for(int l=0;l<n;l++){\n          if(abs(v[l]-c)<=ans)mask|=(1<<l);\n        }\n        min_s[mask]=min(ans,min_s[mask]);\n      }\n      D ans=abs(v[i]-v[j])/2;\n      P c=(v[i]+v[j]);c/=2;\n      int mask=0;\n      for(int l=0;l<n;l++){\n        if(abs(v[l]-c)<=ans)mask|=(1<<l);\n      }\n      min_s[mask]=min(ans,min_s[mask]);\n    }\n  }\n  r(i,n)min_s[(1<<i)]=0;\n  for(int i=(1<<n)-1;i>=0;i--){\n    for(int j=(i-1)&i;j>0;j=(j-1)&i){\n      min_s[j]=min(min_s[j],min_s[i]);\n    }\n  }\n  for(int i=0;i<(1<<n);i++) min_s[i]+=0.0000000001;\n}\nD dfs(int S){\n  if(dp[S])return dp[S];\n  D res=1e8;\n  for(int i=(S-1)&S;i>0;i=(i-1)&S){\n    res=min(res,dfs(i)+dfs(i^S));\n  }\n  return dp[S]=res;\n}\nbool check(D mid){\n  memset(dp,0,sizeof(dp));\n  for(int i=1;i<(1<<n);i++){\n    if(min_s[i]<=mid)dp[i]=1;\n  }\n  return dfs((1<<n)-1)<=m;\n}\nD nibutan(){\n  D l=0,r=100000;\n  r(i,77){\n    D mid=(l+r)/2;//cout<<mid<<endl;\n    if(check(mid))r=mid;\n    else l=mid;\n  }\n  return l;\n}\nint main(){\n  cin>>n>>m;\n  r(i,n){\n    int x,y;\n    cin>>x>>y;\n    v.push_back(P(x,y));\n  }\n  Mae_syori();\n  printf(\"%.12Lf\\n\",nibutan());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n\nconst int MAX_V = 2000; /////////////////////////////////////////////////////////////\n\nstruct Edge{ int to,cap,rev; };\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((Edge){to,cap,(int)G[to].size()});\n  G[to].push_back((Edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if( v == t ) return f;\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    Edge &e = G[v][i];\n    if( !used[e.to] && e.cap > 0 ){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s,t,INT_MAX);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nvoid init(int _size=MAX_V){ rep(i,_size) G[i].clear(); }\n\n\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\n\n\n\n\n\nint N,M;\nPoint ps[111];\n\nint dp[20*20*20][1<<14];\nint calc(int n,double r) {\n  vector<int> vec;\n\n  rep(i,n) {\n    int bits = 0;\n    rep(j,n) {\n      if( LTE(abs(ps[i]-ps[j]),r) ) {\n\tbits |= (1<<j);\n      }\n    }\n    vec.push_back(bits);\n  }\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j)continue;\n      Point Rr = ps[i]-ps[j];\n      if(abs(Rr) <= r*2+EPS || 1){\n\tPoint UKPC,U,P1,P2;\n\tUKPC = (ps[i]+ps[j])*0.5;\n\tdouble l = abs(ps[i]-ps[j]) * 0.5;\n\tif( LTE(r * r - l * l,0)  ) continue;\n\tdouble T = sqrt(r*r-l*l);\n\t\n\tUKPC = (ps[i]+ps[j])*0.5;\n\t//P1 = UKPC + (ps[i]-point[j])/abs(point[i]-point[j])*polar(T,PI/2.0);\n\tPoint uni = (ps[i] - ps[j]) / abs(ps[i]-ps[j]);\n\t//cout << \"uni = \" << uni <<endl;\n\t//P1 = UKPC + (T*((ps[i]-ps[j])/abs(ps[i]-ps[j])))*\n\tP1 = UKPC + rotate(uni,M_PI/2.0) * T;\n\t//P2 = UKPC + (ps[i]-point[j])/abs(point[i]-point[j])*polar(T,-PI/2.0);\n\t//P2 = UKPC + (ps[i]-ps[j])/abs(ps[i]-ps[j])*rotate(T,-M_PI/2.0);\n\tP2 = UKPC + rotate(uni,-M_PI/2.0) * T;\n\t/*\n\tputs(\"\");\n\tcout << ps[i] << \" and \" << ps[j] << endl;\n\tcout << \"UKPC = \" << UKPC << endl;\n\tcout << \"T = \" << T << endl;\n\tcout << \"P1 = \" << P1 << \", P2 = \" << P2 << endl;\n\t*/\n\t//cout << ps[i] << \" and \" << ps[j] <<endl;;\n\tdouble Calc;\n\tint bits = 0;\n\tfor(int k=0;k<n;k++){\n\t  Calc = abs(P1-ps[k]);\n\t  if(fabs(Calc) < r+EPS){\n\t    bits |= (1<<k);\n\t  }\n\t}\n\t//bitset<5> BIT(bits);\n\t//cout << BIT << endl;\n\tvec.push_back(bits);\n\tbits = 0;\n\tfor(int k=0;k<n;k++){\n\t  Calc = abs(P2-ps[k]);\n\t  if(fabs(Calc) < r+EPS){\n\t    bits |= (1<<k);\n\t  }\n\t}\n\t//BIT = bits;\n\t//cout << BIT << endl;\n\tvec.push_back(bits);\n \n      }\n \n    }\n  }\n  assert(vec.size()<20*20*20);\n  int len = vec.size();\n  rep(i,len+1) rep(j,(1<<n)) {\n    dp[i][j] = INT_MAX;\n  }\n  dp[0][0] = 0;\n\n  rep(i,len) {\n    rep(j,(1<<n)) {\n      int bits = vec[i];\n      dp[i+1][j] = min(dp[i+1][j|bits],dp[i][j]);\n      if( dp[i][j] == INT_MAX ) continue;\n      dp[i+1][j|bits] = min(dp[i+1][j|bits],dp[i][j]+1);\n\n    }\n  }\n  int resp = dp[len][(1<<n)-1];\n  return resp;\n}\n\nbool check(double r) {\n  return calc(N,r) <= M;\n}\n\nvoid compute() {\n  double L=0,R=100000000;//fewopajfeaw\n  rep(_,100) {//feoajfewao\n    double _M = ( L + R ) * 0.5;\n    if( check(_M) ) {\n       R = _M;\n    } else {\n      L = _M;\n    }\n  }\n  printf(\"%.10f\\n\",L);\n}\n\nint main() {\n  cin >> N >> M;\n  rep(i,N) cin >> ps[i].x >> ps[i].y;\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntypedef pair<double, double> PD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst double EPS = 1e-10;\n\ndouble dist(PD x, PD y){\n    return sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\n\ndouble calcCircleOf2Point(PD p1, PD p2, PD p3, PD ce){\n    double x1 = p1.first, x2 = p2.first, x3 = p3.first;\n    double y1 = p1.second, y2 = p2.second, y3 = p3.second;\n\n    double ox, oy, a, b, c, d;\n    double r1, r2, r3;\n\n    a = x2 - x1 ;\n    b = y2 - y1 ;\n    c = x3 - x1 ;\n    d = y3 - y1 ;\n\n    if (fabs(a * d - b * c) <= EPS) return -1.0;\n\n    ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2 ;\n    if  (fabs(b) > EPS) {\n        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2 ;\n    } else {\n        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2 ;\n    }\n    r1   = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1)) ;\n    r2   = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2)) ;\n    r3   = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3)) ;\n    ce = PD(ox, oy);\n    return (r1 + r2 + r3) / 3 ;\n}\n\ndouble calc(vector<PD> p){\n    int n = p.size();\n    if (n <= 1) return 0.0;\n    if (n == 2) return dist(p[0], p[1]) / 2;\n\n    double ret = 1e9;\n\n    REP(i,n) REP(j,i){\n        PD c((p[i].first + p[j].first) / 2, (p[i].second + p[j].second) / 2);\n        double d = dist(c, p[i]);\n        bool ok = true;\n        REP(k,n) if (dist(c, p[k]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    REP(i,n) REP(j,i) REP(k,i){\n        PD c;\n        double d = calcCircleOf2Point(p[i], p[j], p[k], c);\n        bool ok = true;\n        REP(l,n) if (dist(c, p[l]) > d + EPS) ok = false;\n        if (ok) ret = fmin(ret, d);\n    }\n\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<PD> p(n);\n    REP(i,n) cin >> p[i].first >> p[i].second;\n\n    sort(ALL(p));\n    p.erase(unique(ALL(p)), p.end());\n\n    n = p.size();\n\n    vector<double> r(1<<n);\n    REP(mask,1<<n){\n        vector<PD> a;\n        REP(i,n) if ((mask >> i) & 1) a.push_back(p[i]);\n        r[mask] = calc(a);\n\n        // cout << mask << \" \" << r[mask] << endl;\n    }\n\n    vector<vector<double> > dp(1<<n, vector<double>(m+1, 1e9));\n    dp[0][0] = 0;\n    REP(i,m){\n        REP(mask,1<<n){\n            int co = (1 << n) - 1 - mask;\n            for (int next = (1 << n) - 1; next >= 0; --next){\n                next &= co;\n                dp[mask | next][i+1] = fmin(dp[mask | next][i+1], fmax(dp[mask][i], r[next]));\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist2(double px, double py, double qx, double qy) {\n  return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] / 100000000;\n    Y[i] = P[i] % 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n\n    // cerr << \"s: \" << s << endl;\n\n    double minr = 1e50;\n    REP(i, 0, N) REP(j, i + 1, N) REP(k, j + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)) && (s & (1LL << k)))) continue;\n\n      // cerr << \"  i, j, k: \" << i << \" \" << j << \" \" << k << endl;\n\n      double d1x = +(Y[i] - Y[j]);\n      double d1y = -(X[i] - X[j]);\n      double m1x = (X[i] + X[j]) / 2.0;\n      double m1y = (Y[i] + Y[j]) / 2.0;\n      double d2x = +(Y[j] - Y[k]);\n      double d2y = -(X[j] - X[k]);\n      double m2x = (X[j] + X[k]) / 2.0;\n      double m2y = (Y[j] + Y[k]) / 2.0;\n\n      double x, y, r;\n      if((d1y * d2x) - (d1x * d2y) < EPS) {\n        double di = dist2(X[j], Y[j], X[k], Y[k]);\n        double dj = dist2(X[k], Y[k], X[i], Y[i]);\n        double dk = dist2(X[i], Y[i], X[j], Y[j]);\n\n        // cerr << \"    di: \" << di << \", dj: \" << dj << \", dk: \" << dk << endl;\n\n        if(di > dj && di > dk) { x = (X[j] + X[k]) / 2.0; y = (Y[j] + Y[k]) / 2.0; r = sqrt(di) / 2.0; };\n        if(dj > dk && dj > di) { x = (X[k] + X[i]) / 2.0; y = (Y[k] + Y[i]) / 2.0; r = sqrt(dj) / 2.0; };\n        if(dk > di && dk > dj) { x = (X[i] + X[j]) / 2.0; y = (Y[i] + Y[j]) / 2.0; r = sqrt(dk) / 2.0; };\n      } else {\n\n        // cerr << \"    d1: (\" << d1x << \", \" << d1y << \"), m1: :(\" << m1x << \", \" << m1y << \")\" << endl;\n        // cerr << \"    d2: (\" << d2x << \", \" << d2y << \"), m2: :(\" << m2x << \", \" << m2y << \")\" << endl;\n\n        double a = d1x, b = -d2x, c = m2x - m1x;\n        double d = d1y, e = -d2y, f = m2y - m1y;\n\n        // cerr << \"    a: \" << a << \", b: \" << b << \", c: \" << c << endl;\n        // cerr << \"    d: \" << d << \", e: \" << e << \", f: \" << f << endl;\n\n        double t1 = (c * e - b * f) / (a * e - b * d);\n        double t2 = (c * d - a * f) / (b * d - a * e);\n        if(-EPS < t1 && t1 < EPS) t1 = 0;\n        if(-EPS < t2 && t2 < EPS) t2 = 0;\n\n        // cerr << \"    t1: \" << t1 << \", t2: \" << t2 << endl;\n\n        x = d1x * t1 + m1x;\n        y = d1y * t1 + m1y;\n        r = sqrt((X[i] - x) * (X[i] - x) + (Y[i] - y) * (Y[i] - y));\n      }\n\n      // cerr << \"    (x, y): (\" << x << \", \" << y << \"), r: \" << r << endl;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r * r) ok = false;\n      if(ok) minr = min(minr, r);\n\n      // cerr << \"    ok: \" << ok << endl;\n    }\n    // radius[s] = minr;\n\n    // cerr << s << \": \" << radius[s] << endl;\n\n    double minr_ = 1e50;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)))) continue;\n\n      double x = (X[i] + X[j]) / 2.0;\n      double y = (Y[i] + Y[j]) / 2.0;\n      double r = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r * r) ok = false;\n      if(ok) minr_ = min(minr_, r);\n    }\n    radius[s] = min(minr, minr_);\n  }\n\n  REP(i, 0, N) radius[1LL << i] = 0.0;\n  REP(i, 0, N) REP(j, 0, N) radius[(1LL << i) | (1LL << j)] = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n  radius[0] = 0.0;\n\n  // cerr << radius[0] << endl;\n  // cerr << radius[(1LL << N) - 1] << endl;\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e50));\n  dp[0][0] = 0.0;\n  REP(i, 0, M) REP(s, 0, 1LL << N) {\n    // cerr << s << \", \" << i << \": \" << dp[s][i] << endl;\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e50;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nusing P = complex<D>;\n\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn(abs(a-b)); }\nD mabs(P p) { return abs(p.real()) + abs(p.imag()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.real()-l.real())) return l.real() < r.real();\n    if (sgn(r.imag()-l.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nD cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nD dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgn(cross(b, c) / mabs(b));\n    if (s) return s;\n    if (!sgn(mabs(c)) || !sgn(mabs(c-b))) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\n\nstruct L {\n    P x, y;\n    L() {}\n    L(P x, P y) :x(x), y(y) {}\n    P vec() const { return y-x; }\n};\nD abs(const L &l) { return abs(l.vec()); }\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.x)/abs(l.vec()));\n}\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec()*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\n\n\nusing Pol = V<P>;\nusing Tri = array<P, 3>;\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nC circumCircle(P a, P b, P c) {\n    b -= a; c -= a;\n    D s = 2*cross(b, c);\n    D x = norm(b-c), y = norm(c), z = norm(b);\n    D S = x+y+z;\n    P r = (y*(S-2*y)*b+z*(S-2*z)*c)/(s*s);\n    return C(r + a, abs(r));\n}\n\nC smallestEnclosingCircle(Pol &p, int ps = 0, Tri q = Tri(), int qs = 0) {\n    if (ps == p.size()) {\n        switch (qs) {\n            case 0:\n                return C(P(0, 0), -1);\n            case 1:\n                return C(q[0], 0);\n            case 2:\n                return C((q[0]+q[1])/D(2.0), abs(q[0]-q[1])/D(2.0));\n            case 3:\n                return circumCircle(q[0], q[1], q[2]);\n        }\n        assert(false);\n    }\n    C c = smallestEnclosingCircle(p, ps+1, q, qs);\n    if (sgn(abs(p[ps]-c.p) - c.r) == 1) {\n        q[qs] = p[ps];\n        return smallestEnclosingCircle(p, ps+1, q, qs+1);\n    }\n    return c;\n}\n\n\n\n\n\nconst int MN = 14;\nconst int MM = 14;\nint n, m;\nP p[MN];\nD pre[1<<MN];\nD dp[MM+1][1<<MN];\nbool vis[MM+1][1<<MN];\n\nD solve(int f, int m) {\n    if (f == 0) return 0;\n    if (m == 0) return 1e100;\n    if (vis[m][f]) return dp[m][f];\n    vis[m][f] = true;\n    D ans = 1e100;\n    int g = 0;\n    do {\n        ans = min(ans, max(pre[g], solve(f^g, m-1)));\n        g = ((g|~f)+1) & f;\n    } while (g);\n    return dp[m][f] = ans;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    for (int f = 0; f < (1<<n); f++) {\n        V<P> v;\n        for (int i = 0; i < n; i++) {\n            if (!(f & (1<<i))) continue;\n            v.push_back(p[i]);\n        }\n        pre[f] = smallestEnclosingCircle(v).r;\n\n//        cout << f << \" \" << pre[f] << endl;\n    }\n\n    cout << solve((1<<n) - 1, m) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\nconstexpr double PI = 3.1415926535897932;\n\nusing int32 = std::int_fast64_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast64_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nconst char *yes(bool c) { return c ? \"yes\" : \"no\"; }\nconst char *Yes(bool c) { return c ? \"Yes\" : \"No\"; }\nconst char *YES(bool c) { return c ? \"YES\" : \"NO\"; }\nconst char *pos(bool c) { return c ? \"possible\" : \"impossible\"; }\nconst char *Pos(bool c) { return c ? \"Possible\" : \"Impossible\"; }\nconst char *POS(bool c) { return c ? \"POSSIBLE\" : \"IMPOSSIBLE\"; }\ntemplate<class T>bool bmaxi(T&a, const T&b) { if (b<a)return 0;a = b;return 1; }\ntemplate<class T>bool bmini(T&a, const T&b) { if (a<b)return 0;a = b;return 1; }\ntemplate<class T>bool nmaxi(T&a, const T&b) { if (a<b) { a = b;return 1; }return 0; }\ntemplate<class T>bool nmini(T&a, const T&b) { if (b<a) { a = b;return 1; }return 0; }\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);bool f = 0;while (c<'0' || '9'<c) { if (c == '-')f = 1;c = fgetc(stdin); }\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }if (f)d = -d;\n}\ntemplate<typename T>auto scan(T&d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\td = 0;int c = fgetc(stdin);while (c == ' ' || c == '\\n')c = fgetc(stdin);\n\twhile (c != ' '&&c != '\\n') { d = d * 10 + c - '0';c = fgetc(stdin); }\n}\nvoid scan(char&d) { d = fgetc(stdin);while (d == ' ' || d == '\\n')d = fgetc(stdin); }\nvoid scan(double&d) { scanf(\"%lf\", &d); }void scan(std::string&d) {\n\td.clear();int c = fgetc(stdin);\n\twhile (c == ' ' || c == '\\n')c = fgetc(stdin);while (c != ' '&&c != '\\n') { d.push_back(c);c = fgetc(stdin); }\n}\ntemplate<typename F, typename...R>void scan(F&f, R&...r) { scan(f);scan(r...); }\ntemplate<typename T>T in() { T d;scan(d);return d; }\ntemplate <typename T>auto print(T d)->typename std::enable_if<std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;bool f = 0;if (d<0) { f = 1;d = -d; }while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;if (f)fputc('-', stdout);while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<typename T>auto print(T d)->typename std::enable_if<!std::is_signed<T>::value>::type\n{\n\tstatic int c[20];int i = 0;while (d) { c[i++] = d % 10;d /= 10; }\n\tif (!i)c[i++] = 0;while (i--)fputc(c[i] + '0', stdout);\n}\ntemplate<>void print<char>(char d) { fputc(d, stdout); }\ntemplate<>void print<double>(double d) { printf(\"%f\", d); }\ntemplate<>void print<char *>(char *c) { while (*c != '\\0')fputc(*(c++), stdout); }void print() {}\ntemplate<typename F, typename...R>void print(F f, R...r) { print(f);print(r...); }\ntemplate<typename...R>void println(R...r) { print(r...);fputc('\\n', stdout); }\ntemplate<typename...R>int END(R...r) { println(r...);return 0; }\nstruct angle {\n\tdouble r;\n\tangle() :r(0) {}\n\tangle(double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic double arr(const double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const double &o)const { return angle(r * o); }\n\tconst angle operator/(const double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const double &o) { return *this = *this * o; }\n\tangle &operator/=(const double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator double()const { return r; }\n\tconst double sin()const { return std::sin(r); }\n\tconst double cos()const { return std::cos(r); }\n\n\tconst double degree()const { return r*(180.0 / PI); }\n\tconst double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr double eps = 0.0000001;\n};\nangle operator\"\" _deg(long double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr double eps = 0.0000000000001;\n\tdouble x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(double x_, double y_) :x(x_), y(y_) {}\n\tpvec(double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / o.abs2(); }\n\tconst pvec operator*(const double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const double &o) { return *this = *this * o; }\n\tpvec &operator/=(const double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst double abs()const { return mysqrt(abs2()); }\n\tconst double abs2()const { return x*x + y*y; }\n\tconst angle arg()const { return angle(std::atan2(y, x)); }\n\tstatic const double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\tconst pvec dir()const { return *this / abs(); }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\nprivate:\n\tstatic const double mysqrt(const double &x) {\n\t\tdouble h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tdouble r = *(double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\n\nint main(void) {\n\tconst uint32 n = in<uint32>(), m = in<uint32>();\n\tconst uint32 siz = (uint32)1 << n;\n\tstd::vector<pvec> d(n);\n\tfor (auto &x : d)scan(x.x, x.y);\n\tstd::vector<double> t(siz, -0.00001);\n\tfor (uint32 i = 0;i < siz;++i) {\n\t\tfor (uint32 j = 0;j < n;++j) {\n\t\t\tfor (uint32 k = 0;k < n;++k) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif ((i >> j & 1) && (i >> k & 1)) {\n\t\t\t\t\tbmaxi(t[i], (d[j] - d[k]).abs2());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble low = 0, high = 40000000000;\n\n\tstd::vector<uint32> dp(siz);\n\tfor (uint32 bs = 0;bs < 100;++bs) {\n\t\tconst double mid = (low + high) / 2;\n\t\tfor (auto &x : dp)x = 100;\n\t\tfor (uint32 i = 1;i < siz;++i) {\n\t\t\tif (t[i] <= mid) { dp[i] = 1;continue; }\n\t\t\tfor (int32 k = (int32)i;k >= 0;k--) {\n\t\t\t\tk &= (int32)i;\n\t\t\t\tbmini(dp[i], dp[k] + dp[i - k]);\n\t\t\t}\n\t\t}\n\t\tif (dp.back() <= m)high = mid;\n\t\telse low=mid;\n\t}\n\tdouble ans = std::sqrt(high) / 2;\n\tprintln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nstruct Vector {\n\tdouble x, y;\n\tdouble length() const { return std::sqrt(x * x + y * y); }\n\tdouble dot(const Vector& that) const { return x * that.x + y * that.y; }\n\tdouble cross(const Vector& that) const { return x * that.y - y * that.x; }\n\tVector rotate90() const { return Vector{ -y, x }; }\n\tVector flip180() const { return Vector{ -x, -y }; }\n};\nVector operator*(const Vector& vec, const double scala) { return Vector{ vec.x * scala, vec.y * scala }; }\nVector operator*(const double scala, const Vector& vec) { return Vector{ vec.x * scala, vec.y * scala }; }\nstruct Coordinate {\n\tdouble x, y;\n\tdouble distance_from(const Coordinate& that) const { return (*this - that).length(); }\n\tCoordinate mid_point(const Coordinate& that) const { return Coordinate{ (x + that.x) / 2, (y + that.y) / 2 }; }\n\tVector operator-(const Coordinate& that) const { return Vector{ x - that.x, y - that.y }; }\n};\nCoordinate operator+(const Vector& vec, const Coordinate& coordinate) { return Coordinate{ vec.x + coordinate.x, vec.y + coordinate.y }; }\nCoordinate operator+(const Coordinate& coordinate, const Vector& vec) { return Coordinate{ vec.x + coordinate.x, vec.y + coordinate.y }; }\nconstexpr double EPS = 0.000000001;\nint remove_all(const std::vector<Coordinate>& bravers, int state, const double radius, const Coordinate center) {\n\tfor (auto i = 0; i < bravers.size(); ++i) if ((state & (1 << i)) != 0) {\n\t\tif (bravers[i].distance_from(center) <= radius + EPS) {\n\t\t\tstate ^= 1 << i;\n\t\t}\n\t}\n\treturn state;\n}\nbool can_defeat(const std::vector<Coordinate>& bravers, const int state, const int rest, const double radius, std::vector<std::vector<int>> &memo) {\n\tif (state == 0) return true;\n\tif (rest == 0) return false;\n\tif (memo[rest][state] >= 0) return memo[rest][state] == 1;\n\tmemo[rest][state] = 0;\n\tfor (auto i = 0; i < bravers.size(); ++i) if ((state & (1 << i)) != 0) {\n\t\tif (can_defeat(bravers, remove_all(bravers, state, radius, bravers[i]), rest - 1, radius, memo)) {\n\t\t\tmemo[rest][state] = 1;\n\t\t\treturn true;\n\t\t}\n\t\tfor (auto j = 0; j < i; ++j) if ((state & (1 << j)) != 0 && bravers[i].distance_from(bravers[j]) <= radius * 2 + EPS && EPS < bravers[i].distance_from(bravers[j])) {\n\t\t\tauto mid = bravers[i].mid_point(bravers[j]);\n\t\t\tauto vec = bravers[i] - bravers[j];\n\t\t\tauto catheti = vec.rotate90() * std::sqrt(radius * radius - vec.length() * vec.length() / 4) * (1 / vec.length());\n\t\t\tif (can_defeat(bravers, remove_all(bravers, state, radius, mid + catheti), rest - 1, radius, memo) || can_defeat(bravers, remove_all(bravers, state, radius, mid + catheti.flip180()), rest - 1, radius, memo)) {\n\t\t\t\tmemo[rest][state] = 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint n, m; std::cin >> n >> m;\n\tstd::vector<Coordinate> bravers(n); for (auto& braver : bravers) std::cin >> braver.x >> braver.y;\n\tstd::vector<std::vector<int>> memo(m + 1, std::vector<int>(1 << n, -1));\n\tdouble min = 0.0;\n\tdouble max = 150000;\n\twhile (min + 0.000001 < max) {\n\t\tauto mid = (min + max) / 2;\n\t\tfor (auto& vec : memo) std::fill(vec.begin(), vec.end(), -1);\n\t\tif (can_defeat(bravers, (1 << n) - 1, m, mid, memo)) max = mid;\n\t\telse min = mid;\n\t}\n\tstd::cout << std::setprecision(10) << std::fixed << max << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n \nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nusing C = pair<ld, P>;\n#define rad first\n#define pnt second\n \nC smallest_enclosing_disc(vector<P> ps){\n    auto c3 = [](const P &a, const P &b, const P &c){\n        ld A = norm(b - c);\n        ld B = norm(c - a);\n        ld C = norm(a - b);\n        ld S = abs(cross(b - a, c - a));\n        P p = (A*(B+C-A)*a + B*(C+A-B)*b + C*(A+B-C)*c) / (4*S*S);\n        ld r = abs(p - a);\n        return make_pair(r, p);\n    };\n \n    auto c2 = [](const P &a, const P &b){\n        P c = (a + b) / (ld)2;\n        ld r = abs(a - c);\n        return make_pair(r, c);\n    };\n \n    auto in_circle = [](const P &a, const C &c){\n        return norm(a - c.pnt) <= c.rad*c.rad + eps;\n    };\n \n    int n = ps.size();\n    if(n == 1) return make_pair(0, ps[0]);\n    random_shuffle(ps.begin(), ps.end());\n    C c = c2(ps[0], ps[1]);\n    for(int i = 2; i < n; ++i){\n        if(!in_circle(ps[i], c)){\n            c = c2(ps[0], ps[i]);\n            for(int j = 1; j < i; ++j){\n                if(!in_circle(ps[j], c)){\n                    c = c2(ps[j], ps[i]);\n                    for(int k = 0; k < j; ++k){\n                        if(!in_circle(ps[k], c)){\n                            c = c3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\ndouble circle_r[1 << 14];\ndouble dp[1 << 14][20];\ndouble solve(int bit, int k) {\n    if(dp[bit][k] + eps > inf) return dp[bit][k];\n    if(k == 1) return dp[bit][k] = circle_r[bit];\n    for(int part=bit; part>0; part=(part-1)&bit) {\n        int nbit = bit ^ part;\n        chmin(dp[bit][k], max(solve(nbit, k-1), circle_r[part]));\n        // printf(\"lhs(%lld, %lld) = %.12f, rhs(%lld) = %.12f\\n\", nbit, k-1, dp[nbit][k-1], part, circle_r[part]);\n    }\n    // printf(\"dp[%lld][%lld] = %.12f\\n\", bit, k, dp[bit][k]);\n    return dp[bit][k];\n}\n \nsigned main() {\n    int N, M; cin >> N >> M;\n    vector<P> ps;\n    for(int i=0; i<N; i++) {\n        double x, y; cin >> x >> y;\n        ps.push_back(P(x, y));\n    }\n\n    for(int bit=1; bit<(1<<N); bit++) {\n        vector<P> tmp;\n        for(int i=0; i<N; i++) {\n            if(bit >> i & 1) tmp.push_back(ps[i]);\n        }\n        circle_r[bit] = smallest_enclosing_disc(tmp).first;\n        // printf(\"circle_r[%lld] = %.12f\\n\", bit, circle_r[bit]);\n    }\n\n    for(int i=0; i<(1 << N); i++) {\n        fill(dp[i], dp[i] + 20, inf);\n    }\n    printf(\"%.12f\\n\", solve((1 << N) - 1, M));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist2(double px, double py, double qx, double qy) {\n  return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> X(N), Y(N);\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n\n    // cerr << \"s: \" << s << endl;\n\n    double minr2 = 1e20;\n    REP(i, 0, N) REP(j, i + 1, N) REP(k, j + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)) && (s & (1LL << k)))) continue;\n\n      // cerr << \"  i, j, k: \" << i << \" \" << j << \" \" << k << endl;\n\n      double d1x = +(Y[i] - Y[j]);\n      double d1y = -(X[i] - X[j]);\n      double m1x = (X[i] + X[j]) / 2.0;\n      double m1y = (Y[i] + Y[j]) / 2.0;\n      double d2x = +(Y[j] - Y[k]);\n      double d2y = -(X[j] - X[k]);\n      double m2x = (X[j] + X[k]) / 2.0;\n      double m2y = (Y[j] + Y[k]) / 2.0;\n\n      double x, y, r2;\n      if((d1y * d2x) - (d1x * d2y) < EPS) {\n        double di = dist2(X[j], Y[j], X[k], Y[k]);\n        double dj = dist2(X[k], Y[k], X[i], Y[i]);\n        double dk = dist2(X[i], Y[i], X[j], Y[j]);\n\n        // cerr << \"    di: \" << di << \", dj: \" << dj << \", dk: \" << dk << endl;\n\n        if(di > dj && di > dk) { x = (X[j] + X[k]) / 2.0; y = (Y[j] + Y[k]) / 2.0; r2 = pow(sqrt(di) / 2.0, 2); };\n        if(dj > dk && dj > di) { x = (X[k] + X[i]) / 2.0; y = (Y[k] + Y[i]) / 2.0; r2 = pow(sqrt(dj) / 2.0, 2); };\n        if(dk > di && dk > dj) { x = (X[i] + X[j]) / 2.0; y = (Y[i] + Y[j]) / 2.0; r2 = pow(sqrt(dk) / 2.0, 2); };\n      } else {\n\n        // cerr << \"    d1: (\" << d1x << \", \" << d1y << \"), m1: :(\" << m1x << \", \" << m1y << \")\" << endl;\n        // cerr << \"    d2: (\" << d2x << \", \" << d2y << \"), m2: :(\" << m2x << \", \" << m2y << \")\" << endl;\n\n        double a = d1x, b = -d2x, c = m2x - m1x;\n        double d = d1y, e = -d2y, f = m2y - m1y;\n\n        // cerr << \"    a: \" << a << \", b: \" << b << \", c: \" << c << endl;\n        // cerr << \"    d: \" << d << \", e: \" << e << \", f: \" << f << endl;\n\n        double t1 = (c * e - b * f) / (a * e - b * d);\n        double t2 = (c * d - a * f) / (b * d - a * e);\n        if(-EPS < t1 && t1 < EPS) t1 = 0;\n        if(-EPS < t2 && t2 < EPS) t2 = 0;\n\n        // cerr << \"    t1: \" << t1 << \", t2: \" << t2 << endl;\n\n        x = d1x * t1 + m1x;\n        y = d1y * t1 + m1y;\n        r2 = (X[i] - x) * (X[i] - x) + (Y[i] - y) * (Y[i] - y);\n      }\n\n      // cerr << \"    (x, y): (\" << x << \", \" << y << \"), r: \" << sqrt(r2) << endl;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r2 + EPS) ok = false;\n      if(ok) minr2 = min(minr2, r2);\n\n      // cerr << \"    ok: \" << ok << endl;\n    }\n    radius[s] = sqrt(minr2);\n\n    // cerr << s << \": \" << radius[s] << endl;\n  }\n\n  REP(i, 0, N) radius[1LL << i] = 0.0;\n  REP(i, 0, N) REP(j, 0, N) radius[(1LL << i) | (1LL << j)] = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e20));\n  dp[0][0] = 0.0;\n  REP(s, 0, 1LL << N) REP(i, 0, M) {\n    // cerr << s << \", \" << i << \": \" << dp[s][i] << endl;\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e20;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\ntypedef complex<double> P;\nint N, M;\nP p[14];\n\nconstexpr double EPS = 1e-8;\nint dp[1 << 14];\nconstexpr int INF = 100;\nbool check(double r) {\n\n\tvector<int> b;\n\tfor (int i : range(N)) {\n\t\tint bit = 0;\n\t\tfor (int j : range(N)) {\n\t\t\tdouble d = abs(p[i] - p[j]);\n\t\t\tif (d < EPS)bit|=(1<<j);\n\t\t}\n\t\tb.push_back(bit);\n\t}\n\tfor (int i : range(N)) {\n\t\tfor (int j : range(N)){\n\t\t\tP v = p[i] - p[j];\n\t\t\tdouble d = abs(v);\n\t\t\tif (d < EPS || d>2*r + EPS)continue;\n\t\t\tP u(v.imag(),-v.real());\n\t\t\tu /= d;\n\t\t\td /= 2;\n\t\t\tdouble dd = sqrt(r*r - d * d);\n\t\t\tu *= dd;\n\t\t\tP c = (p[i] + p[j]) / 2.0 + u;\n\t\t\tint bit = 0;\n\t\t\tfor (int k : range(N)) {\n\t\t\t\tif (r - abs(p[k] - c) >= -EPS)bit |= (1 << k);\n\t\t\t}\n\t\t\tb.push_back(bit);\n\t\t}\n\t}\n\tfor (int i : range(1 << N))dp[i] = INF;\n\tdp[0] = 0;\n\tfor (int i : range(1 << N)) {\n\t\tfor (auto &it : b) {\n\t\t\tchmin(dp[i | it], dp[i] + 1);\n\t\t}\n\t}\n\treturn dp[(1 << N) - 1] <= M;\n}\nint main() {\n\tcout << fixed;\n\tcout << setprecision(10);\n\tcin >> N >> M;\n\tfor (int i : range(N)) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\tdouble lb = EPS;\n\tdouble ub = 1e6;\n\tfor (int i : range(100)) {\n\t\tconst double mid = (lb + ub) / 2;\n\t\t(check(mid) ? ub : lb) = mid;\n\t}\n\tcout << ub << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist(double px, double py, double qx, double qy) {\n  return sqrt((px - qx) * (px - qx) + (py - qy) * (py - qy));\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] / 100000000;\n    Y[i] = P[i] % 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n    ll cnt = 0;\n    REP(i, 0, N) if(s & (1LL << i)) cnt++;\n    if(cnt < 2) {\n      radius[s] = 0.0;\n      continue;\n    }\n\n    double minr = 1e10;\n    REP(i, 0, N) REP(j, i + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)))) continue;\n\n      double d = dist(X[i], Y[i], X[j], Y[j]) / 2.0;\n      double dx = +(Y[i] - Y[j]) / (d * 2.0);\n      double dy = -(X[i] - X[j]) / (d * 2.0);\n      double mx = (X[i] + X[j]) / 2.0;\n      double my = (Y[i] + Y[j]) / 2.0;\n\n      bool ok = true;\n      REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], mx, my) > d + EPS) ok = false;\n      if(ok) {\n        minr = min(minr, d);\n        continue;\n      }\n\n      double l1 = d, h1 = 1e10;\n      REP(_, 0, 100) {\n        double m = (l1 + h1) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c1x = mx + dx * t;\n        double c1y = my + dy * t;\n        bool ok1 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c1x, c1y) > m + EPS) ok1 = false;\n\n        (ok1 ? h1 : l1) = m;\n      }\n\n      double l2 = d, h2 = 1e10;\n      REP(_, 0, 100) {\n        double m = (l2 + h2) / 2.0;\n        double t = sqrt(m * m - d * d);\n\n        double c2x = mx - dx * t;\n        double c2y = my - dy * t;\n        bool ok2 = true;\n        REP(k, 0, N) if(s & (1LL << k)) if(dist(X[k], Y[k], c2x, c2y) > m + EPS) ok2 = false;\n\n        (ok2 ? h2 : l2) = m;\n      }\n\n      minr = min(minr, min(h1, h2));\n    }\n    radius[s] = minr;\n  }\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e10));\n  dp[0][0] = 0.0;\n  REP(s, 0, 1LL << N) REP(i, 0, M) {\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e10;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing Double = double;\nusing Point = complex<Double>;\nconst Double EPS = 1e-8;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nnamespace std {\n  bool operator<(const Point a, const Point b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nDouble dot(const Point &a, const Point &b){ return a.X*b.X + a.Y*b.Y; }\nDouble cross(const Point &a, const Point &b){ return a.X*b.Y - a.Y*b.X; }\n\n// AB からみて AC がどの方向にあるか\nint ccw(const Point &a, const Point &b, const Point &c){\n  const Point db = b - a;\n  const Point dc = c - a;\n  if(cross(db,dc) >  EPS) return +1;  // ccw\n  if(cross(db,dc) < -EPS) return -1;  // cw\n  if(dot(db,dc)   < -EPS) return +2;  // c--a--b on line\n  if(norm(db) < norm(dc)) return -2;  // a--b--c on line or a==b\n  return 0;                           // a--c--b on line or a==c or b==c\n}\n\nvector<Point> circlesPointsRadius(const Point &a, const Point &b, const Double r){\n  vector<Point> cs;\n  Point abH = (b-a)*0.5;\n  Double d = abs(abH);\n  if(d == 0 ) return {a};\n  if(d > r) return {};\n  Double dN = sqrt(r*r - d*d);\n  Point n = abH * Point(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if(dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n\nPoint p[20];\nvector<int> nexts[20];\nint dp[1<<15];\n\nbool check(int n, int m, double r){\n  rep(i,n){\n    nexts[i].clear();\n    rep(j,n){\n      auto vc = circlesPointsRadius(p[i], p[j], r);\n      for(auto &c : vc){\n        int mask = 0;\n        rep(k,n) if(abs(c-p[k]) < r + EPS) mask |= (1<<k);\n        nexts[i].push_back(mask);\n      }\n    }\n    if(nexts[i].size()==0) nexts[i].push_back(1<<i);\n    // dbg(r,i,nexts[i]);\n  }\n\n  fill(dp, dp + (1<<n), 12345678);\n  dp[0] = 0;\n  rep(mask, 1<<n) if(dp[mask]>=0){\n    rep(i,n) if((mask>>i)%2==0){\n      for(auto &nm : nexts[i]){\n        dp[mask|nm] = min(dp[mask|nm], dp[mask] + 1);\n      }\n    }\n  }\n  return dp[(1<<n) - 1] <= m;\n}\n\ndouble solve(){\n  int n,m;\n  cin>>n>>m;\n  rep(i,n){\n    Double x,y;\n    cin>>x>>y;\n    p[i] = {x,y};\n  }\n\n  if(n==m) return 0;\n\n  double l=0, r=2e5;\n  rep(_,100){\n    double mid = (l+r)/2.0;\n    if(check(n,m,mid)) r = mid;\n    else l = mid;\n  }\n  return (l+r)/2.0;\n}\n\nint main(){\n  printf(\"%.10f\\n\", solve());\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 円の内外判定\n//  2 => out : 0 => on : 1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n// 凸包 : 凸多角形のある一辺上にある点を含まない\n/*\n Polygon convex_hull(vector<Point> ps) {\n int n = ps.size();\n int k = 0;\n sort(ps.begin(), ps.end());\n Polygon ch(2 * n);\n for (int i = 0; i < n; ch[k++] = ps[i++])\n while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n ch.resize(k - 1);\n return ch;\n }\n */\n// 凸多角形の直径\nld convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    ld res = abs(poly[ii] - poly[jj]);\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    do{\n        if(cross(poly[(i+1)%n] - poly[i],poly[(j+1)%n] - poly[j]) >= 0) j = (j+1)%n;\n        else i = (i+1)%n;\n        if(abs(poly[i] - poly[j]) > res){\n            res = abs(poly[i] - poly[j]);\n            maxi = i; maxj = j;\n        }\n    }while(i != ii || j != jj);\n    return res;\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\ntypedef Point P;\ntemplate <class iter>\nstd::pair<P, ld> min_ball(iter left, iter right, int seed = 1333) {\n    const int n = right - left;\n    \n    assert(n >= 1);\n    if (n == 1) {\n        return {*left, ld(0)};\n    }\n    \n    std::mt19937 mt(seed);\n    std::shuffle(left, right, mt);\n    // std::random_shuffle(left, right); // simple but deprecated\n    \n    iter ps = left;\n    using circle = std::pair<P, ld>;\n    \n    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {\n        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),\n        S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        ld r2 = std::norm(p - a);\n        return {p, r2};\n    };\n    \n    auto make_circle_2 = [](const P &a, const P &b) -> circle {\n        P c = (a + b) / (ld)2;\n        ld r2 = std::norm(a - c);\n        return {c, r2};\n    };\n    \n    auto in_circle = [](const P &a, const circle &c) -> bool {\n        return std::norm(a - c.first) <= c.second + eps;\n    };\n    \n    circle c = make_circle_2(ps[0], ps[1]);\n    \n    // MiniDisc\n    for (int i = 2; i < n; ++i) {\n        if (!in_circle(ps[i], c)) {\n            // MiniDiscWithPoint\n            c = make_circle_2(ps[0], ps[i]);\n            for (int j = 1; j < i; ++j) {\n                if (!in_circle(ps[j], c)) {\n                    // MiniDiscWith2Points\n                    c = make_circle_2(ps[i], ps[j]);\n                    for (int k = 0; k < j; ++k) {\n                        if (!in_circle(ps[k], c)) {\n                            c = make_circle_3(ps[i], ps[j], ps[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return c;\n}\n\n#define MAX_N 15\n#define MAX_M 15\nll N,M;\nPoint p[MAX_N];\n\n// dp[S][cnt] := 死んでいる勇者がSでcnt回爆発を行なっている時の最小半径\nld dp[1<<MAX_N][MAX_M];\n\n\nvector<pair<ld,ll>> St;\nvoid init(){\n    for(int i = 0;i < (1<<MAX_N);i++)for(int j = 0;j < MAX_M;j++) dp[i][j] = -1;\n}\n\nld rec(ll S,ll cnt,int p){\n    ld& res = dp[S][cnt];\n    if(S==((1<<N)-1)) return 0;\n    if(cnt==M) return LINF;\n    if(!(res < 0)) return res;\n    res = LINF;\n    for(int i = p; i < St.size();i++){\n        if(S == (S|St[i].second)) continue;\n        res = min(res,max(St[i].first,rec(S|St[i].second,cnt+1,i+1)));\n    }\n    return res;\n}\n\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cin >> N >> M;\n    for(int i = 0; i < N;i++) p[i] = input_point();\n    \n    // 最小包含円\n    for(int i = 1; i < (1<<N);i++){\n        vector<P> tp;\n        for(int j = 0; j < N;j++){\n            if((i>>j)&1){\n                tp.push_back(p[j]);\n            }\n        }\n        auto c = min_ball(tp.begin(),tp.end());\n//        cout << bitset<10>(i) << \" \" << c << endl;\n        St.push_back({sqrt(c.second),i});\n    }\n    \n    cout << fixed << setprecision(12) << rec(0,0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-10;\n\ndouble dist2(double px, double py, double qx, double qy) {\n  return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> P(N);\n  REP(i, 0, N) {\n    ll X, Y;\n    cin >> X >> Y;\n    P[i] = X * 100000000 + Y;\n  }\n\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n\n  N = P.size();\n  vector<double> X(N), Y(N);\n  REP(i, 0, N) {\n    X[i] = P[i] % 100000000;\n    Y[i] = P[i] / 100000000;\n  }\n\n  vector<double> radius(1LL << N);\n  REP(s, 0, 1LL << N) {\n\n    // cerr << \"s: \" << s << endl;\n\n    double minr = 1e20;\n    REP(i, 0, N) REP(j, i + 1, N) REP(k, j + 1, N) {\n      if(!((s & (1LL << i)) && (s & (1LL << j)) && (s & (1LL << k)))) continue;\n\n      // cerr << \"  i, j, k: \" << i << \" \" << j << \" \" << k << endl;\n\n      double d1x = +(Y[i] - Y[j]);\n      double d1y = -(X[i] - X[j]);\n      double m1x = (X[i] + X[j]) / 2.0;\n      double m1y = (Y[i] + Y[j]) / 2.0;\n      double d2x = +(Y[j] - Y[k]);\n      double d2y = -(X[j] - X[k]);\n      double m2x = (X[j] + X[k]) / 2.0;\n      double m2y = (Y[j] + Y[k]) / 2.0;\n\n      double x, y, r;\n      if((d1y * d2x) - (d1x * d2y) < EPS) {\n        double di = dist2(X[j], Y[j], X[k], Y[k]);\n        double dj = dist2(X[k], Y[k], X[i], Y[i]);\n        double dk = dist2(X[i], Y[i], X[j], Y[j]);\n\n        // cerr << \"    di: \" << di << \", dj: \" << dj << \", dk: \" << dk << endl;\n\n        if(di > dj && di > dk) { x = (X[j] + X[k]) / 2.0; y = (Y[j] + Y[k]) / 2.0; r = sqrt(di) / 2.0; };\n        if(dj > dk && dj > di) { x = (X[k] + X[i]) / 2.0; y = (Y[k] + Y[i]) / 2.0; r = sqrt(dj) / 2.0; };\n        if(dk > di && dk > dj) { x = (X[i] + X[j]) / 2.0; y = (Y[i] + Y[j]) / 2.0; r = sqrt(dk) / 2.0; };\n      } else {\n\n        // cerr << \"    d1: (\" << d1x << \", \" << d1y << \"), m1: :(\" << m1x << \", \" << m1y << \")\" << endl;\n        // cerr << \"    d2: (\" << d2x << \", \" << d2y << \"), m2: :(\" << m2x << \", \" << m2y << \")\" << endl;\n\n        double a = d1x, b = -d2x, c = m2x - m1x;\n        double d = d1y, e = -d2y, f = m2y - m1y;\n\n        // cerr << \"    a: \" << a << \", b: \" << b << \", c: \" << c << endl;\n        // cerr << \"    d: \" << d << \", e: \" << e << \", f: \" << f << endl;\n\n        double t1 = (c * e - b * f) / (a * e - b * d);\n        double t2 = (c * d - a * f) / (b * d - a * e);\n        if(-EPS < t1 && t1 < EPS) t1 = 0;\n        if(-EPS < t2 && t2 < EPS) t2 = 0;\n\n        // cerr << \"    t1: \" << t1 << \", t2: \" << t2 << endl;\n\n        x = d1x * t1 + m1x;\n        y = d1y * t1 + m1y;\n        r = sqrt((X[i] - x) * (X[i] - x) + (Y[i] - y) * (Y[i] - y));\n      }\n\n      // cerr << \"    (x, y): (\" << x << \", \" << y << \"), r: \" << sqrt(r2) << endl;\n\n      bool ok = true;\n      REP(l, 0, N) if(s & (1LL << l)) if((X[l] - x) * (X[l] - x) + (Y[l] - y) * (Y[l] - y) > r * r) ok = false;\n      if(ok) minr = min(minr, r);\n\n      // cerr << \"    ok: \" << ok << endl;\n    }\n    radius[s] = minr;\n\n    // cerr << s << \": \" << radius[s] << endl;\n  }\n\n  REP(i, 0, N) radius[1LL << i] = 0.0;\n  REP(i, 0, N) REP(j, 0, N) radius[(1LL << i) | (1LL << j)] = sqrt(dist2(X[i], Y[i], X[j], Y[j])) / 2.0;\n  radius[0] = 0.0;\n\n  // cerr << radius[0] << endl;\n\n  vector< vector<double> > dp(1LL << N, vector<double>(M + 1, 1e20));\n  dp[0][0] = 0.0;\n  REP(i, 0, M) REP(s, 0, 1LL << N) {\n    // cerr << s << \", \" << i << \": \" << dp[s][i] << endl;\n    ll sup = 0;\n    REP(j, 0, N) if(!(s & (1LL << j))) sup = sup | (1LL << j);\n\n    ll sub = sup;\n    do {\n      dp[s | sub][i + 1] = min(dp[s | sub][i + 1], max(dp[s][i], radius[sub]));\n      sub = (sub - 1) & sup;\n    } while(sub != sup);\n  }\n\n  double ans = 1e20;\n  REP(i, 0, M + 1) ans = min(ans, dp[(1LL << N) - 1][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nPS = [list(map(int, input().split())) for i in range(N)]\nfrom itertools import combinations\nfrom math import sqrt\n\ndef dist(p):\n    x, y = p\n    return x**2 + y**2\ndef dist2(p, q):\n    x0, y0 = p; x1, y1 = q\n    return (x0 - x1)**2 + (y0 - y1)**2\ndef cross(p0, p1):\n    x0, y0 = p0; x1, y1 = p1\n    return x0*y1 - x1*y0\nmemo = {}\nEPS = 1e-8\nALL = 2**N-1\ndef dfs(state, cnt):\n    key = (state, cnt)\n    if key in memo:\n        return memo[key]\n    if state == ALL:\n        return 0.\n    if cnt == 0:\n        return 1e18\n    res = 0.\n    P = []\n    for i in range(N):\n        if not (state >> i) & 1:\n            P.append(i)\n    l = len(P)\n    if l <= cnt:\n        return 0.\n    if l == 2:\n        return dist2(PS[P[0]], PS[P[1]])\n    res = 1e18\n    for i, j in combinations(P, 2):\n        p0 = x0, y0 = PS[i]\n        p1 = x1, y1 = PS[j]\n        a = (x0+x1)/2; b = (y0+y1)/2; r = ((x0 - x1)/2)**2 + ((y0 - y1)/2)**2\n        cont = 0\n        for l in P:\n            x, y = PS[l]\n            if (x-a)**2 + (y-b)**2 <= r + EPS:\n                cont |= 1 << l\n        res = min(res, max(r, dfs(state | cont, cnt-1)))\n    for p in combinations(P, 3):\n        i, j, k = p\n        det = cross(PS[i], PS[j]) + cross(PS[j], PS[k]) + cross(PS[k], PS[i])\n        if det == 0:\n            continue\n        D0 = -dist(PS[i]); D1 = -dist(PS[j]); D2 = -dist(PS[k])\n        R = []\n        for l in [0, -1, 1]:\n            p0 = x0, y0 = PS[p[l]]\n            p1 = x1, y1 = PS[p[l+1]]\n            R.append((y0-y1)*D0 - (x0-x1)*D1 + cross(p0, p1)*D2)\n        a, b, c = R\n        cont = 0\n        r = -c-(a/2)**2-(b/2)**2\n        for l in P:\n            x, y = PS[l]\n            if (x+a/2)**2 + (y+b/2)**2 <= r + EPS:\n                cont |= 1 << l\n        res = min(res, max(r, dfs(state | cont, cnt-1)))\n    memo[key] = res\n    return res\nprint(\"%.09f\" % sqrt(dfs(0, M)))\n\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nPS = [list(map(int, input().split())) for i in range(N)]\nfrom itertools import combinations\nfrom math import sqrt\n\ndef dist(p):\n    x, y = p\n    return x**2 + y**2\ndef dist2(p, q):\n    x0, y0 = p; x1, y1 = q\n    return (x0 - x1)**2 + (y0 - y1)**2\ndef cross(p0, p1):\n    x0, y0 = p0; x1, y1 = p1\n    return x0*y1 - x1*y0\nmemo = {}\nEPS = 1e-8\nALL = 2**N-1\ndef dfs(state, cnt):\n    key = (state, cnt)\n    if key in memo:\n        return memo[key]\n    if state == ALL:\n        return 0.\n    if cnt == 0:\n        return 1e18\n    P = []\n    for i in range(N):\n        if not (state >> i) & 1:\n            P.append(i)\n    l = len(P)\n    if l <= cnt:\n        return 0.\n    if l == 2:\n        return dist2(PS[P[0]], PS[P[1]])/4.\n    res = 1e18\n    for i, j in combinations(P, 2):\n        p0 = x0, y0 = PS[i]\n        p1 = x1, y1 = PS[j]\n        #a = (x0+x1)/2; b = (y0+y1)/2; r = ((x0 - x1)/2)**2 + ((y0 - y1)/2)**2\n        a2 = x0+x1; b2 = y0+y1; r4 = (x0 - x1)**2 + (y0 - y1)**2\n        cont = 0\n        for l in P:\n            x, y = PS[l]\n            #if (x-a)**2 + (y-b)**2 <= r + EPS:\n            if (2*x-a2)**2 + (2*y-b2)**2 <= r4:\n                cont |= 1 << l\n        res = min(res, max(r4/4., dfs(state | cont, cnt-1)))\n    for p in combinations(P, 3):\n        i, j, k = p\n        det = cross(PS[i], PS[j]) + cross(PS[j], PS[k]) + cross(PS[k], PS[i])\n        if det == 0:\n            continue\n        D0 = -dist(PS[i]); D1 = -dist(PS[j]); D2 = -dist(PS[k])\n        R = []\n        for l in [0, -1, 1]:\n            p0 = x0, y0 = PS[p[l]]\n            p1 = x1, y1 = PS[p[l+1]]\n            R.append((y0-y1)*D0 - (x0-x1)*D1 + cross(p0, p1)*D2)\n        a, b, c = R\n        cont = 0\n        #r = -c-(a/2)**2-(b/2)**2\n        r4 = -4*c-a**2-b**2\n        for l in P:\n            x, y = PS[l]\n            #if (x+a/2)**2 + (y+b/2)**2 <= r + EPS:\n            if (2*x+a)**2 + (2*y+b)**2 <= r4:\n                cont |= 1 << l\n        res = min(res, max(r4/4., dfs(state | cont, cnt-1)))\n    memo[key] = res\n    return res\nprint(\"%.09f\" % sqrt(dfs(0, M)))\n\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nPS = [list(map(int, input().split())) for i in range(N)]\nfrom itertools import combinations\nfrom math import sqrt\n\ndef dist(p):\n    x, y = p\n    return x**2 + y**2\ndef dist2(p, q):\n    x0, y0 = p; x1, y1 = q\n    return (x0 - x1)**2 + (y0 - y1)**2\ndef cross(p0, p1):\n    x0, y0 = p0; x1, y1 = p1\n    return x0*y1 - x1*y0\nmemo = {}\nEPS = 1e-8\nALL = 2**N-1\ndef dfs(state, cnt):\n    key = (state, cnt)\n    if key in memo:\n        return memo[key]\n    if state == ALL:\n        return 0.\n    if cnt == 0:\n        return 1e18\n    res = 0.\n    P = []\n    for i in range(N):\n        if not (state >> i) & 1:\n            P.append(i)\n    l = len(P)\n    if l <= cnt:\n        return 0.\n    if l == 2:\n        return dist2(PS[P[0]], PS[P[1]])\n    res = 1e18\n    for i, j in combinations(P, 2):\n        p0 = x0, y0 = PS[i]\n        p1 = x1, y1 = PS[j]\n        a = (x0+x1)/2; b = (y0+y1)/2; r = ((x0 - x1)/2)**2 + ((y0 - y1)/2)**2\n        cont = 0\n        for l in P:\n            x, y = PS[l]\n            if (x-a)**2 + (y-b)**2 <= r + EPS:\n                cont |= 1 << l\n        res = min(res, max(r, dfs(state | cont, cnt-1)))\n    for p in combinations(P, 3):\n        i, j, k = p\n        det = cross(PS[i], PS[j]) + cross(PS[j], PS[k]) + cross(PS[k], PS[i])\n        if det == 0:\n            continue\n        D0 = -dist(PS[i]); D1 = -dist(PS[j]); D2 = -dist(PS[k])\n        R = []\n        for l in [0, -1, 1]:\n            p0 = x0, y0 = PS[p[l]]\n            p1 = x1, y1 = PS[p[l+1]]\n            R.append((y0-y1)*D0 - (x0-x1)*D1 + cross(p0, p1)*D2)\n        a, b, c = R\n        cont = 0\n        r = -c-(a/2)**2-(b/2)**4\n        for l in P:\n            x, y = PS[l]\n            if (x+a/2)**2 + (y+b/2)**2 <= r + EPS:\n                cont |= 1 << l\n        res = min(res, max(r, dfs(state | cont, cnt-1)))\n    memo[key] = res\n    return res\nprint(sqrt(dfs(0, M)))\n\n"
  }
]