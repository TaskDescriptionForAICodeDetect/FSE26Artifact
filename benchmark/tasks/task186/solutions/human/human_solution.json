[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n// max=6*9 * 10*10\nusing namespace std;\n\ntypedef struct {\n  int x,y,p,m ; // ÂÃÂÂ®ÂÃ£ÂÃÂ}ÂXÂAÂyÂiÂÂÂeÂB, ÂÃ\n} State;\n\nint main(){\n  int h,w,x,y;\n  int g[10][10];\n  int sx,sy, gx,gy;\n  int dx[4] = { 0,1,0,-1 };  // ÂÃ£ÂAÂEÂAÂÂºÂAÂÂ¶\n  int dy[4] = { -1,0,1,0 };\n  int dice[7][4] = // 1,2,... ÂÂªÂÃ£ÂÃÂÂ ÂÃ©ÂÂÂÃÂÂ¡ÂÃÂÂÂÂ\n    {\n      { 0,0,0,0 },\n      { 2,4,5,3 }, { 6,4,1,3 },\n      { 2,1,5,6 }, { 2,6,5,1 },\n      { 1,4,6,3 }, { 2,3,5,4 }\n    };\n  queue<State> q;\n  State st, st2;\n  unsigned int flag[10][10];\n  unsigned int min;\n\n  while( cin>>h>>w && ( h||w ) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++)\n\tcin >> g[i][j];\n    cin >> sy>>sx>> gy>>gx;\n\n    /*\n    cout << \"h=\"<<h<<\" w=\"<<w<<endl;\n    cout << \"start=(\"<<sx<<\",\"<<sy<<\") goal=(\"<<gx<<\",\"<<gy<<\")\"<<endl;\n    */\n    st.x=sx; st.y=sy; st.p=0; st.m=1;\n    q.push( st );\n\n\n    memset( flag,-1,sizeof(flag) );\n    min = flag[0][0];\n\n    //    int loop=0;\n\n    while( q.size()>0 ){\n      st = q.front(); q.pop();\n\n      /******\n      cout << \"size=\"<<q.size()<<\" min=\"<<min\n\t   <<\" x=\"<<st.x<<\" y=\"<<st.y\n\t   <<\" p=\"<<st.p<<\" m=\"<<st.m   <<endl;\n      if( loop++>10 )\n\tbreak;\n      /*******/\n\n      if( st.p>min )\n\tcontinue;\n      \n      if( flag[st.y][st.x]> st.p ){\n\tflag[st.y][st.x] = st.p;\n      }\n      if( flag[st.y][st.x] < st.p )\n\tcontinue;\n\n\n      if( (st.x==gx) && (st.y==gy) ){ // goal\n\t//\tcout << \"goal\" << endl;\n\tif( min>st.p )\n\t  min=st.p;\n\tcontinue;\n      }\n\n      for( int i=0;i<4;i++ ){\n\n\tx=st.x+dx[i]; y=st.y+dy[i];\n\t// gx,gy ÂÃ»ÂÃ¼ÂÃÂtÂÃ»ÂÃ¼ÂÃÂiÂÃ±ÂÃÂÃÂÂ¢ÂÂ©ÂmÂF\n\t/*\n\tif( abs(st.x-gx) < abs( x-gx ) ||\n\t    abs(st.y-gy) < abs( y-gy ) ){\n\t  //\t  cout << \" %%\"<<endl;\n\t  continue;\n\t}\n\t*/\n\n\tif( 0<=x && x<w && 0<=y && y<h ){\n\t  st2.x=x; st2.y=y;\n\t  st2.p= st.p + g[y][x] * (7-dice[st.m][i]);\n\t  st2.m = dice[st.m][i];\n\t  q.push( st2 );\n\t}\n      }\n    }\n    cout << min << endl;\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint face[6];\n} DICE;\n\ntypedef struct {\n\tint cost;\n\tint x, y;\n\tDICE dice;\n} DATA;\n\n#define NORTH\t\t(0)\n#define SOUTH\t\t(1)\n#define EAST\t    (2)\n#define WEST\t\t(3)\n\nbool operator<(const DATA& a, const DATA& b)\n{\n\treturn (a.cost > b.cost);\n}\n\npriority_queue<DATA> pq;\n\nvoid rote(int dir, const DICE& in, DICE* out)\n{\n\tswitch (dir)\n\t{\n\t  case NORTH:\n\t  \tout->face[0] = in.face[1];\n\t\tout->face[1] = in.face[2];\n\t\tout->face[2] = in.face[3];\n\t\tout->face[3] = in.face[0];\n\t\tout->face[4] = in.face[4];\n\t\tout->face[5] = in.face[5];\n\t\tbreak;\n\t  case SOUTH:\n\t  \tout->face[0] = in.face[3];\n\t\tout->face[1] = in.face[0];\n\t\tout->face[2] = in.face[1];\n\t\tout->face[3] = in.face[2];\n\t\tout->face[4] = in.face[4];\n\t\tout->face[5] = in.face[5];\n\t\tbreak;\n\t  case EAST:\n\t  \tout->face[0] = in.face[5];\n\t\tout->face[1] = in.face[1];\n\t\tout->face[2] = in.face[4];\n\t\tout->face[3] = in.face[3];\n\t\tout->face[4] = in.face[0];\n\t\tout->face[5] = in.face[2];\n\t\tbreak;\n\t  case WEST:\n\t  \tout->face[0] = in.face[4];\n\t\tout->face[1] = in.face[1];\n\t\tout->face[2] = in.face[5];\n\t\tout->face[3] = in.face[3];\n\t\tout->face[4] = in.face[2];\n\t\tout->face[5] = in.face[0];\n\t\tbreak;\n\t}\n}\n\nint main(void)\n{\n\tDATA add;\n\tint field[12][12];\n\tint h, w;\n\tint sx, sy;\n\tint gx, gy;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &h, &w);\n\t\t\n\t\tif (!h)break;\n\t\t\n\t\twhile (!pq.empty()){\n\t\t\tpq.pop();\n\t\t}\n\t\tmemset(field, -1, sizeof(field));\n\t\tfor (int y = 1; y <= h; y++){\n\t\t\tfor (int x = 1; x <= w; x++){\n\t\t\t\tscanf(\"%d\", &field[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &sy, &sx);\n\t\tscanf(\"%d%d\", &gy, &gx);\n\t\t\n\t\tadd.x = sx + 1;\n\t\tadd.y = sy + 1;\n\t\tadd.cost = 0;\n\t\tadd.dice.face[0] = 1;\n\t\tadd.dice.face[1] = 2;\n\t\tadd.dice.face[2] = 6;\n\t\tadd.dice.face[3] = 5;\n\t\tadd.dice.face[4] = 3;\n\t\tadd.dice.face[5] = 4;\n\t\t\n\t\tpq.push(add);\n\t\t\n\t\twhile (!pq.empty()){\n\t\t\tconst DATA &d = pq.top();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (d.x == gx + 1 && d.y == gy + 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd.x = d.x;\n\t\t\tadd.y = d.y - 1;\n\t\t\trote(NORTH, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x;\n\t\t\tadd.y = d.y + 1;\n\t\t\trote(SOUTH, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x + 1;\n\t\t\tadd.y = d.y;\n\t\t\trote(EAST, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x - 1;\n\t\t\tadd.y = d.y;\n\t\t\trote(WEST, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\t\n\t\t\tpq.pop();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", pq.top().cost);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Cost first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  Dice d;\n  int y, x;\n\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State& right) const{\n    return y == right.y ? x < right.x : y < right.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<pair<int, State>, vector<pair<int, State> >, greater<pair<int, State> > > q;\n    q.push(MP(0, s));\n    map<pi, int> m;\n    m[MP(sy, sx)] = 0;\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      //      printf(\"qsize %d\\n\", qsize);\n      rep(i, qsize){\n\tpair<int, State> now = q.top(); q.pop();\n\trep(d, 4){\n\t  pair<int , State> next = now;\n\t  next.S.y += dy[d]; next.S.x += dx[d];\n\t  int ny = next.S.y, nx = next.S.x;\n\t  if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\t  int tmp;\n\t  switch(d){\n\t  case 0: // west\n\t    tmp = 7 - next.S.d.t;\n\t    next.S.d.t = next.S.d.e;\n\t    next.S.d.e = tmp;\n\t    break;\n\t  case 1: // north\n\t    tmp = 7 - next.S.d.t;\n\t    next.S.d.t = next.S.d.s;\n\t    next.S.d.s = tmp;\n\t    break;\n\t  case 2: // south\n\t    tmp = 7 - next.S.d.e;\n\t    next.S.d.e = next.S.d.t;\n\t    next.S.d.t = tmp;\n\t    break;\n\t  case 3: // east\n\t    tmp = 7 - next.S.d.s;\n\t    next.S.d.s = next.S.d.t;\n\t    next.S.d.t = tmp;\n\t    break;\n\t  }\n\n\t  next.Cost += cost[ny][nx] * (7 - next.S.d.t);\n\t  if(m.count(MP(ny, nx)) != 0  && m[MP(ny,nx)] <= next.Cost) continue;\n\t  m[MP(ny,nx)] = next.Cost;\n\t  //\t  printf(\"%d %d\\n\", ny, nx);\n\t  if(ny == gy && nx == gx){\n\t    res = min(res, next.Cost);\n\t    break;\n\t  }\n\t  q.push(next);\n\t}\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n\n#define N 16\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define DIRMAX 4\n\nusing namespace std;\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst int infty = (1LL<<31)-1;\n\nstruct Dice{\n  int D[6];\n  Dice(){D[5]=1;D[1]=2;D[2]=3;decide();}\n  void decide(){D[0]=7-D[5];D[3]=7-D[1];D[4]=7-D[2];}\n  void roll(int dir){\n    switch(dir){\n    case NORTH:D[5]=D[1];D[1]=D[0];break;\n    case EAST: D[2]=D[5];D[5]=D[4];break;\n    case SOUTH:D[1]=D[5];D[5]=D[3];break;\n    case WEST: D[5]=D[2];D[2]=D[0];break;\n    }\n    decide();\n  }\n};\n\nstruct State{\n  Dice c;\n  int i,j;\n  int cost;\n  bool operator>(const State &t)const{\n    return cost > t.cost; \n  }\n};\n\ninline bool isinside(int i, int j, int h, int w){\n  return 0<=i&&i<h&&0<=j&&j<w;\n}\n\nint dijkstra(int h, int w, int M[][N],\n\t     int si, int sj, int gi, int gj){\n  State init;\n  int A[N][N];\n  bool vis[N][N];\n  priority_queue<State,vector<State>,greater<State> > qs;\n  init.cost=0;\n  init.i=si;\n  init.j=sj;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      vis[i][j] = false;\n      A[i][j] = infty;\n    }\n  }\n  \n  qs.push( init );\n  while(!qs.empty()){\n    State now = qs.top();\n    qs.pop();\n\n    //if( vis[now.i][now.j] ) continue;\n    vis[now.i][now.j] = false;\n\n    for(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n      State next = now;\n      next.i = now.i + di[k];\n      next.j = now.j + dj[k];\n      next.c.roll( k );\n      if( !isinside(next.i, next.j, h, w ) ) continue;\n      next.cost += next.c.D[0] * M[next.i][next.j];\n      if( next.cost < A[next.i][next.j] ){\n\tA[next.i][next.j] = next.cost;\n\tif( !vis[next.i][next.j] ){\n\t  vis[now.i][now.j]=true;\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  return A[gi][gj];\n}\n\nint main()\n{\n  while(true){\n    int h,w;\n    int M[N][N];\n    cin >> h >> w;\n    if( h == 0 && w == 0 ) break;\n    \n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    int si,sj,gi,gj;cin >> si >> sj >> gi >> gj;\n    cout << dijkstra(h,w,M,si,sj,gi,gj) << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nvoid R(int&a,int&b,int&c,int&d){int t=a;a=b,b=c,c=d,d=t;}\nstruct S{int n,e,s,w,u,d,p,x,y;bool operator<(const S&r)const{return p>r.p;}};\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint S::*r[4][2]={\n\t{&S::e,&S::w},\n\t{&S::s,&S::n},\n\t{&S::w,&S::e},\n\t{&S::n,&S::s},\n};\nint main()\n{\n\tint h,w,a[10][10],sx,sy,gx,gy,i,j;\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\tfor(i=0;i<h;++i)for(j=0;j<w;++j)scanf(\"%d\",&a[i][j]);\n\t\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\t\tstd::priority_queue<S>q;\n\t\tS s={5,3,2,4,1,6,0,sx,sy};\n\t\tq.push(s);\n\t\tbool f[10][10][7][7]={0};\n\t\tfor(;;)\n\t\t{\n\t\t\ts=q.top();q.pop();\n\t\t\tif(s.x==gx&&s.y==gy){printf(\"%d\\n\",s.p);break;}\n\t\t\tif(f[s.y][s.x][s.n][s.s]++)continue;\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tS t=s;\n\t\t\t\tt.x+=dx[i];t.y+=dy[i];\n\t\t\t\tif(t.x<0||t.y<0||t.x>=w||t.y>=h)continue;\n\t\t\t\tR(t.d,t.*r[i][0],t.u,t.*r[i][1]);\n\t\t\t\tt.p+=a[t.y][t.x]*t.d;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\ntypedef tuple<int,int,int,int,int,int> T;//<cost,A,B,C,y,x>\n#define INF 1e8\n\nint main(){\n    int h,w;\n    int map[10][10];//[y][x]\n    int minimum[6][6][6][10][10];//[テ、ツクツ甘ゥツ敖「テ」ツ?ョテァツ崢ョ][テ・ツ債療・ツ青妥」ツ?江[テヲツ敖アテ・ツ青妥」ツ?江[][y][x]\n    priority_queue<T,vector<T>,greater<T>> que;\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>map[i][j];\n            }\n        }\n        int start_y,start_x,end_y,end_x;\n        cin>>start_y>>start_x>>end_y>>end_x;\n        while(!que.empty())que.pop();\n        que.push(T(0,1,2,3,start_y,start_x));\n        fill(minimum[0][0][0][0],minimum[6][0][0][0],INF);\n        while(!que.empty()){\n            T t = que.top(); que.pop();\n            int cost=get<0>(t), A=get<1>(t),B=get<2>(t),C=get<3>(t), y=get<4>(t), x=get<5>(t);\n            if(cost>minimum[A-1][B-1][C-1][y][x]) continue;\n            int penalty;\n            //テ・ツ個?\n            if(y){\n                int newA=B,newB=7-A,newC=C;\n                penalty=cost+(7-newA)*map[y-1][x];\n                if(penalty<minimum[newA-1][newB-1][newC-1][y-1][x]){\n                    minimum[newA-1][newB-1][newC-1][y-1][x]=penalty;\n                    que.emplace(penalty,newA,newB,newC,y-1,x);\n                }\n            }\n            //テ・ツ債?\n            if(y!=h-1){\n                int newA=7-B,newB=A,newC=C;\n                penalty=cost+(7-newA)*map[y+1][x];\n                if(penalty<minimum[newA-1][newB-1][newC-1][y+1][x]){\n                    minimum[newA-1][newB-1][newC-1][y+1][x]=penalty;\n                    que.emplace(penalty,newA,newB,newC,y+1,x);\n                }\n            }\n            //テヲツ敖ア\n            if(x!=w-1){\n                int newA=7-C,newB=B,newC=A;\n                penalty=cost+(7-newA)*map[y][x+1];\n                if(penalty<minimum[newA-1][newB-1][newC-1][y][x+1]){\n                    minimum[newA-1][newB-1][newC-1][y][x+1]=penalty;\n                    que.emplace(penalty,newA,newB,newC,y,x+1);\n                }\n            }\n            //ティツ・ツソ\n            if(x){\n                int newA=C,newB=B,newC=7-A;\n                penalty=cost+(7-newA)*map[y][x-1];\n                if(penalty<minimum[newA-1][newB-1][newC-1][y][x-1]){\n                    minimum[newA-1][newB-1][newC-1][y][x-1]=penalty;\n                    que.emplace(penalty,newA,newB,newC,y,x-1);\n                }\n            }\n        }\n        int ans=INF;\n        for(int i=0;i<6;i++)for(int j=0;j<6;j++)for(int k=0;k<6;k++)ans=min(ans,minimum[i][j][k][end_y][end_x]);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * File:   main.cpp\n * Author: administrator\n *\n * Created on 2011å¹´8æ27æ¥, ä¸å2:23\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <string>\n#include <map>\n#include <set>\n#include <math.h>\n#include <queue>\n#define M 15\nusing namespace std;\n\nstruct node {\n    int x, y, bottom, east;\n    long long value;\n} s, p;\nqueue<node>Q;\nint mark[M][M][M][M];\nlong long dis[M][M][M][M];\nint value[M][M];\nint n, m;\nint sx, sy, ex, ey;\nlong long oo = 100000000000000LL;\nint add[7][5] = {\n    {0},\n    {5, 4, 2, 3},\n    {3, 1, 4, 6},\n    {2, 6, 5, 1},\n    {5, 6, 2, 1},\n    {6, 4, 1, 3},\n    {3, 2, 4, 5}\n};\n\nint gcd(int x, int y) {\n    while (y) {\n        int t = x % y;\n        x = y;\n        y = t;\n    }\n    return x;\n}\n\nint LCM(int x, int y) {\n    return x*y;\n    int t = gcd(x, y);\n    return x / t*y;\n}\n\nvoid checkIn(int &H) {\n    if (dis[s.x][s.y][s.bottom][s.east] > s.value) {\n        dis[s.x][s.y][s.bottom][s.east] = s.value;\n        if (s.x == ex && s.y == ey)return;\n        if (!mark[s.x][s.y][s.bottom][s.east]) {\n            mark[s.x][s.y][s.bottom][s.east] = 1;\n            //Q[H++] = s;\n            Q.push(s);\n        }\n    }\n}\n\nint find(int e, int b, int k) {\n    int i;\n    for (i = 0; i < 4; i++)\n        if (add[e][i] == b) {\n            return add[e][(i + k + 4) % 4];\n        }\n}\n\nvoid SPFA() {\n    int i, j, k, x, y, bottom, east;\n    int L, H;\n    for (x = 0; x < n; x++)\n        for (y = 0; y < m; y++)\n            for (i = 1; i <= 6; i++)\n                for (j = 1; j <= 6; j++) {\n                    dis[x][y][i][j] = oo;\n                    mark[x][y][i][j] = 0;\n                }\n    dis[sx][sy][6][3] = 0;\n    s.x = sx, s.y = sy, s.bottom = 6, s.east = 3, s.value = 0;\n    mark[s.x][s.y][s.bottom][s.east] = 1;\n    L = H = 0;\n    while (!Q.empty())Q.pop();\n    //Q[H++] = s;\n    Q.push(s);\n    while (!Q.empty()) {\n        //p = Q[L++];\n        p = Q.front();\n        Q.pop();\n        mark[p.x][p.y][p.bottom][p.east] = 0;\n        x = p.x, y = p.y;\n        if (x > 0) {//up\n            s.x = p.x - 1;\n            s.y = p.y;\n            s.bottom = find(p.east, p.bottom, 1);\n            s.east = p.east;\n            s.value = p.value + LCM(value[s.x][s.y], s.bottom);\n            checkIn(H);\n        }\n        if (x < n - 1) {//down\n            s.x = p.x + 1;\n            s.y = p.y;\n            s.bottom = find(p.east, p.bottom, -1);\n            s.east = p.east;\n            s.value = p.value + LCM(value[s.x][s.y], s.bottom);\n            checkIn(H);\n        }\n        if (y > 0) {//left\n            s.x = p.x;\n            s.y = p.y - 1;\n            s.bottom = 7 - p.east;\n            s.east = p.bottom;\n            s.value = p.value + LCM(value[s.x][s.y], s.bottom);\n            checkIn(H);\n        }\n        if (y < m - 1) {//right\n            s.x = p.x;\n            s.y = p.y + 1;\n            s.bottom = p.east;\n            s.east = 7 - p.bottom;\n            s.value = p.value + LCM(value[s.x][s.y], s.bottom);\n            checkIn(H);\n        }\n    }\n}\n\nint main(int argc, char** argv) {\n    int i, j, k;\n    while (scanf(\"%d %d\", &n, &m), n | m) {\n        for (i = 0; i < n; i++)\n            for (j = 0; j < m; j++)\n                scanf(\"%d\", &value[i][j]);\n        scanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n        SPFA();\n        long long ans = oo;\n        for (i = 1; i <= 6; i++)\n            for (j = 1; j <= 6; j++)\n                if (dis[ex][ey][i][j] < ans)\n                    ans = dis[ex][ey][i][j];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost > s.cost;\n    }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<pi, int> m;\n    m[MP(sy, sx)] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx) res = min(res, now.cost);\n\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\tif(m.count(MP(ny, nx)) != 0  && m[MP(ny,nx)] <= next.cost) continue;\n\tm[MP(ny,nx)] = next.cost;\n\t//\t  printf(\"%d %d\\n\", ny, nx);\n\t/*\t  if(ny == gy && nx == gx){\n\t\t  res = min(res, next.cost);\n\t\t  break;\n\t\t  }*/\n\tq.push(next);\n      }\n    }\n    printf(\"%d\\n\", res==INF?0:res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <ctime>\nusing namespace std;\n\nint H[6][6] = {\n    {1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n    {3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n    {2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n    {4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n    {0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n    {0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[4] = {0,1,-1,0};\nint dy[4] = {-1,0,0,1};\n\n// サイコロライブラリ\n// d[0] := top,   d[1] := front \n// d[2] := right, d[3] := left\n// d[4] := back,  d[5] := bottom\nenum{TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\nstruct Cube{\n    vector<int> d;\n    // コンストラクタで初期化\n    Cube(vector<int> v){\n        if( v.size() == 6 )\n            d = v;\n        else\n            d = vector<int>(6);\n    }\n    Cube(){ d = vector<int>(6); }\n    // dirの方向に回転 (副作用なし)\n    Cube roll(int dir) const {\n        vector<int> d_(6);\n        for(int i = 0 ; i < 6 ; i++ ){\n            d_[i] = d[ H[dir][i] ];\n        }\n        return Cube(d_);\n    }\n};\n// Cube の順序を定義 (map<Cube,T> を使いたいとき用)\nbool operator<(const Cube& a, const Cube& b){\n    if( a.d[0] == b.d[0] )\n        return a.d[1] < b.d[1];\n    return a.d[0] < b.d[0];\n}\n\nconst int INF = 1e+8;\nint m[10][10];\nint w, h, sx, sy, gx, gy;\n// d[y][x][top][front] := (x,y) にサイコロの上面がtop, 正面がfrontだったときの最小コスト\nint d[10][10][10][10];\n\nstruct State{\n\tCube c;\n\tint x, y, cost;\n\tState(){}\n\tState(Cube c_, int x_, int y_, int cost_){\n\t\tc = c_; x = x_; y = y_; cost = cost_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\nint solve(){\n\t// 初期化\n\tfor(int y=0 ; y < 10 ; y++ ){\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\tfor(int i=0 ; i < 10 ; i++ ){\n\t\t\t\tfill(d[y][x][i], d[y][x][i]+10, INF);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> v(6);\n\tfor(int i=0 ; i < 6 ; i++ ){\n\t\tv[i] = i+1;\n\t}\n\td[sy][sx][1][2] = 0;\n\tpriority_queue<State> q;\n\tq.push( State(Cube(v), sx, sy, 0) );\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint x = q.top().x;\n\t\tint y = q.top().y;\n\t\tint cost = q.top().cost;\n\t\tCube c = q.top().c;\n\t\tq.pop();\n\t\t\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tCube next = c.roll(i);\n\t\t\tint next_cost = cost + next.d[BOTTOM] * m[my][mx];\n\t\t\tint top = next.d[TOP];\n\t\t\tint front = next.d[FRONT];\n\t\t\tif( next_cost < d[my][mx][top][front] ){\n\t\t\t\td[my][mx][top][front] = next_cost;\n\t\t\t\tq.push( State(next, mx, my, next_cost) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> h >> w , h || w ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[40][40];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;\n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n    RollMe(i);\n    if(/*!used[ny][nx] &&*/ 0<=nx && nx<w && 0<=ny && ny <h && dpused[ny][nx] >= sam+imap[ny][nx]*dice[5]){\n      //used[ny][nx] = true;\n      //RollMe(i);\n\tdpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));\n      //used[ny][nx] = false;\n    }\n      RollMe(Reverse(i));\n  }\n}\n\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\tdpused[i][j] = INF;\n      }\n    //used[s.S][s.F] = true;\n    dpused[s.S][s.F] = 0;\n    rec(s,0);\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint rol[4][4]={\n\t{4,5,2,0},\n\t{1,0,3,5},\n\t{0,2,5,4},\n\t{5,3,0,1}\n};\nvi a;\nvoid roll(int b){\n\tint tmp=a[2+rol[b][0]];\n\trep(i,3)a[2+rol[b][i]]=a[2+rol[b][i+1]];\n\ta[2+rol[b][3]]=tmp;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(m));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\tint sx,sy,gx,gy;\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tvi q(8);\n\t\tq[0]=sx;q[1]=sy;q[2]=1;q[3]=2;\n\t\tq[4]=3;q[5]=5;q[6]=4;q[7]=6;\n\t\tmap<vi,int>ma;\n\t\tint out=inf;\n\t\tqueue<pair<vi,int> >que;\n\t\tque.push(pair<vi,int>(q,0));\n\t\twhile(!que.empty()){\n\t\t\tvi w=que.front().first;\n\t\t\tint t=que.front().second;\n\t\t\tque.pop();\n\t\t\tif(ma[w]<t)continue;\n\t\t\trep(i,4){\n\t\t\t\ta=w;\n\t\t\t\ta[0]+=dx[i];\n\t\t\t\ta[1]+=dy[i];\n\t\t\t\tif(a[0]<0||a[1]<0||a[0]>=n||a[1]>=m)continue;\n\t\t\t\troll(i);\n\t\t\t\tint cost=t+a[7]*in[a[0]][a[1]];\n\t\t\t\tif(ma[a]==0||ma[a]>cost){\n\t\t\t\t\tma[a]=cost;\n\t\t\t\t\tque.push(pair<vi,int>(a,cost));\n\t\t\t\t\tif(a[0]==gx&&a[1]==gy)out=min(out,cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass Dice\n{\nprivate:\n  /*\n    pip[0] = top, pip[1] = south, pip[2] = east\n    pip[3] = bottom, pip[4] = north, pip[5] = west\n  */\n  int pip[6];\npublic:\n  enum { TOP, SOUTH, EAST, BOTTOM, NORTH, WEST };\n\n  Dice(int top = 1, int south = 2, int east = 3)\n  {\n    pip[TOP] = top;\n    pip[SOUTH] = south;\n    pip[EAST] = east;\n    pip[BOTTOM] = 7 - top;\n    pip[NORTH] = 7 - south;\n    pip[WEST] = 7 - east;\n  }\n\n  // east:+, west:-\n  void rotateX(int r)\n  {\n    while (r < 0)\n      r += 4;\n    r %= 4;\n    for (int i = 0; i < r; ++i) {\n      int tmp = pip[TOP];\n      pip[TOP] = pip[WEST];\n      pip[WEST] = pip[BOTTOM];\n      pip[BOTTOM] = pip[EAST];\n      pip[EAST] = tmp;\n    }\n  }\n\n  // south:+, north:-\n  void rotateY(int r)\n  {\n    while (r < 0)\n      r += 4;\n    r %= 4;\n    for (int i = 0; i < r; ++i) {\n      int tmp = pip[TOP];\n      pip[TOP] = pip[NORTH];\n      pip[NORTH] = pip[BOTTOM];\n      pip[BOTTOM] = pip[SOUTH];\n      pip[SOUTH] = tmp;\n    }\n  }\n \n  int get(int p) const\n  {\n    return pip[p];\n  } \n};\n\nclass State\n{\npublic:\n  int x, y, cost;\n  Dice dice;\n  State(int _x = 0, int _y = 0, int _cost)\n    :x(_x), y(_y), cost(_cost) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint main()\n{\n  int h, w;\n  while (cin >> h >> w) {\n    if ((h|w) == 0)\n      break;\n\n    vector<vector<int> > mass(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j)\n\tcin >> mass[i][j];\n    }\n\n    int sx, sy, gx, gy;\n    cin >> sy >> sx >> gy >> gx;\n\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0));\n    int dp[10][10][6][6][6]; // dp[y][x][top][south][east]\n    for (int y = 0; y < 10; ++y)\n      for (int x = 0; x < 10; ++x)\n\tfor (int t = 0; t < 6; ++t)\n\t  for (int s = 0; s < 6; ++s)\n\t    for (int e = 0; e < 6; ++e)\n\t      dp[y][x][t][s][e] = INF;\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.x == gx && st.y == gy) {\n\tcout << st.cost << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.x][st.dice.get(Dice::TOP)][st.dice.get(Dice::SOUTH)][st.dice.get(Dice::EAST)] < st.cost)\n\tcontinue;\n\n      dp[st.y][st.x][st.dice.get(Dice::TOP)][st.dice.get(Dice::SOUTH)][st.dice.get(Dice::EAST)] = st.cost;\n      for (int d = 0; d < 4; ++d) {\n\tint x = st.x + dx[d];\n\tint y = st.y + dy[d];\n\tif (x < 0 || w <= x || y < 0 || h <= y)\n\t  continue;\n\n\tDice dice = st.dice;\n\tif (dx[d] != 0)\n\t  dice.rotateX(dx[d]);\n\telse\n\t  dice.rotateY(dy[d]);\n\n\tint cost = st.cost + mass[y][x] * dice.get(Dice::BOTTOM);\n\tif (dp[y][x][dice.get(Dice::TOP)][dice.get(Dice::SOUTH)][dice.get(Dice::EAST)] > cost) {\n\t  dp[y][x][dice.get(Dice::TOP)][dice.get(Dice::SOUTH)][dice.get(Dice::EAST)] = cost;\n\t  State tmp(x, y, cost);\n\t  tmp.dice = dice;\n\t  que.push(tmp);\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,1,0,-1};\nint h,w;\n\nclass state{\npublic:\n  int y,x, up,n,e, cost;\n};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nint main(){\n  while(cin >> h >> w && (h|w)){\n    int a[11][11],b[11][11],gx,gy,ans=INF;\n    state u,v;\n    queue<state> Q;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> a[i][j];\n        b[i][j] = INF;\n      }\n    }\n    cin >> u.y >> u.x >> gy >> gx;\n    b[u.y][u.x] = 0;\n    u.up = 1;\n    u.n = 5;\n    u.e = 3;\n    u.cost = 0;\n    Q.push(u);\n\n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n\n      if(u.y == gy && u.x == gx){\n        ans = min(ans,u.cost);\n        continue;\n      }\n\n      for(int i=0;i<4;i++){\n        v = u;\n        v.y += dy[i];\n        v.x += dx[i];\n        if(!check(v.y,v.x)) continue;\n        if(i == 0){\n          v.up = 7 - u.n;\n          v.n = u.up;\n        } else if(i == 1){\n          v.up = 7 - u.e;\n          v.e = u.up;\n        } else if(i == 2){\n          v.up = u.n;\n          v.n = 7 - u.up;\n        } else if(i == 3){\n          v.up = u.e;\n          v.e = 7 - u.up;\n        }\n        v.cost += a[v.y][v.x] * (7 - v.up);\n        if(b[v.y][v.x] > v.cost){\n          b[v.y][v.x] = v.cost;\n          Q.push(v);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//14\n#include<iostream>\n#include<map>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct D{\n  int s[6],x,y;\n  D(){\n    for(int i=0;i<6;i++){\n      s[i]=i+1;\n    }\n  }\n  void r(int a,int b,int c,int d){\n    int t=s[a];\n    s[a]=s[b];\n    s[b]=s[c];\n    s[c]=s[d];\n    s[d]=t;\n  }\n  void dr(int p){\n    int d[][4]={{0,1,5,4},{0,4,5,1},{0,2,5,3},{0,3,5,2}};\n    int dx[]={0,0,-1,1};\n    int dy[]={-1,1,0,0};\n    r(d[p][0],d[p][1],d[p][2],d[p][3]);\n    x+=dx[p];\n    y+=dy[p];\n  }\n  bool operator<(D a)const{\n    if(x!=a.x){\n      return x<a.x;\n    }else if(y!=a.y){\n      return y<a.y;\n    }else{\n      return lexicographical_compare(s,s+6,a.s,a.s+6);\n    }\n  }\n};\n\nint main(){\n  for(int h,w;cin>>h>>w,h|w;){\n    int g[10][10];\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n      }\n    }\n    int sy,sx,gy,gx;\n    cin>>sy>>sx>>gy>>gx;\n    typedef pair<int,D> S;\n    priority_queue<S,vector<S>,greater<S> > que;\n    D is;\n    is.x=sx;\n    is.y=sy;\n    que.push(make_pair(0,is));\n    map<D,bool> p;\n    for(;;){\n      int t=que.top().first;\n      D c=que.top().second;\n      if(c.x==gx&&c.y==gy)break;\n      que.pop();\n      if(p[c]++)continue;\n      for(int i=0;i<4;i++){\n\tD n=c;\n\tn.dr(i);\n\tif(0<=n.x&&n.x<w&&0<=n.y&&n.y<h){\n\t  que.push(make_pair(t+n.s[5]*g[n.y][n.x],n));\n\t}\n      }\n    }\n    cout<<que.top().first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass Dice\n{\nprivate:\n  /*\n    pip[0] = top, pip[1] = south, pip[2] = east\n    pip[3] = bottom, pip[4] = north, pip[5] = west\n  */\n  int pip[6];\npublic:\n  enum { TOP, SOUTH, EAST, BOTTOM, NORTH, WEST };\n\n  Dice(int top = 1, int south = 2, int east = 3)\n  {\n    pip[TOP] = top;\n    pip[SOUTH] = south;\n    pip[EAST] = east;\n    pip[BOTTOM] = 7 - top;\n    pip[NORTH] = 7 - south;\n    pip[WEST] = 7 - east;\n  }\n\n  // east:+, west:-\n  void rotateX(int r)\n  {\n    if (r < 0)\n      r += 4 * (-(r/4) + 1);\n    r %= 4;\n    for (int i = 0; i < r; ++i) {\n      int tmp = pip[TOP];\n      pip[TOP] = pip[WEST];\n      pip[WEST] = pip[BOTTOM];\n      pip[BOTTOM] = pip[EAST];\n      pip[EAST] = tmp;\n    }\n  }\n\n  // south:+, north:-\n  void rotateY(int r)\n  {\n    if (r < 0)\n      r += 4 * (-(r/4) + 1);\n    r %= 4;\n    for (int i = 0; i < r; ++i) {\n      int tmp = pip[TOP];\n      pip[TOP] = pip[NORTH];\n      pip[NORTH] = pip[BOTTOM];\n      pip[BOTTOM] = pip[SOUTH];\n      pip[SOUTH] = tmp;\n    }\n  }\n \n  inline int get(int p) const\n  {\n    return pip[p];\n  } \n};\n\nclass State\n{\npublic:\n  int x, y, cost;\n  Dice dice;\n  State(int _x = 0, int _y = 0, int _cost = 0)\n    :x(_x), y(_y), cost(_cost) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint main()\n{\n  int h, w;\n  while (cin >> h >> w) {\n    if ((h|w) == 0)\n      break;\n\n    vector<vector<int> > mass(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j)\n\tcin >> mass[i][j];\n    }\n\n    int sx, sy, gx, gy;\n    cin >> sy >> sx >> gy >> gx;\n\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0));\n    int dp[10][10][6][6][6]; // dp[y][x][top][south][east]\n    for (int y = 0; y < 10; ++y)\n      for (int x = 0; x < 10; ++x)\n\tfor (int t = 0; t < 6; ++t)\n\t  for (int s = 0; s < 6; ++s)\n\t    for (int e = 0; e < 6; ++e)\n\t      dp[y][x][t][s][e] = INF;\n\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.x == gx && st.y == gy) {\n\tcout << st.cost << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.x][st.dice.get(Dice::TOP)-1][st.dice.get(Dice::SOUTH)-1][st.dice.get(Dice::EAST)-1] < st.cost)\n\tcontinue;\n\n      dp[st.y][st.x][st.dice.get(Dice::TOP)-1][st.dice.get(Dice::SOUTH)-1][st.dice.get(Dice::EAST)-1] = st.cost;\n      for (int d = 0; d < 4; ++d) {\n\tint x = st.x + dx[d];\n\tint y = st.y + dy[d];\n\tif (x < 0 || w <= x || y < 0 || h <= y)\n\t  continue;\n\n\tDice dice = st.dice;\n\tif (dx[d] != 0)\n\t  dice.rotateX(dx[d]);\n\telse\n\t  dice.rotateY(dy[d]);\n\n\tint cost = st.cost + mass[y][x] * dice.get(Dice::BOTTOM);\n\tif (dp[y][x][dice.get(Dice::TOP)-1][dice.get(Dice::SOUTH)-1][dice.get(Dice::EAST)-1] > cost) {\n\t  dp[y][x][dice.get(Dice::TOP)-1][dice.get(Dice::SOUTH)-1][dice.get(Dice::EAST)-1] = cost;\n\t  State tmp(x, y, cost);\n\t  tmp.dice = dice;\n\t  que.push(tmp);\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[12][12],d[6],tx,ty;\nunsigned b[12][12][6][6];\nvoid f(int p,int x,int y){\n  p+=a[x][y]*d[5];\n  if(a[x][y]!=-1&&b[x][y][d[0]-1][d[1]-1]>(unsigned)p){\n    b[x][y][d[0]-1][d[1]-1]=p;\n    if(x!=tx||y!=ty){\n      swap(d[4],d[0]);\n      swap(d[0],d[2]);\n      swap(d[2],d[5]);\n      f(p,x-1,y);\n      swap(d[2],d[0]);\n      swap(d[0],d[4]);\n      swap(d[4],d[5]);\n      swap(d[3],d[0]);\n      swap(d[0],d[1]);\n      swap(d[1],d[5]);\n      f(p,x,y-1);\n      swap(d[1],d[0]);\n      swap(d[0],d[3]);\n      swap(d[3],d[5]);\n      swap(d[2],d[0]);\n      swap(d[0],d[4]);\n      swap(d[4],d[5]);\n      f(p,x+1,y);\n      swap(d[4],d[0]);\n      swap(d[0],d[2]);\n      swap(d[2],d[5]);\n      swap(d[1],d[0]);\n      swap(d[0],d[3]);\n      swap(d[3],d[5]);\n      f(p,x,y+1);\n      swap(d[3],d[0]);\n      swap(d[0],d[1]);\n      swap(d[1],d[5]);\n    }\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int h,w,sx,sy;\n  while(cin>>h>>w&&h+w){\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++)\n\tcin>>a[j][i];\n    cin>>sy>>sx>>ty>>tx;\n    sx++;\n    sy++;\n    tx++;\n    ty++;\n    d[0]=1;\n    d[1]=2;\n    d[2]=3;\n    d[3]=5;\n    d[4]=4;\n    d[5]=6;\n    memset(b,-1,sizeof(b));\n    b[sx][sy][d[0]-1][d[1]-1]=0;\n    swap(d[4],d[0]);\n    swap(d[0],d[2]);\n    swap(d[2],d[5]);\n    f(0,sx-1,sy);\n    swap(d[2],d[0]);\n    swap(d[0],d[4]);\n    swap(d[4],d[5]);\n    swap(d[3],d[0]);\n    swap(d[0],d[1]);\n    swap(d[1],d[5]);\n    f(0,sx,sy-1);\n    swap(d[1],d[0]);\n    swap(d[0],d[3]);\n    swap(d[3],d[5]);\n    swap(d[2],d[0]);\n    swap(d[0],d[4]);\n    swap(d[4],d[5]);\n    f(0,sx+1,sy);\n    swap(d[4],d[0]);\n    swap(d[0],d[2]);\n    swap(d[2],d[5]);\n    swap(d[1],d[0]);\n    swap(d[0],d[3]);\n    swap(d[3],d[5]);\n    f(0,sx,sy+1);\n    swap(d[3],d[0]);\n    swap(d[0],d[1]);\n    swap(d[1],d[5]);\n    unsigned mn=-1;\n    for(i=0;i<6;i++)\n      for(j=0;j<6;j++)\n\tmn=min(mn,b[tx][ty][j][i]);\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Cost first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  Dice d;\n  int y, x;\n\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State& right) const{\n    return y == right.y ? x < right.x : y < right.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<pair<int, State>, vector<pair<int, State> >, greater<pair<int, State> > > q;\n    q.push(MP(0, s));\n    map<pi, int> m;\n    m[MP(sy, sx)] = 0;\n    while(1){\n      int qsize = (int)q.size();\n      //      printf(\"qsize %d\\n\", qsize);\n      rep(i, qsize){\n\tpair<int, State> now = q.top(); q.pop();\n\trep(d, 4){\n\t  pair<int , State> next = now;\n\t  next.S.y += dy[d]; next.S.x += dx[d];\n\t  int ny = next.S.y, nx = next.S.x;\n\t  if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\t  int tmp;\n\t  switch(d){\n\t  case 0:\n\t    tmp = 7 - next.S.d.t;\n\t    next.S.d.t = next.S.d.e;\n\t    next.S.d.e = tmp;\n\t    break;\n\t  case 1:\n\t    tmp = 7 - next.S.d.t;\n\t    next.S.d.t = next.S.d.s;\n\t    next.S.d.s = tmp;\n\t    break;\n\t  case 2:\n\t    tmp = 7 - next.S.d.e;\n\t    next.S.d.e = next.S.d.t;\n\t    next.S.d.t = tmp;\n\t    break;\n\t  case 3:\n\t    tmp = 7 - next.S.d.s;\n\t    next.S.d.s = next.S.d.t;\n\t    next.S.d.t = tmp;\n\t    break;\n\t  }\n\n\t  next.Cost += cost[ny][nx] * (7 - next.S.d.t);\n\t  if(m.count(MP(ny, nx)) != 0  && m[MP(ny,nx)] <= next.Cost) continue;\n\t  m[MP(ny,nx)] = next.Cost;\n\t  //\t  printf(\"%d %d\\n\", ny, nx);\n\t  if(ny == gy && nx == gx){\n\t    printf(\"%d\\n\", next.Cost);\n\t    goto e;\n\t  }\n\t  q.push(next);\n\t}\n      }\n    }\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost > s.cost;\n  }\n};\n\nstruct mstruct{\n  int y, x;\n  Dice d;\n\n  bool operator<(const mstruct &m) const{\n    return y == m.y ? x < m.x : y < m.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<mstruct, int> m;\n    mstruct ms;\n    ms.y = sy; ms.x = sx;\n    ms.d.t = 1; ms.d.s = 2; s.d.e = 3;\n    m[ms] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx){\n\t//\t res = min(res, now.cost);\n\tprintf(\"%d\\n\", now.cost);\n\tgoto e;\n      }\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\t//\tprintf(\"%d\\n\", next.cost);\n\tmstruct ns;\n\tns.y = ny; ns.x = nx;\n\tns.d.t = next.d.t; ns.d.s = next.d.s; ns.d.e = next.d.e;\n\tif(m.count(ns) != 0  && m[ns] <= next.cost) continue;\n\tm[ns] = next.cost;\n\t//printf(\"%d %d %d\\n\", next.y, next.x, next.cost);\n\tq.push(next);\n      }\n    }\n    //    printf(\"%d\\n\", res==INF?0:res);\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef long long int lli;\nconst lli INF = (1LL<<60);\nconst lli dy[4] = {-1,0,1,0};\nconst lli dx[4] = {0,1,0,-1};\nlli h,w;\n\nclass state{\npublic:\n  lli y,x, up,n,e, cost;\n};\n\nbool check(lli y, lli x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nint main(){\n  while(cin >> h >> w && (h|w)){\n    lli a[11][11],b[11][11],gx,gy,ans=INF;\n    state u,v;\n    queue<state> Q;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> a[i][j];\n        b[i][j] = INF;\n      }\n    }\n    cin >> u.y >> u.x >> gy >> gx;\n    b[u.y][u.x] = 0;\n    u.up = 1;\n    u.n = 5;\n    u.e = 3;\n    u.cost = 0;\n    Q.push(u);\n\n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n\n      if(u.y == gy && u.x == gx){\n        ans = min(ans,u.cost);\n        continue;\n      }\n\n      for(int i=0;i<4;i++){\n        v = u;\n        v.y += dy[i];\n        v.x += dx[i];\n        if(!check(v.y,v.x)) continue;\n        if(i == 0){\n          v.up = 7 - u.n;\n          v.n = u.up;\n        } else if(i == 1){\n          v.up = 7 - u.e;\n          v.e = u.up;\n        } else if(i == 2){\n          v.up = u.n;\n          v.n = 7 - u.up;\n        } else if(i == 3){\n          v.up = u.e;\n          v.e = 7 - u.up;\n        }\n        v.cost += a[v.y][v.x] * (7 - v.up);\n        if(b[v.y][v.x] > v.cost){\n          b[v.y][v.x] = v.cost;\n          Q.push(v);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,s,e,w,n,b;\n\tDice(int tt,int ss,int ee,int ww,int nn,int bb):t(tt),s(ss),e(ee),w(ww),n(nn),b(bb){}\n\tvoid rotx(){\n\t\tDice tmp=*this;\n\t\tt=tmp.w;\n\t\te=tmp.t;\n\t\tw=tmp.b;\n\t\tb=tmp.e;\n\t}\n\tvoid roty(){\n\t\tDice tmp=*this;\n\t\tt=tmp.s;\n\t\ts=tmp.b;\n\t\tn=tmp.t;\n\t\tb=tmp.n;\n\t}\n};\n\nstruct Stat{\n\tint x,y,cost;\n\tDice dice;\n\tStat(int xx,int yy,int c,Dice d):x(xx),y(yy),cost(c),dice(d){}\n\tbool operator<(const Stat &st)const{ return cost<st.cost; }\n};\n\nint main(){\n\tfor(int h,w;scanf(\"%d%d\",&h,&w),h;){\n\t\tint grid[10][10];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",grid[i]+j);\n\t\tint sx,sy,gx,gy;\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\n\t\tDice ini(1,2,3,4,5,6);\n\n\t\tint cmin[10][10][6][6],ans;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int t=1;t<=6;t++)for(int w=1;w<=6;w++)\tcmin[i][j][t][w]=1<<30;\n\t\tcmin[sy][sx][ini.t][ini.w]=0;\n\t\tpriority_queue<Stat> pq;\tpq.push(Stat(sx,sy,0,ini));\n\t\twhile(!pq.empty()){\n\t\t\tStat a=pq.top();\tpq.pop();\n\t\t\tint x=a.x,y=a.y,cost=-a.cost;\n\t\t\tDice d=a.dice;\n\t\t\tif(x==gx && y==gy){ ans=cost; break; }\n\t\t\tif(cmin[y][x][d.t][d.w]<cost)\tcontinue;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h){\n\t\t\t\t\tDice nextdice=d;\n\t\t\t\t\tif(i==0)\t\tnextdice.rotx();\n\t\t\t\t\telse if(i==1)\tnextdice.roty();\n\t\t\t\t\telse if(i==2)\tnextdice.rotx(),nextdice.rotx(),nextdice.rotx();\n\t\t\t\t\telse\t\t\tnextdice.roty(),nextdice.roty(),nextdice.roty();\n\t\t\t\t\tint nextt=nextdice.t;\n\t\t\t\t\tint nextw=nextdice.w;\n\t\t\t\t\tint nextcost=cost+nextdice.b*grid[yy][xx];\n\t\t\t\t\tif(nextcost<cmin[yy][xx][nextt][nextw]){\n\t\t\t\t\t\tpq.push(Stat(xx,yy,-nextcost,nextdice));\n\t\t\t\t\t\tcmin[yy][xx][nextt][nextw]=nextcost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps = 1e-9;\n\nenum R_Way {\n\tR_Left,\n\tR_Front,\n\tR_Right,\n\tR_Back,\n\n\tR_Dummy,\n};\nstruct Dice {\n\tint tp;\n\tint bo;\n\tint no;\n\tint so;\n\tint ea;\n\tint we;\n\tDice(int tp_, int bo_, int no_, int so_, int ea_, int we_) :\n\t\ttp(tp_), bo(bo_), no(no_), so(so_), ea(ea_), we(we_) {\n\n\t}\n\tDice(vector<int>pips_) {\n\n\t}\n\n\tDice() {\n\t\ttp = 1;\n\t\tbo = 6;\n\t\tno = 5;\n\t\tso = 2;\n\t\tea = 3;\n\t\twe = 4;\n\t}\n\n\tint rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tint c = tp;\n\t\t\ttp = we;\n\t\t\twe = bo;\n\t\t\tbo = ea;\n\t\t\tea = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tint c = tp;\n\t\t\ttp = so;\n\t\t\tso = bo;\n\t\t\tbo = no;\n\t\t\tno = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\tint c = tp;\n\t\t\ttp = ea;\n\t\t\tea = bo;\n\t\t\tbo = we;\n\t\t\twe = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\tint c = tp;\n\t\t\ttp = no;\n\t\t\tno = bo;\n\t\t\tbo = so;\n\t\t\tso = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\treturn tp;\n\t}\n\tint rotate(const int way) {\n\t\treturn rotate(static_cast<R_Way>(way));\n\t}\n\tvoid spin(const int  clockwise) {\n\t\tif (!clockwise) {\n\n\t\t\trotate(R_Way::R_Left);\n\t\t\trotate(R_Way::R_Back);\n\t\t\trotate(R_Way::R_Right);\n\t\t}\n\t\telse {\n\n\t\t\trotate(R_Way::R_Left);\n\t\t\trotate(R_Way::R_Front);\n\t\t\trotate(R_Way::R_Right);\n\t\t}\n\t}\n\tint hash()const {\n\t\treturn tp + we * 6 + no * 36;\n\t}\n};\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\n\nint gettop(int south, int east) {\n\treturn geteast(south, east);\n}\nint getsouth(int east, int top) {\n\treturn 7 - geteast(top, east);\n}\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\n\nint H, W;\nbool check(const int y, const int x) {\n\treturn y >= 0 && y < H&&x >= 0 && x < W;\n}\nstruct aa {\n\tint x;\n\tint y;\n\tint tp;\n\tint bo;\n\tint no;\n\tint so;\n\tint ea;\n\tint we;\n\tint hash;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\t//aa?????????????????¶\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint memo[101][101][1000];\nint main() {\n\tmap<int, int>mp;\n\tint num = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tfor (int j = 0; j < 100; ++j) {\n\t\t\t\tfor (int k = 0; k < 1000; ++k) {\n\t\t\t\t\tmemo[i][j][k] = 1e8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy; cin >> sy >> sx >> gy >> gx;\n\t\t\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tDice ini_di;\n\t\tque.push(aa{ sx,sy,ini_di.tp,ini_di.bo,ini_di.no,ini_di.so,ini_di.ea,ini_di.we,ini_di.hash(),0 });\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop(); if (atop.x == gx&&atop.y == gy) {\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tconst int nextx = atop.x + dx[way];\n\t\t\t\tconst int nexty = atop.y + dy[way];\n\t\t\t\t\n\t\t\t\tDice di = Dice(atop.tp, atop.bo, atop.no, atop.so, atop.ea, atop.we);\n\t\t\t\tif (check(nexty, nextx)) {\n\t\t\t\t\tdi.rotate(way);\n\t\t\t\t\tconst int nexttime=  atop.time + di.bo*field[nexty][nextx];\n\t\t\t\t\tif (mp.find(di.hash()) == mp.end()) {\n\t\t\t\t\t\tmp[di.hash()] = num++;\n\t\t\t\t\t}\n\t\t\t\t\tif (memo[nextx][nexty][mp[di.hash()]]>nexttime) {\n\t\t\t\t\t\tmemo[nextx][nexty][mp[di.hash()]] = nexttime;\n\t\t\t\t\t\tque.push(aa{ nextx,nexty,di.tp,di.bo,di.no,di.so,di.ea,di.we,di.hash(),nexttime });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n\tint face[6];\n} DICE;\n\ntypedef struct {\n\tint cost;\n\tint x, y;\n\tDICE dice;\n} DATA;\n\n#define NORTH\t\t(0)\n#define SOUTH\t\t(1)\n#define EAST\t    (2)\n#define WEST\t\t(3)\n\nbool operator<(const DATA& a, const DATA& b)\n{\n\treturn (a.cost > b.cost);\n}\n\npriority_queue<DATA> pq;\n\nvoid rote(int dir, const DICE& in, DICE* out)\n{\n\tswitch (dir)\n\t{\n\t  case NORTH:\n\t  \tout->face[0] = in.face[1];\n\t\tout->face[1] = in.face[2];\n\t\tout->face[2] = in.face[3];\n\t\tout->face[3] = in.face[0];\n\t\tout->face[4] = in.face[4];\n\t\tout->face[5] = in.face[5];\n\t\tbreak;\n\t  case SOUTH:\n\t  \tout->face[0] = in.face[3];\n\t\tout->face[1] = in.face[0];\n\t\tout->face[2] = in.face[1];\n\t\tout->face[3] = in.face[2];\n\t\tout->face[4] = in.face[4];\n\t\tout->face[5] = in.face[5];\n\t\tbreak;\n\t  case EAST:\n\t  \tout->face[0] = in.face[5];\n\t\tout->face[1] = in.face[1];\n\t\tout->face[2] = in.face[4];\n\t\tout->face[3] = in.face[3];\n\t\tout->face[4] = in.face[0];\n\t\tout->face[5] = in.face[2];\n\t\tbreak;\n\t  case WEST:\n\t  \tout->face[0] = in.face[4];\n\t\tout->face[1] = in.face[1];\n\t\tout->face[2] = in.face[5];\n\t\tout->face[3] = in.face[3];\n\t\tout->face[4] = in.face[2];\n\t\tout->face[5] = in.face[0];\n\t\tbreak;\n\t}\n}\n\nint main(void)\n{\n\tDATA add;\n\tint field[100][100];\n\tint h, w;\n\tint sx, sy;\n\tint gx, gy;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &h, &w);\n\t\t\n\t\tif (!h)break;\n\t\t\n\t\twhile (!pq.empty()){\n\t\t\tpq.pop();\n\t\t}\n\t\tmemset(field, -1, sizeof(field));\n\t\tfor (int y = 1; y <= h; y++){\n\t\t\tfor (int x = 1; x <= w; x++){\n\t\t\t\tscanf(\"%d\", &field[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &sy, &sx);\n\t\tscanf(\"%d%d\", &gy, &gx);\n\t\t\n\t\tadd.x = sx + 1;\n\t\tadd.y = sy + 1;\n\t\tadd.cost = 0;\n\t\tadd.dice.face[0] = 1;\n\t\tadd.dice.face[1] = 2;\n\t\tadd.dice.face[2] = 6;\n\t\tadd.dice.face[3] = 5;\n\t\tadd.dice.face[4] = 3;\n\t\tadd.dice.face[5] = 4;\n\t\t\n\t\tpq.push(add);\n\t\t\n\t\twhile (!pq.empty()){\n\t\t\tconst DATA &d = pq.top();\n\t\t\t\n\t\t\t\n\t\t\tif (d.x == gx + 1 && d.y == gy + 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd.x = d.x;\n\t\t\tadd.y = d.y - 1;\n\t\t\trote(NORTH, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x;\n\t\t\tadd.y = d.y + 1;\n\t\t\trote(SOUTH, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x + 1;\n\t\t\tadd.y = d.y;\n\t\t\trote(EAST, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x - 1;\n\t\t\tadd.y = d.y;\n\t\t\trote(WEST, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\t\n\t\t\tpq.pop();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", pq.top().cost);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  lee1r\n * Created Time:  2011/8/24 15:42:22\n * File Name: 8.24_G.cpp\n */\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<ctime>\n#define L(x) ((x)<<1)\n#define R(x) ((x)<<1|1)\n#define Half(x) ((x)>>1)\n#define Lowbit(x) ((x)&(-(x)))\nusing namespace std;\nconst int kInf(0x7f7f7f7f);\nconst double kEps(1e-8);\ntypedef unsigned int uint;\ntypedef long long int64;\ntypedef unsigned long long uint64;\n\nbool scanf(int &num)\n{\n    char in;\n    while((in=getchar())!=EOF && (in>'9' || in<'0'));\n    if(in==EOF) return false;\n    num=in-'0';\n    while(in=getchar(),in>='0' && in<='9') num*=10,num+=in-'0';\n    return true;\n}\n\nint init[7]={};\nint dice[50][7]={\n{0,0,0,0,0,0},\n{6,2,3,5,4,1},\n{6,3,5,4,2,1},\n{6,4,2,3,5,1},\n{1,3,2,4,5,6},\n{1,4,5,3,2,6},\n{2,1,3,6,4,5},\n{1,5,3,2,4,6},\n{5,6,3,1,4,2},\n{4,2,6,5,1,3},\n{2,3,6,4,1,5},\n{3,5,6,2,1,4},\n{5,4,6,3,1,2},\n{1,2,4,5,3,6},\n{2,6,4,1,3,5},\n{6,5,4,2,3,1},\n{5,1,4,6,3,2},\n{3,2,1,5,6,4},\n{2,4,1,3,6,5},\n{4,5,1,2,6,3},\n{5,3,1,4,6,2},\n{4,1,2,6,5,3},\n{3,1,5,6,2,4},\n{4,6,5,1,2,3},\n{3,6,2,1,5,4}\n};\n\nvoid Left(int *a,int *b)\n{\n    b[1]=a[1];b[3]=a[3];\n    b[0]=a[4];b[4]=a[5];b[5]=a[2];b[2]=a[0];\n}\n\nvoid Front(int *a,int *b)\n{\n    b[4]=a[4];b[2]=a[2];\n    b[0]=a[1];b[1]=a[5];b[5]=a[3];b[3]=a[0];\n}\n\nint N,M,r[17][17],x0,y0,x1,y1;\nint dist[9999];\nbool inq[9999];\n\nint f(int a,int b,int c,int d)\n{\n    return a*1000+b*100+c*10+d;\n}\n\nvoid SPFA()\n{\n    int start(f(x0,y0,6,2));\n    queue<int> q;\n    memset(inq,false,sizeof(inq));\n    memset(dist,0x7f,sizeof(dist));\n    dist[start]=0;\n    q.push(start);\n    inq[start]=true;\n    while(!q.empty())\n    {\n        int t(q.front());q.pop();inq[t]=false;\n        int d(dist[t]);\n        int nowx,nowy,nowa,nowb;\n        nowb=t%10;t/=10;\n        nowa=t%10;t/=10;\n        nowy=t%10;t/=10;\n        nowx=t%10;\n        int pos;\n        for(pos=1;pos<=24;pos++)\n            if(dice[pos][0]==nowa && dice[pos][1]==nowb)\n                break;\n        int news[7];\n        if(nowy-1>=0)\n        {\n            Left(dice[pos],news);\n            int tt(f(nowx,nowy-1,news[0],news[1]));\n            if(dist[tt]>d+r[nowx][nowy-1]*news[0])\n            {\n                dist[tt]=d+r[nowx][nowy-1]*news[0];\n                if(!inq[tt])\n                {\n                    q.push(tt);\n                    inq[tt]=true;\n                }\n            }\n        }\n        if(nowx+1<N)\n        {\n            Front(dice[pos],news);\n            int tt(f(nowx+1,nowy,news[0],news[1]));\n            if(dist[tt]>d+r[nowx+1][nowy]*news[0])\n            {\n                dist[tt]=d+r[nowx+1][nowy]*news[0];\n                if(!inq[tt])\n                {\n                    q.push(tt);\n                    inq[tt]=true;\n                }\n            }\n        }\n        if(nowx-1>=0)\n        {\n            int tmp[7];\n            Front(dice[pos],news);\n            Front(news,tmp);\n            Front(tmp,news);\n            int tt(f(nowx-1,nowy,news[0],news[1]));\n            if(dist[tt]>d+r[nowx-1][nowy]*news[0])\n            {\n                dist[tt]=d+r[nowx-1][nowy]*news[0];\n                if(!inq[tt])\n                {\n                    q.push(tt);\n                    inq[tt]=true;\n                }\n            }\n        }\n        if(nowy+1<M)\n        {\n            int tmp[7];\n            Left(dice[pos],news);\n            Left(news,tmp);\n            Left(tmp,news);\n            int tt(f(nowx,nowy+1,news[0],news[1]));\n            if(dist[tt]>d+r[nowx][nowy+1]*news[0])\n            {\n                dist[tt]=d+r[nowx][nowy+1]*news[0];\n                if(!inq[tt])\n                {\n                    q.push(tt);\n                    inq[tt]=true;\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    //freopen(\"data.in\",\"r\",stdin);\n    #endif\n    \n    while(scanf(N) && scanf(M) && (N || M))\n    {\n        for(int i=0;i<N;i++)\n            for(int j=0;j<M;j++)\n                scanf(r[i][j]);\n        scanf(x0);scanf(y0);\n        scanf(x1);scanf(y1);\n        //  Input\n        \n        SPFA();\n        \n        int ans(kInf);\n        for(int i=1;i<=6;i++)\n            for(int j=1;j<=6;j++)\n                ans=min(ans,dist[f(x1,y1,i,j)]);\n        \n        printf(\"%d\\n\",ans);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nclass Dice{\npublic:\n\tDice(){\n\t\tnumber = new int[6];\n\t\twork = new int[6];\n\t};\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'E':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tint getBottom(){\n\t\treturn number[5];\n\t}\n\n\tint getEast(){\n\t\treturn number[2];\n\t}\n\n\tvoid setNumber(int n0,int n1,int n2,int n3,int n4,int n5){\n\t\tnumber[0] = n0;\n\t\tnumber[1] = n1;\n\t\tnumber[2] = n2;\n\t\tnumber[3] = n3;\n\t\tnumber[4] = n4;\n\t\tnumber[5] = n5;\n\t}\n\n\tvoid init(){\n\t\tsetNumber(1,5,3,4,2,6);\n\t}\n\n\tvoid set(Dice arg){\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tnumber[i] = arg.number[i];\n\t\t}\n\t}\n\n\tint* number;\n\tint* work;\n};\n\nint H,W,diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nstruct Info{\n\tInfo(){\n\t\trow = col = penalty = 0;\n\t\tdice.init();\n\t}\n\n\tvoid set(int arg_row,int arg_col,int arg_penalty){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tpenalty = arg_penalty;\n\t}\n\tint row,col,penalty;\n\tDice dice;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint dp[10][10][7][7];\n\tint map[10][10],start_row,start_col,goal_row,goal_col,minimum,next_row,next_col;\n\tqueue<Info> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&map[i][k]);\n\t\t}\n\n\t\tscanf(\"%d %d\",&start_row,&start_col);\n\t\tscanf(\"%d %d\",&goal_row,&goal_col);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tfor(int p = 1; p <= 6; p++){\n\t\t\t\t\tfor(int q = 1; q <= 6; q++)dp[i][k][p][q] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tInfo first;\n\t\tfirst.set(start_row,start_col,0);\n\t\tdp[start_row][start_col][first.dice.getBottom()][first.dice.getEast()] = 0;\n\n\t\twhile(!Q.empty())Q.pop();\n\t\tQ.push(first);\n\n\t\tminimum = BIG_NUM;\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row == goal_row && Q.front().col == goal_col){\n\t\t\t\tminimum = min(minimum,Q.front().penalty);\n\t\t\t\tQ.pop();\n\t\t\t}else if(Q.front().penalty >= minimum ||\n\t\t\t\t\tQ.front().penalty > dp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\t\t\tInfo next;\n\t\t\t\t\t\tnext.set(next_row,next_col,Q.front().penalty);\n\t\t\t\t\t\tnext.dice.set(Q.front().dice);\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tnext.dice.roll('N');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tnext.dice.roll('W');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tnext.dice.roll('E');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tnext.dice.roll('S');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(dp[next_row][next_col][next.dice.getBottom()][next.dice.getEast()] > dp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]+\n\t\t\t\t\t\t\t\tmap[next_row][next_col]*next.dice.getBottom()){\n\t\t\t\t\t\t\tdp[next_row][next_col][next.dice.getBottom()][next.dice.getEast()] =\n\t\t\t\t\t\t\t\t\tdp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]+map[next_row][next_col]*next.dice.getBottom();\n\t\t\t\t\t\t\tnext.penalty += map[next_row][next_col]*next.dice.getBottom();\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tDice(int top,int bottom,int north,int south,int east,int west,int sx,int sy,int cost){\n\t\tt=top,b=bottom,n=north,s=south,e=east,w=west;\n\t\tx=sx,y=sy,c=cost;\n\t}\n\tbool operator<(const Dice &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint w,h;\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nint main(){\n\tint p[10][10],memo[10][10];\n\twhile(cin>>h>>w && h!=0){\n\t\tpriority_queue<Dice> que;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>p[y][x];\n\t\t\t\tmemo[y][x]=-1;\n\t\t\t}\n\n\t\tint gx,gy,sx,sy;\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\tque.push(Dice(1,6,5,2,3,4,sx,sy,0));\n\t\twhile(!que.empty()){\n\t\t\tDice now=que.top();\n\t\t\tque.pop();\n//\t\t\tcout<<now.x<<\" \"<<now.y<<\" \"<<now.b<<\" \"<<now.c<<endl;\n\t\t\tif(now.x==gx && now.y==gy) {cout<<now.c<<endl; break;}\n\t\t\tif(memo[now.y][now.x]>=0 && memo[now.y][now.x]<=now.c) continue;\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tDice copy=now;\n\t\t\t\tcopy.roll(r);\n\t\t\t\tif(in(copy.x,copy.y)){\n\t\t\t\t\tcopy.c+=copy.b*p[copy.y][copy.x];\n\t\t\t\t\tque.push(copy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n\nstruct Dice{\n  int tmp,d[6];\n  Dice(){\n    for(int i = 0 ; i < 6 ; i++){\n      d[i] = i;\n    }\n  }\n  void rollN(){\n    tmp = d[0];\n    d[0] = d[1];\n    d[1] = d[5];\n    d[5] = d[4];\n    d[4] = tmp;\n  }\n  void rollE(){\n    tmp = d[0];\n    d[0] = d[3];\n    d[3] = d[5];\n    d[5] = d[2];\n    d[2] = tmp;\n  }\n  void rollS(){\n    tmp = d[0];\n    d[0] = d[4];\n    d[4] = d[5];\n    d[5] = d[1];\n    d[1] = tmp;\n  }\n  void rollW(){\n    tmp = d[0];\n    d[0] = d[2];\n    d[2] = d[5];\n    d[5] = d[3];\n    d[3] = tmp;\n  }\n};\n\nstruct State{\n  int cost,x,y;\n  Dice d;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(cin >> H >> W, H){\n    int field[MAX_H][MAX_W];\n    int sx,sy,gx,gy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    int cost[MAX_H][MAX_W][6][6][6];\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        for(int k = 0 ; k < 6 ; k++){\n          for(int l = 0 ; l < 6 ; l++){\n            for(int m = 0 ; m < 6 ; m++){\n              cost[i][j][k][l][m] = 1e9;\n            }\n          }\n        }\n      }\n    }\n    Dice die;\n    cost[sy][sx][die.d[0]][die.d[1]][die.d[2]] = 0;\n    priority_queue<State> Q;\n    Q.push((State){0,sx,sy,die});\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    while(!Q.empty()){\n      State s = Q.top(); Q.pop();\n      int x = s.x, y = s.y;\n      int ncost = cost[y][x][s.d.d[0]][s.d.d[1]][s.d.d[2]];\n      if(ncost < s.cost){ continue; }\n      if(x == gx && y == gy){\n        cout << s.cost << endl;\n        break;\n      }\n      for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        Dice d = s.d;\n        if(0 > nx || nx >= W || 0 > ny || ny >= H){\n          continue;\n        }\n        switch(i){\n        case 0:\n          d.rollW();\n          break;\n        case 1:\n          d.rollN();\n          break;\n        case 2:\n          d.rollE();\n          break;\n        case 3:\n          d.rollS();\n          break;\n        }\n        int p = (d.d[5]+1)*field[ny][nx];\n        if(s.cost + p < cost[ny][nx][d.d[0]][d.d[1]][d.d[2]]){\n          cost[ny][nx][d.d[0]][d.d[1]][d.d[2]] = s.cost + p;\n          Q.push((State){cost[ny][nx][d.d[0]][d.d[1]][d.d[2]],nx,ny,d});\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost < s.cost;\n    }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<pi, int> m;\n    m[MP(sy, sx)] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx) res = min(res, now.cost);\n\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\tif(m.count(MP(ny, nx)) != 0  && m[MP(ny,nx)] <= next.cost) continue;\n\tm[MP(ny,nx)] = next.cost;\n\t//\t  printf(\"%d %d\\n\", ny, nx);\n\t/*\t  if(ny == gy && nx == gx){\n\t\t  res = min(res, next.cost);\n\t\t  break;\n\t\t  }*/\n\tq.push(next);\n      }\n    }\n    printf(\"%d\\n\", res==INF?0:res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\n\nint H[6][6] = {\n\t{1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n\t{3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n\t{2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n\t{4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n\t{0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n\t{0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[6] = {0,1,-1,0,0,0};\nint dy[6] = {-1,0,0,1,0,0};\n// 高さと幅\nint h, w;\n// s[y][x] := (x,y)のマスに書かれた数字\nint s[11][11];\n\n\n// サイコロライブラリ\n// d[0] := top\n// d[1] := front \n// d[2] := right\n// d[3] := left\n// d[4] := back\n// d[5] := bottom\nenum{TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\n\nstruct Cube{\n\tint x,y;\n\tvector<int> d;\n\t// コンストラクタで初期化\n\tCube(vector<int> v, int x_, int y_){\n\t\tx = x_; y = y_;\n\t\tif( v.size() == 6 ){\n\t\t\td = v;\n\t\t}else{\n\t\t\td = vector<int> (6);\n\t\t}\n\t}\n\t// dirの方向に回転 (副作用なし)\n\tCube roll(int dir){\n\t\tCube result = (*this);\n\t\tvector<int> d_(6);\n    \tfor(int i = 0 ; i < 6 ; i++ ){\n        \td_[i] = d[ H[dir][i] ];\n    \t}\n    \tresult.d = d_;\n    \tresult.x += dx[dir];\n    \tresult.y += dy[dir];\n    \treturn result;\n    }\n};\nbool operator<(const Cube& c1, const Cube& c2){\n\treturn P(c1.x,c1.y) < P(c2.x,c2.y);\n}\n\ntypedef pair<int,Cube> State;\n\n// ゴール g, 初期のキューブの状態 c からのダイクストラ法\nint dijkstra(Cube c , P g){\n\t// greater<State> を指定することで コスト が小さい順に取り出せる\n\tpriority_queue<State, vector<State>, greater<State> > q;\n\t\n\t// d[cube] := cube にたどり着く最小コスト. (cubeは位置のキューブの状態を持っている)\n\tmap<Cube,int> d;\n\t\n\td[c] = 0;\n\tState start( 0 , c );\n\tq.push( start );\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\tint now_cost = q.top().first;\n\t\tCube c = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif( P(c.x,c.y) == g ){\n\t\t\tresult = now_cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int dir=0 ; dir < 6 ; dir++ ){\n\t\t\tCube c_ = c.roll( dir );\n\t\t\tif( c_.x < 0 || c_.y < 0 || c_.x >= w || c_.y >= h ) continue;\n\t\t\t\n\t\t\tint next_cost = now_cost + s[c_.y][c_.x] * c_.d[BOTTOM];\n\t\t\tif( d.count(c_) == 0 ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}else if( next_cost < d[c_] ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tvector<int> v(6);\n\tv[0] = 1; v[5] = 6;\n\tv[1] = 2; v[4] = 5;\n\tv[2] = 3; v[3] = 4;\t\n\t\n\twhile( cin >> h >> w , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tCube c( v, sx, sy );\n\t\tint ans = dijkstra( c , P(gx,gy) );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 10\n#define MAX_W 10\n \nstruct Dice{\n    int tmp,d[6];\n    Dice(){\n\tfor(int i = 0 ; i < 6 ; i++){\n\t    d[i] = i;\n\t}\n    }\n    void rollN(){\n\ttmp = d[0];\n\td[0] = d[1];\n\td[1] = d[5];\n\td[5] = d[4];\n\td[4] = tmp;\n    }\n    void rollE(){\n\ttmp = d[0];\n\td[0] = d[3];\n\td[3] = d[5];\n\td[5] = d[2];\n\td[2] = tmp;\n    }\n    void rollS(){\n\ttmp = d[0];\n\td[0] = d[4];\n\td[4] = d[5];\n\td[5] = d[1];\n\td[1] = tmp;\n    }\n    void rollW(){\n\ttmp = d[0];\n\td[0] = d[2];\n\td[2] = d[5];\n\td[5] = d[3];\n\td[3] = tmp;\n    }\n};\n \nstruct State{\n    int cost,x,y;\n    Dice d;\n    bool operator < (const State &s)const{\n\treturn cost > s.cost;\n    }\n};\n \nint main(){\n    int H,W;\n    while(cin >> H >> W, H){\n\tint field[MAX_H][MAX_W];\n\tint sx,sy,gx,gy;\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t    }\n\t}\n\tcin >> sy >> sx >> gy >> gx;\n\tint cost[MAX_H][MAX_W][6][6][6];\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tfor(int k = 0 ; k < 6 ; k++){\n\t\t    for(int l = 0 ; l < 6 ; l++){\n\t\t\tfor(int m = 0 ; m < 6 ; m++){\n\t\t\t    cost[i][j][k][l][m] = 1e9;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tDice die;\n\tcost[sy][sx][die.d[0]][die.d[1]][die.d[2]] = 0;\n\tpriority_queue<State> Q;\n\tQ.push((State){0,sx,sy,die});\n\tconst int dx[] = {-1,0,1,0};\n\tconst int dy[] = {0,-1,0,1};\n\twhile(!Q.empty()){\n\t    State s = Q.top(); Q.pop();\n\t    int x = s.x, y = s.y;\n\t    int ncost = cost[y][x][s.d.d[0]][s.d.d[1]][s.d.d[2]];\n\t    if(ncost < s.cost){ continue; }\n\t    if(x == gx && y == gy){\n\t\tcout << s.cost << endl;\n\t\tbreak;\n\t    }\n\t    for(int i = 0 ; i < 4 ; i++){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tDice d = s.d;\n\t\tif(0 > nx || nx >= W || 0 > ny || ny >= H){\n\t\t    continue;\n\t\t}\n\t\tswitch(i){\n\t\tcase 0:\n\t\t    d.rollW();\n\t\t    break;\n\t\tcase 1:\n\t\t    d.rollN();\n\t\t    break;\n\t\tcase 2:\n\t\t    d.rollE();\n\t\t    break;\n\t\tcase 3:\n\t\t    d.rollS();\n\t\t    break;\n\t\t}\n\t\tint p = (d.d[5]+1)*field[ny][nx];\n\t\tif(s.cost + p < cost[ny][nx][d.d[0]][d.d[1]][d.d[2]]){\n\t\t    cost[ny][nx][d.d[0]][d.d[1]][d.d[2]] = s.cost + p;\n\t\t    Q.push((State){cost[ny][nx][d.d[0]][d.d[1]][d.d[2]],nx,ny,d});\n\t\t}\n\t    }\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nclass Dice{\npublic:\n\tDice(){\n\t\tnumber = new int[6];\n\t\twork = new int[6];\n\t};\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'E':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tint getBottom(){\n\t\treturn number[5];\n\t}\n\n\tint getEast(){\n\t\treturn number[2];\n\t}\n\n\tvoid setNumber(int n0,int n1,int n2,int n3,int n4,int n5){\n\t\tnumber[0] = n0;\n\t\tnumber[1] = n1;\n\t\tnumber[2] = n2;\n\t\tnumber[3] = n3;\n\t\tnumber[4] = n4;\n\t\tnumber[5] = n5;\n\t}\n\n\tvoid init(){\n\t\tsetNumber(1,5,3,4,2,6);\n\t}\n\n\tvoid set(Dice arg){\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tnumber[i] = arg.number[i];\n\t\t}\n\t}\n\n\tint* number;\n\tint* work;\n};\n\nint H,W,diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nstruct Info{\n\tInfo(){\n\t\trow = col = penalty = 0;\n\t\tdice.init();\n\t}\n\n\tvoid set(int arg_row,int arg_col,int arg_penalty){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tpenalty = arg_penalty;\n\t}\n\tint row,col,penalty;\n\tDice dice;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint dp[10][10][7][7];\n\tint map[10][10],start_row,start_col,goal_row,goal_col,minimum,next_row,next_col;\n\tqueue<Info> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&map[i][k]);\n\t\t}\n\n\t\tscanf(\"%d %d\",&start_row,&start_col);\n\t\tscanf(\"%d %d\",&goal_row,&goal_col);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tfor(int p = 1; p <= 6; p++){\n\t\t\t\t\tfor(int q = 1; q <= 6; q++)dp[i][k][p][q] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tInfo first;\n\t\tfirst.set(start_row,start_col,0);\n\t\tdp[start_row][start_col][first.dice.getBottom()][first.dice.getEast()] = 0;\n\n\t\twhile(!Q.empty())Q.pop();\n\t\tQ.push(first);\n\n\t\tminimum = BIG_NUM;\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row == goal_row && Q.front().col == goal_col){\n\t\t\t\tminimum = min(minimum,Q.front().penalty);\n\t\t\t\tQ.pop();\n\t\t\t}else if(Q.front().penalty >= minimum){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\t\t\tInfo next;\n\t\t\t\t\t\tnext.set(next_row,next_col,Q.front().penalty);\n\t\t\t\t\t\tnext.dice.set(Q.front().dice);\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tnext.dice.roll('N');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tnext.dice.roll('W');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tnext.dice.roll('E');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tnext.dice.roll('S');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(dp[next_row][next_col][next.dice.getBottom()][next.dice.getEast()] > dp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]+\n\t\t\t\t\t\t\t\tmap[next_row][next_col]*next.dice.getBottom()){\n\t\t\t\t\t\t\tdp[next_row][next_col][next.dice.getBottom()][next.dice.getEast()] =\n\t\t\t\t\t\t\t\t\tdp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]+map[next_row][next_col]*next.dice.getBottom();\n\t\t\t\t\t\t\tnext.penalty += map[next_row][next_col]*next.dice.getBottom();\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\n#include<string.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tDice(int top,int bottom,int north,int south,int east,int west,int sx,int sy,int cost){\n\t\tt=top,b=bottom,n=north,s=south,e=east,w=west;\n\t\tx=sx,y=sy,c=cost;\n\t}\n\tbool operator<(const Dice &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint w,h;\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nint main(){\n\tint p[10][10],memo[10][10][100];\n\twhile(cin>>h>>w && h!=0){\n\t\tpriority_queue<Dice> que;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>p[y][x];\n\t\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\n\t\tint gx,gy,sx,sy;\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\tque.push(Dice(1,6,5,2,3,4,sx,sy,0));\n\t\twhile(!que.empty()){\n\t\t\tDice now=que.top();\n\t\t\tque.pop();\n//\t\t\tcout<<now.x<<\" \"<<now.y<<\" \"<<now.b<<\" \"<<now.c<<endl;\n\t\t\tif(now.x==gx && now.y==gy) {cout<<now.c<<endl; break;}\n\t\t\tif(memo[now.y][now.x][now.e*7+now.b]>=0 && memo[now.y][now.x][now.e*7+now.b]<=now.c) continue;\n\n\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tDice copy=now;\n\t\t\t\tcopy.roll(r);\n\t\t\t\tif(in(copy.x,copy.y)){\n\t\t\t\t\tcopy.c+=copy.b*p[copy.y][copy.x];\n\t\t\t\t\tque.push(copy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e9 + 10;\n\nint field[11][11];\n\nstruct Point {\npublic:\n  int y, x;\n  \n  Point(int y, int x):y(y), x(x) { }\n  Point() { };\n  \n  void operator=(Point p) {\n    this->y = p.y;\n    this->x = p.x;\n  }\n};\n\nenum { U, F, R, D, B, L };\n\nstruct Dice {\npublic:\n  int face[6];\n  \n  Dice() { face[F] = 2; face[R] = 3; face[U] = 1; face[B] = 5; face[L] = 4; face[D] = 6; }\n  \n  Dice(const Dice& d) {\n    for (int i = 0; i < 6; i++) {\n      face[i] = d.face[i];\n    }  \n  }\n  \n  Dice turn(int dir) {\n    switch (dir) {\n      case 0: rotate(U, R, D, L); break;\n      case 1: rotate(D, B, U, F); break;\n      case 2: rotate(U, L, D, R); break;\n      case 3: rotate(D, F, U, B); break;\n    } \n    return *this;\n  }\n  \n  int &operator[](int n) { \n    return face[n];\n  }\n  \n  void rotate(int a, int b, int c, int d) {\n    int t = face[d];\n    face[d] = face[c];\n    face[c] = face[b];\n    face[b] = face[a];\n    face[a] = t;\n  }\n  \n};\n\nPoint start, goal;\nint h, w;\n\nstruct State {\npublic:\n  Point p;\n  Dice d;\n  State(Point p): p(p) { }\n  State(Point p, Dice d):p(p), d(d) { }\n};\n\n\n\nsigned main() {\n  Dice tmp;\n  \n  int y, x;\n  while (true) {\n    cin >> h >> w;\n    if (h + w == 0) {\n      break;\n    }\n    memset(field, 0, sizeof(field));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        int f;\n        cin >> f;\n        field[i][j] = f;\n      }\n    }\n    cin >> y >> x;\n    start = Point(y, x);\n    cin >> y >> x;\n    goal = Point(y, x);\n    \n    queue<State> q;\n\n    int dist[11][11][7];    \n    for (int i = 0; i < 11; i++) {\n      for (int j = 0; j < 11; j++) {\n        for (int k = 0; k < 7; k++) {\n          dist[i][j][k] = INF;\n        }\n      }\n    }  \n    \n    dist[start.y][start.x][6] = 0;\n    \n    q.push(State(start));\n\n    bool checked[11][11][7] = { false };    \n    while (!q.empty()) {\n      State s = q.front(); q.pop();\n      \n      int dy[4] = { 0, 1, 0, -1 };\n      int dx[4] = { 1, 0, -1, 0 };\n      int sy = s.p.y;\n      int sx = s.p.x;\n      int sd = s.d.face[D];\n      Dice sdice = s.d;\n      Dice tmp = sdice;\n      if (checked[sy][sx][sdice.face[D]]) {\n        continue;\n      }\n      checked[sy][sx][sdice.face[D]] = true;\n      for (int i = 0; i < 4; i++) {\n        int ny = sy + dy[i];\n        int nx = sx + dx[i];\n        if (ny < 0 || ny >= h) {\n          continue;\n        }\n        if (nx < 0 || nx >= w) {\n          continue;\n        }\n        tmp = sdice;\n        Dice d = tmp.turn(i);\n        \n        if (checked[ny][nx][d.face[D]]) {\n          continue;\n        }\n        if (dist[sy][sx][sd] + field[ny][nx] * d.face[D] < dist[ny][nx][d.face[D]]) {\n          dist[ny][nx][d.face[D]] = dist[sy][sx][sd] + field[ny][nx] * d.face[D];\n          q.push(State(Point(ny, nx), d));\n        } \n      }\n    }\n    \n    int ans = INF;\n    for (int i = 1; i < 7; i++) {\n      ans = min(ans, dist[goal.y][goal.x][i]);\n    }  \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int INF = (1<<29);\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,1,0,-1};\nint h,w;\n\nclass state{\npublic:\n  int y,x, up,n,e, cost;\n};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nint main(){\n  while(cin >> h >> w && (h|w)){\n    int a[11][11],b[11][11][6][6][6],gx,gy,ans=INF;\n    state u,v;\n    queue<state> Q;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> a[i][j];\n        for(int k=0;k<6;k++) for(int l=0;l<36;l++) b[i][j][k][l/6][l%6] = INF;\n      }\n    }\n    cin >> u.y >> u.x >> gy >> gx;\n    b[u.y][u.x][0][4][2] = 0;\n    u.up = 1;\n    u.n = 5;\n    u.e = 3;\n    u.cost = 0;\n    Q.push(u);\n\n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n\n      if(u.y == gy && u.x == gx){\n        ans = min(ans,u.cost);\n        continue;\n      }\n\n      for(int i=0;i<4;i++){\n        v = u;\n        v.y += dy[i];\n        v.x += dx[i];\n        if(!check(v.y,v.x)) continue;\n        if(i == 0){\n          v.up = 7 - u.n;\n          v.n = u.up;\n        } else if(i == 1){\n          v.up = 7 - u.e;\n          v.e = u.up;\n        } else if(i == 2){\n          v.up = u.n;\n          v.n = 7 - u.up;\n        } else if(i == 3){\n          v.up = u.e;\n          v.e = 7 - u.up;\n        }\n        v.cost += a[v.y][v.x] * (7 - v.up);\n        if(b[v.y][v.x][v.up-1][v.n-1][v.e-1] > v.cost){\n          b[v.y][v.x][v.up-1][v.n-1][v.e-1] = v.cost;\n          Q.push(v);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\n\nint H[6][6] = {\n\t{1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n\t{3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n\t{2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n\t{4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n\t{0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n\t{0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[6] = {0,1,-1,0,0,0};\nint dy[6] = {-1,0,0,1,0,0};\n// 高さと幅\nint h, w;\n// s[y][x] := (x,y)のマスに書かれた数字\nint s[11][11];\n\n\n// サイコロライブラリ\n// d[0] := top\n// d[1] := front \n// d[2] := right\n// d[3] := left\n// d[4] := back\n// d[5] := bottom\nstruct Cube{\n\tint x,y;\n\tvector<int> d;\n\t// コンストラクタで初期化\n\tCube(vector<int> v, int x_, int y_){\n\t\tx = x_; y = y_;\n\t\tif( v.size() == 6 ){\n\t\t\td = v;\n\t\t}else{\n\t\t\td = vector<int> (6);\n\t\t}\n\t}\n\t// dirの方向に回転 (副作用なし)\n\tCube roll(int dir){\n\t\tCube result = (*this);\n\t\tvector<int> d_(6);\n    \tfor(int i = 0 ; i < 6 ; i++ ){\n        \td_[i] = d[ H[dir][i] ];\n    \t}\n    \tresult.d = d_;\n    \tresult.x += dx[dir];\n    \tresult.y += dy[dir];\n    \treturn result;\n    }\n};\nbool operator<(const Cube& c1, const Cube& c2){\n\treturn P(c1.x,c1.y) < P(c2.x,c2.y);\n}\n\ntypedef pair<int,Cube> State;\n\n// ゴール g, 初期のキューブの状態 c からのダイクストラ法\nint dijkstra(Cube c , P g){\n\t// greater<State> を指定することで コスト が小さい順に取り出せる\n\tpriority_queue<State, vector<State>, greater<State> > q;\n\t\n\t// d[cube] := cube にたどり着く最小コスト. (cubeは位置のキューブの状態を持っている)\n\tmap<Cube,int> d;\n\t\n\td[c] = 0;\n\tState start( 0 , c );\n\tq.push( start );\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\tint now_cost = q.top().first;\n\t\tCube c = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif( P(c.x,c.y) == g ){\n\t\t\tresult = now_cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int dir=0 ; dir < 6 ; dir++ ){\n\t\t\tCube c_ = c.roll( dir );\n\t\t\tif( c_.x < 0 || c_.y < 0 || c_.x >= w || c_.y >= h ) continue;\n\t\t\t\n\t\t\tint next_cost = now_cost + s[c_.y][c_.x] * c_.d[5];\n\t\t\tif( d.count(c_) == 0 ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}else if( next_cost < d[c_] ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tvector<int> v(6);\n\tv[0] = 1; v[5] = 6;\n\tv[1] = 2; v[4] = 5;\n\tv[2] = 3; v[3] = 4;\t\n\t\n\twhile( cin >> h >> w , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tCube c( v, sx, sy );\n\t\tint ans = dijkstra( c , P(gx,gy) );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef vector<int> Dice;\nenum {TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\n#define rotate_swap(x, a, b, c, d) swap(x[a], x[b]); swap(x[b], x[c]); swap(x[c], x[d]);\n\nvoid rotate_r(Dice &dice) {rotate_swap(dice, TOP, LEFT, BOTTOM, RIGHT);}\nvoid rotate_l(Dice &dice) {rotate_swap(dice, TOP, RIGHT, BOTTOM, LEFT);}\nvoid rotate_f(Dice &dice) {rotate_swap(dice, TOP, BACK, BOTTOM, FRONT);}\nvoid rotate_b(Dice &dice) {rotate_swap(dice, TOP, FRONT, BOTTOM, BACK);}\n\nstruct Status {\n  int x, y, cost;\n  Dice d;\n  bool operator<(const Status &s) const {return cost > s.cost;}\n};\n\nint main() {\n  while (true) {\n    int h, w;\n    cin >> h >> w;\n    if (h == 0) break;\n    int board[h][w];\n    rep (i, h) rep (j, w) cin >> board[i][j];\n    int x1, y1, x2, y2;\n    cin >> y1 >> x1 >> y2 >> x2;\n    int dis[h][w][6][6][6];\n    memset(dis, -1, sizeof(dis));\n    priority_queue<Status> que;\n    Dice d(6);\n    rep (i, 6) d[i] = i + 1;\n    que.push((Status){x1, y1, 0, d});\n    while (!que.empty()) {\n      Status now = que.top();\n      que.pop();\n      if (now.y == y2 && now.x == x2) {\n\tcout << now.cost << endl;\n\tbreak;\n      }\n      if (now.x < 0 || w <= now.x || now.y < 0 || h <= now.y) continue;\n      if (dis[now.y][now.x][now.d[TOP]][now.d[FRONT]][now.d[RIGHT]] != -1) continue;\n      dis[now.y][now.x][now.d[TOP]][now.d[FRONT]][now.d[RIGHT]] = now.cost;\n      Dice d1 = now.d, d2 = now.d, d3 = now.d, d4 = now.d;\n      rotate_r(d1);\n      rotate_l(d2);\n      rotate_f(d3);\n      rotate_b(d4);\n      if (now.x < w - 1) que.push((Status){now.x + 1, now.y, now.cost + d1[BOTTOM] * board[now.y][now.x + 1], d1});\n      if (0 < now.x) que.push((Status){now.x - 1, now.y, now.cost + d2[BOTTOM] * board[now.y][now.x - 1], d2});\n      if (now.y < h - 1) que.push((Status){now.x, now.y + 1, now.cost + d3[BOTTOM] * board[now.y + 1][now.x], d3});\n      if (0 < now.y) que.push((Status){now.x, now.y - 1, now.cost + d4[BOTTOM] * board[now.y - 1][now.x], d4});\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nint field[11][11];\n\nstruct Point {\npublic:\n  int y, x;\n  \n  Point(int y, int x):y(y), x(x) { }\n  Point() { };\n  \n  void operator=(Point p) {\n    this->y = p.y;\n    this->x = p.x;\n  }\n};\n\nenum { U, F, R, D, B, L };\n\nstruct Dice {\npublic:\n  int face[6];\n  \n  Dice() { face[F] = 2; face[R] = 3; face[U] = 1; face[B] = 5; face[L] = 4; face[D] = 6; }\n  \n  Dice(const Dice& d) {\n    for (int i = 0; i < 6; i++) {\n      face[i] = d.face[i];\n    }  \n  }\n  \n  Dice turn(int dir) {\n    switch (dir) {\n      case 0: rotate(U, R, D, L); break;\n      case 1: rotate(D, B, U, F); break;\n      case 2: rotate(U, L, D, R); break;\n      case 3: rotate(D, F, U, B); break;\n    } \n    return *this;\n  }\n  \n  int &operator[](int n) { \n    return face[n];\n  }\n  \n  void rotate(int a, int b, int c, int d) {\n    int t = face[d];\n    face[d] = face[c];\n    face[c] = face[b];\n    face[b] = face[a];\n    face[a] = t;\n  }\n  \n};\n\nPoint start, goal;\nint h, w;\n\nstruct State {\npublic:\n  Point p;\n  Dice d;\n  State(Point p): p(p) { }\n  State(Point p, Dice d):p(p), d(d) { }\n};\n\n\n\nint main() {\n  Dice tmp;\n  \n  int y, x;\n  while (true) {\n    cin >> h >> w;\n    if (h + w == 0) {\n      break;\n    }\n    memset(field, 0, sizeof(field));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        int f;\n        cin >> f;\n        field[i][j] = f;\n      }\n    }\n    cin >> y >> x;\n    start = Point(y, x);\n    cin >> y >> x;\n    goal = Point(y, x);\n    \n    queue<State> q;\n\n    int dist[11][11][7];    \n    for (int i = 0; i < 11; i++) {\n      for (int j = 0; j < 11; j++) {\n        for (int k = 0; k < 7; k++) {\n          dist[i][j][k] = INF;\n        }\n      }\n    }  \n    \n    dist[start.y][start.x][6] = 0;\n    \n    q.push(State(start));\n\n    bool checked[11][11][7] = { false };    \n    while (!q.empty()) {\n      State s = q.front(); q.pop();\n      \n      int dy[4] = { 0, 1, 0, -1 };\n      int dx[4] = { 1, 0, -1, 0 };\n      int sy = s.p.y;\n      int sx = s.p.x;\n      int sd = s.d.face[D];\n      Dice sdice = s.d;\n      Dice tmp = sdice;\n      if (checked[sy][sx][sdice.face[D]]) {\n        continue;\n      }\n      checked[sy][sx][sdice.face[D]] = true;\n      for (int i = 0; i < 4; i++) {\n        int ny = sy + dy[i];\n        int nx = sx + dx[i];\n        if (ny < 0 || ny >= h) {\n          continue;\n        }\n        if (nx < 0 || nx >= w) {\n          continue;\n        }\n        tmp = sdice;\n        Dice d = tmp.turn(i);\n        \n        if (checked[ny][nx][d.face[D]]) {\n          continue;\n        }\n        if (dist[sy][sx][sd] + field[ny][nx] * d.face[D] < dist[ny][nx][d.face[D]]) {\n          dist[ny][nx][d.face[D]] = dist[sy][sx][sd] + field[ny][nx] * d.face[D];\n          q.push(State(Point(ny, nx), d));\n        } \n      }\n    }\n    \n    int ans = INF;\n    for (int i = 1; i < 7; i++) {\n      ans = min(ans, dist[goal.y][goal.x][i]);\n    }  \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  T var[6];\n  dice(T *v) {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n    REP(i,6)\n      var[i] = v[i];\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n           a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n           a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    int tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  int id[6];\n};\n\nbool operator < (const dice<int> &a, const dice<int> &b) {\n  REP(i, 6) {\n    if (a.var[i] != b.var[i])\n      return a.var[i] < b.var[i];\n  }\n  return true;\n}\n\nstruct P {\n  int cost;\n  int x;\n  int y;\n  dice<int> di;\n  P(int cost,int x,int y,dice<int> di) : cost(cost),x(x),y(y),di(di) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.cost>b.cost;\n}\n\n  \n\nint main() {\n  int h, w;\n  while(cin>>h>>w,h) {\n    int ba[w][h];\n    REP(y,h)\n      REP(x,w)\n        cin >> ba[x][y];\n    int sx,sy,gx,gy;\n    cin>>sy>>sx>>gy>>gx;\n\n    int arr[] = {1,2,4,3,5,6};\n    dice<int> di(arr);\n\n    priority_queue<P> Q;\n    Q.push(P(0,sx,sy,di));\n    map<dice<int>,bool> visited[w][h];\n//    memset(visited,0,sizeof(visited));\n    int res[w][h];\n    REP(x,w) REP(y,h)\n      res[x][y] = INF;\n    res[sx][sy] = 0;\n    while(!Q.empty()) {\n      P p =Q.top();\n      Q.pop();\n      int x=p.x,y=p.y,cost=p.cost;\n      dice<int> nd = p.di;\n      if (visited[x][y][nd]) continue;\n      visited[x][y][nd] = 1;\n      const int dx[] = {0,1,0,-1};\n      const int dy[] = {-1,0,1,0};\n      REP(k,4) {\n        int xx = x+dx[k];\n        int yy = y+dy[k];\n        if (xx<0||xx>=w||yy<0||yy>=h) continue;\n\n        dice<int> tmp = nd;\n        if (k == 0) { tmp.roll_x();tmp.roll_x();tmp.roll_x(); }\n        else if (k == 1) tmp.roll_y();\n        else if (k == 2) tmp.roll_x();\n        else { tmp.roll_y();tmp.roll_y();tmp.roll_y(); }\n\n        if (res[xx][yy] > cost + tmp[BOTTOM]*ba[xx][yy]) {\n          res[xx][yy] = cost + tmp[BOTTOM]*ba[xx][yy];\n          Q.push(P(res[xx][yy], xx,yy, tmp));\n        }\n      }\n    }\n    cout << res[gx][gy] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint rol[4][4]={\n\t{4,5,2,0},\n\t{1,0,3,5},\n\t{0,2,5,4},\n\t{5,3,0,1}\n};\nvi a;\nvoid roll(int b){\n\tint tmp=a[2+rol[b][0]];\n\trep(i,3)a[2+rol[b][i]]=a[2+rol[b][i+1]];\n\ta[2+rol[b][3]]=tmp;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(m));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\tint sx,sy,gx,gy;\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tvi q(8);\n\t\tq[0]=sx;q[1]=sy;q[2]=1;q[3]=2;\n\t\tq[4]=3;q[5]=5;q[6]=4;q[7]=6;\n\t\tmap<vi,int>ma;\n\t\tint out=inf;\n\t\tpriority_queue<pair<int,vi> >que;\n\t\tque.push(pair<int,vi>(0,q));\n\t\twhile(!que.empty()){\n\t\t\tvi w=que.top().second;\n\t\t\tint t=-que.top().first;\n\t\t\tque.pop();\n\t\t\tif(ma[w]<t)continue;\n\t\t\trep(i,4){\n\t\t\t\ta=w;\n\t\t\t\ta[0]+=dx[i];\n\t\t\t\ta[1]+=dy[i];\n\t\t\t\tif(a[0]<0||a[1]<0||a[0]>=n||a[1]>=m)continue;\n\t\t\t\troll(i);\n\t\t\t\tint cost=t+a[7]*in[a[0]][a[1]];\n\t\t\t\tif(ma[a]==0||ma[a]>cost){\n\t\t\t\t\tma[a]=cost;\n\t\t\t\t\tque.push(pair<int,vi>(-cost,a));\n\t\t\t\t\tif(a[0]==gx&&a[1]==gy)out=min(out,cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<'L'<<__LINE__<<\": \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tos<<'(';\n\tprint_tuple<Args...>(os,t);\n\treturn os<<')';\n}\n\nstruct Die{\n\tarray<int,6> faces;\n\tDie(){\n\t\tfaces[0]=2; faces[1]=5;\n\t\tfaces[2]=3; faces[3]=4;\n\t\tfaces[4]=1; faces[5]=6;\n\t}\n\tvoid Rotate(int a,int b,int c,int d){\n\t\tswap(faces[a],faces[b]);\n\t\tswap(faces[b],faces[c]);\n\t\tswap(faces[c],faces[d]);\n\t}\n\tvoid TurnU(){Rotate(4,0,5,1);}\n\tvoid TurnD(){Rotate(4,1,5,0);}\n\tvoid TurnL(){Rotate(4,2,5,3);}\n\tvoid TurnR(){Rotate(4,3,5,2);}\n};\nbool operator<(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(a.faces),end(a.faces),begin(b.faces),end(b.faces));\n}\nbool operator>(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(b.faces),end(b.faces),begin(a.faces),end(a.faces));\n}\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\tusing first_argument_type=decltype(helper(&Functor::operator()));\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvector<vector<int>> grid(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>grid[i][j];\n\t\tint si,sj,gi,gj; cin>>si>>sj>>gi>>gj;\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<Die,int,int,int> a,tuple<Die,int,int,int> b){\n\t\t\treturn get<3>(a)>get<3>(b);\n\t\t});\n\t\tpq.emplace(Die(),si,sj,0);\n\t\tset<tuple<Die,int,int>> vis;\n\t\twhile(pq.size()){\n\t\t\tDie d; int i,j,c; tie(d,i,j,c)=pq.top(); pq.pop();\n\t\t\tif(vis.count(make_tuple(d,i,j))) continue;\n\t\t\tif(i==gi && j==gj){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfunction<void(Die&)> turns[]={&Die::TurnU,&Die::TurnD,&Die::TurnL,&Die::TurnR};\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w){\n\t\t\t\t\tDie t=d;\n\t\t\t\t\tturns[k](t);\n\t\t\t\t\tpq.emplace(t,ni,nj,c+t.faces[5]*grid[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n           a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n           a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\n    bool operator<(const dice<T>& b)const{\n\t\tconst dice<T> &a = *this;\n\t\tif(a[TOP]==b[TOP]){\n\t\t\tif(a[FRONT]==b[FRONT]){\n\t\t\t\treturn a[RIGHT]<b[RIGHT];\n\t\t\t}\n\t\t\treturn a[FRONT]<b[FRONT];\n\t\t}\n\t\treturn a[TOP]<b[TOP];\n    }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nstruct node{\n    int y,x,cost;\n\tdice<int> di;\n    node(int y,int x,dice<int> di,int cost):y(y),x(x),di(di),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\n\nconst int MAX=INT_MAX/10;\ntypedef map<dice<int>,int> md;\ntypedef vector<md> vm;\ntypedef vector<vm> vvm;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\nint main(){\n    int h,w;\n    while(cin>>h>>w,h){\n        vvi field(h,vi(w));\n        REP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n        }\n\t\tpii start,goal;\n\t\tcin>>start.first>>start.second;\n\t\tcin>>goal.first>>goal.second;\n\n        priority_queue<node> q;\n\t\tdice<int> start_die;\n\t\tstart_die[TOP]=1;\n\t\tstart_die[FRONT]=2;\n\t\tstart_die[RIGHT]=3;\n\t\tstart_die[BOTTOM]=6;\n\t\tstart_die[BACK]=5;\n\t\tstart_die[LEFT]=4;\n\t\tq.push(node(start.first,start.second,start_die,0));\n\t\tvector<dice<int> > all_rolls=start_die.all_rolls();\n        vvm cost(h,vm(w,md()));\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tREP(k,all_rolls.size()){\n\t\t\t\t\tcost[i][j][all_rolls[k]]=MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[start.first][start.second][start_die]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.y][cnode.x][cnode.di]<cnode.cost){\n                continue;\n            }\n\t\t\tREP(i,4){\n\t\t\t\tint x=cnode.x+dx[i];\n\t\t\t\tint y=cnode.y+dy[i];\n\t\t\t\tif(x>=0&&y>=0&&x<w&&y<h){\n\t\t\t\t\tdice<int> newdie(cnode.di);\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tREP(j,3)newdie.roll_y();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tREP(j,3)newdie.roll_x();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tnewdie.roll_y();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tnewdie.roll_x();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint newcost=cnode.cost+field[y][x]*newdie[BOTTOM];\n\t\t\t\t\tif(cost[y][x][newdie]>newcost){\n\t\t\t\t\t\tcost[y][x][newdie]=newcost;\n\t\t\t\t\t\tq.push(node(y,x,newdie,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tint ans=MAX;\n\t\tREP(i,all_rolls.size()){\n\t\t\tans=min(ans,cost[goal.first][goal.second][all_rolls[i]]);\n\t\t}\n\t\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstruct _nd {\n\tint cost;\n\tint x,y;\n\tint a,b,c;\n};\nint main()\n{\n\tint h,w;\n\tconst int dx[] = {0,1,0,-1}; // up, right, down, left\n\tconst int dy[] = {-1,0,1,0};\n\tconst int inf = 99999999;\n\twhile( cin>>h>>w, h|w ){\n\t\tint field[10][10];\n\t\tint memo[7][7][7][10][10];\n\t\tint sx,sy,gx,gy;\n\t\tint ans = inf;\n\t\t\n\t\tfor(int a=0; a<7; a++)for(int b=0; b<7; b++)for(int c=0; c<7; c++)\n\t\t\tfor(int d=0; d<10; d++)for(int e=0; e<10; e++)memo[a][b][c][d][e] = inf;\n\t\tfor(int i=0; i<h; i++)\n\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\tcin>>field[i][j];\n\t\t\n\t\tcin>>sy>>sx;\n\t\tcin>>gy>>gx;\n\t\t\n\t\tstruct _nd nd;\n\t\tnd.cost = 0;\n\t\tnd.x=sx; nd.y=sy;\n\t\tnd.a=1; nd.b=2; nd.c=3;\n\t\tvector< struct _nd > vs;\n\t\tvs.push_back( nd );\n\t\tmemo[1][2][3][sy][sx] = 0;\n\t\twhile( vs.size() ){\n\t\t\tint tmin = inf;\n\t\t\tint ind;\n\t\t\tfor(int i=0; i<vs.size(); i++){\n\t\t\t\tif( tmin > vs[i].cost ){\n\t\t\t\t\ttmin = vs[i].cost;\n\t\t\t\t\tind = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd = vs[ind];\n\t\t\tif( (nd.x==gx && nd.y==gy) || nd.cost>=ans )break;\n\t\t\tvs.erase( vs.begin()+ind );\n\t\t\t\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tint tx = nd.x + dx[k];\n\t\t\t\tint ty = nd.y + dy[k];\n\t\t\t\tint na = k==0 ? nd.b   : k==1 ? 7-nd.c : k==2 ? 7-nd.b : nd.c ;\n\t\t\t\tint nb = k==0 ? 7-nd.a : k==1 ? nd.b   : k==2 ? nd.a   : nd.b ;\n\t\t\t\tint nc = k==0 ? nd.c   : k==1 ? nd.a   : k==2 ? nd.c   : 7-nd.a ;\n\t\t\t\t\n\t\t\t\t//printf(\"k:%d  (%d,%d),[na:nb:nc]=[%d:%d:%d]\\n\",k,tx,ty,na,nb,nc);\n\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h ||\n\t\t\t\t\t\tmemo[na][nb][nc][ty][tx] <= field[ty][tx]*(7-na)+nd.cost ) continue;\n\t\t\t\t//printf(\"k:%d  (%d,%d),[na:nb:nc]=[%d:%d:%d]  _old[%d:%d:%d]\\n\",k,tx,ty,na,nb,nc\n\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nd.a,nd.b,nd.c);\n\t\t\t\tmemo[na][nb][nc][ty][tx] = field[ty][tx]*(7-na) + nd.cost;\n\t\t\t\tif( tx==gx && ty==gy ){ ans = min( ans, field[ty][tx]*(7-na) + nd.cost ); }\n\t\t\t\t//printf(\"memo[%d][%d][%d][%d][%d] = %d\\n\",na,nb,nc,ty,tx,field[ty][tx]*(7-na) + nd.cost);\n\t\t\t\tstruct _nd tmp = {field[ty][tx]*(7-na)+nd.cost, tx, ty, na, nb, nc};\n\t\t\t\tvs.push_back( tmp );\n\t\t\t}\n\t\t\t//printf(\"_\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\n#define NORTH\t\t(0)\n#define SOUTH\t\t(1)\n#define EAST\t    (2)\n#define WEST\t\t(3)\n\ntypedef struct {\n\tint face[6];\n} DICE;\n\ntypedef struct {\n\tint cost;\n\tint x, y;\n\tDICE dice;\n} DATA;\n\nbool operator<(const DATA& a, const DATA& b)\n{\n\treturn (a.cost > b.cost);\n}\n\nvoid rote(int dir, const DICE& in, DICE* out)\n{\n\tswitch (dir)\n\t{\n\t  case NORTH:\n\t  \tout->face[0] = in.face[1];\n\t\tout->face[1] = in.face[2];\n\t\tout->face[2] = in.face[3];\n\t\tout->face[3] = in.face[0];\n\t\tout->face[4] = in.face[4];\n\t\tout->face[5] = in.face[5];\n\t\tbreak;\n\t  case SOUTH:\n\t  \tout->face[0] = in.face[3];\n\t\tout->face[1] = in.face[0];\n\t\tout->face[2] = in.face[1];\n\t\tout->face[3] = in.face[2];\n\t\tout->face[4] = in.face[4];\n\t\tout->face[5] = in.face[5];\n\t\tbreak;\n\t  case EAST:\n\t  \tout->face[0] = in.face[5];\n\t\tout->face[1] = in.face[1];\n\t\tout->face[2] = in.face[4];\n\t\tout->face[3] = in.face[3];\n\t\tout->face[4] = in.face[0];\n\t\tout->face[5] = in.face[2];\n\t\tbreak;\n\t  case WEST:\n\t  \tout->face[0] = in.face[4];\n\t\tout->face[1] = in.face[1];\n\t\tout->face[2] = in.face[5];\n\t\tout->face[3] = in.face[3];\n\t\tout->face[4] = in.face[2];\n\t\tout->face[5] = in.face[0];\n\t\tbreak;\n\t}\n}\n\nint main(void)\n{\n\tDATA add;\n\tint field[12][12];\n\tint h, w;\n\tint sx, sy;\n\tint gx, gy;\n\t\n\twhile (1){\n\t\tpriority_queue<DATA> pq;\n\t\tscanf(\"%d%d\", &h, &w);\n\t\t\n\t\tif (!h)break;\n\t\t\n\t\tmemset(field, -1, sizeof(field));\n\t\tfor (int y = 1; y <= h; y++){\n\t\t\tfor (int x = 1; x <= w; x++){\n\t\t\t\tscanf(\"%d\", &field[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &sy, &sx);\n\t\tscanf(\"%d%d\", &gy, &gx);\n\t\t\n\t\tadd.x = sx + 1;\n\t\tadd.y = sy + 1;\n\t\tadd.cost = 0;\n\t\tadd.dice.face[0] = 1;\n\t\tadd.dice.face[1] = 2;\n\t\tadd.dice.face[2] = 6;\n\t\tadd.dice.face[3] = 5;\n\t\tadd.dice.face[4] = 3;\n\t\tadd.dice.face[5] = 4;\n\t\t\n\t\tpq.push(add);\n\t\t\n\t\twhile (!pq.empty()){\n\t\t\tconst DATA &d = pq.top();\n\t\t\t\n\t\t\t\n\t\t\tif (d.x == gx + 1 && d.y == gy + 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd.x = d.x;\n\t\t\tadd.y = d.y - 1;\n\t\t\trote(NORTH, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x;\n\t\t\tadd.y = d.y + 1;\n\t\t\trote(SOUTH, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x + 1;\n\t\t\tadd.y = d.y;\n\t\t\trote(EAST, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\tadd.x = d.x - 1;\n\t\t\tadd.y = d.y;\n\t\t\trote(WEST, d.dice, &add.dice);\n\t\t\tadd.cost = d.cost + field[add.x][add.y] * add.dice.face[2];\n\t\t\tif (field[add.x][add.y] != -1){\n\t\t\t\tpq.push(add);\n\t\t\t}\n\t\t\t\n\t\t\tpq.pop();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", pq.top().cost);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost > s.cost;\n  }\n};\n\nstruct mstruct{\n  int y, x;\n  Dice d;\n\n  bool operator<(const mstruct &m) const{\n    return y == m.y ? x < m.x : y < m.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<mstruct, int> m;\n    mstruct ms;\n    ms.y = sy; ms.x = sx;\n    ms.d.t = 1; ms.d.s = 2; s.d.e = 3;\n    m[ms] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx){\n\t// res = min(res, now.cost);\n\tprintf(\"%d\\n\", now.cost);\n\tgoto e;\n      }\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\t//\tprintf(\"%d\\n\", next.cost);\n\tmstruct ns;\n\tns.y = ny; ns.x = nx;\n\tns.d.t = next.d.t; ns.d.s = next.d.s; ns.d.e = next.d.e;\n\tif(m.count(ns) != 0  && m[ns] <= next.cost) continue;\n\tm[ns] = next.cost;\n\t//\t  printf(\"%d %d\\n\", ny, nx);\n\t/*\t  if(ny == gy && nx == gx){\n\t\t  res = min(res, next.cost);\n\t\t  break;\n\t\t  }*/\n\tq.push(next);\n      }\n    }\n\n    //    printf(\"%d\\n\", res==INF?0:res);\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\n\nconst int TOP = 0;\nconst int BOTTOM = 1;\nconst int LEFT = 2;\nconst int BACK = 3;\nconst int RIGHT = 4;\nconst int FRONT = 5;\nclass Saikoro {\npublic:\n    int V[6]; \n    bool nullType;\n    Saikoro( int a, int b ) {\n        V[TOP] = a;\n        V[BOTTOM] = 7 - a;\n        V[FRONT] = b;\n        V[BACK] = 7 - b;\n        const int T[6][4] = {\n            { 2, 3, 5, 4 },\n            { 1, 4, 6, 3 },\n            { 6, 5, 1, 2 },\n            { 1, 5, 6, 2 },\n            { 3, 6, 4, 1 },\n            { 3, 2, 4, 5 }\n        };\n        for ( int i = 0; i < 4; ++ i ) {\n            if ( T[a-1][i] == b ) {\n                int left = i - 1;\n                if ( left < 0 ) left = 3;\n                V[LEFT] = T[a-1][left];\n                break;\n            }\n        }\n        V[RIGHT] = 7 - V[LEFT];\n        nullType = false;\n    }\n    int getV( int dir ) {\n        return V[2+dir];\n    }\n    int getTop() {\n        return V[TOP];\n    }\n    int getBottom() {\n        return V[BOTTOM];\n    }\n    void rollLeft() {\n        int NV[6];\n        NV[FRONT] = V[FRONT];\n        NV[BACK] = V[BACK];\n        NV[LEFT] = V[TOP];\n        NV[TOP] = V[RIGHT];\n        NV[RIGHT] = V[BOTTOM];\n        NV[BOTTOM] = V[LEFT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void rollRight() {\n        int NV[6];\n        NV[FRONT] = V[FRONT];\n        NV[BACK] = V[BACK];\n        NV[LEFT] = V[BOTTOM];\n        NV[BOTTOM] = V[RIGHT];\n        NV[RIGHT] = V[TOP];\n        NV[TOP] = V[LEFT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void rollFront() {\n        int NV[6];\n        NV[LEFT] = V[LEFT];\n        NV[RIGHT] = V[RIGHT];\n        NV[FRONT] = V[TOP];\n        NV[TOP] = V[BACK];\n        NV[BACK] = V[BOTTOM];\n        NV[BOTTOM] = V[FRONT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void rollBack() {\n        int NV[6];\n        NV[LEFT] = V[LEFT];\n        NV[RIGHT] = V[RIGHT];\n        NV[FRONT] = V[BOTTOM];\n        NV[BOTTOM] = V[BACK];\n        NV[BACK] = V[TOP];\n        NV[TOP] = V[FRONT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void roll( int dir ) {\n        if ( dir == 0 ) rollLeft();\n        if ( dir == 1 ) rollBack();\n        if ( dir == 2 ) rollRight();\n        if ( dir == 3 ) rollFront();\n    }\n    Saikoro() {\n        nullType = true;\n    }\n};\n\nbool operator < ( const Saikoro& a , const Saikoro& b ) {\n    VI ad = VI( a.V, a.V+6 ), bd = VI( b.V, b.V+6 );\n    return ad < bd;\n}\n \nostream& operator << ( ostream& os, Saikoro s ) {\n    const string T[6] = { \"TOP\", \"BOTTOM\", \"LEFT\", \"BACK\", \"RIGHT\", \"FRONT\" };\n    os << \"{\";\n    for ( int i = 0; i < 6; ++ i ) {\n        os << T[i] << \":\" << s.V[i];\n        if ( i + 1 < 6 ) os << \", \";\n    }\n    os << \"}\";\n    return os;\n}\n\nconst int SIZE = 11;\nint h, w;\nint M[SIZE][SIZE];\nint sr, sc, gr, gc;\n\nbool input() {\n    if ( ! ( cin >> h >> w && h ) ) return false;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cin >> M[i][j];\n        }\n    }\n    cin >> sr >> sc >> gr >> gc;\n    return true;\n}\n\ntypedef pair <II, Saikoro> STATE;\ntypedef pair <int, STATE> NODE;\ntypedef priority_queue <NODE, vector<NODE>, greater<NODE> > QUEUE;\nconst int dr[4] = { 0, -1, 0, 1 };\nconst int dc[4] = { -1, 0, 1, 0 };\nint MC[SIZE][SIZE];\nQUEUE Q;\nint solve() {\n    STATE start_state( II( sr, sc ), Saikoro( 1, 2 ) );\n    Q = QUEUE();\n    Q.push( NODE( 0, start_state ) );\n    fill( (int*)MC, (int*)MC+SIZE*SIZE, INT_MAX );\n\n    while ( ! Q.empty() ) {\n        NODE node = Q.top();\n        Q.pop();\n\n        int steps = node.first;\n        int r = node.second.first.first;\n        int c = node.second.first.second;\n        Saikoro s = node.second.second;\n\n        if ( r == gr && c == gc ) return steps;\n\n        for ( int i = 0; i < 4; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( nr < 0 || nr >= h || nc < 0 || nc >= w ) continue;\n            Saikoro ns = s;\n            ns.roll(i);\n            int nsteps = steps + M[nr][nc] * ns.getBottom();\n            if ( nsteps >= MC[nr][nc] ) continue;\n            MC[nr][nc] = nsteps;\n            NODE next( nsteps, STATE( II( nr, nc ), ns ) );\n            Q.push( next );\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while ( input() ) {\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\ntypedef pair<int , int> P;\ntypedef pair<P,P> P2;\n\nint h,w;\nint g[30][30];\nint d[30][30][50000];\n\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r[4][6] = { {1,5,2,3,0,4},\n\t\t{3,1,0,5,4,2},\n\t\t{4,0,2,3,5,1},\n\t\t{2,1,5,0,4,3} };\n\nvector<int> trans(int n){\n  vector<int> res;\n  while(n>0){\n    res.push_back(n%6);\n    n/=6;\n  }\n  while(res.size()<6)res.push_back(0);\n  return res;\n}\n\nint rot(int n,int dir){\n  int tmp[6];\n  vector<int> die = trans(n);\n  for(int i=0;i<6;i++)tmp[i] = die[r[dir][i]];\n\n  int res = 0, k = 1;\n  for(int i=0;i<6;i++){\n    res += tmp[i] * k;\n    k *= 6;\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<50000;k++)d[i][j][k] = 100000000;\n      }\n    }\n\n    int sy,sx,gy,gx;\n    cin >> sy >> sx >> gy >> gx;\n    \n    priority_queue<P2> q;\n    q.push(P2(P(0,44790),P(sy,sx)));\n    d[sy][sx][44790] = 0;\n\n    while(!q.empty()){\n      P2 p = q.top();q.pop();\n      int s = p.first.first , num = p.first.second;\n      int y = p.second.first , x = p.second.second;\n\n      for(int i=0;i<4;i++){\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(ny<0 || nx<0 || h<=ny || w<=nx)continue;\n\tint nnum = rot(num,i);\n\t//cout << \"[\" << nnum << \"]\" << endl;\n\tvector<int> die = trans(nnum);\n\t//for(int j=0;j<6;j++)cout << die[j] << \" \";\n\t//cout << endl;\n\tif(d[ny][nx][nnum] > d[y][x][num] + g[ny][nx]*(die[5]+1)){\n\t  //cout << nnum << endl;\n\t  d[ny][nx][nnum] = d[y][x][num] + g[ny][nx]*(die[5]+1);\n\t  q.push(P2(P(d[ny][nx][nnum],nnum),P(ny,nx)));\n\t}\n      }\n    }\n\n    int m = 100000000;\n    for(int i=0;i<50000;i++)m = min(m,d[gy][gx][i]);\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nenum direction{\n  UP    = 0,\n  RIGHT = 1,\n  DOWN  = 2,\n  LEFT  = 3\n};\n\n/*\n *   6\n *   2\n * 3 1 4\n *   5\n */\n\n/* top and RIGHT */\nint next_top[7][7][4];\nint next_left[7][7][4];\nint front[7][7];\n\nvoid initDie(){\n  front[1][3] = 2; front[1][2] = 4; front[1][4] = 5; front[1][5] = 3;\n  front[2][1] = 3; front[2][3] = 6; front[2][4] = 1; front[2][6] = 4;\n  front[3][1] = 5; front[3][2] = 1; front[3][5] = 6; front[3][6] = 2;\n  for(int i = 4; i < 7; i++){\n    for(int j = 1; j < 7; j++){\n      if(i == j || i + j == 7) continue;\n      int t = 7 - i;\n      int l = 7 - j;\n      front[i][j] = front[t][l];\n    }\n  }\n\n  for(int t = 1; t < 7; t++){\n    for(int l = 1; l < 7; l++){\n      if(t == l || t + l == 7) continue;\n\n      next_top[t][l][UP]     = 7 - front[t][l];\n      next_top[t][l][LEFT]   = 7 - l;\n      next_top[t][l][RIGHT]  = l;\n      next_top[t][l][DOWN]   = front[t][l];\n\n      next_left[t][l][UP]    = l;\n      next_left[t][l][LEFT]  = t;\n      next_left[t][l][RIGHT] = 7 - t;\n      next_left[t][l][DOWN]  = l;\n    }\n  }\n}\n\nint b[10][10];\nint memo[10][10][7][7];\n\nint main(){\n  int h,w;\n\n  initDie();\n\n  while((h = getInt()) + (w = getInt())){\n    REP(i,h) REP(j,w) b[i][j] = getInt();\n    int sy = getInt();\n    int sx = getInt();\n    int gy = getInt();\n    int gx = getInt();\n    typedef pair<int, pair<pair<int,int>,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    pq.push(mp(0, mp( mp(sx,sy), mp(1, 4))));\n    memset(memo, -1, sizeof(memo));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      int cost = d.f;\n      int x = d.s.f.f;\n      int y = d.s.f.s;\n      int t = d.s.s.f;\n      int l = d.s.s.s;\n\n      //printf(\"cost = %d, (%d,%d) (%d,%d)\\n\",cost,x,y,t,l);\n\n      if(x == gx && y == gy){\n        print(cost);\n        break;\n      }\n\n      if(memo[x][y][t][l] != -1)\n        continue;\n\n      memo[x][y][t][l] = cost;\n\n      REP(i,4){\n        int xx = x + _dx[i];\n        int yy = y + _dy[i];\n        if(!ISIN(xx,yy,w,h)) continue;\n        int tt = next_top[t][l][i];\n        int ll = next_left[t][l][i];\n\n        int cc = cost + (7 - tt) * b[yy][xx];\n\n        if(memo[xx][yy][tt][ll] == -1)\n          pq.push(mp(cc, mp( mp(xx,yy), mp(tt,ll))));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\ntypedef struct{\n  int t,b,n,w,s,e;\n}dice;\n\ntypedef struct{\n  int x,y;\n  int cost;\n  dice d;\n}state;\n\n\nmain(){\n  int h,w;\n  while(cin>>h>>w,h|w){\n    int cost[h][w][6*6];\n    rep(i,h)rep(j,w)rep(k,36)cost[i][j][k]=INT_MAX;\n\n    dice td;\n    td.t=1;\n    td.b=6;\n    td.s=2;\n    td.n=5;\n    td.e=3;\n    td.w=4;\n\n    int pen[h][w];\n    rep(i,h)rep(j,w)cin>>pen[i][j];\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n\n    queue<state> Q;\n    state tstate={sx,sy,0,td};\n    Q.push(tstate);\n    cost[sx][sy][6+4]=0;\n\n    int ans=INT_MAX;\n\n    while(!Q.empty()){\n      tstate=Q.front();Q.pop();\n\n      int cx=tstate.x,cy=tstate.y;\n      int ccost=tstate.cost;\n      dice cd=tstate.d;\n      if(ccost>ans)continue;\n      if(cx==gx && cy==gy){\n\tans=ccost;\n\tcontinue;\n      }\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || ny<0 || h<=nx || w<=ny)continue;\n\tdice nd=cd;\n\tint t=nd.t;\n\tswitch(i){\n\tcase 0://e\n\t  nd.t=nd.w;\n\t  nd.w=nd.b;\n\t  nd.b=nd.e;\n\t  nd.e=t;\n\t  break;\n\tcase 1://s\n\t  nd.t=nd.n;\n\t  nd.n=nd.b;\n\t  nd.b=nd.s;\n\t  nd.s=t;\n\t  break;\n\tcase 2://w\n\t  nd.t=nd.e;\n\t  nd.e=nd.b;\n\t  nd.b=nd.w;\n\t  nd.w=t;\n\t  break;\n\tcase 3://n\n\t  nd.t=nd.s;\n\t  nd.s=nd.b;\n\t  nd.b=nd.n;\n\t  nd.n=t;\n\t  break;\n\t}\n\tint ncost=ccost+nd.b*pen[nx][ny];\n\tint dst=nd.t*6+nd.n-1;\n\tif(cost[nx][ny][dst]<=ncost)continue;\n\tcost[nx][ny][dst]=ncost;\n\ttstate.x=nx;\n\ttstate.y=ny;\n\ttstate.cost=ncost;\n\ttstate.d=nd;\n\tQ.push(tstate);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass Dice\n{\nprivate:\n  /*\n    pip[0] = top, pip[1] = south, pip[2] = east\n    pip[3] = bottom, pip[4] = north, pip[5] = west\n  */\n  int pip[6];\npublic:\n  enum { TOP, SOUTH, EAST, BOTTOM, NORTH, WEST };\n\n  Dice(int top = 1, int south = 2, int east = 3)\n  {\n    pip[TOP] = top;\n    pip[SOUTH] = south;\n    pip[EAST] = east;\n    pip[BOTTOM] = 7 - top;\n    pip[NORTH] = 7 - south;\n    pip[WEST] = 7 - east;\n  }\n\n  // east:+, west:-\n  void rotateX(int r)\n  {\n    while (r < 0)\n      r += 4;\n    r %= 4;\n    for (int i = 0; i < r; ++i) {\n      int tmp = pip[TOP];\n      pip[TOP] = pip[WEST];\n      pip[WEST] = pip[BOTTOM];\n      pip[BOTTOM] = pip[EAST];\n      pip[EAST] = tmp;\n    }\n  }\n\n  // south:+, north:-\n  void rotateY(int r)\n  {\n    while (r < 0)\n      r += 4;\n    r %= 4;\n    for (int i = 0; i < r; ++i) {\n      int tmp = pip[TOP];\n      pip[TOP] = pip[NORTH];\n      pip[NORTH] = pip[BOTTOM];\n      pip[BOTTOM] = pip[SOUTH];\n      pip[SOUTH] = tmp;\n    }\n  }\n \n  int get(int p) const\n  {\n    return pip[p];\n  } \n};\n\nclass State\n{\npublic:\n  int x, y, cost;\n  Dice dice;\n  State(int _x = 0, int _y = 0, int _cost = 0)\n    :x(_x), y(_y), cost(_cost) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint main()\n{\n  int h, w;\n  while (cin >> h >> w) {\n    if ((h|w) == 0)\n      break;\n\n    vector<vector<int> > mass(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j)\n\tcin >> mass[i][j];\n    }\n\n    int sx, sy, gx, gy;\n    cin >> sy >> sx >> gy >> gx;\n\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0));\n    int dp[10][10][6][6][6]; // dp[y][x][top][south][east]\n    for (int y = 0; y < 10; ++y)\n      for (int x = 0; x < 10; ++x)\n\tfor (int t = 0; t < 6; ++t)\n\t  for (int s = 0; s < 6; ++s)\n\t    for (int e = 0; e < 6; ++e)\n\t      dp[y][x][t][s][e] = INF;\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.x == gx && st.y == gy) {\n\tcout << st.cost << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.x][st.dice.get(Dice::TOP)][st.dice.get(Dice::SOUTH)][st.dice.get(Dice::EAST)] < st.cost)\n\tcontinue;\n\n      dp[st.y][st.x][st.dice.get(Dice::TOP)][st.dice.get(Dice::SOUTH)][st.dice.get(Dice::EAST)] = st.cost;\n      for (int d = 0; d < 4; ++d) {\n\tint x = st.x + dx[d];\n\tint y = st.y + dy[d];\n\tif (x < 0 || w <= x || y < 0 || h <= y)\n\t  continue;\n\n\tDice dice = st.dice;\n\tif (dx[d] != 0)\n\t  dice.rotateX(dx[d]);\n\telse\n\t  dice.rotateY(dy[d]);\n\n\tint cost = st.cost + mass[y][x] * dice.get(Dice::BOTTOM);\n\tif (dp[y][x][dice.get(Dice::TOP)][dice.get(Dice::SOUTH)][dice.get(Dice::EAST)] > cost) {\n\t  dp[y][x][dice.get(Dice::TOP)][dice.get(Dice::SOUTH)][dice.get(Dice::EAST)] = cost;\n\t  State tmp(x, y, cost);\n\t  tmp.dice = dice;\n\t  que.push(tmp);\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\n\nint H[6][6] = {\n\t{1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n\t{3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n\t{2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n\t{4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n\t{0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n\t{0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[4] = {0,1,-1,0};\nint dy[4] = {-1,0,0,1};\n// 高さと幅\nint h, w;\n// s[y][x] := (x,y)のマスに書かれた数字\nint s[11][11];\n\n\n// サイコロライブラリ\n// d[0] := top,   d[1] := front \n// d[2] := right, d[3] := left\n// d[4] := back,  d[5] := bottom\nenum{TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\n\nstruct Cube{\n\tint x,y;\n\tvector<int> d;\n\t// コンストラクタで初期化\n\tCube(vector<int> v, int x_, int y_){\n\t\tx = x_; y = y_;\n\t\tif( v.size() == 6 ){\n\t\t\td = v;\n\t\t}else{\n\t\t\td = vector<int> (6);\n\t\t}\n\t}\n\t// dirの方向に回転 (副作用なし)\n\tCube roll(int dir){\n\t\tCube result = (*this);\n\t\tvector<int> d_(6);\n    \tfor(int i = 0 ; i < 6 ; i++ ){\n        \td_[i] = d[ H[dir][i] ];\n    \t}\n    \tresult.d = d_;\n    \tresult.x += dx[dir];\n    \tresult.y += dy[dir];\n    \treturn result;\n    }\n};\nbool operator<(const Cube& c1, const Cube& c2){\n\tif( P(c1.x,c1.y) == P(c2.x,c2.y) ){\n\t\tif( c1.d[0] == c2.d[0] ){\n\t\t\treturn c1.d[1] < c2.d[1];\n\t\t}else{\n\t\t\treturn c1.d[0] < c2.d[0];\n\t\t}\n\t}\n\treturn P(c1.x,c1.y) < P(c2.x,c2.y);\n}\n\ntypedef pair<int,Cube> State;\n\n// ゴール g, 初期のキューブの状態 c からのダイクストラ法\nint dijkstra(Cube c , P g){\n\t// greater<State> を指定することで コスト が小さい順に取り出せる\n\tpriority_queue<State, vector<State>, greater<State> > q;\n\t\n\t// d[cube] := cube にたどり着く最小コスト. (cubeは位置のキューブの状態を持っている)\n\tmap<Cube,int> d;\n\t\n\td[c] = 0;\n\tState start( 0 , c );\n\tq.push( start );\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\tint now_cost = q.top().first;\n\t\tCube c = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif( P(c.x,c.y) == g ){\n\t\t\tresult = min( result , now_cost );\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int dir=0 ; dir < 4 ; dir++ ){\n\t\t\tCube c_ = c.roll( dir );\n\t\t\tif( c_.x < 0 || c_.y < 0 || c_.x >= w || c_.y >= h ) continue;\n\t\t\t\n\t\t\tint next_cost = now_cost + s[c_.y][c_.x] * c_.d[BOTTOM];\n\t\t\tif( d.count(c_) == 0 ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}else if( next_cost < d[c_] ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tvector<int> v(6);\n\tv[0] = 1; v[5] = 6;\n\tv[1] = 2; v[4] = 5;\n\tv[2] = 3; v[3] = 4;\t\n\t\n\twhile( cin >> h >> w , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tCube c( v, sx, sy );\n\t\tint ans = dijkstra( c , P(gx,gy) );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint field[10][10];\nint costs[7][7][10][10]; // floor, north, x, y\n\nstruct Task {\n\tint floor, north, west, x, y;\n};\nstruct TaskComparator {\n\tbool operator()(const Task &a, const Task &b){\n\t\treturn costs[a.floor][a.north][a.x][a.y] > costs[b.floor][b.north][b.x][b.y];\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tfor(int i = 0; i < 7; ++i){\n\t\t\tfor(int j = 0; j < 7; ++j){\n\t\t\t\tfor(int k = 0; k < 10; ++k){\n\t\t\t\t\tfor(int l = 0; l < 10; ++l){\n\t\t\t\t\t\tcosts[i][j][k][l] = 0x7fffffff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint h, w;\n\t\tscanf(\"%d%d\", &h, &w);\n\t\tif(h == 0 && w == 0){ break; }\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tscanf(\"%d\", &(field[j][i]));\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy;\n\t\tscanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\t\tpriority_queue<Task, vector<Task>, TaskComparator> q;\n\t\tTask task = { 6, 5, 4, sx, sy };\n\t\tcosts[6][5][sx][sy] = 0;\n\t\tq.push(task);\n\t\twhile(!q.empty()){\n\t\t\ttask = q.top(); q.pop();\n\t\t\tif(task.x == gx && task.y == gy){ break; }\n\t\t\tint cost = costs[task.floor][task.north][task.x][task.y];\n\t\t\tif(task.x > 0){\t// ツ青シツ陛サツ古シ\n\t\t\t\tint tmp = cost + task.west * field[task.x - 1][task.y];\n\t\t\t\tif(tmp < costs[task.west][task.north][task.x - 1][task.y]){\n\t\t\t\t\tcosts[task.west][task.north][task.x - 1][task.y] = tmp;\n\t\t\t\t\tTask t = { task.west, task.north, 7 - task.floor, task.x - 1, task.y };\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(task.x < w - 1){\t// ツ督個陛サツ古シ\n\t\t\t\tint tmp = cost + (7 - task.west) * field[task.x + 1][task.y];\n\t\t\t\tif(tmp < costs[7 - task.west][task.north][task.x + 1][task.y]){\n\t\t\t\t\tcosts[7 - task.west][task.north][task.x + 1][task.y] = tmp;\n\t\t\t\t\tTask t = { 7 - task.west, task.north, task.floor, task.x + 1, task.y };\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(task.y > 0){\t// ツ北ツ陛サツ古シ\n\t\t\t\tint tmp = cost + task.north * field[task.x][task.y - 1];\n\t\t\t\tif(tmp < costs[task.north][7 - task.floor][task.x][task.y - 1]){\n\t\t\t\t\tcosts[task.north][7 - task.floor][task.x][task.y - 1] = tmp;\n\t\t\t\t\tTask t = { task.north, 7 - task.floor, task.west, task.x, task.y - 1 };\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(task.y < h - 1){\t// ツ禿ャツ陛サツ古シ\n\t\t\t\tint tmp = cost + (7 - task.north) * field[task.x][task.y + 1];\n\t\t\t\tif(tmp < costs[7 - task.north][task.floor][task.x][task.y + 1]){\n\t\t\t\t\tcosts[7 - task.north][task.floor][task.x][task.y + 1] = tmp;\n\t\t\t\t\tTask t = { 7 - task.north, task.floor, task.west, task.x, task.y + 1 };\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", costs[task.floor][task.north][task.x][task.y]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nint field[10][10];\n\ntypedef long long W;\n\nconst W INF = 1LL << 50;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph& G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint toV(int x, int y, int a, int b, int c) {\n\treturn x * 10 * 7 * 7 * 7 + y * 7 * 7 * 7 + a * 7 * 7 + b * 7 + c;\n}\n\nint dx[] = { 0, 1, 0, -1 }, dy[] = { -1, 0, 1, 0 };\n\nvoid rot(int k, int a, int b, int c, int& na, int& nb, int& nc) {\n\tif(k == 0) {\n\t\tna = 7 - b;\n\t\tnb = a;\n\t\tnc = c;\n\t}\n\tif(k == 1) {\n\t\tna = a;\n\t\tnb = 7 - c;\n\t\tnc = b;\n\t}\n\tif(k == 2) {\n\t\tna = b;\n\t\tnb = 7 - a;\n\t\tnc = c;\n\t}\n\tif(k == 3) {\n\t\tna = a;\n\t\tnb = c;\n\t\tnc = 7 - b;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h, w, sx, sy, gx, gy;\n\twhile(cin >> h >> w, h) {\n\t\tfor(int y = 0; y < h; y++) {\n\t\t\tfor(int x = 0; x < w; x++) {\n\t\t\t\tcin >> field[y][x];\n\t\t\t}\n\t\t}\n\n\t\tcin >> sy >> sx >> gy >> gx;\n\n\t\tGraph G(10 * 10 * 7 * 7 * 7);\n\t\tvector<W> d(10 * 10 * 7 * 7 * 7);\n\n\t\tfor(int y = 0; y < h; y++) {\n\t\t\tfor(int x = 0; x < w; x++) {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\t\t\tfor(int a = 1; a <= 6; a++) {\n\t\t\t\t\t\tfor(int b = 1; b <= 6; b++) {\n\t\t\t\t\t\t\tfor(int c = 1; c <= 6; c++) {\n\t\t\t\t\t\t\t\tint v1 = toV(x, y, a, b, c);\n\t\t\t\t\t\t\t\tint na, nb, nc;\n\t\t\t\t\t\t\t\trot(k, a, b, c, na, nb, nc);\n\t\t\t\t\t\t\t\tint v2 = toV(nx, ny, na, nb, nc);\n\t\t\t\t\t\t\t\tG[v1].push_back(edge{ v2, field[ny][nx] * (7 - nb) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(toV(sx, sy, 2, 1, 3), G, d);\n\t\tW ans = INF;\n\t\tfor(int a = 1; a <= 6; a++) {\n\t\t\tfor(int b = 1; b <= 6; b++) {\n\t\t\t\tfor(int c = 1; c <= 6; c++) {\n\t\t\t\t\tans = min(ans, d[toV(gx, gy, a, b, c)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nvoid fn(vector<int>& a,char s){\n  if(0){\n  }else if(s=='n'){\n    int s=a[0];\n    a[0]=a[4];\n    a[4]=a[5];\n    a[5]=a[1];\n    a[1]=s;\n  }else if(s=='s'){\n    int s=a[0];\n    a[0]=a[1];\n    a[1]=a[5];\n    a[5]=a[4];\n    a[4]=s;\n  }else if(s=='e'){\n    int s=a[0];\n    a[0]=a[2];\n    a[2]=a[5];\n    a[5]=a[3];\n    a[3]=s;\n  }else if(s=='w'){\n    int s=a[0];\n    a[0]=a[3];\n    a[3]=a[5];\n    a[5]=a[2];\n    a[2]=s;\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int h,w;\n  while(cin>>h>>w,h||w){\n    int a[12][12];\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++)\n\tcin>>a[j][i];\n    int sx,sy,tx,ty;\n    cin>>sy>>sx>>ty>>tx;\n    sx++;\n    sy++;\n    tx++;\n    ty++;\n    int b[12][12][7][7];\n    memset(b,-1,sizeof(b));\n    priority_queue<pair<pair<int,vector<int> >,pair<int,int> >,vector<pair<pair<int,vector<int> >,pair<int,int> > >,greater<pair<pair<int,vector<int> >,pair<int,int> > > > c;\n    vector<int> d;\n    for(i=1;i<7;i++)\n      d.push_back(i);\n    c.push(make_pair(make_pair(0,d),make_pair(sx,sy)));\n    while(c.empty()==0){\n      int x,y,z;\n      vector<int> d;\n      x=c.top().second.first;\n      y=c.top().second.second;\n      z=c.top().first.first;\n      d=c.top().first.second;\n      if(x==tx&&y==ty)\n\tbreak;\n      c.pop();\n      if(b[x][y][d[0]][d[1]]==-1||b[x][y][d[0]][d[1]]>z){\n\tb[x][y][d[0]][d[1]]=z;\n\tif(a[x-1][y]!=-1){\n\t  fn(d,'e');\n\t  c.push(make_pair(make_pair(z+a[x-1][y]*d[5],d),make_pair(x-1,y)));\n\t  fn(d,'w');\n\t}\n\tif(a[x+1][y]!=-1){\n\t  fn(d,'w');\n\t  c.push(make_pair(make_pair(z+a[x+1][y]*d[5],d),make_pair(x+1,y)));\n\t  fn(d,'e');\n\t}\n\tif(a[x][y-1]!=-1){\n\t  fn(d,'s');\n\t  c.push(make_pair(make_pair(z+a[x][y-1]*d[5],d),make_pair(x,y-1)));\n\t  fn(d,'n');\n\t}\n\tif(a[x][y+1]!=-1){\n\t  fn(d,'n');\n\t  c.push(make_pair(make_pair(z+a[x][y+1]*d[5],d),make_pair(x,y+1)));\n\t  fn(d,'s');\n\t}\n      }\n    }\n    cout<<c.top().first.first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[40][40];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;\n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n    RollMe(i);\n    if(/*!used[ny][nx] &&*/ 0<=nx && nx<w && 0<=ny && ny <h && dpused[ny][nx] >= sam+imap[ny][nx]*dice[5]){\n      //used[ny][nx] = true;\n      //RollMe(i);\n\tdpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));\n      //used[ny][nx] = false;\n    }\n      RollMe(Reverse(i));\n  }\n\n}\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\tdpused[i][j] = INF;\n      }\n    //used[s.S][s.F] = true;\n    dpused[s.S][s.F] = 0;\n    rec(s,0);\n    //assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n           \n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n#include <cassert>\nstruct Dice\n{\n    int bottom, east, south;\n    Dice(int bottom, int east, int south)\n\t: bottom(bottom), east(east), south(south)\n    {\n\tint t[3] = { bottom, east, south };\n\tfor (int i = 0; i < 3; ++i)\n\t    if (t[i] < 0 || t[i] > 6)\n\t\tcout << t[i] << endl;\n\n    }\n    Dice roll(int dx, int dy)\n    {\n\tif (dy == 0)\n\t{\n\t    if (dx == 1)\n\t\treturn Dice(east, 7 - bottom, south);\n\t    else if (dx == -1)\n\t\treturn Dice(7 - east, bottom, south);\n\t    else\n\t\texit(1);\n\t}\n\telse if (dx == 0)\n\t{\n\t    if (dy == 1)\n\t\treturn Dice(7 - south, east, bottom);\n\t    else if (dy == -1)\n\t\treturn Dice(south, east, 7 - bottom);\n\t    else\n\t\texit(1);\n\t}\n\telse\n\t    exit(1);\n    }\n    int hash() const\n    {\n\treturn bottom*100 + east*10 + south;\n    }\n};\nbool operator<(const Dice& a, const Dice& b)\n{\n    return a.hash() < b.hash();\n}\nstruct Node\n{\n    int pena, x, y;\n    Dice dice;\n};\nbool operator<(const Node& a, const Node& b)\n{\n    return a.pena > b.pena;\n}\nint main()\n{\n    int h, w, sx, sy, gx, gy;\n    while (cin >> h >> w, h | w)\n    {\n\tint cell[16][16];\n\trep (y, h)\n\t    rep (x, w)\n\t    cin >> cell[h-1 - y][x];\n\tcin >> sy >> sx >> gy >> gx;\n\tsy = h-1 - sy;\n\tgy = h-1 - gy;\n\n\tmap<Dice, int> dp[16][16];\n\tpriority_queue<Node> q;\n\tq.push((Node){ 0, sx, sy, Dice(6, 3, 2) });\n\tdp[sy][sx][q.top().dice] = 0;\n\twhile (!q.empty())\n\t{\n\t    Node cur = q.top(); q.pop();\n\t    if (cur.pena > dp[cur.y][cur.x][cur.dice])\n\t\tcontinue;\n\n\t    static const int dx[] = { 0, 1, 0, -1 };\n\t    static const int dy[] = { 1, 0, -1, 0 };\n\t    for (int i = 0; i < 4; ++i)\n\t    {\n\t\tint tx = cur.x + dx[i], ty = cur.y + dy[i];\n\t\tif (tx < 0 || ty < 0 || tx >= w || ty >= h)\n\t\t    continue;\n\n\t\tDice d = cur.dice.roll(dx[i], dy[i]);\n\t\tint pena = cur.pena + d.bottom * cell[ty][tx];\n\t\tif (!dp[ty][tx].count(d) || pena < dp[ty][tx][d])\n\t\t{\n\t\t    dp[ty][tx][d] = pena;\n\t\t    q.push((Node){ pena, tx, ty, d });\n\t\t}\n\t    }\n\t}\n\tint res = 1e9;\n\tforeach (it, dp[gy][gx])\n\t    min_swap(res, it->second);\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1057 Rolling Dice\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint x, y, d0, d1, c;\n\tNode(int x, int y, int d0, int d1, int c) : x(x), y(y), d0(d0), d1(d1), c(c) {}\n\tbool operator < (const Node &nd) const { return c > nd.c; }\n};\n\nchar dx[] = {-1,1,0,0};\nchar dy[] = {0,0,-1,1};\n\nchar dice[6][4] = {\n\t{5,2,1,4}, {1,1,3,0}, {0,3,2,2},\n\t{2,5,4,1}, {4,4,0,3}, {3,0,5,5}\n};\nchar side[] = {1,2,4,5};\nint dice_color[6] = {1, 4, 2, 6, 3, 5};\n\nint getUpper(int a, int b){\n\tif(a%3 == 0) return dice_color[a+0];\n\tif(b%3 == 0) return dice_color[b+1];\n\tfor(int i=0;i<4;i++)\n\t\tif(a==side[i]&&b==side[(i+1)%4]) return dice_color[2];\n\treturn dice_color[5];\n}\n\nint main(){\n\tint w, h;\n\tint cost[10][10];\n\twhile(cin >> h >> w, w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++) cin >> cost[i][j];\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tint mem[10][10][6][6];\n\t\tmemset(mem, -1, sizeof(mem));\n\t\tpriority_queue<Node> qu; qu.push(Node(sx, sy, 0, 1, 0));\n\t\tmem[sx][sy][0][1] = 0;\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint x = nd.x, y = nd.y, d0 = nd.d0, d1 = nd.d1, c = nd.c;\n\t\t\tif(mem[x][y][d0][d1]!=c) continue;\n\t\t\tif(x==gx&&y==gy){\n\t\t\t\tcout << mem[x][y][d0][d1] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i], nd0 = dice[d0][i], nd1 = dice[d1][i];\n\t\t\t\tif(nx<0||h<=nx||ny<0||w<=ny) continue;\n\t\t\t\tif(mem[nx][ny][nd0][nd1]==-1||mem[nx][ny][nd0][nd1]>mem[x][y][d0][d1]+cost[nx][ny]*(7-getUpper(nd0,nd1))){\n\t\t\t\t\tqu.push(Node(nx,ny,nd0,nd1,mem[x][y][d0][d1]+cost[nx][ny]*(7-getUpper(nd0,nd1))));\n\t\t\t\t\tmem[nx][ny][nd0][nd1] = mem[x][y][d0][d1]+cost[nx][ny]*(7-getUpper(nd0,nd1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\nenum FACE { TOP, BOTTOM, NORTH, SOUTH, WEST, EAST };\n\nclass dice {\nprivate:\n\tint num[6];\n\npublic:\n\tinline void roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[NORTH] = 5;\n\t\tnum[SOUTH] = 2;\n\t\tnum[EAST] = 3;\n\t\tnum[WEST] = 4;\n\t}\n\n\tdice(const dice& d) {\n\t\tnum[TOP] = d[TOP];\n\t\tnum[BOTTOM] = d[BOTTOM];\n\t\tnum[NORTH] = d[NORTH];\n\t\tnum[SOUTH] = d[SOUTH];\n\t\tnum[EAST] = d[EAST];\n\t\tnum[WEST] = d[WEST];\n\t}\n\n\tint encode() const {\n\t\treturn (num[TOP] - 1) * 6 * 6 + (num[NORTH] - 1) * 6 + (num[EAST] - 1);\n\t}\n\n\tconst int& operator[] (FACE f) const { return num[f]; }\n};\n\nvoid north(dice& d) { d.roll(TOP, SOUTH, BOTTOM, NORTH); }\nvoid east(dice& d) { d.roll(TOP, WEST, BOTTOM, EAST); }\nvoid west(dice& d) { d.roll(TOP, EAST, BOTTOM, WEST); }\nvoid south(dice& d) { d.roll(TOP, NORTH, BOTTOM, SOUTH); }\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int INF = 0xfffffff;\nint h, w;\nint gx, gy;\nint field[MAX_SIZE][MAX_SIZE];\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nvoid (*func[4])(dice& d) = { east, south, west, north};\n\nbool visited[MAX_SIZE][MAX_SIZE][6];\n\nbool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\ntypedef int weight;\nvector<weight> dist;\nstruct state {\n\tint x, y;\n\tdice d;\n\tweight dist;\n\tstate(int x, int y, const dice& d, weight dist):x(x), y(y), d(d), dist(dist){}\n\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nweight dijkstra(int sx, int sy, dice d) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<vector<weight>>> dist(h, vector<vector<weight>>(w, vector<weight>(6*6*6, INF)));\n\tdist[sy][sx][d.encode()] = 0;\n\tque.push(state(sx, sy, d, 0));\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.y][s.x][s.d.encode()] < s.dist)\n\t\t\tcontinue;\n\n\t\tif(s.x == gx && s.y == gy)\n\t\t\treturn s.dist;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tconst int nx = s.x + dx[i];\n\t\t\tconst int ny = s.y + dy[i];\n\t\t\tif(out(nx, ny)) continue;\n\t\t\tdice next_d(s.d);\n\t\t\tfunc[i](next_d);\n\t\t\tconst int next_dist = s.dist + next_d[BOTTOM] * field[ny][nx];\n\t\t\tif(dist[ny][nx][next_d.encode()] > next_dist) {\n\t\t\t\tdist[ny][nx][next_d.encode()] = next_dist;\n\t\t\t\tque.push(state(nx, ny, next_d, next_dist));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tmemset(visited, false, sizeof(visited));\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\n\t\tcout << dijkstra(sx, sy, dice()) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[40][40];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;\n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n    RollMe(i);\n    if(/*!used[ny][nx] &&*/ 0<=nx && nx<w && 0<=ny && ny <h && dpused[ny][nx] >= sam+imap[ny][nx]*dice[5]){\n      //used[ny][nx] = true;\n      //RollMe(i);\n\tdpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));\n      //used[ny][nx] = false;\n    }\n      RollMe(Reverse(i));\n  }\n\n}\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\tdpused[i][j] = INF;\n      }\n    //used[s.S][s.F] = true;\n    dpused[s.S][s.F] = 0;\n    rec(s,0);\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:ツ可コツ、1:ツ右ツ、2:ツ湘」ツ、3:ツ債カ\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[20][20];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n/*\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n*/\n\n/* //ツづ?/ツづ?暗債づ慊づェツづ?つ「ツづゥツづ?づ個づ債使ツ用ツつオツづ按つ「*/\n/*ツ　\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;  \n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n*/\n//if(/*!used[ny][nx] &&*/// !(0<=nx && nx<w && 0<=ny && ny <h))continue;\n    //cout << \"nx = \" << nx << \" ny = \"  << ny << endl;//\n//      RollMe(i);\n//if( dpused[ny][nx] > (sam+imap[ny][nx]*dice[5]) ){\n      //used[ny][nx] = true;//\n      //RollMe(i);//\n      //dpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n\t//rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));//\n      //used[ny][nx] = false;//\n      //  }\n//    RollMe(Reverse(i));\n//}\n//}\n\n\nint idx(int tp,int ft){\n  return tp*10+ft;\n}\n\n\nstruct special{\n  int x,y,top,front,left,back,right,bottom,cost;\n  //special (int x,int y,int top,int front,int left,int back,int right,int bottom,int cost):x(x),y(y),top(top),front(front),left(left),back(back),right(right),bottom(bottom),cost(cost){}\n\n  bool operator < (const special &p)const{\n    return cost > p.cost;\n  }\n\n \n\n  //0->top, 1->front, 2->left, 3->back, 4->right, 5->bottom\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = back;\n    back = bottom;\n    bottom = front;\n    front = top;\n    top = h;\n  }\n  else if(face == 1){\n    int h = top;\n    top = left;\n    left = bottom;\n    bottom = right;\n    right = h;\n  }\n  else if(face == 2){\n    int h = top;\n    top = front;\n    front = bottom;\n    bottom = back;\n    back = h;\n  }\n  else if(face == 3){\n    int h = top;\n    top = right;\n    right = bottom;\n    bottom= left;\n    left = h;\n  }\n}\n\n\n};\nint D[20][20][100];\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\t//\tdpused[i][j] = INF;\n\tfor(int k=0;k<100;k++)D[i][j][k] = INF;\n      }\n  \n    //used[s.S][s.F] = true;\n    //dpused[s.S][s.F] = 0;\n    //rec(s,0);\n    D[s.S][s.F][idx(1,2)]=0;\n    priority_queue<special>que;\n    special In;\n    //int dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n    In.x = s.F;In.y = s.S; In.top = 1;In.front = 2;In.left = 4;In.back = 5;In.right = 3;In.bottom = 6; In.cost = 0;\n    que.push(In);\n    //special - > x,y,top,front,left,back,right,bottom,cost;\n    while(!que.empty()){\n      special pos = que.top(); que.pop();\n      //majesty\n      if(pos.x == g.F && pos.y == g.S){\n\tcandidate = min(candidate,pos.cost);\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tint nx = pos.x+dx[i],ny = pos.y+dy[i];\n\n\tif(!(0<=nx && nx <w && 0<= ny && ny <h))continue;\n\tpos.RollMe(i);       \n\n\tif(D[ny][nx][idx(pos.top,pos.front)] > imap[ny][nx]*pos.bottom+ pos.cost){\n\t  D[ny][nx][idx(pos.top,pos.front)] = imap[ny][nx]*pos.bottom+ pos.cost;\n\t  In.x = nx;In.y = ny;In.top = pos.top;In.front = pos.front;In.back = pos.back;In.left = pos.left; In.right = pos.right; In.bottom = pos.bottom; In.cost =  imap[ny][nx]*pos.bottom+ pos.cost;\n\t  que.push(In);\n\t}\n\t  pos.RollMe(Reverse(i));\n\n      }\n\n    }\n\n    /*\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cout << dpused[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //ツづ?つオツ按ォツづーツ使ツつ、ツづ按づァツ要ツ確ツ認\n\n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n\nPoint ACM,IC,PC;\nSegment IC_PC,PC_ACM,ACM_IC;\n\n\n\ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n\ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n\nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n\ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n\nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n /*memo:\nツ渉可甘コツバツーツジツδ?δ督つセツづ?催?帰ツづ?枝ツ静伉づィツづーツつオツづつづつづ個探ツ催オツづーツつィツつアツづ按づ?づ?つ「ツつス\ndpusedツづ?つ「ツつ、ツ配ツ療アツづ可つサツつアツづ個マツスツづ慊づ?つュツづゥツ催?短ツコツスツトツづーツ陛崢堕カツつオツ、ツ催?度ツつサツづ個マツスツづ可督楪陳?つオツつスツ催崢づ嬰pusedツづ個値ツづヲツづィツづ?渉ャツつウツつ「ツづ個づ?つ?づェツづ篠更ツ新ツつキツづゥツづ?つ「ツつ、ツ陛サツ針ツづ?つ?づゥ\nツつオツつゥツつオwツづ?ツつェツ妥・ツつォツつ「ツづ?（?ツ　ツ陳?甘板づ債つスツづ淞つオツづ?つ「ツづ按つ「ツつェ4*4ツつ?つスツづィツづ慊づ?づ債つ、ツづ慊つュツつ「ツつュツ様ツ子)ツ催?渉ャツコツスツトツつェツ本ツ猟按づ個催?渉ャツコツスツトツづヲツづィツづ「ツづ「ツ妥・ツつォツつュツづ按づゥ\nツつ?づゥツマツスツつゥツづァツつ?づゥツマツスツづ慊づ?暗堋督ョツつオツつスツ催崢づ可づ?つ、ツつ「ツつ、ツ経ツ路ツづ?暗堋督ョツつオツづヲツつ、ツつェツ督楪陳?つオツつスツ催崢づ個サツイツコツδ債づ個湘ウツ仰オツづ債暗ェツ渉渉づ可づ按づゥツづ?考ツつヲツづ?つ「ツつスツづ個つセツつェツつサツつ、ツづ?づ債づ按つ「ツづ個つセツづォツつ、ツつゥ\n(0,0)->(1,0)ツづー(0,0)->(0,1)->(1,1)->(1,0)ツづ?暗堋督ョツつオツづ?づ?個仰凝?づ?0,0)->(0,1)->(0,0)->(1,0)ツづ?暗ェツ渉渉づ?サツイツコツδ債づ個湘ウツ妥板づ債つゥツづュツづァツづ按つ「ツづヲツつ、ツづ按気ツづ?つキツづゥ\nツサツイツコツδ債づ個湘ウツ妥板つェツつゥツづュツづァツづ按つ「ツづ個づ?つ?づェツづ篠余ツ計ツづ可暗堋督ョツつキツづゥツ閉ェツコツスツトツつェツつゥツつゥツづゥツづ個づ?鳴ウツ妥環づ?つ?づゥ\nツづ?つオツ０ツづ個マツスツつェツつ?づィツ可督嘉アツづィツつオツづ?暗堋督ョツつキツづゥツづ?コツスツトツつェツ渉ャツつウツつュツづ按づゥツづ個づ?つ?づェツづ篠、ツコツスツトツつェツ渉ャツつウツつュツづ按づゥツづ?つ「ツつ、ツ湘ーツ個渉づーツ鳴楪つスツつオツづ?つ「ツづゥツづ個づ?姪「ツ妥ィツづ按つュツ更ツ新ツつウツづェツづゥツづ個つセツつェツ、WAツづ?つ?づ?つス\n\nツつアツづェツづ慊づ?づ債経ツ路ツづ可甘鳴係ツづ按つュツサツイツコツδ債づ個湘ウツ妥板づ債督ッツつカツづ?つオツづ?つォツつスツつェツつ、ツづ慊つュツつ「ツつゥツづ按つ「ツづ個づ?考ツつヲツづーツ嘉シツづ淞つス\nツ暗環置ツつセツつッツづ?催?渉ャツコツスツトツづーツ甘?猟敖つオツづ?つォツつスツつェツつウツづァツづ可サツイツコツδ債づ個湘ウツ妥板づーツ津?嘉?つオツづДPツづーツ行ツつ、ツつアツづ?づ?つオツつス\nツサツイツコツδ債づ可甘鳴つキツづゥツ渉按猟敖づ債渉可甘コツバツーツジツδ?δ督づ個づ?づ個づーツ猟ャツ用ツ、ツ新ツつスツづ按陛サツ法ツづ?渉可甘コツバツーツジツδ?δ督づ可サツイツコツδ債づ個湘ウツ妥板づーツつュツづュツつヲツづゥツつセツつッツづ按づ個づ?つウツづ卍づ?篠楪甘板づ債要ツつウツづ按つ「\n\nツづ按つコツサツイツコツδ債づ個湘ウツ妥板つェツづ按つ「ツづ?つ、ツづ慊つュツつ「ツつゥツづ按つゥツづ按づ?つスツづ個つセツづォツつ、ツつゥ\nツづ?つ、ツつ「ツづ?つスツ湘ェツ債?づ可板スツ療。ツつェツつ?づゥツづ個つゥ\nツ篠?づ個個サツ催敖づ個療債づ?づ?0*10ツづ個マツスツづ個個仰嘉環づーツ脳ツ禿?シツδ?ミツδ個ーツシツδ?δ督づ?づ債つセツつキツつアツづ?つェツづ?つォツづ按つ「ツ湘」ツづ可、ツノツーツトツづ可渉堕つュツづ個づ?渉ュツ々ツ姪環倒ツづ按づ個づ?参ツづ?つスツづ?づ個づ?つ?づゥ\n\nツ素ツ陳シツづ可サツイツコツδ債づ個購ツ禿シツづーツつオツづヲツつ、ツづ?思ツつ、\n\nツ板スツ療。ツづーツ嘉ッツ津δづ可帰ツづゥツづ慊づ?づ可個ゥツづつつッツづェツづ按つッツづェツづ篠誰ツつゥツづ可閉キツつ「ツづ?づ敖づヲツつ、\n   */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost > s.cost;\n  }\n};\n\nstruct mstruct{\n  int y, x;\n  Dice d;\n\n  bool operator<(const mstruct &m) const{\n    return y == m.y ? x < m.x : y < m.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<mstruct, int> m;\n    mstruct ms;\n    ms.y = sy; ms.x = sx;\n    ms.d.t = 1; ms.d.s = 2; s.d.e = 3;\n    m[ms] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx){\n\t// res = min(res, now.cost);\n\tprintf(\"%d\\n\", now.cost);\n\tgoto e;\n      }\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\t//\tprintf(\"%d\\n\", next.cost);\n\tmstruct ns;\n\tns.y = ny; ns.x = nx;\n\tns.d.t = next.d.t; ns.d.s = next.d.s; ns.d.e = next.d.e;\n\tif(m.count(ns) != 0  && m[ns] <= next.cost) continue;\n\tm[ns] = next.cost;\n\t//\t  printf(\"%d %d\\n\", ny, nx);\n\t/*\t  if(ny == gy && nx == gx){\n\t\t  res = min(res, next.cost);\n\t\t  break;\n\t\t  }*/\n\tq.push(next);\n      }\n    }\n    puts(\"-1\");\n    //    printf(\"%d\\n\", res==INF?0:res);\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstd::istream &operator>>(std::istream &is, P &p){\n\treturn is >> p.first >> p.second;\n}\n\nstruct Dice{\nprivate:\n\tstatic const int _roll[4][6], _turn[2][6];\npublic:\n\tvector<int> value;\n\t// 1-6 : top, near, right, left, far, bottom \n\n\tDice(){\n\t\tvalue.resize(6);\n\t\tfor (int i = 0; i < 6; ++i) value[i] = i+1;\n\t}\n\tDice(initializer_list<int> il){\n\t\tvalue.resize(6, -1);\n\t\tint cnt = 0;\n\t\tfor (auto &e : il){\n\t\t\tvalue[cnt++] = e;\n\t\t\tif (cnt >= 6) break;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) if (value[i] < 0) value[i] = 5 - value[5 - i];\n\t}\n\n\tvoid roll(int dir){ // N, E, W, S\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_roll[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tvoid turn(int dir){ // L, R\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_turn[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tint &operator[](int i){\n\t\treturn value[i];\n\t}\n};\n\nconst int Dice::_roll[4][6] = {\n\t{ 1, 5, 2, 3, 0, 4 }, // North\n\t{ 3, 1, 0, 5, 4, 2 }, // East\n\t{ 2, 1, 5, 0, 4, 3 }, // West\n\t{ 4, 0, 2, 3, 5, 1 }, // South\n};\n\nconst int Dice::_turn[2][6] = {\n\t{ 0, 3, 1, 4, 2, 5 }, // Left\n\t{ 0, 2, 4, 1, 3, 5 }, // Right\n};\n\nint board[10][10];\n\nstruct state{\n\tP first;\n\tDice second;\n\tbool operator<(const state &r)const{\n\t\tif(first != r.first) return first < r.first;\n\t\trep(i, 6) if (second.value[i] != r.second.value[i]) return second.value[i] < r.second.value[i];\n\t\treturn false;\n\t}\n};\n\nint dx[] = {0, 1, -1, 0};\nint dy[] = {-1, 0, 0, 1};\n\nint main(){\n\tint h, w;\n\twhile (cin >> h >> w, h | w){\n\t\trep(i, h) rep(j, w) cin >> board[i][j];\n\t\tP s, g;\n\t\tcin >> s >> g;\n\n\t\tmap<state, int> m;\n\n\t\tpriority_queue<pair<int, state>, vector<pair<int, state>>, greater<pair<int, state>>> q;\n\t\tq.push(make_pair(0, state{ s, Dice() }));\n\t\tint ans = -1;\n\t\twhile (!q.empty()){\n\t\t\tint dist = q.top().first;\n\t\t\tstate s = q.top().second;\n\t\t\tP &pos = s.first;\n\t\t\tDice &d = s.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif (m[s] < dist) continue;\n\t\t\tif (s.first == g){\n\t\t\t\tans = dist;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint nx = pos.second + dx[i], ny = pos.first + dy[i];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\tstate nxt = s;\n\t\t\t\tnxt.second.roll(i);\n\t\t\t\tnxt.first = make_pair(ny, nx);\n\t\t\t\tif (m.count(nxt) && m[nxt] <= dist + nxt.second[5] * board[ny][nx]) continue;\n\t\t\t\tm[nxt] = dist + nxt.second[5] * board[ny][nx];\n\t\t\t\tq.push(make_pair(dist + nxt.second[5] * board[ny][nx], nxt));\n\t\t\t}\n\t\t}\n\t\t//cout << \"+++\";\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n\nstruct Dice{\n  int tmp,d[6];\n  Dice(){\n    for(int i = 0 ; i < 6 ; i++){\n      d[i] = i+1;\n    }\n  }\n  void rollN(){\n    tmp = d[0];\n    d[1] = d[5];\n    d[5] = d[4];\n    d[4] = tmp;\n  }\n  void rollE(){\n    tmp = d[0];\n    d[0] = d[3];\n    d[3] = d[5];\n    d[5] = d[2];\n    d[2] = tmp;\n  }\n  void rollS(){\n    tmp = d[0];\n    d[0] = d[4];\n    d[4] = d[5];\n    d[5] = d[1];\n    d[1] = tmp;\n  }\n  void rollW(){\n    tmp = d[0];\n    d[0] = d[2];\n    d[2] = d[5];\n    d[5] = d[3];\n    d[3] = tmp;\n  }\n};\n\nstruct State{\n  int cost,x,y;\n  Dice d;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(cin >> H >> W, H){\n    int field[MAX_H][MAX_W];\n    int sx,sy,gx,gy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    Dice die;\n    int cost[MAX_H][MAX_W][7][7][7];\n    for(int i = 0 ; i < MAX_H ; i++){\n      for(int j = 0 ; j < MAX_W ; j++){\n        for(int k = 0 ; k < 7 ; k++){\n          for(int l = 0 ; l < 7 ; l++){\n            for(int m = 0 ; m < 7 ; m++){\n              cost[i][j][k][l][m] = 1e9;\n            }\n          }\n        }\n      }\n    }\n    cost[sy][sx][die.d[0]][die.d[1]][die.d[2]] = 0;\n    priority_queue<State> Q;\n    Q.push((State){0,sx,sy,die});\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    while(!Q.empty()){\n      State s = Q.top(); Q.pop();\n      int x = s.x, y = s.y;\n      int ncost = cost[y][x][s.d.d[0]][s.d.d[1]][s.d.d[2]];\n      if(ncost < s.cost){\n        continue;\n      }\n      if(x == gx && y == gy){\n        cout << s.cost << endl;\n        break;\n      }\n      for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        Dice d = s.d;\n        if(0 > nx || nx >= W || 0 > ny || ny >= H){\n          continue;\n        }\n        switch(i){\n        case 0:\n          d.rollW();\n          break;\n        case 1:\n          d.rollN();\n          break;\n        case 2:\n          d.rollE();\n          break;\n        case 3:\n          d.rollS();\n          break;\n        }\n        int p = d.d[5]*field[ny][nx];\n        if(ncost + p < cost[ny][nx][d.d[0]][d.d[1]][d.d[2]]){\n          cost[ny][nx][d.d[0]][d.d[1]][d.d[2]] = ncost + p;\n          Q.push((State){cost[ny][nx][d.d[0]][d.d[1]][d.d[2]],nx,ny,d});\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost > s.cost;\n  }\n};\n\nstruct mstruct{\n  int y, x;\n  Dice d;\n\n  bool operator<(const mstruct &m) const{\n    return y == m.y ? x < m.x : y < m.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<mstruct, int> m;\n    mstruct ms;\n    ms.y = sy; ms.x = sx;\n    ms.d.t = 1; ms.d.s = 2; s.d.e = 3;\n    m[ms] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx){\n\t res = min(res, now.cost);\n\t//\tprintf(\"%d\\n\", now.cost);\n\t//\tgoto e;\n      }\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\t//\tprintf(\"%d\\n\", next.cost);\n\tmstruct ns;\n\tns.y = ny; ns.x = nx;\n\tns.d.t = next.d.t; ns.d.s = next.d.s; ns.d.e = next.d.e;\n\tif(m.count(ns) != 0  && m[ns] <= next.cost) continue;\n\tm[ns] = next.cost;\n\tprintf(\"%d %d %d\\n\", next.y, next.x, next.cost);\n\tq.push(next);\n      }\n    }\n    printf(\"%d\\n\", res==INF?0:res);\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint rol[4][4]={\n\t{4,5,2,0},\n\t{1,0,3,5},\n\t{0,2,5,4},\n\t{5,3,0,1}\n};\nvi a;\nvoid roll(int b){\n\tint tmp=a[2+rol[b][0]];\n\trep(i,3)a[2+rol[b][i]]=a[2+rol[b][i+1]];\n\ta[2+rol[b][3]]=tmp;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(m));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\tint sx,sy,gx,gy;\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tvi q(8);\n\t\tq[0]=sx;q[1]=sy;q[2]=1;q[3]=2;\n\t\tq[4]=3;q[5]=5;q[6]=4;q[7]=6;\n\t\tint ma[11][11][666];\n\t\trep(i,11)rep(j,11)rep(k,666)ma[i][j][k]=inf;\n\t\tma[sx][sy][123]=0;\n\t\tint out=inf;\n\t\tpriority_queue<pair<int,vi> >que;\n\t\tque.push(pair<int,vi>(0,q));\n\t\twhile(!que.empty()){\n\t\t\tvi w=que.top().second;\n\t\t\tint t=-que.top().first;\n\t\t\tque.pop();\n\t\t\tif(ma[w[0]][w[1]][w[2]*100+w[3]*10+w[4]]<t)continue;\n\t\t\trep(i,4){\n\t\t\t\ta=w;\n\t\t\t\ta[0]+=dx[i];\n\t\t\t\ta[1]+=dy[i];\n\t\t\t\tif(a[0]<0||a[1]<0||a[0]>=n||a[1]>=m)continue;\n\t\t\t\troll(i);\n\t\t\t\tint cost=t+a[7]*in[a[0]][a[1]];\n\t\t\t\tif(ma[a[0]][a[1]][a[2]*100+a[3]*10+a[4]]>cost){\n\t\t\t\t\tma[a[0]][a[1]][a[2]*100+a[3]*10+a[4]]=cost;\n\t\t\t\t\tque.push(pair<int,vi>(-cost,a));\n\t\t\t\t\tif(a[0]==gx&&a[1]==gy)out=min(out,cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint board[10][10];\nint memo[7][7][7][10][10];\nint h,w;\n\nstruct State {\n    int x,y,top,south,east,cost;\n    State(int x,int y,int top,int south,int east,int cost) :\n        x(x), y(y), top(top), south(south), east(east), cost(cost) {;}\n};\n\nconst bool operator<(const State &s,const State &t) {\n    return s.cost > t.cost;\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nState roll(State s,int k) {\n    int nx = s.x + dx[k], ny = s.y + dy[k];\n    if(nx < 0 || nx > w-1 || ny < 0 || ny > h-1)\n        return State(-1,0,0,0,0,0);\n\n    int ntop,nsouth,neast;\n    if(k == 0) {\n        nsouth = s.south;\n        neast = s.top;\n        ntop = 7 - s.east;\n    }else if(k == 1) {\n        neast = s.east;\n        nsouth = s.top;\n        ntop = 7 - s.south;\n    }else if(k == 2) {\n        nsouth = s.south;\n        neast = 7 - s.top;\n        ntop = s.east;\n    }else if(k == 3) {\n        neast = s.east;\n        nsouth = 7 - s.top;\n        ntop = s.south;\n    }\n    return State(nx,ny,ntop,nsouth,neast,0);\n}\n\ninline int dist(State s) {\n    return memo[s.top][s.south][s.east][s.y][s.x];\n}\n\nint main() {\n    while(cin>>h>>w, h|w) {\n        for(int i=0; i<h; ++i)\n            for(int j=0; j<w; ++j) cin>>board[i][j];\n\n        int sx,sy,gx,gy;\n        cin>>sy>>sx>>gy>>gx;\n\n        priority_queue<State> q;\n        memset(memo, -1, sizeof(memo));\n        memo[1][2][3][sy][sx] = 0;\n        q.push(State(sx,sy,1,2,3,0));\n        while(!q.empty()) {\n            State s = q.top(); q.pop();\n            for(int k=0; k<4; ++k) {\n                State ns = roll(s,k);\n                if(ns.x == -1) continue;\n                int nc = dist(s) + (7-ns.top)*board[ns.y][ns.x];\n                if(dist(ns) != -1/* && nc > dist(ns)*/) continue;\n                memo[ns.top][ns.south][ns.east][ns.y][ns.x] = nc;\n                ns.cost = nc;\n                q.push(ns);\n            }\n        }\n\n        int ans = 1<<29;\n        for(int i=1; i<=6; ++i)\n            for(int j=1; j<=6; ++j)\n                for(int k=1; k<=6; ++k) {\n                    if(memo[i][j][k][gy][gx] == -1) continue;\n                    ans = min(ans, memo[i][j][k][gy][gx]);\n                }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\nbool used[20][20];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n    if(!used[ny][nx] && 0<=nx && nx<w && 0<=ny && ny <h){\n      used[ny][nx] = true;\n      RollMe(i);\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      RollMe(Reverse(i));\n      used[ny][nx] = false;\n    }\n  }\n\n}\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++)used[i][j] = false;\n    used[s.S][s.F] = true;\n    rec(s,0);\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,s,e,w,n,b;\n\tDice(int tt,int ss,int ee,int ww,int nn,int bb):t(tt),s(ss),e(ee),w(ww),n(nn),b(bb){}\n\tvoid rotx(){\n\t\tDice tmp=*this;\n\t\tt=tmp.w;\n\t\te=tmp.t;\n\t\tw=tmp.b;\n\t\tb=tmp.e;\n\t}\n\tvoid roty(){\n\t\tDice tmp=*this;\n\t\tt=tmp.s;\n\t\ts=tmp.b;\n\t\tn=tmp.t;\n\t\tb=tmp.n;\n\t}\n};\n\nstruct Stat{\n\tint x,y,cost;\n\tDice dice;\n\tStat(int xx,int yy,int c,Dice d):x(xx),y(yy),cost(c),dice(d){}\n\tbool operator<(const Stat &st)const{ return cost<st.cost; }\n};\n\nint main(){\n\tfor(int h,w;scanf(\"%d%d\",&h,&w),h;){\n\t\tint grid[10][10];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",grid[i]+j);\n\t\tint sx,sy,gx,gy;\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\n\t\tDice ini(1,2,3,4,5,6);\n\n\t\tint cmin[10][10][7][7],ans;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int t=1;t<=6;t++)for(int w=1;w<=6;w++)\tcmin[i][j][t][w]=1<<30;\n\t\tcmin[sy][sx][ini.t][ini.w]=0;\n\t\tpriority_queue<Stat> pq;\tpq.push(Stat(sx,sy,0,ini));\n\t\twhile(!pq.empty()){\n\t\t\tStat a=pq.top();\tpq.pop();\n\t\t\tint x=a.x,y=a.y,cost=-a.cost;\n\t\t\tDice d=a.dice;\n\t\t\tif(x==gx && y==gy){ ans=cost; break; }\n\t\t\tif(cmin[y][x][d.t][d.w]<cost)\tcontinue;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h){\n\t\t\t\t\tDice nextdice=d;\n\t\t\t\t\tif(i==0)\t\tnextdice.rotx();\n\t\t\t\t\telse if(i==1)\tnextdice.roty();\n\t\t\t\t\telse if(i==2)\tnextdice.rotx(),nextdice.rotx(),nextdice.rotx();\n\t\t\t\t\telse\t\t\tnextdice.roty(),nextdice.roty(),nextdice.roty();\n\t\t\t\t\tint nextt=nextdice.t;\n\t\t\t\t\tint nextw=nextdice.w;\n\t\t\t\t\tint nextcost=cost+nextdice.b*grid[yy][xx];\n\t\t\t\t\tif(nextcost<cmin[yy][xx][nextt][nextw]){\n\t\t\t\t\t\tpq.push(Stat(xx,yy,-nextcost,nextdice));\n\t\t\t\t\t\tcmin[yy][xx][nextt][nextw]=nextcost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <string>\n#include <map>\n#include <set>\n#include <math.h>\n#define M 15\nusing namespace std;\n\nstruct node {\n    int x, y, bottom, east;\n    long long value;\n} Q[M*M*M*M*M], s, p;\nint mark[M][M][M][M];\nlong long dis[M][M][M][M];\nint value[M][M];\nint n, m;\nint sx, sy, ex, ey;\nlong long oo = 100000000000000LL;\nint add[7][7] = {\n    {0},\n    {5, 4, 2, 3},\n    {3, 1, 4, 6},\n    {2, 6, 5, 1},\n    {5, 6, 2, 1},\n    {6, 4, 1, 3},\n    {3, 2, 4, 5}\n};\n\nvoid checkIn(int &H) {\n    if (dis[s.x][s.y][s.bottom][s.east] > s.value) {\n        dis[s.x][s.y][s.bottom][s.east] = s.value;\n        if (!mark[s.x][s.y][s.bottom][s.east]) {\n        \tif(s.x==ex&&s.y==ey)return;\n            mark[s.x][s.y][s.bottom][s.east] = 1;\n            Q[H++] = s;\n        }\n        //printf(\"s %d %d %d %d\\n\", s.x, s.y, s.bottom, s.east);\n    }\n}\n\nint find(int e, int b, int k) {\n    int i;\n    for (i = 0; i < 4; i++)\n        if (add[e][i] == b) {\n            return add[e][(i + k + 4) % 4];\n        }\n}\n\nvoid SPFA() {\n    int i, j, k, x, y, bottom, east;\n    int L, H;\n    for (x = 0; x < n; x++)\n        for (y = 0; y < m; y++)\n            for (i = 1; i <= 6; i++)\n                for (j = 1; j <= 6; j++) {\n                    dis[x][y][i][j] = oo;\n                    mark[x][y][i][j] = 0;\n                }\n    dis[sx][sy][6][3] = 0;\n    s.x = sx, s.y = sy, s.bottom = 6, s.east = 3, s.value = 0;\n    mark[s.x][s.y][s.bottom][s.east] = 1;\n    L = H = 0;\n    Q[H++] = s;\n    while (L < H) {\n        p = Q[L++];\n        mark[p.x][p.y][p.bottom][p.east] = 0;\n        x = p.x, y = p.y;\n        if (x > 0) {//up\n            s.x = p.x - 1;\n            s.y = p.y;\n            s.bottom = find(p.east, p.bottom, 1);\n            s.east = p.east;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n        if (x < n - 1) {//down\n            s.x = p.x + 1;\n            s.y = p.y;\n            s.bottom = find(p.east, p.bottom, -1);\n            s.east = p.east;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n        if (y > 0) {//left\n            s.x = p.x;\n            s.y = p.y - 1;\n            s.bottom = 7 - p.east;\n            s.east = p.bottom;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n        if (y < m - 1) {//right\n            //puts(\"yes\");\n            s.x = p.x;\n            s.y = p.y + 1;\n            s.bottom = p.east;\n            s.east = 7 - p.bottom;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n    }\n}\n\nint main(int argc, char** argv) {\n    int i, j, k;\n    while (scanf(\"%d %d\", &n, &m), n | m) {\n        for (i = 0; i < n; i++)\n            for (j = 0; j < m; j++)\n                scanf(\"%d\", &value[i][j]);\n        scanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n        SPFA();\n        long long ans = oo;\n        for (i = 1; i <= 6; i++)\n            for (j = 1; j <= 6; j++)\n                if (dis[ex][ey][i][j] < ans)\n                    ans = dis[ex][ey][i][j];\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  int cost;\n  Dice d;\n  int y, x;\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State &s) const{\n    return cost > s.cost;\n  }\n};\n\nstruct mstruct{\n  int y, x;\n  Dice d;\n\n  bool operator<(const mstruct &m) const{\n    return y == m.y ? x < m.x : y < m.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.cost = 0;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<State, vector<State> > q;\n\n    q.push(s);\n    map<mstruct, int> m;\n    mstruct ms;\n    ms.y = sy; ms.x = sx;\n    ms.d.t = 1; ms.d.s = 2; s.d.e = 3;\n    m[ms] = 0;\n    while(!q.empty()){\n      State now = q.top(); q.pop();\n\n      if(now.y == gy && now.x == gx){\n\t res = min(res, now.cost);\n\t//\tprintf(\"%d\\n\", now.cost);\n\t//\tgoto e;\n      }\n      rep(d, 4){\n\tState next = now;\n\tnext.y += dy[d]; next.x += dx[d];\n\tint ny = next.y, nx = next.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.e;\n\t  next.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.d.t;\n\t  next.d.t = next.d.s;\n\t  next.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.d.e;\n\t  next.d.e = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.d.s;\n\t  next.d.s = next.d.t;\n\t  next.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.cost += cost[ny][nx] * (7 - next.d.t);\n\t//\tprintf(\"%d\\n\", next.cost);\n\tmstruct ns;\n\tns.y = ny; ns.x = nx;\n\tns.d.t = next.d.t; ns.d.s = next.d.s; ns.d.e = next.d.e;\n\tif(m.count(ns) != 0  && m[ns] <= next.cost) continue;\n\tm[ns] = next.cost;\n\t//printf(\"%d %d %d\\n\", next.y, next.x, next.cost);\n\tq.push(next);\n      }\n    }\n    printf(\"%d\\n\", res==INF?0:res);\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 10000000\nusing namespace std;\n\nint mdata[10][10];\nint h, w;\nint sx, sy, gx, gy;\nclass State{\npublic:\n  int x, y;\n  int sai[3];\n  int pe;\n};\n\nint bfs();\n\nmain(){\n  while(1){\n    cin >> h >> w;\n    if(h==0 && w==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mdata[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    cout << bfs() << endl;\n  }\n  return 0;\n}\n\nint bfs(){\n  int dx[4]={0, 1, 0, -1};\n  int dy[4]={-1, 0, 1, 0};\n  int cost[10][10];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cost[i][j]=INF;\n    }\n  }\n  State u, v;\n  u.sai[0]=1;\n  u.sai[1]=2;\n  u.sai[2]=3;\n  u.pe=0;\n  u.x=sx;\n  u.y=sy;\n  queue<State> Q;\n  Q.push(u);\n  while(!Q.empty()){\n    u=Q.front(), Q.pop();\n    //printf(\"%d %d %d %d %d %d\\n\", u.x, u.y, u.sai[0], u.sai[1], u.sai[2], u.pe);\n    if(u.x==gx && u.y==gy) continue;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << cost[i][j] << ' ';\n      }\n      cout << endl;\n      }*/\n    for(int i=0;i<4;i++){\n      int ty, tx;\n      ty=u.y+dy[i];\n      tx=u.x+dx[i];\n      if(ty>=0 && ty<h){\n\tif(tx>=0 && tx<w){\n\t  int tmp;\n\t  if(i==0){\n\t    tmp=(7-u.sai[1])*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.pe=tmp;\n\t      v.sai[0]=u.sai[1];\n\t      v.sai[1]=7-u.sai[0];\n\t      v.sai[2]=u.sai[2];\n\t      Q.push(v);\n\t    }\n\t  }\n\t  else if(i==1){\n\t    tmp=u.sai[2]*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=7-u.sai[2];\n\t      v.sai[1]=u.sai[1];\n\t      v.sai[2]=u.sai[0];\n\t      Q.push(v);\n\t    }\n\t  }\n\t  else if(i==2){\n\t    tmp=u.sai[1]*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=7-u.sai[1];\n\t      v.sai[1]=u.sai[0];\n\t      v.sai[2]=u.sai[2];\n\t      Q.push(v);\n\t    }\n\t  }\n\t  else if(i==3){\n\t    tmp=(7-u.sai[2])*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=u.sai[2];\n\t      v.sai[1]=u.sai[1];\n\t      v.sai[2]=7-u.sai[0];\n\t      Q.push(v);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return cost[gy][gx];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<'L'<<__LINE__<<\": \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tos<<'(';\n\tprint_tuple<Args...>(os,t);\n\treturn os<<')';\n}\n\nstruct Die{\n\tarray<int,6> faces;\n\tDie(){\n\t\tfaces[0]=2; faces[1]=5;\n\t\tfaces[2]=3; faces[3]=4;\n\t\tfaces[4]=1; faces[5]=6;\n\t}\n\tvoid Rotate(int a,int b,int c,int d){\n\t\tswap(faces[a],faces[b]);\n\t\tswap(faces[b],faces[c]);\n\t\tswap(faces[c],faces[d]);\n\t}\n\tvoid TurnU(){Rotate(4,0,5,1);}\n\tvoid TurnD(){Rotate(4,1,5,0);}\n\tvoid TurnL(){Rotate(4,2,5,3);}\n\tvoid TurnR(){Rotate(4,3,5,2);}\n};\nbool operator<(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(a.faces),end(a.faces),begin(b.faces),end(b.faces));\n}\nbool operator>(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(b.faces),end(b.faces),begin(a.faces),end(a.faces));\n}\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvector<vector<int>> grid(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>grid[i][j];\n\t\tint si,sj,gi,gj; cin>>si>>sj>>gi>>gj;\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<Die,int,int,int> a,tuple<Die,int,int,int> b){\n\t\t\treturn get<3>(a)>get<3>(b);\n\t\t});\n\t\tpq.emplace(Die(),si,sj,0);\n\t\tset<tuple<Die,int,int>> vis;\n\t\twhile(pq.size()){\n\t\t\tDie d; int i,j,c; tie(d,i,j,c)=pq.top(); pq.pop();\n\t\t\tif(vis.count(make_tuple(d,i,j))) continue;\n\t\t\tvis.insert(make_tuple(d,i,j));\n\t\t\tif(i==gi && j==gj){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfunction<void(Die&)> turns[]={&Die::TurnU,&Die::TurnD,&Die::TurnL,&Die::TurnR};\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w){\n\t\t\t\t\tDie t=d;\n\t\t\t\t\tturns[k](t);\n\t\t\t\t\tpq.emplace(t,ni,nj,c+t.faces[5]*grid[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nint d[6700],w,h,m[10][10],sx,sy,gx,gy,dx[]={1,0,-1,0},dy[]={0,1,0,-1},r[][7]={{},{0,0,3,5,2,4,0},{0,4,0,1,6,0,3},{0,2,6,0,0,1,5},{0,5,1,0,0,6,2},{0,3,0,6,1,0,4},{0,0,4,2,5,3,0}};\nvector<edge> g[6600];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+6700,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>h>>w&&h){\n\t\trep(i,6600)g[i].clear();\n\t\trep(i,h)rep(j,w)cin>>m[i][j];\n\t\tcin>>sy>>sx>>gy>>gx;int count=0;\n\t\trep(y,h)rep(x,w)for(int t=1;t<7;t++)for(int f=1;f<7;f++)rep(d,4){\n\t\t\tedge e;\n\t\t\tint nx=x+dx[d],ny=y+dy[d];\n\t\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h&&t!=f&&t+f!=7){\n\t\t\t\tswitch(d){\n\t\t\t\tcase 0:\n\t\t\t\t\te.to=(7-r[t][f])*1000+f*100+ny*10+nx;\n\t\t\t\t\te.cost=m[ny][nx]*r[t][f];break;\n\t\t\t\tcase 1:\n\t\t\t\t\te.to=(7-f)*1000+t*100+ny*10+nx;\n\t\t\t\t\te.cost=m[ny][nx]*f;break;\n\t\t\t\tcase 2:\n\t\t\t\t\te.to=r[t][f]*1000+f*100+ny*10+nx;\n\t\t\t\t\te.cost=m[ny][nx]*(7-r[t][f]);break;\n\t\t\t\tcase 3:\n\t\t\t\t\te.to=f*1000+(7-t)*100+ny*10+nx;\n\t\t\t\t\te.cost=m[ny][nx]*(7-f);break;\n\t\t\t\t}\n\t\t\t\tg[t*1000+f*100+y*10+x].push_back(e);\n\t\t\t}\n\t\t}\n\t\tdijkstra(1200+sy*10+sx);\n\t\tint ans=INF;\n\t\trep(t,7)rep(f,7)ans=min(ans,d[t*1000+f*100+gy*10+gx]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Cost first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  Dice d;\n  int y, x;\n\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State& right) const{\n    return y == right.y ? x < right.x : y < right.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<pair<int, State>, vector<pair<int, State> >, greater<pair<int, State> > > q;\n    q.push(MP(0, s));\n    map<pi, int> m;\n    m[MP(sy, sx)] = 0;\n    while(!q.empty()){\n      pair<int, State> now = q.top(); q.pop();\n\n      if(now.S.y == gy && now.S.x == gx) res = min(res, now.Cost);\n\n      rep(d, 4){\n\tpair<int , State> next = now;\n\tnext.S.y += dy[d]; next.S.x += dx[d];\n\tint ny = next.S.y, nx = next.S.x;\n\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\tint tmp;\n\tswitch(d){\n\tcase 0: // west\n\t  tmp = 7 - next.S.d.t;\n\t  next.S.d.t = next.S.d.e;\n\t  next.S.d.e = tmp;\n\t  break;\n\tcase 1: // north\n\t  tmp = 7 - next.S.d.t;\n\t  next.S.d.t = next.S.d.s;\n\t  next.S.d.s = tmp;\n\t  break;\n\tcase 2: // east\n\t  tmp = 7 - next.S.d.e;\n\t  next.S.d.e = next.S.d.t;\n\t  next.S.d.t = tmp;\n\t  break;\n\tcase 3: // south\n\t  tmp = 7 - next.S.d.s;\n\t  next.S.d.s = next.S.d.t;\n\t  next.S.d.t = tmp;\n\t  break;\n\t}\n\n\tnext.Cost += cost[ny][nx] * (7 - next.S.d.t);\n\tif(m.count(MP(ny, nx)) != 0  && m[MP(ny,nx)] <= next.Cost) continue;\n\tm[MP(ny,nx)] = next.Cost;\n\t//\t  printf(\"%d %d\\n\", ny, nx);\n\t/*\t  if(ny == gy && nx == gx){\n\t\t  res = min(res, next.Cost);\n\t\t  break;\n\t\t  }*/\n\tq.push(next);\n      }\n    }\n    printf(\"%d\\n\", res==INF?0:res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr int NUMBER_OF_FACES = 6;\nenum FACE { TOP, BOTTOM, NORTH, SOUTH, WEST, EAST };\n\nclass dice {\nprivate:\n\tint num[NUMBER_OF_FACES];\n\npublic:\n\tinline void roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[NORTH] = 5;\n\t\tnum[SOUTH] = 2;\n\t\tnum[EAST] = 3;\n\t\tnum[WEST] = 4;\n\t}\n\n\tdice(const dice& d) {\n\t\tnum[TOP] = d[TOP];\n\t\tnum[BOTTOM] = d[BOTTOM];\n\t\tnum[NORTH] = d[NORTH];\n\t\tnum[SOUTH] = d[SOUTH];\n\t\tnum[EAST] = d[EAST];\n\t\tnum[WEST] = d[WEST];\n\t}\n\n\tinline int encode() const {\n\t\treturn (num[TOP] - 1) * NUMBER_OF_FACES * NUMBER_OF_FACES + (num[NORTH] - 1) * NUMBER_OF_FACES + (num[EAST] - 1);\n\t}\n\n\tconst int& operator[] (FACE f) const { return num[f]; }\n};\n\nvoid north(dice& d) { d.roll(TOP, SOUTH, BOTTOM, NORTH); }\nvoid east(dice& d) { d.roll(TOP, WEST, BOTTOM, EAST); }\nvoid west(dice& d) { d.roll(TOP, EAST, BOTTOM, WEST); }\nvoid south(dice& d) { d.roll(TOP, NORTH, BOTTOM, SOUTH); }\n\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nvoid (*rotate_dice[4])(dice& d) = {east, south, west, north};\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int INF = 0xfffffff;\n\nint h, w;\nint gx, gy;\nint field[MAX_SIZE][MAX_SIZE];\n\ntypedef int weight;\nstruct state {\n\tint x, y;\n\tdice d;\n\tweight dist;\n\tstate(int x, int y, const dice& d, weight dist):x(x), y(y), d(d), dist(dist){}\n\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\ninline bool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\nweight dijkstra(int sx, int sy, dice d) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<vector<weight>>> dist(h, vector<vector<weight>>(w, vector<weight>(NUMBER_OF_FACES*NUMBER_OF_FACES*NUMBER_OF_FACES, INF)));\n\tdist[sy][sx][d.encode()] = 0;\n\tque.push(state(sx, sy, d, 0));\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.y][s.x][s.d.encode()] < s.dist)\n\t\t\tcontinue;\n\n\t\tif(s.x == gx && s.y == gy)\n\t\t\treturn s.dist;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tconst int nx = s.x + dx[i];\n\t\t\tconst int ny = s.y + dy[i];\n\t\t\tif(out(nx, ny)) continue;\n\t\t\tdice next_d(s.d);\n\t\t\trotate_dice[i](next_d);\n\n\t\t\tconst int next_dist = s.dist + next_d[BOTTOM] * field[ny][nx];\n\t\t\tconst int value = next_d.encode();\n\t\t\tif(dist[ny][nx][value] > next_dist) {\n\t\t\t\tdist[ny][nx][value] = next_dist;\n\t\t\t\tque.push(state(nx, ny, next_d, next_dist));\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\n\t\tcout << dijkstra(sx, sy, dice()) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define INF 10000000\n// max=6*9 * 10*10\nusing namespace std;\n\ntypedef struct {\n  int x,y,p,m ; // ÂÃÂÂ®ÂÃ£ÂÃÂ}ÂXÂAÂyÂiÂÂÂeÂB, ÂÃ\n} State;\n\nint main(){\n  int h,w,x,y;\n  int g[10][10];\n  int sx,sy, gx,gy;\n  int dx[4] = { 0,1,0,-1 };  // ÂÃ£ÂAÂEÂAÂÂºÂAÂÂ¶\n  int dy[4] = { -1,0,1,0 };\n  int dice[7][4] = // 1,2,... ÂÂªÂÃ£ÂÃÂÂ ÂÃ©ÂÂÂÃÂÂ¡ÂÃÂÂÂÂ\n    {\n      { 0,0,0,0 },\n      { 2,4,5,3 }, { 6,4,1,3 },\n      { 2,1,5,6 }, { 2,6,5,1 },\n      { 1,4,6,3 }, { 2,3,5,4 }\n    };\n  queue<State> q;\n  State st, st2;\n\n  while( cin>>h>>w && ( h||w ) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++)\n\tcin >> g[i][j];\n    cin >> sy>>sx>> gy>>gx;\n\n    /*\n    cout << \"h=\"<<h<<\" w=\"<<w<<endl;\n    cout << \"start=(\"<<sx<<\",\"<<sy<<\") goal=(\"<<gx<<\",\"<<gy<<\")\"<<endl;\n    */\n    st.x=sx; st.y=sy; st.p=0; st.m=1;\n    q.push( st );\n\n    int min = INF;\n\n    //    int loop=0;\n\n    while( q.size()>0 ){\n      st = q.front(); q.pop();\n\n      /******\n      cout << \"size=\"<<q.size()<<\" min=\"<<min\n\t   <<\" x=\"<<st.x<<\" y=\"<<st.y\n\t   <<\" p=\"<<st.p<<\" m=\"<<st.m   <<endl;\n      if( loop++>10 )\n\tbreak;\n      /*******/\n\n      if( st.p>min )\n\tcontinue;\n\n      if( (st.x==gx) && (st.y==gy) ){ // goal\n\t//\tcout << \"goal\" << endl;\n\tif( min>st.p )\n\t  min=st.p;\n\tcontinue;\n      }\n\n      for( int i=0;i<4;i++ ){\n\n\n\tx=st.x+dx[i]; y=st.y+dy[i];\n\tif( 0<=x && x<w && 0<=y && y<h ){\n\t  st2.x=x; st2.y=y;\n\t  st2.p= st.p + g[y][x] * (7-dice[st.m][i]);\n\t  st2.m = dice[st.m][i];\n\t  q.push( st2 );\n\t}\n      }\n    }\n    cout << min << endl;\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\n#include<string.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tDice(int top,int bottom,int north,int south,int east,int west,int sx,int sy,int cost){\n\t\tt=top,b=bottom,n=north,s=south,e=east,w=west;\n\t\tx=sx,y=sy,c=cost;\n\t}\n\tbool operator<(const Dice &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint w,h;\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nint main(){\n\tint p[10][10],memo[10][10][100];\n\twhile(cin>>h>>w && h!=0){\n\t\tpriority_queue<Dice> que;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>p[y][x];\n\t\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\n\t\tint gx,gy,sx,sy;\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\tque.push(Dice(1,6,5,2,3,4,sx,sy,0));\n\t\twhile(!que.empty()){\n\t\t\tDice now=que.top();\n\t\t\tque.pop();\n//\t\t\tcout<<now.x<<\" \"<<now.y<<\" \"<<now.b<<\" \"<<now.c<<endl;\n\t\t\tif(now.x==gx && now.y==gy) {cout<<now.c<<endl; break;}\n\t\t\tif(memo[now.y][now.x][now.e*7+now.b]>=0 && memo[now.y][now.x][now.e*7+now.b]<=now.c) continue;\n\t\t\tmemo[now.y][now.x][now.e*7+now.b]=now.c;\n\n\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tDice copy=now;\n\t\t\t\tcopy.roll(r);\n\t\t\t\tif(in(copy.x,copy.y)){\n\t\t\t\t\tcopy.c+=copy.b*p[copy.y][copy.x];\n\t\t\t\t\tque.push(copy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n// max=6*9 * 10*10\nusing namespace std;\n\ntypedef struct {\n  short x,y ; // ÂÃÂÂ®ÂÃ£ÂÃÂ}ÂX\n  unsigned short p; // ÂyÂiÂÂÂeÂB\n  short m; // ÂÃ\n} State;\n\nint main(){\n  short h,w,x,y;\n  short g[10][10];\n  short sx,sy, gx,gy;\n  short dx[4] = { 0,1,0,-1 };  // ÂÃ£ÂAÂEÂAÂÂºÂAÂÂ¶\n  short dy[4] = { -1,0,1,0 };\n  short dice[7][4] = // 1,2,... ÂÂªÂÃ£ÂÃÂÂ ÂÃ©ÂÂÂÃÂÂ¡ÂÃÂÂÂÂ\n    {\n      { 0,0,0,0 },\n      { 2,4,5,3 }, { 6,4,1,3 },\n      { 2,1,5,6 }, { 2,6,5,1 },\n      { 1,4,6,3 }, { 2,3,5,4 }\n    };\n  queue<State> q;\n  State st, st2;\n  unsigned int flag[10][10];\n  unsigned int min;\n\n  while( cin>>h>>w && ( h||w ) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++)\n\tcin >> g[i][j];\n    cin >> sy>>sx>> gy>>gx;\n\n    st.x=sx; st.y=sy; st.p=0; st.m=1;\n    q.push( st );\n\n    memset( flag,-1,sizeof(flag) );\n    min = flag[0][0];\n\n    while( q.size()>0 ){\n      st = q.front(); q.pop();\n      /*\n      if( st.p>min )\n\tcontinue;\n      */\n      if( flag[st.y][st.x]> st.p ){\n\tflag[st.y][st.x] = st.p;\n      } else if( flag[st.y][st.x] < st.p ){\n\tcontinue;\n      }\n\n      if( (st.x==gx) && (st.y==gy) ){ // goal\n\tif( min>st.p )\n\t  min=st.p;\n\tcontinue;\n      }\n\n      for( int i=0;i<4;i++ ){\n\tx=st.x+dx[i]; y=st.y+dy[i];\n\tif( 0<=x && x<w && 0<=y && y<h ){\n\t  st2.x=x; st2.y=y;\n\t  st2.p= st.p + g[y][x] * (7-dice[st.m][i]);\n\t  st2.m = dice[st.m][i];\n\t  q.push( st2 );\n\t}\n      }\n    }\n    cout << min << endl;\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\ntypedef struct{\n  int t,b,n,w,s,e;\n}dice;\n\ntypedef struct{\n  int x,y;\n  int cost;\n  dice d;\n}state;\n\n\nmain(){\n  int h,w;\n  while(cin>>h>>w,h|w){\n    int cost[h][w][6*6];\n    rep(i,h)rep(j,w)rep(k,36)cost[i][j][k]=INT_MAX/2;\n\n    dice td;\n    td.t=1;\n    td.b=6;\n    td.s=2;\n    td.n=5;\n    td.e=3;\n    td.w=4;\n\n    int pen[h][w];\n    rep(i,h)rep(j,w)cin>>pen[i][j];\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n\n    queue<state> Q;\n    state tstate={sx,sy,0,td};\n    Q.push(tstate);\n    cost[sx][sy][6+4]=0;\n\n    int ans=INT_MAX/2;\n\n    while(!Q.empty()){\n      tstate=Q.front();Q.pop();\n\n      int cx=tstate.x,cy=tstate.y;\n      int ccost=tstate.cost;\n      dice cd=tstate.d;\n      if(ccost>ans)continue;\n      if(cx==gx && cy==gy){\n\tans=ccost;\n\tcontinue;\n      }\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || ny<0 || h<=nx || w<=ny)continue;\n\tdice nd=cd;\n\tint t=nd.t;\n\tswitch(i){\n\tcase 0://e\n\t  nd.t=nd.w;\n\t  nd.w=nd.b;\n\t  nd.b=nd.e;\n\t  nd.e=t;\n\t  break;\n\tcase 1://s\n\t  nd.t=nd.n;\n\t  nd.n=nd.b;\n\t  nd.b=nd.s;\n\t  nd.s=t;\n\t  break;\n\tcase 2://w\n\t  nd.t=nd.e;\n\t  nd.e=nd.b;\n\t  nd.b=nd.w;\n\t  nd.w=t;\n\t  break;\n\tcase 3://n\n\t  nd.t=nd.s;\n\t  nd.s=nd.b;\n\t  nd.b=nd.n;\n\t  nd.n=t;\n\t  break;\n\t}\n\tint ncost=ccost+nd.b*pen[nx][ny];\n\tint dst=nd.t*6+nd.n-1;\n\tif(cost[nx][ny][dst]<=ncost)continue;\n\tcost[nx][ny][dst]=ncost;\n\ttstate.x=nx;\n\ttstate.y=ny;\n\ttstate.cost=ncost;\n\ttstate.d=nd;\n\tQ.push(tstate);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\ntypedef struct{\n  int t,b,n,w,s,e;\n}dice;\n\ntypedef struct{\n  int x,y;\n  int cost;\n  dice d;\n}state;\n\n\nmain(){\n  int h,w;\n  while(cin>>h>>w,h|w){\n    int cost[h][w][6*6];\n    rep(i,h)rep(j,w)rep(k,36)cost[i][j][k]=INT_MAX;\n\n    dice td;\n    td.t=1;\n    td.b=6;\n    td.s=2;\n    td.n=5;\n    td.e=3;\n    td.w=4;\n\n    int pen[h][w];\n    rep(i,h)rep(j,w)cin>>pen[i][j];\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n\n    queue<state> Q;\n    state tstate={sx,sy,0,td};\n    Q.push(tstate);\n    cost[sx][sy][4]=0;\n\n    int ans=INT_MAX;\n\n    while(!Q.empty()){\n      tstate=Q.front();Q.pop();\n\n      int cx=tstate.x,cy=tstate.y;\n      int ccost=tstate.cost;\n      dice cd=tstate.d;\n      if(ccost>ans)continue;\n      if(cx==gx && cy==gy){\n\tans=ccost;\n\tcontinue;\n      }\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || ny<0 || h<=nx || w<=ny)continue;\n\tdice nd=cd;\n\tint t=nd.t;\n\tswitch(i){\n\tcase 0://e\n\t  nd.t=nd.w;\n\t  nd.w=nd.b;\n\t  nd.b=nd.e;\n\t  nd.e=t;\n\t  break;\n\tcase 1://s\n\t  nd.t=nd.n;\n\t  nd.n=nd.b;\n\t  nd.b=nd.s;\n\t  nd.s=t;\n\t  break;\n\tcase 2://w\n\t  nd.t=nd.e;\n\t  nd.e=nd.b;\n\t  nd.b=nd.w;\n\t  nd.w=t;\n\t  break;\n\tcase 3://n\n\t  nd.t=nd.s;\n\t  nd.s=nd.b;\n\t  nd.b=nd.n;\n\t  nd.n=t;\n\t  break;\n\t}\n\tint ncost=ccost+nd.b*pen[nx][ny];\n\tint dst=(nd.t-1)*6+nd.n-1;\n\tif(cost[nx][ny][dst]<=ncost)continue;\n\tcost[nx][ny][dst]=ncost;\n\ttstate.x=nx;\n\ttstate.y=ny;\n\ttstate.cost=ncost;\n\ttstate.d=nd;\n\tQ.push(tstate);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstd::istream &operator>>(std::istream &is, P &p){\n\treturn is >> p.first >> p.second;\n}\n\nstruct Dice{\nprivate:\n\tstatic const int _roll[4][6], _turn[2][6];\npublic:\n\tvector<int> value;\n\t// 1-6 : top, near, right, left, far, bottom \n\n\tDice(){\n\t\tvalue.resize(6);\n\t\tfor (int i = 0; i < 6; ++i) value[i] = i+1;\n\t}\n\tDice(initializer_list<int> il){\n\t\tvalue.resize(6, -1);\n\t\tint cnt = 0;\n\t\tfor (auto &e : il){\n\t\t\tvalue[cnt++] = e;\n\t\t\tif (cnt >= 6) break;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) if (value[i] < 0) value[i] = 5 - value[5 - i];\n\t}\n\n\tvoid roll(int dir){ // N, E, W, S\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_roll[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tvoid turn(int dir){ // L, R\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_turn[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tint &operator[](int i){\n\t\treturn value[i];\n\t}\n};\n\nconst int Dice::_roll[4][6] = {\n\t{ 1, 5, 2, 3, 0, 4 }, // North\n\t{ 3, 1, 0, 5, 4, 2 }, // East\n\t{ 2, 1, 5, 0, 4, 3 }, // West\n\t{ 4, 0, 2, 3, 5, 1 }, // South\n};\n\nconst int Dice::_turn[2][6] = {\n\t{ 0, 3, 1, 4, 2, 5 }, // Left\n\t{ 0, 2, 4, 1, 3, 5 }, // Right\n};\n\nint board[10][10];\n\nstruct state{\n\tP first;\n\tDice second;\n\tbool operator<(const state &r)const{\n\t\treturn first < r.first;\n\t}\n};\n\nint dx[] = {0, 1, -1, 0};\nint dy[] = {-1, 0, 0, 1};\n\nint main(){\n\tint h, w;\n\twhile (cin >> h >> w, h | w){\n\t\trep(i, h) rep(j, w) cin >> board[i][j];\n\t\tP s, g;\n\t\tcin >> s >> g;\n\n\t\tmap<state, int> m;\n\n\t\tpriority_queue<pair<int, state>, vector<pair<int, state>>, greater<pair<int, state>>> q;\n\t\tq.push(make_pair(0, state{ s, Dice() }));\n\t\tint ans = -1;\n\t\twhile (!q.empty()){\n\t\t\tint dist = q.top().first;\n\t\t\tstate s = q.top().second;\n\t\t\tP &pos = s.first;\n\t\t\tDice &d = s.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif (m[s] < dist) continue;\n\t\t\tif (s.first == g){\n\t\t\t\tans = dist;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint nx = pos.second + dx[i], ny = pos.first + dy[i];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\tstate nxt = s;\n\t\t\t\tnxt.second.roll(i);\n\t\t\t\tnxt.first = make_pair(ny, nx);\n\t\t\t\tif (m.count(nxt) && m[nxt] <= dist + nxt.second[5] * board[ny][nx]) continue;\n\t\t\t\tm[nxt] = dist + nxt.second[5] * board[ny][nx];\n\t\t\t\tq.push(make_pair(dist + nxt.second[5] * board[ny][nx], nxt));\n\t\t\t}\n\t\t}\n\t\tcout << \"+++\";\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <map>\n#include <queue>\n#include <vector>\n\n#define X first\n#define Y second\n#define P first\n#define S second\n#define mp(x, y) make_pair(x, y)\n\nusing namespace std;\ntypedef ostringstream OSS;\ntypedef pair<int, int> PII;\ntypedef pair<PII, string> PIIS;\n\nstruct die_t {\n\tint top, front, right, left, back, bottom;\n\tdie_t ( int t, int f, int r, int l, int bk, int b )\n\t\t: top(t), front(f), right(r), left(l), back(bk), bottom(b) { }\n\tdie_t ( string dice ) {\n\t\ttop = dice[0] - '0'; front = dice[1] - '0'; right = dice[2] - '0';\n\t\tleft = dice[3] - '0'; back = dice[4] - '0'; bottom = dice[5] - '0';\n\t}\n\tvoid rotate_swap ( int &a, int &b, int &c, int &d ) {\n\t\tswap(a, b); swap(b, c); swap(c, d);\n\t}\n\tvoid rotate_right ( void ) { rotate_swap(top,left,bottom,right); }\n\tvoid rotate_left ( void ) { rotate_swap(top,right,bottom,left); }\n\tvoid rotate_front ( void ) { rotate_swap(top,back,bottom,front); }\n\tvoid rotate_back ( void ) { rotate_swap(top,front,bottom,back); }\n\tvoid rotate_cw ( void ) { rotate_swap(back,left,front,right); }\n\tvoid rotate_cc ( void ) { rotate_swap(back,right,front,left); }\n\tbool rotate_set ( int n, int t, int f, int r, int l, int bk, int b ) {\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tif (n == equal_num(t, f, r, l, bk, b)) { return true; }\n\t\t\t\trotate_cw();\n\t\t\t}\n\t\t\t(i&1 ? rotate_front() : rotate_right());\n\t\t}\n\t\treturn false;\n\t}\n\tint equal_num ( int t, int f, int r, int l, int bk, int b ) {\n\t\treturn (top==t) + (front==f) + (right==r) + (left==l) + (back==bk) + (bottom==b);\n\t}\n\tstring toString ( void ) {\n\t\tOSS os; os << top << front << right << left << back << bottom;\n\t\treturn os.str();\n\t}\n};\n\nconst int INF = 1 << 29;\nconst int MAX_WH = 10;\n\nint main ( void )\n{\n\tvector<string> vs;\n\tdie_t dd(\"123456\");\n\tfor (int i = 0; i < 6; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tvs.push_back(dd.toString());\n\t\t\tdd.rotate_cw();\n\t\t}\n\t\tif (i&1) { dd.rotate_front(); }\n\t\telse { dd.rotate_right(); }\n\t}\n\n\tint h, w, mat[MAX_WH][MAX_WH];\n\n\twhile (cin >> h >> w, h | w) {\n\t\tmap<string, int> M[MAX_WH][MAX_WH];\n\t\tfor (int y = 0; y < h; ++y) {\n\t\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t\tcin >> mat[y][x];\n\t\t\t\tfor (int i = 0, I = vs.size(); i < I; ++i) {\n\t\t\t\t\tM[y][x].insert(mp(vs[i], INF));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPII s, g;\n\t\tcin >> s.Y >> s.X;\n\t\tcin >> g.Y >> g.X;\n\n\t\tdie_t dice(\"123456\");\n\t\tqueue<PIIS> Q;\n\t\tM[s.Y][s.X][\"123456\"] = 0;\n\t\tQ.push(mp(mp(s.X, s.Y), dice.toString()));\n\n\t\twhile (!Q.empty()) {\n\t\t\tPIIS piis = Q.front(); Q.pop();\n\t\t\tPII p = piis.P;\n\t\t\tstring s = piis.S, s1, s2, s3, s4;\n\t\t\tdie_t d1(s), d2(s), d3(s), d4(s);\n\t\t\td1.rotate_right(); s1 = d1.toString();\n\t\t\td2.rotate_left(); s2 = d2.toString();\n\t\t\td3.rotate_front(); s3 = d3.toString();\n\t\t\td4.rotate_back(); s4 = d4.toString();\n\t\t\tint now = M[p.Y][p.X][s];\n\n\t\t\tif (p.X + 1 < w\n\t\t\t&& M[p.Y][p.X+1][s1] > now + mat[p.Y][p.X+1] * d1.bottom) {\n\t\t\t\tM[p.Y][p.X+1][s1] = now + mat[p.Y][p.X+1] * d1.bottom;\n\t\t\t\tQ.push(mp(mp(p.X+1, p.Y), s1));\n\t\t\t}\n\t\t\tif (p.X - 1 >=0\n\t\t\t&& M[p.Y][p.X-1][s2] > now + mat[p.Y][p.X-1] * d2.bottom) {\n\t\t\t\tM[p.Y][p.X-1][s2] = now + mat[p.Y][p.X-1] * d2.bottom;\n\t\t\t\tQ.push(mp(mp(p.X-1, p.Y), s2));\n\t\t\t}\n\t\t\tif (p.Y + 1 < h\n\t\t\t&& M[p.Y+1][p.X][s3] > now + mat[p.Y+1][p.X] * d3.bottom) {\n\t\t\t\tM[p.Y+1][p.X][s3] = now + mat[p.Y+1][p.X] * d3.bottom;\n\t\t\t\tQ.push(mp(mp(p.X, p.Y+1), s3));\n\t\t\t}\n\t\t\tif (p.Y - 1 >=0\n\t\t\t&& M[p.Y-1][p.X][s4] > now + mat[p.Y-1][p.X] * d4.bottom) {\n\t\t\t\tM[p.Y-1][p.X][s4] = now + mat[p.Y-1][p.X] * d4.bottom;\n\t\t\t\tQ.push(mp(mp(p.X, p.Y-1), s4));\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0, I = vs.size(); i < I; ++i) {\n\t\t\tans = min(ans, M[g.Y][g.X][vs[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nenum direction{\n  UP    = 0,\n  RIGHT = 1,\n  DOWN  = 2,\n  LEFT  = 3\n};\n\n/*\n *   6\n *   2\n * 3 1 4\n *   5\n */\n\n/* top and RIGHT */\nint next_top[7][7][4];\nint next_left[7][7][4];\nint front[7][7];\n\nvoid initDie(){\n  front[1][3] = 2; front[1][2] = 4; front[1][4] = 5; front[1][5] = 3;\n  front[2][1] = 3; front[2][3] = 6; front[2][4] = 1; front[2][6] = 4;\n  front[3][1] = 5; front[3][2] = 1; front[3][5] = 6; front[3][6] = 2;\n  for(int i = 4; i < 7; i++){\n    for(int j = 1; j < 7; j++){\n      if(i == j || i + j == 7) continue;\n      int t = 7 - i;\n      int l = 7 - j;\n      front[i][j] = front[t][l];\n    }\n  }\n\n  for(int t = 1; t < 7; t++){\n    for(int l = 1; l < 7; l++){\n      if(t == l || t + l == 7) continue;\n\n      next_top[t][l][UP]     = 7 - front[t][l];\n      next_top[t][l][LEFT]   = 7 - l;\n      next_top[t][l][RIGHT]  = l;\n      next_top[t][l][DOWN]   = front[t][l];\n\n      next_left[t][l][UP]    = l;\n      next_left[t][l][LEFT]  = t;\n      next_left[t][l][RIGHT] = 7 - t;\n      next_left[t][l][DOWN]  = l;\n    }\n  }\n}\n\nint b[10][10];\nint memo[10][10][7][7];\n\nint main(){\n  int h,w;\n\n  initDie();\n\n  while((h = getInt()) + (w = getInt())){\n    REP(i,h) REP(j,w) b[i][j] = getInt();\n    int sx = getInt();\n    int sy = getInt();\n    int gy = getInt();\n    int gx = getInt();\n    typedef pair<int, pair<pair<int,int>,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    pq.push(mp(0, mp( mp(sx,sy), mp(1, 4))));\n    memset(memo, -1, sizeof(memo));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      int cost = d.f;\n      int x = d.s.f.f;\n      int y = d.s.f.s;\n      int t = d.s.s.f;\n      int l = d.s.s.s;\n\n      //printf(\"cost = %d, (%d,%d) (%d,%d)\\n\",cost,x,y,t,l);\n\n      if(x == gx && y == gy){\n        print(cost);\n        break;\n      }\n\n      if(memo[x][y][t][l] != -1)\n        continue;\n\n      memo[x][y][t][l] = cost;\n\n      REP(i,4){\n        int xx = x + _dx[i];\n        int yy = y + _dy[i];\n        if(!ISIN(xx,yy,w,h)) continue;\n        int tt = next_top[t][l][i];\n        int ll = next_left[t][l][i];\n\n        int cc = cost + (7 - tt) * b[yy][xx];\n\n        if(memo[xx][yy][tt][ll] == -1)\n          pq.push(mp(cc, mp( mp(xx,yy), mp(tt,ll))));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nstruct S{int n,e,s,w,u,d,p,x,y;bool operator<(const S&r)const{return p>r.p;}};\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint S::*r[4][2]={\n\t{&S::e,&S::w},\n\t{&S::s,&S::n},\n\t{&S::w,&S::e},\n\t{&S::n,&S::s},\n};\nvoid R(int&a,int&b,int&c,int&d){int t=a;a=b,b=c,c=d,d=t;}\nint main()\n{\n\tint h,w,a[10][10],sx,sy,gx,gy,i,j;\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\tfor(i=0;i<h;++i)for(j=0;j<w;++j)scanf(\"%d\",&a[i][j]);\n\t\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\t\tstd::priority_queue<S>q;\n\t\tS s={5,3,2,4,1,6,0,sx,sy};\n\t\tq.push(s);\n\t\tbool f[10][10][7][7]={0};\n\t\tfor(;;)\n\t\t{\n\t\t\ts=q.top();q.pop();\n\t\t\tif(s.x==gx&&s.y==gy){printf(\"%d\\n\",s.p);break;}\n\t\t\tif(f[s.y][s.x][s.u][s.s]++)continue;\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tS t=s;\n\t\t\t\tt.x+=dx[i];t.y+=dy[i];\n\t\t\t\tif(t.x<0||t.y<0||t.x>=w||t.y>=h)continue;\n\t\t\t\tR(t.d,t.*r[i][0],t.u,t.*r[i][1]);\n\t\t\t\tt.p+=a[t.y][t.x]*t.d;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 1000000000\nusing namespace std;\n\nint mdata[10][10];\nint h, w;\nint sx, sy, gx, gy;\nclass State{\npublic:\n  int x, y;\n  int sai[3];\n  int pe;\n};\n\nint bfs();\n\nmain(){\n  while(1){\n    cin >> h >> w;\n    if(h==0 && w==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mdata[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    cout << bfs() << endl;\n  }\n  return 0;\n}\n\nint bfs(){\n  int dx[4]={0, 1, 0, -1};\n  int dy[4]={-1, 0, 1, 0};\n  int cost[10][10];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cost[i][j]=INF;\n    }\n  }\n  State u, v;\n  u.sai[0]=1;\n  u.sai[1]=2;\n  u.sai[2]=3;\n  u.pe=0;\n  u.x=sx;\n  u.y=sy;\n  queue<State> Q;\n  Q.push(u);\n  while(!Q.empty()){\n    u=Q.front(), Q.pop();\n    //printf(\"%d %d %d %d %d %d\\n\", u.x, u.y, u.sai[0], u.sai[1], u.sai[2], u.pe);\n    if(u.x==gx && u.y==gy) continue;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << cost[i][j] << ' ';\n      }\n      cout << endl;\n      }*/\n    for(int i=0;i<4;i++){\n      int ty, tx;\n      ty=u.y+dy[i];\n      tx=u.x+dx[i];\n      if(ty>=0 && ty<h){\n\tif(tx>=0 && tx<w){\n\t  int tmp;\n\t  switch(i){\n\t  case 0:\n\t    tmp=(7-u.sai[1])*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=u.sai[1];\n\t      v.sai[1]=7-u.sai[0];\n\t      v.sai[2]=u.sai[2];\n\t      Q.push(v);\n\t    }\n\t    break;\n\t  case 1:\n\t    tmp=u.sai[2]*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=7-u.sai[2];\n\t      v.sai[1]=u.sai[1];\n\t      v.sai[2]=u.sai[0];\n\t      Q.push(v);\n\t    }\n\t    break;\n\t  case 2:\n\t    tmp=u.sai[1]*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=7-u.sai[1];\n\t      v.sai[1]=u.sai[0];\n\t      v.sai[2]=u.sai[2];\n\t      Q.push(v);\n\t    }\n\t    break;\n\t  case 3:\n\t    tmp=(7-u.sai[2])*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    if(v.pe<cost[ty][tx]){\n\t      cost[ty][tx]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      v.sai[0]=u.sai[2];\n\t      v.sai[1]=u.sai[1];\n\t      v.sai[2]=7-u.sai[0];\n\t      Q.push(v);\n\t    }\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\t  \n\t}\n      }\n    }\n  }\n  return cost[gy][gx];\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef struct duitype\n{\n\tlong x,y,z;\n}duitype;\nduitype dui[1000000];\nlong jl[7][7][7][7][7][7];\nbool bj[11][11][1000];\nlong temp[7];\nlong vv[7];\nlong v[46657][7];\nlong have[11][11][1000];\nlong aa,a1,b1,c1,d1,e1,f1,a2,b2,head,last,x,y,z,top,i,ans,k,j,place,zz,n,m;\nlong map[105][105];\nvoid cha(long a,long b,long c,long d)\n{\n\tlong t;\n\tt=temp[a];\n\ttemp[a]=temp[b];\n\ttemp[b]=temp[c];\n\ttemp[c]=temp[d];\n\ttemp[d]=t;\n}\nlong change(long z,char c)\n{\n\tlong i;\n\tfor (i=1;i<=6;i++)\n\t  temp[i]=v[z][i];\n\tswitch(c)\n\t{\n\t\tcase 'u':cha(6,3,4,5);break;\n\t\tcase 'd':cha(4,3,6,5);break;\n\t\tcase 'r':cha(1,5,2,3);break;\n\t\tcase 'l':cha(1,3,2,5);break;\n\t}\n\treturn jl[temp[1]][temp[2]][temp[3]][temp[4]][temp[5]][temp[6]];\n}\nvoid ind(long x,long y,long z,long all,char c)\n{\n\tlong ne;\n  if (x<=0 || x>n || y<=0 || y>m)\n    return;\n\tne=change(z,c);\n  if (have[x][y][ne]>all+vv[v[ne][5]]*map[x][y])\n\t{\n\t  have[x][y][ne]=all+vv[v[ne][5]]*map[x][y];\n\t\tif (!bj[x][y][ne]){\n\t\t\tbj[x][y][ne]=true;\n\t\t\tlast++;\n\t\t\tdui[last].x=x;\n\t\t\tdui[last].y=y;\n\t\t\tdui[last].z=ne;\n\t\t}\n\t} \n\tif (x==a2 && y==b2)\n\t  if (ans>have[x][y][ne])\n\t  {\n\t    ans=have[x][y][ne];\n\t  }\n}\nint main()\n{\n\ttop=0;\n\tfor (a1=1;a1<=6;a1++)\n\t  for (b1=1;b1<=6;b1++)\n  \t\tif (b1!=a1)\n\t    \tfor (c1=1;c1<=6;c1++)\n\t      \tif (c1!=a1 && c1!=b1)\n\t\t\t\t\t\tfor (d1=1;d1<=6;d1++)\n\t        \t\tif (d1!=a1 && d1!=b1 && d1!=c1)\n\t\t\t\t\t\t\t\tfor (e1=1;e1<=6;e1++)\n\t\t          \t\tif (e1!=a1 && e1!=b1 && e1!=c1 && e1!=d1)\n  \t  \t        \t\t{\n  \t  \t        \t\t\tf1=21-a1-b1-c1-d1-e1;\n    \t  \t      \t\t\ttop++;jl[a1][b1][c1][d1][e1][f1]=top;\n      \t  \t    \t\t\tv[top][1]=a1;v[top][2]=b1;v[top][3]=c1;v[top][4]=d1;v[top][5]=e1;v[top][6]=f1;\n        \t  \t  \t\t} \n  while (scanf(\"%d %d\",&n,&m)==2){\n  \tif (n==0)\n  \t  return 0;\n  \tfor (i=1;i<=n;i++)\n    \tfor (j=1;j<=m;j++)\n      \tfor (k=1;k<=top;k++){\n        \thave[i][j][k]=10000000;\n      \t  bj[i][j][k]=false;\n\t\t\t\t}\n\t  ans=10000000;\n  \tfor (i=1;i<=n;i++)\n    \tfor (j=1;j<=m;j++)\n      \tscanf(\"%d\",&map[i][j]);\n \t  scanf(\"%d%d%d%d\",&a1,&b1,&a2,&b2);\n  \ta1++;a2++;b1++;b2++;\n  \tvv[1]=4;vv[2]=3;vv[3]=1;vv[4]=2;vv[5]=6;vv[6]=5;\n\t\tz=zz=jl[1][2][3][4][5][6]; \n  \thead=0;last=1;dui[1].x=a1;dui[1].y=b1;dui[1].z=z;\n  \thave[a1][b1][z]=0;\n  \twhile (head<last)\n  \t{\n  \t\thead++;\n  \t\tx=dui[head].x;y=dui[head].y;z=dui[head].z;\n  \t  bj[x][y][z]=false;\n\t\t\tind(x+1,y,z,have[x][y][z],'d');\n    \tind(x-1,y,z,have[x][y][z],'u');\n  \t  ind(x,y+1,z,have[x][y][z],'r');\n    \tind(x,y-1,z,have[x][y][z],'l');\n\t\t}\n\t\tprintf(\"%ld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint board[10][10];\nint memo[7][7][7][10][10];\nint h,w;\n\nstruct State {\n    int x,y,top,south,east,cost;\n    State(int x,int y,int top,int south,int east,int cost) :\n        x(x), y(y), top(top), south(south), east(east), cost(cost) {;}\n};\n\nconst bool operator<(const State &s,const State &t) {\n    return s.cost > t.cost;\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nState roll(State s,int k) {\n    int nx = s.x + dx[k], ny = s.y + dy[k];\n    if(nx < 0 || nx > w-1 || ny < 0 || ny > h-1)\n        return State(-1,0,0,0,0,0);\n\n    int ntop,nsouth,neast;\n    if(k == 0) {\n        nsouth = s.south;\n        neast = s.top;\n        ntop = 7 - s.east;\n    }else if(k == 1) {\n        neast = s.east;\n        nsouth = s.top;\n        ntop = 7 - s.south;\n    }else if(k == 2) {\n        nsouth = s.south;\n        neast = 7 - s.top;\n        ntop = s.east;\n    }else if(k == 3) {\n        neast = s.east;\n        nsouth = 7 - s.top;\n        ntop = s.south;\n    }\n    return State(nx,ny,ntop,nsouth,neast,0);\n}\n\ninline int dist(State s) {\n    return memo[s.top][s.south][s.east][s.y][s.x];\n}\n\nint main() {\n    while(cin>>h>>w, h|w) {\n        for(int i=0; i<h; ++i)\n            for(int j=0; j<w; ++j) cin>>board[i][j];\n\n        int sx,sy,gx,gy;\n        cin>>sy>>sx>>gy>>gx;\n\n        priority_queue<State> q;\n        memset(memo, -1, sizeof(memo));\n        memo[1][2][3][sy][sx] = 0;\n        q.push(State(sx,sy,1,2,3,0));\n        while(!q.empty()) {\n            State s = q.top(); q.pop();\n            for(int k=0; k<4; ++k) {\n                State ns = roll(s,k);\n                if(ns.x == -1) continue;\n                int nc = dist(s) + (7-ns.top)*board[ns.y][ns.x];\n                if(dist(ns) != -1 && nc > dist(ns)) continue;\n                memo[ns.top][ns.south][ns.east][ns.y][ns.x] = nc;\n                ns.cost = nc;\n                //cout<<ns.x<<\" \"<<ns.y<<\" \"<<ns.top<<\" \"<<ns.south<<\" \"<<ns.east<<\" \"<<ns.cost<<endl;\n                q.push(ns);\n            }\n        }\n\n        int ans = 1<<29;\n        for(int i=1; i<=6; ++i)\n            for(int j=1; j<=6; ++j)\n                for(int k=1; k<=6; ++k) {\n                    if(memo[i][j][k][gy][gx] == -1) continue;\n                    ans = min(ans, memo[i][j][k][gy][gx]);\n                }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nenum FACE { TOP, BOTTOM, NORTH, SOUTH, WEST, EAST };\n\nclass dice {\nprivate:\n\tint num[6];\n\npublic:\n\tinline void roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[NORTH] = 5;\n\t\tnum[SOUTH] = 2;\n\t\tnum[EAST] = 3;\n\t\tnum[WEST] = 4;\n\t}\n\n\tdice(const dice& d) {\n\t\tnum[TOP] = d[TOP];\n\t\tnum[BOTTOM] = d[BOTTOM];\n\t\tnum[NORTH] = d[NORTH];\n\t\tnum[SOUTH] = d[SOUTH];\n\t\tnum[EAST] = d[EAST];\n\t\tnum[WEST] = d[WEST];\n\t}\n\n\tint encode() const {\n\t\treturn (num[TOP] - 1) * 6 * 6 + (num[NORTH] - 1) * 6 + (num[EAST] - 1);\n\t}\n\n\tconst int& operator[] (FACE f) const { return num[f]; }\n};\n\nvoid north(dice& d) { d.roll(TOP, SOUTH, BOTTOM, NORTH); }\nvoid east(dice& d) { d.roll(TOP, WEST, BOTTOM, EAST); }\nvoid west(dice& d) { d.roll(TOP, EAST, BOTTOM, WEST); }\nvoid south(dice& d) { d.roll(TOP, NORTH, BOTTOM, SOUTH); }\n\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nvoid (*func[4])(dice& d) = {east, south, west, north};\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int INF = 0xfffffff;\n\nint h, w;\nint gx, gy;\nint field[MAX_SIZE][MAX_SIZE];\n\ntypedef int weight;\nvector<weight> dist;\nstruct state {\n\tint x, y;\n\tdice d;\n\tweight dist;\n\tstate(int x, int y, const dice& d, weight dist):x(x), y(y), d(d), dist(dist){}\n\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\ninline bool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\nweight dijkstra(int sx, int sy, dice d) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<vector<weight>>> dist(h, vector<vector<weight>>(w, vector<weight>(6*6*6, INF)));\n\tdist[sy][sx][d.encode()] = 0;\n\tque.push(state(sx, sy, d, 0));\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.y][s.x][s.d.encode()] < s.dist)\n\t\t\tcontinue;\n\n\t\tif(s.x == gx && s.y == gy)\n\t\t\treturn s.dist;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tconst int nx = s.x + dx[i];\n\t\t\tconst int ny = s.y + dy[i];\n\t\t\tif(out(nx, ny)) continue;\n\t\t\tdice next_d(s.d);\n\t\t\tfunc[i](next_d);\n\n\t\t\tconst int next_dist = s.dist + next_d[BOTTOM] * field[ny][nx];\n\t\t\tconst int value = next_d.encode();\n\t\t\tif(dist[ny][nx][value] > next_dist) {\n\t\t\t\tdist[ny][nx][value] = next_dist;\n\t\t\t\tque.push(state(nx, ny, next_d, next_dist));\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\n\t\tcout << dijkstra(sx, sy, dice()) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nclass DICE{\npublic:\n\tvector<int> dice;\n\tDICE(){\n\t\tdice.resize(6);\n\t\trep(i,6)dice[i]=i+1;\n\t}\n\t// top/front/right/left/back/bottom  \n\tvoid back(){\n\t\tint to[] = {4,0,2,3,5,1};\n\t\tvector<int> tmp(6);\n\t\trep(i,6)tmp[to[i]] = dice[i];\n\t\tdice = tmp;\n\t}\n\tvoid left(){\n\t\tint to[] = {3,1,0,5,4,2};\n\t\tvector<int> tmp(6);\n\t\trep(i,6)tmp[to[i]] = dice[i];\n\t\tdice = tmp;\n\t}\n\tvoid rotate(){\n\t\tint to[] = {0,3,1,4,2,5};\n\t\tvector<int> tmp(6);\n\t\trep(i,6)tmp[to[i]] = dice[i];\n\t\tdice = tmp;\n\t}\n\tvoid select(int n){\n\t\tif(n==0)left();\n\t\telse if(n==1)left(),left(),left();\n\t\telse if(n==2)back();\n\t\telse if(n==3)back(),back(),back();\n\t}\n};\nstruct NODE{\n\tint cost,x,y;\n\tDICE dice;\n\tNODE(int a,int b,int c,DICE d){cost = a , x = b , y = c , dice = d;}\n};\nbool operator<(const NODE &a,const NODE &b){\n\tif(a.cost != b.cost)return a.cost > b.cost;\n\tif(a.x != b.x)return a.x < b.x;\n\tif(a.y != b.y)return a.y < b.y;\n\tif(a.dice.dice != b.dice.dice)return a.dice.dice < b.dice.dice;\n\treturn false;\n}\nint main(){\n\tint W,H;\n\tint data[10][10];\n\t\n\twhile(cin >> H >> W , H){\n\t\tmap<NODE,bool> done;\n\t\tpriority_queue<NODE> Q;\n\t\trep(i,H)rep(j,W)\n\t\t\tcin >> data[i][j];\n\t\tint sx,sy,gx,gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tQ.push(NODE(0,sx,sy,DICE()));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[q])continue;\n\t\t\telse done[q] = true;\n\t\t\tif(q.x == gx && q.y == gy){\n\t\t\t\tcout << q.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tNODE next = q;\n\t\t\t\tnext.x = dx[i] + q.x;\n\t\t\t\tnext.y = dy[i] + q.y;\n\t\t\t\tnext.dice.select(i);\n\t\t\t\tif(next.x < 0 || next.y < 0 || next.y >= H || next.x >= W) continue;\n\t\t\t\tnext.cost = q.cost + next.dice.dice[5] * data[next.y][next.x] ;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e9 + 10;\n\nint field[11][11];\n\nstruct Point {\npublic:\n  int y, x;\n  \n  Point(int y, int x):y(y), x(x) { }\n  Point() { };\n  \n  void operator=(Point p) {\n    this->y = p.y;\n    this->x = p.x;\n  }\n};\n\nenum { U, F, R, D, B, L };\n\nstruct Dice {\npublic:\n  int face[6];\n  \n  Dice() { face[F] = 2; face[R] = 3; face[U] = 1; face[B] = 5; face[L] = 4; face[D] = 6; }\n  \n  Dice(const Dice& d) {\n    for (int i = 0; i < 6; i++) {\n      face[i] = d.face[i];\n    }  \n  }\n  \n  Dice turn(int dir) {\n    switch (dir) {\n      case 0: rotate(U, R, D, L); break;\n      case 1: rotate(D, B, U, F); break;\n      case 2: rotate(U, L, D, R); break;\n      case 3: rotate(D, F, U, B); break;\n    } \n    return *this;\n  }\n  \n  int &operator[](int n) { \n    return face[n];\n  }\n  \n  void rotate(int a, int b, int c, int d) {\n    int t = face[d];\n    face[d] = face[c];\n    face[c] = face[b];\n    face[b] = face[a];\n    face[a] = t;\n  }\n  \n};\n\nPoint start, goal;\nint h, w;\n\nstruct State {\npublic:\n  Point p;\n  Dice d;\n  State(Point p): p(p) { }\n  State(Point p, Dice d):p(p), d(d) { }\n};\n\n\n\nsigned main() {\n  Dice tmp;\n  \n  int y, x;\n  while (true) {\n    cin >> h >> w;\n    if (h + w == 0) {\n      break;\n    }\n    memset(field, 0, sizeof(field));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        int f;\n        cin >> f;\n        field[i][j] = f;\n      }\n    }\n    cin >> y >> x;\n    start = Point(y, x);\n    cin >> y >> x;\n    goal = Point(y, x);\n    \n    queue<State> q;\n\n    int dist[11][11][7];    \n    for (int i = 0; i < 11; i++) {\n      for (int j = 0; j < 11; j++) {\n        for (int k = 0; k < 7; k++) {\n          dist[i][j][k] = INF;\n        }\n      }\n    }  \n    \n    dist[start.y][start.x][6] = 0;\n    \n    q.push(State(start));\n\n    bool checked[11][11][7] = { false };    \n    while (!q.empty()) {\n      State s = q.front(); q.pop();\n      \n      int dy[4] = { 0, 1, 0, -1 };\n      int dx[4] = { 1, 0, -1, 0 };\n      int sy = s.p.y;\n      int sx = s.p.x;\n      int sd = s.d.face[D];\n      Dice sdice = s.d;\n      Dice tmp = sdice;\n      if (checked[sy][sx][sdice.face[D]]) {\n        continue;\n      }\n      checked[sy][sx][sdice.face[D]] = true;\n      for (int i = 0; i < 4; i++) {\n        int ny = sy + dy[i];\n        int nx = sx + dx[i];\n        if (ny < 0 || ny >= h) {\n          continue;\n        }\n        if (nx < 0 || nx >= w) {\n          continue;\n        }\n        tmp = sdice;\n        Dice d = tmp.turn(i);\n        \n        if (checked[ny][nx][d.face[D]]) {\n          continue;\n        }\n        if (dist[sy][sx][sd] + field[ny][nx] * d.face[D] < dist[ny][nx][d.face[D]]) {\n          dist[ny][nx][d.face[D]] = dist[sy][sx][sd] + field[ny][nx] * d.face[D];\n          q.push(State(Point(ny, nx), d));\n        } \n      }\n    }\n    \n    int ans = INF;\n    for (int i = 1; i < 7; i++) {\n      ans = min(ans, dist[goal.y][goal.x][i]);\n    }  \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\n\nconst int TOP = 0;\nconst int BOTTOM = 1;\nconst int LEFT = 2;\nconst int BACK = 3;\nconst int RIGHT = 4;\nconst int FRONT = 5;\nclass Saikoro {\npublic:\n    int V[6]; \n    bool nullType;\n    Saikoro( int a, int b ) {\n        V[TOP] = a;\n        V[BOTTOM] = 7 - a;\n        V[FRONT] = b;\n        V[BACK] = 7 - b;\n        const int T[6][4] = {\n            { 2, 3, 5, 4 },\n            { 1, 4, 6, 3 },\n            { 6, 5, 1, 2 },\n            { 1, 5, 6, 2 },\n            { 3, 6, 4, 1 },\n            { 3, 2, 4, 5 }\n        };\n        for ( int i = 0; i < 4; ++ i ) {\n            if ( T[a-1][i] == b ) {\n                int left = i - 1;\n                if ( left < 0 ) left = 3;\n                V[LEFT] = T[a-1][left];\n                break;\n            }\n        }\n        V[RIGHT] = 7 - V[LEFT];\n        nullType = false;\n    }\n    int getV( int dir ) {\n        return V[2+dir];\n    }\n    int getTop() {\n        return V[TOP];\n    }\n    int getBottom() {\n        return V[BOTTOM];\n    }\n    void rollLeft() {\n        int NV[6];\n        NV[FRONT] = V[FRONT];\n        NV[BACK] = V[BACK];\n        NV[LEFT] = V[TOP];\n        NV[TOP] = V[RIGHT];\n        NV[RIGHT] = V[BOTTOM];\n        NV[BOTTOM] = V[LEFT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void rollRight() {\n        int NV[6];\n        NV[FRONT] = V[FRONT];\n        NV[BACK] = V[BACK];\n        NV[LEFT] = V[BOTTOM];\n        NV[BOTTOM] = V[RIGHT];\n        NV[RIGHT] = V[TOP];\n        NV[TOP] = V[LEFT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void rollFront() {\n        int NV[6];\n        NV[LEFT] = V[LEFT];\n        NV[RIGHT] = V[RIGHT];\n        NV[FRONT] = V[TOP];\n        NV[TOP] = V[BACK];\n        NV[BACK] = V[BOTTOM];\n        NV[BOTTOM] = V[FRONT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void rollBack() {\n        int NV[6];\n        NV[LEFT] = V[LEFT];\n        NV[RIGHT] = V[RIGHT];\n        NV[FRONT] = V[BOTTOM];\n        NV[BOTTOM] = V[BACK];\n        NV[BACK] = V[TOP];\n        NV[TOP] = V[FRONT];\n        for ( int i = 0; i < 6; ++ i ) V[i] = NV[i];\n    }\n    void roll( int dir ) {\n        if ( dir == 0 ) rollLeft();\n        if ( dir == 1 ) rollBack();\n        if ( dir == 2 ) rollRight();\n        if ( dir == 3 ) rollFront();\n    }\n    Saikoro() {\n        nullType = true;\n    }\n};\n\nbool operator < ( const Saikoro& a , const Saikoro& b ) {\n    VI ad = VI( a.V, a.V+6 ), bd = VI( b.V, b.V+6 );\n    return ad < bd;\n}\n \nostream& operator << ( ostream& os, Saikoro s ) {\n    const string T[6] = { \"TOP\", \"BOTTOM\", \"LEFT\", \"BACK\", \"RIGHT\", \"FRONT\" };\n    os << \"{\";\n    for ( int i = 0; i < 6; ++ i ) {\n        os << T[i] << \":\" << s.V[i];\n        if ( i + 1 < 6 ) os << \", \";\n    }\n    os << \"}\";\n    return os;\n}\n\nconst int SIZE = 11;\nint h, w;\nint M[SIZE][SIZE];\nint sr, sc, gr, gc;\n\nbool input() {\n    if ( ! ( cin >> h >> w && h ) ) return false;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cin >> M[i][j];\n        }\n    }\n    cin >> sr >> sc >> gr >> gc;\n    return true;\n}\n\ntypedef pair <II, Saikoro> STATE;\ntypedef pair <int, STATE> NODE;\ntypedef priority_queue <NODE, vector<NODE>, greater<NODE> > QUEUE;\nconst int dr[4] = { 0, -1, 0, 1 };\nconst int dc[4] = { -1, 0, 1, 0 };\ntypedef map <STATE, int> MIN_COST;\nMIN_COST MC;\nQUEUE Q;\n\nbool is_min( int next_steps, STATE s ) {\n    if ( MC.count(s) ) return next_steps < MC[s];\n    return true;\n}\n\nint solve() {\n    STATE start_state( II( sr, sc ), Saikoro( 1, 2 ) );\n    Q = QUEUE();\n    Q.push( NODE( 0, start_state ) );\n    MC.clear();\n\n    while ( ! Q.empty() ) {\n        NODE node = Q.top();\n        Q.pop();\n\n        int steps = node.first;\n        int r = node.second.first.first;\n        int c = node.second.first.second;\n        Saikoro s = node.second.second;\n\n        if ( r == gr && c == gc ) return steps;\n\n        for ( int i = 0; i < 4; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( nr < 0 || nr >= h || nc < 0 || nc >= w ) continue;\n            Saikoro ns = s;\n            ns.roll(i);\n            int nsteps = steps + M[nr][nc] * ns.getBottom();\n            STATE nstate( II( nr, nc ), ns );\n            if ( ! is_min( nsteps, nstate ) ) continue;\n            MC[nstate] = nsteps;\n            NODE next( nsteps, nstate );\n            Q.push( next );\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while ( input() ) {\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int a[][12],int b[][12],int d[],int p,int x,int y,int gx,int gy){\n  p+=a[x][y]*d[5];\n  if(0){\n  }else if(a[x][y]==-1){\n  }else if(x==gx&&y==gy){\n    if(b[x][y]==-1||b[x][y]>p)\n      b[x][y]=p;\n  }else if(b[x][y]==-1||b[x][y]>p){\n    b[x][y]=p;\n    swap(d[4],d[0]);\n    swap(d[0],d[2]);\n    swap(d[2],d[5]);\n    f(a,b,d,p,x-1,y,gx,gy);\n    swap(d[2],d[0]);\n    swap(d[0],d[4]);\n    swap(d[4],d[5]);\n\n    swap(d[3],d[0]);\n    swap(d[0],d[1]);\n    swap(d[1],d[5]);\n    f(a,b,d,p,x,y-1,gx,gy);\n    swap(d[1],d[0]);\n    swap(d[0],d[3]);\n    swap(d[3],d[5]);\n\n    swap(d[2],d[0]);\n    swap(d[0],d[4]);\n    swap(d[4],d[5]);\n    f(a,b,d,p,x+1,y,gx,gy);\n    swap(d[4],d[0]);\n    swap(d[0],d[2]);\n    swap(d[2],d[5]);\n\n    swap(d[1],d[0]);\n    swap(d[0],d[3]);\n    swap(d[3],d[5]);\n    f(a,b,d,p,x,y+1,gx,gy);\n    swap(d[3],d[0]);\n    swap(d[0],d[1]);\n    swap(d[1],d[5]);\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int a[12][12],b[12][12],d[6],w,h,sx,sy,gx,gy;\n  while(cin>>h>>w&&h+w){\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++)\n\tcin>>a[j][i];\n    cin>>sy>>sx>>gy>>gx;\n    sx++;\n    sy++;\n    gx++;\n    gy++;\n    d[0]=1;\n    d[1]=2;\n    d[2]=3;\n    d[3]=5;\n    d[4]=4;\n    d[5]=6;\n    memset(b,-1,sizeof(b));\n    b[sx][sy]=0;\n    swap(d[4],d[0]);\n    swap(d[0],d[2]);\n    swap(d[2],d[5]);\n    f(a,b,d,0,sx-1,sy,gx,gy);\n    swap(d[2],d[0]);\n    swap(d[0],d[4]);\n    swap(d[4],d[5]);\n\n    swap(d[3],d[0]);\n    swap(d[0],d[1]);\n    swap(d[1],d[5]);\n    f(a,b,d,0,sx,sy-1,gx,gy);\n    swap(d[1],d[0]);\n    swap(d[0],d[3]);\n    swap(d[3],d[5]);\n\n    swap(d[2],d[0]);\n    swap(d[0],d[4]);\n    swap(d[4],d[5]);\n    f(a,b,d,0,sx+1,sy,gx,gy);\n    swap(d[4],d[0]);\n    swap(d[0],d[2]);\n    swap(d[2],d[5]);\n\n    swap(d[1],d[0]);\n    swap(d[0],d[3]);\n    swap(d[3],d[5]);\n    f(a,b,d,0,sx,sy+1,gx,gy);\n    swap(d[3],d[0]);\n    swap(d[0],d[1]);\n    swap(d[1],d[5]);\n    cout<<b[gx][gy]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\n#include<queue>\nusing namespace std;\nint ijk[11][11][800];\nint v[11][11][800];\nint c[12][12];\nstruct wolf{\n\tint t[6];\n\twolf(){\n\t\tfor(int i=0;i<6;i++)t[i]=i;\n\t}\n};\ninline bool operator<(const wolf&a,const wolf&b){\n\tfor(int i=0;i<6;i++)if(a.t[i]!=b.t[i])return a.t[i]<b.t[i];\n\treturn false;\n}\nmap<wolf,int>m;\nvector<wolf>rev;\nvoid rN(wolf &a){int tmp=a.t[0];a.t[0]=a.t[1];a.t[1]=a.t[5];a.t[5]=a.t[4];a.t[4]=tmp;}\nvoid rS(wolf &a){int tmp=a.t[0];a.t[0]=a.t[4];a.t[4]=a.t[5];a.t[5]=a.t[1];a.t[1]=tmp;}\nvoid rE(wolf &a){int tmp=a.t[0];a.t[0]=a.t[3];a.t[3]=a.t[5];a.t[5]=a.t[2];a.t[2]=tmp;}\nvoid rW(wolf &a){int tmp=a.t[0];a.t[0]=a.t[2];a.t[2]=a.t[5];a.t[5]=a.t[3];a.t[3]=tmp;}\nint main(){\n\tint a,b;\n\twolf test;\n\tint sz=0;\n\tdo{\n\t\trev.push_back(test);\n\t\tm[test]=sz++;\n\t}while(next_permutation(test.t,test.t+6));\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&c[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<sz;k++){\n\t\t\tijk[i][j][k]=999999999;v[i][j][k]=0;\n\t\t}\n\t\tint sr,sc,gr,gc;scanf(\"%d%d%d%d\",&sr,&sc,&gr,&gc);\n\t\tijk[sr][sc][0]=0;\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >Q;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(sr,sc)));\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first.first;\n\t\t\tint st=Q.top().first.second;\n\t\t\twolf now=rev[st];\n\t\t\tint row=Q.top().second.first;\n\t\t\tint col=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[row][col][st])continue;\n\t\t\tv[row][col][st]=1;\n\t\t\tint to;\n\t\t\trN(now);to=m[now];\n\t\t\tif(row&&!v[row-1][col][to]&&ijk[row-1][col][to]>cost+(now.t[5]+1)*c[row-1][col]){\n\t\t\t\tijk[row-1][col][to]=cost+(now.t[5]+1)*c[row-1][col];\n\t\t\t\tQ.push(make_pair(make_pair(-ijk[row-1][col][to],to),make_pair(row-1,col)));\n\t\t\t}rS(now);\n\t\t\trS(now);to=m[now];\n\t\t\tif(row<a-1&&!v[row+1][col][to]&&ijk[row+1][col][to]>cost+(now.t[5]+1)*c[row+1][col]){\n\t\t\t\tijk[row+1][col][to]=cost+(now.t[5]+1)*c[row+1][col];\n\t\t\t\tQ.push(make_pair(make_pair(-ijk[row+1][col][to],to),make_pair(row+1,col)));\n\t\t\t}rN(now);\n\t\t\trW(now);to=m[now];\n\t\t\tif(col&&!v[row][col-1][to]&&ijk[row][col-1][to]>cost+(now.t[5]+1)*c[row][col-1]){\n\t\t\t\tijk[row][col-1][to]=cost+(now.t[5]+1)*c[row][col-1];\n\t\t\t\tQ.push(make_pair(make_pair(-ijk[row][col-1][to],to),make_pair(row,col-1)));\n\t\t\t}rE(now);\n\t\t\trE(now);to=m[now];\n\t\t\tif(col<b-1&&!v[row][col+1][to]&&ijk[row][col+1][to]>cost+(now.t[5]+1)*c[row][col+1]){\n\t\t\t\tijk[row][col+1][to]=cost+(now.t[5]+1)*c[row][col+1];\n\t\t\t\tQ.push(make_pair(make_pair(-ijk[row][col+1][to],to),make_pair(row,col+1)));\n\t\t\t}rW(now);\n\t\t}\n\t\tint ret=99999999;\n\t\tfor(int i=0;i<sz;i++)ret=min(ret,ijk[gr][gc][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<'L'<<__LINE__<<\": \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tos<<'(';\n\tprint_tuple<Args...>(os,t);\n\treturn os<<')';\n}\n\nstruct Die{\n\tarray<int,6> faces;\n\tDie(){\n\t\tfaces[0]=2; faces[1]=5;\n\t\tfaces[2]=3; faces[3]=4;\n\t\tfaces[4]=1; faces[5]=6;\n\t}\n\tvoid Rotate(int a,int b,int c,int d){\n\t\tswap(faces[a],faces[b]);\n\t\tswap(faces[b],faces[c]);\n\t\tswap(faces[c],faces[d]);\n\t}\n\tvoid TurnU(){Rotate(4,0,5,1);}\n\tvoid TurnD(){Rotate(4,1,5,0);}\n\tvoid TurnL(){Rotate(4,2,5,3);}\n\tvoid TurnR(){Rotate(4,3,5,2);}\n};\nbool operator<(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(a.faces),end(a.faces),begin(b.faces),end(b.faces));\n}\nbool operator>(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(b.faces),end(b.faces),begin(a.faces),end(a.faces));\n}\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvector<vector<int>> grid(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>grid[i][j];\n\t\tint si,sj,gi,gj; cin>>si>>sj>>gi>>gj;\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<Die,int,int,int> a,tuple<Die,int,int,int> b){\n\t\t\treturn get<3>(a)>get<3>(b);\n\t\t});\n\t\tpq.emplace(Die(),si,sj,0);\n\t\tset<tuple<Die,int,int>> vis;\n\t\twhile(pq.size()){\n\t\t\tDie d; int i,j,c; tie(d,i,j,c)=pq.top(); pq.pop();\n\t\t\tif(vis.count(make_tuple(d,i,j))) continue;\n\t\t\tif(i==gi && j==gj){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfunction<void(Die&)> turns[]={&Die::TurnU,&Die::TurnD,&Die::TurnL,&Die::TurnR};\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w){\n\t\t\t\t\tDie t=d;\n\t\t\t\t\tturns[k](t);\n\t\t\t\t\tpq.emplace(t,ni,nj,c+t.faces[5]*grid[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <string>\n#include <map>\n#include <set>\n#include <math.h>\n#define M 15\nusing namespace std;\n\nstruct node {\n    int x, y, bottom, east;\n    __int64 value;\n} Q[M*M*M*M*M*M], s, p;\nint mark[M][M][M][M];\n__int64 dis[M][M][M][M];\nint value[M][M];\nint n, m;\nint sx, sy, ex, ey;\n__int64 oo = 100000000000000LL;\nint add[7][7] = {\n    {0},\n    {5, 4, 2, 3},\n    {3, 1, 4, 6},\n    {2, 6, 5, 1},\n    {5, 6, 2, 1},\n    {6, 4, 1, 3},\n    {3, 2, 4, 5}\n};\n\nvoid checkIn(int &H) {\n    if (dis[s.x][s.y][s.bottom][s.east] > s.value) {\n        dis[s.x][s.y][s.bottom][s.east] = s.value;\n        if (!mark[s.x][s.y][s.bottom][s.east]) {\n            mark[s.x][s.y][s.bottom][s.east] = 1;\n            Q[H++] = s;\n        }\n        //printf(\"s %d %d %d %d\\n\", s.x, s.y, s.bottom, s.east);\n    }\n}\n\nint find(int e, int b, int k) {\n    int i;\n    for (i = 0; i < 4; i++)\n        if (add[e][i] == b) {\n            return add[e][(i + k + 4) % 4];\n        }\n}\n\nvoid SPFA() {\n    int i, j, k, x, y, bottom, east;\n    int L, H;\n    for (x = 0; x < n; x++)\n        for (y = 0; y < m; y++)\n            for (i = 1; i <= 6; i++)\n                for (j = 1; j <= 6; j++) {\n                    dis[x][y][i][j] = oo;\n                    mark[x][y][i][j] = 0;\n                }\n    dis[sx][sy][6][3] = 0;\n    s.x = sx, s.y = sy, s.bottom = 6, s.east = 3, s.value = 0;\n    mark[s.x][s.y][s.bottom][s.east] = 1;\n    L = H = 0;\n    Q[H++] = s;\n    while (L < H) {\n        p = Q[L++];\n        mark[p.x][p.y][p.bottom][p.east] = 0;\n        x = p.x, y = p.y;\n        if (x > 0) {//up\n            s.x = p.x - 1;\n            s.y = p.y;\n            s.bottom = find(p.east, p.bottom, 1);\n            s.east = p.east;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n        if (x < n - 1) {//down\n            s.x = p.x + 1;\n            s.y = p.y;\n            s.bottom = find(p.east, p.bottom, -1);\n            s.east = p.east;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n        if (y > 0) {//left\n            s.x = p.x;\n            s.y = p.y - 1;\n            s.bottom = 7 - p.east;\n            s.east = p.bottom;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n        if (y < m - 1) {//right\n            //puts(\"yes\");\n            s.x = p.x;\n            s.y = p.y + 1;\n            s.bottom = p.east;\n            s.east = 7 - p.bottom;\n            s.value = p.value + value[s.x][s.y] * s.bottom;\n            checkIn(H);\n        }\n    }\n}\n\nint main(int argc, char** argv) {\n    int i, j, k;\n    while (scanf(\"%d %d\", &n, &m), n | m) {\n        for (i = 0; i < n; i++)\n            for (j = 0; j < m; j++)\n                scanf(\"%d\", &value[i][j]);\n        scanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n        SPFA();\n        __int64 ans = oo;\n        for (i = 1; i <= 6; i++)\n            for (j = 1; j <= 6; j++)\n                if (dis[ex][ey][i][j] < ans)\n                    ans = dis[ex][ey][i][j];\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\n#include<functional>\n#include<queue>\nusing namespace std;\npriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>>>Q;\nint dice[6][6][6][6][6][6];\nvector<int>dice2[720];\nint c[720][4], H, W;\nint dp[12][12][720], z[12][12];\nint main() {\n\tvector<int>a;\n\tfor (int i = 0; i < 6; i++)a.push_back(i);\n\tint cnt = 0;\n\tdo {\n\t\tdice2[cnt] = a;\n\t\tdice[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]] = cnt;\n\t\tcnt++;\n\t} while (next_permutation(a.begin(), a.end()));\n\tfor (int i = 0; i < 720; i++) {\n\t\tvector<int>d = dice2[i], e = d;\n\t\te[0] = d[2]; e[1] = d[1]; e[2] = d[5]; e[3] = d[0]; e[4] = d[4]; e[5] = d[3];\n\t\tc[i][0] = dice[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]];\n\t\te[0] = d[3]; e[1] = d[1]; e[2] = d[0]; e[3] = d[5]; e[4] = d[4]; e[5] = d[2];\n\t\tc[i][1] = dice[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]];\n\t\te[0] = d[1]; e[1] = d[5]; e[2] = d[2]; e[3] = d[3]; e[4] = d[0]; e[5] = d[4];\n\t\tc[i][2] = dice[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]];\n\t\te[0] = d[4]; e[1] = d[0]; e[2] = d[3]; e[3] = d[2]; e[4] = d[5]; e[5] = d[1];\n\t\tc[i][3] = dice[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]];\n\t}\n\twhile (true) {\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++)cin >> z[i][j];\n\t\t}\n\t\tfor (int i = 0; i < 12; i++) {\n\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\tfor (int k = 0; k < 720; k++)dp[i][j][k] = 1 << 30;\n\t\t\t}\n\t\t}\n\t\tint SX, SY, TX, TY;\n\t\tcin >> SX >> SY >> TX >> TY;\n\t\tSX++; SY++; TX++; TY++;\n\t\tQ.push(make_tuple(0, SX, SY, 0)); dp[SX][SY][0] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.top(); Q.pop();\n\t\t\tint a1 = get<0>(tup), a2 = get<1>(tup);\n\t\t\tint a3 = get<2>(tup), a4 = get<3>(tup);\n\t\t\tint dy[4] = { -1,1,0,0 };\n\t\t\tint dx[4] = { 0,0,-1,1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint e = c[a4][i]; vector<int>f = dice2[e];\n\t\t\t\tint px = a2 + dx[i], py = a3 + dy[i];\n\t\t\t\tif (px <= 0 || px > H)continue;\n\t\t\t\tif (py <= 0 || py > W)continue;\n\t\t\t\tint pen = (f[5] + 1) * z[px][py];\n\t\t\t\tif (a1 + pen < dp[px][py][e]) {\n\t\t\t\t\tdp[px][py][e] = a1 + pen;\n\t\t\t\t\tQ.push(make_tuple(dp[px][py][e], px, py, e));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minx = 1 << 30;\n\t\tfor (int i = 0; i < 720; i++) {\n\t\t\tminx = min(minx, dp[TX][TY][i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<'L'<<__LINE__<<\": \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tos<<'(';\n\tprint_tuple<Args...>(os,t);\n\treturn os<<')';\n}\n\nstruct Die{\n\tarray<int,6> faces;\n\tDie(){\n\t\tfaces[0]=2; faces[1]=5;\n\t\tfaces[2]=3; faces[3]=4;\n\t\tfaces[4]=1; faces[5]=6;\n\t}\n\tvoid Rotate(int a,int b,int c,int d){\n\t\tswap(faces[a],faces[b]);\n\t\tswap(faces[b],faces[c]);\n\t\tswap(faces[c],faces[d]);\n\t}\n\tvoid TurnU(){Rotate(4,0,5,1);}\n\tvoid TurnD(){Rotate(4,1,5,0);}\n\tvoid TurnL(){Rotate(4,2,5,3);}\n\tvoid TurnR(){Rotate(4,3,5,2);}\n};\nbool operator<(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(a.faces),end(a.faces),begin(b.faces),end(b.faces));\n}\nbool operator>(const Die& a,const Die& b){\n\treturn lexicographical_compare(begin(b.faces),end(b.faces),begin(a.faces),end(a.faces));\n}\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvector<vector<int>> grid(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>grid[i][j];\n\t\tint si,sj,gi,gj; cin>>si>>sj>>gi>>gj;\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<Die,int,int,int> a,tuple<Die,int,int,int> b){\n\t\t\treturn get<3>(a)>get<3>(b);\n\t\t});\n\t\tpq.emplace(Die(),si,sj,0);\n\t\tset<tuple<Die,int,int>> vis;\n\t\twhile(pq.size()){\n\t\t\tDie d; int i,j,c; tie(d,i,j,c)=pq.top(); pq.pop();\n\t\t\tif(vis.count(make_tuple(d,i,j))) continue;\n\t\t\tvis.emplace(d,i,j);\n\t\t\tif(i==gi && j==gj){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfunction<void(Die&)> turns[]={&Die::TurnU,&Die::TurnD,&Die::TurnL,&Die::TurnR};\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w){\n\t\t\t\t\tDie t=d;\n\t\t\t\t\tturns[k](t);\n\t\t\t\t\tpq.emplace(t,ni,nj,c+t.faces[5]*grid[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstd::istream &operator>>(std::istream &is, P &p){\n\treturn is >> p.first >> p.second;\n}\n\nstruct Dice{\nprivate:\n\tstatic const int _roll[4][6], _turn[2][6];\npublic:\n\tvector<int> value;\n\t// 1-6 : top, near, right, left, far, bottom \n\n\tDice(){\n\t\tvalue.resize(6);\n\t\tfor (int i = 0; i < 6; ++i) value[i] = i+1;\n\t}\n\tDice(initializer_list<int> il){\n\t\tvalue.resize(6, -1);\n\t\tint cnt = 0;\n\t\tfor (auto &e : il){\n\t\t\tvalue[cnt++] = e;\n\t\t\tif (cnt >= 6) break;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) if (value[i] < 0) value[i] = 5 - value[5 - i];\n\t}\n\n\tvoid roll(int dir){ // N, E, W, S\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_roll[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tvoid turn(int dir){ // L, R\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_turn[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tint &operator[](int i){\n\t\treturn value[i];\n\t}\n};\n\nconst int Dice::_roll[4][6] = {\n\t{ 1, 5, 2, 3, 0, 4 }, // North\n\t{ 3, 1, 0, 5, 4, 2 }, // East\n\t{ 2, 1, 5, 0, 4, 3 }, // West\n\t{ 4, 0, 2, 3, 5, 1 }, // South\n};\n\nconst int Dice::_turn[2][6] = {\n\t{ 0, 3, 1, 4, 2, 5 }, // Left\n\t{ 0, 2, 4, 1, 3, 5 }, // Right\n};\n\nint board[10][10];\n\nstruct state{\n\tP first;\n\tDice second;\n\tbool operator<(const state &r)const{\n\t\treturn first < r.first;\n\t}\n};\n\nint dx[] = {0, 1, -1, 0};\nint dy[] = {-1, 0, 0, 1};\n\nint main(){\n\tint h, w;\n\twhile (cin >> h >> w, h | w){\n\t\trep(i, h) rep(j, w) cin >> board[i][j];\n\t\tP s, g;\n\t\tcin >> s >> g;\n\n\t\tmap<state, int> m;\n\n\t\tpriority_queue<pair<int, state>, vector<pair<int, state>>, greater<pair<int, state>>> q;\n\t\tq.push(make_pair(0, state{ s, Dice() }));\n\t\tint ans = -1;\n\t\twhile (!q.empty()){\n\t\t\tint dist = q.top().first;\n\t\t\tstate s = q.top().second;\n\t\t\tP &pos = s.first;\n\t\t\tDice &d = s.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif (m[s] < dist) continue;\n\t\t\tif (s.first == g){\n\t\t\t\tans = dist;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint nx = pos.second + dx[i], ny = pos.first + dy[i];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\tstate nxt = s;\n\t\t\t\tnxt.second.roll(i);\n\t\t\t\tnxt.first = make_pair(ny, nx);\n\t\t\t\tif (m.count(nxt) && m[nxt] <= dist + nxt.second[5] * board[ny][nx]) continue;\n\t\t\t\tm[nxt] = dist + nxt.second[5] * board[ny][nx];\n\t\t\t\tq.push(make_pair(dist + nxt.second[5] * board[ny][nx], nxt));\n\t\t\t}\n\t\t}\n\t\t//cout << \"+++\";\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tDice(int top,int bottom,int north,int south,int east,int west,int sx,int sy,int cost){\n\t\tt=top,b=bottom,n=north,s=south,e=east,w=west;\n\t\tx=sx,y=sy,c=cost;\n\t}\n\tbool operator<(const Dice &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint w,h;\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nint main(){\n\tint p[10][10];\n\twhile(cin>>h>>w && h!=0){\n\t\tpriority_queue<Dice> que;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t\tcin>>p[y][x];\n\n\t\tint gx,gy,sx,sy;\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\tque.push(Dice(1,6,5,2,3,4,sx,sy,0));\n\t\twhile(!que.empty()){\n\t\t\tDice now=que.top();\n\t\t\tque.pop();\n//\t\t\tcout<<now.x<<\" \"<<now.y<<\" \"<<now.b<<\" \"<<now.c<<endl;\n\t\t\tif(now.x==gx && now.y==gy) {cout<<now.c<<endl; break;}\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tDice copy=now;\n\t\t\t\tcopy.roll(r);\n\t\t\t\tif(in(copy.x,copy.y)){\n\t\t\t\t\tcopy.c+=copy.b*p[copy.y][copy.x];\n\t\t\t\t\tque.push(copy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint x;\n\tint y;\n\tint under;\n\tint over;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\n// y,x,ºÌÚ,ãÌÚ\nvector<edge> G[10][10][7][7];\nint d[10][10][7][7];\nconst int INF = 100000000;\n\nint h,w;\n\nint field[10][10];\n\nclass Situation{\npublic:\n\tint x,y,under,over;\n\tint cost;\n\tSituation(int x_,int y_,int under_,int over_,int cost_){\n\t\tx = x_;\n\t\ty = y_;\n\t\tunder = under_;\n\t\tover = over_;\n\t\tcost = cost_;\n\t}\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\n\nvoid dijkstra(int x,int y,int under,int over){\n\tpriority_queue<Situation> que;\n\tfor(int i = 0; i < 10; i++)\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tfor(int k = 0; k < 7; k++)\n\t\t\t\tfill(d[i][j][k],d[i][j][k]+7,INF);\n\n\td[y][x][under][over] = 0;\n\tque.push(Situation(x,y,under,over,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint cx = p.x;\n\t\tint cy = p.y;\n\t\tint cu = p.under;\n\t\tint co = p.over;\n\n\t\tif(d[cy][cx][cu][co] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[cy][cx][cu][co].size(); i++){\n\t\t\tedge e = G[cy][cx][cu][co][i];\n\t\t\tint cost = field[e.y][e.x]*e.under;\n\t\t\tif(d[e.y][e.x][e.under][e.over] > d[cy][cx][cu][co] + cost){\n\t\t\t\td[e.y][e.x][e.under][e.over] = d[cy][cx][cu][co] + cost;\n\t\t\t\tque.push(Situation(e.x,e.y,e.under,e.over,d[e.y][e.x][e.under][e.over]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin >> h >> w && !(h==0&&w==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> start,goal;\n\t\tcin >> start.first >> start.second;\n\t\tcin >> goal.first >> goal.second;\n\n\t\t// edgeðÔ\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\t\tfor(int l = 0; l < 7; l++)\n\t\t\t\t\t\tG[i][j][k][l].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dy[]={-1,0,0,1};\n\t\tint dx[]={0,-1,1,0};\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t// êÊÌÚ\n\t\t\t\tfor(int k = 1; k < 7; k++){\n\t\t\t\t\t// ã¤ÊÌÚ\n\t\t\t\t\tfor(int l = 1; l < 7; l++){\n\t\t\t\t\t\tif(k == l || k + l == 7)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\t\tpair<int,int> np;\n\t\t\t\t\t\t\tnp.first = i + dy[m];\n\t\t\t\t\t\t\tnp.second = j + dx[m];\n\t\t\t\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\t\t\t\t// »ÝÌ}XÌóµÉ¶Äedgeðãü\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.x = np.second;\n\t\t\t\t\t\t\t\te.y = np.first;\n\t\t\t\t\t\t\t\t// ãÉiÞê\n\t\t\t\t\t\t\t\tif(dy[m] == -1){\n\t\t\t\t\t\t\t\t\te.under = l;\n\t\t\t\t\t\t\t\t\te.over = 7-k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// ºÉiÞê\n\t\t\t\t\t\t\t\telse if(dy[m] == 1){\n\t\t\t\t\t\t\t\t\te.under = 7-l;\n\t\t\t\t\t\t\t\t\te.over = k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// ¶EÉiÞê\n\t\t\t\t\t\t\t\telse if(dx[m] == 1 || dx[m]==-1){\n\t\t\t\t\t\t\t\t\te.over = l;\n\t\t\t\t\t\t\t\t\tif(k == 1 || k == 6){\n\t\t\t\t\t\t\t\t\t\tif(l == 2){\n\t\t\t\t\t\t\t\t\t\t\te.under = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 3){\n\t\t\t\t\t\t\t\t\t\t\te.under = 2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 5){\n\t\t\t\t\t\t\t\t\t\t\te.under = 3;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 4){\n\t\t\t\t\t\t\t\t\t\t\te.under = 5;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(k == 1){\n\t\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if(k == 2 || k == 5){\n\t\t\t\t\t\t\t\t\t\tif(l == 3){\n\t\t\t\t\t\t\t\t\t\t\te.under = 6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 4){\n\t\t\t\t\t\t\t\t\t\t\te.under = 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 1){\n\t\t\t\t\t\t\t\t\t\t\te.under = 3;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 6){\n\t\t\t\t\t\t\t\t\t\t\te.under = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(k==2){\n\t\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if(k == 3 || k == 4){\n\t\t\t\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\t\t\t\te.under =5;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 2){\n\t\t\t\t\t\t\t\t\t\t\te.under = 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 5){\n\t\t\t\t\t\t\t\t\t\t\te.under = 6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l==6){\n\t\t\t\t\t\t\t\t\t\t\te.under = 2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(k==3){\n\t\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(dx[m]==-1){\n\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tG[i][j][k][l].push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(start.second,start.first,6,5);\n\t\tint minCost = 1000000000;\n\t\tfor(int i = 1; i < 7; i++){\n\t\t\tfor(int j = 1; j < 7; j++){\n\t\t\t\tminCost = min(minCost,d[goal.first][goal.second][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minCost<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n\n#define N 16\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define DIRMAX 4\n\nusing namespace std;\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst int infty = (1LL<<31)-1;\nconst int dc[] = {120,24,6,2,1};\n\nstruct Dice{\n  int D[6];\n  Dice(){D[5]=1;D[1]=2;D[2]=3;decide();}\n  void decide(){D[0]=7-D[5];D[3]=7-D[1];D[4]=7-D[2];}\n  void roll(int dir){\n    switch(dir){\n    case NORTH:D[5]=D[1];D[1]=D[0];break;\n    case EAST: D[2]=D[5];D[5]=D[4];break;\n    case SOUTH:D[1]=D[5];D[5]=D[3];break;\n    case WEST: D[5]=D[2];D[2]=D[0];break;\n    }\n    decide();\n  }\n  int index()const{\n    int ret = 0;\n    for(int i = 0; i < 5; ++i){\n      if(D[i]>D[i+1])ret+=dc[i]*(D[i]-D[i+1]);\n    }\n    return ret;\n  }\n};\n\nstruct State{\n  Dice c;\n  int i,j;\n  int cost;\n  bool operator>(const State &t)const{\n    return cost > t.cost; \n  }\n};\n\ninline bool isinside(int i, int j, int h, int w){\n  return 0<=i&&i<h&&0<=j&&j<w;\n}\n\nint dijkstra(int h, int w, int M[][N],\n\t     int si, int sj, int gi, int gj){\n  int ret = infty;\n  State init;\n  int A[720][N][N];\n  bool vis[720][N][N];\n  priority_queue<State,vector<State>,greater<State> > qs;\n  \n  init.cost=0;\n  init.i=si;\n  init.j=sj;\n  for(int i = 0; i < 720; ++i){\n    for(int j = 0; j < N; ++j){\n      for(int k = 0; k < N; ++k){\n\tvis[i][j][k] = false;\n\tA[i][j][k] = infty;\n      }\n    }\n  }\n  \n  qs.push( init );\n  while(!qs.empty()){\n    int cstate;\n    State now = qs.top();\n    qs.pop();\n\n    cstate = now.c.index();\n    if( vis[cstate][now.i][now.j] ) continue;\n    vis[cstate][now.i][now.j] = true;\n\n    for(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n      int ncstate;\n      State next = now;\n      next.i = now.i + di[k];\n      next.j = now.j + dj[k];\n      next.c.roll( k );\n      if( !isinside(next.i, next.j, h, w ) ) continue;\n      next.cost += next.c.D[0] * M[next.i][next.j];\n      ncstate = next.c.index();\n      if( next.cost < A[ncstate][next.i][next.j] ){\n\tA[ncstate][next.i][next.j] = next.cost;\n\tif( !vis[ncstate][next.i][next.j] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < 720; ++i){\n    ret = min( ret, A[i][gi][gj] );\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int h,w;\n    int M[N][N];\n    cin >> h >> w;\n    if( h == 0 && w == 0 ) break;\n    \n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    int si,sj,gi,gj;cin >> si >> sj >> gi >> gj;\n    cout << dijkstra(h,w,M,si,sj,gi,gj) << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef pair<int , int> P;\ntypedef pair<P,P> P2;\n\nint h,w;\nint g[30][30];\nint d[30][30][25];\n\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r[4][6] = { {1,5,2,3,0,4},\n\t\t{3,1,0,5,4,2},\n\t\t{4,0,2,3,5,1},\n\t\t{2,1,5,0,4,3} };\n\nvector<int> trans(int n){\n  vector<int> res;\n  while(n>0){\n    res.push_back(n%6);\n    n/=6;\n  }\n  while(res.size()<6)res.push_back(0);\n  return res;\n}\n\nint rot(int n,int dir){\n  int tmp[6];\n  vector<int> die = trans(n);\n  for(int i=0;i<6;i++)tmp[i] = die[r[dir][i]];\n\n  int res = 0, k = 1;\n  for(int i=0;i<6;i++){\n    res += tmp[i] * k;\n    k *= 6;\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<25;k++)d[i][j][k] = 10000000;\n      }\n    }\n\n    int sy,sx,gy,gx;\n    cin >> sy >> sx >> gy >> gx;\n    \n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    map<int,int> m1,m2;\n    m1[44790] = 1;\n    m2[1] = 44790;\n    q.push(P2(P(0,1),P(sy,sx)));\n    d[sy][sx][1] = 0;\n    int cnt = 2;\n\n    int hoge = 0;\n    while(!q.empty()){\n      P2 p = q.top();q.pop();\n      int s = p.first.first , num = p.first.second;\n      int y = p.second.first , x = p.second.second;\n\n      //cout << num << endl;\n\n      for(int i=0;i<4;i++){\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(ny<0 || nx<0 || h<=ny || w<=nx)continue;\n\tint nnum = rot(m2[num],i);\n\n\tvector<int> die = trans(nnum);\n\tif(!m1[nnum]){\n\t  m1[nnum] = cnt;\n\t  m2[cnt] = nnum;\n\t  cnt++;\n\t}\n\tnnum = m1[nnum];\n\n\tif(d[ny][nx][nnum] > d[y][x][num] + g[ny][nx]*(die[5]+1)){\n\t  d[ny][nx][nnum] = d[y][x][num] + g[ny][nx]*(die[5]+1);\n\t  q.push(P2(P(d[ny][nx][nnum],nnum),P(ny,nx)));\n\t}\n      }\n    }\n\n    int m = 10000000;\n    for(int i=0;i<25;i++)m = min(m,d[gy][gx][i]);\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\n\nclass Dice {\npublic:\n  int f[6];\n  int x, y, cost;\n  Dice() {\n    f[0] = 1;\n    f[1] = 2;\n    f[2] = 3;\n    f[3] = 6;\n    f[4] = 5;\n    f[5] = 4;\n  }\n  bool operator <(const Dice &d) const {\n    if(x != d.x) return x < d.x;\n    if(y != d.y) return y < d.y;\n    for(int i = 0; i < 3; ++i) {\n      if(f[i] != d.f[i]) return f[i] < d.f[i];\n    }\n    return false;\n  }\n\n  void rotate(int dx, int dy) {\n    int tmp;\n    tmp = f[0];\n    if(dx == -1) {\n      f[0] = f[2];\n      f[2] = f[3];\n      f[3] = f[5];\n      f[5] = tmp;\n    } else if(dx == 1) {\n      f[0] = f[5];\n      f[5] = f[3];\n      f[3] = f[2];\n      f[2] = tmp;\n    }\n    x += dx;\n\n    tmp = f[0];\n    if(dy == -1) {\n      f[0] = f[1];\n      f[1] = f[3];\n      f[3] = f[4];\n      f[4] = tmp;\n    } else if(dy == 1) {\n      f[0] = f[4];\n      f[4] = f[3];\n      f[3] = f[1];\n      f[1] = tmp;\n    }\n    y += dy;\n  }\n};\n\nclass Dice2 {\npublic:\n  Dice d;\n  int cost;\n  Dice2(Dice d, int cost) : d(d), cost(cost) {}\n  bool operator <(const Dice2 &d2) const {\n    return cost > d2.cost;\n  }\n};\n\nint h, w;\nint M[10][10];\nint sx, sy;\nint gx, gy;\n\nvoid solve() {\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n  Dice d;\n  d.x = sx;\n  d.y = sy;\n  d.cost = 0;\n  priority_queue<Dice2> que;\n  que.push(Dice2(d,0));\n  set<Dice> vis;\n  vis.insert(d);\n  while(!que.empty()) {\n    const Dice2 d2 = que.top(); que.pop();\n    if(d2.d.x == gx && d2.d.y == gy) {\n      cout << d2.cost << endl;\n      return;\n    }\n\n    for(int i = 0; i < 4; ++i) {\n      d = d2.d;\n      int nx = d.x + dx[i];\n      int ny = d.y + dy[i];\n      if(nx < 0 || nx >= w) continue;\n      if(ny < 0 || ny >= h) continue;\n      d.rotate(dx[i], dy[i]);\n      if(vis.find(d) != vis.end()) continue;\n      vis.insert(d);\n      que.push(Dice2(d, d2.cost + d.f[3]*M[ny][nx]));\n    }\n  }\n}\n\nmain() {\n  while((cin >> h >> w) && (h || w)) {\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n\tcin >> M[i][j];\n      }\n    }\n    cin >> sy >> sx;\n    cin >> gy >> gx;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#define INF 10000000\n// max=6*9 * 10*10\nusing namespace std;\n\ntypedef struct {\n  int x,y,p,m ; // ÂÃÂÂ®ÂÃ£ÂÃÂ}ÂXÂAÂyÂiÂÂÂeÂB, ÂÃ\n} State;\n\nint main(){\n  int h,w,x,y;\n  int g[10][10];\n  int sx,sy, gx,gy;\n  int dx[4] = { 0,1,0,-1 };  // ÂÃ£ÂAÂEÂAÂÂºÂAÂÂ¶\n  int dy[4] = { -1,0,1,0 };\n  int dice[7][4] = // 1,2,... ÂÂªÂÃ£ÂÃÂÂ ÂÃ©ÂÂÂÃÂÂ¡ÂÃÂÂÂÂ\n    {\n      { 0,0,0,0 },\n      { 2,4,5,3 }, { 6,4,1,3 },\n      { 2,1,5,6 }, { 2,6,5,1 },\n      { 1,4,6,3 }, { 2,3,5,4 }\n    };\n  queue<State> q;\n  State st, st2;\n\n  while( cin>>h>>w && ( h||w ) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++)\n\tcin >> g[i][j];\n    cin >> sy>>sx>> gy>>gx;\n\n    /*\n    cout << \"h=\"<<h<<\" w=\"<<w<<endl;\n    cout << \"start=(\"<<sx<<\",\"<<sy<<\") goal=(\"<<gx<<\",\"<<gy<<\")\"<<endl;\n    */\n    st.x=sx; st.y=sy; st.p=0; st.m=1;\n    q.push( st );\n\n    int min = INF;\n\n    //    int loop=0;\n\n    while( q.size()>0 ){\n      st = q.front(); q.pop();\n\n      /******\n      cout << \"size=\"<<q.size()<<\" min=\"<<min\n\t   <<\" x=\"<<st.x<<\" y=\"<<st.y\n\t   <<\" p=\"<<st.p<<\" m=\"<<st.m   <<endl;\n      if( loop++>10 )\n\tbreak;\n      /*******/\n\n      if( st.p>min )\n\tcontinue;\n\n      if( (st.x==gx) && (st.y==gy) ){ // goal\n\t//\tcout << \"goal\" << endl;\n\tif( min>st.p )\n\t  min=st.p;\n\tcontinue;\n      }\n\n      for( int i=0;i<4;i++ ){\n\n\tx=st.x+dx[i]; y=st.y+dy[i];\n\t// gx,gy ÂÃ»ÂÃ¼ÂÃÂtÂÃ»ÂÃ¼ÂÃÂiÂÃ±ÂÃÂÃÂÂ¢ÂÂ©ÂmÂF\n\tif( abs(st.x-gx) < abs( x-gx ) ||\n\t    abs(st.y-gy) < abs( y-gy ) ){\n\t  //\t  cout << \" %%\"<<endl;\n\t  continue;\n\t}\n\n\tif( 0<=x && x<w && 0<=y && y<h ){\n\t  st2.x=x; st2.y=y;\n\t  st2.p= st.p + g[y][x] * (7-dice[st.m][i]);\n\t  st2.m = dice[st.m][i];\n\t  q.push( st2 );\n\t}\n      }\n    }\n    cout << min << endl;\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Dice {\n  int top;\n  int front;\n  int right;\n  Dice() {;}\n  Dice(int t, int f, int r) : top(t), front(f), right(r) {;}\n};\n\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\nDice rotate(Dice dice, int i) {\n  int top = dice.top;\n  int front = dice.front;\n  int right = dice.right;\n  Dice d;\n  int rtop = 7 - top;\n  int rfront = 7 - front;\n  int rright = 7 - right;\n  if (i == 0) {\n    d.top = rright;\n    d.front = front;\n    d.right = top;\n  } else if (i == 1) {\n    d.top = right;\n    d.front = front;\n    d.right = rtop;\n  } else if (i == 2) {\n    d.top = rfront;\n    d.front = top;\n    d.right = right;\n  } else if (i == 3) {\n    d.top = front;\n    d.front = rtop;\n    d.right = right; \n  }\n  return d;\n}\n\nint encode(Dice d) {\n  return d.top + d.front * 6 + d.right * 36;\n}\n\nstruct State {\n  int cost;\n  int x;\n  int y;\n  Dice dice;\n  State() {;}\n  State(int c, int x, int y, Dice d) : cost(c), x(x), y(y), dice(d) {;}\n  bool operator<(const State &rhs) const { return cost > rhs.cost; }\n};\n\nint field[20][20];\nint dist[400][10][10];\nbool visit[400][10][10];\n\nint main() {\n  int h, w;\n  while (scanf(\"%d %d\", &h, &w), h|w) {\n    MEMSET(field, 0);\n    MEMSET(visit, false);\n    MEMSET(dist, 0x0f);\n    REP(y, h) REP(x, w) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    int sx, sy, gx, gy;\n    scanf(\"%d %d %d %d\", &sy, &sx, &gy, &gx);\n    priority_queue<State> que;\n    que.push(State(0, sx, sy, Dice(1, 2, 3)));\n    while (!que.empty()) {\n      State s = que.top();\n      que.pop();\n      int e = encode(s.dice);\n      if (visit[e][s.y][s.x]) { continue; }\n      visit[e][s.y][s.x] = true;\n      if (s.x == gx && s.y == gy) {\n        printf(\"%d\\n\", s.cost);\n        break;\n      }\n      //cout << s.x << \" \" << s.y << endl;\n      REP(i, 4) {\n        int nx = s.x + dx[i];\n        int ny = s.y + dy[i];\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n        Dice ndice = rotate(s.dice, i);\n        int ne = encode(ndice);\n        int ncost = s.cost + (7 - ndice.top) * field[ny][nx];\n        if (visit[ne][ny][nx] || ncost >= dist[ne][ny][nx]) { continue; }\n        dist[ne][ny][nx] = ncost;\n        que.push(State(ncost, nx, ny, ndice));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\ntypedef pair<int , int> P;\ntypedef pair<P,P> P2;\n\nint h,w;\nint g[30][30];\nint d[30][30][50000];\n\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r[4][6] = { {1,5,2,3,0,4},\n\t\t{3,1,0,5,4,2},\n\t\t{4,0,2,3,5,1},\n\t\t{2,1,5,0,4,3} };\n\nvector<int> trans(int n){\n  vector<int> res;\n  while(n>0){\n    res.push_back(n%6);\n    n/=6;\n  }\n  while(res.size()<6)res.push_back(0);\n  return res;\n}\n\nint rot(int n,int dir){\n  int tmp[6];\n  vector<int> die = trans(n);\n  for(int i=0;i<6;i++)tmp[i] = die[r[dir][i]];\n\n  int res = 0, k = 1;\n  for(int i=0;i<6;i++){\n    res += tmp[i] * k;\n    k *= 6;\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<50000;k++)d[i][j][k] = 100000000;\n      }\n    }\n\n    int sy,sx,gy,gx;\n    cin >> sy >> sx >> gy >> gx;\n    \n    priority_queue<P2> q;\n    q.push(P2(P(0,44790),P(sy,sx)));\n    d[sy][sx][44790] = 0;\n\n    while(!q.empty()){\n      P2 p = q.top();q.pop();\n      int s = p.first.first , num = p.first.second;\n      int y = p.second.first , x = p.second.second;\n\n      for(int i=0;i<4;i++){\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(ny<0 || nx<0 || h<=ny || w<=nx)continue;\n\tint nnum = rot(num,i);\n\t//cout << \"[\" << nnum << \"]\" << endl;\n\tvector<int> die = trans(nnum);\n\t//for(int j=0;j<6;j++)cout << die[j] << \" \";\n\t//cout << endl;\n\tif(d[ny][nx][nnum] > d[y][x][num] + g[ny][nx]*(die[5]+1)){\n\t  //cout << nnum << endl;\n\t  d[ny][nx][nnum] = d[y][x][num] + g[ny][nx]*(die[5]+1);\n\t  q.push(P2(P(d[ny][nx][nnum],nnum),P(ny,nx)));\n\t}\n      }\n    }\n\n    int m = 100000000;\n    for(int i=0;i<50000;i++)m = min(m,d[gy][gx][i]);\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\n\nint H[6][6] = {\n\t{1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n\t{3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n\t{2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n\t{4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n\t{0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n\t{0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[6] = {0,1,-1,0,0,0};\nint dy[6] = {-1,0,0,1,0,0};\n// 高さと幅\nint h, w;\n// s[y][x] := (x,y)のマスに書かれた数字\nint s[11][11];\n\n\n// サイコロライブラリ\n// d[0] := top\n// d[1] := front \n// d[2] := right\n// d[3] := left\n// d[4] := back\n// d[5] := bottom\nstruct Cube{\n\tint x,y;\n\tvector<int> d;\n\t// コンストラクタで初期化\n\tCube(vector<int> v, int x_, int y_){\n\t\tx = x_; y = y_;\n\t\tif( v.size() == 6 ){\n\t\t\td = v;\n\t\t}else{\n\t\t\td = vector<int> (6);\n\t\t}\n\t}\n\t// dirの方向に回転 (副作用なし)\n\tCube roll(int dir){\n\t\tCube result = (*this);\n\t\tvector<int> d_(6);\n    \tfor(int i = 0 ; i < 6 ; i++ ){\n        \td_[i] = d[ H[dir][i] ];\n    \t}\n    \tresult.d = d_;\n    \tresult.x += dx[dir];\n    \tresult.y += dy[dir];\n    \treturn result;\n    }\n};\nbool operator<(const Cube& c1, const Cube& c2){\n\treturn P(c1.x,c1.y) < P(c2.x,c2.y);\n}\n\ntypedef pair<int,Cube> State;\n\n// ゴール g, 初期のキューブの状態 c からのダイクストラ法\nint dijkstra(Cube c , P g){\n\t// greater<State> を指定することで コスト が小さい順に取り出せる\n\tpriority_queue<State, vector<State>, greater<State> > q;\n\t\n\t// d[cube] := cube にたどり着く最小コスト. (cubeは位置のキューブの状態を持っている)\n\tmap<Cube,int> d;\n\t\n\td[c] = 0;\n\tState start( 0 , c );\n\tq.push( start );\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\tint now_cost = q.top().first;\n\t\tCube c = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif( P(c.x,c.y) == g ){\n\t\t\tresult = now_cost;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int dir=0 ; dir < 6 ; dir++ ){\n\t\t\tCube c_ = c.roll( dir );\n\t\t\tif( c_.x < 0 || c_.y < 0 || c_.x >= w || c_.y >= h ) continue;\n\t\t\t\n\t\t\tint next_cost = now_cost + s[c_.y][c_.x] * c_.d[5];\n\t\t\tif( d.count(c_) == 0 ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}else if( next_cost < d[c_] ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid debug(Cube c, int cost){\n\tcout << \"(\" << c.x << \",\" << c.y << \") : \" << cost << endl;\n}\n\n// \nint bfs(Cube c , P g){\n\tqueue<State> q;\n\t\n\t// d[cube] := cube にたどり着く最小コスト. (cubeは位置のキューブの状態を持っている)\n\tmap<Cube,int> d;\n\t\n\td[c] = 0;\n\tState start( 0 , c );\n\tq.push( start );\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\tint now_cost = q.front().first;\n\t\tCube c = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tdebug( c , now_cost );\n\t\t\n\t\tif( P(c.x,c.y) == g ){\n\t\t\tresult = min( result , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int dir=0 ; dir < 6 ; dir++ ){\n\t\t\tCube c_ = c.roll( dir );\n\t\t\tif( c_.x < 0 || c_.y < 0 || c_.x >= w || c_.y >= h ) continue;\n\t\t\t\n\t\t\tint next_cost = now_cost + s[c_.y][c_.x] * c_.d[5];\n\t\t\tif( d.count(c_) == 0 ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}else if( next_cost < d[c_] ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\t// d[0] := top\n\t// d[1] := front \n\t// d[2] := right\n\t// d[3] := left\n\t// d[4] := back\n\t// d[5] := bottom\n\tvector<int> v(6);\n\tv[0] = 1; v[5] = 6;\n\tv[1] = 2; v[4] = 5;\n\tv[2] = 3; v[3] = 4;\t\n\t\n\twhile( cin >> h >> w , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tCube c( v, sx, sy );\n\t\tint ans = dijkstra( c , P(gx,gy) );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice(T *v) {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n    REP(i,6)\n      var[i] = v[i];\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n           a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n           a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    int tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nbool operator < (const dice<int> &a, const dice<int> &b) {\n  if (a[TOP]!=b[TOP]) return a[TOP] < b[TOP];\n  if (a[FRONT]!=b[FRONT]) return a[FRONT] < b[FRONT];\n  if (a[BACK]!=b[BACK]) return a[BACK] < b[BACK];\n  if (a[BOTTOM]!=b[BOTTOM]) return a[BOTTOM] < b[BOTTOM];\n  if (a[LEFT]!=b[LEFT]) return a[LEFT] < b[LEFT];\n  return a[RIGHT] < b[RIGHT];;\n}\n\nstruct P {\n  int cost;\n  int x;\n  int y;\n  dice<int> di;\n  P(int cost,int x,int y,dice<int> di) : cost(cost),x(x),y(y),di(di) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.cost>b.cost;\n}\n\n  \n\nint main() {\n  int h, w;\n  while(cin>>h>>w,h) {\n    int ba[w][h];\n    REP(y,h)\n      REP(x,w)\n        cin >> ba[x][y];\n    int sx,sy,gx,gy;\n    cin>>sy>>sx>>gy>>gx;\n\n    int arr[] = {1,2,4,3,5,6};\n    dice<int> di(arr);\n\n    priority_queue<P> Q;\n    Q.push(P(0,sx,sy,di));\n    map<dice<int>,bool> visited[w][h];\n//    memset(visited,0,sizeof(visited));\n    map<dice<int>,int> res[w][h];\n    vector<dice<int> > vvv = di.all_rolls();\n    REP(i,vvv.size()) {\n      REP(x,w) REP(y,h) {\n        res[x][y][vvv[i]] = INF;\n      }\n    }\n    res[sx][sy][di] = 1;\n    while(!Q.empty()) {\n      P p =Q.top();\n      Q.pop();\n      int x=p.x,y=p.y,cost=p.cost;\n      dice<int> nd = p.di;\n      if (visited[x][y][nd]) {\n//        printf(\"a %d,%d %d\\n\",x,y,cost);\n        continue;\n      }\n      //     printf(\"%d,%d %d\\n\",x,y,cost);\n      visited[x][y][nd] = 1;\n      //cout << res[x][y][nd] << endl;\n      const int dx[] = {0,1,0,-1};\n      const int dy[] = {-1,0,1,0};\n      REP(k,4) {\n        int xx = x+dx[k];\n        int yy = y+dy[k];\n        if (xx<0||xx>=w||yy<0||yy>=h) continue;\n\n        dice<int> tmp = nd;\n        if (k == 0) { tmp.roll_x();tmp.roll_x();tmp.roll_x(); }\n        else if (k == 1) tmp.roll_y();\n        else if (k == 2) tmp.roll_x();\n        else { tmp.roll_y();tmp.roll_y();tmp.roll_y(); }\n        \n        if (res[xx][yy][tmp] > cost + tmp[BOTTOM]*ba[xx][yy]) {\n          res[xx][yy][tmp] = cost + tmp[BOTTOM]*ba[xx][yy];\n          Q.push(P(res[xx][yy][tmp], xx,yy, tmp));\n        }\n      }\n    }\n    int rs = INF;\n    REP(i,vvv.size())\n      rs = min(rs, res[gx][gy][vvv[i]]);\n    cout << rs << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nclass DICE{\npublic:\n\tvector<int> dice;\n\tDICE(){\n\t\tdice.resize(6);\n\t\trep(i,6)dice[i]=i+1;\n\t}\n\t// top/front/right/left/back/bottom  \n\tvoid back(){\n\t\tint to[] = {4,0,2,3,5,1};\n\t\tvector<int> tmp(6);\n\t\trep(i,6)tmp[to[i]] = dice[i];\n\t\tdice = tmp;\n\t}\n\tvoid left(){\n\t\tint to[] = {3,1,0,5,4,2};\n\t\tvector<int> tmp(6);\n\t\trep(i,6)tmp[to[i]] = dice[i];\n\t\tdice = tmp;\n\t}\n\tvoid rotate(){\n\t\tint to[] = {0,3,1,4,2,5};\n\t\tvector<int> tmp(6);\n\t\trep(i,6)tmp[to[i]] = dice[i];\n\t\tdice = tmp;\n\t}\n\tvoid select(int n){\n\t\tif(n==0)left();\n\t\telse if(n==1)left(),left(),left();\n\t\telse if(n==2)back();\n\t\telse if(n==3)back(),back(),back();\n\t}\n};\nstruct NODE{\n\tint cost,x,y;\n\tDICE dice;\n\tNODE(int a,int b,int c,DICE d){cost = a , x = b , y = c , dice = d;}\n};\nbool operator<(const NODE &a,const NODE &b){\n\tif(a.x != b.x)return a.x < b.x;\n\tif(a.y != b.y)return a.y < b.y;\n\tif(a.dice.dice != b.dice.dice)return a.dice.dice < b.dice.dice;\n\treturn false;\n}\nbool operator>(const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint main(){\n\tint W,H;\n\tint data[10][10];\n\twhile(cin >> H >> W , H){\n\t\tmap<NODE,bool> done;\n\t\tpriority_queue<NODE,vector<NODE>,greater<NODE> > Q;\n\t\trep(i,H)rep(j,W)\n\t\t\tcin >> data[i][j];\n\t\tint sx,sy,gx,gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tQ.push(NODE(0,sx,sy,DICE()));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[q])continue;\n\t\t\telse done[q] = true;\n\t\t\tif(q.x == gx && q.y == gy){\n\t\t\t\tcout << q.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tNODE next = q;\n\t\t\t\tnext.x = dx[i] + q.x;\n\t\t\t\tnext.y = dy[i] + q.y;\n\t\t\t\tnext.dice.select(i);\n\t\t\t\tif(next.x < 0 || next.y < 0 || next.y >= H || next.x >= W) continue;\n\t\t\t\tnext.cost = q.cost + next.dice.dice[5] * data[next.y][next.x] ;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstruct _nd {\n\tint cost;\n\tint x,y;\n\tint a,b,c;\n};\nint main()\n{\n\tint h,w;\n\tconst int dx[] = {0,1,0,-1}; // up, right, down, left\n\tconst int dy[] = {-1,0,1,0};\n\tconst int inf = 99999999;\n\twhile( cin>>h>>w, h|w ){\n\t\tint field[2][10];\n\t\tint memo[7][7][7][2][10];\n\t\tint sx,sy,gx,gy;\n\t\tint ans = inf;\n\t\t\n\t\tfor(int a=0; a<7; a++)for(int b=0; b<7; b++)for(int c=0; c<7; c++)\n\t\t\tfor(int d=0; d<2; d++)for(int e=0; e<10; e++)memo[a][b][c][d][e] = inf;\n\t\tfor(int i=0; i<h; i++)\n\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\tcin>>field[i][j];\n\t\t\n\t\tcin>>sy>>sx;\n\t\tcin>>gy>>gx;\n\t\t\n\t\tstruct _nd nd;\n\t\tnd.cost = 0;\n\t\tnd.x=sx; nd.y=sy;\n\t\tnd.a=1; nd.b=2; nd.c=3;\n\t\tvector< struct _nd > vs;\n\t\tvs.push_back( nd );\n\t\tmemo[1][2][3][sy][sx] = 0;\n\t\twhile( vs.size() ){\n\t\t\tint tmin = inf;\n\t\t\tint ind;\n\t\t\tfor(int i=0; i<vs.size(); i++){\n\t\t\t\tif( tmin > vs[i].cost ){\n\t\t\t\t\ttmin = vs[i].cost;\n\t\t\t\t\tind = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd = vs[ind];\n\t\t\tif( (nd.x==gx && nd.y==gy) || nd.cost>=ans )break;\n\t\t\tvs.erase( vs.begin()+ind );\n\t\t\t\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tint tx = nd.x + dx[k];\n\t\t\t\tint ty = nd.y + dy[k];\n\t\t\t\tint na = k==0 ? nd.b   : k==1 ? 7-nd.c : k==2 ? 7-nd.b : nd.c ;\n\t\t\t\tint nb = k==0 ? 7-nd.a : k==1 ? nd.b   : k==2 ? nd.a   : nd.b ;\n\t\t\t\tint nc = k==0 ? nd.c   : k==1 ? nd.a   : k==2 ? nd.c   : 7-nd.a ;\n\t\t\t\t\n\t\t\t\t//printf(\"k:%d  (%d,%d),[na:nb:nc]=[%d:%d:%d]\\n\",k,tx,ty,na,nb,nc);\n\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h ||\n\t\t\t\t\t\tmemo[na][nb][nc][ty][tx] <= field[ty][tx]*(7-na)+nd.cost ) continue;\n\t\t\t\t//printf(\"k:%d  (%d,%d),[na:nb:nc]=[%d:%d:%d]  _old[%d:%d:%d]\\n\",k,tx,ty,na,nb,nc\n\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nd.a,nd.b,nd.c);\n\t\t\t\tmemo[na][nb][nc][ty][tx] = field[ty][tx]*(7-na) + nd.cost;\n\t\t\t\tif( tx==gx && ty==gy ){ ans = min( ans, field[ty][tx]*(7-na) + nd.cost ); }\n\t\t\t\t//printf(\"memo[%d][%d][%d][%d][%d] = %d\\n\",na,nb,nc,ty,tx,field[ty][tx]*(7-na) + nd.cost);\n\t\t\t\tstruct _nd tmp = {field[ty][tx]*(7-na)+nd.cost, tx, ty, na, nb, nc};\n\t\t\t\tvs.push_back( tmp );\n\t\t\t}\n\t\t\t//printf(\"_\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[40][40];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;\n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n    RollMe(i);\n    if(/*!used[ny][nx] &&*/ 0<=nx && nx<w && 0<=ny && ny <h && dpused[ny][nx] > sam+imap[ny][nx]*dice[5]){\n      //used[ny][nx] = true;\n      //RollMe(i);\n\tdpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));\n      //used[ny][nx] = false;\n    }\n      RollMe(Reverse(i));\n  }\n\n}\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\tdpused[i][j] = INF;\n      }\n    //used[s.S][s.F] = true;\n    dpused[s.S][s.F] = 0;\n    rec(s,0);\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[20][20];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n/*\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n*/\n/*\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;  \n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n*/\n//if(/*!used[ny][nx] &&*/// !(0<=nx && nx<w && 0<=ny && ny <h))continue;\n    //cout << \"nx = \" << nx << \" ny = \"  << ny << endl;//\n//      RollMe(i);\n//if( dpused[ny][nx] > (sam+imap[ny][nx]*dice[5]) ){\n      //used[ny][nx] = true;//\n      //RollMe(i);//\n      //dpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n\t//rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));//\n      //used[ny][nx] = false;//\n      //  }\n//    RollMe(Reverse(i));\n//}\n//}\n\n\nint idx(int tp,int ft){\n  return tp*10+ft;\n}\n\n\nstruct special{\n  int x,y,top,front,left,back,right,bottom,cost;\n  //special (int x,int y,int top,int front,int left,int back,int right,int bottom,int cost):x(x),y(y),top(top),front(front),left(left),back(back),right(right),bottom(bottom),cost(cost){}\n\n  bool operator < (const special &p)const{\n    return cost > p.cost;\n  }\n\n\n  //0->top, 1->front, 2->left, 3->back, 4->right, 5->bottom\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = back;\n    back = bottom;\n    bottom = front;\n    front = top;\n    top = h;\n  }\n  else if(face == 1){\n    int h = top;\n    top = left;\n    left = bottom;\n    bottom = right;\n    right = h;\n  }\n  else if(face == 2){\n    int h = top;\n    top = front;\n    front = bottom;\n    bottom = back;\n    back = h;\n  }\n  else if(face == 3){\n    int h = top;\n    top = right;\n    right = bottom;\n    bottom= left;\n    left = h;\n  }\n}\n\n\n};\nint D[20][20][100];\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\t//\tdpused[i][j] = INF;\n\tfor(int k=0;k<100;k++)D[i][j][k] = INF;\n      }\n  \n    //used[s.S][s.F] = true;\n    //dpused[s.S][s.F] = 0;\n    //rec(s,0);\n    D[s.S][s.F][idx(1,2)]=0;\n    priority_queue<special>que;\n    special In;\n    //int dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n    In.x = s.F;In.y = s.S; In.top = 1;In.front = 2;In.left = 4;In.back = 5;In.right = 3;In.bottom = 6; In.cost = 0;\n    que.push(In);\n    //special - > x,y,top,front,left,back,right,bottom,cost;\n    while(!que.empty()){\n      special pos = que.top(); que.pop();\n      //majesty\n      if(pos.x == g.F && pos.y == g.S){\n\tcandidate = min(candidate,pos.cost);\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tint nx = pos.x+dx[i],ny = pos.y+dy[i];\n\n\tif(!(0<=nx && nx <w && 0<= ny && ny <h))continue;\n\tpos.RollMe(i);       \n\n\tif(D[ny][nx][idx(pos.top,pos.front)] > imap[ny][nx]*pos.bottom+ pos.cost){\n\t  D[ny][nx][idx(pos.top,pos.front)] = imap[ny][nx]*pos.bottom+ pos.cost;\n\t  In.x = nx;In.y = ny;In.top = pos.top;In.front = pos.front;In.back = pos.back;In.left = pos.left; In.right = pos.right; In.bottom = pos.bottom; In.cost =  imap[ny][nx]*pos.bottom+ pos.cost;\n\t  que.push(In);\n\t}\n\t  pos.RollMe(Reverse(i));\n\n      }\n\n    }\n\n    /*\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cout << dpused[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef pair<int , int> P;\ntypedef pair<P,P> P2;\n\nint h,w;\nint g[30][30];\nint d[30][30][50000];\n\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r[4][6] = { {1,5,2,3,0,4},\n\t\t{3,1,0,5,4,2},\n\t\t{4,0,2,3,5,1},\n\t\t{2,1,5,0,4,3} };\n\nvector<int> trans(int n){\n  vector<int> res;\n  while(n>0){\n    res.push_back(n%6);\n    n/=6;\n  }\n  while(res.size()<6)res.push_back(0);\n  return res;\n}\n\nint rot(int n,int dir){\n  int tmp[6];\n  vector<int> die = trans(n);\n  for(int i=0;i<6;i++)tmp[i] = die[r[dir][i]];\n\n  int res = 0, k = 1;\n  for(int i=0;i<6;i++){\n    res += tmp[i] * k;\n    k *= 6;\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<50000;k++)d[i][j][k] = 10000000;\n      }\n    }\n\n    int sy,sx,gy,gx;\n    cin >> sy >> sx >> gy >> gx;\n    \n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(P(0,44790),P(sy,sx)));\n    d[sy][sx][44790] = 0;\n\n    while(!q.empty()){\n      P2 p = q.top();q.pop();\n      int s = p.first.first , num = p.first.second;\n      int y = p.second.first , x = p.second.second;\n\n      for(int i=0;i<4;i++){\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(ny<0 || nx<0 || h<=ny || w<=nx)continue;\n\tint nnum = rot(num,i);\n\n\tvector<int> die = trans(nnum);\n\n\tif(d[ny][nx][nnum] > d[y][x][num] + g[ny][nx]*(die[5]+1)){\n\t  d[ny][nx][nnum] = d[y][x][num] + g[ny][nx]*(die[5]+1);\n\t  q.push(P2(P(d[ny][nx][nnum],nnum),P(ny,nx)));\n\t}\n      }\n    }\n\n    int m = 10000000;\n    for(int i=0;i<50000;i++)m = min(m,d[gy][gx][i]);\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[20][20];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;  \n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n  \n    if(/*!used[ny][nx] &&*/ !(0<=nx && nx<w && 0<=ny && ny <h))continue;\n    //cout << \"nx = \" << nx << \" ny = \"  << ny << endl;\n       RollMe(i);\n    if( dpused[ny][nx] >= (sam+imap[ny][nx]*dice[5]) ){\n      //used[ny][nx] = true;\n      //RollMe(i);\n\tdpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));\n      //used[ny][nx] = false;\n    }\n      RollMe(Reverse(i));\n  }\n}\n\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\tdpused[i][j] = INF;\n      }\n    //used[s.S][s.F] = true;\n    dpused[s.S][s.F] = 0;\n    rec(s,0);\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint x;\n\tint y;\n\tint under;\n\tint over;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\n// y,x,ºÌÚ,ãÌÚ\nvector<edge> G[10][10][7][7];\nint d[10][10][7][7];\nconst int INF = 100000000;\n\nint h,w;\n\nint field[10][10];\n\nclass Situation{\npublic:\n\tint x,y,under,over;\n\tint cost;\n\tSituation(int x_,int y_,int under_,int over_,int cost_){\n\t\tx = x_;\n\t\ty = y_;\n\t\tunder = under_;\n\t\tover = over_;\n\t\tcost = cost_;\n\t}\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\n\nedge prevv[10][10][7][7];\n\nvoid dijkstra(int x,int y,int under,int over){\n\tpriority_queue<Situation> que;\n\tfor(int i = 0; i < 10; i++)\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tfor(int k = 0; k < 7; k++)\n\t\t\t\tfill(d[i][j][k],d[i][j][k]+7,INF);\n\n\td[y][x][under][over] = 0;\n\tque.push(Situation(x,y,under,over,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint cx = p.x;\n\t\tint cy = p.y;\n\t\tint cu = p.under;\n\t\tint co = p.over;\n\n\t\tif(d[cy][cx][cu][co] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[cy][cx][cu][co].size(); i++){\n\t\t\tedge e = G[cy][cx][cu][co][i];\n\t\t\tint cost = field[e.y][e.x]*e.under;\n\t\t\tif(d[e.y][e.x][e.under][e.over] > d[cy][cx][cu][co] + cost){\n\t\t\t\tedge ret;\n\t\t\t\tret.y = cy;ret.x=x;ret.over=co;ret.under=cu;\n\t\t\t\tprevv[e.y][e.x][e.under][e.over] = ret;\n\t\t\t\td[e.y][e.x][e.under][e.over] = d[cy][cx][cu][co] + cost;\n\t\t\t\tque.push(Situation(e.x,e.y,e.under,e.over,d[e.y][e.x][e.under][e.over]));\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<endl;\n}\n\nint main(){\n\n\twhile(cin >> h >> w && !(h==0&&w==0)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tpair<int,int> start,goal;\n\t\tcin >> start.first >> start.second;\n\t\tcin >> goal.first >> goal.second;\n\n\t\t// edgeðÔ\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\t\tfor(int l = 0; l < 7; l++)\n\t\t\t\t\t\tG[i][j][k][l].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dy[]={-1,0,0,1};\n\t\tint dx[]={0,-1,1,0};\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t// êÊÌÚ\n\t\t\t\tfor(int k = 1; k < 7; k++){\n\t\t\t\t\t// ã¤ÊÌÚ\n\t\t\t\t\tfor(int l = 1; l < 7; l++){\n\t\t\t\t\t\tif(k == l || k + l == 7)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\t\tpair<int,int> np;\n\t\t\t\t\t\t\tnp.first = i + dy[m];\n\t\t\t\t\t\t\tnp.second = j + dx[m];\n\t\t\t\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\t\t\t\t// »ÝÌ}XÌóµÉ¶Äedgeðãü\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.x = np.second;\n\t\t\t\t\t\t\t\te.y = np.first;\n\t\t\t\t\t\t\t\t//e.cost = field[np.first][np.second];\n\t\t\t\t\t\t\t\t// ãÉiÞê\n\t\t\t\t\t\t\t\tif(dy[m] == -1){\n\t\t\t\t\t\t\t\t\te.under = l;\n\t\t\t\t\t\t\t\t\te.over = 7-k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// ºÉiÞê\n\t\t\t\t\t\t\t\telse if(dy[m] == 1){\n\t\t\t\t\t\t\t\t\te.under = 7-l;\n\t\t\t\t\t\t\t\t\te.over = k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// ¶EÉiÞê\n\t\t\t\t\t\t\t\telse if(dx[m] == 1 || dx[m]==-1){\n\t\t\t\t\t\t\t\t\te.over = l;\n\t\t\t\t\t\t\t\t\tif(k == 1 || k == 6){\n\t\t\t\t\t\t\t\t\t\tif(l == 2){\n\t\t\t\t\t\t\t\t\t\t\te.under = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 3){\n\t\t\t\t\t\t\t\t\t\t\te.under = 2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 5){\n\t\t\t\t\t\t\t\t\t\t\te.under = 3;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 4){\n\t\t\t\t\t\t\t\t\t\t\te.under = 5;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(k == 1){\n\t\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if(k == 2 || k == 5){\n\t\t\t\t\t\t\t\t\t\tif(l == 3){\n\t\t\t\t\t\t\t\t\t\t\te.under = 6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 4){\n\t\t\t\t\t\t\t\t\t\t\te.under = 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 1){\n\t\t\t\t\t\t\t\t\t\t\te.under = 3;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 6){\n\t\t\t\t\t\t\t\t\t\t\te.under = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(k==2){\n\t\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if(k == 3 || k == 4){\n\t\t\t\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\t\t\t\te.under =5;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 2){\n\t\t\t\t\t\t\t\t\t\t\te.under = 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l == 5){\n\t\t\t\t\t\t\t\t\t\t\te.under = 6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(l==6){\n\t\t\t\t\t\t\t\t\t\t\te.under = 2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(k==3){\n\t\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(dx[m]==-1){\n\t\t\t\t\t\t\t\t\t\te.under = 7-e.under;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tG[i][j][k][l].push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0,0,6,5);\n\t\tint minCost = 1000000000;\n\t\tfor(int i = 1; i < 7; i++){\n\t\t\tfor(int j = 1; j < 7; j++){\n\t\t\t\tminCost = min(minCost,d[goal.first][goal.second][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minCost<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nvoid roll(vector<int>& dice, int a, int b, int c, int d){\n  int tmp = dice[a];\n  dice[a] = dice[b];\n  dice[b] = dice[c];\n  dice[c] = dice[d];\n  dice[d] = tmp;\n}\nvector<int> roll_r(int r, vector<int> dice){\n  switch(r){\n    case 0:\n      roll(dice, 0, 3, 5, 2);\n      break;\n    case 1:\n      roll(dice, 0, 4, 5, 1);\n      break;\n    case 2:\n      roll(dice, 0, 2, 5, 3);\n      break;\n    case 3:\n      roll(dice, 0, 1, 5, 4);\n      break;\n  }\n  return dice;\n}\n\nstruct S{\n  int x, y;\n  int c;\n  vector<int> d;\n  S(int x, int y, int c, vector<int> d) : \n    x(x), y(y), c(c), d(d) {}\n  bool operator < (const S& s) const {\n    if(c != s.c) return c > s.c;\n    if(x != s.x) return x < s.x;\n    if(y != s.y) return y < s.y;\n    else return d < s.d;\n  }\n};\ntypedef pair<int, int> P;\n\n//{TOP, +Y, +X, -X, -Y, BOTTOM}\nint main(){\n  int H, W;\n  while(cin>>H>>W && H){\n    int grid[10][10];\n    REP(i, H)REP(j, W) cin>>grid[i][j];\n    int sx, sy, gx, gy;\n    cin>>sy>>sx>>gy>>gx;\n    priority_queue<S> que;\n    int start[] = {1, 2, 3, 4, 5, 6};\n    que.push(S(sx, sy, 0, vector<int>(start, start + 6)));\n    set< pair<P, vector<int> > > used;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == gx && s.y == gy){\n        cout<<s.c<<endl;\n        break;\n      }\n      if(used.count(make_pair(P(s.x, s.y), s.d))) continue;\n      used.insert(make_pair(P(s.x, s.y), s.d));\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        if(valid(nx, ny, W, H)){\n          vector<int> nd = roll_r(r, s.d);\n          if(!used.count(make_pair(P(nx, ny), nd))){\n            que.push(S(nx, ny, grid[ny][nx] * nd[5] + s.c, nd));\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\n\nint H[6][6] = {\n\t{1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n\t{3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n\t{2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n\t{4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n\t{0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n\t{0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[6] = {0,1,-1,0,0,0};\nint dy[6] = {-1,0,0,1,0,0};\n// 高さと幅\nint h, w;\n// s[y][x] := (x,y)のマスに書かれた数字\nint s[11][11];\n\n\n// サイコロライブラリ\n// d[0] := top,   d[1] := front \n// d[2] := right, d[3] := left\n// d[4] := back,  d[5] := bottom\nenum{TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\n\nstruct Cube{\n\tint x,y;\n\tvector<int> d;\n\t// コンストラクタで初期化\n\tCube(vector<int> v, int x_, int y_){\n\t\tx = x_; y = y_;\n\t\tif( v.size() == 6 ){\n\t\t\td = v;\n\t\t}else{\n\t\t\td = vector<int> (6);\n\t\t}\n\t}\n\t// dirの方向に回転 (副作用なし)\n\tCube roll(int dir){\n\t\tCube result = (*this);\n\t\tvector<int> d_(6);\n    \tfor(int i = 0 ; i < 6 ; i++ ){\n        \td_[i] = d[ H[dir][i] ];\n    \t}\n    \tresult.d = d_;\n    \tresult.x += dx[dir];\n    \tresult.y += dy[dir];\n    \treturn result;\n    }\n};\nbool operator<(const Cube& c1, const Cube& c2){\n\treturn P(c1.x,c1.y) < P(c2.x,c2.y);\n}\n\ntypedef pair<int,Cube> State;\n\n// ゴール g, 初期のキューブの状態 c からのダイクストラ法\nint dijkstra(Cube c , P g){\n\t// greater<State> を指定することで コスト が小さい順に取り出せる\n\tpriority_queue<State, vector<State>, greater<State> > q;\n\t\n\t// d[cube] := cube にたどり着く最小コスト. (cubeは位置のキューブの状態を持っている)\n\tmap<Cube,int> d;\n\t\n\td[c] = 0;\n\tState start( 0 , c );\n\tq.push( start );\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\tint now_cost = q.top().first;\n\t\tCube c = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif( P(c.x,c.y) == g ){\n\t\t\tresult = now_cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int dir=0 ; dir < 4 ; dir++ ){\n\t\t\tCube c_ = c.roll( dir );\n\t\t\tif( c_.x < 0 || c_.y < 0 || c_.x >= w || c_.y >= h ) continue;\n\t\t\t\n\t\t\tint next_cost = now_cost + s[c_.y][c_.x] * c_.d[BOTTOM];\n\t\t\tif( d.count(c_) == 0 ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}else if( next_cost < d[c_] ){\n\t\t\t\td[c_] = next_cost;\n\t\t\t\tState next( next_cost , c_ );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tvector<int> v(6);\n\tv[0] = 1; v[5] = 6;\n\tv[1] = 2; v[4] = 5;\n\tv[2] = 3; v[3] = 4;\t\n\t\n\twhile( cin >> h >> w , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tCube c( v, sx, sy );\n\t\tint ans = dijkstra( c , P(gx,gy) );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n\nstruct Dice{\n  int tmp,d[6];\n  Dice(){\n    for(int i = 0 ; i < 6 ; i++){\n      d[i] = i+1;\n    }\n  }\n  void rollN(){\n    tmp = d[0];\n    d[1] = d[5];\n    d[5] = d[4];\n    d[4] = tmp;\n  }\n  void rollE(){\n    tmp = d[0];\n    d[0] = d[3];\n    d[3] = d[5];\n    d[5] = d[2];\n    d[2] = tmp;\n  }\n  void rollS(){\n    tmp = d[0];\n    d[0] = d[4];\n    d[4] = d[5];\n    d[5] = d[1];\n    d[1] = tmp;\n  }\n  void rollW(){\n    tmp = d[0];\n    d[0] = d[2];\n    d[2] = d[5];\n    d[5] = d[3];\n    d[3] = tmp;\n  }\n};\n\nstruct State{\n  int cost,x,y;\n  Dice d;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(cin >> H >> W, H){\n    int field[MAX_H][MAX_W];\n    int sx,sy,gx,gy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    Dice die;\n    int cost[MAX_H][MAX_W];\n    fill(cost[0],cost[0]+MAX_H*MAX_W,1e9);\n    cost[sy][sx] = 0;\n    priority_queue<State> Q;\n    Q.push((State){0,sx,sy,die});\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    while(!Q.empty()){\n      State s = Q.top(); Q.pop();\n      int x = s.x, y = s.y;\n      if(cost[y][x] < s.cost){\n        continue;\n      }\n      if(x == gx && y == gy){\n        cout << s.cost << endl;\n        break;\n      }\n      for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        Dice d = s.d;\n        if(0 > nx || nx >= W || 0 > ny || ny >= H){\n          continue;\n        }\n        switch(i){\n        case 0:\n          d.rollW();\n          break;\n        case 1:\n          d.rollN();\n          break;\n        case 2:\n          d.rollE();\n          break;\n        case 3:\n          d.rollS();\n          break;\n        }\n        int p = d.d[5]*field[ny][nx];\n        if(cost[y][x] + p < cost[ny][nx]){\n          cost[ny][nx] = cost[y][x] + p;\n          Q.push((State){cost[ny][nx],nx,ny,d});\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef pair<int , int> P;\ntypedef pair<P,P> P2;\n\nint h,w;\nint g[30][30];\nint d[30][30][50000];\n\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r[4][6] = { {1,5,2,3,0,4},\n\t\t{3,1,0,5,4,2},\n\t\t{4,0,2,3,5,1},\n\t\t{2,1,5,0,4,3} };\n\nvector<int> trans(int n){\n  vector<int> res;\n  while(n>0){\n    res.push_back(n%6);\n    n/=6;\n  }\n  while(res.size()<6)res.push_back(0);\n  return res;\n}\n\nint rot(int n,int dir){\n  int tmp[6];\n  vector<int> die = trans(n);\n  for(int i=0;i<6;i++)tmp[i] = die[r[dir][i]];\n\n  int res = 0, k = 1;\n  for(int i=0;i<6;i++){\n    res += tmp[i] * k;\n    k *= 6;\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<50000;k++)d[i][j][k] = 10000000;\n      }\n    }\n\n    int sy,sx,gy,gx;\n    cin >> sy >> sx >> gy >> gx;\n    \n    priority_queue<P2> q;\n    q.push(P2(P(0,44790),P(sy,sx)));\n    d[sy][sx][44790] = 0;\n\n    //set<int> SET;\n    while(!q.empty()){\n      P2 p = q.top();q.pop();\n      //SET.insert(p.first.second);\n      int s = p.first.first , num = p.first.second;\n      int y = p.second.first , x = p.second.second;\n\n      for(int i=0;i<4;i++){\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(ny<0 || nx<0 || h<=ny || w<=nx)continue;\n\tint nnum = rot(num,i);\n\n\tvector<int> die = trans(nnum);\n\n\tif(d[ny][nx][nnum] > d[y][x][num] + g[ny][nx]*(die[5]+1)){\n\t  d[ny][nx][nnum] = d[y][x][num] + g[ny][nx]*(die[5]+1);\n\t  q.push(P2(P(d[ny][nx][nnum],nnum),P(ny,nx)));\n\t}\n      }\n    }\n    //cout << SET.size() << endl;\n    int m = 10000000;\n    for(int i=0;i<50000;i++)m = min(m,d[gy][gx][i]);\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\nusing namespace std;\n#define inf 100000000\n\n\nvoid U(int *nx,int *now)\n{\n    nx[1]=now[2];\n    nx[2]=7-now[1];\n    nx[3]=now[3];\n}\n\nvoid D(int *nx,int *now)\n{\n    nx[1]=7-now[2];\n    nx[2]=now[1];\n    nx[3]=now[3];\n}\n\nvoid L(int *nx,int *now)\n{\n    nx[1]=now[3];\n    nx[2]=now[2];\n    nx[3]=7-now[1];\n}\n\nvoid R(int *nx,int *now)\n{\n    nx[1]=7-now[3];\n    nx[2]=now[2];\n    nx[3]=now[1];\n}\n\n\nint n,m;\nint a[12][12];\nint qx[500000],qy[500000];\nint q1[500000],q2[500000],q3[500000];\nint dis[12][12][10][10][10];\nint t[12][12][10][10][10];\nint now[7],nx[7];\nint sx,sy,tx,ty;\n\nint main()\n{\n  //  freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m;\n    for (int i=0;i<=11;i++)\n        for (int j=0;j<=11;j++)\n            for (int i1=0;i1<=7;i1++)\n            for (int i2=0;i2<=7;i2++)\n            for (int i3=0;i3<=7;i3++)\n            dis[i][j][i1][i2][i3]=inf;\n    memset(t,0,sizeof(t));\n    while (n+m!=0)\n    {\n        for (int k=1;k<=n;k++)\n            for (int j=1;j<=m;j++)\n                scanf(\"%d\",&a[k][j]);\n        cin>>sx>>sy>>tx>>ty;\n        sx++;sy++;tx++;ty++;\n        int head=1;\n        int tail=1;\n        q1[1]=1;\n        q2[1]=2;\n        q3[1]=3;\n        qx[1]=sx;\n        qy[1]=sy;\n        dis[sx][sy][1][2][3]=0;\n        while (head<=tail)\n        {\n            now[1]=q1[head];\n            now[2]=q2[head];\n            now[3]=q3[head];\n            int x,y;\n            x=qx[head],y=qy[head];\n            head++;\n            t[x][y][now[1]][now[2]][now[3]]=0;\n            int DIS=dis[x][y][now[1]][now[2]][now[3]];\n            if (x>1)\n            {\n                U(nx,now);\n                int &nx_dis=dis[x-1][y][nx[1]][nx[2]][nx[3]];\n                int &nx_t=t[x-1][y][nx[1]][nx[2]][nx[3]];\n                int temp=DIS+a[x-1][y]*(7-nx[1]);\n                if (temp<nx_dis)\n                {\n                    nx_dis=temp;\n                    if (!nx_t)\n                    {\n                        nx_t=1;\n                        qx[++tail]=x-1;\n                        qy[tail]=y;\n                        q1[tail]=nx[1];\n                        q2[tail]=nx[2];\n                        q3[tail]=nx[3];\n                    }\n                }\n            }\n            if (x<n)\n            {\n                D(nx,now);\n                int &nx_dis=dis[x+1][y][nx[1]][nx[2]][nx[3]];\n                int &nx_t=t[x+1][y][nx[1]][nx[2]][nx[3]];\n                int temp=DIS+a[x+1][y]*(7-nx[1]);\n                if (temp<nx_dis)\n                {\n                    nx_dis=temp;\n                    if (!nx_t)\n                    {\n                        nx_t=1;\n                        qx[++tail]=x+1;\n                        qy[tail]=y;\n                        q1[tail]=nx[1];\n                        q2[tail]=nx[2];\n                        q3[tail]=nx[3];\n                    }\n                }\n            }\n            if (y>1)\n            {\n                L(nx,now);\n                int &nx_dis=dis[x][y-1][nx[1]][nx[2]][nx[3]];\n                int &nx_t=t[x][y-1][nx[1]][nx[2]][nx[3]];\n                int temp=DIS+a[x][y-1]*(7-nx[1]);\n                if (temp<nx_dis)\n                {\n                    nx_dis=temp;\n                    if (!nx_t)\n                    {\n                        nx_t=1;\n                        qx[++tail]=x;\n                        qy[tail]=y-1;\n                        q1[tail]=nx[1];\n                        q2[tail]=nx[2];\n                        q3[tail]=nx[3];\n                    }\n                }\n            }\n            if (y<m)\n            {\n                R(nx,now);\n                int &nx_dis=dis[x][y+1][nx[1]][nx[2]][nx[3]];\n                int &nx_t=t[x][y+1][nx[1]][nx[2]][nx[3]];\n                int temp=DIS+a[x][y+1]*(7-nx[1]);\n                if (temp<nx_dis)\n                {\n                    nx_dis=temp;\n                    if (!nx_t)\n                    {\n                        nx_t=1;\n                        qx[++tail]=x;\n                        qy[tail]=y+1;\n                        q1[tail]=nx[1];\n                        q2[tail]=nx[2];\n                        q3[tail]=nx[3];\n                    }\n                }\n            }\n        }\n        int ans=inf;\n        for (int i=1;i<7;i++)\n            for (int j=1;j<7;j++)\n                for (int k=1;k<7;k++)\n                    ans=min(ans,dis[tx][ty][i][j][k]);\n\n\n\n        for (int k=1;k<=tail;k++)\n            dis[qx[k]][qy[k]][q1[k]][q2[k]][q3[k]]=inf;\n\n        cout<<ans<<endl;\n\n        cin>>n>>m;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <ctime>\nusing namespace std;\n\nint H[6][6] = {\n    {1,5,2,3,0,4}, // North : 奥へ移動   ( y:-1 )\n    {3,1,0,5,4,2}, // East  : 右へ移動   ( x:+1 )\n    {2,1,5,0,4,3}, // West  : 左へ移動   ( x:-1 )\n    {4,0,2,3,5,1}, // South : 手前へ移動 ( y:+1 )\n    {0,2,4,1,3,5}, // Right : 右回りに回転 (移動なし)\n    {0,3,1,4,2,5}  // Left  : 左回りに回転 (移動なし)\n};\n\nint dx[4] = {0,1,-1,0};\nint dy[4] = {-1,0,0,1};\n\n// サイコロライブラリ\n// d[0] := top,   d[1] := front \n// d[2] := right, d[3] := left\n// d[4] := back,  d[5] := bottom\nenum{TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\nstruct Cube{\n    vector<int> d;\n    // コンストラクタで初期化\n    Cube(vector<int> v){\n        if( v.size() == 6 )\n            d = v;\n        else\n            d = vector<int>(6);\n    }\n    Cube(){ d = vector<int>(6); }\n    // dirの方向に回転 (副作用なし)\n    Cube roll(int dir){\n        vector<int> d_(6);\n        for(int i = 0 ; i < 6 ; i++ ){\n            d_[i] = d[ H[dir][i] ];\n        }\n        return Cube(d_);\n    }\n};\n// Cube の順序を定義 (map<Cube,T> を使いたいとき用)\nbool operator<(const Cube& a, const Cube& b){\n    if( a.d[0] == b.d[0] )\n        return a.d[1] < b.d[1];\n    return a.d[0] < b.d[0];\n}\n\nconst int INF = 1e+8;\nint m[10][10];\nint w, h, sx, sy, gx, gy;\n// d[y][x][top][front] := (x,y) にサイコロの上面がtop, 正面がfrontだったときの最小コスト\nint d[10][10][10][10];\n\nstruct State{\n\tCube c;\n\tint x, y, cost;\n\tState(){}\n\tState(Cube c_, int x_, int y_, int cost_){\n\t\tc = c_; x = x_; y = y_; cost = cost_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\nint solve(){\n\t// 初期化\n\tfor(int y=0 ; y < 10 ; y++ ){\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\tfor(int i=0 ; i < 10 ; i++ ){\n\t\t\t\tfill(d[y][x][i], d[y][x][i]+10, INF);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> v(6);\n\tfor(int i=0 ; i < 6 ; i++ ){\n\t\tv[i] = i+1;\n\t}\n\td[sy][sx][1][2] = 0;\n\tpriority_queue<State> q;\n\tq.push( State(Cube(v), sx, sy, 0) );\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint x = q.top().x;\n\t\tint y = q.top().y;\n\t\tint cost = q.top().cost;\n\t\tCube c = q.top().c;\n\t\tq.pop();\n\t\t\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tCube next = c.roll(i);\n\t\t\tint next_cost = cost + next.d[BOTTOM] * m[my][mx];\n\t\t\tint top = next.d[TOP];\n\t\t\tint front = next.d[FRONT];\n\t\t\tif( next_cost < d[my][mx][top][front] ){\n\t\t\t\td[my][mx][top][front] = next_cost;\n\t\t\t\tq.push( State(next, mx, my, next_cost) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> h >> w , h || w ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice(T *v) {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n    REP(i,6)\n      var[i] = v[i];\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n           a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n           a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    int tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nstruct P {\n  int cost;\n  int x;\n  int y;\n  dice<int> di;\n  P(int cost,int x,int y,dice<int> di) : cost(cost),x(x),y(y),di(di) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.cost>b.cost;\n}\n\n  \n\nint main() {\n  int h, w;\n  while(cin>>h>>w,h) {\n    int ba[w][h];\n    REP(y,h)\n      REP(x,w)\n        cin >> ba[x][y];\n    int sx,sy,gx,gy;\n    cin>>sy>>sx>>gy>>gx;\n\n    int arr[] = {1,2,4,3,5,6};\n    dice<int> di(arr);\n\n    priority_queue<P> Q;\n    Q.push(P(0,sx,sy,di));\n    bool visited[w][h];\n    int res[w][h];\n    REP(x,w) REP(y,h)\n      res[x][y] = INF;\n    res[sx][sy] = 0;\n    memset(visited,0,sizeof(visited));\n    while(!Q.empty()) {\n      P p =Q.top();\n      Q.pop();\n      int x=p.x,y=p.y,cost=p.cost;\n      dice<int> nd = p.di;\n      if (visited[x][y]) continue;\n      visited[x][y] = 1;\n      const int dx[] = {0,1,0,-1};\n      const int dy[] = {-1,0,1,0};\n      REP(k,4) {\n        int xx = x+dx[k];\n        int yy = y+dy[k];\n        if (xx<0||xx>=w||yy<0||yy>=h) continue;\n        if (visited[xx][yy]) continue;\n\n        dice<int> tmp = nd;\n        if (k == 0) { tmp.roll_x();tmp.roll_x();tmp.roll_x(); }\n        else if (k == 1) tmp.roll_y();\n        else if (k == 2) tmp.roll_x();\n        else { tmp.roll_y();tmp.roll_y();tmp.roll_y(); }\n\n        if (res[xx][yy] > cost + tmp[BOTTOM]*ba[xx][yy]) {\n          res[xx][yy] = cost + tmp[BOTTOM]*ba[xx][yy];\n          Q.push(P(res[xx][yy], xx,yy, tmp));\n        }\n      }\n    }\n    cout << res[gx][gy] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n \nconst int INF = (1<<29);\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,1,0,-1};\nint h,w;\n \nclass state{\npublic:\n  int y,x, up,n,e, cost;\n};\n \nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n \nint main(){\n  while(cin >> h >> w && (h|w)){\n    int a[11][11],b[11][11][6][6][6],gx,gy,ans=INF;\n    state u,v;\n    queue<state> Q;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> a[i][j];\n        for(int k=0;k<6;k++) for(int l=0;l<36;l++) b[i][j][k][l/6][l%6] = INF;\n      }\n    }\n    cin >> u.y >> u.x >> gy >> gx;\n    b[u.y][u.x][0][4][2] = 0;\n    u.up = 1;\n    u.n = 5;\n    u.e = 3;\n    u.cost = 0;\n    Q.push(u);\n \n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n \n      if(u.y == gy && u.x == gx){\n        ans = min(ans,u.cost);\n        continue;\n      }\n \n      for(int i=0;i<4;i++){\n        v = u;\n        v.y += dy[i];\n        v.x += dx[i];\n        if(!check(v.y,v.x)) continue;\n        if(i == 0){\n          v.up = 7 - u.n;\n          v.n = u.up;\n        } else if(i == 1){\n          v.up = 7 - u.e;\n          v.e = u.up;\n        } else if(i == 2){\n          v.up = u.n;\n          v.n = 7 - u.up;\n        } else if(i == 3){\n          v.up = u.e;\n          v.e = 7 - u.up;\n        }\n        v.cost += a[v.y][v.x] * (7 - v.up);\n        if(b[v.y][v.x][v.up-1][v.n-1][v.e-1] > v.cost){\n          b[v.y][v.x][v.up-1][v.n-1][v.e-1] = v.cost;\n          Q.push(v);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Cost first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Dice{\n  int t, s, e;\n};\n\nstruct State{\n  Dice d;\n  int y, x;\n\n  // 最後のconstを忘れると\"instaniated from here\"とエラーがでる\n  bool operator<( const State& right) const{\n    return y == right.y ? x < right.x : y < right.y;\n  }\n};\n\nint h, w, sy, sx, gy, gx;\nint cost[16][16];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d%d\", &h, &w) && h+w){\n    int res = INF;\n    rep(i, h) rep(j, w) scanf(\"%d\", &cost[i][j]);\n    scanf(\"%d%d%d%d\", &sy, &sx, &gy, &gx);\n\n    State s;\n    s.d.t = 1; s.d.s = 2; s.d.e = 3;\n    s.y = sy; s.x = sx;\n\n    priority_queue<pair<int, State>, vector<pair<int, State> >, greater<pair<int, State> > > q;\n    q.push(MP(0, s));\n    map<pi, int> m;\n    m[MP(sy, sx)] = 0;\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      //      printf(\"qsize %d\\n\", qsize);\n      rep(i, qsize){\n\tpair<int, State> now = q.top(); q.pop();\n\trep(d, 4){\n\t  pair<int , State> next = now;\n\t  next.S.y += dy[d]; next.S.x += dx[d];\n\t  int ny = next.S.y, nx = next.S.x;\n\t  if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\n\t  int tmp;\n\t  switch(d){\n\t  case 0: // west\n\t    tmp = 7 - next.S.d.t;\n\t    next.S.d.t = next.S.d.e;\n\t    next.S.d.e = tmp;\n\t    break;\n\t  case 1: // north\n\t    tmp = 7 - next.S.d.t;\n\t    next.S.d.t = next.S.d.s;\n\t    next.S.d.s = tmp;\n\t    break;\n\t  case 2: // east\n\t    tmp = 7 - next.S.d.e;\n\t    next.S.d.e = next.S.d.t;\n\t    next.S.d.t = tmp;\n\t    break;\n\t  case 3: // south\n\t    tmp = 7 - next.S.d.s;\n\t    next.S.d.s = next.S.d.t;\n\t    next.S.d.t = tmp;\n\t    break;\n\t  }\n\n\t  next.Cost += cost[ny][nx] * (7 - next.S.d.t);\n\t  if(m.count(MP(ny, nx)) != 0  && m[MP(ny,nx)] <= next.Cost) continue;\n\t  m[MP(ny,nx)] = next.Cost;\n\t  //\t  printf(\"%d %d\\n\", ny, nx);\n\t  if(ny == gy && nx == gx){\n\t    res = min(res, next.Cost);\n\t    break;\n\t  }\n\t  q.push(next);\n\t}\n      }\n    }\n    printf(\"%d\\n\", res==INF?0:res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 10000000\nusing namespace std;\n\nint mdata[10][10];\nint h, w;\nint sx, sy, gx, gy;\nclass State{\npublic:\n  int x, y;\n  int sai[3];\n  int pe;\n};\n\nint bfs();\n\nmain(){\n  while(1){\n    cin >> h >> w;\n    if(h==0 && w==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mdata[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    cout << bfs() << endl;\n  }\n  return 0;\n}\n\nint bfs(){\n  int dx[4]={0, 1, 0, -1};\n  int dy[4]={-1, 0, 1, 0};\n  int cost[10][10][6][6][6];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<6;k++){\n\tfor(int l=0;l<6;l++){\n\t  for(int o=0;o<6;o++){\n\t    cost[i][j][k][l][o]=INF;\n\t  }\n\t}\n      }\n    }\n  }\n  State u, v;\n  u.sai[0]=1;\n  u.sai[1]=2;\n  u.sai[2]=3;\n  u.pe=0;\n  u.x=sx;\n  u.y=sy;\n  cost[u.y][u.x][0][1][2]=0;\n  queue<State> Q;\n  Q.push(u);\n  while(!Q.empty()){\n    u=Q.front(), Q.pop();\n    //printf(\"%d %d %d %d %d %d\\n\", u.x, u.y, u.sai[0], u.sai[1], u.sai[2], u.pe);\n    if(u.x==gx && u.y==gy) continue;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << cost[i][j] << ' ';\n      }\n      cout << endl;\n      }*/\n    for(int i=0;i<4;i++){\n      int ty, tx;\n      ty=u.y+dy[i];\n      tx=u.x+dx[i];\n      if(ty>=0 && ty<h){\n\tif(tx>=0 && tx<w){\n\t  int tmp;\n\t  if(i==0){\n\t    tmp=(7-u.sai[1])*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    v.sai[0]=u.sai[1];\n\t    v.sai[1]=7-u.sai[0];\n\t    v.sai[2]=u.sai[2];\n\t    if(v.pe<cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]){\n\t      cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      Q.push(v);\n\t    }\n\t  }\n\t  else if(i==1){\n\t    tmp=u.sai[2]*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    v.sai[0]=7-u.sai[2];\n\t    v.sai[1]=u.sai[1];\n\t    v.sai[2]=u.sai[0];\n\t    if(v.pe<cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]){\n\t      cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      Q.push(v);\n\t    }\n\t  }\n\t  else if(i==2){\n\t    tmp=u.sai[1]*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    v.sai[0]=7-u.sai[1];\n\t    v.sai[1]=u.sai[0];\n\t    v.sai[2]=u.sai[2];\n\t    if(v.pe<cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]){\n\t      cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      Q.push(v);\n\t    }\n\t  }\n\t  else if(i==3){\n\t    tmp=(7-u.sai[2])*mdata[ty][tx];\n\t    v.pe=u.pe+tmp;\n\t    v.sai[0]=u.sai[2];\n\t    v.sai[1]=u.sai[1];\n\t    v.sai[2]=7-u.sai[0];\n\t    if(v.pe<cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]){\n\t      cost[ty][tx][v.sai[0]-1][v.sai[1]-1][v.sai[2]-1]=v.pe;\n\t      v.x=tx;\n\t      v.y=ty;\n\t      Q.push(v);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  int ans=INF;\n  for(int i=0;i<6;i++){\n    for(int j=0;j<6;j++){\n      for(int k=0;k<6;k++){\n\tif(ans>cost[gy][gx][i][j][k]) ans=cost[gy][gx][i][j][k];\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\nenum FACE { TOP, BOTTOM, NORTH, SOUTH, WEST, EAST };\n\nclass dice {\nprivate:\n\tint num[6];\n\npublic:\n\tinline void roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[NORTH] = 5;\n\t\tnum[SOUTH] = 2;\n\t\tnum[EAST] = 3;\n\t\tnum[WEST] = 4;\n\t}\n\n\tdice(const dice& d) {\n\t\tnum[TOP] = d[TOP];\n\t\tnum[BOTTOM] = d[BOTTOM];\n\t\tnum[NORTH] = d[NORTH];\n\t\tnum[SOUTH] = d[SOUTH];\n\t\tnum[EAST] = d[EAST];\n\t\tnum[WEST] = d[WEST];\n\t}\n\n\tconst int& operator[] (FACE f) const { return num[f]; }\n};\n\nvoid north(dice& d) { d.roll(TOP, SOUTH, BOTTOM, NORTH); }\nvoid east(dice& d) { d.roll(TOP, WEST, BOTTOM, EAST); }\nvoid west(dice& d) { d.roll(TOP, EAST, BOTTOM, WEST); }\nvoid south(dice& d) { d.roll(TOP, NORTH, BOTTOM, SOUTH); }\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int INF = 0xfffffff;\nint h, w;\nint gx, gy;\nint field[MAX_SIZE][MAX_SIZE];\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nvoid (*func[4])(dice& d) = { east, south, west, north};\n\nbool visited[MAX_SIZE][MAX_SIZE][6];\n\nbool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\nint dfs(int x, int y, dice d) {\n\tif(x == gx && y == gy) return 0;\n\tif(visited[y][x][d[TOP] - 1]) return INF;\n\tvisited[y][x][d[TOP] - 1] = true;\n\n\tint res = INF;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i];\n\t\tconst int ny = y + dy[i];\n\t\tif(out(nx, ny)) continue;\n\n\t\tdice next_d(d);\n\t\tfunc[i](next_d);\n\t\tchmin(res, dfs(nx, ny, next_d) + next_d[BOTTOM] * field[ny][nx]);\n\t}\n\n\tvisited[y][x][d[TOP] - 1] = false;\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tmemset(visited, false, sizeof(visited));\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\n\t\tcout << dfs(sx, sy, dice()) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * File:   main.cpp\n * Author: Prowindy\n *\n * Created on 2011å¹´8æ24æ¥, ä¸å2:27\n */\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string.h>\n#include <queue>\nusing namespace std;\nint dp[16][16][8][8][8];\n\nint main() {\n    for (int h, w; scanf(\"%d%d\", &h, &w) && h;) {\n        int table[16][16];\n        int x, y;\n         for (y = 0; y < h; y++)\n        for (x = 0; x < w; x++)\n                scanf(\"%d\", &table[x][y]);\n\n        int startX, startY, goalX, goalY;\n        cin >> startY >> startX >> goalY >> goalX;\n        vector<int> node;\n        priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > q;\n        {\n\n            node.push_back(0);\n            node.push_back(startX);\n            node.push_back(startY);\n            node.push_back(1);\n            node.push_back(2);\n            node.push_back(3);\n            q.push(node);\n        }\n\n        memset(dp, 100, sizeof (dp));\n\n        int oo = dp[0][0][0][0][0];\n        dp[startX][startY][1][2][3] = 0;\n\n        while (!q.empty()) {\n            const vector<int> node = q.top();\n            q.pop();\n            const int cost = node[0];\n            const int x = node[1];\n            const int y = node[2];\n            const int up = node[3];\n            const int south = node[4];\n            const int east = node[5];\n\n            if (dp[x][y][up][south][east] != cost) {\n                continue;\n            }\n\n            // æ±è¥¿åå\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx, ny, nup, nsouth, neast, ncost;\n\n                switch (dir) {\n                    case 0:\n                        //æ±\n                        if (x + 1 == w) {\n                            continue;\n                        }\n                        nx = x + 1;\n                        ny = y;\n                        nup = 7 - east;\n                        nsouth = south;\n                        neast = up;\n                        break;\n                    case 1:\n                        //è¥¿\n                        if (x == 0) {\n                            continue;\n                        }\n                        nx = x - 1;\n                        ny = y;\n                        nup = east;\n                        nsouth = south;\n                        neast = 7 - up;\n                        break;\n                    case 2:\n                        //å\n                        if (y + 1 == h) {\n                            continue;\n                        }\n                        nx = x;\n                        ny = y + 1;\n                        nup = 7 - south;\n                        nsouth = up;\n                        neast = east;\n                        break;\n                    case 3:\n                        //å\n                        if (y == 0) {\n                            continue;\n                        }\n                        nx = x;\n                        ny = y - 1;\n                        nup = south;\n                        nsouth = 7 - up;\n                        neast = east;\n                        break;\n                }\n\n                ncost = cost + table[nx][ny] * (7 - nup);\n\n                if (dp[nx][ny][nup][nsouth][neast] <= ncost) {\n                    continue;\n                }\n                dp[nx][ny][nup][nsouth][neast] = ncost;\n\n                vector<int> next;\n                next.push_back(ncost);\n                next.push_back(nx);\n                next.push_back(ny);\n                next.push_back(nup);\n                next.push_back(nsouth);\n                next.push_back(neast);\n\n                q.push(next);\n            }\n        }\n\n        int best = oo;\n        for (int i = 1; i <= 6; ++i) {\n            for (int j = 1; j <= 6; ++j) {\n                for (int k = 1; k <= 6; ++k) {\n                    best = min(best, dp[goalX][goalY][i][j][k]);\n                }\n            }\n        }\n        cout << best << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef pair<int , int> P;\ntypedef pair<P,P> P2;\n\nint h,w;\nint g[30][30];\nint d[30][30][25];\n\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r[4][6] = { {1,5,2,3,0,4},\n\t\t{3,1,0,5,4,2},\n\t\t{4,0,2,3,5,1},\n\t\t{2,1,5,0,4,3} };\n\nvector<int> trans(int n){\n  vector<int> res;\n  while(n>0){\n    res.push_back(n%6);\n    n/=6;\n  }\n  while(res.size()<6)res.push_back(0);\n  return res;\n}\n\nint rot(int n,int dir){\n  int tmp[6];\n  vector<int> die = trans(n);\n  for(int i=0;i<6;i++)tmp[i] = die[r[dir][i]];\n\n  int res = 0, k = 1;\n  for(int i=0;i<6;i++){\n    res += tmp[i] * k;\n    k *= 6;\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<25;k++)d[i][j][k] = 10000000;\n      }\n    }\n\n    int sy,sx,gy,gx;\n    cin >> sy >> sx >> gy >> gx;\n    \n    priority_queue<P2> q;\n    map<int,int> m1,m2;\n    m1[44790] = 1;\n    m2[1] = 44790;\n    q.push(P2(P(0,1),P(sy,sx)));\n    d[sy][sx][1] = 0;\n    int cnt = 2;\n\n    while(!q.empty()){\n      P2 p = q.top();q.pop();\n      int s = p.first.first , num = p.first.second;\n      int y = p.second.first , x = p.second.second;\n\n      //cout << num << endl;\n\n      for(int i=0;i<4;i++){\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(ny<0 || nx<0 || h<=ny || w<=nx)continue;\n\tint nnum = rot(m2[num],i);\n\n\tvector<int> die = trans(nnum);\n\tif(!m1[nnum]){\n\t  m1[nnum] = cnt;\n\t  m2[cnt] = nnum;\n\t  cnt++;\n\t}\n\tnnum = m1[nnum];\n\n\tif(d[ny][nx][nnum] > d[y][x][num] + g[ny][nx]*(die[5]+1)){\n\t  d[ny][nx][nnum] = d[y][x][num] + g[ny][nx]*(die[5]+1);\n\t  q.push(P2(P(d[ny][nx][nnum],nnum),P(ny,nx)));\n\t}\n      }\n    }\n\n    int m = 10000000;\n    for(int i=0;i<25;i++)m = min(m,d[gy][gx][i]);\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\n#define roll_swap(x, a, b, c, d) swap(x.a, x.b), swap(x.b, x.c), swap(x.c, x.d);\nstruct Dice {\n    int top, front, right, left, back, bottom;\n    \n    Dice(int to = 1, int fr = 2, int ri = 3, int le = 4, int ba = 5, int bo = 6) \n    : top(to), front(fr), right(ri), left(le), back(ba), bottom(bo) { }\n    void roll_right() { roll_swap((*this), top, left, bottom, right); }\n    void roll_left() { roll_swap((*this), top, right, bottom, left); }\n    void roll_front() { roll_swap((*this), top, back, bottom, front); }\n    void roll_back() { roll_swap((*this), top, front, bottom, back); }\n    void roll_cw() { roll_swap((*this), back, left, front, right); }\n    void roll_ccw() { roll_swap((*this), back, right, front, left); }\n    void roll(int dir) {\n        if (dir == 0) (*this).roll_front();\n        if (dir == 1) (*this).roll_right();\n        if (dir == 2) (*this).roll_back();\n        if (dir == 3) (*this).roll_left();\n    }\n    friend bool operator < (const Dice &d1, const Dice &d2) {\n        int vd1[] = {d1.top, d1.front, d1.right, d1.left, d1.back, d1.bottom};\n        int vd2[] = {d2.top, d2.front, d2.right, d2.left, d2.back, d2.bottom};\n        return vector<int>(vd1, vd1 + 6) < vector<int>(vd2, vd2 + 6);\n    }\n    friend ostream& operator << (ostream& s, const Dice& d) { \n        return s << '<' << d.top << ',' << d.front << ',' << d.right << '>'; \n    }\n};\n\nvector<Dice> all_rotate() {\n    vector<Dice> res(24);\n    Dice d;\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 4; j++) {\n            res[i * 4 + j] = d;\n            d.roll_cw();\n        }\n        if (i & 1) d.roll_front();\n        else d.roll_right();\n    }\n    return res;    \n}\n\nconst int INF = 1<<29;\n\nint n, m;\nint fi[15][15];\nint sx, sy, tx, ty;\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n    vector<Dice> vd = all_rotate();\n    map<Dice,int> ma;\n    for (int i = 0; i < vd.size(); ++i) ma[vd[i]] = i;\n    \n//    COUT(vd);\n//    COUT(ma);\n    \n    while (cin >> n >> m) {\n        if (n == 0) break;\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) cin >> fi[i][j];\n        cin >> sx >> sy >> tx >> ty;\n        \n        int dp[15][15][31];\n        for (int i = 0; i < 15; ++i) for (int j = 0; j < 15; ++j) for (int k = 0; k < 31; ++k) dp[i][j][k] = INF;\n        dp[sx][sy][0] = 0;\n        priority_queue< pair<int,pair<pint,int> >, vector<pair<int,pair<pint,int> > >, greater<pair<int,pair<pint,int> > > > que;\n        que.push( MP(0, MP(pint(sx,sy), 0)) );\n        while (!que.empty()) {\n            //cout << que.top() << endl;\n            \n            int dist = que.top().first;\n            int x = que.top().second.first.first;\n            int y = que.top().second.first.second;\n            int id = que.top().second.second;\n            Dice d = vd[id];\n            que.pop();\n            \n            if (dist > dp[x][y][id]) continue;\n            \n            for (int i = 0; i < 4; ++i) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n                Dice nd = d;\n                nd.roll(i);\n                int nid = ma[nd];\n                \n                int add = nd.bottom * fi[nx][ny];\n                int ndist = dist + add;\n                if (chmin(dp[nx][ny][nid], ndist)) {\n                    que.push( MP(ndist, MP(pint(nx,ny),nid)) );\n                }\n            }\n        }\n        \n        int Min = INF;\n        for (int i = 0; i < 24; ++i) chmin(Min, dp[tx][ty][i]);\n        \n        cout << Min << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\n#include <algorithm>\n// max=6*9 * 10*10\nusing namespace std;\n\nclass State{\npublic:\n  short x,y ; // ÂÃÂÂ®ÂÃ£ÂÃÂ}ÂX\n  unsigned short p; // ÂyÂiÂÂÂeÂB\n  short m; // ÂÃ\n};\n\nint main(){\n  short h,w,x,y;\n  short g[10][10];\n  short sx,sy, gx,gy;\n  short dx[4] = { 0,1,0,-1 };  // ÂÃ£ÂAÂEÂAÂÂºÂAÂÂ¶\n  short dy[4] = { -1,0,1,0 };\n  short dice[7][4] = // 1,2,... ÂÂªÂÃ£ÂÃÂÂ ÂÃ©ÂÂÂÃÂÂ¡ÂÃÂÂÂÂ\n    {\n      { 0,0,0,0 },\n      { 2,4,5,3 }, { 6,4,1,3 },\n      { 2,1,5,6 }, { 2,6,5,1 },\n      { 1,4,6,3 }, { 2,3,5,4 }\n    };\n  stack<State*> q;\n  State *st, *st2;\n  unsigned int flag[10][10];\n  unsigned int min;\n\n  st = new State();\n\n  while( cin>>h>>w && ( h||w ) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++)\n\tcin >> g[i][j];\n    cin >> sy>>sx>> gy>>gx;\n\n    st->x=sx; st->y=sy; st->p=0; st->m=1;\n    q.push( st );\n\n    memset( flag,-1,sizeof(flag) );\n    min = flag[0][0];\n\n    while( q.size()>0 ){\n      st = q.top(); q.pop();\n      if( st->p>min ){\n\tst->~State();\n\tcontinue;\n      }\n      if( flag[st->y][st->x]> st->p ){\n\tflag[st->y][st->x] = st->p;\n      } else if( flag[st->y][st->x] < st->p ){\n\tst->~State();\n\tcontinue;\n      }\n\n      if( (st->x==gx) && (st->y==gy) ){ // goal\n\tif( min>st->p )\n\t  min=st->p;\n\tst->~State();\n\tcontinue;\n      }\n\n      for( int i=0;i<4;i++ ){\n\tx=st->x+dx[i]; y=st->y+dy[i];\n\tif( 0<=x && x<w && 0<=y && y<h ){\n\t  st2 = new State();\n\t  st2->x=x; st2->y=y;\n\t  st2->p= st->p + g[y][x] * (7-dice[st->m][i]);\n\t  st2->m = dice[st->m][i];\n\t  q.push( st2 );\n\t}\n      }\n    }\n\n    cout << min << endl;\n  }\n  st->~State();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 10;\nconst int INF = (1<<25);\nconst int D_MAX = 7;\n\nclass Dice{\n\npublic:\n  int top,bottom,north,south,west,east;\n\n  Dice(){}\n  Dice(int t, int b, int n, int s, int w, int e)\n    :top(t),bottom(b),north(n),south(s),west(w),east(e){}\n\n  void setDice(int t, int b, int n, int s, int w, int e){\n    top = t; bottom = b, north = n; south = s, west = w; east = e;\n  }\n\n  void rotateNorth(){setDice(south,north,top,bottom,west,east);}\n  void rotateSouth(){setDice(north,south,bottom,top,west,east);}\n  void rotateEast(){setDice(west,east,north,south,bottom,top);}\n  void rotateWest(){setDice(east,west,north,south,top,bottom);}\n  void rotateCW(){setDice(top,bottom,west,east,south,north);}\n  void rotateCCW(){setDice(top,bottom,east,west,north,south);}\n};\n\n\nstruct State{\n  int x,y,t;\n  Dice d;\n  State(){}\n  State(int a, int b, int c, Dice dd):x(a),y(b),t(c),d(dd){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint M[MAX][MAX];\nint T[MAX][MAX][D_MAX][D_MAX][D_MAX];\n// T[i][j][k][l][m] := mininum cost to M[i][k] with Dice's top is k, south is l, east = m;\nint w,h,sx,sy,gx,gy;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nstring dir = \"NESW\";\n\nbool isInside(int x, int y){return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++) cin >> M[i][j];\n  cin >> sy >> sx >> gy >> gx;\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < D_MAX; k++)\n\tfor(int l = 0; l < D_MAX; l++)\n\t  for(int m = 0; m < D_MAX; m++) T[i][j][k][l][m] = INF;\n}\n\n\nvoid solve(){\n\n  T[sy][sx][1][2][3];\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,Dice(1,6,5,2,4,3)));\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(now.t > T[now.y][now.x][now.d.top][now.d.south][now.d.east]) continue;\n\n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      if(dir[i] == 'N') nex.d.rotateNorth();\n      if(dir[i] == 'S') nex.d.rotateSouth();\n      if(dir[i] == 'E') nex.d.rotateEast();\n      if(dir[i] == 'W') nex.d.rotateWest();\n\n      if(isInside(nex.x,nex.y) && T[nex.y][nex.x][nex.d.top][nex.d.south][nex.d.east] > now.t+M[nex.y][nex.x]*nex.d.bottom){\t\n\tT[nex.y][nex.x][nex.d.top][nex.d.south][nex.d.east] = now.t+M[nex.y][nex.x]*nex.d.bottom;\n\tnex.t += M[nex.y][nex.x]*nex.d.bottom;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < D_MAX; i++)\n    for(int j = 0; j < D_MAX; j++)\n      for(int k = 0; k < D_MAX; k++) ans = min(ans,T[gy][gx][i][j][k]);\n\n  cout << ans << endl;\n  \n}\n\nint main(){\n  \n  while(cin >> h >> w && h+w){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n\n#define MAXN 11\n#define MAXD 7\n#define MAXS 50005\n\nusing namespace std;\n\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\nint w,h;\nint mat[MAXN][MAXN];\nint ssi,ssj,sti,stj;\nint f[MAXN][MAXN][MAXD][MAXD][MAXD];\nint inq[MAXN][MAXN][MAXD][MAXD][MAXD];\nstruct node{\n    int x,y;\n    int a,b,c;\n};\nqueue<node> q;\n\nvoid roll(int x,int y,int z,int d,int &nx,int &ny,int &nz){\n    if (d==0){\n        nx = 7 - y;\n        ny = x;\n        nz = z;\n    }\n    if (d==1){\n        nx = y;\n        ny = 7 - x;\n        nz = z;\n    }\n    if (d==2){\n        nx = 7 - z;\n        ny = y;\n        nz = x;\n    }\n    if (d==3){\n        nx = z;\n        ny = y;\n        nz = 7 - x;\n    }\n}\n\nvoid spfa(){\n    int sss,sst,ans,i,x,y,a,b,c,s,nx,ny,na,nb,nc,ns,cost;\n    memset(f,1,sizeof(f));\n    memset(inq,0,sizeof(inq));\n    node tmp;\n    tmp.x = ssi;\n    tmp.y = ssj;\n    tmp.a = 1;\n    tmp.b = 2;\n    tmp.c = 3;\n    f[ssi][ssj][1][2][3] = 0;\n    inq[ssi][ssj][1][2][3] = 1;\n    while (!q.empty()) q.pop();\n    q.push(tmp);\n    ans = 1234567980;\n    while (!q.empty()){\n        tmp = q.front();\n        q.pop();\n        x = tmp.x;\n        y = tmp.y;\n        a = tmp.a;\n        b = tmp.b;\n        c = tmp.c;\n        if (x==sti && y==stj){\n            ans = min(ans,f[x][y][a][b][c]);\n            continue;\n        }\n        //printf(\"%d %d %d %d %d %d\\n\",x,y,a,b,c,f[x][y][a][b][c]);\n        //printf(\"%d %d\\n\",sti,stj);\n        for (i=0;i<4;i++){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            if (nx>=0 && nx<h && ny>=0 && ny<w){\n                roll(a,b,c,i,na,nb,nc);\n                cost = mat[nx][ny] * (7 - na);\n                //printf(\"new %d %d %d %d %d\\n\",nx,ny,na,nb,nc);\n                if (f[x][y][a][b][c]+cost<f[nx][ny][na][nb][nc]){\n                    f[nx][ny][na][nb][nc] = f[x][y][a][b][c] + cost;\n                    if (inq[nx][ny][na][nb][nc]==0){\n                        tmp.x = nx;\n                        tmp.y = ny;\n                        tmp.a = na;\n                        tmp.b = nb;\n                        tmp.c = nc;\n                        q.push(tmp);\n                        inq[nx][ny][na][nb][nc] = 1;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    //freopen(\"g.in\",\"r\",stdin);\n    //freopen(\"g.out\",\"w\",stdout);\n    int i,j;\n    while (scanf(\"%d%d\",&h,&w)!=EOF && (h>0 && w>0)){\n        for (i=0;i<h;i++)\n            for (j=0;j<w;j++)\n                scanf(\"%d\",&mat[i][j]);\n        scanf(\"%d%d\",&ssi,&ssj);\n        scanf(\"%d%d\",&sti,&stj);\n        spfa();\n        //break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\n#include <algorithm>\n// max=6*9 * 10*10\nusing namespace std;\n\ntypedef struct {\n  short x,y ; // ÂÃÂÂ®ÂÃ£ÂÃÂ}ÂX\n  unsigned short p; // ÂyÂiÂÂÂeÂB\n  short m; // ÂÃ\n} State;\n\nint main(){\n  short h,w,x,y;\n  short g[10][10];\n  short sx,sy, gx,gy;\n  short dx[4] = { 0,1,0,-1 };  // ÂÃ£ÂAÂEÂAÂÂºÂAÂÂ¶\n  short dy[4] = { -1,0,1,0 };\n  short dice[7][4] = // 1,2,... ÂÂªÂÃ£ÂÃÂÂ ÂÃ©ÂÂÂÃÂÂ¡ÂÃÂÂÂÂ\n    {\n      { 0,0,0,0 },\n      { 2,4,5,3 }, { 6,4,1,3 },\n      { 2,1,5,6 }, { 2,6,5,1 },\n      { 1,4,6,3 }, { 2,3,5,4 }\n    };\n  stack<State> q;\n  State st, st2;\n  unsigned int flag[10][10];\n  unsigned int min;\n\n  while( cin>>h>>w && ( h||w ) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++)\n\tcin >> g[i][j];\n    cin >> sy>>sx>> gy>>gx;\n\n    st.x=sx; st.y=sy; st.p=0; st.m=1;\n    q.push( st );\n\n    memset( flag,-1,sizeof(flag) );\n    min = flag[0][0];\n\n    while( q.size()>0 ){\n      st = q.top(); q.pop();\n      /*\n      if( st.p>min )\n\tcontinue;\n      */\n      if( flag[st.y][st.x]> st.p ){\n\tflag[st.y][st.x] = st.p;\n      } else if( flag[st.y][st.x] < st.p ){\n\tcontinue;\n      }\n\n      if( (st.x==gx) && (st.y==gy) ){ // goal\n\tif( min>st.p )\n\t  min=st.p;\n\tcontinue;\n      }\n\n      for( int i=0;i<4;i++ ){\n\tx=st.x+dx[i]; y=st.y+dy[i];\n\tif( 0<=x && x<w && 0<=y && y<h ){\n\t  st2.x=x; st2.y=y;\n\t  st2.p= st.p + g[y][x] * (7-dice[st.m][i]);\n\t  st2.m = dice[st.m][i];\n\t  q.push( st2 );\n\t}\n      }\n    }\n    cout << min << endl;\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n\n#define N 16\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define DIRMAX 4\n\nusing namespace std;\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst int infty = (1LL<<31)-1;\n\nstruct Dice{\n  int D[6];\n  Dice(){D[5]=1;D[1]=2;D[2]=3;decide();}\n  void decide(){D[0]=7-D[5];D[3]=7-D[1];D[4]=7-D[2];}\n  void roll(int dir){\n    switch(dir){\n    case NORTH:D[5]=D[1];D[1]=D[0];break;\n    case EAST: D[2]=D[5];D[5]=D[4];break;\n    case SOUTH:D[1]=D[5];D[5]=D[3];break;\n    case WEST: D[5]=D[2];D[2]=D[0];break;\n    }\n    decide();\n  }\n};\n\nstruct State{\n  Dice c;\n  int i,j;\n  int cost;\n  bool operator>(const State &t)const{\n    return cost > t.cost; \n  }\n};\n\ninline bool isinside(int i, int j, int h, int w){\n  return 0<=i&&i<h&&0<=j&&j<w;\n}\n\nint dijkstra(int h, int w, int M[][N],\n\t     int si, int sj, int gi, int gj){\n  State init;\n  int A[N][N];\n  bool vis[N][N];\n  priority_queue<State,vector<State>,greater<State> > qs;\n  init.cost=0;\n  init.i=si;\n  init.j=sj;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      vis[i][j] = false;\n      A[i][j] = infty;\n    }\n  }\n  \n  qs.push( init );\n  while(!qs.empty()){\n    State now = qs.top();\n    qs.pop();\n\n    //cout << now.i << ' ' << now.j << ' ' << now.cost << endl;\n    if( vis[now.i][now.j] ) continue;\n    vis[now.i][now.j] = true;\n\n    for(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n      State next = now;\n      next.i = now.i + di[k];\n      next.j = now.j + dj[k];\n      next.c.roll( k );\n      if( !isinside(next.i, next.j, h, w ) ) continue;\n      next.cost += next.c.D[0] * M[next.i][next.j];\n      if( next.cost < A[next.i][next.j] ){\n\tA[next.i][next.j] = next.cost;\n\tif( !vis[next.i][next.j] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  return A[gi][gj];\n}\n\nint main()\n{\n  while(true){\n    int h,w;\n    int M[N][N];\n    cin >> h >> w;\n    if( h == 0 && w == 0 ) break;\n    \n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    int si,sj,gi,gj;cin >> si >> sj >> gi >> gj;\n    cout << dijkstra(h,w,M,si,sj,gi,gj) << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * File:   main.cpp\n * Author: Prowindy\n *\n * Created on 2011å¹´8æ24æ¥, ä¸å2:27\n */\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\nusing namespace std;\nint dp[16][16][8][8][8];\n\nint main() {\n    for (int h, w; scanf(\"%d%d\", &h, &w) && h;) {\n        int table[16][16];\n        int x, y;\n         for (y = 0; y < h; y++)\n        for (x = 0; x < w; x++)\n                scanf(\"%d\", &table[x][y]);\n\n        int startX, startY, goalX, goalY;\n        cin >> startY >> startX >> goalY >> goalX;\n        vector<int> node;\n        priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > q;\n        {\n\n            node.push_back(0);\n            node.push_back(startX);\n            node.push_back(startY);\n            node.push_back(1);\n            node.push_back(2);\n            node.push_back(3);\n            q.push(node);\n        }\n\n        memset(dp, 100, sizeof (dp));\n\n        int oo = dp[0][0][0][0][0];\n        dp[startX][startY][1][2][3] = 0;\n\n        while (!q.empty()) {\n            const vector<int> node = q.top();\n            q.pop();\n            const int cost = node[0];\n            const int x = node[1];\n            const int y = node[2];\n            const int up = node[3];\n            const int south = node[4];\n            const int east = node[5];\n\n            if (dp[x][y][up][south][east] != cost) {\n                continue;\n            }\n\n            // æ±è¥¿åå\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx, ny, nup, nsouth, neast, ncost;\n\n                switch (dir) {\n                    case 0:\n                        //æ±\n                        if (x + 1 == w) {\n                            continue;\n                        }\n                        nx = x + 1;\n                        ny = y;\n                        nup = 7 - east;\n                        nsouth = south;\n                        neast = up;\n                        break;\n                    case 1:\n                        //è¥¿\n                        if (x == 0) {\n                            continue;\n                        }\n                        nx = x - 1;\n                        ny = y;\n                        nup = east;\n                        nsouth = south;\n                        neast = 7 - up;\n                        break;\n                    case 2:\n                        //å\n                        if (y + 1 == h) {\n                            continue;\n                        }\n                        nx = x;\n                        ny = y + 1;\n                        nup = 7 - south;\n                        nsouth = up;\n                        neast = east;\n                        break;\n                    case 3:\n                        //å\n                        if (y == 0) {\n                            continue;\n                        }\n                        nx = x;\n                        ny = y - 1;\n                        nup = south;\n                        nsouth = 7 - up;\n                        neast = east;\n                        break;\n                }\n\n                ncost = cost + table[nx][ny] * (7 - nup);\n\n                if (dp[nx][ny][nup][nsouth][neast] <= ncost) {\n                    continue;\n                }\n                dp[nx][ny][nup][nsouth][neast] = ncost;\n\n                vector<int> next;\n                next.push_back(ncost);\n                next.push_back(nx);\n                next.push_back(ny);\n                next.push_back(nup);\n                next.push_back(nsouth);\n                next.push_back(neast);\n\n                q.push(next);\n            }\n        }\n\n        int best = oo;\n        for (int i = 1; i <= 6; ++i) {\n            for (int j = 1; j <= 6; ++j) {\n                for (int k = 1; k <= 6; ++k) {\n                    best = min(best, dp[goalX][goalY][i][j][k]);\n                }\n            }\n        }\n        cout << best << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<cassert>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define MAX 10\n#define INFTY (1 << 21)\nmap<string, int> M;\n\nclass Cube{\npublic:\n  string f;\n  Cube(){ f = \"123456\"; }\n  void roll_left(){ roll(0, 2, 5, 3);}\n  void roll_back(){ roll(0, 1, 5, 4);}\n  void roll_right(){ rep(i, 3) roll_left(); }\n  void roll_front(){ rep(i, 3) roll_back(); }\n  void roll(int i, int j, int k, int l){\n    char t = f[i]; f[i] = f[j]; f[j] = f[k]; f[k] = f[l]; f[l] = t;\n  }\n};\n\nclass State{\npublic:\n  int i, j, cost;\n  Cube c;\n  State(int i=0, int j=0, Cube c=Cube(), int cost=0): i(i), j(j), c(c), cost(cost){}\n  bool operator < ( const State &s) const{ return cost > s.cost; }\n};\n\nint dijkstra(int H, int W, int G[MAX][MAX], int si, int sj, int gi, int gj){\n  Cube s = Cube();\n  bool visited[MAX][MAX][24];\n  int d[MAX][MAX][24];\n  priority_queue<State> PQ;\n\n  rep(i, H) rep(j, W) rep(k, 24){\n    visited[i][j][k] = false;\n    d[i][j][k] = INFTY;\n  }\n\n  PQ.push(State(si, sj, s, 0));\n  d[si][sj][M[s.f]] = 0;\n\n  State u, v;\n  while(!PQ.empty()){\n    u = PQ.top(); PQ.pop();\n    if ( u.i == gi && u.j == gj ) return u.cost;\n    Cube cube = u.c;\n    int c = M[cube.f];\n    if ( visited[u.i][u.j][c] ) continue;\n    visited[u.i][u.j][c] = true;\n\n    int ni, nj;\n    rep(r, 4){\n      v = u;\n      ni = u.i;\n      nj = u.j;\n      if ( r == 0 && u.j < W-1 ) { v.c.roll_right(); nj++; }\n      if ( r == 1 && u.i >= 1 ) { v.c.roll_back(); ni--; }\n      if ( r == 2 && u.j >= 1 ) { v.c.roll_left(); nj--; }\n      if ( r == 3 && u.i < H-1) { v.c.roll_front(); ni++; }\n      v.i = ni;\n      v.j = nj;\n      int cost = G[ni][nj] * (v.c.f[5]-'0') + u.cost;\n      int nc = M[v.c.f];\n      if ( d[ni][nj][nc] > cost ){\n\td[ni][nj][nc] = cost;\n\tv.i = ni;\n\tv.j = nj;\n\tv.cost = cost;\n\tPQ.push(v);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  string t[24] = {\"123456\",\"135246\",\"154326\",\"142536\",\"326154\",\"365214\",\"351624\",\"312564\",\"246135\",\"263415\",\"231645\",\"214365\",\"645231\",\"653421\",\"632541\",\"624351\",\"415263\",\"456123\",\"462513\",\"421653\",\"513462\",\"536142\",\"564312\",\"541632\"};\n  rep(i, 24) M[t[i]] = i;\n}\n\nmain(){\n  init();\n  int H, W, G[MAX][MAX], si, sj, gi, gj;\n  while(1){\n    cin >> H >> W;\n    if ( H == 0 && W == 0 ) break;\n\n    rep(i, H) rep(j, W) cin >> G[i][j];\n    rep(i, H) rep(j, W) assert( 0 <= G[i][j] && G[i][j] <= 9 );\n    cin >> si >> sj >> gi >> gj;\n \n    cout << dijkstra(H, W, G, si, sj, gi, gj) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n\nstruct Dice{\n  int tmp,d[6];\n  Dice(){\n    for(int i = 0 ; i < 6 ; i++){\n      d[i] = i;\n    }\n  }\n  void rollN(){\n    tmp = d[0];\n    d[1] = d[5];\n    d[5] = d[4];\n    d[4] = tmp;\n  }\n  void rollE(){\n    tmp = d[0];\n    d[0] = d[3];\n    d[3] = d[5];\n    d[5] = d[2];\n    d[2] = tmp;\n  }\n  void rollS(){\n    tmp = d[0];\n    d[0] = d[4];\n    d[4] = d[5];\n    d[5] = d[1];\n    d[1] = tmp;\n  }\n  void rollW(){\n    tmp = d[0];\n    d[0] = d[2];\n    d[2] = d[5];\n    d[5] = d[3];\n    d[3] = tmp;\n  }\n};\n\nstruct State{\n  int cost,x,y;\n  Dice d;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(cin >> H >> W, H){\n    int field[MAX_H][MAX_W];\n    int sx,sy,gx,gy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    int cost[MAX_H][MAX_W][6][6][6];\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        for(int k = 0 ; k < 6 ; k++){\n          for(int l = 0 ; l < 6 ; l++){\n            for(int m = 0 ; m < 6 ; m++){\n              cost[i][j][k][l][m] = 1e9;\n            }\n          }\n        }\n      }\n    }\n    Dice die;\n    cost[sy][sx][die.d[0]][die.d[1]][die.d[2]] = 0;\n    priority_queue<State> Q;\n    Q.push((State){0,sx,sy,die});\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    while(!Q.empty()){\n      State s = Q.top(); Q.pop();\n      int x = s.x, y = s.y;\n      int ncost = cost[y][x][s.d.d[0]][s.d.d[1]][s.d.d[2]];\n      if(x == gx && y == gy){\n        cout << s.cost << endl;\n        break;\n      }\n      if(ncost < s.cost){\n        continue;\n      }\n      for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        Dice d = s.d;\n        if(0 > nx || nx >= W || 0 > ny || ny >= H){\n          continue;\n        }\n        switch(i){\n        case 0:\n          d.rollW();\n          break;\n        case 1:\n          d.rollN();\n          break;\n        case 2:\n          d.rollE();\n          break;\n        case 3:\n          d.rollS();\n          break;\n        }\n        int p = (d.d[5]+1)*field[ny][nx];\n        if(ncost + p < cost[ny][nx][d.d[0]][d.d[1]][d.d[2]]){\n          cost[ny][nx][d.d[0]][d.d[1]][d.d[2]] = ncost + p;\n          Q.push((State){cost[ny][nx][d.d[0]][d.d[1]][d.d[2]],nx,ny,d});\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct state{\n  int y,x,a,b,c,d,e,f,cost;\n  bool operator < (const state&p)const{\n    return cost > p.cost;\n  }\n};\n\nint h,w;\nint t[10][10];\n\nint d[10][10][6][6][6][6][6][6];\n\nvoid solve(){\n  int ay,ax,by,bx;\n  cin>>ay>>ax>>by>>bx;\n  //memset(d,sizeof(d),0);  \n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<6;k++)\n    for(int l=0;l<6;l++)\n      for(int m=0;m<6;m++)\n        for(int n=0;n<6;n++)\n          for(int o=0;o<6;o++)\n        for(int p=0;p<6;p++)\n          d[i][j][k][l][m][n][o][p]=0;\n  d[ay][ax][0][1][2][3][4][5]=1;\n  priority_queue< state > Q;\n  Q.push((state){ay,ax,0,1,2,3,4,5,1});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.y][s.x][s.a][s.b][s.c][s.d][s.e][s.f])continue;\n    if(s.y==by&&s.x==bx){cout<<s.cost-1<<endl;return;}\n    if(s.y>0){\n      int* k=&d[s.y-1][s.x][s.b][s.f][s.c][s.d][s.a][s.e];\n      int ncost=s.cost+(s.e+1)*t[s.y-1][s.x];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y-1,s.x,s.b,s.f,s.c,s.d,s.a,s.e,ncost});\n      }\n    }\n    if(s.y+1<h){\n      int* k=&d[s.y+1][s.x][s.e][s.a][s.c][s.d][s.f][s.b];\n      int ncost=s.cost+(s.b+1)*t[s.y+1][s.x];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y+1,s.x,s.e,s.a,s.c,s.d,s.f,s.b,ncost});\n      }\n    }\n    if(s.x>0){\n      int* k=&d[s.y][s.x-1][s.c][s.b][s.f][s.a][s.e][s.d];\n      int ncost=s.cost+(s.d+1)*t[s.y][s.x-1];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y,s.x-1,s.c,s.b,s.f,s.a,s.e,s.d,ncost});\n      }  \n    }\n    if(s.x+1<w){\n      int* k=&d[s.y][s.x+1][s.d][s.b][s.a][s.f][s.e][s.c];\n      int ncost=s.cost+(s.c+1)*t[s.y][s.x+1];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y,s.x+1,s.d,s.b,s.a,s.f,s.e,s.c,ncost});\n      }  \n    }\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0&&w==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>t[i][j];\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nclass Dice{\npublic:\n\tDice(){\n\t\tnumber = new int[6];\n\t\twork = new int[6];\n\t};\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'E':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tint getBottom(){\n\t\treturn number[5];\n\t}\n\n\tint getEast(){\n\t\treturn number[2];\n\t}\n\n\tvoid setNumber(int n0,int n1,int n2,int n3,int n4,int n5){\n\t\tnumber[0] = n0;\n\t\tnumber[1] = n1;\n\t\tnumber[2] = n2;\n\t\tnumber[3] = n3;\n\t\tnumber[4] = n4;\n\t\tnumber[5] = n5;\n\t}\n\n\tvoid init(){\n\t\tsetNumber(1,5,3,4,2,6);\n\t}\n\n\tvoid set(Dice arg){\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tnumber[i] = arg.number[i];\n\t\t}\n\t}\n\n\tint* number;\n\tint* work;\n};\n\nint H,W,diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nstruct Info{\n\tInfo(){\n\t\trow = col = penalty = 0;\n\t\tdice.init();\n\t}\n\n\tvoid set(int arg_row,int arg_col,int arg_penalty){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tpenalty = arg_penalty;\n\t}\n\tint row,col,penalty;\n\tDice dice;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint dp[10][10][7][7];\n\tint map[10][10],start_row,start_col,goal_row,goal_col,minimum,next_row,next_col;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&map[i][k]);\n\t\t}\n\n\t\tscanf(\"%d %d\",&start_row,&start_col);\n\t\tscanf(\"%d %d\",&goal_row,&goal_col);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tfor(int p = 1; p <= 6; p++){\n\t\t\t\t\tfor(int q = 1; q <= 6; q++)dp[i][k][p][q] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tInfo first;\n\t\tfirst.set(start_row,start_col,0);\n\t\tdp[start_row][start_col][first.dice.getBottom()][first.dice.getEast()] = 0;\n\t\tqueue<Info> Q;\n\n\t\tQ.push(first);\n\n\t\tminimum = BIG_NUM;\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row == goal_row && Q.front().col == goal_col){\n\t\t\t\tminimum = min(minimum,Q.front().penalty);\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\t\t\tInfo next;\n\t\t\t\t\t\tnext.set(next_row,next_col,Q.front().penalty);\n\t\t\t\t\t\tnext.dice.set(Q.front().dice);\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tnext.dice.roll('N');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tnext.dice.roll('W');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tnext.dice.roll('E');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tnext.dice.roll('S');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(dp[next_row][next_col][next.dice.getBottom()][next.dice.getEast()] > dp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]+\n\t\t\t\t\t\t\t\tmap[next_row][next_col]*next.dice.getBottom()){\n\t\t\t\t\t\t\tdp[next_row][next_col][next.dice.getBottom()][next.dice.getEast()] =\n\t\t\t\t\t\t\t\t\tdp[Q.front().row][Q.front().col][Q.front().dice.getBottom()][Q.front().dice.getEast()]+map[next_row][next_col]*next.dice.getBottom();\n\t\t\t\t\t\t\tnext.penalty += map[next_row][next_col]*next.dice.getBottom();\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nstruct N{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tbool operator<(const N &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint dp[10][10][50];\n\nint main()\n{\n\tint h,w;\n\twhile(cin>>h>>w,h)\n\t{\n\t\tint g[h][w],sy,sx,gy,gx;\n\t\trep(i,h)rep(j,w)cin>>g[i][j];\n\t\t\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\trep(i,10)rep(j,10)fill_n(dp[i][j],50,inf);\n\t\tdp[sy][sx][1*7+2]=0;\n\t\t\n\t\tN cur; cur.y=sy,cur.x=sx,cur.c=0;\n\t\tcur.t=1,cur.b=6,cur.e=3,cur.w=4,cur.s=2,cur.n=5;\n\t\t\n\t\tpriority_queue<N> Q; Q.push(cur);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tcur=Q.top(); Q.pop();\n\t\t\t\n\t\t\tif(cur.y==gy&&cur.x==gx)\n\t\t\t{\n\t\t\t\tcout<<cur.c<<endl; break;\n\t\t\t}\n\t\t\t\n\t\t\trep(d,4)\n\t\t\t{\n\t\t\t\tint ny=cur.y+dy[d],nx=cur.x+dx[d];\n\t\t\t\tif(ny<0||nx<0||ny>=h||nx>=w)continue;\n\t\t\t\t\n\t\t\t\tN nxt=cur; nxt.roll(d);\n\t\t\t\tnxt.c+=g[ny][nx]*nxt.b;\n\t\t\t\tif(dp[ny][nx][nxt.t*7+nxt.s]<=nxt.c)continue;\n\t\t\t\tdp[ny][nx][nxt.t*7+nxt.s]=nxt.c;\n\t\t\t\tQ.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int dice[6][4] = {{2,3,5,4},\n                        {1,4,6,3},\n                        {1,2,6,5},\n                        {1,5,6,2},\n                        {1,3,6,4},\n                        {2,4,5,3}};\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, -1, 0, 1};\n\nint roll(int curr, int dir)\n{\n    int next = dice[curr/4][(dir+curr)%4] - 1;\n    for(int i=0; ; ++i){\n        if(dice[next][(2+dir+i)%4] - 1 == curr/4){\n            next *= 4;\n            next += i;\n            return next;\n        }\n    }\n}\n\nclass Data\n{\npublic:\n    int y, x, d;\n    Data (int y0, int x0, int d0){\n        y = y0;\n        x = x0;\n        d = d0;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n            }\n        }\n        int sy, sx, gy, gx;\n        cin >> sy >> sx >> gy >> gx;\n\n        vector<vector<vector<int> > > dp(h, vector<vector<int> >(w, vector<int>(24, INT_MAX)));\n        dp[sy][sx][0] = 0;\n        multimap<int, Data> m;\n        m.insert(make_pair(0, Data(sy, sx, 0)));\n        while(!m.empty()){\n            int cost = m.begin()->first;\n            Data d = m.begin()->second;\n            m.erase(m.begin());\n            if(cost > dp[d.y][d.x][d.d])\n                continue;\n            if(d.y == gy && d.x == gx){\n                cout << cost << endl;\n                break;\n            }\n            for(int i=0; i<4; ++i){\n                Data d1 = Data(d.y+dy[i], d.x+dx[i], roll(d.d, i));\n                if(d1.y < 0 || d1.y >= h || d1.x < 0 || d1.x >= w)\n                    continue;\n                int cost1 = cost + (6 - d1.d/4) * grid[d1.y][d1.x];\n                if(cost1 < dp[d1.y][d1.x][d1.d]){\n                    dp[d1.y][d1.x][d1.d] = cost1;\n                    m.insert(make_pair(cost1, d1));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n\nstruct Dice{\n  int tmp,d[6];\n  Dice(){\n    for(int i = 0 ; i < 6 ; i++){\n      d[i] = i+1;\n    }\n  }\n  void rollN(){\n    tmp = d[0];\n    d[1] = d[5];\n    d[5] = d[4];\n    d[4] = tmp;\n  }\n  void rollE(){\n    tmp = d[0];\n    d[0] = d[3];\n    d[3] = d[5];\n    d[5] = d[2];\n    d[2] = tmp;\n  }\n  void rollS(){\n    tmp = d[0];\n    d[0] = d[4];\n    d[4] = d[5];\n    d[5] = d[1];\n    d[1] = tmp;\n  }\n  void rollW(){\n    tmp = d[0];\n    d[0] = d[2];\n    d[2] = d[5];\n    d[5] = d[3];\n    d[3] = tmp;\n  }\n};\n\nstruct State{\n  int cost,x,y;\n  Dice d;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int H,W;\n  while(cin >> H >> W, H){\n    int field[MAX_H][MAX_W];\n    int sx,sy,gx,gy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n      }\n    }\n    cin >> sy >> sx >> gy >> gx;\n    Dice die;\n    int cost[MAX_H][MAX_W][6][6][6];\n    for(int i = 0 ; i < MAX_H ; i++){\n      for(int j = 0 ; j < MAX_W ; j++){\n        for(int k = 0 ; k < 6 ; k++){\n          for(int l = 0 ; l < 6 ; l++){\n            for(int m = 0 ; m < 6 ; m++){\n              cost[i][j][k][l][m] = 1e9;\n            }\n          }\n        }\n      }\n    }\n    cost[sy][sx][die.d[0]][die.d[1]][die.d[2]] = 0;\n    priority_queue<State> Q;\n    Q.push((State){0,sx,sy,die});\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    while(!Q.empty()){\n      State s = Q.top(); Q.pop();\n      int x = s.x, y = s.y;\n      int ncost = cost[y][x][s.d.d[0]][s.d.d[1]][s.d.d[2]];\n      if(ncost < s.cost){\n        continue;\n      }\n      if(x == gx && y == gy){\n        cout << s.cost << endl;\n        break;\n      }\n      for(int i = 0 ; i < 4 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        Dice d = s.d;\n        if(0 > nx || nx >= W || 0 > ny || ny >= H){\n          continue;\n        }\n        switch(i){\n        case 0:\n          d.rollW();\n          break;\n        case 1:\n          d.rollN();\n          break;\n        case 2:\n          d.rollE();\n          break;\n        case 3:\n          d.rollS();\n          break;\n        }\n        int p = d.d[5]*field[ny][nx];\n        if(ncost + p < cost[ny][nx][d.d[0]][d.d[1]][d.d[2]]){\n          cost[ny][nx][d.d[0]][d.d[1]][d.d[2]] = ncost + p;\n          Q.push((State){cost[ny][nx][d.d[0]][d.d[1]][d.d[2]],nx,ny,d});\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,imap[20][20];\nP s,g;         \nconst int dx[4] = {0,1,0,-1};//0:下、1:右、2:上、3:左\nconst int dy[4] = {1,0,-1,0};\n//bool used[20][20];\nint dpused[40][40];\nint candidate;\nint dice[6] = {1,2,4,5,3,6};//0:top,1:front,2:left,3:back,4:right,5:bottom\n\nint Reverse(int p){\n  if(p == 0)return 2;\n  if(p == 1)return 3;\n  if(p == 2)return 0;\n  if(p == 3)return 1;\n}\n\nvoid RollMe(int face){ //enomoto\n  if(face == 0){\n    int h = dice[3];\n    dice[3] = dice[5];\n    dice[5] = dice[1];\n    dice[1] = dice[0];\n    dice[0] = h;\n  }\n  else if(face == 1){\n    int h = dice[0];\n    dice[0] = dice[2];\n    dice[2] = dice[5];\n    dice[5] = dice[4];\n    dice[4] = h;\n  }\n  else if(face == 2){\n    int h = dice[0];\n    dice[0] = dice[1];\n    dice[1] = dice[5];\n    dice[5] = dice[3];\n    dice[3] = h;\n  }\n  else if(face == 3){\n    int h = dice[0];\n    dice[0] = dice[4];\n    dice[4] = dice[5];\n    dice[5] = dice[2];\n    dice[2] = h;\n  }\n}\n\nvoid rec(P p,int sam){\n  //cout << \"Pos = \" << p.F << \" \" << p.S << \",sam = \" << sam << endl;\n  if(p == g){\n    candidate = min(candidate,sam);\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = p.F+dx[i],ny = p.S+dy[i];\n    RollMe(i);\n    if(/*!used[ny][nx] &&*/ 0<=nx && nx<w && 0<=ny && ny <h && dpused[ny][nx] > sam+imap[ny][nx]*dice[5]){\n      //used[ny][nx] = true;\n      //RollMe(i);\n\tdpused[ny][nx] = sam+imap[ny][nx]*dice[5];\n      rec(P(nx,ny),dice[5]*imap[ny][nx]+sam);\n      //RollMe(Reverse(i));\n      //used[ny][nx] = false;\n    }\n      RollMe(Reverse(i));\n  }\n}\n\nconst int INF = 1<<30;\nint main(){\n  while(cin >> h >> w && h && w){\n    candidate = INF;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> imap[i][j];\n    }\n    cin >> s.S >> s.F;\n    cin >> g.S >> g.F;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){//used[i][j] = false;\n\tdpused[i][j] = INF;\n      }\n    //used[s.S][s.F] = true;\n    dpused[s.S][s.F] = 0;\n    rec(s,0);\n    assert(candidate != INF);\n    cout << candidate << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <map>\n#include <queue>\n#include <vector>\n\n#define X first\n#define Y second\n#define P first\n#define S second\n#define mp(x, y) make_pair(x, y)\n\nusing namespace std;\ntypedef ostringstream OSS;\ntypedef pair<int, int> PII;\ntypedef pair<PII, string> PIIS;\n\nstruct die_t {\n\tint top, front, right, left, back, bottom;\n\tdie_t ( int t, int f, int r, int l, int bk, int b )\n\t\t: top(t), front(f), right(r), left(l), back(bk), bottom(b) { }\n\tdie_t ( string dice ) {\n\t\ttop = dice[0] - '0'; front = dice[1] - '0'; right = dice[2] - '0';\n\t\tleft = dice[3] - '0'; back = dice[4] - '0'; bottom = dice[5] - '0';\n\t}\n\tvoid rotate_swap ( int &a, int &b, int &c, int &d ) {\n\t\tswap(a, b); swap(b, c); swap(c, d);\n\t}\n\tvoid rotate_right ( void ) { rotate_swap(top,left,bottom,right); }\n\tvoid rotate_left ( void ) { rotate_swap(top,right,bottom,left); }\n\tvoid rotate_front ( void ) { rotate_swap(top,back,bottom,front); }\n\tvoid rotate_back ( void ) { rotate_swap(top,front,bottom,back); }\n\tvoid rotate_cw ( void ) { rotate_swap(back,left,front,right); }\n\tvoid rotate_cc ( void ) { rotate_swap(back,right,front,left); }\n\tbool rotate_set ( int n, int t, int f, int r, int l, int bk, int b ) {\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tif (n == equal_num(t, f, r, l, bk, b)) { return true; }\n\t\t\t\trotate_cw();\n\t\t\t}\n\t\t\t(i&1 ? rotate_front() : rotate_right());\n\t\t}\n\t\treturn false;\n\t}\n\tint equal_num ( int t, int f, int r, int l, int bk, int b ) {\n\t\treturn (top==t) + (front==f) + (right==r) + (left==l) + (back==bk) + (bottom==b);\n\t}\n\tstring toString ( void ) {\n\t\tOSS os; os << top << front << right << left << back << bottom;\n\t\treturn os.str();\n\t}\n};\n\nconst int INF = 1 << 29;\nconst int MAX_WH = 10;\n\nint main ( void )\n{\n\tvector<string> vs;\n\tdie_t dd(\"123456\");\n\tfor (int i = 0; i < 6; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tvs.push_back(dd.toString());\n\t\t\tdd.rotate_cw();\n\t\t}\n\t\tif (i&1) { dd.rotate_front(); }\n\t\telse { dd.rotate_right(); }\n\t}\n\n\tint h, w, mat[MAX_WH][MAX_WH];\n\tmap<string, int> M[MAX_WH][MAX_WH];\n\n\twhile (cin >> h >> w, h | w) {\n\t\tfor (int y = 0; y < h; ++y) {\n\t\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t\tcin >> mat[y][x];\n\t\t\t\tM[y][x].clear();\n\t\t\t\tfor (int i = 0, I = vs.size(); i < I; ++i) {\n\t\t\t\t\tM[y][x].insert(mp(vs[i], INF));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPII s, g;\n\t\tcin >> s.Y >> s.X;\n\t\tcin >> g.Y >> g.X;\n\n\t\tdie_t dice(\"123456\");\n\t\tqueue<PIIS> Q;\n\t\tM[s.Y][s.X][\"123456\"] = 0;\n\t\tQ.push(mp(mp(s.X, s.Y), dice.toString()));\n\n\t\twhile (!Q.empty()) {\n\t\t\tPIIS piis = Q.front(); Q.pop();\n\t\t\tPII p = piis.P;\n\t\t\tstring s = piis.S, s1, s2, s3, s4;\n\t\t\tdie_t d1(s), d2(s), d3(s), d4(s);\n\t\t\td1.rotate_right(); s1 = d1.toString();\n\t\t\td2.rotate_left(); s2 = d2.toString();\n\t\t\td3.rotate_front(); s3 = d3.toString();\n\t\t\td4.rotate_back(); s4 = d4.toString();\n\n\t\t\tif (p.X + 1 < w\n\t\t\t&& M[p.Y][p.X+1][s1] > M[p.Y][p.X][s] + mat[p.Y][p.X+1] * d1.bottom) {\n\t\t\t\tM[p.Y][p.X+1][s1] = M[p.Y][p.X][s] + mat[p.Y][p.X+1] * d1.bottom;\n\t\t\t\tQ.push(mp(mp(p.X+1, p.Y), d1.toString()));\n\t\t\t}\n\t\t\tif (p.X - 1 >=0\n\t\t\t&& M[p.Y][p.X-1][s2] > M[p.Y][p.X][s] + mat[p.Y][p.X-1] * d2.bottom) {\n\t\t\t\tM[p.Y][p.X-1][s2] = M[p.Y][p.X][s] + mat[p.Y][p.X-1] * d2.bottom;\n\t\t\t\tQ.push(mp(mp(p.X-1, p.Y), d2.toString()));\n\t\t\t}\n\t\t\tif (p.Y + 1 < h\n\t\t\t&& M[p.Y+1][p.X][s3] > M[p.Y][p.X][s] + mat[p.Y+1][p.X] * d3.bottom) {\n\t\t\t\tM[p.Y+1][p.X][s3] = M[p.Y][p.X][s] + mat[p.Y+1][p.X] * d3.bottom;\n\t\t\t\tQ.push(mp(mp(p.X, p.Y+1), d3.toString()));\n\t\t\t}\n\t\t\tif (p.Y - 1 >=0\n\t\t\t&& M[p.Y-1][p.X][s4] > M[p.Y][p.X][s] + mat[p.Y-1][p.X] * d4.bottom) {\n\t\t\t\tM[p.Y-1][p.X][s4] = M[p.Y][p.X][s] + mat[p.Y-1][p.X] * d4.bottom;\n\t\t\t\tQ.push(mp(mp(p.X, p.Y-1), d4.toString()));\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0, I = vs.size(); i < I; ++i) {\n\t\t\tans = min(ans, M[g.Y][g.X][vs[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <map>\n#include <queue>\n#include <vector>\n\n#define X first\n#define Y second\n#define P first\n#define S second\n#define C first\n#define D second\n#define mp(x, y) make_pair(x, y)\n\nusing namespace std;\ntypedef ostringstream OSS;\ntypedef pair<int, int> PII;\ntypedef pair<PII, string> PIIS;\ntypedef pair<int, PIIS> PIIIS;\n\nstruct die_t {\n\tint top, front, right, left, back, bottom;\n\tdie_t ( int t, int f, int r, int l, int bk, int b )\n\t\t: top(t), front(f), right(r), left(l), back(bk), bottom(b) { }\n\tdie_t ( string dice ) {\n\t\ttop = dice[0] - '0'; front = dice[1] - '0'; right = dice[2] - '0';\n\t\tleft = dice[3] - '0'; back = dice[4] - '0'; bottom = dice[5] - '0';\n\t}\n\tvoid rotate_swap ( int &a, int &b, int &c, int &d ) {\n\t\tswap(a, b); swap(b, c); swap(c, d);\n\t}\n\tvoid rotate_right ( void ) { rotate_swap(top,left,bottom,right); }\n\tvoid rotate_left ( void ) { rotate_swap(top,right,bottom,left); }\n\tvoid rotate_front ( void ) { rotate_swap(top,back,bottom,front); }\n\tvoid rotate_back ( void ) { rotate_swap(top,front,bottom,back); }\n\tvoid rotate_cw ( void ) { rotate_swap(back,left,front,right); }\n\tvoid rotate_cc ( void ) { rotate_swap(back,right,front,left); }\n\tbool rotate_set ( int n, int t, int f, int r, int l, int bk, int b ) {\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tif (n == equal_num(t, f, r, l, bk, b)) { return true; }\n\t\t\t\trotate_cw();\n\t\t\t}\n\t\t\t(i&1 ? rotate_front() : rotate_right());\n\t\t}\n\t\treturn false;\n\t}\n\tint equal_num ( int t, int f, int r, int l, int bk, int b ) {\n\t\treturn (top==t) + (front==f) + (right==r) + (left==l) + (back==bk) + (bottom==b);\n\t}\n\tstring toString ( void ) {\n\t\tOSS os; os << top << front << right << left << back << bottom;\n\t\treturn os.str();\n\t}\n};\n\nconst int INF = 1 << 29;\nconst int MAX_WH = 10;\n\nint main ( void )\n{\n\tvector<string> vs;\n\tdie_t dd(\"123456\");\n\tfor (int i = 0; i < 6; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tvs.push_back(dd.toString());\n\t\t\tdd.rotate_cw();\n\t\t}\n\t\tif (i&1) { dd.rotate_front(); }\n\t\telse { dd.rotate_right(); }\n\t}\n\n\tint h, w, mat[MAX_WH][MAX_WH];\n\n\twhile (cin >> h >> w, h | w) {\n\t\tmap<string, int> M[MAX_WH][MAX_WH];\n\t\tfor (int y = 0; y < h; ++y) {\n\t\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t\tcin >> mat[y][x];\n\t\t\t\tfor (int i = 0, I = vs.size(); i < I; ++i) {\n\t\t\t\t\tM[y][x].insert(mp(vs[i], INF));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPII s, g;\n\t\tcin >> s.Y >> s.X;\n\t\tcin >> g.Y >> g.X;\n\n\t\tdie_t dice(\"123456\");\n\t\tpriority_queue<PIIIS, vector<PIIIS>, greater<PIIIS> > Q;\n\t\tM[s.Y][s.X][\"123456\"] = 0;\n\t\tQ.push(mp(0, mp(mp(s.X, s.Y), dice.toString())));\n\n\t\twhile (!Q.empty()) {\n\t\t\tPIIIS piiis = Q.top(); Q.pop();\n\t\t\tPIIS piis = piiis.D;\n\t\t\tPII p = piis.P;\n\n\t\t\tif (M[p.Y][p.X][piis.S] < piiis.C) { continue; }\n\n\t\t\tstring s = piis.S, s1, s2, s3, s4;\n\t\t\tdie_t d1(s), d2(s), d3(s), d4(s);\n\t\t\td1.rotate_right(); s1 = d1.toString();\n\t\t\td2.rotate_left(); s2 = d2.toString();\n\t\t\td3.rotate_front(); s3 = d3.toString();\n\t\t\td4.rotate_back(); s4 = d4.toString();\n\n\t\t\tif (p.X + 1 < w\n\t\t\t&& M[p.Y][p.X+1][s1] > M[p.Y][p.X][s] + mat[p.Y][p.X+1] * d1.bottom) {\n\t\t\t\tM[p.Y][p.X+1][s1] = M[p.Y][p.X][s] + mat[p.Y][p.X+1] * d1.bottom;\n\t\t\t\tQ.push(mp(M[p.Y][p.X+1][s1], mp(mp(p.X+1, p.Y), s1)));\n\t\t\t}\n\t\t\tif (p.X - 1 >=0\n\t\t\t&& M[p.Y][p.X-1][s2] > M[p.Y][p.X][s] + mat[p.Y][p.X-1] * d2.bottom) {\n\t\t\t\tM[p.Y][p.X-1][s2] = M[p.Y][p.X][s] + mat[p.Y][p.X-1] * d2.bottom;\n\t\t\t\tQ.push(mp(M[p.Y][p.X-1][s2], mp(mp(p.X-1, p.Y), s2)));\n\t\t\t}\n\t\t\tif (p.Y + 1 < h\n\t\t\t&& M[p.Y+1][p.X][s3] > M[p.Y][p.X][s] + mat[p.Y+1][p.X] * d3.bottom) {\n\t\t\t\tM[p.Y+1][p.X][s3] = M[p.Y][p.X][s] + mat[p.Y+1][p.X] * d3.bottom;\n\t\t\t\tQ.push(mp(M[p.Y+1][p.X][s3], mp(mp(p.X, p.Y+1), s3)));\n\t\t\t}\n\t\t\tif (p.Y - 1 >=0\n\t\t\t&& M[p.Y-1][p.X][s4] > M[p.Y][p.X][s] + mat[p.Y-1][p.X] * d4.bottom) {\n\t\t\t\tM[p.Y-1][p.X][s4] = M[p.Y][p.X][s] + mat[p.Y-1][p.X] * d4.bottom;\n\t\t\t\tQ.push(mp(M[p.Y-1][p.X][s4], mp(mp(p.X, p.Y-1), s4)));\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0, I = vs.size(); i < I; ++i) {\n\t\t\tans = min(ans, M[g.Y][g.X][vs[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tDice(int top,int bottom,int north,int south,int east,int west,int sx,int sy,int cost){\n\t\tt=top,b=bottom,n=north,s=south,e=east,w=west;\n\t\tx=sx,y=sy,c=cost;\n\t}\n\tbool operator<(const Dice &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint w,h;\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nint main(){\n\tint p[10][10],memo[10][10][100];\n\twhile(cin>>h>>w && h!=0){\n\t\tpriority_queue<Dice> que;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>p[y][x];\n\t\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\n\t\tint gx,gy,sx,sy;\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\tque.push(Dice(1,6,5,2,3,4,sx,sy,0));\n\t\twhile(!que.empty()){\n\t\t\tDice now=que.top();\n\t\t\tque.pop();\n//\t\t\tcout<<now.x<<\" \"<<now.y<<\" \"<<now.b<<\" \"<<now.c<<endl;\n\t\t\tif(now.x==gx && now.y==gy) {cout<<now.c<<endl; break;}\n\t\t\tif(memo[now.y][now.x][now.e*7+now.b]>=0 && memo[now.y][now.x][now.e*7+now.b]<=now.c) continue;\n\n\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tDice copy=now;\n\t\t\t\tcopy.roll(r);\n\t\t\t\tif(in(copy.x,copy.y)){\n\t\t\t\t\tcopy.c+=copy.b*p[copy.y][copy.x];\n\t\t\t\t\tque.push(copy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct state{\n  int y,x,a,b,c,d,e,f,cost;\n  bool operator < (const state&p)const{\n    return cost > p.cost;\n  }\n};\n\nint h,w;\nint t[10][10];\n\nint d[10][10][6][6][6][6][6][6];\n\nvoid solve(){\n  int ay,ax,by,bx;\n  cin>>ay>>ax>>by>>bx;\n  //  memset(d,sizeof(d),0);\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<6;k++)\n\tfor(int l=0;l<6;l++)\n\t  for(int m=0;m<6;m++)\n\t    for(int n=0;n<6;n++)\n\t      for(int o=0;o<6;o++)\n\t\tfor(int p=0;p<6;p++)\n\t\t  d[i][j][k][l][m][n][o][p]=0;\n  \n  d[ay][ax][1][2][3][4][5][6]=1;\n  priority_queue< state > Q;\n  Q.push((state){ay,ax,1,2,3,4,5,6,1});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.y][s.x][s.a][s.b][s.c][s.d][s.e][s.f])continue;\n    if(s.y==by&&s.x==bx){cout<<s.cost-1<<endl;return;}\n    if(s.y>0){\n      int* k=&d[s.y-1][s.x][s.b][s.f][s.c][s.d][s.a][s.e];\n      int ncost=s.cost+s.e*t[s.y-1][s.x];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y-1,s.x,s.b,s.f,s.c,s.d,s.a,s.e,ncost});\n      }\n    }\n    if(s.y+1<h){\n      int* k=&d[s.y+1][s.x][s.e][s.a][s.c][s.d][s.f][s.b];\n      int ncost=s.cost+s.b*t[s.y+1][s.x];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y+1,s.x,s.e,s.a,s.c,s.d,s.f,s.b,ncost});\n      }\n    }\n    if(s.x>0){\n      int* k=&d[s.y][s.x-1][s.c][s.b][s.f][s.a][s.e][s.d];\n      int ncost=s.cost+s.d*t[s.y][s.x-1];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y,s.x-1,s.c,s.b,s.f,s.a,s.e,s.d,ncost});\n      }  \n    }\n    if(s.x+1<w){\n      int* k=&d[s.y][s.x+1][s.d][s.b][s.a][s.f][s.e][s.c];\n      int ncost=s.cost+s.c*t[s.y][s.x+1];\n      if( *k==0 || ncost < *k){\n\t*k=ncost;\n\tQ.push((state){s.y,s.x+1,s.d,s.b,s.a,s.f,s.e,s.c,ncost});\n      }  \n    }\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0&&w==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>t[i][j];\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstd::istream &operator>>(std::istream &is, P &p){\n\treturn is >> p.first >> p.second;\n}\n\nstruct Dice{\nprivate:\n\tstatic const int _roll[4][6], _turn[2][6];\npublic:\n\tvector<int> value;\n\t// 1-6 : top, near, right, left, far, bottom \n\n\tDice(){\n\t\tvalue.resize(6);\n\t\tfor (int i = 0; i < 6; ++i) value[i] = i+1;\n\t}\n\tDice(initializer_list<int> il){\n\t\tvalue.resize(6, -1);\n\t\tint cnt = 0;\n\t\tfor (auto &e : il){\n\t\t\tvalue[cnt++] = e;\n\t\t\tif (cnt >= 6) break;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) if (value[i] < 0) value[i] = 5 - value[5 - i];\n\t}\n\n\tvoid roll(int dir){ // N, E, W, S\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_roll[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tvoid turn(int dir){ // L, R\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_turn[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tint &operator[](int i){\n\t\treturn value[i];\n\t}\n};\n\nconst int Dice::_roll[4][6] = {\n\t{ 1, 5, 2, 3, 0, 4 }, // North\n\t{ 3, 1, 0, 5, 4, 2 }, // East\n\t{ 2, 1, 5, 0, 4, 3 }, // West\n\t{ 4, 0, 2, 3, 5, 1 }, // South\n};\n\nconst int Dice::_turn[2][6] = {\n\t{ 0, 3, 1, 4, 2, 5 }, // Left\n\t{ 0, 2, 4, 1, 3, 5 }, // Right\n};\n\nint board[10][10];\n\nstruct state{\n\tP first;\n\tDice second;\n\tbool operator<(const state &r)const{\n\t\treturn first < r.first;\n\t}\n};\n\nint dx[] = {0, 1, -1, 0};\nint dy[] = {-1, 0, 0, 1};\n\nint main(){\n\tint h, w;\n\twhile (cin >> h >> w, h | w){\n\t\trep(i, h) rep(j, w) cin >> board[i][j];\n\t\tP s, g;\n\t\tcin >> s >> g;\n\n\t\tmap<state, int> m;\n\n\t\tpriority_queue<pair<int, state>, vector<pair<int, state>>, greater<pair<int, state>>> q;\n\t\tq.push(make_pair(0, state{ s, Dice() }));\n\t\tint ans = -1;\n\t\twhile (!q.empty()){\n\t\t\tint dist = q.top().first;\n\t\t\tstate s = q.top().second;\n\t\t\tP &pos = s.first;\n\t\t\tDice &d = s.second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif (m[s] < dist) continue;\n\t\t\tif (s.first == g){\n\t\t\t\tans = dist;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint nx = pos.second + dx[i], ny = pos.first + dy[i];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\tstate nxt = s;\n\t\t\t\tnxt.second.roll(i);\n\t\t\t\tnxt.first = make_pair(ny, nx);\n\t\t\t\tif (m.count(nxt) && m[nxt] <= dist + nxt.second[5] * board[ny][nx]) continue;\n\t\t\t\tm[nxt] = dist + nxt.second[5] * board[ny][nx];\n\t\t\t\tq.push(make_pair(dist + nxt.second[5] * board[ny][nx], nxt));\n\t\t\t}\n\t\t}\n\t\tcout << \"+++\";\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { char r, c, d[3]; int s; } Q;\nQ q[QMAX+2]; int top;\n\nchar map[11][11];\nint mk[11][11][6][6];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, s, r2, c2, s2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tq[0].r = sr, q[0].c = sc, q[0].s = 0, q[0].d[0] = 1, q[0].d[1] = 2, q[0].d[2] = 3;\n\t\tans = 0x7fffffff; top = 1;\n\t\twhile (top > 0) {\n\t\t\tr = q[--top].r, c = q[top].c, s = q[top].s;\n\t\t\tmemcpy(dice+1, q[top].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i];\n\t\t\tif (r == gr && c == gc) {\n\t\t\t\tif (s < ans) ans = s; continue;\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\ts2 = s + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]] == 0 || mk[r2][c2][dice2[1]][dice2[2]] > s2) {\n\t\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]] = s2;\n\t\t\t\t\tq[top].r = r2, q[top].c = c2, q[top].s = s2;\n\t\t\t\t\tmemcpy(q[top].d, dice2+1, 3); top++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { char r, c, d[3]; int s; } Q;\nQ q[100000]; int top, end;\n\nchar map[11][11];\nint mk[11][11][6][6];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, s, r2, c2, s2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tq[0].r = sr, q[0].c = sc, q[0].s = 0, q[0].d[0] = 1, q[0].d[1] = 2, q[0].d[2] = 3;\n\t\tans = 0x7fffffff; top = 0, end = 1;\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, s = q[top].s;\n\t\t\tmemcpy(dice+1, q[top].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i]; top++;\n\t\t\tif (r == gr && c == gc) {\n\t\t\t\tif (s < ans) ans = s; continue;\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\ts2 = s + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]] != 0 && mk[r2][c2][dice2[1]][dice2[2]] < s2) continue;\n\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]] = s2;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].s = s2;\n\t\t\t\tmemcpy(q[end].d, dice2+1, 3); end++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 3000000\ntypedef struct { char r, c, d[3]; int s; } Q;\nQ q[QMAX+2]; int top, end;\n\nchar map[11][11];\nchar mk[11][11][6][6][540];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, s, r2, c2, s2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tq[0].r = sr, q[0].c = sc, q[0].s = 0, q[0].d[0] = 1, q[0].d[1] = 2, q[0].d[2] = 3;\n\t\tans = 0x7fffffff; top = 0, end = 1;\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, s = q[top].s;\n\t\t\tmemcpy(dice+1, q[top].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i]; top++;\n\t\t\tif (r == gr && c == gc) {\n\t\t\t\tif (s < ans) ans = s; continue;\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\ts2 = s + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]][s2]) continue;\n\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]][s2] = 1;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].s = s2;\n\t\t\t\tmemcpy(q[end].d, dice2+1, 3); end++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "h,w,g[10][10],sx,sy,gx,gy;P[11][10][7][7],*a;Q[999][999],N[1000];E(p,x,y,u,s,e){p+=g[x][y]*(7-u);a=P[x][y][u]+s;p<*a?*a=p,Q[p][N[p]++]=x+y*10|u<<8|s<<16|e<<24:0;}main(x,y,p,t,u,s,e){for(;scanf(\"%d%d\",&h,&w)*h;printf(\"%d\\n\",p)){for(y=0;y<h;y++)for(x=0;x<w;x++)scanf(\"%d\",g[x]+y);scanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);memset(P,1,2e4);memset(N,0,4e3);for(*Q[P[sx][sy][*N=1][2]=p=0]=0x3020100+sx+sy*10;;){if(N[p]){t=Q[p][--N[p]];x=t&255,y=x/10,x%=10;if(x==gx&&y==gy)break;u=t>>8&255;s=t>>16&255;e=t>>24&255;x>0&&E(p,x-1,y,e,s,7-u);x<w-1&&E(p,x+1,y,7-e,s,u);y>0&&E(p,x,y-1,s,7-u,e);y<h-1&&E(p,x,y+1,7-s,u,e);}else p++;}}}"
  },
  {
    "language": "C",
    "code": "h,w,g[10][10],sx,sy,gx,gy;\nP[10][10][7][7];//P[x][y][u][s]:=(Êu(x,y),ãÊu,ìÊs)ÌÅ¬yieB\nQ[999][999];//Q[p]:=yieBpÌóÔL[AQ[p][i]:=x+y*10|u<<8|s<<16|e<<24 (e:Ê)\nN[999];//N[p]:=Q[p]ÌTCY\nE(p,x,y,u,s,e){\n\tp+=g[x][y]*(7-u);\n\tQ[p][N[p]++]=x+y*10|u<<8|s<<16|e<<24;\n}\nmain(){\n\tint x,y,p,t,u,s,e;\n\tfor(;scanf(\"%d%d\",&h,&w)*h;){\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&g[x][y]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\t\tmemset(P,-1,sizeof(P));\n\t\tmemset(N,0,sizeof(N));\n\t\tP[sx][sy][1][2]=0;\n\t\tQ[0][0]=sx+sy*10|1<<8|2<<16|3<<24;\n\t\tN[0]=1;\n\t\tp=0;\n\t\tfor(;;){\n\t\t\tif(N[p]){\n\t\t\t\tt=Q[p][--N[p]];\n\t\t\t\tx=t&255,y=x/10,x%=10;\n\t\t\t\tif(x==gx&&y==gy)\n\t\t\t\t\tbreak;\n\t\t\t\tu=(t>>8)&255;\n\t\t\t\ts=(t>>16)&255;\n\t\t\t\te=(t>>24)&255;\n\t\t\t\tif(x>0)\n\t\t\t\t\tE(p,x-1,y,e,s,7-u);\n\t\t\t\tif(x<w-1)\n\t\t\t\t\tE(p,x+1,y,7-e,s,u);\n\t\t\t\tif(y>0)\n\t\t\t\t\tE(p,x,y-1,s,7-u,e);\n\t\t\t\tif(y<h-1)\n\t\t\t\t\tE(p,x,y+1,7-s,u,e);\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",p);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { char r, c, d[3]; int s; } Q;\nQ q[QMAX+2]; int top, end;\n\nchar map[11][11];\nchar mk[11][11][6][6][540];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, s, r2, c2, s2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tq[0].r = sr, q[0].c = sc, q[0].s = 0, q[0].d[0] = 1, q[0].d[1] = 2, q[0].d[2] = 3;\n\t\tans = 0x7fffffff; top = 0, end = 1;\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, s = q[top].s;\n\t\t\tmemcpy(dice+1, q[top].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i]; top++;\n\t\t\tif (r == gr && c == gc) {\n\t\t\t\tif (s < ans) ans = s; continue;\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\ts2 = s + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]][s2]) continue;\n\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]][s2] = 1;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].s = s2;\n\t\t\t\tmemcpy(q[end].d, dice2+1, 3); end++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QSIZE 5000000\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { char r, c, d[3]; int t; } QUE;\nQUE que[QSIZE+2];\nint qsize;\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq(void)\n{\n//\tif (qsize == 0) return 0;\n//\t*a = que[0].a, *b = que[0].b, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(void)\n{\n\tint i, min;\n\n\ti = qsize++;\n//\tque[i].t = t, que[i].a = a, que[i].b = b, que[i].c = c;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\nchar map[11][11];\nint mk[11][11][6][6];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, t, r2, c2, t2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tqsize = 0;\n\t\tque[0].r = sr, que[0].c = sc, que[0].t = 0, que[0].d[0] = 1, que[0].d[1] = 2, que[0].d[2] = 3;\n\t\tans = 0x7fffffff; enq();\n\t\twhile (qsize > 0) {\n\t\t\tr = que[0].r, c = que[0].c, t = que[0].t;\n\t\t\tmemcpy(dice+1, que[0].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i]; deq();\n\t\t\tif (r == gr && c == gc) { ans = t; break; }\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\tt2 = t + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]] == 0 || mk[r2][c2][dice2[1]][dice2[2]] > t2) {\n\t\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]] = t2;\n\t\t\t\t\tque[qsize].r = r2, que[qsize].c = c2, que[qsize].t = t2;\n\t\t\t\t\tmemcpy(que[qsize].d, dice2+1, 3); enq();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "h,w,g[10][10],sx,sy,gx,gy;\nP[10][10][7][7];//P[x][y][u][s]:=(Êu(x,y),ãÊu,ìÊs)ÌÅ¬yieB\nQ[999][999];//Q[p]:=yieBpÌóÔL[AQ[p][i]:=x+y*10|u<<8|s<<16|e<<24 (e:Ê)\nN[999];//N[p]:=Q[p]ÌTCY\nE(p,x,y,u,s,e){\n\tp+=g[x][y]*(7-u);\n\tif(P[x][y][u][s]==-1||p<P[x][y][u][s]){\n\t\tP[x][y][u][s]=p;\n\t\tQ[p][N[p]++]=x+y*10|u<<8|s<<16|e<<24;\n\t}\n}\nmain(){\n\tint x,y,p,t,u,s,e;\n\tfor(;scanf(\"%d%d\",&h,&w)*h;){\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&g[x][y]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\t\tmemset(P,-1,sizeof(P));\n\t\tmemset(N,0,sizeof(N));\n\t\tP[sx][sy][1][2]=0;\n\t\tQ[0][0]=sx+sy*10|1<<8|2<<16|3<<24;\n\t\tN[0]=1;\n\t\tp=0;\n\t\tfor(;;){\n\t\t\tif(N[p]){\n\t\t\t\tt=Q[p][--N[p]];\n\t\t\t\tx=t&255,y=x/10,x%=10;\n\t\t\t\tif(x==gx&&y==gy)\n\t\t\t\t\tbreak;\n\t\t\t\tu=(t>>8)&255;\n\t\t\t\ts=(t>>16)&255;\n\t\t\t\te=(t>>24)&255;\n\t\t\t\tif(x>0)\n\t\t\t\t\tE(p,x-1,y,e,s,7-u);\n\t\t\t\tif(x<w-1)\n\t\t\t\t\tE(p,x+1,y,7-e,s,u);\n\t\t\t\tif(y>0)\n\t\t\t\t\tE(p,x,y-1,s,7-u,e);\n\t\t\t\tif(y<h-1)\n\t\t\t\t\tE(p,x,y+1,7-s,u,e);\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",p);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QSIZE 110000\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { char r, c, d[3]; int t; } QUE;\nQUE que[QSIZE+2];\nint qsize;\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq(void)\n{\n//\tif (qsize == 0) return 0;\n//\t*a = que[0].a, *b = que[0].b, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(void)\n{\n\tint i, min;\n\n\ti = qsize++;\n//\tque[i].t = t, que[i].a = a, que[i].b = b, que[i].c = c;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\nchar map[11][11];\nint mk[11][11][6][6];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, t, r2, c2, t2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tqsize = 0;\n\t\tque[0].r = sr, que[0].c = sc, que[0].t = 0, que[0].d[0] = 1, que[0].d[1] = 2, que[0].d[2] = 3;\n\t\tans = 0x7fffffff; enq();\n\t\twhile (qsize > 0) {\n\t\t\tr = que[0].r, c = que[0].c, t = que[0].t;\n\t\t\tmemcpy(dice+1, que[0].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i]; deq();\n\t\t\tif (r == gr && c == gc) { ans = t; break; }\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\tt2 = t + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]] == 0 || mk[r2][c2][dice2[1]][dice2[2]] > t2) {\n\t\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]] = t2;\n\t\t\t\t\tque[qsize].r = r2, que[qsize].c = c2, que[qsize].t = t2;\n\t\t\t\t\tmemcpy(que[qsize].d, dice2+1, 3); enq();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "h,w,g[10][10],sx,sy,gx,gy;\nP[10][10][7][7];//P[x][y][u][s]:=(Êu(x,y),ãÊu,ìÊs)ÌÅ¬yieB\nQ[999][99];//Q[p]:=yieBpÌóÔL[AQ[p][i]:=x+y*10|u<<8|s<<16|e<<24 (e:Ê)\nN[999];//N[p]:=Q[p]ÌTCY\nE(p,x,y,u,s,e){\n\tp+=g[x][y]*(7-u);\n\tif(P[x][y][u][s]==-1||p<P[x][y][u][s]){\n\t\tP[x][y][u][s]=p;\n\t\tQ[p][N[p]++]=x+y*10|u<<8|s<<16|e<<24;\n\t}\n}\nmain(){\n\tint x,y,p,t,u,s,e;\n\tfor(;scanf(\"%d%d\",&h,&w)*h;){\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&g[x][y]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&sy,&sx,&gy,&gx);\n\t\tmemset(P,-1,sizeof(P));\n\t\tmemset(N,0,sizeof(N));\n\t\tP[sx][sy][1][2]=0;\n\t\tQ[0][0]=sx+sy*10|1<<8|2<<16|3<<24;\n\t\tN[0]=1;\n\t\tp=0;\n\t\tfor(;;){\n\t\t\tif(N[p]){\n\t\t\t\tt=Q[p][--N[p]];\n\t\t\t\tx=t&255,y=x/10,x%=10;\n\t\t\t\tif(x==gx&&y==gy)\n\t\t\t\t\tbreak;\n\t\t\t\tu=(t>>8)&255;\n\t\t\t\ts=(t>>16)&255;\n\t\t\t\te=(t>>24)&255;\n\t\t\t\tif(x>0)\n\t\t\t\t\tE(p,x-1,y,e,s,7-u);\n\t\t\t\tif(x<w-1)\n\t\t\t\t\tE(p,x+1,y,7-e,s,u);\n\t\t\t\tif(y>0)\n\t\t\t\t\tE(p,x,y-1,s,7-u,e);\n\t\t\t\tif(y<h-1)\n\t\t\t\t\tE(p,x,y+1,7-s,u,e);\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\",p);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 200000\ntypedef struct { char r, c, d[3]; int s; } Q;\nQ q[QMAX+2]; int top, end;\n\nchar map[11][11];\nint mk[11][11][6][6];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, s, r2, c2, s2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tq[0].r = sr, q[0].c = sc, q[0].s = 0, q[0].d[0] = 1, q[0].d[1] = 2, q[0].d[2] = 3;\n\t\tans = 0x7fffffff; top = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, s = q[top].s;\n\t\t\tmemcpy(dice+1, q[top].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i];\n\t\t\tif (++top == QMAX) top = 0;\n\t\t\tif (r == gr && c == gc) {\n\t\t\t\tif (s < ans) ans = s; continue;\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\ts2 = s + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]] != 0 && mk[r2][c2][dice2[1]][dice2[2]] < s2) continue;\n\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]] = s2;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].s = s2;\n\t\t\t\tmemcpy(q[end].d, dice2+1, 3); if (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n\nstruct Dice{\n\tint t,b,n,s,e,w;\n\tint y,x;\n\t\n\tint c;\n\tDice(int top,int bottom,int north,int south,int east,int west,int sx,int sy,int cost){\n\t\tt=top,b=bottom,n=north,s=south,e=east,w=west;\n\t\tx=sx,y=sy,c=cost;\n\t}\n\tbool operator<(const Dice &r)const\n\t{\n\t\treturn c>r.c;\n\t}\n\tvoid roll(int d)\n\t{\n\t\tint tmp;\n\t\ty+=dy[d],x+=dx[d];\n\t\t\n\t\tif(d==0)\n\t\t{\n\t\t\ttmp=t; t=s; s=b; b=n; n=tmp;\n\t\t}else if(d==1)\n\t\t{\n\t\t\ttmp=t; t=e; e=b; b=w; w=tmp;\n\t\t}else if(d==2)\n\t\t{\n\t\t\ttmp=t; t=n; n=b; b=s; s=tmp;\n\t\t}else\n\t\t{\n\t\t\ttmp=t; t=w; w=b; b=e; e=tmp;\n\t\t}\n\t}\n};\n\nint w,h;\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nint main(){\n\tint p[10][10];\n\twhile(cin>>h>>w && h!=0){\n\t\tpriority_queue<Dice> que;\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t\tcin>>p[y][x];\n\n\t\tint gx,gy,sx,sy;\n\t\tcin>>sy>>sx>>gy>>gx;\n\t\tque.push(Dice(1,6,5,2,3,4,sx,sy,0));\n\t\twhile(!que.empty()){\n\t\t\tDice now=que.top();\n\t\t\tque.pop();\n//\t\t\tcout<<now.x<<\" \"<<now.y<<\" \"<<now.b<<\" \"<<now.c<<endl;\n\t\t\tif(now.x==gx && now.y==gy) {cout<<now.c<<endl; break;}\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tDice copy=now;\n\t\t\t\tcopy.roll(r);\n\t\t\t\tif(in(copy.x,copy.y)){\n\t\t\t\t\tcopy.c+=copy.b*p[copy.y][copy.x];\n\t\t\t\t\tque.push(copy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1057: Rolling Dice\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QSIZE 2000000\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { char r, c, d[3]; int t; } QUE;\nQUE que[QSIZE+2];\nint qsize;\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tQUE t = que[i]; que[i] = que[min]; que[min] = t;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq(void)\n{\n//\tif (qsize == 0) return 0;\n//\t*a = que[0].a, *b = que[0].b, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(void)\n{\n\tint i, min;\n\n\ti = qsize++;\n//\tque[i].t = t, que[i].a = a, que[i].b = b, que[i].c = c;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tQUE tt = que[i]; que[i] = que[min]; que[min] = tt;\n\t\ti = min;\n\t}\n}\n\nchar map[11][11];\nint mk[11][11][6][6];\nint mv[4][2] =  {{-1,0},{0,1},{1,0},{0,-1}};\nint rot[4][3] = {{2,6,3},{4,2,1},{5,1,3},{3,2,6}};\n\nint main()\n{\n\tint h, w, sr, sc, gr, gc, i, r, c, t, r2, c2, t2, ans;\n\tchar dice[7], dice2[7];\n\n\twhile (scanf(\"%d%d\", &h, &w) && h > 0) {\n\t\tmemset(mk, -1, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &i), map[r][c]= i;\n\t\tscanf(\"%d%d%d%d\", &sr, &sc, &gr, &gc);\n\t\tqsize = 0;\n\t\tque[0].r = sr, que[0].c = sc, que[0].t = 0, que[0].d[0] = 1, que[0].d[1] = 2, que[0].d[2] = 3;\n\t\tans = 0x7fffffff; enq();\n\t\twhile (qsize > 0) {\n\t\t\tr = que[0].r, c = que[0].c, t = que[0].t;\n\t\t\tmemcpy(dice+1, que[0].d, 3); for (i = 4; i <= 6; i++) dice[i] = 7 - dice[7-i]; deq();\n\t\t\tif (r == gr && c == gc) { ans = t; break; }\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\t\tdice2[1] = dice[rot[i][0]],\tdice2[2] = dice[rot[i][1]], dice2[3] = dice[rot[i][2]];\n\t\t\t\tt2 = t + (7 - dice2[1])*map[r2][c2];\n\t\t\t\tif (mk[r2][c2][dice2[1]][dice2[2]] < 0 || mk[r2][c2][dice2[1]][dice2[2]] > t2) {\n\t\t\t\t\tmk[r2][c2][dice2[1]][dice2[2]] = t2;\n\t\t\t\t\tque[qsize].r = r2, que[qsize].c = c2, que[qsize].t = t2;\n\t\t\t\t\tmemcpy(que[qsize].d, dice2+1, 3); enq();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        while(true){\n \n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n \n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            sy = sc.nextInt();\n            sx = sc.nextInt();\n            gy = sc.nextInt();\n            gx = sc.nextInt();\n \n            System.out.println(bfs());\n        }\n    }\n \n    class Dice{\n        int[] dice = new int[6];\n        Dice(int a, int b, int c, int d, int e, int f){\n            dice[0] = a; dice[1] = b; dice[2] = c;\n            dice[3] = d; dice[4] = e; dice[5] = f;\n        }\n    }\n \n    int[][] dd = {{4,0,2,3,5,1}, {3,1,0,5,4,2}, {1,5,2,3,0,4}, {2,1,5,0,4,3}};\n \n    Dice rotate(Dice d, int idx){\n        return new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n \n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {1, 0, -1, 0};\n \n    int bfs(){\n        //x, y pena\n        Queue<int[]> q = new LinkedList<int[]>();\n        Queue<Dice> di = new LinkedList<Dice>();\n        int[][] v = new int[h][w];\n        for(int i=0; i<h; i++) Arrays.fill(v[i], Integer.MAX_VALUE);\n        q.add(new int[]{sx, sy, 0});\n \n        Dice d = new Dice(1,2,3,4,5,6);\n        di.add(d);\n        int min = Integer.MAX_VALUE;\n \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1], pena = qq[2];\n            Dice ddd = di.poll();\n \n            if(x==gx && y==gy){\n                min = Math.min(min, pena);\n                continue;\n            }\n \n            if(v[y][x]<=pena) continue;\n            v[y][x] = pena;\n \n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                Dice newDice = rotate(ddd, i);\n                q.add(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5]});\n                di.add(newDice);\n            }\n        }\n \n        if(min==Integer.MAX_VALUE) min = -1;\n        return min;\n    }\n \n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        while(true){\n \n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n \n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            sy = sc.nextInt();\n            sx = sc.nextInt();\n            gy = sc.nextInt();\n            gx = sc.nextInt();\n \n            System.out.println(bfs());\n        }\n    }\n \n    class Dice{\n        int[] dice = new int[6];\n        Dice(int a, int b, int c, int d, int e, int f){\n            dice[0] = a; dice[1] = b; dice[2] = c;\n            dice[3] = d; dice[4] = e; dice[5] = f;\n        }\n    }\n \n    int[][] dd = {{1,5,2,3,0,4}, {3,1,0,5,4,2}, {4,0,2,3,5,1}, {2,1,5,0,4,3}};\n \n    Dice rotate(Dice d, int idx){\n        return new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n \n    class P{\n        Dice d;\n        int[] num;\n        P(int[] num, Dice d){\n            this.num = num;\n            this.d = d;\n        }\n    }\n    \n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {-1, 0, 1, 0};\n    \n    int bfs(){\n        //x, y pena,direction\n        PriorityQueue<P> \n            q = new PriorityQueue<P>(10, new Comparator<P>(){\n                    public int compare(P a, P b){\n                        return a.num[2] - b.num[2];\n                    }\n                });\n        boolean[][][][] v = new boolean[h][w][6][6];\n        Dice d = new Dice(1,2,3,4,5,6);\n        q.add(new P(new int[]{sx, sy, 0}, d));\n              \n        int min = Integer.MAX_VALUE;\n              \n        while(q.size()>0){\n            P p = q.poll();\n            int[] qq = p.num;\n            int x = qq[0], y = qq[1], pena = qq[2];\n            Dice ddd = p.d;\n            //System.out.println(x+\" \"+y+\" \"+pena+\" \"+Arrays.toString(ddd.dice));\n \n            if(x==gx && y==gy) return pena;\n\n            if(v[y][x][ddd.dice[0]-1][ddd.dice[1]-1]) continue;\n            v[y][x][ddd.dice[0]-1][ddd.dice[1]-1] = true;\n \n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                Dice newDice = rotate(ddd, i);\n                q.add(new P(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5], newDice.dice[0], newDice.dice[1]}, newDice));\n            }\n        }\n\n        return min; \n    }\n \n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][] cost = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t\tArrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint startH = sc.nextInt();\n\t\t\tint startW = sc.nextInt();\n\t\t\tint destH = sc.nextInt();\n\t\t\tint destW = sc.nextInt();\n\n\t\t\tDice dice = new Dice(1, 2, 3, 5, 4, 6, startH, startW, 0);\n\t\t\tcost[startH][startW] = 0;\n\t\t\tQueue<Dice> que = new LinkedList<Dice>();\n\t\t\tque.add(dice);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tDice now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nextH = now.h + dy[j];\n\t\t\t\t\t\tint nextW = now.w + dx[j];\n\t\t\t\t\t\tif (0 <= nextH && nextH < h && 0 <= nextW && nextW < w) {\n\t\t\t\t\t\t\tDice next = new Dice(now.top, now.front, now.right,\n\t\t\t\t\t\t\t\t\tnow.back, now.left, now.reverse, nextH,\n\t\t\t\t\t\t\t\t\tnextW, now.cost);\n\t\t\t\t\t\t\tswitch (j) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tnext.roll_right();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tnext.roll_front();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tnext.roll_back();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tnext.roll_left();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnext.cost += field[next.h][next.w] * next.reverse;\n\t\t\t\t\t\t\tif (next.cost < cost[next.h][next.w]) {\n\t\t\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcost[next.h][next.w] = next.cost;\n\t\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cost[destH][destW]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Dice {\n\t\tint top;\n\t\tint front;\n\t\tint right;\n\t\tint back;\n\t\tint left;\n\t\tint reverse;\n\n\t\tint h;\n\t\tint w;\n\t\tint cost;\n\n\t\tpublic Dice(int top, int front, int right, int back, int left,\n\t\t\t\tint reverse, int h, int w, int cost) {\n\t\t\tsuper();\n\t\t\tthis.top = top;\n\t\t\tthis.front = front;\n\t\t\tthis.right = right;\n\t\t\tthis.back = back;\n\t\t\tthis.left = left;\n\t\t\tthis.reverse = reverse;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tvoid disp() {\n\t\t\tSystem.out.print(this.top + \" \" + this.front + \" \" + this.right\n\t\t\t\t\t+ \" \" + this.back + \" \" + this.left + \" \" + this.reverse);\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tvoid rotate_parallel() {\n\t\t\tint tmp = this.back;\n\t\t\tthis.back = this.right;\n\t\t\tthis.right = this.front;\n\t\t\tthis.front = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t\tvoid roll_back() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.front;\n\t\t\tthis.front = this.reverse;\n\t\t\tthis.reverse = this.back;\n\t\t\tthis.back = tmp;\n\t\t}\n\n\t\tvoid roll_front() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.back;\n\t\t\tthis.back = this.reverse;\n\t\t\tthis.reverse = this.front;\n\t\t\tthis.front = tmp;\n\t\t}\n\n\t\tvoid roll_right() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.left;\n\t\t\tthis.left = this.reverse;\n\t\t\tthis.reverse = this.right;\n\t\t\tthis.right = tmp;\n\t\t}\n\n\t\tvoid roll_left() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.right;\n\t\t\tthis.right = this.reverse;\n\t\t\tthis.reverse = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    int h,w;\n    int[][] board;\n    int sx,sy,gx,gy;\n    int[] dx = {0,1,0,-1};\n    int[] dy = {-1,0,1,0};\n    \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        \n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n            \n            board = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    board[i][j] = sc.nextInt();\n                }\n            }\n            \n            sy = sc.nextInt(); sx = sc.nextInt();\n            gy = sc.nextInt(); gx = sc.nextInt();\n            \n            System.out.println(getMin());\n        }\n    }\n    \n    int getMin(){\n        //x,y,up,south,east,penalty\n        PriorityQueue<int[]> \n            q = new PriorityQueue<int[]>(20,new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[5] - b[5];\n                    }\n                });\n        q.add(new int[]{sx,sy,1,2,3,0});\n        boolean[][] v = new boolean[h][w];\n        \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1], \n                up = qq[2], south = qq[3], east = qq[4], pena = qq[5];\n            \n            if(v[y][x]) continue;\n            v[y][x] = true;\n            \n            if(x==gx && y==gy) return pena;\n            \n            for(int i=0; i<4; i++){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(nx>=0 && nx<w && ny>=0 && ny<h){\n                    int[] dice = getDice(up,south,east,i);\n                    //System.out.println(\"dice \"+Arrays.toString(dice));\n                    q.add(new int[]{nx,ny,dice[0],dice[1],dice[2],\n                                    pena+(7-dice[0])*board[ny][nx]});\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    int[] getDice(int up, int south, int east, int direc){\n        int newUp = 0, newSouth = 0, newEast = 0;\n        if(direc==0){\n            newUp = south;\n            newEast = east;\n            newSouth = 7-up;\n        }else if(direc==1){\n            newUp = 7-east;\n            newSouth = south;\n            newEast = up;\n        }else if(direc==2){\n            newUp = 7-south;\n            newEast = east;\n            newSouth = up;\n        }else{\n            newUp = east;\n            newSouth = south;\n            newEast = 7-up;\n        }\n        \n        return new int[]{newUp,newSouth,newEast};\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] f,minf;\n\tstatic int sx,sy,gx,gy;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tH=cin.nextInt();\n\t\t\tW=cin.nextInt();\n\t\t\tif(H+W==0)break;\n\t\t\tf=new int[H][W];\n\t\t\tminf=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tf[i][j]=cin.nextInt();\n\t\t\t\t\tminf[i][j]=1<<30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsx=cin.nextInt();\n\t\t\tsy=cin.nextInt();\n\t\t\tgx=cin.nextInt();\n\t\t\tgy=cin.nextInt();\n\t\t\t\n\t\t\tPriorityQueue<Dice> q = new PriorityQueue<Dice>(200,new Comparator<Dice>(){\n\t\t\t\tpublic int compare(Dice o1, Dice o2) {\n\t\t\t\t\treturn o1.min-o2.min;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tDice ddd= new Dice(\n\t\t\t\t\tnew Integer(1),\n\t\t\t\t\tnew Integer(6),\n\t\t\t\t\tnew Integer(2),\n\t\t\t\t\tnew Integer(5),\n\t\t\t\t\tnew Integer(3),\n\t\t\t\t\tnew Integer(4)\n\t\t\t\t\t);\n\t\t\t\n\t\t\tddd.x=ddd.y=ddd.min=0;\n\t\t\tq.add(ddd);\n\t\t\tint ans=1<<30;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tDice d = q.poll();\n\t\t\t\tint x=d.x;\n\t\t\t\tint y=d.y;\n\t\t\t\tint min=d.min;\n//\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+min+\" \"+d);\n\t\t\t\tif(x==gx&&y==gy){\n\t\t\t\t\tans=Math.min(min,ans);;\n\t\t\t\t}\n\t\t\t\tif(minf[x][y]<=min)continue;\n\t\t\t\tminf[x][y]=min;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+v1[i];\n\t\t\t\t\tint yy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=H||yy<0||yy>=W)continue;\n\t\t\t\t\tDice next=roll(d,v1[i],v2[i]);\n\t\t\t\t\tInteger id=(next.id[1]);\n\t\t\t\t\t\n\t\t\t\t\tnext.min=d.min+(id*f[xx][yy]);\n\t\t\t\t\tnext.x=xx;\n\t\t\t\t\tnext.y=yy;\n\t\t\t\t\tq.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\t\n\t}\n\tstatic Dice roll(Dice d,int a,int b){\n\t\tDice re;\n\n\t\tif(a==0){\n\t\t\tif(b==1){\n\t\t\t\td.rollY(false);\n\t\t\t\tre=d.copy();\n\t\t\t\td.rollY(true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\td.rollY(true);\n\t\t\t\tre=d.copy();\n\t\t\t\td.rollY(false);\n\t\t\t}\n\t\t}\n\t\telse if(a==1){\n\t\t\td.rollX(true);\n\t\t\tre=d.copy();\n\t\t\td.rollX(false);\n\t\t}\n\t\telse{\n\t\t\td.rollX(false);\n\t\t\tre=d.copy();\n\t\t\td.rollX(true);\n\t\t}\n\t\treturn re;\n\t}\n\n\t//さいころのデータクラス\n\t//equalsは向きも含めて同値であり,isEquivalentは回転することで同じ賽であることを調べる\n\t//Verify: AOJ0502, AOJ1057\n\tstatic class Dice {\n\t\tpublic int x,y,min;\n\t\tpublic Integer[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\t\n\t\t\tpublic Integer get(Face f){\n\t\t\t\treturn id[f.ordinal()];\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice copy(){\n\t\t\t\treturn new Dice(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tInteger[] tid = (Integer[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice(Integer top, Integer bottom, Integer front, Integer back, Integer right, Integer left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tInteger[] tid = new Integer[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\t\n\t\t\t//true: X軸方向に手前に転がす\n\t\t\t//false: X軸方向に奥に転がす\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\t\n\t\t\t//true: Y軸方向に左へ転がす\n\t\t\t//false: Y軸方向に右へ転がす\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\t\n\t\t\t//true: Z軸方向に右へ回す\n\t\t\t//false: Z軸方向に左へ回す\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\t\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tInteger tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tString str = \"\";\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\tstr += id[f.ordinal()] + \" \";\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\tint hash = 31;\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\thash += hash*17+id[f.ordinal()].hashCode();\n\t\t\t\t}\n\t\t\t\treturn hash;\n\t\t\t}\n\t}\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] f,minf;\n\tstatic int sx,sy,gx,gy;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tH=cin.nextInt();\n\t\t\tW=cin.nextInt();\n\t\t\tif(H+W==0)break;\n\t\t\tf=new int[H][W];\n\t\t\tminf=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tf[i][j]=cin.nextInt();\n\t\t\t\t\tminf[i][j]=1<<30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsx=cin.nextInt();\n\t\t\tsy=cin.nextInt();\n\t\t\tgx=cin.nextInt();\n\t\t\tgy=cin.nextInt();\n\t\t\t\n\t\t\tPriorityQueue<Dice> q = new PriorityQueue<Dice>(200,new Comparator<Dice>(){\n\t\t\t\tpublic int compare(Dice o1, Dice o2) {\n\t\t\t\t\treturn o1.min-o2.min;\n\t\t\t\t}\n\t\t\t});\n\t\t\tDice ddd= new Dice(1,6,2,5,3,4);\n\t\t\tddd.x=ddd.y=ddd.min=0;\n\t\t\tq.add(ddd);\n\t\t\tint ans=1<<30;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tDice d = q.poll();\n\t\t\t\tint x=d.x;\n\t\t\t\tint y=d.y;\n\t\t\t\tint min=d.min;\n//\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+min+\" \"+d);\n\t\t\t\tif(x==gx&&y==gy){\n\t\t\t\t\tans=Math.min(min,ans);;\n\t\t\t\t}\n\t\t\t\tif(minf[x][y]<=min)continue;\n\t\t\t\tminf[x][y]=min;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+v1[i];\n\t\t\t\t\tint yy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=H||yy<0||yy>=W)continue;\n\t\t\t\t\tDice next=roll(d,v1[i],v2[i]);\n\t\t\t\t\tnext.min=d.min+((Integer)next.id[1]*f[xx][yy]);\n\t\t\t\t\tnext.x=xx;\n\t\t\t\t\tnext.y=yy;\n\t\t\t\t\tq.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\t\n\t}\n\tstatic Dice roll(Dice d,int a,int b){\n\t\tDice re;\n\t\tif(a==0){\n\t\t\tif(b==1){\n\t\t\t\td.rollY(false);\n\t\t\t\tre=d.copy();\n\t\t\t\td.rollY(true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\td.rollY(true);\n\t\t\t\tre=d.copy();\n\t\t\t\td.rollY(false);\n\t\t\t}\n\t\t}\n\t\telse if(a==1){\n\t\t\td.rollX(true);\n\t\t\tre=d.copy();\n\t\t\td.rollX(false);\n\t\t}\n\t\telse{\n\t\t\td.rollX(false);\n\t\t\tre=d.copy();\n\t\t\td.rollX(true);\n\t\t}\n\t\treturn re;\n\t}\n\n\t//さいころのデータクラス\n\t//equalsは向きも含めて同値であり,isEquivalentは回転することで同じ賽であることを調べる\n\t//Verify: AOJ0502, AOJ1057\n\tstatic class Dice <T>{\n\t\tpublic int x,y,min;\n\t\tpublic T[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\t\n\t\t\tpublic T get(Face f){\n\t\t\t\treturn id[f.ordinal()];\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice<T> copy(){\n\t\t\t\treturn new Dice<T>(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\t\n\t\t\t//true: X軸方向に手前に転がす\n\t\t\t//false: X軸方向に奥に転がす\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\t\n\t\t\t//true: Y軸方向に左へ転がす\n\t\t\t//false: Y軸方向に右へ転がす\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\t\n\t\t\t//true: Z軸方向に右へ回す\n\t\t\t//false: Z軸方向に左へ回す\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\t\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tT tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object o) {\n\t\t\t\tif(!(o instanceof Dice<?>))return false;\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tDice<T> d = (Dice<T>)o;\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\tif(!id[f.ordinal()].equals(d.id[f.ordinal()])){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tboolean isEquivalent(Dice<T> d) {\n\t\t\t\tfor(int i=0; i<6; i++) {\n\t\t\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\t\t\tif(this.equals(d)) return true;\n\t\t\t\t\t\trollZ(false);\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2==1) rollY(false);\n\t\t\t\t\telse rollX(false);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tList<Dice<T>> getAllState(){\n\t\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\t\trollZ(false);\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\t\telse rollX(false);\n\t\t\t\t}\n\t\t\t\treturn lst;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tString str = \"\";\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\tstr += id[f.ordinal()] + \" \";\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\tint hash = 31;\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\thash += hash*17+id[f.ordinal()].hashCode();\n\t\t\t\t}\n\t\t\t\treturn hash;\n\t\t\t}\n\t}\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    int h,w;\n    int[][] board;\n    int sx,sy,gx,gy;\n    int[] dx = {0,1,0,-1};\n    int[] dy = {-1,0,1,0};\n    \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        \n        while(true){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n            \n            board = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    board[i][j] = sc.nextInt();\n                }\n            }\n            \n            sy = sc.nextInt(); sx = sc.nextInt();\n            gy = sc.nextInt(); gx = sc.nextInt();\n            \n            System.out.println(getMin());\n        }\n    }\n    \n    int getMin(){\n        //x,y,up,south,east,penalty\n        PriorityQueue<int[]> \n            q = new PriorityQueue<int[]>(20,new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[5] - b[5];\n                    }\n                });\n        q.add(new int[]{sx,sy,1,2,3,0});\n        boolean[][][][][] v = new boolean[h][w][7][7][7];\n        \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1], \n                up = qq[2], south = qq[3], east = qq[4], pena = qq[5];\n            \n            if(v[y][x][up][south][east]) continue;\n            v[y][x][up][south][east] = true;\n            \n            if(x==gx && y==gy) return pena;\n            \n            for(int i=0; i<4; i++){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(nx>=0 && nx<w && ny>=0 && ny<h){\n                    int[] dice = getDice(up,south,east,i);\n                    //System.out.println(\"dice \"+Arrays.toString(dice));\n                    q.add(new int[]{nx,ny,dice[0],dice[1],dice[2],\n                                    pena+(7-dice[0])*board[ny][nx]});\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    int[] getDice(int up, int south, int east, int direc){\n        int newUp = 0, newSouth = 0, newEast = 0;\n        if(direc==0){\n            newUp = south;\n            newSouth = 7-up;\n            newEast = east;\n        }else if(direc==1){\n            newUp = 7-east;\n            newSouth = south;\n            newEast = up;\n        }else if(direc==2){\n            newUp = 7-south;\n            newSouth = up;\n            newEast = east;\n        }else{\n            newUp = east;\n            newSouth = south;\n            newEast = 7-up;\n        }\n        \n        return new int[]{newUp,newSouth,newEast};\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\n\t    h = sc.nextInt();\n\t    w = sc.nextInt();\n\t    if(h==0 && w==0) break;\n\n\t    grid = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    grid[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\t    sy = sc.nextInt();\n\t    sx = sc.nextInt();\n\t    gy = sc.nextInt();\n\t    gx = sc.nextInt();\n\n\t    System.out.println(bfs());\n\t}\n    }\n\n    class Dice{\n\tint[] dice = new int[6];\n\tDice(int a, int b, int c, int d, int e, int f){\n\t    dice[0] = a; dice[1] = b; dice[2] = c;\n\t    dice[3] = d; dice[4] = e; dice[5] = f;\n\t}\n    }\n\n    int[][] dd = {{1,5,2,3,0,4}, {3,1,0,5,4,2}, {4,0,2,3,5,1}, {2,1,5,0,4,3}};\n\n    Dice rotate(Dice d, int idx){\n\treturn new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n\n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {-1, 0, 1, 0};\n\n    int bfs(){\n\t//x, y pena\n\tQueue<int[]> q = new LinkedList<int[]>();\n\tQueue<Dice> di = new LinkedList<Dice>();\n\tint[][] v = new int[h][w];\n\tfor(int i=0; i<h; i++) Arrays.fill(v[i], Integer.MAX_VALUE);\n\tq.add(new int[]{sx, sy, 0});\n\n\tDice d = new Dice(1,2,3,4,5,6);\n\tdi.add(d);\n\tint min = Integer.MAX_VALUE;\n\n\twhile(q.size()>0){\n\t    int[] qq = q.poll();\n\t    int x = qq[0], y = qq[1], pena = qq[2];\n\t    Dice ddd = di.poll();\n\n\t    if(x==gx && y==gy){\n\t\tmin = Math.min(min, pena);\n\t\tcontinue;\n\t    }\n\n\t    //System.out.println(x+\" \"+y);\n\n\t    if(v[y][x]<=pena) continue;\n\t    v[y][x] = pena;\n\n\t    for(int i=0; i<4; i++){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n\t\tDice newDice = rotate(ddd, i);\n\t\tq.add(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5]});\n\t\tdi.add(newDice);\n\t    }\n\t}\n\n\tif(min==Integer.MAX_VALUE) min = -1;\n\treturn min;\n    }\n\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n//キューでやってみた\n\npublic class Main {\n\t\n\tclass P implements Comparable<P>{\n\t\tint y;\n\t\tint x;\n\t\tint top;\n\t\tint front;\n\t\tint left;\n\t\tint cost;\n\t\tP(int y,int x,int top,int front,int left,int cost){\n\t\t\tthis.y=y;\n\t\t\tthis.x=x;\n\t\t\tthis.top=top;\n\t\t\tthis.front=front;\n\t\t\tthis.left=left;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\tif(this.cost < o.cost){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if(this.cost > o.cost){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse return 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tnew Main().run();\n\t}\n\n\tfinal int INF=2<<29;//初期値用\n\tint nx[] = {0,1,0,-1};//移動用\n\tint ny[] = {-1,0,1,0};\n\tint map[][];//マップの床に書いてあるのいれておくやつ\n\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint h,w;\n\t\tint cost[][][][][];//y座標,x座標,サイコロの上面、全面、左側のときのスタートからy,xまでのコストをいれておくやつ\n\t\tint s[]=new int[2];//スタートのy,x座標\n\t\tint g[]=new int[2];//ゴールの\n\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\n\t\t\tif(h + w == 0) break;\n\n\t\t\tcost=new int[h][w][7][7][7];//後ろ3つはサイコロのTop,Front,Left\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tcost[a][b][c][d][e]=INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tmap=new int[h][w];\n\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}//for\n\t\t\ts[0]=sc.nextInt();\n\t\t\ts[1]=sc.nextInt();\n\t\t\tg[0]=sc.nextInt();\n\t\t\tg[1]=sc.nextInt();\n\t\t\tcost[s[0]][s[1]][1][2][4]=0;//最初のサイコロの向きは確定なので、これはコスト0にしておく\n\t\t\tSystem.out.println(dijkstra(cost, s[0], s[1], g[0], g[1], h, w));\n\t\t}\n\n\t}\n\t\n\tint dijkstra(int cost[][][][][],int sy,int sx,int gy,int gx,int h,int w){\n\t\tPriorityQueue<P> q=new PriorityQueue<P>();\n\t\tq.add(new P(sy,sx,1,2,4,0));\n\t\tint x,y,t,f,l;\n\t\tboolean use[][][][][]=new boolean[h][w][7][7][7];\n\t\tfor(int a=0;a<h;a++){\n\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\tuse[a][b][c][d][e]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty()){\n\t\t\tx=y=t=f=l=-1;\n\t\t\t//まだ使ってないやつで、最小の奴\n\t\t\t//これをpraiolryqueueにするとTLEを脱出できるかも\n//\t\t\tfor(int a=0;a<h;a++){\n//\t\t\t\tfor(int b=0;b<w;b++){\n//\t\t\t\t\tfor(int c=1;c<7;c++){\n//\t\t\t\t\t\tfor(int d=1;d<7;d++){\n//\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n//\t\t\t\t\t\t\t\tif(!use[a][b][c][d][e] && \n//\t\t\t\t\t\t\t\t\t\t(x==-1 || cost[a][b][c][d][e]<cost[y][x][t][f][l])){\n//\t\t\t\t\t\t\t\t\ty=a;x=b;t=c;f=d;l=e;\n//\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tP p=q.poll();\n\t\t\ty=p.y;\n\t\t\tx=p.x;\n\t\t\tt=p.top;\n\t\t\tf=p.front;\n\t\t\tl=p.left;\n\t\t\tif(use[y][x][t][f][l]) continue;\n\t\t\t//System.out.println(y+\" \"+x);\n\n\t\t\t//if(x==-1) break;\n\t\t\t//System.out.println(y+\" \"+x);\n\t\t\tuse[y][x][t][f][l]=true;\n\n\t\t\t//今回の移動は4方向\n\t\t\t//それにあわせてのサイコロの目の変化にあわせて計算\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t//移動できるかどうかのチェック 壁チェック\n\t\t\t\tif(y+ny[i]<0 || x+nx[i]<0 || h<=y+ny[i] || w<=x+nx[i]) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][f][7-t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][f][7-t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-f)));\n\t\t\t\t\tq.add(new P(y+ny[i],x+nx[i],f,7-t,l,cost[y+ny[i]][x+nx[i]][f][7-t][l]));\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][l][f][7-t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][l][f][7-t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-l)));\n\t\t\t\t\tq.add(new P(y+ny[i],x+nx[i],l,f,7-t,cost[y+ny[i]][x+nx[i]][l][f][7-t]));\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-f][t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-f][t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*f));\n\t\t\t\t\tq.add(new P(y+ny[i],x+nx[i],7-f,t,l,cost[y+ny[i]][x+nx[i]][7-f][t][l]));\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-l][f][t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-l][f][t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*l));\n\t\t\t\t\tq.add(new P(y+ny[i],x+nx[i],7-l,f,t,cost[y+ny[i]][x+nx[i]][7-l][f][t]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t//ゴールについたものの中で最小を見つける\n\t\tfor(int c=1;c<7;c++){\n\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\tans=Math.min(ans, cost[gy][gx][c][d][e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tnew Main().run();\n\t}\n\n\tfinal int INF=2<<10;\n\tint nx[] = {0,1,0,-1};\n\tint ny[] = {-1,0,1,0};\n\tint map[][];\n\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint h,w;\n\t\tint cost[][][][][];\n\t\tint s[]=new int[2];\n\t\tint g[]=new int[2];\n\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\n\t\t\tif(h + w == 0) break;\n\n\t\t\tcost=new int[h][w][7][7][7];//後ろ3つはサイコロのTop,Front,Left\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tcost[a][b][c][d][e]=INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tmap=new int[h][w];\n\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}//for\n\t\t\ts[0]=sc.nextInt();\n\t\t\ts[1]=sc.nextInt();\n\t\t\tg[0]=sc.nextInt();\n\t\t\tg[1]=sc.nextInt();\n\t\t\tcost[s[0]][s[1]][1][2][4]=0;\n\t\t\tSystem.out.println(dijkstra(cost, s[0], s[1], g[0], g[1], h, w));\n\t\t}\n\n\t}\n\tint dijkstra(int cost[][][][][],int sy,int sx,int gy,int gx,int h,int w){\n\t\tint x,y,t,f,l;\n\t\tboolean use[][]=new boolean[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tArrays.fill(use[i], false);\n\t\t}\n\t\twhile(true){\n\t\t\tx=y=t=f=l=-1;\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tif(!use[a][b] && \n\t\t\t\t\t\t\t\t\t\t(x==-1 || cost[a][b][c][d][e]<cost[y][x][t][f][l])){\n\t\t\t\t\t\t\t\t\ty=a;x=b;t=c;f=d;l=e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x==-1) break;\n\t\t\t//System.out.println(y+\" \"+x);\n\t\t\tuse[y][x]=true;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t//移動できるかどうかのチェック 壁チェック\n\t\t\t\tif(y+ny[i]<0 || x+nx[i]<0 || h<=y+ny[i] || w<=x+nx[i]) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][f][7-t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][f][7-t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-f)));\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][l][f][7-t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][l][f][7-t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-l)));\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-f][t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-f][t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*f));\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-l][f][t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-l][f][t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int c=1;c<7;c++){\n\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\tans=Math.min(ans, cost[gy][gx][c][d][e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][] cost = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tArrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tint startH = sc.nextInt();\n\t\t\tint startW = sc.nextInt();\n\t\t\tint destH = sc.nextInt();\n\t\t\tint destW = sc.nextInt();\n\n\t\t\tDice dice = new Dice(1, 2, 3, 4, 5, 6, startH, startW, 0);\n\t\t\tcost[startH][startW] = 0;\n\t\t\tQueue<Dice> que = new LinkedList<Dice>();\n\t\t\tque.add(dice);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tDice now = que.poll();\n\t\t\t\t\tif (now.h == destH && now.w == destW) {\n\t\t\t\t\t\tif (now.cost < cost[destH][destW]) {\n\t\t\t\t\t\t\tcost[destH][destW] = now.cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nextH = now.h + dy[j];\n\t\t\t\t\t\tint nextW = now.w + dx[j];\n\t\t\t\t\t\tif (0 <= nextH && nextH < h && 0 <= nextW && nextW < w) {\n\t\t\t\t\t\t\tDice next = new Dice(now.top, now.front,\n\t\t\t\t\t\t\t\t\tnow.right, now.back, now.left, now.reverse,\n\t\t\t\t\t\t\t\t\tnextH, nextW, now.cost);\n\t\t\t\t\t\t\tswitch (j) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tnext.roll_right();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tnext.roll_front();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tnext.roll_back();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tnext.roll_left();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnext.cost += field[next.h][next.w] * next.reverse;\n\t\t\t\t\t\t\tif (next.cost < cost[next.h][next.w]) {\n\t\t\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcost[next.h][next.w] = next.cost;\n\t\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cost[destH][destW]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Dice {\n\t\tint top;\n\t\tint front;\n\t\tint right;\n\t\tint back;\n\t\tint left;\n\t\tint reverse;\n\n\t\tint h;\n\t\tint w;\n\t\tint cost;\n\n\t\tpublic Dice(int top, int front, int right, int back, int left,\n\t\t\t\tint reverse, int h, int w, int cost) {\n\t\t\tsuper();\n\t\t\tthis.top = top;\n\t\t\tthis.front = front;\n\t\t\tthis.right = right;\n\t\t\tthis.back = back;\n\t\t\tthis.left = left;\n\t\t\tthis.reverse = reverse;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tvoid disp() {\n\t\t\tSystem.out.print(this.top + \" \" + this.front + \" \" + this.right\n\t\t\t\t\t+ \" \" + this.back + \" \" + this.left + \" \" + this.reverse);\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tvoid rotate_parallel() {\n\t\t\tint tmp = this.back;\n\t\t\tthis.back = this.right;\n\t\t\tthis.right = this.front;\n\t\t\tthis.front = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t\tvoid roll_back() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.front;\n\t\t\tthis.front = this.reverse;\n\t\t\tthis.reverse = this.back;\n\t\t\tthis.back = tmp;\n\t\t}\n\n\t\tvoid roll_front() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.back;\n\t\t\tthis.back = this.reverse;\n\t\t\tthis.reverse = this.front;\n\t\t\tthis.front = tmp;\n\t\t}\n\n\t\tvoid roll_right() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.left;\n\t\t\tthis.left = this.reverse;\n\t\t\tthis.reverse = this.right;\n\t\t\tthis.right = tmp;\n\t\t}\n\n\t\tvoid roll_left() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.right;\n\t\t\tthis.right = this.reverse;\n\t\t\tthis.reverse = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Rolling Dice\npublic class Main{\n\n\tstatic class Dice <T>{\n\t\tpublic T[] id;\n\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\n\t\tpublic T get(Face f){\n\t\t\treturn id[f.ordinal()];\n\t\t}\n\n\t\tpublic Dice() {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT[] tid = (T[])new Object[6];\n\n\t\t\tid = tid;\n\t\t}\n\n\n\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT[] tid = (T[])new Object[6];\n\t\t\tid = tid;\n\n\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t}\n\t\tvoid rollX(boolean isReverse) {\n\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t}\n\t\tvoid rollY(boolean isReverse) {\n\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t}\n\t\tvoid rollZ(boolean isReverse) {\n\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t}\n\n\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\tT tmp = id[w.ordinal()];\n\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\tid[z.ordinal()] = tmp;\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(!(o instanceof Dice<?>))return false;\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tDice<T> d = (Dice<T>)o;\n\t\t\tfor(Face f : Face.values()){\n\t\t\t\tif(!id[f.ordinal()].equals(d.id[f.ordinal()])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\n\t\t}\n\t\tboolean isEquivalent(Dice<T> d) {\n\t\t\tfor(int i=0; i<6; i++) {\n\t\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\t\tif(this.equals(d)) return true;\n\t\t\t\t\trollZ(false);\n\t\t\t\t}\n\t\t\t\tif(i%2==1) rollY(false);\n\t\t\t\telse rollX(false);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tList<Dice<T>> getAllState(){\n\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\trollZ(false);\n\t\t\t\t}\n\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\telse rollX(false);\n\t\t\t}\n\t\t\treturn lst;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString str = \"\";\n\t\t\tfor(Face f : Face.values()){\n\t\t\t\tstr += id[f.ordinal()] + \" \";\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hash = 31;\n\t\t\tfor(Face f : Face.values()){\n\t\t\t\thash += hash*17+id[f.ordinal()].hashCode();\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\t}\n\n\tstatic int[][][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h==0&&w==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint si = sc.nextInt();\n\t\t\tint sj = sc.nextInt();\n\t\t\tint gi = sc.nextInt();\n\t\t\tint gj = sc.nextInt();\n\t\t\tDice<Integer> dd = new Dice<Integer>(1, 6, 2, 5, 3, 4);\n\t\t\tList<Dice<Integer>> d = dd.getAllState();\n\t\t\tdist = new int[h][w][24];\n\t\t\tfor(int[][] a:dist)for(int[] b:a)Arrays.fill(b, Integer.MAX_VALUE);\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]]-dist[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tdist[si][sj][0]=0;\n\t\t\tq.add(new int[]{si, sj, 0});\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tif(a[0]==gi&&a[1]==gj){\n\t\t\t\t\tmin = Math.min(min, dist[a[0]][a[1]][a[2]]);\n\t\t\t\t}\n\t\t\t\tDice<Integer> tt = d.get(a[2]);\n\t\t\t\tDice<Integer> t = new Dice<Integer>(tt.get(Dice.Face.TOP), \n\t\t\t\t\t\ttt.get(Dice.Face.BOTTOM),\n\t\t\t\t\t\ttt.get(Dice.Face.FRONT), \n\t\t\t\t\t\ttt.get(Dice.Face.BACK), \n\t\t\t\t\t\ttt.get(Dice.Face.RIGHT), \n\t\t\t\t\t\ttt.get(Dice.Face.LEFT));\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = a[0] + move[k][0];\n\t\t\t\t\tint nj = a[1] + move[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\t\tswitch(k){\n\t\t\t\t\t\tcase 0: t.rollX(true);break;\n\t\t\t\t\t\tcase 1: t.rollX(false);break;\n\t\t\t\t\t\tcase 2: t.rollY(false);break;\n\t\t\t\t\t\tcase 3: t.rollY(true);break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint index = -1;\n\t\t\t\t\t\tfor(int i=0;i<24;i++)if(t.equals(d.get(i))){index=i;break;}\n\t\t\t\t\t\tint v = dist[a[0]][a[1]][a[2]] + m[ni][nj]*t.get(Dice.Face.BOTTOM);\n\t\t\t\t\t\tswitch(k){\n\t\t\t\t\t\tcase 0: t.rollX(false);break;\n\t\t\t\t\t\tcase 1: t.rollX(true);break;\n\t\t\t\t\t\tcase 2: t.rollY(true);break;\n\t\t\t\t\t\tcase 3: t.rollY(false);break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(v < dist[ni][nj][index]){\n\t\t\t\t\t\t\tdist[ni][nj][index] = v;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj,index});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tstatic int[][] move = {{1, 0},{-1,0},{0,1},{0,-1}};\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint x, y;\n\t\tint cost;\n\t\tint top, come, right;\n\t\t\n\t\tpublic Walk(int x, int y, int cost, int top, int come, int right) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cost = cost;\n\t\t\tthis.top = top;\n\t\t\tthis.come = come;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[10][10];\n\t\tboolean[][][][][] is_visited = new boolean[10][10][7][7][7];\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\t\t\tfor(int l = 0; l < 7; l++){\n\t\t\t\t\t\t\tfor(int m = 0; m < 7; m++){\n\t\t\t\t\t\t\t\tis_visited[i][j][k][l][m] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s_y = sc.nextInt();\n\t\t\tint s_x = sc.nextInt();\n\t\t\tint g_y = sc.nextInt();\n\t\t\tint g_x = sc.nextInt();\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\tqueue.add(new Walk(s_x, s_y, 0, 1, 2, 3));\n\t\t\t\n\t\t\tint min_cost = Integer.MAX_VALUE;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.x + \" \" + walk.y);\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.y][walk.x][walk.top][walk.come][walk.right]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[walk.y][walk.x][walk.top][walk.come][walk.right] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.x == g_x && walk.y == g_y){\n\t\t\t\t\tmin_cost = Math.min(min_cost, walk.cost);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.y > 0){\n\t\t\t\t\tfinal int next_x = walk.x;\n\t\t\t\t\tfinal int next_y = walk.y - 1;\n\t\t\t\t\tfinal int next_top = walk.come;\n\t\t\t\t\tfinal int next_bottom = 7 - walk.come;\n\t\t\t\t\tfinal int next_right = walk.right;\n\t\t\t\t\tfinal int next_come = 7 - walk.top;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_visited[next_y][next_x][next_top][next_come][next_right]){\n\t\t\t\t\t\tqueue.add(new Walk(next_x, next_y, walk.cost + map[next_y][next_x] * next_bottom, next_top, next_come, next_right));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.y < h - 1){\n\t\t\t\t\tfinal int next_x = walk.x;\n\t\t\t\t\tfinal int next_y = walk.y + 1;\n\t\t\t\t\tfinal int next_top = 7 - walk.come;\n\t\t\t\t\tfinal int next_bottom = walk.come;\n\t\t\t\t\tfinal int next_right = walk.right;\n\t\t\t\t\tfinal int next_come = walk.top;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_visited[next_y][next_x][next_top][next_come][next_right]){\n\t\t\t\t\t\tqueue.add(new Walk(next_x, next_y, walk.cost + map[next_y][next_x] * next_bottom, next_top, next_come, next_right));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.x > 0){\n\t\t\t\t\tfinal int next_x = walk.x - 1;\n\t\t\t\t\tfinal int next_y = walk.y;\n\t\t\t\t\tfinal int next_top = walk.right;\n\t\t\t\t\tfinal int next_bottom = 7 - walk.right;\n\t\t\t\t\tfinal int next_right = 7 - walk.top;\n\t\t\t\t\tfinal int next_come = walk.come;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_visited[next_y][next_x][next_top][next_come][next_right]){\n\t\t\t\t\t\tqueue.add(new Walk(next_x, next_y, walk.cost + map[next_y][next_x] * next_bottom, next_top, next_come, next_right));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.x < w - 1){\n\t\t\t\t\tfinal int next_x = walk.x + 1;\n\t\t\t\t\tfinal int next_y = walk.y;\n\t\t\t\t\tfinal int next_top = 7 - walk.right;\n\t\t\t\t\tfinal int next_bottom = walk.right;\n\t\t\t\t\tfinal int next_right = walk.top;\n\t\t\t\t\tfinal int next_come = walk.come;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_visited[next_y][next_x][next_top][next_come][next_right]){\n\t\t\t\t\t\tqueue.add(new Walk(next_x, next_y, walk.cost + map[next_y][next_x] * next_bottom, next_top, next_come, next_right));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min_cost);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][][][] cost = new int[h][w][6][6]\n\t\t\t;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\t\tArrays.fill(cost[i][j][k], Integer.MAX_VALUE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint startH = sc.nextInt();\n\t\t\tint startW = sc.nextInt();\n\t\t\tint destH = sc.nextInt();\n\t\t\tint destW = sc.nextInt();\n\n\t\t\tDice dice = new Dice(1, 2, 3, 4, 5, 6, startH, startW, 0);\n\t\t\tcost[startH][startW][0][1] = 0;\n\t\t\tQueue<Dice> que = new LinkedList<Dice>();\n\t\t\tque.add(dice);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tDice now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nextH = now.h + dy[j];\n\t\t\t\t\t\tint nextW = now.w + dx[j];\n\t\t\t\t\t\tif (0 <= nextH && nextH < h && 0 <= nextW && nextW < w) {\n\t\t\t\t\t\t\tDice next = new Dice(now.top, now.front, now.right,\n\t\t\t\t\t\t\t\t\tnow.back, now.left, now.reverse, nextH,\n\t\t\t\t\t\t\t\t\tnextW, now.cost);\n\t\t\t\t\t\t\tswitch (j) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tnext.roll_right();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tnext.roll_front();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tnext.roll_back();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tnext.roll_left();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnext.cost += field[next.h][next.w] * next.reverse;\n\t\t\t\t\t\t\tif (next.cost < cost[next.h][next.w][next.top - 1][next.front - 1]) {\n\t\t\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcost[next.h][next.w][next.top - 1][next.front - 1]= next.cost;\n\t\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\t\tans = Math.min(ans, cost[destH][destW][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Dice {\n\t\tint top;\n\t\tint front;\n\t\tint right;\n\t\tint back;\n\t\tint left;\n\t\tint reverse;\n\n\t\tint h;\n\t\tint w;\n\t\tint cost;\n\n\t\tpublic Dice(int top, int front, int right, int back, int left,\n\t\t\t\tint reverse, int h, int w, int cost) {\n\t\t\tsuper();\n\t\t\tthis.top = top;\n\t\t\tthis.front = front;\n\t\t\tthis.right = right;\n\t\t\tthis.back = back;\n\t\t\tthis.left = left;\n\t\t\tthis.reverse = reverse;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tvoid disp() {\n\t\t\tSystem.out.print(this.top + \" \" + this.front + \" \" + this.right\n\t\t\t\t\t+ \" \" + this.back + \" \" + this.left + \" \" + this.reverse);\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tvoid rotate_parallel() {\n\t\t\tint tmp = this.back;\n\t\t\tthis.back = this.right;\n\t\t\tthis.right = this.front;\n\t\t\tthis.front = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t\tvoid roll_back() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.front;\n\t\t\tthis.front = this.reverse;\n\t\t\tthis.reverse = this.back;\n\t\t\tthis.back = tmp;\n\t\t}\n\n\t\tvoid roll_front() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.back;\n\t\t\tthis.back = this.reverse;\n\t\t\tthis.reverse = this.front;\n\t\t\tthis.front = tmp;\n\t\t}\n\n\t\tvoid roll_right() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.left;\n\t\t\tthis.left = this.reverse;\n\t\t\tthis.reverse = this.right;\n\t\t\tthis.right = tmp;\n\t\t}\n\n\t\tvoid roll_left() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.right;\n\t\t\tthis.right = this.reverse;\n\t\t\tthis.reverse = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tnew Main().run();\n\t}\n\n\tfinal int INF=2<<20;\n\tint nx[] = {0,1,0,-1};\n\tint ny[] = {-1,0,1,0};\n\tint map[][];\n\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint h,w;\n\t\tint cost[][][][][];\n\t\tint s[]=new int[2];\n\t\tint g[]=new int[2];\n\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\n\t\t\tif(h + w == 0) break;\n\n\t\t\tcost=new int[h][w][7][7][7];//後ろ3つはサイコロのTop,Front,Left\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tcost[a][b][c][d][e]=INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tmap=new int[h][w];\n\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}//for\n\t\t\ts[0]=sc.nextInt();\n\t\t\ts[1]=sc.nextInt();\n\t\t\tg[0]=sc.nextInt();\n\t\t\tg[1]=sc.nextInt();\n\t\t\tcost[s[0]][s[1]][1][2][4]=0;\n\t\t\tSystem.out.println(dijkstra(cost, s[0], s[1], g[0], g[1], h, w));\n\t\t}\n\n\t}\n\tint dijkstra(int cost[][][][][],int sy,int sx,int gy,int gx,int h,int w){\n\t\tint x,y,t,f,l;\n\t\tboolean use[][]=new boolean[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tArrays.fill(use[i], false);\n\t\t}\n\t\twhile(true){\n\t\t\tx=y=t=f=l=-1;\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tif(!use[a][b] && \n\t\t\t\t\t\t\t\t\t\t(x==-1 || cost[a][b][c][d][e]<cost[y][x][t][f][l])){\n\t\t\t\t\t\t\t\t\ty=a;x=b;t=c;f=d;l=e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x==-1) break;\n\t\t\t//System.out.println(y+\" \"+x);\n\t\t\tuse[y][x]=true;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t//移動できるかどうかのチェック 壁チェック\n\t\t\t\tif(y+ny[i]<0 || x+nx[i]<0 || h<=y+ny[i] || w<=x+nx[i]) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][f][7-t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][f][7-t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-f)));\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][l][f][7-t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][l][f][7-t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-l)));\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-f][t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-f][t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*f));\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-l][f][t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-l][f][t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int c=1;c<7;c++){\n\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\tans=Math.min(ans, cost[gy][gx][c][d][e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        while(true){\n \n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n \n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            sy = sc.nextInt();\n            sx = sc.nextInt();\n            gy = sc.nextInt();\n            gx = sc.nextInt();\n \n            System.out.println(bfs());\n        }\n    }\n \n    class Dice{\n        int[] dice = new int[6];\n        Dice(int a, int b, int c, int d, int e, int f){\n            dice[0] = a; dice[1] = b; dice[2] = c;\n            dice[3] = d; dice[4] = e; dice[5] = f;\n        }\n    }\n \n    int[][] dd = {{1,5,2,3,0,4}, {3,1,0,5,4,2}, {4,0,2,3,5,1}, {2,1,5,0,4,3}};\n \n    Dice rotate(Dice d, int idx){\n        return new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n \n    class P{\n        Dice d;\n        int[] num;\n        P(int[] num, Dice d){\n            this.num = num;\n            this.d = d;\n        }\n    }\n    \n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {-1, 0, 1, 0};\n    \n    int bfs(){\n        //x, y pena,direction\n        PriorityQueue<P> \n            q = new PriorityQueue<P>(10, new Comparator<P>(){\n                    public int compare(P a, P b){\n                        return a.num[2] - b.num[2];\n                    }\n                });\n        boolean[][][] v = new boolean[h][w][4];\n        Dice d = new Dice(1,2,3,4,5,6);\n        q.add(new P(new int[]{sx, sy, 0, -1}, d));\n              \n        int min = Integer.MAX_VALUE;\n              \n        while(q.size()>0){\n            P p = q.poll();\n            int[] qq = p.num;\n            int x = qq[0], y = qq[1], pena = qq[2], direc = qq[3];\n            Dice ddd = p.d;\n            //System.out.println(x+\" \"+y+\" \"+pena+\" \"+Arrays.toString(ddd.dice));\n \n            if(x==gx && y==gy) return pena;\n\n            if(direc!=-1){ \n                if(v[y][x][direc]) continue;\n                v[y][x][direc] = true;\n            }\n \n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                Dice newDice = rotate(ddd, i);\n                q.add(new P(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5], i}, newDice));\n            }\n        }\n\n        return min; \n    }\n \n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int h,w;\n    int[][] board;\n    int sx,sy,gx,gy;\n    int[] dx = {0,1,0,-1};\n    int[] dy = {-1,0,1,0};\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    h = sc.nextInt();\n\t    w = sc.nextInt();\n\t    if(h==0 && w==0) break;\n\n\t    board = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    board[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\n\t    sy = sc.nextInt(); sx = sc.nextInt();\n\t    gy = sc.nextInt(); gx = sc.nextInt();\n\n\t    System.out.println(getMin());\n\t}\n    }\n\n    int getMin(){\n\t//x,y,up,south,east,pena\n\tPriorityQueue<int[]> \n\t    q = new PriorityQueue<int[]>(20,new Comparator<int[]>(){\n\t\t    public int compare(int[] a, int[] b){\n\t\t\treturn a[5] - b[5];\n\t\t    }\n\t\t});\n\tq.add(new int[]{sx,sy,1,2,3,0});\n\tboolean[][] v = new boolean[h][w];\n\n\twhile(q.size()>0){\n\t    int[] qq = q.poll();\n\t    int x = qq[0], y = qq[1], \n\t\tup = qq[2], south = qq[3], east = qq[4], pena = qq[5];\n\n\t    if(v[y][x]) continue;\n\t    v[y][x] = true;\n\n\t    if(x==gx && y==gy) return pena;\n\n\t    for(int i=0; i<4; i++){\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t    int[] dice = getDice(up,south,east,i);\n\t\t    q.add(new int[]{nx,ny,dice[0],dice[1],dice[2],\n\t\t\t\t    pena+(7-dice[0])*board[ny][nx]});\n\t\t}\n\t    }\n\t}\n\n\treturn -1;\n    }\n\n    int[] getDice(int up, int south, int east, int direc){\n\tint newUp = 0, newSouth = 0, newEast = 0;\n\tif(direc==0){\n\t    newUp = south;\n\t    newEast = east;\n\t    newSouth = 7-up;\n\t}else if(direc==1){\n\t    newUp = 7-east;\n\t    newSouth = south;\n\t    newEast = up;\n\t}else if(direc==2){\n\t    newUp = 7-south;\n\t    newEast = east;\n\t    newSouth = up;\n\t}else{\n\t    newUp = east;\n\t    newSouth = south;\n\t    newEast = 7-up;\n\t}\n\n\treturn new int[]{newUp,newSouth,newEast};\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint h=sc.nextInt(), w=sc.nextInt();\n\t\t\tif(h==0 && w==0) break;\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint si=sc.nextInt(), sj=sc.nextInt();\n\t\t\tint gi=sc.nextInt(), gj=sc.nextInt();\n\n\t\t\tQueue<State> open = new PriorityQueue<State>();\n\t\t\tSet<State> closed = new HashSet<State>();\n\n\t\t\tState st = null;\n\t\t\topen.add(new State(0,new Dice(si,sj,1,6,4,3,5,2)));\n\t\t\tState ans = null;\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tst = open.poll();\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\t\t\t\tif(st.d.i == gi && st.d.j == gj){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.addAll(st.nexts(map));\n\t\t\t}\n\t\t\tSystem.out.println(ans.cost);\n\t\t}\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint cost;\n\tDice d;\n\n\tState(int cost,Dice d){\n\t\tthis.cost = cost;\n\t\tthis.d = d.copy();\n\t}\n\n\tList<State> nexts(int[][] map){\n\t\tList<State> sts = new ArrayList<State>();\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tDice dice = d.copy();\n\t\t\tif(dice.move(map,i)){\n\t\t\t\tsts.add(new State(cost+dice.b*map[dice.i][dice.j], dice));\n\t\t\t}\n\t\t}\n\n\t\treturn sts;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn this.d.equals(st.d);\n\t}\n\n\tpublic int hashCode(){\n\t\treturn d.i + d.j + d.t + d.b + d.w + d.e + d.n + d.s;\n\t}\n}\n\nclass Dice{\n\tint i,j;\n\tint t,b,w,e,n,s;\n\n\tDice(int i,int j,int t,int b,int w,int e,int n,int s){\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t\tthis.t = t;\n\t\tthis.b = b;\n\t\tthis.w = w;\n\t\tthis.e = e;\n\t\tthis.n = n;\n\t\tthis.s = s;\n\t}\n\n\tpublic boolean equals(Object dtmp){\n\t\tDice d = (Dice)dtmp;\n\t\treturn this.i == d.i && this.j == d.j &&\n\t\t\tthis.t == d.t && this.b == d.b && this.w == d.w &&\n\t\t\tthis.e == d.e && this.n == d.n && this.s == d.s;\n\t}\n\n\tboolean move(int[][] map,int d){\n\t\tDice tmp = this.copy();\n\n\t\tswitch(d){\n\t\tcase 0:\n\t\t\tif(i-1<0) return false;\n\t\t\ti = i-1;\n\t\t\tt = tmp.s; b = tmp.n; n = tmp.t; s = tmp.b;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(j+1>=map[0].length) return false;\n\t\t\tj = j+1;\n\t\t\tt = tmp.w; b = tmp.e; w = tmp.b; e = tmp.t;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(i+1>=map.length) return false;\n\t\t\ti = i+1;\n\t\t\tt = tmp.n; b = tmp.s; n = tmp.b; s = tmp.t;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(j-1<0) return false;\t\n\t\t\tj = j-1;\n\t\t\tt = tmp.e; b = tmp.w; w = tmp.t; e = tmp.b;\n\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n\tDice copy(){\n\t\treturn new Dice(i,j,t,b,w,e,n,s);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n \n    void solve(){\n    Scanner sc = new Scanner(System.in);\n \n    while(true){\n \n        h = sc.nextInt();\n        w = sc.nextInt();\n        if(h==0 && w==0) break;\n \n        grid = new int[h][w];\n        for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            grid[i][j] = sc.nextInt();\n        }\n        }\n        sy = sc.nextInt();\n        sx = sc.nextInt();\n        gy = sc.nextInt();\n        gx = sc.nextInt();\n \n        System.out.println(bfs());\n    }\n    }\n \n    class Dice{\n    int[] dice = new int[6];\n    Dice(int a, int b, int c, int d, int e, int f){\n        dice[0] = a; dice[1] = b; dice[2] = c;\n        dice[3] = d; dice[4] = e; dice[5] = f;\n    }\n    }\n \n    int[][] dd = {{1,5,2,3,0,4}, {3,1,0,5,4,2}, {4,0,2,3,5,1}, {2,1,5,0,4,3}};\n \n    Dice rotate(Dice d, int idx){\n    return new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n \n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {-1, 0, 1, 0};\n \n    int bfs(){\n    //x, y pena\n    Queue<int[]> q = new LinkedList<int[]>();\n    Queue<Dice> di = new LinkedList<Dice>();\n    int[][] v = new int[h][w];\n    for(int i=0; i<h; i++) Arrays.fill(v[i], Integer.MAX_VALUE);\n    q.add(new int[]{sx, sy, 0});\n \n    Dice d = new Dice(1,2,3,4,5,6);\n    di.add(d);\n    int min = Integer.MAX_VALUE;\n \n    while(q.size()>0){\n        int[] qq = q.poll();\n        int x = qq[0], y = qq[1], pena = qq[2];\n        Dice ddd = di.poll();\n \n        if(x==gx && y==gy){\n        min = Math.min(min, pena);\n        continue;\n        }\n \n        //System.out.println(x+\" \"+y);\n \n        if(v[y][x]<=pena) continue;\n        v[y][x] = pena;\n \n        for(int i=0; i<4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n        Dice newDice = rotate(ddd, i);\n        q.add(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5]});\n        di.add(newDice);\n        }\n    }\n \n    if(min==Integer.MAX_VALUE) min = -1;\n    return min;\n    }\n \n \n    public static void main(String[] args){\n    new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tnew Main().run();\n\t}\n\n\tfinal int INF=2<<29;//初期値用\n\tint nx[] = {0,1,0,-1};//移動用\n\tint ny[] = {-1,0,1,0};\n\tint map[][];//マップの床に書いてあるのいれておくやつ\n\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint h,w;\n\t\tint cost[][][][][];//y座標,x座標,サイコロの上面、全面、左側のときのスタートからy,xまでのコストをいれておくやつ\n\t\tint s[]=new int[2];//スタートのy,x座標\n\t\tint g[]=new int[2];//ゴールの\n\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\n\t\t\tif(h + w == 0) break;\n\n\t\t\tcost=new int[h][w][7][7][7];//後ろ3つはサイコロのTop,Front,Left\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tcost[a][b][c][d][e]=INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tmap=new int[h][w];\n\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}//for\n\t\t\ts[0]=sc.nextInt();\n\t\t\ts[1]=sc.nextInt();\n\t\t\tg[0]=sc.nextInt();\n\t\t\tg[1]=sc.nextInt();\n\t\t\tcost[s[0]][s[1]][1][2][4]=0;//最初のサイコロの向きは確定なので、これはコスト0にしておく\n\t\t\tSystem.out.println(dijkstra(cost, s[0], s[1], g[0], g[1], h, w));\n\t\t}\n\n\t}\n\t\n\tint dijkstra(int cost[][][][][],int sy,int sx,int gy,int gx,int h,int w){\n\t\tint x,y,t,f,l;\n\t\tboolean use[][][][][]=new boolean[h][w][7][7][7];\n\t\tfor(int a=0;a<h;a++){\n\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\tuse[a][b][c][d][e]=false;;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tx=y=t=f=l=-1;\n\t\t\t//まだ使ってないやつで、\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tif(!use[a][b][c][d][e] && \n\t\t\t\t\t\t\t\t\t\t(x==-1 || cost[a][b][c][d][e]<cost[y][x][t][f][l])){\n\t\t\t\t\t\t\t\t\ty=a;x=b;t=c;f=d;l=e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x==-1) break;\n\t\t\t//System.out.println(y+\" \"+x);\n\t\t\tuse[y][x][t][f][l]=true;\n\n\t\t\t//今回の移動は4方向\n\t\t\t//それにあわせてのサイコロの目の変化にあわせて計算\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t//移動できるかどうかのチェック 壁チェック\n\t\t\t\tif(y+ny[i]<0 || x+nx[i]<0 || h<=y+ny[i] || w<=x+nx[i]) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][f][7-t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][f][7-t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-f)));\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][l][f][7-t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][l][f][7-t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-l)));\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-f][t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-f][t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*f));\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-l][f][t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-l][f][t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t//ゴールについたものの中で最小を見つける\n\t\tfor(int c=1;c<7;c++){\n\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\tans=Math.min(ans, cost[gy][gx][c][d][e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\npublic class Main {\n\n\tstatic int H,W;\n\tstatic int[][] f,minf;\n\tstatic int sx,sy,gx,gy;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tstatic HashMap<Dice,Integer>[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tH=cin.nextInt();\n\t\t\tW=cin.nextInt();\n\t\t\tif(H+W==0)break;\n\t\t\tf=new int[H][W];\n\t\t\tminf=new int[H][W];\n\t\t\tmap=new HashMap[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tmap[i][j]=new HashMap<Dice,Integer>();\n\t\t\t\t\tf[i][j]=cin.nextInt();\n\t\t\t\t\tminf[i][j]=1<<30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsx=cin.nextInt();\n\t\t\tsy=cin.nextInt();\n\t\t\tgx=cin.nextInt();\n\t\t\tgy=cin.nextInt();\n\t\t\t\n\t\t\tPriorityQueue<Dice> q = new PriorityQueue<Dice>(200,new Comparator<Dice>(){\n\t\t\t\tpublic int compare(Dice o1, Dice o2) {\n\t\t\t\t\treturn o1.min-o2.min;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tDice ddd= new Dice(\n\t\t\t\t\tnew Integer(1),\n\t\t\t\t\tnew Integer(6),\n\t\t\t\t\tnew Integer(2),\n\t\t\t\t\tnew Integer(5),\n\t\t\t\t\tnew Integer(3),\n\t\t\t\t\tnew Integer(4)\n\t\t\t\t\t);\n\t\t\t\n\t\t\tddd.x=ddd.y=ddd.min=0;\n\t\t\tq.add(ddd);\n\t\t\tint ans=1<<30;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tDice d = q.poll();\n\t\t\t\tint x=d.x;\n\t\t\t\tint y=d.y;\n\t\t\t\tint min=d.min;\n//\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+min+\" \"+d);\n\t\t\t\tif(x==gx&&y==gy){\n\t\t\t\t\tans=Math.min(min,ans);;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(minf[x][y]<=min)continue;\n\t\t\t\tminf[x][y]=min;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+v1[i];\n\t\t\t\t\tint yy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=H||yy<0||yy>=W)continue;\n\t\t\t\t\tDice next=roll(d,v1[i],v2[i]);\n\t\t\t\t\tInteger id=(next.id[1]);\n\t\t\t\t\t\n\t\t\t\t\tnext.min=d.min+(id*f[xx][yy]);\n\t\t\t\t\tnext.x=xx;\n\t\t\t\t\tnext.y=yy;\n\t\t\t\t\tq.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\t\n\t}\n\tstatic Dice roll(Dice d,int a,int b){\n\t\tDice re;\n\n\t\tif(a==0){\n\t\t\tif(b==1){\n\t\t\t\td.rollY(false);\n\t\t\t\tre=d.copy();\n\t\t\t\td.rollY(true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\td.rollY(true);\n\t\t\t\tre=d.copy();\n\t\t\t\td.rollY(false);\n\t\t\t}\n\t\t}\n\t\telse if(a==1){\n\t\t\td.rollX(true);\n\t\t\tre=d.copy();\n\t\t\td.rollX(false);\n\t\t}\n\t\telse{\n\t\t\td.rollX(false);\n\t\t\tre=d.copy();\n\t\t\td.rollX(true);\n\t\t}\n\t\treturn re;\n\t}\n\n\t//さいころのデータクラス\n\t//equalsは向きも含めて同値であり,isEquivalentは回転することで同じ賽であることを調べる\n\t//Verify: AOJ0502, AOJ1057\n\tstatic class Dice {\n\t\tpublic int x,y,min;\n\t\tpublic Integer[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\t\n\t\t\tpublic Integer get(Face f){\n\t\t\t\treturn id[f.ordinal()];\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice copy(){\n\t\t\t\treturn new Dice(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tInteger[] tid = (Integer[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Dice(Integer top, Integer bottom, Integer front, Integer back, Integer right, Integer left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tInteger[] tid = new Integer[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\t\n\t\t\t//true: X軸方向に手前に転がす\n\t\t\t//false: X軸方向に奥に転がす\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\t\n\t\t\t//true: Y軸方向に左へ転がす\n\t\t\t//false: Y軸方向に右へ転がす\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\t\n\t\t\t//true: Z軸方向に右へ回す\n\t\t\t//false: Z軸方向に左へ回す\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\t\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tInteger tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tString str = \"\";\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\tstr += id[f.ordinal()] + \" \";\n\t\t\t\t}\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\tint hash = 31;\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\thash += hash*17+id[f.ordinal()].hashCode();\n\t\t\t\t}\n\t\t\t\treturn hash;\n\t\t\t}\n\t}\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        while(true){\n \n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n \n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            sy = sc.nextInt();\n            sx = sc.nextInt();\n            gy = sc.nextInt();\n            gx = sc.nextInt();\n \n            System.out.println(bfs());\n        }\n    }\n \n    class Dice{\n        int[] dice = new int[6];\n        Dice(int a, int b, int c, int d, int e, int f){\n            dice[0] = a; dice[1] = b; dice[2] = c;\n            dice[3] = d; dice[4] = e; dice[5] = f;\n        }\n    }\n \n    int[][] dd = {{1,5,2,3,0,4}, {3,1,0,5,4,2}, {4,0,2,3,5,1}, {2,1,5,0,4,3}};\n \n    Dice rotate(Dice d, int idx){\n        return new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n \n    class P{\n        Dice d;\n        int[] num;\n        P(int[] num, Dice d){\n            this.num = num;\n            this.d = d;\n        }\n    }\n    \n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {-1, 0, 1, 0};\n    \n    int bfs(){\n        //x, y pena\n        PriorityQueue<P> \n            q = new PriorityQueue<P>(10, new Comparator<P>(){\n                    public int compare(P a, P b){\n                        return a.num[2] - b.num[2];\n                    }\n                });\n        int[][] v = new int[h][w];\n        for(int i=0; i<h; i++) Arrays.fill(v[i], Integer.MAX_VALUE);\n        Dice d = new Dice(1,2,3,4,5,6);\n        q.add(new P(new int[]{sx, sy, 0}, d));\n              \n        int min = Integer.MAX_VALUE;\n              \n        while(q.size()>0){\n            P p = q.poll();\n            int[] qq = p.num;\n            int x = qq[0], y = qq[1], pena = qq[2];\n            Dice ddd = p.d;\n            //System.out.println(x+\" \"+y+\" \"+pena+\" \"+Arrays.toString(ddd.dice));\n \n            if(x==gx && y==gy) return pena;\n \n            if(v[y][x]<=pena) continue;\n            v[y][x] = pena;\n \n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                Dice newDice = rotate(ddd, i);\n                q.add(new P(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5]}, newDice));\n            }\n        }\n\n        return min; \n    }\n \n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][][][][] cost = new int[h][w][6][6][6];\n\t\t\t;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tArrays.fill(cost[i][j][k][l], Integer.MAX_VALUE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint startH = sc.nextInt();\n\t\t\tint startW = sc.nextInt();\n\t\t\tint destH = sc.nextInt();\n\t\t\tint destW = sc.nextInt();\n\n\t\t\tDice dice = new Dice(1, 2, 3, 4, 5, 6, startH, startW, 0);\n\t\t\tcost[startH][startW][1][2][3] = 0;\n\t\t\tQueue<Dice> que = new LinkedList<Dice>();\n\t\t\tque.add(dice);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tDice now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nextH = now.h + dy[j];\n\t\t\t\t\t\tint nextW = now.w + dx[j];\n\t\t\t\t\t\tif (0 <= nextH && nextH < h && 0 <= nextW && nextW < w) {\n\t\t\t\t\t\t\tDice next = new Dice(now.top, now.front, now.right,\n\t\t\t\t\t\t\t\t\tnow.back, now.left, now.reverse, nextH,\n\t\t\t\t\t\t\t\t\tnextW, now.cost);\n\t\t\t\t\t\t\tswitch (j) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tnext.roll_right();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tnext.roll_front();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tnext.roll_back();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tnext.roll_left();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnext.cost += field[next.h][next.w] * next.reverse;\n\t\t\t\t\t\t\tif (next.cost < cost[next.h][next.w][next.top - 1][next.front - 1][next.right - 1]) {\n\t\t\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcost[next.h][next.w][next.top - 1][next.front - 1][next.right- 1] = next.cost;\n\t\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\tans = Math.min(ans, cost[destH][destW][i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Dice {\n\t\tint top;\n\t\tint front;\n\t\tint right;\n\t\tint back;\n\t\tint left;\n\t\tint reverse;\n\n\t\tint h;\n\t\tint w;\n\t\tint cost;\n\n\t\tpublic Dice(int top, int front, int right, int back, int left,\n\t\t\t\tint reverse, int h, int w, int cost) {\n\t\t\tsuper();\n\t\t\tthis.top = top;\n\t\t\tthis.front = front;\n\t\t\tthis.right = right;\n\t\t\tthis.back = back;\n\t\t\tthis.left = left;\n\t\t\tthis.reverse = reverse;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tvoid disp() {\n\t\t\tSystem.out.print(this.top + \" \" + this.front + \" \" + this.right\n\t\t\t\t\t+ \" \" + this.back + \" \" + this.left + \" \" + this.reverse);\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tvoid rotate_parallel() {\n\t\t\tint tmp = this.back;\n\t\t\tthis.back = this.right;\n\t\t\tthis.right = this.front;\n\t\t\tthis.front = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t\tvoid roll_back() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.front;\n\t\t\tthis.front = this.reverse;\n\t\t\tthis.reverse = this.back;\n\t\t\tthis.back = tmp;\n\t\t}\n\n\t\tvoid roll_front() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.back;\n\t\t\tthis.back = this.reverse;\n\t\t\tthis.reverse = this.front;\n\t\t\tthis.front = tmp;\n\t\t}\n\n\t\tvoid roll_right() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.left;\n\t\t\tthis.left = this.reverse;\n\t\t\tthis.reverse = this.right;\n\t\t\tthis.right = tmp;\n\t\t}\n\n\t\tvoid roll_left() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.right;\n\t\t\tthis.right = this.reverse;\n\t\t\tthis.reverse = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W, startR, startC, goalR, goalC;\n\tstatic int[][] f;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new int[H][W];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tf[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstartR = sc.nextInt();\n\t\t\tstartC = sc.nextInt();\n\t\t\tgoalR = sc.nextInt();\n\t\t\tgoalC = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tHashSet<State> visited = new HashSet<State>();\n\t\tState start = new State(startR, startC, new Dice(new int[] { 1, 5, 3, 2, 4, 6 }), 0);\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(start);\n\t\twhile (true) {\n\t\t\tState st = q.poll();\n\t\t\tif (st.r == goalR && st.c == goalC) return st.pena;\n\t\t\tif (visited.contains(st)) continue;\n\t\t\tvisited.add(st);\n\t\t\tif (st.r > 0) {\n\t\t\t\tst.dice.rollN();\n\t\t\t\tq.add(new State(st.r - 1, st.c, st.dice, st.pena + st.dice.bottom() * f[st.r - 1][st.c]));\n\t\t\t\tst.dice.rollS();\n\t\t\t}\n\t\t\tif (st.r < H - 1) {\n\t\t\t\tst.dice.rollS();\n\t\t\t\tq.add(new State(st.r + 1, st.c, st.dice, st.pena + st.dice.bottom() * f[st.r + 1][st.c]));\n\t\t\t\tst.dice.rollN();\n\t\t\t}\n\t\t\tif (st.c < W - 1) {\n\t\t\t\tst.dice.rollE();\n\t\t\t\tq.add(new State(st.r, st.c + 1, st.dice, st.pena + st.dice.bottom() * f[st.r][st.c + 1]));\n\t\t\t\tst.dice.rollW();\n\t\t\t}\n\t\t\tif (st.c > 0) {\n\t\t\t\tst.dice.rollW();\n\t\t\t\tq.add(new State(st.r, st.c - 1, st.dice, st.pena + st.dice.bottom() * f[st.r][st.c - 1]));\n\t\t\t\tst.dice.rollE();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint pena;\n\t\tint r, c;\n\t\tDice dice;\n\n\t\tState(int r, int c, Dice dice, int pena) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.dice = dice.clone();\n\t\t\tthis.pena = pena;\n\t\t}\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tState state = (State) o;\n\t\t\treturn this.r == state.r && this.c == state.c && this.dice.equals(state.dice);\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\tint ret = 31;\n\t\t\tret = ret * 17 + r;\n\t\t\tret = ret * 17 + c;\n\t\t\tret = ret * 17 + dice.hashCode();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.pena - o.pena;\n\t\t}\n\n\t}\n\n\tstatic class Dice {\n\t\tint[] val = new int[6];\n\n\t\tDice(int[] val) {\n\t\t\tif (val[0] + val[5] != 7 || val[1] + val[3] != 7 || val[2] + val[4] != 7) throw new RuntimeException();\n\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\tthis.val[i] = val[i];\n\t\t\t}\n\t\t}\n\n\t\tvoid rollN() {\n\t\t\tint tmp = north();\n\t\t\tthis.val[1] = this.val[0];\n\t\t\tthis.val[0] = this.val[3];\n\t\t\tthis.val[3] = this.val[5];\n\t\t\tthis.val[5] = tmp;\n\t\t}\n\n\t\tvoid rollS() {\n\t\t\tint tmp = south();\n\t\t\tthis.val[3] = this.val[0];\n\t\t\tthis.val[0] = this.val[1];\n\t\t\tthis.val[1] = this.val[5];\n\t\t\tthis.val[5] = tmp;\n\t\t}\n\n\t\tvoid rollE() {\n\t\t\tint tmp = east();\n\t\t\tthis.val[2] = this.val[0];\n\t\t\tthis.val[0] = this.val[4];\n\t\t\tthis.val[4] = this.val[5];\n\t\t\tthis.val[5] = tmp;\n\t\t}\n\n\t\tvoid rollW() {\n\t\t\tint tmp = west();\n\t\t\tthis.val[4] = this.val[0];\n\t\t\tthis.val[0] = this.val[2];\n\t\t\tthis.val[2] = this.val[5];\n\t\t\tthis.val[5] = tmp;\n\t\t}\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (!(o instanceof Dice)) return false;\n\t\t\treturn Arrays.equals(this.val, ((Dice) o).val);\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(this.val);\n\t\t}\n\n\t\tpublic Dice clone() {\n\t\t\treturn new Dice(this.val);\n\t\t}\n\n\t\tint top() {\n\t\t\treturn this.val[0];\n\t\t}\n\n\t\tint bottom() {\n\t\t\treturn this.val[5];\n\t\t}\n\n\t\tint north() {\n\t\t\treturn this.val[1];\n\t\t}\n\n\t\tint south() {\n\t\t\treturn this.val[3];\n\t\t}\n\n\t\tint east() {\n\t\t\treturn this.val[2];\n\t\t}\n\n\t\tint west() {\n\t\t\treturn this.val[4];\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Main{\n \n    int h, w;\n    int sx, sy, gx, gy;\n    int[][] grid;\n \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n \n        while(true){\n \n            h = sc.nextInt();\n            w = sc.nextInt();\n            if(h==0 && w==0) break;\n \n            grid = new int[h][w];\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    grid[i][j] = sc.nextInt();\n                }\n            }\n            sy = sc.nextInt();\n            sx = sc.nextInt();\n            gy = sc.nextInt();\n            gx = sc.nextInt();\n \n            System.out.println(bfs());\n        }\n    }\n \n    class Dice{\n        int[] dice = new int[6];\n        Dice(int a, int b, int c, int d, int e, int f){\n            dice[0] = a; dice[1] = b; dice[2] = c;\n            dice[3] = d; dice[4] = e; dice[5] = f;\n        }\n    }\n \n    int[][] dd = {{1,5,2,3,0,4}, {3,1,0,5,4,2}, {4,0,2,3,5,1}, {2,1,5,0,4,3}};\n \n    Dice rotate(Dice d, int idx){\n        return new Dice(d.dice[dd[idx][0]], d.dice[dd[idx][1]], d.dice[dd[idx][2]], d.dice[dd[idx][3]], d.dice[dd[idx][4]], d.dice[dd[idx][5]]);\n    }\n \n    class P{\n        Dice d;\n        int[] num;\n        P(int[] num, Dice d){\n            this.num = num;\n            this.d = d;\n        }\n    }\n    \n    int[] dx = {0, 1, 0, -1};\n    int[] dy = {-1, 0, 1, 0};\n    \n    int bfs(){\n        //x, y pena,direction\n        PriorityQueue<P> \n            q = new PriorityQueue<P>(10, new Comparator<P>(){\n                    public int compare(P a, P b){\n                        return a.num[2] - b.num[2];\n                    }\n                });\n        boolean[][][][] v = new boolean[h][w][6][6];\n        Dice d = new Dice(1,2,3,4,5,6);\n        q.add(new P(new int[]{sx, sy, 0}, d));\n              \n        int min = Integer.MAX_VALUE;\n              \n        while(q.size()>0){\n            P p = q.poll();\n            int[] qq = p.num;\n            int x = qq[0], y = qq[1], pena = qq[2];\n            Dice ddd = p.d;\n            //System.out.println(x+\" \"+y+\" \"+pena+\" \"+Arrays.toString(ddd.dice));\n \n            if(x==gx && y==gy) return pena;\n\n            if(v[y][x][ddd.dice[0]-1][ddd.dice[1]-1]) continue;\n            v[y][x][ddd.dice[0]-1][ddd.dice[1]-1] = true;\n \n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                Dice newDice = rotate(ddd, i);\n                q.add(new P(new int[]{nx, ny, pena+grid[ny][nx]*newDice.dice[5], newDice.dice[0], newDice.dice[1]}, newDice));\n            }\n        }\n\n        return min; \n    }\n \n \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[h][w];\n\t\t\tint[][][][] cost = new int[h][w][6][6]\n\t\t\t;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\t\tArrays.fill(cost[i][j][k], Integer.MAX_VALUE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint startH = sc.nextInt();\n\t\t\tint startW = sc.nextInt();\n\t\t\tint destH = sc.nextInt();\n\t\t\tint destW = sc.nextInt();\n\t\t\t\n\t\t\tDice dice = new Dice(1, 2, 3, 5, 4, 6, startH, startW, 0);\n\t\t\tcost[startH][startW][0][1] = 0;\n\t\t\tQueue<Dice> que = new LinkedList<Dice>();\n\t\t\tque.add(dice);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tDice now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tint nextH = now.h + dy[j];\n\t\t\t\t\t\tint nextW = now.w + dx[j];\n\t\t\t\t\t\tif (0 <= nextH && nextH < h && 0 <= nextW && nextW < w) {\n\t\t\t\t\t\t\tDice next = new Dice(now.top, now.front, now.right,\n\t\t\t\t\t\t\t\t\tnow.back, now.left, now.reverse, nextH,\n\t\t\t\t\t\t\t\t\tnextW, now.cost);\n\t\t\t\t\t\t\tswitch (j) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tnext.roll_right();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tnext.roll_front();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tnext.roll_back();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tnext.roll_left();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnext.cost += field[next.h][next.w] * next.reverse;\n\t\t\t\t\t\t\tif (next.cost < cost[next.h][next.w][next.top - 1][next.front - 1]) {\n\t\t\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcost[next.h][next.w][next.top - 1][next.front - 1]= next.cost;\n\t\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\t\tans = Math.min(ans, cost[destH][destW][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Dice {\n\t\tint top;\n\t\tint front;\n\t\tint right;\n\t\tint back;\n\t\tint left;\n\t\tint reverse;\n\n\t\tint h;\n\t\tint w;\n\t\tint cost;\n\n\t\tpublic Dice(int top, int front, int right, int back, int left,\n\t\t\t\tint reverse, int h, int w, int cost) {\n\t\t\tsuper();\n\t\t\tthis.top = top;\n\t\t\tthis.front = front;\n\t\t\tthis.right = right;\n\t\t\tthis.back = back;\n\t\t\tthis.left = left;\n\t\t\tthis.reverse = reverse;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tvoid disp() {\n\t\t\tSystem.out.print(this.top + \" \" + this.front + \" \" + this.right\n\t\t\t\t\t+ \" \" + this.back + \" \" + this.left + \" \" + this.reverse);\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tvoid rotate_parallel() {\n\t\t\tint tmp = this.back;\n\t\t\tthis.back = this.right;\n\t\t\tthis.right = this.front;\n\t\t\tthis.front = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t\tvoid roll_back() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.front;\n\t\t\tthis.front = this.reverse;\n\t\t\tthis.reverse = this.back;\n\t\t\tthis.back = tmp;\n\t\t}\n\n\t\tvoid roll_front() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.back;\n\t\t\tthis.back = this.reverse;\n\t\t\tthis.reverse = this.front;\n\t\t\tthis.front = tmp;\n\t\t}\n\n\t\tvoid roll_right() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.left;\n\t\t\tthis.left = this.reverse;\n\t\t\tthis.reverse = this.right;\n\t\t\tthis.right = tmp;\n\t\t}\n\n\t\tvoid roll_left() {\n\t\t\tint tmp = this.top;\n\t\t\tthis.top = this.right;\n\t\t\tthis.right = this.reverse;\n\t\t\tthis.reverse = this.left;\n\t\t\tthis.left = tmp;\n\t\t}\n\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package aoj11kai;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tnew Main().run();\n\t}\n\n\tfinal int INF=2<<29;//初期値用\n\tint nx[] = {0,1,0,-1};//移動用\n\tint ny[] = {-1,0,1,0};\n\tint map[][];//マップの床に書いてあるのいれておくやつ\n\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint h,w;\n\t\tint cost[][][][][];//y座標,x座標,サイコロの上面、全面、左側のときのスタートからy,xまでのコストをいれておくやつ\n\t\tint s[]=new int[2];//スタートのy,x座標\n\t\tint g[]=new int[2];//ゴールの\n\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\n\t\t\tif(h + w == 0) break;\n\n\t\t\tcost=new int[h][w][7][7][7];//後ろ3つはサイコロのTop,Front,Left\n\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tcost[a][b][c][d][e]=INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tmap=new int[h][w];\n\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}//for\n\t\t\ts[0]=sc.nextInt();\n\t\t\ts[1]=sc.nextInt();\n\t\t\tg[0]=sc.nextInt();\n\t\t\tg[1]=sc.nextInt();\n\t\t\tcost[s[0]][s[1]][1][2][4]=0;//最初のサイコロの向きは確定なので、これはコスト0にしておく\n\t\t\tSystem.out.println(dijkstra(cost, s[0], s[1], g[0], g[1], h, w));\n\t\t}\n\n\t}\n\t\n\tint dijkstra(int cost[][][][][],int sy,int sx,int gy,int gx,int h,int w){\n\t\tint x,y,t,f,l;\n\t\tboolean use[][][][][]=new boolean[h][w][7][7][7];\n\t\tfor(int a=0;a<h;a++){\n\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\tuse[a][b][c][d][e]=false;;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tx=y=t=f=l=-1;\n\t\t\t//まだ使ってないやつで、\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tfor(int c=1;c<7;c++){\n\t\t\t\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\t\t\t\tif(!use[a][b][c][d][e] && \n\t\t\t\t\t\t\t\t\t\t(x==-1 || cost[a][b][c][d][e]<cost[y][x][t][f][l])){\n\t\t\t\t\t\t\t\t\ty=a;x=b;t=c;f=d;l=e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x==-1) break;\n\t\t\t//System.out.println(y+\" \"+x);\n\t\t\tuse[y][x][t][f][l]=true;\n\n\t\t\t//今回の移動は4方向\n\t\t\t//それにあわせてのサイコロの目の変化にあわせて計算\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t//移動できるかどうかのチェック 壁チェック\n\t\t\t\tif(y+ny[i]<0 || x+nx[i]<0 || h<=y+ny[i] || w<=x+nx[i]) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][f][7-t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][f][7-t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-f)));\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][l][f][7-t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][l][f][7-t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*(7-l)));\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-f][t][l]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-f][t][l], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*f));\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tcost[y+ny[i]][x+nx[i]][7-l][f][t]=\n\t\t\t\t\t\t\tMath.min(cost[y+ny[i]][x+nx[i]][7-l][f][t], cost[y][x][t][f][l]+(map[y+ny[i]][x+nx[i]]*l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t//ゴールについたものの中で最小を見つける\n\t\tfor(int c=1;c<7;c++){\n\t\t\tfor(int d=1;d<7;d++){\n\t\t\t\tfor(int e=1;e<7;e++){\n\t\t\t\t\tans=Math.min(ans, cost[gy][gx][c][d][e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Rolling Dice\npublic class Main{\n\n\tstatic class Dice <T>{\n\t\tpublic T[] id;\n\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\n\t\tpublic T get(Face f){\n\t\t\treturn id[f.ordinal()];\n\t\t}\n\t\t\n\t\tpublic Dice<T> copy(){\n\t\t\treturn new Dice<T>(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t}\n\t\t\n\t\tpublic Dice() {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT[] tid = (T[])new Object[6];\n\t\t\tid = tid;\n\t\t}\n\t\t\n\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT[] tid = (T[])new Object[6];\n\t\t\tid = tid;\n\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t}\n\t\t\n\t\t//true: Xツ篠イツ陛サツ古シツづ可偲ィツ前ツづ可転ツつェツつキ\n\t\t//false: Xツ篠イツ陛サツ古シツづ可可慊づ可転ツつェツつキ\n\t\tvoid rollX(boolean isReverse) {\n\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t}\n\t\t\n\t\t//true: Yツ篠イツ陛サツ古シツづ可債カツづ鳴転ツつェツつキ\n\t\t//false: Yツ篠イツ陛サツ古シツづ可右ツづ鳴転ツつェツつキ\n\t\tvoid rollY(boolean isReverse) {\n\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t}\n\t\t\n\t\t//true: Zツ篠イツ陛サツ古シツづ可右ツづ鳴嘉アツつキ\n\t\t//false: Zツ篠イツ陛サツ古シツづ可債カツづ鳴嘉アツつキ\n\t\tvoid rollZ(boolean isReverse) {\n\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t}\n\t\t\n\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\tT tmp = id[w.ordinal()];\n\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\tid[z.ordinal()] = tmp;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(!(o instanceof Dice<?>))return false;\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tDice<T> d = (Dice<T>)o;\n\t\t\tfor(Face f : Face.values()){\n\t\t\t\tif(!id[f.ordinal()].equals(d.id[f.ordinal()])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tboolean isEquivalent(Dice<T> d) {\n\t\t\tfor(int i=0; i<6; i++) {\n\t\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\t\tif(this.equals(d)) return true;\n\t\t\t\t\trollZ(false);\n\t\t\t\t}\n\t\t\t\tif(i%2==1) rollY(false);\n\t\t\t\telse rollX(false);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tList<Dice<T>> getAllState(){\n\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\trollZ(false);\n\t\t\t\t}\n\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\telse rollX(false);\n\t\t\t}\n\t\t\treturn lst;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString str = \"\";\n\t\t\tfor(Face f : Face.values()){\n\t\t\t\tstr += id[f.ordinal()] + \" \";\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hash = 31;\n\t\t\tfor(Face f : Face.values()){\n\t\t\t\thash += hash*17+id[f.ordinal()].hashCode();\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\t}\n\n\tstatic int[][][] dist;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif(h==0&&w==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\tint si = sc.nextInt();\n\t\t\tint sj = sc.nextInt();\n\t\t\tint gi = sc.nextInt();\n\t\t\tint gj = sc.nextInt();\n\t\t\tDice<Integer> dd = new Dice<Integer>(1, 6, 2, 5, 3, 4);\n\t\t\tList<Dice<Integer>> d = dd.getAllState();\n\t\t\tdist = new int[h][w][24];\n\t\t\tfor(int[][] a:dist)for(int[] b:a)Arrays.fill(b, Integer.MAX_VALUE);\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]]-dist[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tdist[si][sj][0]=0;\n\t\t\tq.add(new int[]{si, sj, 0});\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tif(a[0]==gi&&a[1]==gj){\n\t\t\t\t\tmin = Math.min(min, dist[a[0]][a[1]][a[2]]);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = a[0] + move[k][0];\n\t\t\t\t\tint nj = a[1] + move[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\t\tDice<Integer> t = d.get(a[2]).copy();\n\t\t\t\t\t\tswitch(k){\n\t\t\t\t\t\tcase 0: t.rollX(true);break;\n\t\t\t\t\t\tcase 1: t.rollX(false);break;\n\t\t\t\t\t\tcase 2: t.rollY(false);break;\n\t\t\t\t\t\tcase 3: t.rollY(true);break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint index = -1;\n\t\t\t\t\t\tfor(int i=0;i<24;i++)if(t.equals(d.get(i))){index=i;break;}\n\t\t\t\t\t\tint v = dist[a[0]][a[1]][a[2]] + m[ni][nj]*t.get(Dice.Face.BOTTOM);\n\t\t\t\t\t\tif(v < dist[ni][nj][index]){\n\t\t\t\t\t\t\tdist[ni][nj][index] = v;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj,index});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tstatic int[][] move = {{1, 0},{-1,0},{0,1},{0,-1}};\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0&&d[1]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//ダイクストラ\n\t\t//　サイコロのエンコードがガバガバだが(Max:64*7+8*7+7=511)\n\t\t//  dp[H*W][enc(dice)]:最小コスト　を更新する\n\t\t\n\t\tint INF=(int)1e9;\n\t\tint dmax=64*7+8*7+7;\n\t\tint[][] dp=new int[H*W][];\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tdp[i]=new int[dmax+1];\n\t\t\tfor(int j=0;j<=dmax;j++)dp[i][j]=INF;\n\t\t}\n\t\t\n\t\tPriorityQueue<State> PQ=new PriorityQueue<State>();\n\t\t\n\t\tState Init=new State(0,Start[0]*W+Start[1],new Dice(1,7-2,3));\n\t\tdp[Init.V][Dice.Enc(Init.D)]=0;\n\t\t\n\t\tPQ.Push(Init);\n\t\t\n\t\twhile(!PQ.IsEmpty){\n\t\t\tState state=PQ.Top;PQ.Pop();\n\t\t\tint C=state.C;\n\t\t\tint V=state.V;\n\t\t\tDice D=state.D;\n//Console.Write(\"pop:C={0},R={1},C={2},Dice:\",C,V/W,V%W);\n//Console.WriteLine(\" T:{0},N:{1},E:{2},S:{3},W:{4},B:{5}\",D.T,D.N,D.E,D.S,D.W,D.B);\n\t\t\t//左\n\t\t\tif(V%W!=0){\n\t\t\t\tif(dp[V-1][Dice.Enc(Dice.RotL(D))]>dp[V][Dice.Enc(D)]+A[V/W][V%W-1]*Dice.RotL(D).B){\n\t\t\t\t\tdp[V-1][Dice.Enc(Dice.RotL(D))]=dp[V][Dice.Enc(D)]+A[V/W][V%W-1]*Dice.RotL(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V-1][Dice.Enc(Dice.RotL(D))],V-1,Dice.RotL(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//右\n\t\t\tif(V%W!=W-1){\n\t\t\t\tif(dp[V+1][Dice.Enc(Dice.RotR(D))]>dp[V][Dice.Enc(D)]+A[V/W][V%W+1]*Dice.RotR(D).B){\n\t\t\t\t\tdp[V+1][Dice.Enc(Dice.RotR(D))]=dp[V][Dice.Enc(D)]+A[V/W][V%W+1]*Dice.RotR(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V+1][Dice.Enc(Dice.RotR(D))],V+1,Dice.RotR(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//下\n\t\t\tif(V/W!=H-1){\n\t\t\t\tif(dp[V+W][Dice.Enc(Dice.RotD(D))]>dp[V][Dice.Enc(D)]+A[V/W+1][V%W]*Dice.RotD(D).B){\n\t\t\t\t\tdp[V+W][Dice.Enc(Dice.RotD(D))]=dp[V][Dice.Enc(D)]+A[V/W+1][V%W]*Dice.RotD(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V+W][Dice.Enc(Dice.RotD(D))],V+W,Dice.RotD(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//上\n\t\t\tif(V/W!=0){\n\t\t\t\tif(dp[V-W][Dice.Enc(Dice.RotU(D))]>dp[V][Dice.Enc(D)]+A[V/W-1][V%W]*Dice.RotU(D).B){\n\t\t\t\t\tdp[V-W][Dice.Enc(Dice.RotU(D))]=dp[V][Dice.Enc(D)]+A[V/W-1][V%W]*Dice.RotU(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V-W][Dice.Enc(Dice.RotU(D))],V-W,Dice.RotU(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint Min=INF;\n\t\tfor(int i=0;i<=dmax;i++){\n\t\t\tMin=Math.Min(Min,dp[Goal[0]*W+Goal[1]][i]);\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Min);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tclass State:IComparable<State>{\n\t\tpublic int C;\n\t\tpublic int V;\n\t\tpublic Dice D;\n\t\tpublic State(int c_,int v_,Dice d_){\n\t\t\tC=c_;V=v_;D=d_;\n\t\t}\n\t\tpublic int CompareTo(State other){\n\t\t\t//比較を逆順にしておく\n\t\t\treturn this.C>other.C?-1:this.C<other.C?1:0;\n\t\t}\n\t}\n\t\t\n\t\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tint[][] A;\n\tint[] Start;\n\tint[] Goal;\n\tpublic Sol(int[] d_){\n\t\tH=d_[0];W=d_[1];\n\t\tA=new int[H][];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tA[i]=ria();\n\t\t}\n\t\tStart=ria();\n\t\tGoal=ria();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}\n\n\n\n\n\n\n\nclass Dice{\n\t\n\tpublic int T;\n\tpublic int B;\n\tpublic int N;\n\tpublic int E;\n\tpublic int W;\n\tpublic int S;\n\t\n\tpublic Dice(int t_,int n_,int e_){\n\t\tT=t_;\n\t\tN=n_;\n\t\tB=7-T;\n\t\tS=7-N;\n\t\tE=e_;\n\t\tW=7-E;\n\t}\n\n\tpublic static int Enc(Dice D){\n\t\treturn 64*D.T+8*D.N+D.E;\n\t}\n\tpublic static Dice Dec(int N){\n\t\tint top=N/64;\n\t\tint north=(N%64)/8;\n\t\tint east=N%8;\n\t\treturn new Dice(top,north,east);\n\t}\n\t\n\tpublic static Dice RotR(Dice D){\n\t\treturn new Dice(D.W,D.N,D.T);\n\t}\n\tpublic static Dice RotL(Dice D){\n\t\treturn new Dice(D.E,D.N,D.B);\n\t}\n\tpublic static Dice RotU(Dice D){\n\t\treturn new Dice(D.S,D.T,D.E);\n\t}\n\tpublic static Dice RotD(Dice D){\n\t\treturn new Dice(D.N,D.B,D.E);\n\t}\n}\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic bool Contains(T elem){\n\t\treturn this.buffer.Contains(elem);\n\t}\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n\t\n\tpublic T this[int i]{\n\t\tget{return this.buffer[i];}\n\t}\n\tpublic bool IsEmpty{\n\t\tget{return this.Count==0;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0&&d[1]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//ダイクストラ\n\t\t//　サイコロのエンコードがガバガバだが(Max:64*7+8*7+7=511)\n\t\t//  dp[H*W][enc(dice)]:最小コスト　を更新する\n\t\t\n\t\tint INF=(int)1e9;\n\t\tint dmax=64*7+8*7+7;\n\t\tint[][] dp=new int[H*W][];\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tdp[i]=new int[dmax+1];\n\t\t\tfor(int j=0;j<=dmax;j++)dp[i][j]=INF;\n\t\t}\n\t\t\n\t\tPriorityQueue<State> PQ=new PriorityQueue<State>();\n\t\t\n\t\tState Init=new State(0,Start[0]*W+Start[1],new Dice(1,7-2,3));\n\t\tdp[Init.V][Dice.Enc(Init.D)]=0;\n\t\t\n\t\tPQ.Push(Init);\n\t\t\n\t\twhile(!PQ.IsEmpty){\n\t\t\tState state=PQ.Top;PQ.Pop();\n\t\t\tint C=state.C;\n\t\t\tint V=state.V;\n\t\t\tDice D=state.D;\n//Console.Write(\"pop:C={0},R={1},C={2},Dice:\",C,V/W,V%W);\n//Console.WriteLine(\" T:{0},N:{1},E:{2},S:{3},W:{4},B:{5}\",D.T,D.N,D.E,D.S,D.W,D.B);\n\t\t\t//左\n\t\t\tif(V%W!=0){\n\t\t\t\tif(dp[V-1][Dice.Enc(Dice.RotL(D))]>C+A[V/W][V%W-1]*Dice.RotL(D).B){\n\t\t\t\t\tdp[V-1][Dice.Enc(Dice.RotL(D))]=C+A[V/W][V%W-1]*Dice.RotL(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V-1][Dice.Enc(Dice.RotL(D))],V-1,Dice.RotL(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//右\n\t\t\tif(V%W!=W-1){\n\t\t\t\tif(dp[V+1][Dice.Enc(Dice.RotR(D))]>C+A[V/W][V%W+1]*Dice.RotR(D).B){\n\t\t\t\t\tdp[V+1][Dice.Enc(Dice.RotR(D))]=C+A[V/W][V%W+1]*Dice.RotR(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V+1][Dice.Enc(Dice.RotR(D))],V+1,Dice.RotR(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//下\n\t\t\tif(V/W!=H-1){\n\t\t\t\tif(dp[V+W][Dice.Enc(Dice.RotD(D))]>C+A[V/W+1][V%W]*Dice.RotD(D).B){\n\t\t\t\t\tdp[V+W][Dice.Enc(Dice.RotD(D))]=C+A[V/W+1][V%W]*Dice.RotD(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V+W][Dice.Enc(Dice.RotD(D))],V+W,Dice.RotD(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//上\n\t\t\tif(V/W!=0){\n\t\t\t\tif(dp[V-W][Dice.Enc(Dice.RotU(D))]>C+A[V/W-1][V%W]*Dice.RotU(D).B){\n\t\t\t\t\tdp[V-W][Dice.Enc(Dice.RotU(D))]=C+A[V/W-1][V%W]*Dice.RotU(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V-W][Dice.Enc(Dice.RotU(D))],V-W,Dice.RotU(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint Min=INF;\n\t\tfor(int i=0;i<=dmax;i++){\n\t\t\tMin=Math.Min(Min,dp[Goal[0]*W+Goal[1]][i]);\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Min);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tclass State:IComparable<State>{\n\t\tpublic int C;\n\t\tpublic int V;\n\t\tpublic Dice D;\n\t\tpublic State(int c_,int v_,Dice d_){\n\t\t\tC=c_;V=v_;D=d_;\n\t\t}\n\t\tpublic int CompareTo(State other){\n\t\t\t//比較を逆順にしておく\n\t\t\treturn this.C>other.C?-1:this.C<other.C?1:0;\n\t\t}\n\t}\n\t\t\n\t\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tint[][] A;\n\tint[] Start;\n\tint[] Goal;\n\tpublic Sol(int[] d_){\n\t\tH=d_[0];W=d_[1];\n\t\tA=new int[H][];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tA[i]=ria();\n\t\t}\n\t\tStart=ria();\n\t\tGoal=ria();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}\n\n\n\n\n\n\n\nclass Dice{\n\t\n\tpublic int T;\n\tpublic int B;\n\tpublic int N;\n\tpublic int E;\n\tpublic int W;\n\tpublic int S;\n\t\n\tpublic Dice(int t_,int n_,int e_){\n\t\tT=t_;\n\t\tN=n_;\n\t\tB=7-T;\n\t\tS=7-N;\n\t\tE=e_;\n\t\tW=7-E;\n\t}\n\n\tpublic static int Enc(Dice D){\n\t\treturn 64*D.T+8*D.N+D.E;\n\t}\n\tpublic static Dice Dec(int N){\n\t\tint top=N/64;\n\t\tint north=(N%64)/8;\n\t\tint east=N%8;\n\t\treturn new Dice(top,north,east);\n\t}\n\t\n\tpublic static Dice RotR(Dice D){\n\t\treturn new Dice(D.W,D.N,D.T);\n\t}\n\tpublic static Dice RotL(Dice D){\n\t\treturn new Dice(D.E,D.N,D.B);\n\t}\n\tpublic static Dice RotU(Dice D){\n\t\treturn new Dice(D.S,D.T,D.E);\n\t}\n\tpublic static Dice RotD(Dice D){\n\t\treturn new Dice(D.N,D.B,D.E);\n\t}\n}\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic bool Contains(T elem){\n\t\treturn this.buffer.Contains(elem);\n\t}\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n\t\n\tpublic T this[int i]{\n\t\tget{return this.buffer[i];}\n\t}\n\tpublic bool IsEmpty{\n\t\tget{return this.Count==0;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0&&d[1]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t//ダイクストラ\n\t\t//　サイコロのエンコードがガバガバだが(Max:64*7+8*7+7=511)\n\t\t//  dp[H*W][enc(dice)]:最小コスト　を更新する\n\t\t\n\t\tint INF=(int)1e9;\n\t\tint dmax=64*7+8*7+7;\n\t\tint[][] dp=new int[H*W][];\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tdp[i]=new int[dmax+1];\n\t\t\tfor(int j=0;j<=dmax;j++)dp[i][j]=INF;\n\t\t}\n\t\t\n\t\tPriorityQueue<State> PQ=new PriorityQueue<State>();\n\t\t\n\t\tState Init=new State(0,Start[0]*W+Start[1],new Dice(1,7-2,3));\n\t\tdp[Init.V][Dice.Enc(Init.D)]=0;\n\t\t\n\t\tPQ.Push(Init);\n\t\t\n\t\twhile(!PQ.IsEmpty){\n\t\t\tState state=PQ.Top;PQ.Pop();\n\t\t\tint C=state.C;\n\t\t\tint V=state.V;\n\t\t\tDice D=state.D;\n//Console.Write(\"pop:C={0},R={1},C={2},Dice:\",C,V/W,V%W);\n//Console.WriteLine(\" T:{0},N:{1},E:{2},S:{3},W:{4},B:{5}\",D.T,D.N,D.E,D.S,D.W,D.B);\n\t\t\t//左\n\t\t\tif(V%W!=0){\n\t\t\t\tif(dp[V-1][Dice.Enc(Dice.RotL(D))]>dp[V][Dice.Enc(D)]+A[V/W][V%W-1]*Dice.RotL(D).B){\n\t\t\t\t\tdp[V-1][Dice.Enc(Dice.RotL(D))]=dp[V][Dice.Enc(D)]+A[V/W][V%W-1]*Dice.RotL(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V-1][Dice.Enc(Dice.RotL(D))],V-1,Dice.RotL(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//右\n\t\t\tif(V%W!=W-1){\n\t\t\t\tif(dp[V+1][Dice.Enc(Dice.RotR(D))]>dp[V][Dice.Enc(D)]+A[V/W][V%W+1]*Dice.RotR(D).B){\n\t\t\t\t\tdp[V+1][Dice.Enc(Dice.RotR(D))]=dp[V][Dice.Enc(D)]+A[V/W][V%W+1]*Dice.RotR(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V+1][Dice.Enc(Dice.RotR(D))],V+1,Dice.RotR(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//下\n\t\t\tif(V/W!=H-1){\n\t\t\t\tif(dp[V+W][Dice.Enc(Dice.RotD(D))]>dp[V][Dice.Enc(D)]+A[V/W+1][V%W]*Dice.RotD(D).B){\n\t\t\t\t\tdp[V+W][Dice.Enc(Dice.RotD(D))]=dp[V][Dice.Enc(D)]+A[V/W+1][V%W]*Dice.RotD(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V+W][Dice.Enc(Dice.RotD(D))],V+W,Dice.RotD(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//上\n\t\t\tif(V/W!=0){\n\t\t\t\tif(dp[V-W][Dice.Enc(Dice.RotU(D))]>dp[V][Dice.Enc(D)]+A[V/W-1][V%W]*Dice.RotU(D).B){\n\t\t\t\t\tdp[V-W][Dice.Enc(Dice.RotU(D))]=dp[V][Dice.Enc(D)]+A[V/W-1][V%W]*Dice.RotU(D).B;\n\t\t\t\t\tPQ.Push(new State(dp[V-W][Dice.Enc(Dice.RotU(D))],V-W,Dice.RotU(D)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint Min=INF;\n\t\tfor(int i=0;i<=dmax;i++){\n\t\t\tMin=Math.Min(Min,dp[Goal[0]*W+Goal[1]][i]);\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Min);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tclass State:IComparable<State>{\n\t\tpublic int C;\n\t\tpublic int V;\n\t\tpublic Dice D;\n\t\tpublic State(int c_,int v_,Dice d_){\n\t\t\tC=c_;V=v_;D=d_;\n\t\t}\n\t\tpublic int CompareTo(State other){\n\t\t\t//比較を逆順にしておく\n\t\t\treturn this.C>other.C?-1:this.C<other.C?1:0;\n\t\t}\n\t}\n\t\t\n\t\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tint[][] A;\n\tint[] Start;\n\tint[] Goal;\n\tpublic Sol(int[] d_){\n\t\tH=d_[0];W=d_[1];\n\t\tA=new int[H][];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tA[i]=ria();\n\t\t}\n\t\tStart=ria();\n\t\tGoal=ria();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}\n\n\n\n\n\n\n\nclass Dice{\n\t\n\tpublic int T;\n\tpublic int B;\n\tpublic int N;\n\tpublic int E;\n\tpublic int W;\n\tpublic int S;\n\t\n\tpublic Dice(int t_,int n_,int e_){\n\t\tT=t_;\n\t\tN=n_;\n\t\tB=7-T;\n\t\tS=7-N;\n\t\tE=e_;\n\t\tW=7-E;\n\t}\n\n\tpublic static int Enc(Dice D){\n\t\treturn 64*D.T+8*D.N+D.E;\n\t}\n\tpublic static Dice Dec(int N){\n\t\tint top=N/64;\n\t\tint north=(N%64)/8;\n\t\tint east=N%8;\n\t\treturn new Dice(top,north,east);\n\t}\n\t\n\tpublic static Dice RotR(Dice D){\n\t\treturn new Dice(D.W,D.N,D.T);\n\t}\n\tpublic static Dice RotL(Dice D){\n\t\treturn new Dice(D.E,D.N,D.B);\n\t}\n\tpublic static Dice RotU(Dice D){\n\t\treturn new Dice(D.S,D.T,D.E);\n\t}\n\tpublic static Dice RotD(Dice D){\n\t\treturn new Dice(D.N,D.B,D.E);\n\t}\n}\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic bool Contains(T elem){\n\t\treturn this.buffer.Contains(elem);\n\t}\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n\t\n\tpublic T this[int i]{\n\t\tget{return this.buffer[i];}\n\t}\n\tpublic bool IsEmpty{\n\t\tget{return this.Count==0;}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### subroutines\n\ndef gen_dice\n  dice = {}\n  st = 123\n  used = {}\n  used[st] = true\n  q = [st]\n\n  while ! q.empty?\n    u = q.shift\n\n    u0 = u / 100\n    u1 = (u / 10) % 10\n    u2 = u % 10\n\n    dice[u] = [\n      (7 - u2) * 100 + u1 * 10 + u0,\n      u1 * 100 + (7 - u0) * 10 + u2,\n      u2 * 100 + u1 * 10 + (7 - u0),\n      (7 - u1) * 100 + u0 * 10 + u2\n    ]\n\n    for v in dice[u]\n      if ! used[v]\n        used[v] = true\n        q << v\n      end\n    end\n  end\n\n  dice\nend\n\n### main\n\ndice = gen_dice\n#p dice\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0 && w == 0\n\n  mtx = h.times.map{gets.split.map(&:to_i)}\n  sy, sx = gets.split.map(&:to_i)\n  gy, gx = gets.split.map(&:to_i)\n  #p mtx\n  #p [sx, sy]\n  #p [gx, gy]\n\n  sid = sy * w + sx\n  gid = gy * w + gx\n\n  dists = Hash.new{MAX_INT}\n  min_dist = MAX_INT\n\n  st = sid * 1000 + 123\n  dists[st] = 0\n  q = [st]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a] <=> dists[b]}\n    q.delete(u)\n\n    du = dists[u]\n\n    udc = u % 1000\n    uid = u / 1000\n    uy = uid / w\n    ux = uid % w\n    #p [udc, ux, uy, du]\n\n    if uid == gid\n      min_dist = du if min_dist > du\n      next\n    end\n\n    for i in (0..3)\n      vx = ux + DXYS[i][0]\n      vy = uy + DXYS[i][1]\n\n      if vx >= 0 && vx < w && vy >= 0 && vy < h\n        vdc = dice[udc][i]\n        vid = vy * w + vx\n        v = vid * 1000 + vdc\n\n        dv = dists[v]\n        ndv = du + (7 - vdc / 100) * mtx[vy][vx]\n\n        if dv > ndv\n          dists[v] = ndv\n          if dv >= MAX_INT\n            q << v\n          end\n        end\n      end\n    end\n  end\n\n  puts min_dist\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nclass Dice {\n    int F[6];\n    this(int[] F) { this.F = F.dup; }\n    Dice dup() { return new Dice(F); }\n    override bool opEquals(Object o) { \n        auto d = cast(Dice)o;\n        return F == d.F;\n    }\n    void roll(int d) {\n        const R = [\n            [1, 2, 4, 3], /* 0 - 5軸 */\n            [0, 2, 5, 3], /* 1 - 4軸 */\n            [0, 1, 5, 4]  /* 2 - 3軸 */\n        ];\n        auto p = F[ R[d][0] ];\n        foreach (i; 0 .. 3) {\n            F[ R[d][i] ] = F[ R[d][(i + 1) % 4] ];\n        }\n        F[ R[d][3] ] = p;\n    }\n    void roll(int d, int n) {\n        foreach (_; 0 .. n) roll(d);\n    }\n    override size_t toHash() const {\n        size_t ret = 0;\n        foreach (i; 0 .. 6) {\n            ret = ret * 10 + F[i];\n        }\n        return ret;\n    }\n    override int opCmp(Object o ) const {\n        auto d = cast(Dice)o;\n        return cast(int)toHash() - cast(int)o.toHash();\n    }\n    override string toString() const {\n        return \"(\" ~ F[].map!(to!string).join(\" \") ~ \")\";\n    }\n    static Dice[] allStates(Dice d) {\n        Dice[] ret;\n        foreach (i; 0 .. 6) {\n            d.roll(i % 2);\n            foreach (j; 0 .. 4) {\n                d.roll(2);\n                ret ~= d.dup;\n            }\n        }\n        return ret;\n    }\n}\n\nint H, W;\nint[][] F;\nint sx, sy, gx, gy;\nbool input() {\n    scanf(\"%d %d\\n\", &H, &W);\n    if (H == 0 && W == 0) return false;\n    F = new int[][](H, W);\n    foreach (i; 0 .. H) foreach (j; 0 .. W) scanf(\"%d\", &F[i][j]);\n    scanf(\"%d %d %d %d\", &sy, &sx, &gy, &gx);\n    return true;\n}\n\nconst dy  = [-1, 0, 1, 0],\n      dx  = [0, 1, 0, -1],\n      dir = [ [2, 1], [1, 3], [2, 3], [1, 1] ];\n\nstruct State {\n    int id, y, x, cost;\n}\n\nconst INF = 1 << 28;\n\nvoid solve() {\n    auto init = new Dice([1, 2, 3, 4, 5, 6]);\n    int[Dice] M; int id = 0;\n    foreach (state; Dice.allStates(init)) {\n        M[state] = id++;\n    }\n    auto N = new Dice[24];\n    foreach (k, v; M) { N[v] = k; }\n\n    BinaryHeap!(Array!State, \"a.cost > b.cost\") PQ;\n    PQ.insert(State(M[init], sy, sx, 0));\n    auto D = new int[][][](24, H, W);\n    foreach (i; 0 .. 24) foreach (j; 0 .. H) D[i][j][] = INF;\n    D[M[init]][sy][sx] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (i; 0 .. 4) {\n            auto ny = s.y + dy[i],\n                 nx = s.x + dx[i];\n            if (ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n            auto nd = N[s.id].dup;\n            nd.roll(dir[i][0], dir[i][1]);\n            auto ncost = nd.F[5] * F[ny][nx] + s.cost;\n            auto nid = M[nd];\n            if (D[nid][ny][nx] > ncost) {\n                D[nid][ny][nx] = ncost;\n                PQ.insert(State(nid, ny, nx, ncost));\n            }\n        }\n    }\n    int ans = INF;\n    foreach (i; 0 .. 24) {\n        ans = min(ans, D[i][gy][gx]);\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nclass Dice {\n    int F[6];\n    this(int[] F) { this.F = F.dup; }\n    Dice dup() { return new Dice(F); }\n    override bool opEquals(Object o) { \n        auto d = cast(Dice)o;\n        return F == d.F;\n    }\n    void roll(int d) {\n        const R = [\n            [1, 2, 4, 3], /* 0 - 5軸 */\n            [0, 2, 5, 3], /* 1 - 4軸 */\n            [0, 1, 5, 4]  /* 2 - 3軸 */\n        ];\n        auto p = F[ R[d][0] ];\n        foreach (i; 0 .. 3) {\n            F[ R[d][i] ] = F[ R[d][(i + 1) % 4] ];\n        }\n        F[ R[d][3] ] = p;\n    }\n    void roll(int d, int n) {\n        foreach (_; 0 .. n) roll(d);\n    }\n    override size_t toHash() const {\n        size_t ret = 0;\n        foreach (i; 0 .. 6) {\n            ret = ret * 10 + F[i];\n        }\n        return ret;\n    }\n    override string toString() const {\n        return \"(\" ~ F[].map!(to!string).join(\" \") ~ \")\";\n    }\n    static Dice[] allStates(Dice d) {\n        Dice[] ret;\n        foreach (i; 0 .. 6) {\n            d.roll(i % 2);\n            foreach (j; 0 .. 4) {\n                d.roll(2);\n                ret ~= d.dup;\n            }\n        }\n        return ret;\n    }\n}\n\nint H, W;\nint[][] F;\nint sx, sy, gx, gy;\nbool input() {\n    scanf(\"%d %d\\n\", &H, &W);\n    if (H == 0 && W == 0) return false;\n    F = new int[][](H, W);\n    foreach (i; 0 .. H) foreach (j; 0 .. W) scanf(\"%d\", &F[i][j]);\n    scanf(\"%d %d %d %d\", &sy, &sx, &gy, &gx);\n    return true;\n}\n\nconst dy  = [-1, 0, 1, 0],\n      dx  = [0, 1, 0, -1],\n      dir = [ [2, 1], [1, 3], [2, 3], [1, 1] ];\n\nstruct State {\n    int id, y, x, cost;\n}\n\nconst INF = 1 << 28;\n\nvoid solve() {\n    auto init = new Dice([1, 2, 3, 4, 5, 6]);\n    int[Dice] M; int id = 0;\n    foreach (state; Dice.allStates(init)) {\n        M[state] = id++;\n    }\n    auto N = new Dice[24];\n    foreach (k, v; M) { N[v] = k; }\n\n    BinaryHeap!(Array!State, \"a.cost > b.cost\") PQ;\n    PQ.insert(State(M[init], sy, sx, 0));\n    auto D = new int[][][](24, H, W);\n    foreach (i; 0 .. 24) foreach (j; 0 .. H) D[i][j][] = INF;\n    D[M[init]][sy][sx] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        ///writeln(s);\n        foreach (i; 0 .. 4) {\n            auto ny = s.y + dy[i],\n                 nx = s.x + dx[i];\n            if (ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n            auto nd = N[s.id].dup;\n            nd.roll(dir[i][0], dir[i][1]);\n            auto ncost = nd.F[5] * F[ny][nx] + s.cost;\n            auto nid = M[nd];\n            if (D[nid][ny][nx] > ncost) {\n                D[nid][ny][nx] = ncost;\n                PQ.insert(State(nid, ny, nx, ncost));\n            }\n        }\n    }\n    int ans = INF;\n    foreach (i; 0 .. 24) {\n        ans = min(ans, D[i][gy][gx]);\n    }\n    writeln(ans);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import heapq\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nwhile True:\n  h, w = map(int, input().split())\n  if h == 0:\n    break\n  mp = [[-1] + list(map(int, input().split())) +[-1] for _ in range(h)]\n  mp.insert(0, [-1] * (w + 2))\n  mp.append([-1] * (w + 2))\n  sy, sx = map(int, input().split())\n  gy, gx = map(int, input().split())\n  sy += 1\n  sx += 1\n  gy += 1\n  gx += 1\n  que = []\n  heappush(que, (0, sx, sy, 1, 2, 3))\n  dic = {}\n  dic[(sx, sy, 1, 2, 3)] = 0\n  vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n  def spin(top, south, east, direct):\n    if direct == (1, 0):\n      return 7 - east, south, top\n    if direct == (0, -1):\n      return south, 7 - top, east\n    if direct == (-1, 0):\n      return east, south, 7 - top\n    if direct == (0, 1):\n      return 7 - south, top, east\n  while que:\n    pena, x, y, top, south, east = heappop(que)\n    if (x, y) == (gx, gy):\n      print(pena)\n      break\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if mp[ny][nx] == -1:\n        continue\n      new_top, new_south, new_east = spin(top, south, east, (dx, dy))\n      new_pena = pena + (7 - new_top) * mp[ny][nx]\n      if (nx, ny, new_top, new_south, new_east) not in dic:\n        dic[(nx, ny, new_top, new_south, new_east)] = new_pena\n        heappush(que, (new_pena, nx, ny, new_top, new_south, new_east))\n"
  },
  {
    "language": "Python",
    "code": "T, S, E, W, N, B = range(6)\n\nclass Dice:\n\n    def __init__(self):\n        self.state = list(range(6))\n\n    def __eq__(self, dice):\n        return self.state == dice.state\n\n    def __gt__(self, dice):\n        return self.state > dice.state\n\n    def copy(self):\n        dice = Dice()\n        dice.state = [x for x in self.state]\n        return dice\n\n    def _turn(self, turn):\n        k = self.state[turn[-1]]\n        for i in range(4):\n            self.state[turn[i]], k = k, self.state[turn[i]]\n\n    def go_south(self):\n        turn = [T, S, B, N]\n        self._turn(turn)\n\n    def go_north(self):\n        turn = [N, B, S, T]\n        self._turn(turn)\n\n    def go_east(self):\n        turn = [T, E, B, W]\n        self._turn(turn)\n\n    def go_west(self):\n        turn = [T, W, B, E]\n        self._turn(turn)\n\n    def north(self):\n        return self.state[N]\n\n    def south(self):\n        return self.state[S]\n\n    def east(self):\n        return self.state[E]\n\n    def west(self):\n        return self.state[W]\n\n    def bottom(self):\n        return self.state[B]\n\n    def top(self):\n        return self.state[T]\n\n    def goto(self, n):\n        func = [self.go_west, self.go_north, self.go_east, self.go_south]\n        func[n]()\n\n    def show(self):\n        d = list(\"TSEWNB\")\n        for x, s in zip(d, self.state):\n            print(x + \" : {}\".format(s))\n\n\nimport heapq\n\nINF = 10**9\nif __name__ == \"__main__\":\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    while True:\n        dp = [[[[INF for _ in range(6)] for i in range(6)] for j in range(10)] for k in range(10)]\n        h, w = map(int, input().split())\n        if h == 0:\n            break\n\n        cost = [list(map(int, input().split())) for _ in range(h)]\n        sy, sx = map(int, input().split())\n        gy, gx = map(int, input().split())\n        q = []\n        dice = Dice()\n        heapq.heappush(q, [0, sx, sy, dice])\n        dp[sy][sx][dice.bottom()][dice.east()]\n\n        ans = INF+1\n        while q:\n            c, x, y, dice = heapq.heappop(q)\n            if x == gx and y == gy:\n                ans = min(ans, c)\n                continue\n            if c >= ans:\n                continue\n            else:\n                for i in range(4):\n                    ddx, ddy = dx[i], dy[i]\n                    if x + ddx >= w or x + ddx < 0 or y + ddy >= h or y + ddy < 0:\n                        continue\n                    else:\n                        d = dice.copy()\n                        d.goto(i)\n\n                        new_cost = c + (d.bottom()+1)*cost[y+ddy][x+ddx]\n                        if dp[y+ddy][x+ddx][d.bottom()][d.east()] > new_cost:\n                            dp[y+ddy][x+ddx][d.bottom()][d.east()] = new_cost\n                            heapq.heappush(q, [new_cost, x+ddx, y+ddy, d])\n        print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "T, S, E, W, N, B = range(6)\n\nclass Dice:\n\n    def __init__(self):\n        self.state = list(range(1,7))\n\n    def copy(self):\n        dice = Dice()\n        dice.state = [x for x in self.state]\n        return dice\n\n    def _turn(self, turn):\n        k = self.state[turn[-1]]\n        for i in range(4):\n            self.state[turn[i]], k = k, self.state[turn[i]]\n\n    def go_south(self):\n        turn = [T, S, B, N]\n        self._turn(turn)\n\n    def go_north(self):\n        turn = [N, B, S, T]\n        self._turn(turn)\n\n    def go_east(self):\n        turn = [T, E, B, W]\n        self._turn(turn)\n\n    def go_west(self):\n        turn = [T, W, B, E]\n        self._turn(turn)\n\n    def north(self):\n        return self.state[N]\n\n    def south(self):\n        return self.state[S]\n\n    def east(self):\n        return self.state[E]\n\n    def west(self):\n        return self.state[W]\n\n    def bottom(self):\n        return self.state[B]\n\n    def top(self):\n        return self.state[T]\n\n    def goto(self, n):\n        func = [self.go_west, self.go_north, self.go_east, self.go_south]\n        func[n]()\n\n    def show(self):\n        d = list(\"TSEWNB\")\n        for x, s in zip(d, self.state):\n            print(x + \" : {}\".format(s))\n\n\nimport heapq\n\nINF = 10**9\nif __name__ == \"__main__\":\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    while True:\n        dp = [[[[INF for _ in range(7)] for i in range(7)] for j in range(10)] for k in range(10)]\n        h, w = map(int, input().split())\n        if h == 0:\n            break\n\n        cost = [list(map(int, input().split())) for _ in range(h)]\n        sy, sx = map(int, input().split())\n        gy, gx = map(int, input().split())\n        q = []\n        dice = Dice()\n        heapq.heappush(q, [0, sx, sy, dice])\n        dp[sy][sx][dice.bottom()][dice.east()]\n\n        ans = INF+1\n        while q:\n            c, x, y, dice = heapq.heappop(q)\n            if x == gx and y == gy:\n                ans = min(ans, c)\n                continue\n            if c >= ans:\n                continue\n            else:\n                for i in range(4):\n                    ddx, ddy = dx[i], dy[i]\n                    if x + ddx >= w or x + ddx < 0 or y + ddy >= h or y + ddy < 0:\n                        continue\n                    else:\n                        d = dice.copy()\n                        d.goto(i)\n\n                        new_cost = c + d.bottom()*cost[y+ddy][x+ddx]\n                        if dp[y+ddy][x+ddx][d.bottom()][d.east()] > new_cost:\n                            dp[y+ddy][x+ddx][d.bottom()][d.east()] = new_cost\n                            heapq.heappush(q, [new_cost, x+ddx, y+ddy, d])\n        print(ans)\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet};\nuse std::fmt::{Display, Formatter, Error};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\npub struct Dice {\n    top: usize, south: usize, east: usize\n}\nimpl Default for Dice {\n    fn default() -> Self {\n        Dice{ top: 1, south: 2, east: 3}\n    }\n}\nimpl Dice {\n    fn bottom(&self) -> i32 {\n        7 - self.top as i32\n    }\n    fn rotate_north(&self) -> Dice {\n        Dice{ top: self.south, south: 7 - self.top, east: self.east }\n    }\n    fn rotate_south(&self) -> Dice {\n        Dice{ top: 7 - self.south, south: self.top, east: self.east }\n    }\n    fn rotate_east(&self) -> Dice {\n        Dice{ top: 7 - self.east, south: self.south, east: self.top }\n    }\n    fn rotate_wast(&self) -> Dice {\n        Dice{ top: self.east, south: self.south, east: 7 - self.top }\n    }\n}\nstruct ValueWithKey<V, K> {\n    value: V, key: K\n}\nimpl <V, K: Ord> Ord for ValueWithKey<V, K> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.key.cmp(&self.key)\n    }\n}\nimpl <V, K: PartialOrd> PartialOrd for ValueWithKey<V, K> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        other.key.partial_cmp(&self.key)\n    }\n}\nimpl <V, K: PartialEq> PartialEq for ValueWithKey<V, K> {\n    fn eq(&self, other: &Self) -> bool {\n        other.key.eq(&self.key)\n    }\n}\nimpl <V, K: Eq> Eq for ValueWithKey<V, K> {}\nstruct Coordinate {\n    x: usize, y: usize\n}\nfn main(){\n    loop {\n        let_all!(h: usize, w: usize);\n        if h == 0 && w == 0 {\n            return\n        }\n        let mut state: Vec<Vec<i32>> = Vec::with_capacity(h);\n        for _ in 0 .. h {\n            state.push(read_line!(' '; i32));\n        }\n        let mut memo = vec![vec![vec![vec![std::i32::MAX;7];7];w];h];\n        let_all!(sy: usize, sx: usize);\n        let_all!(gy: usize, gx: usize);\n        let mut queue = BinaryHeap::new();\n        memo[sy][sx][1][2] = 0;\n        queue.push(ValueWithKey{value: (Dice::default(), Coordinate{x: sx, y: sy}), key: 0});\n        while let Some(ValueWithKey{value: (dice, Coordinate{x:x, y:y}), key: cost}) = queue.pop() {\n            if x == gx && y == gy {\n                println!(\"{}\", cost);\n                break\n            }\n            if memo[y][x][dice.top][dice.south] == cost {\n                if y > 0 {\n                    let next = dice.rotate_north();\n                    if memo[y - 1][x][next.top][next.south] > cost + state[y - 1][x] * next.bottom() {\n                        memo[y - 1][x][next.top][next.south] = cost + state[y - 1][x] * next.bottom();\n                        queue.push(ValueWithKey{value: (next, Coordinate{x: x, y: y - 1}), key: memo[y - 1][x][next.top][next.south]});\n                    }\n                }\n                if y + 1 < h {\n                   let next = dice.rotate_south();\n                    if memo[y + 1][x][next.top][next.south] > cost + state[y + 1][x] * next.bottom() {\n                        memo[y + 1][x][next.top][next.south] = cost + state[y + 1][x] * next.bottom();\n                        queue.push(ValueWithKey{value: (next, Coordinate{x: x, y: y + 1}), key: memo[y + 1][x][next.top][next.south]});\n                    }\n                }\n                if x > 0 {\n                    let next = dice.rotate_wast();\n                    if memo[y][x - 1][next.top][next.south] > cost + state[y][x - 1] * next.bottom() {\n                        memo[y][x - 1][next.top][next.south] = cost + state[y][x - 1] * next.bottom();\n                        queue.push(ValueWithKey{value: (next, Coordinate{x: x - 1, y: y}), key: memo[y][x - 1][next.top][next.south]});\n                    }\n                }\n                if x + 1 < w {\n                    let next = dice.rotate_east();\n                    if memo[y][x + 1][next.top][next.south] > cost + state[y][x + 1] * next.bottom() {\n                        memo[y][x + 1][next.top][next.south] = cost + state[y][x + 1] * next.bottom();\n                        queue.push(ValueWithKey{value: (next, Coordinate{x: x + 1, y: y}), key: memo[y][x + 1][next.top][next.south]});\n                    }\n                }\n            }\n        }\n    }\n}\n"
  }
]