[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ROWS 12\n#define COLS 6\n\ntypedef struct {\n    int x, y;\n} Position;\n\nchar grid[ROWS][COLS];\nint visited[ROWS][COLS];\nPosition queue[ROWS * COLS];\nint front, rear;\n\nvoid enqueue(int x, int y) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    rear++;\n}\n\nPosition dequeue() {\n    return queue[front++];\n}\n\nint is_empty() {\n    return front == rear;\n}\n\nvoid reset_visited() {\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            visited[i][j] = 0;\n        }\n    }\n}\n\nint bfs(int x, int y, char color) {\n    front = rear = 0;\n    enqueue(x, y);\n    visited[x][y] = 1;\n    int count = 0;\n\n    while (!is_empty()) {\n        Position p = dequeue();\n        count++;\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n        for (int i = 0; i < 4; i++) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            if (nx >= 0 && nx < ROWS && ny >= 0 && ny < COLS && !visited[nx][ny] && grid[nx][ny] == color) {\n                visited[nx][ny] = 1;\n                enqueue(nx, ny);\n            }\n        }\n    }\n    return count;\n}\n\nvoid remove_blocks(char color) {\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            if (visited[i][j] && grid[i][j] == color) {\n                grid[i][j] = '.';\n            }\n        }\n    }\n}\n\nvoid fall_blocks() {\n    for (int j = 0; j < COLS; j++) {\n        int empty_pos = ROWS - 1;\n        for (int i = ROWS - 1; i >= 0; i--) {\n            if (grid[i][j] != '.') {\n                char temp = grid[i][j];\n                grid[i][j] = '.';\n                grid[empty_pos][j] = temp;\n                empty_pos--;\n            }\n        }\n    }\n}\n\nint process_dataset() {\n    int chains = 0;\n    int removed;\n\n    do {\n        removed = 0;\n        reset_visited();\n\n        for (int i = 0; i < ROWS; i++) {\n            for (int j = 0; j < COLS; j++) {\n                if (grid[i][j] != '.' && grid[i][j] != 'X' && !visited[i][j]) {\n                    int count = bfs(i, j, grid[i][j]);\n                    if (count >= 4) {\n                        remove_blocks(grid[i][j]);\n                        removed = 1;\n                    }\n                }\n            }\n        }\n\n        if (removed) {\n            chains++;\n            fall_blocks();\n        }\n    } while (removed);\n\n    return chains;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        for (int i = 0; i < ROWS; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        printf(\"%d\\n\", process_dataset());\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint H = 12, W = 6;\n\nint countChains(vector<vector<char>>& grid) {\n    int chains = 0;\n    bool changed;\n\n    do {\n        changed = false;\n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        vector<pair<int, int>> toRemove;\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (grid[i][j] != '.' && grid[i][j] != 'O' && !visited[i][j]) {\n                    queue<pair<int, int>> q;\n                    vector<pair<int, int>> group;\n                    q.push({i, j});\n                    visited[i][j] = true;\n                    char color = grid[i][j];\n\n                    while (!q.empty()) {\n                        auto p = q.front(); q.pop();\n                        group.push_back(p);\n\n                        for (int d = 0; d < 4; ++d) {\n                            int ni = p.first + dx[d];\n                            int nj = p.second + dy[d];\n                            if (ni >= 0 && ni < H && nj >= 0 && nj < W && !visited[ni][nj] && grid[ni][nj] == color) {\n                                visited[ni][nj] = true;\n                                q.push({ni, nj});\n                            }\n                        }\n                    }\n\n                    if (group.size() >= 4) {\n                        toRemove.insert(toRemove.end(), group.begin(), group.end());\n                    }\n                }\n            }\n        }\n\n        if (!toRemove.empty()) {\n            changed = true;\n            chains++;\n            for (auto& p : toRemove) {\n                grid[p.first][p.second] = '.';\n            }\n\n            for (int j = 0; j < W; ++j) {\n                int write = H - 1;\n                for (int i = H - 1; i >= 0; --i) {\n                    if (grid[i][j] != '.') {\n                        grid[write][j] = grid[i][j];\n                        if (write != i) grid[i][j] = '.';\n                        write--;\n                    }\n                }\n            }\n        }\n    } while (changed);\n\n    return chains;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T--) {\n        vector<vector<char>> grid(H, vector<char>(W));\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        cout << countChains(grid) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BlockPuzzleChains {\n    static final int[] dx = {0, 1, 0, -1};\n    static final int[] dy = {1, 0, -1, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n\n        for (int d = 0; d < datasets; d++) {\n            char[][] grid = new char[12][6];\n            for (int i = 0; i < 12; i++) {\n                String line = scanner.nextLine();\n                for (int j = 0; j < 6; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n\n            int chains = 0;\n            while (true) {\n                boolean[][] visited = new boolean[12][6];\n                boolean hasChain = false;\n\n                for (int i = 0; i < 12; i++) {\n                    for (int j = 0; j < 6; j++) {\n                        if (grid[i][j] != '.' && grid[i][j] != 'X' && !visited[i][j]) {\n                            List<int[]> group = new ArrayList<>();\n                            dfs(grid, i, j, grid[i][j], visited, group);\n                            if (group.size() >= 4) {\n                                hasChain = true;\n                                for (int[] pos : group) {\n                                    grid[pos[0]][pos[1]] = '.';\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (!hasChain) {\n                    break;\n                }\n                chains++;\n                applyGravity(grid);\n            }\n            System.out.println(chains);\n        }\n        scanner.close();\n    }\n\n    private static void dfs(char[][] grid, int i, int j, char color, boolean[][] visited, List<int[]> group) {\n        if (i < 0 || i >= 12 || j < 0 || j >= 6 || visited[i][j] || grid[i][j] != color) {\n            return;\n        }\n        visited[i][j] = true;\n        group.add(new int[]{i, j});\n        for (int k = 0; k < 4; k++) {\n            dfs(grid, i + dx[k], j + dy[k], color, visited, group);\n        }\n    }\n\n    private static void applyGravity(char[][] grid) {\n        for (int j = 0; j < 6; j++) {\n            int emptyRow = 11;\n            for (int i = 11; i >= 0; i--) {\n                if (grid[i][j] != '.') {\n                    if (i != emptyRow) {\n                        grid[emptyRow][j] = grid[i][j];\n                        grid[i][j] = '.';\n                    }\n                    emptyRow--;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:15:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BlockChainCounter {\n    static int[][] grid;\n    static int rows, cols;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            rows = scanner.nextInt();\n            cols = scanner.nextInt();\n            grid = new int[rows][cols];\n\n            // Read grid\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n\n            System.out.println(processChains());\n        }\n    }\n\n    static int processChains() {\n        int chains = 0;\n        boolean chainOccurred;\n\n        do {\n            chainOccurred = false;\n            boolean[][] visited = new boolean[rows][cols];\n            List<int[]> blocksToRemove = new ArrayList<>();\n\n            // Find blocks to remove\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    if (grid[i][j] != 0 && grid[i][j] != 7 && !visited[i][j]) {\n                        List<int[]> group = findConnectedBlocks(i, j, visited);\n                        if (group.size() >= 4) {\n                            blocksToRemove.addAll(group);\n                            chainOccurred = true;\n                        }\n                    }\n                }\n            }\n\n            // Remove blocks\n            for (int[] block : blocksToRemove) {\n                grid[block[0]][block[1]] = 0;\n            }\n\n            // Drop blocks\n            if (chainOccurred) {\n                dropBlocks();\n                chains++;\n            }\n        } while (chainOccurred);\n\n        return chains;\n    }\n\n    static List<int[]> findConnectedBlocks(int x, int y, boolean[][] visited) {\n        List<int[]> group = new ArrayList<>();\n        int color = grid[x][y];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{x, y});\n        visited[x][y] = true;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            group.add(curr);\n\n            for (int k = 0; k < 4; k++) {\n                int nx = curr[0] + dx[k];\n                int ny = curr[1] + dy[k];\n\n                if (isValid(nx, ny) && grid[nx][ny] == color && !visited[nx][ny]) {\n                    queue.offer(new int[]{nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n\n        return group;\n    }\n\n    static void dropBlocks() {\n        for (int j = 0; j < cols; j++) {\n            List<Integer> column = new ArrayList<>();\n            for (int i = rows - 1; i >= 0; i--) {\n                if (grid[i][j] != 0) {\n                    column.add(grid[i][j]);\n                }\n            }\n\n            for (int i = rows - 1; i >= 0; i--) {\n                if (column.isEmpty()) {\n                    grid[i][j] = 0;\n                } else {\n                    grid[i][j] = column.remove(0);\n                }\n            }\n        }\n    }\n\n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols;\n    }\n}",
    "timestamp": "2025-08-05 21:15:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 12\n\nint grid[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nint rows, cols;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y, int color, int* count) {\n    if (x < 0 || x >= rows || y < 0 || y >= cols || visited[x][y] || grid[x][y] != color)\n        return;\n\n    visited[x][y] = true;\n    (*count)++;\n\n    for (int i = 0; i < 4; i++)\n        dfs(x + dx[i], y + dy[i], color, count);\n}\n\nvoid drop_blocks() {\n    for (int j = 0; j < cols; j++) {\n        int bottom = rows - 1;\n        for (int i = rows - 1; i >= 0; i--) {\n            if (grid[i][j] != 0) {\n                grid[bottom][j] = grid[i][j];\n                if (bottom != i)\n                    grid[i][j] = 0;\n                bottom--;\n            }\n        }\n        while (bottom >= 0) {\n            grid[bottom][j] = 0;\n            bottom--;\n        }\n    }\n}\n\nint process_chain() {\n    int chain_count = 0;\n    bool has_disappeared;\n\n    do {\n        has_disappeared = false;\n        memset(visited, 0, sizeof(visited));\n        bool to_remove[MAX_SIZE][MAX_SIZE] = {0};\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (!visited[i][j] && grid[i][j] > 0 && grid[i][j] < 6) {\n                    int count = 0;\n                    dfs(i, j, grid[i][j], &count);\n\n                    if (count >= 4) {\n                        has_disappeared = true;\n                        for (int r = 0; r < rows; r++)\n                            for (int c = 0; c < cols; c++)\n                                if (visited[r][c])\n                                    to_remove[r][c] = true;\n                    }\n                }\n            }\n        }\n\n        if (has_disappeared) {\n            chain_count++;\n            for (int i = 0; i < rows; i++)\n                for (int j = 0; j < cols; j++)\n                    if (to_remove[i][j])\n                        grid[i][j] = 0;\n\n            drop_blocks();\n        }\n    } while (has_disappeared);\n\n    return chain_count;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 1; t <= T; t++) {\n        scanf(\"%d %d\", &rows, &cols);\n        \n        for (int i = 0; i < rows; i++)\n            for (int j = 0; j < cols; j++)\n                scanf(\"%d\", &grid[i][j]);\n\n        printf(\"%d\\n\", process_chain());\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int DIRECTIONS[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nconst int H = 12, W = 6;\n\nbool isValidPos(int r, int c) {\n    return r >= 0 && r < H && c >= 0 && c < W;\n}\n\nvector<vector<int>> dropBlocks(vector<vector<int>>& grid) {\n    for (int c = 0; c < W; c++) {\n        vector<int> column;\n        for (int r = 0; r < H; r++) {\n            if (grid[r][c] > 0) {\n                column.push_back(grid[r][c]);\n                grid[r][c] = 0;\n            }\n        }\n        \n        int r = H - 1;\n        while (!column.empty()) {\n            grid[r][c] = column.back();\n            column.pop_back();\n            r--;\n        }\n    }\n    return grid;\n}\n\nvector<pair<int, int>> findConnectedBlocks(vector<vector<int>>& grid, int color, int r, int c, vector<vector<bool>>& visited) {\n    vector<pair<int, int>> connectedBlocks;\n    queue<pair<int, int>> q;\n    q.push({r, c});\n    visited[r][c] = true;\n    \n    while (!q.empty()) {\n        int cr = q.front().first;\n        int cc = q.front().second;\n        q.pop();\n        connectedBlocks.push_back({cr, cc});\n        \n        for (auto& dir : DIRECTIONS) {\n            int nr = cr + dir[0];\n            int nc = cc + dir[1];\n            \n            if (isValidPos(nr, nc) && !visited[nr][nc] && grid[nr][nc] == color) {\n                q.push({nr, nc});\n                visited[nr][nc] = true;\n            }\n        }\n    }\n    \n    return connectedBlocks;\n}\n\nint simulateChains(vector<vector<int>>& grid) {\n    int chains = 0;\n    bool anyBlocksRemoved;\n    \n    do {\n        anyBlocksRemoved = false;\n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        vector<vector<int>> blocksToRemove(H, vector<int>(W, 0));\n        \n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                if (!visited[r][c] && grid[r][c] > 0 && grid[r][c] < 6) {\n                    vector<pair<int, int>> connectedBlocks = findConnectedBlocks(grid, grid[r][c], r, c, visited);\n                    \n                    if (connectedBlocks.size() >= 4) {\n                        anyBlocksRemoved = true;\n                        for (auto& block : connectedBlocks) {\n                            blocksToRemove[block.first][block.second] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (anyBlocksRemoved) {\n            chains++;\n            for (int r = 0; r < H; r++) {\n                for (int c = 0; c < W; c++) {\n                    if (blocksToRemove[r][c]) {\n                        grid[r][c] = 0;\n                    }\n                }\n            }\n            \n            grid = dropBlocks(grid);\n        }\n    } while (anyBlocksRemoved);\n    \n    return chains;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    for (int t = 0; t < T; t++) {\n        vector<vector<int>> grid(H, vector<int>(W));\n        \n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                cin >> grid[r][c];\n            }\n        }\n        \n        cout << simulateChains(grid) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_chains(datasets):\n    def in_bounds(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n\n    def find_connected_blocks(x, y, block_type):\n        visited = set()\n        stack = [(x, y)]\n        connected = []\n\n        while stack:\n            cx, cy = stack.pop()\n            if (cx, cy) not in visited:\n                visited.add((cx, cy))\n                connected.append((cx, cy))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = cx + dx, cy + dy\n                    if in_bounds(nx, ny) and grid[nx][ny] == block_type:\n                        stack.append((nx, ny))\n        return connected\n\n    def remove_blocks(connected_blocks):\n        for bx, by in connected_blocks:\n            grid[bx][by] = None\n    \n    def drop_blocks():\n        for y in range(cols):\n            empty_positions = [x for x in range(rows) if grid[x][y] is None]\n            filled_positions = [x for x in range(rows) if grid[x][y]]\n\n            if empty_positions and filled_positions:\n                for i in range(len(empty_positions)):\n                    empty_pos = empty_positions[i]\n                    for j in range(len(filled_positions)):\n                        if filled_positions[j] < empty_pos:\n                            grid[empty_pos][y] = grid[filled_positions[j]][y]\n                            grid[filled_positions[j]][y] = None\n                            break\n      \n    results = []\n    for dataset in datasets:\n        rows, cols = len(dataset), len(dataset[0])\n        grid = [list(row) for row in dataset]\n        \n        chain_count = 0\n        found_chain = True\n        \n        while found_chain:\n            found_chain = False\n            for x in range(rows):\n                for y in range(cols):\n                    if grid[x][y] is not None and grid[x][y] != 'B':  # Not a blocking block\n                        connected_blocks = find_connected_blocks(x, y, grid[x][y])\n                        if len(connected_blocks) >= 4:\n                            remove_blocks(connected_blocks)\n                            found_chain = True\n            \n            if found_chain:\n                drop_blocks()\n                chain_count += 1\n        \n        results.append(chain_count)\n    return results\n\n# Example input handling\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip().split('\\n')\n    dataset_count = int(input_data[0])\n    results = []\n    line_idx = 1\n    \n    for _ in range(dataset_count):\n        grid = []\n        while line_idx < len(input_data) and input_data[line_idx]:\n            grid.append(input_data[line_idx])\n            line_idx += 1\n        line_idx += 1\n        results.append(count_chains([grid])[0])\n    \n    print(\" \".join(map(str, results)))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 05:38:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ChainReactionCounter {\n\n    private static final char EMPTY = '.';\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numberOfDatasets = scanner.nextInt();\n        for (int dataset = 0; dataset < numberOfDatasets; dataset++) {\n            int rows = scanner.nextInt();\n            int columns = scanner.nextInt();\n            char[][] grid = new char[rows][columns];\n\n            for (int i = 0; i < rows; i++) {\n                String line = scanner.next();\n                for (int j = 0; j < columns; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n\n            int chains = countChains(grid, rows, columns);\n            System.out.println(chains);\n        }\n        scanner.close();\n    }\n\n    private static int countChains(char[][] grid, int rows, int columns) {\n        int chainCount = 0;\n        boolean anyChange;\n        do {\n            anyChange = false;\n            boolean[][] visited = new boolean[rows][columns];\n            List<List<int[]>> toRemoveGroups = new ArrayList<>();\n\n            // Find all removable groups\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < columns; j++) {\n                    if (!visited[i][j] && grid[i][j] != EMPTY) {\n                        List<int[]> group = new ArrayList<>();\n                        dfs(grid, visited, i, j, grid[i][j], group, rows, columns);\n                        if (group.size() >= 4) {\n                            toRemoveGroups.add(group);\n                        }\n                    }\n                }\n            }\n\n            // Remove blocks\n            for (List<int[]> group : toRemoveGroups) {\n                anyChange = true;\n                for (int[] cell : group) {\n                    grid[cell[0]][cell[1]] = EMPTY;\n                }\n            }\n\n            // Gravity effect\n            if (anyChange) {\n                applyGravity(grid, rows, columns);\n                chainCount++;\n            }\n        } while (anyChange);\n\n        return chainCount;\n    }\n\n    private static void dfs(char[][] grid, boolean[][] visited, int x, int y, char color, List<int[]> group, int rows, int columns) {\n        visited[x][y] = true;\n        group.add(new int[]{x, y});\n        for (int dir = 0; dir < 4; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < columns && !visited[nx][ny] && grid[nx][ny] == color) {\n                dfs(grid, visited, nx, ny, color, group, rows, columns);\n            }\n        }\n    }\n\n    private static void applyGravity(char[][] grid, int rows, int columns) {\n        for (int j = 0; j < columns; j++) {\n            int emptyRow = rows;\n            for (int i = rows - 1; i >= 0; i--) {\n                if (grid[i][j] != EMPTY) {\n                    emptyRow--;\n                    if (emptyRow != i) {\n                        grid[emptyRow][j] = grid[i][j];\n                        grid[i][j] = EMPTY;\n                    }\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 05:38:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n#define EMPTY '.'\n\nchar grid[MAX_ROWS][MAX_COLS];\nint rows, cols;\nint visited[MAX_ROWS][MAX_COLS];\n\nint drow[] = {-1, 1, 0, 0};\nint dcol[] = {0, 0, -1, 1};\n\nint chain_count;\n\nvoid reset_visited() {\n    for (int i = 0; i < rows; ++i) {\n        memset(visited[i], 0, sizeof(visited[i]));\n    }\n}\n\nint is_valid(int row, int col) {\n    return row >= 0 && row < rows && col >= 0 && col < cols;\n}\n\nint flood_fill(int row, int col, char color) {\n    if (!is_valid(row, col) || visited[row][col] || grid[row][col] != color) {\n        return 0;\n    }\n    visited[row][col] = 1;\n    int count = 1;\n    for (int i = 0; i < 4; ++i) {\n        count += flood_fill(row + drow[i], col + dcol[i], color);\n    }\n    return count;\n}\n\nvoid remove_blocks(int row, int col, char color) {\n    if (!is_valid(row, col) || grid[row][col] != color) {\n        return;\n    }\n    grid[row][col] = EMPTY;\n    for (int i = 0; i < 4; ++i) {\n        remove_blocks(row + drow[i], col + dcol[i], color);\n    }\n}\n\nvoid apply_gravity() {\n    for (int col = 0; col < cols; ++col) {\n        int empty_row = -1;\n        for (int row = rows - 1; row >= 0; --row) {\n            if (grid[row][col] == EMPTY) {\n                if (empty_row == -1) {\n                    empty_row = row;\n                }\n            } else if (empty_row != -1) {\n                grid[empty_row][col] = grid[row][col];\n                grid[row][col] = EMPTY;\n                empty_row--;\n            }\n        }\n    }\n}\n\nint process_grid() {\n    int local_chain_count = 0;\n    while (1) {\n        reset_visited();\n        int to_delete = 0;\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (grid[i][j] != EMPTY && !visited[i][j]) {\n                    int block_count = flood_fill(i, j, grid[i][j]);\n                    if (block_count >= 4) {\n                        remove_blocks(i, j, grid[i][j]);\n                        to_delete = 1;\n                    }\n                }\n            }\n        }\n\n        if (!to_delete) break;\n        apply_gravity();\n        local_chain_count++;\n    }\n    return local_chain_count;\n}\n\nint main() {\n    int num_datasets;\n    scanf(\"%d\", &num_datasets);\n\n    for (int dataset = 0; dataset < num_datasets; ++dataset) {\n        scanf(\"%d %d\", &rows, &cols);\n        for (int i = 0; i < rows; ++i) {\n            scanf(\"%s\", grid[i]);\n        }\n        chain_count = process_grid();\n        printf(\"%d\\n\", chain_count);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:39:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_block_puzzle(grid):\n    rows, cols = len(grid), len(grid[0])\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def find_connected_blocks(r, c, color, visited):\n        connected = [(r, c)]\n        visited.add((r, c))\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if is_valid(nr, nc) and grid[nr][nc] == color and (nr, nc) not in visited:\n                connected.extend(find_connected_blocks(nr, nc, color, visited))\n        \n        return connected\n\n    def remove_blocks(blocks):\n        for r, c in blocks:\n            grid[r][c] = '0'\n\n    def drop_blocks():\n        for c in range(cols):\n            column = [grid[r][c] for r in range(rows-1, -1, -1) if grid[r][c] != '0']\n            column += ['0'] * (rows - len(column))\n            for r in range(rows):\n                grid[rows-1-r][c] = column[r]\n\n    chains = 0\n    while True:\n        removals = False\n        visited = set()\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] != '0' and grid[r][c] != 'X' and (r, c) not in visited:\n                    connected = find_connected_blocks(r, c, grid[r][c], visited)\n                    if len(connected) >= 4:\n                        remove_blocks(connected)\n                        removals = True\n\n        if not removals:\n            break\n        \n        drop_blocks()\n        chains += 1\n\n    return chains\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        rows, cols = map(int, input().split())\n        grid = [list(input().strip()) for _ in range(rows)]\n        print(solve_block_puzzle(grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:39:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    T = int(input[ptr])\n    ptr += 1\n    for _ in range(T):\n        grid = []\n        for _ in range(12):\n            grid.append(list(input[ptr]))\n            ptr += 1\n        \n        chains = 0\n        \n        while True:\n            visited = [[False for _ in range(6)] for _ in range(12)]\n            to_remove = set()\n            \n            for i in range(12):\n                for j in range(6):\n                    if grid[i][j] != '.' and grid[i][j] != 'O' and not visited[i][j]:\n                        color = grid[i][j]\n                        queue = deque()\n                        queue.append((i, j))\n                        visited[i][j] = True\n                        group = [(i, j)]\n                        \n                        while queue:\n                            x, y = queue.popleft()\n                            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                                nx, ny = x + dx, y + dy\n                                if 0 <= nx < 12 and 0 <= ny < 6:\n                                    if not visited[nx][ny] and grid[nx][ny] == color:\n                                        visited[nx][ny] = True\n                                        queue.append((nx, ny))\n                                        group.append((nx, ny))\n                        \n                        if len(group) >= 4:\n                            to_remove.update(group)\n            \n            if not to_remove:\n                break\n            \n            chains += 1\n            \n            for x, y in to_remove:\n                grid[x][y] = '.'\n            \n            for j in range(6):\n                column = []\n                for i in range(12):\n                    if grid[i][j] != '.':\n                        column.append(grid[i][j])\n                new_column = ['.'] * (12 - len(column)) + column\n                for i in range(12):\n                    grid[i][j] = new_column[i]\n        \n        print(chains)\n\nsolve()",
    "timestamp": "2025-08-13 05:39:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n// Directions for adjacent cells: left, right, up, and down\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nint rows, cols;\n\n// Perform BFS to find all connected blocks of the same color\nbool bfs(vector<string>& grid, int x, int y, vector<pair<int, int>>& toRemove, vector<vector<bool>>& visited) {\n    char color = grid[x][y];\n    queue<pair<int, int>> q;\n    q.push({x, y});\n    toRemove.push_back({x, y});\n    visited[x][y] = true;\n    \n    while (!q.empty()) {\n        int cx = q.front().first;\n        int cy = q.front().second;\n        q.pop();\n        \n        for (int d = 0; d < 4; ++d) {\n            int nx = cx + dx[d], ny = cy + dy[d];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny] && grid[nx][ny] == color) {\n                visited[nx][ny] = true;\n                toRemove.push_back({nx, ny});\n                q.push({nx, ny});\n            }\n        }\n    }\n    \n    return toRemove.size() >= 4;\n}\n\n// Let the blocks fall down after removal\nvoid applyGravity(vector<string>& grid) {\n    for (int col = 0; col < cols; ++col) {\n        int writeRow = rows - 1;\n        for (int row = rows - 1; row >= 0; --row) {\n            if (grid[row][col] != '.') {\n                grid[writeRow--][col] = grid[row][col];\n            }\n        }\n        while (writeRow >= 0) {\n            grid[writeRow--][col] = '.';\n        }\n    }\n}\n\nint simulate(vector<string>& grid) {\n    int chains = 0;\n    bool anyBlocksRemoved;\n    \n    do {\n        anyBlocksRemoved = false;\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n        \n        for (int x = 0; x < rows; ++x) {\n            for (int y = 0; y < cols; ++y) {\n                if (grid[x][y] != '.' && grid[x][y] != 'B' && !visited[x][y]) {\n                    vector<pair<int, int>> toRemove;\n                    if (bfs(grid, x, y, toRemove, visited)) {\n                        anyBlocksRemoved = true;\n                        for (auto& p : toRemove) {\n                            grid[p.first][p.second] = '.';\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (anyBlocksRemoved) {\n            ++chains;\n            applyGravity(grid);\n        }\n        \n    } while (anyBlocksRemoved);\n    \n    return chains;\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n\n    for (int d = 0; d < numDatasets; ++d) {\n        cin >> rows >> cols;\n        vector<string> grid(rows);\n        for (int i = 0; i < rows; ++i) {\n            cin >> grid[i];\n        }\n        \n        cout << simulate(grid) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:37"
  }
]