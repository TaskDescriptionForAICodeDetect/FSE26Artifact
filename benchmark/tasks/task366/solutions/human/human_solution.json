[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst char p[7] = {'R','G','B','Y','P','O','.'};\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nstring f[12];\nint cnt = 0;\n\nvoid debug(){\n\tcout << endl;\n\tfor(int y=0 ; y<12 ; ++y )\n\t\tcout << f[y] << endl;\n\tcout << endl;\n}\n\nvoid downPuyo(int x,int y){\n\tchar t = f[y+1][x] ;\n\tf[y+1][x] = f[y][x];\n\tf[y][x] = t;\n\t\n\tif( y+1 != 11 && f[y+2][x] == '.' ){\n\t\tdownPuyo( x , y+1 );\n\t}\n}\n\nvoid checkPuyo(int x,int y,char color){\n\tf[y][x] += 'a' - 'A';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\t++cnt;\n\t\t\tcheckPuyo( mx , my , color );\n\t\t}\n\t}\n}\nvoid eracePuyo(int x,int y,char color){\n\tf[y][x] = '.';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\teracePuyo( mx , my , color );\n\t\t}\n\t\tif( f[my][mx] == 'O' ){\n\t\t\tf[my][mx] = '.';\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, chain;\n\t\n\tcin >> n;\n\tfor(int i=0 ; i<n ; ++i ){\n\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\tcin >> f[y];\n\t\t}\n\n\t\t//ú»\n\t\tbool flag = true;\n\t\tchain = 0;\n\n\t\t//Á¦éÕæªÈ­ÈéÜÅ[v\n\t\twhile( flag ){\n\t\t\tflag = false;\n\n\t\t\t/*cout << \"Á¦éO\" << endl;\n\t\t\tdebug();\n\t\t\tcout << endl;*/\n\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t//àµFÕæ¾Á½ç\n\t\t\t\t\t\tif( f[y][x] == p[i] ){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tcheckPuyo( x , y , p[i] );\n\t\t\t\t\t\t\t//àµSÂÈã­ÁÂ¢Ä¢½ç¯·\n\t\t\t\t\t\t\tif( cnt >= 4 ){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\teracePuyo( x , y , p[i] + ('a'-'A') );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//ú»\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tchar c = p[i] + ('a'-'A');\n\t\t\t\t\t\tif( f[y][x] == c ){\n\t\t\t\t\t\t\tf[y][x] -= ('a'-'A');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*cout << \"Á¦½ã\" << endl;\n\t\t\tdebug();\n\t\t\tcout << endl;*/\n\n\t\t\t//Á¦éÕæª éÆ«\n\t\t\tif( flag ){\n\t\t\t\tchain++;\n\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*cout << \"ºã\" << endl;\n\t\t\t\tdebug();\n\t\t\t\tcout << endl;*/\n\t\t\t}\t\t\n\t\t}\n\t\tcout << chain << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<list>\n#include<ctype.h>\n#include<iterator>\n\nusing namespace std;\n\nclass point{\n public:\n  int x;\n  int y;\n  point(){}\n  point(int xa,int ya){\n    x=xa;\n    y=ya;\n  }\n};\n\nclass chain{\n public:\n  list<point> lst;\n  char val;\n  chain(){\n  }\n  chain(char v,list<point> ls);\n};\nchain::chain(char v,list<point> ls){\n  val=v;\n  lst=ls;\n}\nchar map[8][14];\nint isColor(char val){\n  return isalpha(val)&&val!='O';\n}\nint c2i(char c){\n  return c=='R'?1:c=='G'?2:c=='B'?3:c=='Y'?4:c=='P'?5:6;\n}\nchar i2c(int i){\n  return i==1?'R':i==2?'G':i==3?'B':i==4?'Y':i==5?'P':'?';\n}\nint sch(chain *chn){\n  int i,k,j,ci,prev,s,l,x,y,first;\n  chain c;\n  list<point>::iterator it;\n  list<point> buf,next;\n  int dic[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\n  for(i=1;i<14;i++)\n    for(j=1;j<8;j++)\n      if(isColor(map[i][j])){\n\tfirst=i;\n\tgoto find;\n      }\n find:;\n  for(i=first,ci=0;i<14;i++){\n    for(j=1;j<8;j++){\n      if(isColor(map[i][j])){\n\tc.val=map[i][j];\n\tmap[i][j]=c2i(c.val);\n\tbuf.push_back(*(new point(j,i)));\n\tnext.clear();\n\tdo{\n\t  prev=0;\n\t  it=buf.begin();\n\t  while(it!=buf.end()){\t    \n\t    for(l=0;l<4;l++){\n\t      x=it->x+dic[l][1];\n\t      y=it->y+dic[l][0];\n\t      if(c.val==map[y][x]){\n\t\tnext.push_back(*(new point(x,y)));\n\t\tmap[y][x]=c2i(c.val);\n\t\tprev++;\n\t      }\n\t    }\n\t    c.lst.push_back(*it);\n\t    it++;\n\t  }\n\t  buf.clear();\n\t  copy(next.begin(),next.end(),back_inserter(buf));\n\t  next.clear();\n\t}while(prev);\n\tif(c.lst.size()>=4){\n\t  chn[ci].val=c.val;\n\t  it=c.lst.begin();\n\t  while(it!=c.lst.end()){\n\t    chn[ci].lst.push_back(*it);\n\t    it++;\n\t  }\n\t  ci++;\n\t}\n\tc.lst.clear();\n      }\n    }\n  }\n  for(i=first;i<14;i++){\n    for(j=1;j<8;j++){\n      if(map[i][j]>=1&&map[i][j]<=5){\n\tmap[i][j]=i2c(map[i][j]);\n      }\n    }\n  }\n  return ci;\n}\nint main(){\n  int i,k,n,cn,bs,p,j,count;\n  chain ch[18];\n  int dic[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\n  list<point>::iterator it;\n  scanf(\"%d\",&n);\n  for(p=0;p<n;p++){\n    count=0;\n    for(i=1,bs=0;i<13;i++) scanf(\"%s\",map[i]+1);\n    do{\n      cn=sch(ch);\n      if(!cn) break;\n      count++;\n      for(i=0;i<cn;i++){\n\tit=ch[i].lst.begin();\n\twhile(it!=ch[i].lst.end()){\n\t  for(k=0;k<4;k++)\n\t    if(map[it->y+dic[k][0]][it->x+dic[k][1]]=='O')\n\t      map[it->y+dic[k][0]][it->x+dic[k][1]]='F';\n\t  map[it->y][it->x]='F';\n\t  it++;\n\t}\n      }\n      for(i=1;i<13;i++){\n\tfor(j=1;j<8;j++){\n\t  if(map[i][j]=='F'){\n\t    for(k=i-1;k>0;k--){\n\t      if(map[k][j]!='.'){\n\t\tmap[k+1][j]=map[k][j];\n\t      }else{\n\t\tbreak;\n\t      }\n\t    }\n\t    map[k+1][j]='.';\n\t  }\n\t}\n      }\n      for(i=0;i<cn;i++){\n\tch[i].lst.clear();\n      }\n    }while(1);\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\n\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n/*\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tint y = i+dy[k], x = j+dx[k];\n\t\tif(y >= 0 && y < 12 && x >= 0 && x < 6 \n\t\t\t&& area[y][x] == c && !used[y][x]){\n\t\t\tcounter += count(y, x, c);\n\t\t}\n\t}*/\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstring g[12];\nbool vis[12][12];\nbool clr[12][12];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint dfs(int y,int x,int col){\n  if(g[y][x] != col)return 0;\n  if(vis[y][x])return 0;\n  vis[y][x] = true;\n\n  int res = 1;\n  rep(i,4){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(ny<0 || nx<0 || ny>=12 || nx>=6)continue;\n    res += dfs(ny,nx,col);\n  }\n  return res;\n}\n\n\nint chain(void){\n  memset(clr,0,sizeof(clr));\n  rep(i,12){\n    rep(j,6){\n      if(g[i][j] != '.' && g[i][j] != 'O' && !clr[i][j]){\n\tmemset(vis,0,sizeof(vis));\n\tif(dfs(i,j,g[i][j])>=4){\n\t  rep(ii,12)rep(jj,6)clr[ii][jj] |= vis[ii][jj];\n\t}\n      }\n    }\n  }\n\n  rep(i,12){\n    rep(j,6){\n      if(g[i][j] == 'O'){\n\trep(k,4){\n\t  int ny = i+dy[k], nx = j+dx[k];\n\t  if(ny<0 || nx<0 || ny>=12 || nx>=6)continue;\n\t  if(g[ny][nx] != 'O' && clr[ny][nx]){\n\t    clr[i][j] = true;\n\t  }\n\t}\n      }\n    }\n  }\n\n  int num = 0;\n  rep(i,12){\n    rep(j,6){\n      if(clr[i][j])g[i][j] = '.', num++;\n    }\n  }\n  if(num==0)return 0;\n\n  rep(i,6){\n    for(int j=11;j>=0;j--){\n      if(g[j][i] != '.'){\n\tfor(int k=j+1;k<12;k++){\n\t  if(g[k][i] == '.')swap(g[k][i],g[k-1][i]);\n\t  else break;\n\t}\n      }\n    }\n  }\n\n  return chain()+1;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    rep(i,12)cin >> g[i];\n    cout << chain() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\nstring field[12];\nbool used[12][6];\n\nbool inside(int x, int y){\n  return !(x<0 || x>=6 || y>=12 || y<0);\n}\nint check(int x, int y, char color){\n  int ret = 1;\n  used[y][x] = true;\n  rep(k,4){\n    int tx = x + dx[k];\n    int ty = y + dy[k];\n\n    if( !inside(tx,ty) ) continue;\n    if( field[ty][tx]!=color || used[ty][tx] ) continue;\n#if DEB\n    printf(\"k:%d tx:%d , ty:%d  ret:%d  color:%c  f:%c\\n\",k,tx,ty,ret,color,field[ty][tx]);\n#endif\n    ret += check(tx, ty, color);\n  }\n  return ret;\n}\n\nvoid sakujo(int x, int y, char color){\n\n  field[y][x] = '.';\n\n#if DEB\n  puts(\"sakujoooooooooooooooooooooooooooooo\");\n  rep(i,12)cout<<field[i]<<endl;\n  puts(\"----------------------\");\n#endif\n\n  rep(k,4)\n  rep(k,4){\n    int tx = x + dx[k];\n    int ty = y + dy[k];\n    if( !inside(tx,ty) ) continue;\n    if( field[ty][tx]=='O' ){\n      field[ty][tx]='.';\n    }\n    if( field[ty][tx]!=color )continue;\n    sakujo(tx,ty,color);\n  }\n}\nvoid otiru(void){\n  bool ok = true;\n  while(ok){\n    ok = false;\n    rep(i,11)rep(j,6)if( field[i][j]!='.' ){\n      if( field[i+1][j]=='.' ){\n\tfield[i+1][j] = field[i][j];\n\tfield[i][j] = '.';\n\tok = true;\n      }\n    }\n  }\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    rep(i,12)cin>>field[i];\n#if DEB\n    rep(i,12){\n      cout << field[i] << endl;\n    }\n    puts(\"\");\n#endif\n    int ans = 0;\n    bool ok = true;\n    while( ok ){\n      ok = false;\n      memset(used,false,sizeof(used));\n      rep(i,12)rep(j,6)if( field[i][j]!='.' && field[i][j]!='O' ){\n\tif( check(j,i,field[i][j]) >= 4 ){\n\t  sakujo(j,i,field[i][j]);\n\t  ok = true;\n\t}\n      }\n      otiru();\n      if( ok ) ans++;\n#if DEB\n      rep(i,12)cout<<field[i]<<endl;\n      puts(\"\");\n#endif\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nchar ba[12][6];\n\ntypedef pair<int, int> pii;\nbool visited[2][12][6];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint rec(int y, int x, char c, bool f) {\n//  cout << y << \" \" << x << endl;\n  if (f) ba[y][x] = '*';\n  int res = 1;\n  visited[f][y][x] = 1;\n  REP(k,4) {\n    int yy = y+dy[k];\n    int xx = x+dx[k];\n    if (yy<0||yy>=12||xx<0||xx>=6) continue;\n    if (visited[f][yy][xx]) continue;\n    if (ba[yy][xx] == c || f&& ba[yy][xx] == 'O') {\n      res += rec(yy,xx,c,f);\n    }\n  }\n  return res;\n}\n\nint solve() {\n  bool del = 0;\n\n  memset(visited,0,sizeof(visited));\n  REP(i, 12) {\n    REP(j, 6) {\n      if (ba[i][j] != '.' && ba[i][j] != 'O' && !visited[0][i][j]) {\n        if (rec(i, j, ba[i][j], 0) >= 4) {\n          rec(i, j, ba[i][j], 1);\n          del = 1;\n        }\n      }\n    }\n  }\n  if (!del) return 0;\n\n  REP(j, 6) {\n    vector<char> v;\n    for (int i=11; i>=0; --i) {\n      if (ba[i][j] == '.') break;\n      if (ba[i][j] != '*')\n        v.push_back(ba[i][j]);\n    }\n    for (int i=11; i>=0; --i) {\n      if (11-i < v.size())\n        ba[i][j] = v[11-i];\n      else\n        ba[i][j] = '.';\n    }\n  }\n  // REP(i,12) {\n  //   REP(j,6) {\n  //     cout << ba[i][j];\n  //   }\n  //   cout << endl;\n  // }cout << endl;\n\n  return 1 + solve();\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    REP(i, 12) {\n      REP(j, 6) {\n        cin >> ba[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "function bomb(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         CNT++;\n         if(CNT==4)p.push([yy,xx]);\n         yx[yy][xx]=color+CNT;\n         bomb(yy,xx,color);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n        var CNT;\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){CNT=1;yx[i][j]=\"R\"+CNT;bomb(i,j,\"R\");}\n                  if(yx[i][j]==\"G\"){CNT=1;yx[i][j]=\"G\"+CNT;bomb(i,j,\"G\");}\n                  if(yx[i][j]==\"B\"){CNT=1;yx[i][j]=\"B\"+CNT;bomb(i,j,\"B\");}\n                  if(yx[i][j]==\"Y\"){CNT=1;yx[i][j]=\"Y\"+CNT;bomb(i,j,\"Y\");}\n                  if(yx[i][j]==\"P\"){CNT=1;yx[i][j]=\"P\"+CNT;bomb(i,j,\"P\");}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            if(color!=\".\")BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\nchar map[12][6];\nchar color[5]={'R','G','B','Y','P'};\nint d1[4]={0,1,0,-1};\nint d2[4]={1,0,-1,0};\nint flg,c;\nvoid swap(char *map1,char *map2){\n\tchar t;\n\tt=*map1;\n\t*map1=*map2;\n\t*map2=t;\n\treturn;\n}\nvoid fall(){\n\tint i,j,fl;\t\n\tfor(j=0;j<6;j++){\n\t\twhile(1){\t\n\t\t\tfl=0;\n\t\t\tfor(i=11;i>0;i--){\n\t\t\t\tif(map[i][j]=='.'&&map[i-1][j]!='.'){\n\t\t\t\t\tswap(&map[i][j],&map[i-1][j]);fl=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fl==0)break;\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs(char cl,int depth,int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&map[ny][nx]==cl){\n\t\t\tif(depth>=3){\n\t\t\t\tmap[ny][nx]='@';dfs(cl,depth+1,ny,nx);\n\t\t\t}else{\n\t\t\t\tmap[ny][nx]='#';dfs(cl,depth+1,ny,nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs2(int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&(map[ny][nx]=='#'||map[ny][nx]=='@')){\n\t\t\tmap[ny][nx]='*';dfs2(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid vanish(char cl){\n\tint i,j,k;\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]==cl){\n\t\t\t\tdfs(cl,1,i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='@'){\n\t\t\t\tdfs2(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='*'){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(map[i+d1[k]][j+d2[k]]=='O'&&0<=i+d1[k]&&i+d1[k]<12&&0<=j+d2[k]&&j+d2[k]<6){\n\t\t\t\t\t\tmap[i+d1[k]][j+d2[k]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[i][j]='.';flg=1;\n\t\t\t}else if(map[i][j]=='#'){\n\t\t\t\tmap[i][j]=cl;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint set;\n\tcin>>set;\n\tfor(set;set>0;set--){\n\t\tc=0;\n\t\tfor(int i=0;i<12;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\twhile(1){\n\t\t\tflg=0;\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tvanish(color[i]);\n\t\t\t}\n\t\t\tfall();\n\t\t\tif(flg==0)break;\n\t\t\tc++;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int r = 12,c=6;\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\n\nchar m[r][c];\nbool vis[r][c];\nbool willerase[r][c];\n//fall down\nvoid fall(){\n  for(int i=r-1;i>=0;i--){\n    rep(j,c){\n      int now=i;\n      if (m[now][j] == '.')continue;\n      while(now+1 < r && m[now+1][j] == '.')swap(m[now+1][j],m[now][j]),now++;\n    }\n  }\n}\n\n//find ojama\nvoid erase(int y,int x,char tar){\n  if (vis[y][x])return;\n  vis[y][x]=true;\n  m[y][x]='.';\n  rep(i,4){\n    int ney=y+dy[i],nex=x+dx[i];\n    if (ney == -1 || nex == -1 || ney == r || nex == c)continue;\n    if (m[ney][nex] == 'O')m[ney][nex]='.';\n    else if (m[ney][nex] == tar)erase(ney,nex,tar);\n  }\n}\n\n//dousyoku4ko\nvoid check(int y,int x,char tar,int &cnt){\n  if (vis[y][x])return;\n  vis[y][x]=true;\n  cnt++;\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex == -1 || ney == -1 || nex == c || ney == r || m[ney][nex] != tar)\n      continue;\n    check(ney,nex,tar,cnt);\n  }\n}\n\nint solve(){\n  int ret=0;\n  while(true){\n    bool isok=false;\n    rep(i,r)rep(j,c)vis[i][j]=false,willerase[i][j]=false;\n    rep(i,r){\n      rep(j,c)if (!vis[i][j] && m[i][j] != '.' && m[i][j] != 'O'){\n\tint tmp=0;\n\tcheck(i,j,m[i][j],tmp);\n\tif (tmp >= 4)willerase[i][j]=true,isok=true;\n      }\n    }\n    if (!isok)break;\n    rep(i,r)rep(j,c)vis[i][j]=false;\n    rep(i,r){\n      rep(j,c)if (willerase[i][j])erase(i,j,m[i][j]);\n    }\n    fall();\n    ret++;\n  }\n  return ret;\n}\n\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    rep(i,r)cin>>m[i];\n    cout << solve() << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { 1, 0, -1, 0 };\nint main() {\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tconst int H = 12, W = 6;\n\t\tvector<string> S(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tcin >> S[i];\n\t\t}\n\t\tfunction<int(int, int, bool)> get_comp = [&](int x, int y, bool del) {\n\t\t\tqueue<pair<int, int> > que; que.push(make_pair(x, y));\n\t\t\tchar ini = S[x][y];\n\t\t\tint cnt = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpair<int, int> u = que.front(); que.pop();\n\t\t\t\tS[u.first][u.second] = 'V';\n\t\t\t\t++cnt;\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint tx = u.first + dx[i], ty = u.second + dy[i];\n\t\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\t\t\tif (del && S[tx][ty] == 'O') {\n\t\t\t\t\t\t\tS[tx][ty] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (S[tx][ty] == ini) {\n\t\t\t\t\t\t\tque.push(make_pair(tx, ty));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (S[i][j] == 'V') {\n\t\t\t\t\t\tif (del) S[i][j] = '.';\n\t\t\t\t\t\telse S[i][j] = ini;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cnt;\n\t\t};\n\t\tint cnt = 0;\n\t\twhile (true) {\n\t\t\tbool chain = false;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (string(\"RGBYP\").find(S[i][j]) != string::npos) {\n\t\t\t\t\t\tint comps = get_comp(i, j, false);\n\t\t\t\t\t\tif (comps >= 4) {\n\t\t\t\t\t\t\tget_comp(i, j, true);\n\t\t\t\t\t\t\tchain = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chain) ++cnt;\n\t\t\telse break;\n\t\t\tfor (int i = 0; i < W; ++i) {\n\t\t\t\tfor (int j = H - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = j; k < H - 1; ++k) {\n\t\t\t\t\t\tif (S[k + 1][i] == '.') swap(S[k + 1][i], S[k][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nvector<string> puyo;\n\nbool valid(int x, int y)\n{\n\treturn 0 <= x && x < 6 && 0 <= y && y < 12;\n}\n\nbool _v[12][6];\nvector<pint> _c;\nvoid _connect(char c, int x, int y)\n{\n\tif (_v[y][x] || !valid(x, y) || puyo[y][x] != c)\n\t\treturn;\n\n\t_v[y][x] = true;\n\t_c.push_back(pint(x, y));\n\trep (i, 4)\n\t\t_connect(c, x + dx[i], y + dy[i]);\n}\nvector<pint> connect_puyo(char c, int x, int y)\n{\n\tCLEAR(_v, 0);\n\t_c.clear();\n\t_connect(c, x, y);\n\treturn _c;\n}\nvoid vanish(const vector<pint>& p)\n{\n\tforeach (it, p)\n\t{\n\t\tint x = it->first, y = it->second;\n\t\tpuyo[y][x] = '.';\n\t\trep (i, 4)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid(tx, ty) && puyo[ty][tx] == 'O')\n\t\t\t\tpuyo[ty][tx] = '.';\n\t\t}\n\t}\n}\nvoid fall()\n{\n\tfor (int x = 0; x < 6; ++x)\n\t{\n\t\tfor (int y = 0; y < 12; ++y)\n\t\t{\n\t\t\tif (puyo[y][x] != '.')\n\t\t\t\tcontinue;\n\n\t\t\tint t = -1;\n\t\t\tfor (int i = y + 1; i < 12 && t == -1; ++i)\n\t\t\t\tif (puyo[i][x] != '.')\n\t\t\t\t\tt = i;\n\t\t\tif (t != -1)\n\t\t\t\tswap(puyo[y][x], puyo[t][x]);\n\t\t}\n\t}\n}\nbool go()\n{\n\tbool vani = false;\n\tfor (int y = 0; y < 12; ++y)\n\t{\n\t\tfor (int x = 0; x < 6; ++x)\n\t\t{\n\t\t\tif (strchr(\"RGBYP\", puyo[y][x]))\n\t\t\t{\n\t\t\t\tvector<pint> p = connect_puyo(puyo[y][x], x, y);\n\t\t\t\tif (p.size() >= 4)\n\t\t\t\t{\n\t\t\t\t\tvanish(p);\n\t\t\t\t\tvani = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (vani)\n\t\tfall();\n\treturn vani;\n}\nvoid p()\n{\n\tfor (int i = 11; i >= 0; --i)\n\t\tcout << puyo[i] << endl;\n\tcout << endl;\n}\nint main()\n{\n\tint T;\n\tcin >> T;\n\twhile (T--)\n\t{\n\t\tpuyo = vector<string>(12);\n\t\trep (i, 12)\n\t\t\tcin >> puyo[11 - i];\n\n\t\tint res = 0;\n\t\twhile (go())\n\t\t\t++res;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\n\nint di[4] = {0, 0, 1, -1};\nint dj[4] = {1, -1, 0, 0};\n\nint main(){\n    int t;\n    cin >> t;\n    while(t-- > 0){\n        char mat[12][6];\n        for(int i = 0; i < 12; i++) for(int j = 0; j < 6; j++)  cin >> mat[i][j];\n        int ans = 0;\n        queue<pair<int,int>> q;\n        while(1){\n            bool see[12][6] = {}, del[12][6] = {}, erase = false;\n            for(int i = 0; i < 12; i++){\n                for(int j = 0; j < 6; j++){\n                    if(mat[i][j]=='.' || mat[i][j]=='O' || see[i][j])   continue;\n                    vector<pair<int,int>> tmp;\n                    q.push({i,j});\n                    while(!q.empty()){\n                        auto p = q.front(); q.pop();\n                        if(see[p.first][p.second])  continue;\n                        tmp.push_back(p);\n                        see[p.first][p.second] = true;\n                        for(int k = 0; k < 4; k++){\n                            int ni = p.first + di[k], nj = p.second + dj[k];\n                            if(inRange(ni,0,12)&&inRange(nj,0,6)&&!see[ni][nj]&&mat[ni][nj]==mat[i][j]){\n                                q.push({ni,nj});\n                            }\n                        }\n                    }\n                    if(tmp.size() < 4)  continue;\n                    erase = true;\n                    for(pair<int,int> p : tmp){\n                        del[p.first][p.second] = true;\n                        for(int k = 0; k < 4; k++){\n                            int ni = p.first+di[k], nj = p.second+dj[k];\n                            if(inRange(ni,0,12)&&inRange(nj,0,6)&&mat[ni][nj]=='O') del[ni][nj] = true;\n                        }\n                    }\n                }\n            }\n            if(!erase)  break;\n            for(int i = 0; i < 12; i++){\n                for(int j = 0; j < 6; j++){\n                    if(del[i][j])   mat[i][j] = '.';\n                }\n            }\n            for(int i = 11; i >= 0; i--){\n                for(int j = 0; j < 6; j++){\n                    if(mat[i][j] == '.')    continue;\n                    int cp = i;\n                    while(cp+1 < 12 && mat[cp+1][j]=='.')   swap(mat[cp][j], mat[cp+1][j]), cp++;\n                }\n            }\n            ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\n\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tint y = i+dy[k], x = j+dx[k];\n\t\tif(y >= 0 && y < 12 && x >= 0 && x < 6 \n\t\t\t&& area[y][x] == c && !used[y][x]){\n\t\t\tcounter += count(y, x, c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\t/*\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                cin >> f[i][j];\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=0;i<12;i++){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nvector<vector<int>>erase(vector<vector<int>>field) {\n\tint dx[4] = { -1,0,1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\n\tvector<vector<int>>dels(13,vector<int>(6));\n\tUnionFind uf(78);\n\tfor (int nowy = 0; nowy < 13; ++nowy) {\n\t\tfor (int nowx = 0; nowx < 6; ++nowx) {\n\t\t\tif (field[nowy][nowx] != -1 && field[nowy][nowx] != 0) {\n\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\tconst int nextx = nowx + dx[way];\n\t\t\t\t\tconst int nexty = nowy + dy[way];\n\t\t\t\t\tif (nextx >= 0 && nextx < 6 && nexty >= 0 && nexty < 13) {\n\t\t\t\t\t\tif (field[nexty][nextx] == field[nowy][nowx]) {\n\t\t\t\t\t\t\tuf.unionSet(nowy*6+nowx,nexty*6+nextx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int nowy = 0; nowy < 13; ++nowy) {\n\t\tfor (int nowx = 0; nowx < 6; ++nowx) {\n\t\t\tif (field[nowy][nowx] != -1 && field[nowy][nowx] != 0) {\n\t\t\t\tif (uf.size(nowy * 6 + nowx) >= 4) {\n\t\t\t\t\tdels[nowy][nowx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>>fin_dels(dels);\n\tfor (int nowy = 0; nowy < 13; ++nowy) {\n\t\tfor (int nowx = 0; nowx < 6; ++nowx) {\n\t\t\tif (field[nowy][nowx] ==-1) {\n\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\tconst int nextx = nowx + dx[way];\n\t\t\t\t\tconst int nexty = nowy + dy[way];\n\t\t\t\t\tif (nextx >= 0 && nextx < 6 && nexty >= 0 && nexty < 13) {\n\t\t\t\t\t\tif (dels[nexty][nextx]) {\n\t\t\t\t\t\t\tfin_dels[nowy][nowx]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn fin_dels;\n}\nvector<vector<int>>fall(vector<vector<int>>field) {\n\tfor (int k = 0; k < 13; ++k) {\n\t\tfor (int nowy = 12; nowy > 0; --nowy) {\n\t\t\tfor (int nowx = 0; nowx < 6; ++nowx) {\n\t\t\t\tif (!field[nowy][nowx]) {\n\t\t\t\t\tswap(field[nowy][nowx],field[nowy-1][nowx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn field;\n}\n\nint solve(vector<vector<int>>field) {\n\tint ans=0;\n\twhile (true) {\n\t\tvector<vector<int>>dels(erase(field));\n\t\tbool flag=false;\n\t\tfor (int y = 0; y < 13; ++y) {\n\t\t\tfor (int x = 0; x < 6; ++x) {\n\t\t\t\tif (dels[y][x]) {\n\t\t\t\t\tfield[y][x]=0;\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag)return ans;\n\t\tfield=fall(field);\n\t\tans++;\n\t}\n}\n\nint main() {\n\tint Q;cin>>Q;\n\t\n\twhile (Q--) {\n\t\tvector<vector<int>>field(13, vector<int>(6));\n\t\tmap<char, int>mp;\n\t\tmp['R'] = 1;\n\t\tmp['B'] = 2;\n\t\tmp['.'] = 0;\n\t\tmp['G'] = 3;\n\t\tmp['P'] = 4;\n\t\tmp['O']=-1;\n\t\tmp['Y']=5;\n\t\tfor (int i = 0; i < 12; ++i) {\n\t\t\tstring st;cin>>st;\n\t\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\t\tchar ch(st[j]);\n\t\t\t\tfield[i+1][j]=mp[ch];\n\t\t\t}\n\t\t}\n\t\tint ans=solve(field);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,total=0;\nstring t[12];\nint u[12][6],vd[12][6];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint nx,ny,ans,cnt,I,J,K,flg;\nchar key;\nint BlockDelete();\nvoid dfs(int,int);\nvoid dfs2(int,int);\nvoid init();\nvoid put();\nchar tmp[12];\nint main(){\n  cin>>n;\n  while(n--){\n    ans=0;\n    for(int i=0;i<12;i++)cin>>t[i];\n    while(BlockDelete()){\n      ans++;\n      put();\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nint BlockDelete(){\n  //cout<<\"BlockDelete\"<<endl;total++;\n  flg=0;\n  init();\n\n  for(int i=0;i<12;i++){\n    for(int j=0;j<6;j++){\n      if(t[i][j]!='O'&&!vd[i][j]&&t[i][j]!='.'){\n\tcnt=0;\n\tdfs(i,j);\n\tif(cnt>=4){\n\t  flg=1;\n\t  key=t[i][j];\n\t  dfs2(i,j);\n\t}\n      }\n    }\n  }\n  return flg;\n}\n\nvoid dfs(int y,int x){\n  //cout<<\"dfs\"<<endl;total++;\n  cnt++;\n  vd[y][x]=1;\n  for(int i=0;i<4;i++){\n    ny=y+dy[i];nx=x+dx[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12)\n      if(t[y][x]==t[ny][nx]&&!vd[ny][nx])dfs(ny,nx);\n  }\n}\nvoid dfs2(int y,int x){\n  //cout<<\"dfs2\"<<endl;total++;\n  t[y][x]='.';\n  for(int i=0;i<4;i++){\n    ny=y+dy[i];nx=x+dx[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12){\n      if(key==t[ny][nx]){\n\tdfs2(ny,nx);\n      }else if('O'==t[ny][nx]){\n\tt[ny][nx]='.';\n      }\n    }\n  }\n  \n}\nvoid init(){\n\n  //cout<<\"init\"<<endl;total++;\n  for(I=0;I<12;I++){\n    for(J=0;J<6;J++){\n      vd[I][J]=0;\n    }\n  }\n}\n\nvoid put(){\n  //cout<<\"put\"<<endl;total++;\n  for(J=0;J<6;J++){\n    K=11;\n    for(I=11;I>=0;I--){\n      if(t[I][J]!='.')tmp[K--]=t[I][J];\n    }\n    for(I=11;I>=0;I--){\n      if(I>K)t[I][J]=tmp[I];\n      else t[I][J]='.';\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tif(i+dy[k] >= 0 && i+dy[k] < 12 && j+dx[k] >= 0 && j+dx[k] < 6 \n\t\t\t&& area[i+dy[k]][j+dx[k]] == c && !used[i+dy[k]][j+dx[k]]){\n\t\t\tcounter += count(i+dy[k], j+dx[k], c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6 && area[y2][x2] == c) rem(y2, x2, c);\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.'){\n\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\nchar board[12][6];\nint updboard[12][6];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nvoid fallstone() {\n  //ツ猟篠づつキ\n  for(int k=0; k<12; ++k)\n    for(int i=0; i<11; ++i)\n      for(int j=0; j<6; ++j)\n\tif(board[i][j] != '.' && board[i+1][j] == '.') {\n\t  board[i+1][j] = board[i][j];\n\t  board[i][j] = '.';\n\t}\n    return;\n}\n\nvoid deletestone(int stnum) {\n  for(int i=0; i<12; ++i)\n    for(int j=0; j<6; ++j)\n      if(updboard[i][j] == 2) {\n\tif(stnum >= 4) {\n\t  board[i][j] = '.';\n\t  for(int p=0; p<4; ++p)\n\t    for(int q=0; q<4; ++q)\n\t      if(i+dx[p] >= 0 && i+dx[p] < 12\n\t\t && j+dy[q] >= 0 && j+dy[q] < 6\n\t\t && board[j+dx[p]][j+dy[q]] == 'O')\n\t\tboard[i+dx[p]][j+dy[q]] = '.';\n\t}\n\tupdboard[i][j] = 1;\n      }\n  return;\n}\n\nvoid init() {\n  for(int i=0; i<12; ++i)\n    for(int j=0; j<6; ++j)\n      updboard[i][j] = 0;\n  return;\n}\n\nint solve() {\n  int res = 0;\n  bool update = false;\n\n  while(1) {\n\n    update = false;\n    init();\n\n    //4ツづつ暗按湘」ツづつづ按つェツづづつ「ツづゥツ閉板閉ェツづーツ探ツつキ\n    for(int i=0; i<12; ++i) {\n      for(int j=0; j<6; ++j) {\n\tif(updboard[i][j] != 0) continue;\n\tif(board[i][j] == 'O' || board[i][j] == '.') continue;\n\tqueue< pair<int,int> > Q;\n\tQ.push(pair<int,int>(i,j));\n\tint samecolors = 1;\n\twhile(!Q.empty()) {\n\t  pair<int,int> np = Q.front(); Q.pop();\n\t  updboard[np.first][np.second] = 2;\n\t  for(int k=0; k<4; ++k) {\n\t    int nx = np.first+dx[k],ny = np.second+dy[k];\n\t    if(nx >= 0 && nx < 12 && ny >= 0 && ny < 6\n\t       && board[nx][ny] == board[i][j] && updboard[nx][ny] == 0) {\n\t      samecolors++;\n\t      Q.push(pair<int,int>(nx,ny));\n\t    }\n\t  }\n\t}\n\n\tif(samecolors >= 4) update = true;\n\tdeletestone(samecolors);\n      }\n    }\n\n    fallstone();\n    if(!update) break;\n\n    /*\n    //debug output\n    for(int i=0; i<12; ++i) {\n      for(int j=0; j<6; ++j) {\n\tcout<<board[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    res++;\n  }\n\n  return res;\n}\n\nint main() {\n  int n;\n  string in;\n  cin>>n;\n  for(int k=0; k<n; ++k) {\n    for(int j=0; j<12; ++j) {\n      cin>>in;\n      for(int i=0; i<6; ++i)\n\tboard[j][i] = in.at(i);\n    }\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<queue>\n#include<string.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nchar cmap[13][13];\nbool used[13][13];\nint imap[13][13];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nint Cnt = 0;\n\nvoid dfs(int x,int y,char c,int cnt)\n{\n  used[y][x] = true; \n  int fcnt = 0;\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12&&cmap[ny][nx] == c && !used[ny][nx]){\n      fcnt++; Cnt++;\n      dfs(nx,ny,c,cnt+1);\n    }\n  }\n  if(fcnt == 0)imap[y][x] = Cnt;\n}\n\nvoid erase(int x,int y,char c)\n{\n  used[y][x] = true;\n  cmap[y][x] = '.';\n\n  queue<P> que;\n  que.push(P(x,y));\n\n  while(!que.empty())\n    {\n      P p = que.front(); que.pop();\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.F+dx[i],ny = p.S+dy[i];\n\n\t  if(0<=nx&&nx<6&&0<=ny&&ny<12&& ((!used[ny][nx] && cmap[ny][nx] == c) || cmap[ny][nx] == 'O'))\n\t    {\n\t      if(cmap[ny][nx] != 'O')que.push(P(nx,ny));\n\t      cmap[ny][nx] = '.';\n\t      used[ny][nx] = true;\n\t      \n\t    }\n\t}\n    }\n}\n\nvoid display()\n{\n\n  for(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << cmap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  /*\nfor(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << imap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  */\n  cout << endl;\n}\n\n\nvoid drop(int x,int y)\n{\n  //cout << \"x = \" << x << \", y = \" << y << endl;\n  int st,ed;\n  st = y;\n  ed = -1;\n  for(int i=y;i>=0;i--)\n    {\n      if(ed == -1 && cmap[i][x] != '.')\n\t{\n\t  ed = i+1;\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] =\" << cmap[st+ed-(i+1)][x] << \", cmpa[\"<<i<<\"][x] = \"<<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] != '.')\n\t{\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] = \" << cmap[st+ed-(i+1)][x] << \", cmap[\"<<i<<\"][x] = \" <<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] == '.')\n\t{\n\t  st = i;\n\t  ed = -1;\n\t}      \n\n    }\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  while(N-- > 0)\n    {\n      for(int i=0;i<12;i++)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  for(int j=0;j<s.length();j++)\n\t    {\n\t      cmap[i][j] = s[j];\n\t      used[i][j] = false;\n\t      imap[i][j] = -1;\n\t    }\n\t}\n\n      int cnt = 0;\n      while(true)\n\t{\n\t  //display();\n\t  int increase = 0;\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)\n\t\t\t\t {\n\t\t\t\t   imap[i][j] = -1;\n\t\t\t\t   used[i][j] = false;\n\t\t\t\t }\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(cmap[i][j] != '.' && cmap[i][j] != 'O' && !used[i][j])\n\t\t    {\n\t\t      Cnt=1;\n\t\t      dfs(j,i,cmap[i][j],1); //最大何マスつながっているか\n\t\t    }\n\t\t}\n\t    }\n\t\n\t  memset(used,0,sizeof(used));\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)used[i][j] = false;\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(!used[i][j] && imap[i][j] >= 4){\n\t\t    increase++;\n\t\t    erase(j,i,cmap[i][j]);\n\t\t  }\n\t\t}\n\t    }\n\t  //display();\n\t  if(increase == 0)\n\t    {\n\t      break;\n\t    }\n\t  cnt++;\n\n\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      for(int j=11;j>=0;j--)\n\t\t{\n\t\t  if(cmap[j][i] == '.')\n\t\t    {\n\t\t      drop(i,j);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t    }\n\n\n\n\n\n\t}\n\n      cout<< cnt << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int H = 12;\nconst int W = 6;\n\nconst int dy[4]={1,-1,0,0};\nconst int dx[4]={0,0,1,-1};\n\nconst vector<vector<bool>> B(H, vector<bool>(W, false));\n\nbool IN(int y, int x){\n    return 0<=y && y<H && 0<=x && x<W;\n}\n\nvector<string> f(const vector<string> &s){\n    vector<string> t(s);\n\n    vector<vector<bool>> er(B), vis(B);\n\n    rep(i,H)rep(j,W){\n        if(vis[i][j]) continue;\n\n        char c = s[i][j];\n        if(c=='O' || c=='.') continue;\n\n        queue<pi> que;\n        vector<pi> cc;\n\n        vis[i][j] = true;\n        cc.pb({i,j});\n        que.push({i,j});\n        while(!que.empty()){\n            pi now = que.front();\n            que.pop();\n            rep(d,4){\n                int ny = now.fi+dy[d], nx = now.se+dx[d];\n                if(!IN(ny,nx)) continue;\n                if(!vis[ny][nx] && s[ny][nx]==c){\n                    vis[ny][nx] = true;\n                    cc.pb({ny,nx});\n                    que.push({ny,nx});\n                }\n            }\n        }\n\n        if(cc.size()>=4){\n            for(pi p:cc){\n                er[p.fi][p.se] = true;\n                rep(d,4){\n                    int ny = p.fi+dy[d], nx = p.se+dx[d];\n                    if(!IN(ny,nx)) continue;\n                    if(s[ny][nx]=='O') er[ny][nx] = true;\n                }\n            }\n        }\n    }\n\n    rep(i,H)rep(j,W)if(er[i][j]) t[i][j] = '.';\n\n    rep(j,W){\n        vector<char> obj;\n        for(int i=H-1; i>=0; --i){\n            if(t[i][j]!='.') obj.pb(t[i][j]);\n            t[i][j] = '.';\n        }\n\n        int idx = H-1;\n        for(char c:obj) t[idx--][j] = c;\n    }\n    return t;\n}\n\nint solve(){\n    vector<string> s(H);\n    rep(i,H) cin >>s[i];\n\n    int ret = 0;\n    while(1){\n        vector<string> nx = f(s);\n        if(nx == s) break;\n        ++ret;\n        s = nx;\n    }\n    return ret;\n}\n\nint main(){\n    int T;\n    cin >>T;\n    while(T--) cout << solve() << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nchar p[12][7];\nint f[12][6];\nchar memo;\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint dfs(int y, int x, int c){\n  //  fprintf(stderr, \"%d %d %d\\n\", y, x, c);\n  int ret = 0;\n  bool flag = 0;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= 12 || nx >= 6 || memo != p[ny][nx] || f[ny][nx]) continue;\n    flag = 1;\n    f[ny][nx] = 1;\n    //    fprintf(stderr, \"%d %d %d\\n\", ny, nx, c+1);\n    ret += dfs(ny, nx, c+1);\n    if(!ret) f[ny][nx] = 0;\n  }\n\n  if(!flag  && c >= 4){\n    return 1;\n  }\n  return ret;\n}\n\nvoid ojama(){\n  rep(i, 12) rep(j, 7){\n    if(p[i][j] != 'O') continue;\n    //    printf(\"%d %d\\n\", i, j);\n    rep(d, 4){\n      int ny = i + dy[d], nx = j + dx[d];\n      if(ny < 0 || nx < 0 || ny >= 12 || nx >= 6 || !f[ny][nx]) continue;\n      f[i][j] = 1;\n      break;\n    }\n  }\n  return;\n}\n\nvoid del(){\n  rep(i, 12) rep(j, 6){\n    if(!f[i][j]) continue;\n    p[i][j] = '.';\n  }\n  return;\n}\n\nvoid next(){\n  rep(i, 12){\n    rep(j, 6) printf(\"%d \", f[i][j]); puts(\"\");\n    }\n\n  for(int i = 11; i >= 0; i--) rep(j, 6){\n      if(p[i][j] != '.') continue;\n      for(int k = i; k >= 0; k--){\n\tif(p[k][j] == '.') continue;\n\tp[i][j] = p[k][j];\n\tp[k][j] = '.';\n\tbreak;\n      }\n    }\n\n  rep(i, 12){\n    puts(p[i]);\n  }\n  return;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  while(n--){\n    //    puts(\"in\");\n    rep(i, 12){\n      scanf(\"%s\", p[i]);\n    }\n\n    int res = 0;\n    while(true){\n      //      fprintf(stderr, \"%d\\n\", res);\n      int judge = 0, flag = 0;;\n      memset(f, 0, sizeof(f));\n      rep(i, 12) rep(j, 6){\n\t//\tfprintf(stderr, \"%d %d\\n\", i, j);\n\tif(p[i][j] == '.' || p[i][j] == 'O'|| f[i][j]) continue;\n\t//\tfprintf(stderr, \"%d %d\\n\", i, j);\n\tmemo = p[i][j];\n\tflag = dfs(i, j, 0);\n\tjudge += flag;\n\t//\tfprintf(stderr, \"%d\\n\", judge);\n\tif(flag) f[i][j] = 1;\n      }\n      //      printf(\"%d\\n\", judge);\n      if(!judge) break;\n      ojama();\n      //      fprintf(stderr, \"ojama\\n\");\n      del();\n      //      fprintf(stderr, \"del\\n\");\n      next();\n      //      fprintf(stderr, \"next\\n\");\n      res++;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint h=12,w=6,dx[]={1,0,-1,0},dy[]={0,1,0,-1},c,T;\nchar m[101][101];\n\nvoid dfs(int y,int x,char ch){\n\tm[y][x]='?';c++;\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(ny>=0&&ny<h&&nx>=0&&nx<w&&m[ny][nx]==ch)dfs(ny,nx,ch);\n\t\tif(ny>=0&&ny<h&&nx>=0&&nx<w&&m[ny][nx]=='O')m[ny][nx]='o';\n\t}\n}\n\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tint ans=0;\n\t\trep(i,h)rep(j,w)cin>>m[i][j];\n\t\twhile(1){\n\t\t\tint f=0;\n\t\t\trep(i,h)rep(j,w)if(m[i][j]!='.'&&m[i][j]!='O'){\n\t\t\t\tc=0;\n\t\t\t\tchar ch=m[i][j];\n\t\t\t\tdfs(i,j,m[i][j]);\n\t\t\t\trep(k,h)rep(l,w){\n\t\t\t\t\tif(m[k][l]=='?'){\n\t\t\t\t\t\tif(c>3){m[k][l]='.';f=1;}\n\t\t\t\t\t\telse m[k][l]=ch;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[k][l]=='o'){\n\t\t\t\t\t\tif(c>3)m[k][l]='.';\n\t\t\t\t\t\telse m[k][l]='O';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t\tfor(int i=h-1;i>=0;i--)rep(j,w){\n\t\t\t\tif(m[i][j]!='.'){\n\t\t\t\t\tint ny=i;\n\t\t\t\t\twhile(ny!=h-1&&m[ny+1][j]=='.')ny++;\n\t\t\t\t\tif(ny!=i){\n\t\t\t\t\t\tm[ny][j]=m[i][j];\n\t\t\t\t\t\tm[i][j]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n#define all(n) n.begin(),n.end()\n\nconst int MAXW = 6, MAXH = 12;\nchar tile[MAXW + 2][MAXH + 2];\nint checked[MAXW + 2][MAXH + 2];\nchar c;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nint countt(int x, int y)\n{\n    if(tile[x][y] != c) return 0;\n    checked[x][y] = 1;\n    int ans = 1;\n    REP(4)if(!checked[x + dx[i]][y + dy[i]]) ans += countt(x + dx[i], y + dy[i]);\n    return ans;\n}\nvoid van(int x, int y)\n{\n    if(tile[x][y] == 'O') { tile[x][y] = 'v'; return ;}\n    if(tile[x][y] != c) return ;\n    tile[x][y] = 'v';\n    REP(4) van(x + dx[i], y + dy[i]);\n    return;\n}\nvoid test()\n{\n    rep(j, MAXH){rep(i, MAXW) cout << tile[i+1][j+1]; cout << endl;}\n\n}\n\nint main()\n{\n    int t; cin >> t;\n    while(t--)\n    {\n        memset(tile, '.', sizeof(tile));\n        rep(j,MAXH)rep(i,MAXW)cin >> tile[i + 1][j + 1];\n        int vaned = 0;\n        for(int ans = 0; 1; ans++)\n        {\n            vaned = 0;\n            memset(checked, 0, sizeof(checked));\n            for(int i = 1; i <= MAXW; i++)for(int j= 1; j<= MAXH; j++)if(tile[i][j] != 'O' && tile[i][j] != '.' && tile[i][j] != 'v')\n            {\n                int cnt = 0;\n                c = tile[i][j];\n                cnt = countt(i, j);// cout << \"count \" << i << \" \"<< j << \" :\" << cnt << endl;\n                if(cnt >= 4) { van(i, j); vaned = 1;}\n            }\n            //test();\n\n            if(!vaned) { cout << ans << endl; break;}\n        \n            rep(l,12)for(int i = 1; i <= MAXW; i++)for(int j = MAXH; j > 0; j--)if(tile[i][j] == 'v')\n            {\n                for(int k = j; k > 0; k--)tile[i][k] = tile[i][k - 1];\n                /*\n                for(int k = 1 ;k <= MAXH; k++)if(tile[i][j - k] != 'v')\n                    for(int l = j; l >= j - k; l--)\n                    {\n                        if(l - k >= 0) tile[i][l - k] = tile[i][l - k];\n                        else tile[i][l - k] = '.';\n                    }*/\n            }\n            //cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nint TEST;\nstring s[12];\nbool u[12][9];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint dfs(int y,int x,char c){\n  int res=1;\n  u[y][x]=1;\n  r(i,4){\n    int yy=y+dy[i];\n    int xx=x+dx[i];\n    if(yy<0||xx<0||yy>11||xx>5)continue;\n    if(s[yy][xx]==c&&!u[yy][xx])res+=dfs(yy,xx,c);\n  }\n  return res;\n}\nvoid ell(int y,int x,char c){\n  s[y][x]='.';\n  r(i,4){\n    int yy=y+dy[i];\n    int xx=x+dx[i];\n    if(yy<0||xx<0||yy>11||xx>5)continue;\n    if(s[yy][xx]==c)ell(yy,xx,c);\n  }\n}\nvoid fall(){\n  r(i,12)r(j,6)if(s[i][j]=='O'){\n    r(k,4){\n      int y=i+dy[k];\n      int x=j+dx[k];\n      if(x<0||y<0||x>5||y>11)continue;\n      s[i][j]='.';\n    }\n  }\n  r(k,12)r(i,6)for(int j=11;j>0;j--)\n    if(s[j][i]=='.')swap(s[j][i],s[j-1][i]);\n}\nint solve(){\n  for(int ans=0;;ans++){\n    int f=0;\n    memset(u,0,sizeof(u));\n    vector<P>v;\n    r(i,12)r(j,6)if(!u[i][j]&&isalpha(s[i][j])&&s[i][j]!='O'){\n      if(dfs(i,j,s[i][j])>=4)v.push_back(P(i,j));\n    }\n    if(!v.size())return ans;\n    r(i,v.size())ell(v[i].first,v[i].second,s[v[i].first][v[i].second]);\n    fall();\n  }\n}\nint main(){\n  cin>>TEST;\n  while(TEST--){\n    r(i,12)cin>>s[i];\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar str[15][10];\nint UF[100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tfor(int i=0;i<12;i++)scanf(\"%s\",str[i]);\n\t\tbool chg;\n\t\tint ret=0;\n\t\tdo{\n\t\t\tchg=false;\n\t\t\tfor(int i=0;i<72;i++)UF[i]=-1;\n\t\t\tfor(int i=0;i<12;i++)for(int j=0;j<6;j++){\n\t\t\t\tif(str[i][j]=='.'||str[i][j]=='O')continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<12&&0<=j+dy[k]&&j+dy[k]<6&&str[i][j]==str[i+dx[k]][j+dy[k]]){\n\t\t\t\t\t\tUNION(i*6+j,(i+dx[k])*6+j+dy[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(str[i][j]=='.')continue;\n\t\t\t\t\tif(str[i][j]=='O'){\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<12&&0<=j+dy[k]&&j+dy[k]<6&&UF[FIND((i+dx[k])*6+j+dy[k])]<=-4){\n\t\t\t\t\t\t\t\tstr[i][j]='.';chg=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(UF[FIND(i*6+j)]<=-4){str[i][j]='.';chg=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint at=11;\n\t\t\t\tfor(int j=11;j>=0;j--){\n\t\t\t\t\tif(str[j][i]!='.'){\n\t\t\t\t\t\tstr[at--][i]=str[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<=at;j++)str[j][i]='.';\n\t\t\t}\n\t\t\tif(chg)ret++;\n\t\t\t//for(int i=0;i<12;i++)printf(\"%s\\n\",str[i]);printf(\"\\n\");\n\t\t}while(chg);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) v.begin(), v.end()\n#define rev(v) v.rbegin(), v.rend()\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nbool mark[12][6] = {false};\nint c;\nconst int h = 12, w = 6;\n\nvoid clear(){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tmark[i][j] = false;\n\t\t}\n\t}\n}\n\nvoid del(vector<string> &map){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(mark[i][j]){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif((j+dx[k]<0||j+dx[k]>=w)||(i+dy[k]<0||i+dy[k]>=h))continue;\n\t\t\t\t\tif(map[i+dy[k]][j+dx[k]] == 'O') map[i+dy[k]][j+dx[k]] = '.';\n\t\t\t\t}\n\t\t\t\tmap[i][j] = '.';\n\t\t\t\tmark[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(char target, int y, int x, vector<string> &map){\n\tmark[y][x] = true;\n\tfor(int i = 0; i < 4; i++){\n\t\tif((x+dx[i]<0||x+dx[i]>=w)||(y+dy[i]<0||y+dy[i]>=h))continue;\n\t\tif(map[y+dy[i]][x+dx[i]] == target && !mark[y+dy[i]][x+dx[i]]){\n\t\t\tc++;\n\t\t\tdfs(target, y+dy[i], x+dx[i], map);\n\t\t}\n\t}\n}\n\nint main(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n\tint n = 0;\n\tcin >> n;\n\twhile(n--){\n\t\tvector<string> map(h, string(w, ' '));\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> map[i];\n\t\t}\n\t\tint chain = 0;\n\t\twhile(1){\n\t\t\tbool chainf = false;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(map[i][j]=='.' || map[i][j]=='O')continue;\n\t\t\t\t\tc = 1;\n\t\t\t\t\tdfs(map[i][j], i, j, map);\n\t\t\t\t\tif(c >= 4){\n\t\t\t\t\t\tdel(map);\n\t\t\t\t\t\tchainf = true;\n\t\t\t\t\t}\n\t\t\t\t\telse clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chainf) chain++;\n\t\t\telse break;\n\t\t\tfor(int i = h-2; i >= 0; i--){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tint tmp = i;\n\t\t\t\t\twhile(tmp+1<h&&map[tmp+1][j]=='.'){\n\t\t\t\t\t\tmap[tmp+1][j] = map[tmp][j];\n\t\t\t\t\t\tmap[tmp][j] = '.';\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << chain << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nint TEST;\nstring s[12];\nbool u[12][9];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nset<P>st;\nint dfs(int y,int x,char c){\n  int res=1;\n  u[y][x]=1;\n  r(i,4){\n    int yy=y+dy[i];\n    int xx=x+dx[i];\n    if(yy<0||xx<0||yy>11||xx>5)continue;\n    if(s[yy][xx]==c&&!u[yy][xx])res+=dfs(yy,xx,c);\n  }\n  return res;\n}\nvoid ell(int y,int x,char c){\n  s[y][x]='.';\n  st.insert(P(y,x));\n  r(i,4){\n    int yy=y+dy[i];\n    int xx=x+dx[i];\n    if(yy<0||xx<0||yy>11||xx>5)continue;\n    if(s[yy][xx]==c)ell(yy,xx,c);\n  }\n}\nvoid fall(){\n  r(i,12)r(j,6)if(s[i][j]=='O'){\n    r(k,4){\n      int y=i+dy[k];\n      int x=j+dx[k];\n      if(x<0||y<0||x>5||y>11)continue;\n      if(st.count(P(y,x)))s[i][j]='.';\n    }\n  }\n  r(k,12)r(i,6)for(int j=11;j>0;j--)\n    if(s[j][i]=='.')swap(s[j][i],s[j-1][i]);\n}\nint solve(){\n  for(int ans=0;;ans++){\n    st.clear();\n    int f=0;\n    memset(u,0,sizeof(u));\n    vector<P>v;\n    r(i,12)r(j,6)if(!u[i][j]&&isalpha(s[i][j])&&s[i][j]!='O'){\n      if(dfs(i,j,s[i][j])>=4)v.push_back(P(i,j));\n    }\n    if(!v.size())return ans;\n    r(i,v.size())ell(v[i].first,v[i].second,s[v[i].first][v[i].second]);\n    fall();\n  }\n}\nint main(){\n  cin>>TEST;\n  while(TEST--){\n    r(i,12)cin>>s[i];\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) v.begin(), v.end()\n#define rev(v) v.rbegin(), v.rend()\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nbool mark[12][6] = {false};\nint c;\nconst int h = 12, w = 6;\n\nvoid clear(){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tmark[i][j] = false;\n\t\t}\n\t}\n}\n\nvoid del(vector<string> &map){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(mark[i][j]){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif((j+dx[k]<0||j+dx[k]>=w)||(i+dy[k]<0||i+dy[k]>=h))continue;\n\t\t\t\t\tif(map[i+dy[k]][j+dx[k]] == 'O') map[i+dy[k]][j+dx[k]] = '.';\n\t\t\t\t}\n\t\t\t\tmap[i][j] = '.';\n\t\t\t\tmark[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(char target, int y, int x, vector<string> &map){\n\tmark[y][x] = true;\n\tfor(int i = 0; i < 4; i++){\n\t\tif((x+dx[i]<0||x+dx[i]>=w)||(y+dy[i]<0||y+dy[i]>=h))continue;\n\t\tif(map[y+dy[i]][x+dx[i]] == target && !mark[y+dy[i]][x+dx[i]]){\n\t\t\tc++;\n\t\t\tdfs(target, y+dy[i], x+dx[i], map);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n = 0;\n\tcin >> n;\n\twhile(n--){\n\t\tvector<string> map(h, string(w, ' '));\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> map[i];\n\t\t}\n\t\tint chain = 0;\n\t\twhile(1){\n\t\t\tbool chainf = false;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(map[i][j]=='.' || map[i][j]=='O')continue;\n\t\t\t\t\tc = 1;\n\t\t\t\t\tdfs(map[i][j], i, j, map);\n\t\t\t\t\tif(c >= 4){\n\t\t\t\t\t\tdel(map);\n\t\t\t\t\t\tchainf = true;\n\t\t\t\t\t}\n\t\t\t\t\telse clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chainf) chain++;\n\t\t\telse break;\n\t\t\tfor(int i = h-2; i >= 0; i--){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tint tmp = i;\n\t\t\t\t\twhile(tmp+1<h&&map[tmp+1][j]=='.'){\n\t\t\t\t\t\tmap[tmp+1][j] = map[tmp][j];\n\t\t\t\t\t\tmap[tmp][j] = '.';\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << chain << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint T;\nchar N[12][7];\nint tmp[12][6];\nint cnt;\nchar c;\n\nvoid init() {\n  scanf(\"%d\", &T);\n}\n\nbool input() {\n  int i;\n\n  if(!T) return false;\n  T--;\n  for (i = 0; i < 12; i++) {\n    scanf(\" %s\", N[i]);\n  }\n  return true;\n}\n\nvoid jama(int y, int x) {\n  if (x < 0 || 6 <= x || y < 0 || 12 <= y) return;\n  if (N[y][x] == 'O') {\n    tmp[y][x] = 2;\n  }\n\n  return;\n}\n\nvoid funk(int y, int x) {\n  if (x < 0 || 6 <= x || y < 0 || 12 <= y) return;\n  if (tmp[y][x] != 0 || N[y][x] != c) return;\n  tmp[y][x] = 1;\n  cnt++;\n  funk(y - 1, x    );\n  funk(y + 1, x    );\n  funk(y    , x - 1);\n  funk(y    , x + 1);\n}\n\nbool kesu() {\n  int i, j;\n  bool flag = false, k = true;\n\n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 6; j++) {\n      if (tmp[i][j] == 2) {\n        flag = true;\n        N[i][j] = '.';\n      }\n    }\n  }\n  while (k) {\n    k = false;\n    for (i = 11; i > 0; i--) {\n      for (j = 0; j < 6; j++) {\n        if (N[i][j] == '.' && N[i - 1][j] != '.') {\n          k = true;\n          N[i    ][j] = N[i - 1][j];\n          N[i - 1][j] = '.';\n        }\n      }\n    }\n  }\n    return flag;\n}\n\nint main() {\n  int i, j, k, a, b;\n  long long int sum;\n  bool flag;\n\n  init();\n  while (input()) {\n    sum = 0;\n    flag = true;\n    while (flag) {\n      fill(tmp[0], tmp[0] + 12 * 6, 0);\n      for (i = 0; i < 12; i++) {\n        for (j = 0; j < 6; j++) {\n          if (N[i][j] != 'O' && N[i][j] != '.') {\n            c = N[i][j];\n            cnt = 0;\n            funk(i, j);\n\n\n            if (cnt > 3) {\n              for (a = 0; a < 12; a++) {\n                for (b = 0; b < 6; b++) {\n                  if(tmp[a][b] == 1)\n                    tmp[a][b] = 2;\n                  jama(a - 1, b    );\n                  jama(a + 1, b    );\n                  jama(a    , b - 1);\n                  jama(a    , b + 1);\n                }\n              }\n            } else {\n              for (a = 0; a < 12; a++) {\n                for (b = 0; b < 6; b++) {\n                  if(tmp[a][b] == 1)\n                    tmp[a][b] = 3;\n                }\n              }\n            }\n\n\n          }\n        }\n      }\n\n\n      flag = kesu();\n      if (flag) sum++;\n    }\n    /*\n    for (i = 0; i < 12; i++) {\n      printf(\"%s \", N[i]);\n      for (j = 0; j < 6; j++) {\n        printf(\"%d\", tmp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    printf(\"%d\\n\", sum);\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                scanf(\" %c\", &f[i][j]);\n            }\n        }\n        int max_deleted = 0;\n        int res = 0,tx,ty;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=11;i>=0;i--){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(max_deleted < 4) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nchar p[12][7];\nint f[12][6], dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\n\nint main(void){\n\tint a, b, i, j, k, l, g, n, flag, cnt, m;\n\tqueue<pair<int,int> > que;\n\tscanf(\"%d%*c\",&n);\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = 0;j < 12;j++)\n\t\t\tgets(p[j]);\n\t\tm = 0;\n\t\twhile(1){\n\t\t\tflag = 1;\n\t\t\tmemset(f,0,sizeof(f));\n\t\t\tfor(j = 0;j < 12;j++){\n\t\t\t\tfor(k = 0;k < 6;k++){\n\t\t\t\t\tif(p[j][k] != '.' && p[j][k] != 'O' && !f[j][k]){\n\t\t\t\t\t\tque.push(pair<int,int>(j,k));\n\t\t\t\t\t\tf[j][k] = 1;\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\twhile(que.size()){\n\t\t\t\t\t\t\ta = que.front().first;\n\t\t\t\t\t\t\tb = que.front().second;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\t\t\t\tif(a + dy[l] >= 0 && a + dy[l] < 12 && b + dx[l] >= 0 && b + dx[l] < 6 && !f[a + dy[l]][b + dx[l]] && p[j][k] == p[a + dy[l]][b + dx[l]]){\n\t\t\t\t\t\t\t\t\tf[a + dy[l]][b + dx[l]] = 1;\n\t\t\t\t\t\t\t\t\tque.push(pair<int,int>(a + dy[l],b + dx[l]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt >= 4){\n\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\tque.push(pair<int,int>(j,k));\n\t\t\t\t\t\t\tchar c = p[j][k];\n\t\t\t\t\t\t\tp[j][k] = '.';\n\t\t\t\t\t\t\twhile(que.size()){\n\t\t\t\t\t\t\t\ta = que.front().first;\n\t\t\t\t\t\t\t\tb = que.front().second;\n\t\t\t\t\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\t\t\t\t\tif(a + dy[l] >= 0 && a + dy[l] < 12 && b + dx[l] >= 0 && b + dx[l] < 6){\n\t\t\t\t\t\t\t\t\t\tif(c == p[a + dy[l]][b + dx[l]]){\n\t\t\t\t\t\t\t\t\t\t\tque.push(pair<int,int>(a + dy[l],b + dx[l]));\n\t\t\t\t\t\t\t\t\t\t\tp[a + dy[l]][b + dx[l]] = '.';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(p[a + dy[l]][b + dx[l]] == 'O')\n\t\t\t\t\t\t\t\t\t\t\tp[a + dy[l]][b + dx[l]] = '.';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tfor(j = 10;j >= 0;j--){\n\t\t\t\tfor(k = 0;k < 6;k++){\n\t\t\t\t\tif(p[j][k] != '.' && p[j + 1][k] == '.'){\n\t\t\t\t\t\tfor(l = j;p[l + 1][k] == '.' && l < 11;l++);\n\t\t\t\t\t\tp[l][k] = p[j][k];\n\t\t\t\t\t\tp[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm++;\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint main()\n{\n  int T;\n  while (cin >> T) {\n    for (int t = 0; t < T; ++t) {\n      vector<string> puyo(12);\n      for (int i = 0; i < 12; ++i)\n\tcin >> puyo[i];\n\n      int ans = 0;\n      for ( ; ; ) {\n\tbool update = false;\n\tvector<vector<int> > visited(puyo.size(), vector<int>(puyo[0].size(), 0));\n\tfor (unsigned int i = 0; i < puyo.size(); ++i) {\n\t  for (unsigned int j = 0; j < puyo[0].size(); ++j) {\n\t    if (puyo[i][j] != '.' && puyo[i][j] != 'O' && !visited[i][j]) {\n\t      int cnt = 0;\n\t      queue<pair<int, int> > que;\n\t      que.push(pair<int, int>(i, j));\n\t      while (!que.empty()) {\n\t\tconst pair<int, int> p = que.front();\n\t\tque.pop();\n\n\t\t++cnt;\n\t\tvisited[p.first][p.second] = 1;\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t  int ii = p.first + dy[d];\n\t\t  int jj = p.second + dx[d];\n\t\t  if (ii < 0 || ii >= puyo.size() || jj < 0 || jj >= puyo[0].size() || puyo[ii][jj] != puyo[i][j] || visited[ii][jj])\n\t\t      continue;\n\t\t  que.push(pair<int, int>(ii, jj));\n\t\t}\n\t      }\n\t      if (cnt >= 4) {\n\t\tupdate = true;\n\t\tchar color = puyo[i][j];\n\t\tque.push(pair<int, int>(i, j));\n\t\tvector<vector<int> > deleted(puyo.size(), vector<int>(puyo[0].size(), 0));\n\t\twhile (!que.empty()) {\n\t\t  const pair<int, int> p = que.front();\n\t\t  que.pop();\n\n\t\t  puyo[p.first][p.second] = '.';\n\t\t  deleted[p.first][p.second] = 1;\n\t\t  for (int d = 0; d < 4; ++d) {\n\t\t    int ii = p.first + dy[d];\n\t\t    int jj = p.second + dx[d];\n\t\t    if (ii < 0 || ii >= puyo.size() || jj < 0 || jj >= puyo[0].size() || deleted[ii][jj])\n\t\t      continue;\n\t\t    \n\t\t    if (puyo[ii][jj] == color) {\n\t\t      que.push(pair<int, int>(ii, jj));\n\t\t    } else if (puyo[ii][jj] == 'O')\n\t\t      puyo[ii][jj] = '.';\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\n\tif (!update)\n\t  break;\n\n\t++ans;\n\tfor (int i = puyo.size()-1; i >= 0; --i) {\n\t  for (unsigned int j = 0; j < puyo[0].size(); ++j) {\n\t    if (puyo[i][j] != '.') {\n\t      int ii = i + 1;\n\t      while (ii < puyo.size() && puyo[ii][j] == '.')\n\t\t++ii;\n\t      swap(puyo[i][j], puyo[ii-1][j]);\n\t    }\n\t  }\n\t}\n      }\n\n      for (unsigned int i = 0; i < puyo.size(); ++i)\n\tcout << puyo[i] << endl;\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 17 52 ツィツ　WA18 -> 25ツ個エツ暗カツ閉ェツつゥツづつス?\n\n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<string> data(12);\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,-1,1};\n\nbool iscorrect(int y,int x){\n\tif(y>11 || y<0)return false;\n\tif(x<0 || x>5)return false;\n\treturn true;\n}\n\nint cnt;\nbool done[12][6];\nvoid search(int y,int x,int c){\n\tif(data[y][x] != c)return;\n\t\n\tif(done[y][x])return;\n\tcnt++;\n\tdone[y][x] = true;\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx))search(ny,nx,c);\n\t}\n}\nvoid del(int y,int x,int c){\n\tif(data[y][x] != c)return;\n\tdata[y][x] = '.';\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx)){\n\t\t\tif(data[ny][nx]=='O')data[ny][nx]='.';\n\t\t}\n\t}\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx))del(ny,nx,c);\n\t}\n\t\n}\nvoid down(){\n\trep(x,12){\n\t\trep(w,6){\n\t\t\tfor(int i=0;i+1<12;i++){\n\t\t\t\tif(data[i+1][w] == '.'){\n\t\t\t\t\tswap(data[i+1][w],data[i][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\nbool iscell(int i,int j){\n\treturn data[i][j] != 'O' && data[i][j] != '.';\n}\n\nint main(){\n\tint n;\n\tcin >>n;\n\twhile(n--){\n\t\trep(i,12){cin >> data[i];}\n\t\tdown();\n\t\tvector<string> prev = data;\n\t\trep(O,73){\n\t\t\trep(i,12)rep(j,6){\n\t\t\t\tif(iscell(i,j)){\n\t\t\t\t\trep(p,12)rep(q,6)done[p][q] = false;\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tsearch(i,j,data[i][j]);\n\t\t\t\t\t//cerr << cnt << endl;\n\t\t\t\t\tif(cnt>=4){\n\t\t\t\t\t\tdel(i,j,data[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdown();\n\t\t\t//system(\"clear\");rep(i,12){rep(j,6)cout << data[i][j];cout << endl;}usleep(1200000);\n\t\t\tif(prev == data){\n\t\t\t\tcout << O << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = data;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct State { char x[12][6]; };\npair<State, bool>solve(State U) {\n\tbool used[12][6], r[12][6]; for (int i = 0; i < 72; i++) { used[i / 6][i % 6] = false; r[i / 6][i % 6] = false; }\n\tint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\n\tfor (int i = 0; i < 12; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tif (used[i][j] == true || U.x[i][j] == 'O' || U.x[i][j] == '.')continue;\n\t\t\tqueue<pair<int, int>>Q; Q.push(make_pair(i, j)); int c = 0;\n\t\t\tvector<pair<int, int>>v; used[i][j] = true;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front().first, a2 = Q.front().second; c++; Q.pop();\n\t\t\t\tv.push_back(make_pair(a1, a2));\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ex = a1 + dx[k], ey = a2 + dy[k];\n\t\t\t\t\tif (ex < 0 || ey < 0 || ex >= 12 || ey >= 6 || U.x[i][j] != U.x[ex][ey])continue;\n\t\t\t\t\tif (used[ex][ey] == false) { Q.push(make_pair(ex, ey)); used[ex][ey] = true; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c >= 4) {\n\t\t\t\tfor (int k = 0; k < v.size(); k++) {\n\t\t\t\t\tr[v[k].first][v[k].second] = true;\n\t\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\t\tint ex = v[k].first + dx[l], ey = v[k].second + dy[l];\n\t\t\t\t\t\tif (ex < 0 || ey < 0 || ex >= 12 || ey >= 6)continue;\n\t\t\t\t\t\tif (U.x[ex][ey] == 'O') { r[ex][ey] = true; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool update = false;\n\tfor (int i = 0; i < 72; i++) { if (r[i / 6][i % 6] == true) { U.x[i / 6][i % 6] = '.'; update = true; } }\n\tfor (int i = 0; i < 24; i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\tif (U.x[j][k] != '.' && U.x[j + 1][k] == '.')swap(U.x[j][k], U.x[j + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(U, update);\n}\nint main() {\n\tint t; cin >> t;\n\tfor (int i = 0; i < t; i++) {\n\t\tState V;\n\t\tfor (int j = 0; j < 12; j++) { for (int k = 0; k < 6; k++)cin >> V.x[j][k]; }\n\t\tint cnt = 0;\n\t\twhile (true) {\n\t\t\tpair<State, bool>D = solve(V);\n\t\t\tif (D.second == false)break;\n\t\t\tV = D.first; cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst char p[7] = {'R','G','B','Y','P','O','.'};\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nstring f[12];\nint cnt = 0;\n\nvoid downPuyo(int x,int y){\n\tchar t = f[y+1][x] ;\n\tf[y+1][x] = f[y][x];\n\tf[y][x] = t;\n\t\n\tif( y+1 != 11 && f[y+2][x] == '.' ){\n\t\tdownPuyo( x , y+1 );\n\t}\n}\n\nvoid checkPuyo(int x,int y,char color){\n\tf[y][x] += 'a' - 'A';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\t++cnt;\n\t\t\tcheckPuyo( mx , my , color );\n\t\t}\n\t}\n}\nvoid eracePuyo(int x,int y,char color){\n\tf[y][x] = '.';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\teracePuyo( mx , my , color );\n\t\t}\n\t\tif( f[my][mx] == 'O' ){\n\t\t\tf[my][mx] = '.';\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, chain;\n\t\n\tcin >> n;\n\tfor(int i=0 ; i<n ; ++i ){\n\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\tcin >> f[y];\n\t\t}\n\n\t\t//ú»\n\t\tbool flag = true;\n\t\tchain = 0;\n\n\t\t//Á¦éÕæªÈ­ÈéÜÅ[v\n\t\twhile( flag ){\n\t\t\tflag = false;\n\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t//àµFÕæ¾Á½ç\n\t\t\t\t\t\tif( f[y][x] == p[i] ){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tcheckPuyo( x , y , p[i] );\n\t\t\t\t\t\t\t//àµSÂÈã­ÁÂ¢Ä¢½ç¯·\n\t\t\t\t\t\t\tif( cnt >= 4 ){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\teracePuyo( x , y , p[i] + ('a'-'A') );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//ú»\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tchar c = p[i] + ('a'-'A');\n\t\t\t\t\t\tif( f[y][x] == c ){\n\t\t\t\t\t\t\tf[y][x] -= ('a'-'A');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Á¦éÕæª éÆ«\n\t\t\tif( flag ){\n\t\t\t\tchain++;\n\n\t\t\t\tfor(int j=0 ; j<4 ; ++j ){\n\t\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\tcout << chain << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                scanf(\" %c\", &f[i][j]);\n            }\n        }\n        int max_deleted = 0;\n        int res = 0,tx,ty;\n        bool shouldsearch;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=11;i>=0;i--){\n                for(int j=0;j<6;j++){\n                    shouldsearch = false;\n                    for(int k=0;k<4;k++){\n                        tx = i+dx[k];\n                        ty = j+dy[k];\n                        if(0 <= tx && tx < 12 &&\n                           0 <= ty && ty < 6 && f[i][j] == f[tx][ty]){\n                            shouldsearch = true;\n                        }\n                    }\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j] && shouldsearch){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(max_deleted < 4) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring map[12];\nbool dis[12][6],use[12][6];\n\nvoid fall(void){\n  for(int i=0;i<6;i++){\n    int d = 0,c = 0;\n    \n    for(int j=11;j>=0;j--){\n      while(j-d>=0 && map[j-d][i] == '.')d++;\n      if(j-d<0)break;\n      map[j][i] = map[j-d][i];\n      c++;\n    }\n    \n    for(int j=11-c;j>=0;j--)map[j][i] = '.';\n  }\n}\n\nint dfs(int y,int x,bool mode){\n  int dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n  int res;\n\n  use[y][x] = true;\n  res = 1;\n  for(int i=0;i<4;i++){\n    int sx = x+dx[i],sy = y+dy[i];\n    if(sx < 0 || 6 <= sx || sy < 0 || 12 <= sy)continue;\n    if(!use[sy][sx] && map[sy][sx] == map[y][x])res += dfs(sy,sx,mode);\n    if(mode && map[sy][sx] == 'O')map[sy][sx] = '.';\n  }\n  if(mode)map[y][x] = '.';\n  return res;\n}\n\nbool puyo(void){\n  bool f = false;\n  for(int i=0;i<12;i++){\n    for(int j=0;j<6;j++){\n      if(map[i][j] != '.' && map[i][j] != 'O'){\n\tfor(int k=0;k<12;k++){\n\t  for(int l=0;l<6;l++)use[k][l] = false;\n\t}\n\tif(dfs(i,j,false)>=4){\n\t  for(int k=0;k<12;k++){\n\t    for(int l=0;l<6;l++)use[k][l] = false;\n\t  }\n\t  dfs(i,j,true);\n\t  f = true;\n\t}\n\t\n      }\n    }\n  }\n  return f;\n}\n\n\nint main(){\n  int t,ans;\n\n  cin >> t;\n  while(t--){\n    \n    for(int i=0;i<12;i++)cin >> map[i];\n\n    ans = 0;\n    \n    while(1){\n      fall();\n      if(!puyo())break;\n      ans++;\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<queue>\n#include<string.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nchar cmap[13][13];\nbool used[13][13];\nint imap[13][13];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nint Cnt = 0;\n\nvoid dfs(int x,int y,char c,int cnt)\n{\n  used[y][x] = true; \n  int fcnt = 0;\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12&&cmap[ny][nx] == c && !used[ny][nx]){\n      fcnt++; Cnt++;\n      dfs(nx,ny,c,cnt+1);\n    }\n  }\n  if(fcnt == 0)imap[y][x] = Cnt;\n}\n\nvoid erase(int x,int y,char c)\n{\n  used[y][x] = true;\n  cmap[y][x] = '.';\n\n  queue<P> que;\n  que.push(P(x,y));\n\n  while(!que.empty())\n    {\n      P p = que.front(); que.pop();\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.F+dx[i],ny = p.S+dy[i];\n\n\t  if(0<=nx&&nx<6&&0<=ny&&ny<12&& ((!used[ny][nx] && cmap[ny][nx] == c) || cmap[ny][nx] == 'O'))\n\t    {\n\t      if(cmap[ny][nx] != 'O')que.push(P(nx,ny));\n\t      cmap[ny][nx] = '.';\n\t      used[ny][nx] = true;\n\t      \n\t    }\n\t}\n    }\n}\n\nvoid display()\n{\n\n  for(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << cmap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  /*\nfor(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << imap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  */\n  cout << endl;\n}\n\n\nvoid drop(int x,int y)\n{\n  //cout << \"x = \" << x << \", y = \" << y << endl;\n  int st,ed;\n  st = y;\n  ed = -1;\n  for(int i=y;i>=0;i--)\n    {\n      if(ed == -1 && cmap[i][x] != '.')\n\t{\n\t  ed = i+1;\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] =\" << cmap[st+ed-(i+1)][x] << \", cmpa[\"<<i<<\"][x] = \"<<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] != '.')\n\t{\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] = \" << cmap[st+ed-(i+1)][x] << \", cmap[\"<<i<<\"][x] = \" <<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] == '.')\n\t{\n\t  st = i;\n\t  ed = -1;\n\t}      \n\n    }\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  while(N-- > 0)\n    {\n      for(int i=0;i<12;i++)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  for(int j=0;j<s.length();j++)\n\t    {\n\t      cmap[i][j] = s[j];\n\t      used[i][j] = false;\n\t      imap[i][j] = -1;\n\t    }\n\t}\n\n      int cnt = 0;\n      while(true)\n\t{\n\t  //display();\n\t  int increase = 0;\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)\n\t\t\t\t {\n\t\t\t\t   imap[i][j] = -1;\n\t\t\t\t   used[i][j] = false;\n\t\t\t\t }\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(cmap[i][j] != '.' && cmap[i][j] != 'O' && !used[i][j])\n\t\t    {\n\t\t      Cnt=1;\n\t\t      dfs(j,i,cmap[i][j],1); //最大何マスつながっているか\n\t\t    }\n\t\t}\n\t    }\n\t\n\t  memset(used,0,sizeof(used));\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)used[i][j] = false;\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(!used[i][j] && imap[i][j] >= 4){\n\t\t    increase++;\n\t\t    erase(j,i,cmap[i][j]);\n\t\t  }\n\t\t}\n\t    }\n\t  //display();\n\t  if(increase == 0)\n\t    {\n\t      break;\n\t    }\n\t  cnt++;\n\n\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      for(int j=11;j>=0;j--)\n\t\t{\n\t\t  if(cmap[j][i] == '.')\n\t\t    {\n\t\t      drop(i,j);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t    }\n\n\n\n\n\n\t}\n\n      cout<< cnt << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nchar p[12][7];\nint f[12][6];\nchar memo;\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint dfs(int y, int x, int c){\n  //  fprintf(stderr, \"%d %d %d\\n\", y, x, c);\n  int ret = 0;\n  bool flag = 0;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= 12 || nx >= 6 || memo != p[ny][nx] || f[ny][nx]) continue;\n    flag = 1;\n    f[ny][nx] = 1;\n    //    fprintf(stderr, \"%d %d %d\\n\", ny, nx, c+1);\n    ret += dfs(ny, nx, c+1);\n    if(!ret) f[ny][nx] = 0;\n  }\n\n  if(!flag  && c >= 4){\n    return 1;\n  }\n  return ret;\n}\n\nvoid ojama(){\n  rep(i, 12) rep(j, 7){\n    if(p[i][j] != 'O') continue;\n    //    printf(\"%d %d\\n\", i, j);\n    rep(d, 4){\n      int ny = i + dy[d], nx = j + dx[d];\n      if(ny < 0 || nx < 0 || ny >= 12 || nx >= 6 || !f[ny][nx]) continue;\n      f[i][j] = 1;\n      break;\n    }\n  }\n  return;\n}\n\nvoid del(){\n  rep(i, 12) rep(j, 6){\n    if(!f[i][j]) continue;\n    p[i][j] = '.';\n  }\n  return;\n}\n\nvoid next(){\n  /*  rep(i, 12){\n    rep(j, 6) printf(\"%d \", f[i][j]); puts(\"\");\n    }*/\n\n  for(int i = 11; i >= 0; i--) rep(j, 6){\n      if(p[i][j] != '.') continue;\n      for(int k = i; k >= 0; k--){\n\tif(p[k][j] == '.') continue;\n\tp[i][j] = p[k][j];\n\tp[k][j] = '.';\n\tbreak;\n      }\n    }\n\n  /*  rep(i, 12){\n    puts(p[i]);\n    }*/\n  return;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  while(n--){\n    //    puts(\"in\");\n    rep(i, 12){\n      scanf(\"%s\", p[i]);\n    }\n\n    int res = 0;\n    while(true){\n      //      fprintf(stderr, \"%d\\n\", res);\n      int judge = 0, flag = 0;;\n      memset(f, 0, sizeof(f));\n      rep(i, 12) rep(j, 6){\n\t//\tfprintf(stderr, \"%d %d\\n\", i, j);\n\tif(p[i][j] == '.' || p[i][j] == 'O'|| f[i][j]) continue;\n\t//\tfprintf(stderr, \"%d %d\\n\", i, j);\n\tmemo = p[i][j];\n\tflag = dfs(i, j, 0);\n\tjudge += flag;\n\t//\tfprintf(stderr, \"%d\\n\", judge);\n\tif(flag) f[i][j] = 1;\n      }\n      //      printf(\"%d\\n\", judge);\n      if(!judge) break;\n      ojama();\n      //      fprintf(stderr, \"ojama\\n\");\n      del();\n      //      fprintf(stderr, \"del\\n\");\n      next();\n      //      fprintf(stderr, \"next\\n\");\n      res++;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\ntypedef pair<int, int> P;\n\nconst int h = 12;\nconst int w = 6;\nchar field[h][w];\nbool check[h][w];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nbool erase(){\n\tbool ret = false;\n\tmemset(check, 0, sizeof(check));\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif(check[i][j]) continue;\n\t\t\tchar c = field[i][j];\n\t\t\tif(c == 'O' || c == '.') continue;\n\t\t\tqueue<P> q;\n\t\t\tq.push(MP(j, i));\n\t\t\tvector<P> bye;\n\t\t\tint cnt = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tP p = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tif(check[p.Y][p.X]) continue;\n\t\t\t\tcheck[p.Y][p.X] = true;\n\t\t\t\tbye.push_back(p);\n\t\t\t\tcnt++;\n\t\t\t\trep(i, 4){\n\t\t\t\t\tint nx = p.X + dx[i], ny = p.Y + dy[i];\n\t\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t\tif(field[ny][nx] == 'O') bye.push_back(MP(nx, ny));\n\t\t\t\t\tif(field[ny][nx] == c) q.push(MP(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt >= 4){\n\t\t\t\trep(k, bye.size()){\n\t\t\t\t\tfield[bye[k].Y][bye[k].X] = '.';\n\t\t\t\t}\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid drop(){\n\tchar next[h][w];\n\trep(i, h) rep(j, w) next[i][j] = '.';\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tif(field[i][j] != '.'){\n\t\t\t\tint y = i;\n\t\t\t\tint height = h-1;\n\t\t\t\twhile(++y<h){\n\t\t\t\t\tif(field[y][j] != '.') height--;\n\t\t\t\t}\n\t\t\t\tnext[height][j] = field[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(field, next, sizeof(field));\n\t//rep(i, h){\n\t//\trep(j, w) cout << field[i][j];\n\t//\tcout << endl;\n\t//}\n\t//cout << endl;\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\trep(i, h) rep(j, w) cin >> field[i][j];\n\t\tint ans = 0;\n\t\twhile(erase()){\n\t\t\tans++;\n\t\t\tdrop();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar field[12][6];\nbool used[12][6];\nchar now;\nint cnt;\n\nvoid dfs(int x, int y){\n  cnt++;\n  used[y][x] = true;\n  rep(i, 4){\n    int nx = x+dx[i], ny = y+dy[i];\n    if(nx < 0 || nx > 5 || ny < 0 || ny > 11 || used[ny][nx]) continue;\n    if(field[ny][nx] == now) dfs(nx, ny);\n  }\n}\n\nvoid del(int x, int y){\n  field[y][x] = '.';\n  rep(i, 4){\n    int nx = x+dx[i], ny = y+dy[i];\n    if(nx < 0 || nx > 5 || ny < 0 || ny > 11) continue;    \n    if(field[ny][nx] == 'O') field[ny][nx] = '.';\n    if(field[ny][nx] == now) del(nx, ny);    \n  }\n}\n\nvoid drop(){\n  rep(k, 12){\n    for(int i = 1 ; i < 12 ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n\tif(field[i][j] == '.'){\n\t  field[i][j] = field[i-1][j];\n\t  field[i-1][j] = '.';\n\t}\n      }\n    }\n  }\n}\n\nvoid init(){\n  cnt = 0;\n  memset(used, 0, sizeof(used));\n}\n\nvoid output(){\n  rep(i, 12){\n    rep(j, 6){\n      cout << field[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  rep(cs, n){\n    int ans = 0;\n    rep(i, 12) cin >> field[i];\n    \n    for(; ;){\n      bool flag = false;\n      rep(i, 12){\n\trep(j, 6){\n\t  if(isalpha(field[i][j]) && field[i][j] != 'O'){\n\t    init();\n\t    now = field[i][j];\n\t    dfs(j, i);\n\t    if(cnt >= 4){\t      \n\t      //cout << \"Start delete\" << endl;\n\t      //output();\n\t      flag = true;\n\t      //ans++;\n\t      del(j, i);\n\t      //cout << \"Finish delete\" << endl;\n\t      //output();\n\t    }\n\t  }\n\t}\n      }\n      if(flag){\n\tans++;\n\tdrop();\n\t//cout << \"Finish drop\" << endl;\n\t//output();\n      }\t\n      else goto END;\n    }\n  END:;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin(); it!=(c).end(); it++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pr(a) cout << (a) << endl\n#define PR(a,b) cout << (a) << \" \" << (b) << endl\n#define F first\n#define S second\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAX=1000000001;\nconst ll MAXL=1000000000000000001LL;\nconst ll mod=1000000007;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nbool check(int x,int y) {\n  if(x<0 || x>=6) return false;\n  if(y<0 || y>=12) return false;\n  return true;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    string t[12];\n    vector<char> s[6];\n    rep(i,12) cin >> t[i];\n    rep(i,6) {\n      for(int j=11; j>=0; j--) s[i].pb(t[j][i]);\n    }\n    int ans=0;\n    while(1) {\n      bool ck=false;\n      bool d[6][12],d2[6][12];\n      memset(d,false,sizeof(d));\n      memset(d2,false,sizeof(d2));\n      rep(i,6) {\n\trep(j,12) {\n\t  if(!d[i][j] && s[i][j]!='.' && s[i][j]!='O') {\n\t    queue<P> que,que2;\n\t    que.push(P(i,j));\n\t    que2.push(P(i,j));\n\t    d[i][j]=true;\n\t    while(!que.empty()) {\n\t      P p=que.front();\n\t      que.pop();\n\t      int nx=p.F,ny=p.S;\n\t      rep(k,4) {\n\t\tint x=nx+dx[k],y=ny+dy[k];\n\t\tif(check(x,y) && !d[x][y] && s[x][y]==s[i][j]) {\n\t\t  que.push(P(x,y));\n\t\t  que2.push(P(x,y));\n\t\t  d[x][y]=true;\n\t\t}\n\t      }\n\t    }\n\t    if(que2.size()>=4) {\n\t      ck=true;\n\t      while(!que2.empty()) {\n\t\tP p=que2.front();\n\t\tque2.pop();\n\t\ts[p.F][p.S]='.';\n\t\td2[p.F][p.S]=true;\n\t      }\t  \n\t    }\n\t  }\n\t}\n      }\n      if(ck) {\n\trep(i,6) {\n\t  rep(j,12) {\n\t    if(s[i][j]=='O') {\n\t      rep(k,4) {\n\t\tint x=i+dx[k],y=j+dy[k];\n\t\tif(check(x,y) && d2[x][y]) {\n\t\t  s[i][j]='.';\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\trep(i,6) fill(remove(all(s[i]),'.'),s[i].end(),'.');\n\tans++;\n      } else break;\n    }\n    pr(ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\n\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n/*\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tint y = i+dy[k], x = j+dx[k];\n\t\tif(y >= 0 && y < 12 && x >= 0 && x < 6 \n\t\t\t&& area[y][x] == c && !used[y][x]){\n\t\t\tcounter += count(y, x, c);\n\t\t}\n\t*/}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nbool check1[14][8];\nint check2[14][8];\nint block[14][8];\nvoid GetBlock(){\n  memset(block,0,sizeof(block));\n  memset(check1,0,sizeof(check1));\n  for(int i=1; i<=12; i++){\n    for(int j=1; j<=6; j++){\n      block[i][j] = getchar();\n    }\n    getchar();\n  }\n}\nvoid Makecheck2(int x, int y){\n  REP(k,4){\n    if(check2[x+dx[k]][y+dy[k]]==0&&\n        block[x][y]==block[x+dx[k]][y+dy[k]]){\n      check1[x+dx[k]][y+dy[k]] = true;\n      check2[x+dx[k]][y+dy[k]] = 1;\n      Makecheck2(x+dx[k], y+dy[k]);\n    }\n    if(check2[x+dx[k]][y+dy[k]]==0&&block[x+dx[k]][y+dy[k]]=='O')\n      check2[x+dx[k]][y+dy[k]] = 100;\n  }\n}\nint CheckNum(int x, int y){\n  int count = 0;\n  memset(check2,0,sizeof(check2));\n  check2[x][y] = 1;\n  Makecheck2(x,y);\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j]==1) count++;\n  return count;\n}\nvoid Break(){\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j] == 1 || check2[i][j] == 100)\n        block[i][j] = '.';\n  memset(check2,0,sizeof(check2));\n}\n\nbool CheckIsR(){\n  bool flag2 = false;\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check1[i][j]==false){\n        if(block[i][j]!='.'&&block[i][j]!='O'){\n          check1[i][j] = true;\n          if(CheckNum(i,j)>=4){\n            flag2 = true;\n            Break();\n          }\n        }else{\n          check1[i][j] = true;\n        }\n      }\n  return flag2;\n}\nbool Down(){\n  bool flag3;\n  do{\n    flag3 = false;\n    FOR(i,1,13)\n      FOR(j,1,7)\n        if(block[i][j] != '.' && block[i+1][j] == '.'){\n          swap(block[i][j],block[i+1][j]);\n          flag3 = true;\n        }\n  }while(flag3);\n  memset(check1,0,sizeof(check1));\n}\nvoid Out(){\n  FOR(i,1,13){\n    FOR(j,1,7)\n      printf(\"%c\",block[i][j]);\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\nint main(void){  \n  int n;\n  cin>>n;\n  getchar();\n  while(n--){\n    GetBlock();\n    int count=0;\n    while(true){\n      memset(check1,0,sizeof(check1));\n      if(CheckIsR()) count++;\n      else break;\n      Down();\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar t[20][20];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint countPuyo(int x, int y){\n  int res = 1;\n  char tmp = t[y][x];\n  t[y][x] = '.';\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(nx < 0 || 6 <= nx || ny < 0 || 12 <= ny) continue;\n    if(t[ny][nx] != tmp) continue;\n\n    res += countPuyo(nx, ny);\n  }\n  t[y][x] = tmp;\n\n  return res;\n}\n\nvoid deletePuyo(int x, int y){\n  char tmp = t[y][x];\n  t[y][x] = '.';\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(nx < 0 || 6 <= nx || ny < 0 || 12 <= ny) continue;\n    if(t[ny][nx] == 'O'){\n      t[ny][nx] = '.';\n    }\n    if(t[ny][nx] != tmp) continue;\n\n    deletePuyo(nx, ny);\n  }\n}\n\nvoid fallPuyo(){\n  for(int i = 11; i > 0; i--){\n    for(int j = 0; j < 6; j++){\n      if(t[i][j] == '.'){\n\tint k;\n\n\tfor(k = i; k > 0; k--){\n\t  if(t[k][j] != '.'){\n\t    break;\n\t  }\n\t}\n\n\tt[i][j] = t[k][j];\n\tt[k][j] = '.';\n      }\n    }\n  }\n}\n\nint main(){\n  int T;\n  cin >> T;\n\n  while(T--){\n    for(int i = 0; i < 12; i++){\n      cin >> t[i];\n    }\n\n    int rensa = 0;\n\n    while(true){\n      bool flg = false;\n\n      for(int i = 0; i < 12; i++){\n\tfor(int j = 0; j < 6; j++){\n\t  if(t[i][j] != '.' && t[i][j] != 'O' &&\n\t     countPuyo(j, i) >= 4){\n\t    deletePuyo(j, i);\n\t    flg = true;\n\t  }\n\t}\n      }\n\n      if(!flg) break;\n      fallPuyo();\n      rensa++;\n    }\n\n    cout << rensa << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar f[12][7];\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nvoid remove(int x, int y, char a){\n  if( x<0 || x>=12 ) return;\n  if( y<0 || y>=6 ) return;\n  if( f[x][y] != a ) return;\n\n  f[x][y] = '.';\n  for( int d=0;d<4;d++ ){\n    int nx = x+dx[d];\n    int ny=y+dy[d];\n    if( f[nx][ny] == 'O' ){\n      f[nx][ny] = '.';\n    }else\n      remove(x+dx[d], y+dy[d], a);\n  }\n}\n\nint count(int x, int y, char a){\n  if( x<0 || x>=12 ) return 0;\n  if( y<0 || y>=6 ) return 0;\n  if( f[x][y] != a ) return 0;\n\n  f[x][y] = 'C';\n  int rtn=1;\n  for( int d=0;d<4;d++ )\n    rtn += count(x+dx[d], y+dy[d], a);\n\n  f[x][y] = a;\n  return rtn;\n}\n\n\nbool is_remove(){\n  bool rtn = false;\n  for( int i=0;i<12;i++ ){\n    for( int j=0;j<6;j++ ){\n      if( f[i][j] != '.' && f[i][j] != 'O' ){\n\tint c = count(i, j, f[i][j] );\n\tif( c >= 4 ){\n\t  rtn = true;\n\t  remove(i, j, f[i][j]);\n\t}\n      }\n    }\n  }\n  if( rtn ){\n    // ティツ青ステ、ツクツ凝・ツ?ヲテァツ青?\n    for( int j=0;j<6;j++ ){\n      for( int i=12;i>=0;i-- ){\n\tif( f[i][j] == '.' ){\n\t  for( int k=i-1;k>=0;k-- ){\n\t    if( f[k][j] != '.' ){\n\t      f[i][j] = f[k][j];\n\t      f[k][j] = '.';\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n\n  return rtn;\n}\n\nvoid pr(){\n  for( int i=0;i<12;i++ )\n    cout << f[i] << endl;\n}\n\nint main(){\n  int datasetn;\n\n  cin >> datasetn;\n  while( datasetn-- ){\n    for( int i=0;i<12;i++ ){\n      cin >> f[i];\n      //      cout << f[i] << endl;\n    }\n\n\n    int ans=0;\n    //    pr();//\n    while( is_remove() ){\n      ans++;\n      //      pr();//\n    }\n    cout << ans << endl;\n\n    //    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<char> vec;\nchar tab[20][20];\nint ans,pre,dx[]={0,0,1,-1},dy[]={1,-1,0,0},plus,used[20][20];\nvoid are1(int y,int x,char c){\n\tpre++;\n\tused[y][x]=1;\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=dy[i]+y;nx=dx[i]+x;\n\t\tif(ny>=0&&ny<12&&nx>=0&&nx<6){\n\t\tif(tab[ny][nx]==c&&used[ny][nx]==0)\n\t\t\tare1(ny,nx,c);\n\t\t}\n\t}\n}\nvoid are2(int y,int x,char c){\n\tint ny,nx;\n\ttab[y][x]='.';\n\tfor(int i=0;i<4;i++){\n\t\tny=dy[i]+y;nx=dx[i]+x;\n\t\tif(ny>=0&&ny<12&&nx>=0&&nx<6){\n\t\t\tif(tab[ny][nx]==c)\n\t\t\t\tare2(ny,nx,c);\n\t\t\telse if(tab[ny][nx]=='O')\n\t\t\t\ttab[ny][nx]='.';\n\t\t}\n\t}\n}\nvoid rensa(){\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<12;i++)\n\tfor(int j=0;j<6;j++){\n\t\tif(tab[i][j]!='O'&&tab[i][j]!='.'){\n\t\t\tpre=0;\n\t\t\tare1(i,j,tab[i][j]);\n\t\t\tif(pre>=4){\n\t\t\t\tare2(i,j,tab[i][j]);\n\t\t\t\tplus++;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid liset(){\n\tint k;\n\tfor(int i=0;i<6;i++){\n\t\tk=0;\n\t\tfor(int j=11;j>=0;j--){\n\t\t\tif(tab[j][i]!='.')\n\t\t\tvec.push_back(tab[j][i]);\n\t\t}\n\t\tfor(int j=11;(int)11-j<(int)vec.size();j--)\n\t\t\ttab[j][i]=vec[k++];\n\t\tfor(int j=(int)11-vec.size();j>=0;j--)\n\t\t\ttab[j][i]='.';\n\t\tvec.clear();\n\t}\n}\nvoid solve(){\n\tdo{\n\t\tplus=0;\n\t\trensa();\n\t\tif(plus){\n\t\tliset();\n\t\tans++;\n\t\t}\n\t}while(plus);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n-->0){\n\t\tans=0;\n\t\tfor(int i=0;i<12;i++)\n\t\tcin>>tab[i];\n\t\tsolve();\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nvector<string> G;\n\nconst int H = 12, W = 6;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nbool in_range(int y, int x) {\n  return 0<=x&&x<W && 0<=y&&y<H;\n}\n\nvoid drop() {\n  vector<vector<char>> vs(W);\n  rep(j, W) rep(i, H) {\n    if(G[H-1-i][j] != '.')\n      vs[j].push_back(G[H-1-i][j]);\n  }\n  rep(i, W) {\n    while((int)vs[i].size() < H) vs[i].push_back('.');\n  }\n  rep(j, W) rep(i, H) {\n    G[H-1-i][j] = vs[j][i];\n  }\n}\n\nbool vis[H][W];\n\nint counte(int y, int x, char c) {\n  int r = 1;\n  rep(k, 4) {\n    int ny = y + dy[k], nx = x + dx[k];\n    if(!in_range(ny, nx)) continue;\n    if(G[ny][nx] != c) continue;\n    if(vis[ny][nx]) continue;\n    vis[ny][nx] = 1;\n    r += counte(ny, nx, c);\n  }\n  return r;\n}\n\nvoid erase(int y, int x, char c) {\n  G[y][x] = '.';\n  rep(k, 4) {\n    int ny = y + dy[k], nx = x + dx[k];\n    if(!in_range(ny, nx)) continue;\n    if(G[ny][nx] == 'O') {\n      G[ny][nx] = '.';\n    }\n  }\n  rep(k, 4) {\n    int ny = y + dy[k], nx = x + dx[k];\n    if(!in_range(ny, nx)) continue;\n    if(G[ny][nx] == c) {\n      erase(ny, nx, c);\n    }\n  }\n}\n\nint simulate() {\n  int ret = 0;\n  while(1) {\n    bool ok = 0;\n    rep(i, H) rep(j, W) {\n      if(G[i][j] != '.' && G[i][j] != 'O') {\n\tmemset(vis, 0, sizeof vis);\n\tvis[i][j] = 1;\n\tif(counte(i, j, G[i][j]) < 4) continue;\n\tok = 1;\n\terase(i, j, G[i][j]);\n      }\n    }\n    if(ok) {\n      ret ++, drop();\n      ///      rep(i, H) cout << G[i] << endl; cout << endl;\n    }\n    else break;\n  }\n  return ret;\n}\n\nint main() {\n  \n  int T; cin >> T;\n  rep(_, T) {\n    G.clear();\n    G.resize(H);\n    rep(i, H) cin >> G[i];\n    cout << simulate() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<char> vec;\nchar tab[20][20];\nint ans,pre,dx[]={0,0,1,-1},dy[]={1,-1,0,0},plus,used[20][20];\nvoid are1(int y,int x,char c){\n\tpre++;\n\tused[y][x]=1;\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=dy[i]+y;nx=dx[i]+x;\n\t\tif(ny>=0&&ny<12&&nx>=0&&nx<6){\n\t\tif(tab[ny][nx]==c&&used[ny][nx]==0)\n\t\t\tare1(ny,nx,c);\n\t\t}\n\t}\n}\nvoid are2(int y,int x,char c){\n\tint ny,nx;\n\ttab[y][x]='.';\n\tfor(int i=0;i<4;i++){\n\t\tny=dy[i]+y;nx=dx[i]+x;\n\t\tif(ny>=0&&ny<12&&nx>=0&&nx<6){\n\t\t\tif(tab[ny][nx]==c)\n\t\t\t\tare2(ny,nx,c);\n\t\t\telse if(tab[ny][nx]=='O')\n\t\t\t\ttab[ny][nx]='.';\n\t\t}\n\t}\n}\nvoid rensa(){\n\tfor(int i=0;i<12;i++)\n\tfor(int j=0;j<6;j++)\n\tused[i][j]=0;\n\tfor(int i=0;i<12;i++)\n\tfor(int j=0;j<6;j++){\n\t\tif(tab[i][j]!='O'&&tab[i][j]!='.'){\n\t\t\tpre=0;\n\t\t\tare1(i,j,tab[i][j]);\n\t\t\tif(pre>=4){\n\t\t\t\tare2(i,j,tab[i][j]);\n\t\t\t\tplus++;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid liset(){\n\tint k;\n\tfor(int i=0;i<6;i++){\n\t\tk=0;\n\t\tfor(int j=11;j>=0;j--){\n\t\t\tif(tab[j][i]!='.')\n\t\t\tvec.push_back(tab[j][i]);\n\t\t}\n\t\tfor(int j=11;(int)11-j<(int)vec.size();j--)\n\t\t\ttab[j][i]=vec[k++];\n\t\tfor(int j=(int)11-vec.size();j>=0;j--)\n\t\t\ttab[j][i]='.';\n\t\tvec.clear();\n\t}\n}\nvoid solve(){\n\tdo{\n\t\tplus=0;\n\t\trensa();\n\t\tif(plus){\n\t\tliset();\n\t\tans++;\n\t\t}\n\t}while(plus);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n-->0){\n\t\tans=0;\n\t\tfor(int i=0;i<12;i++)\n\t\tcin>>tab[i];\n\t\tsolve();\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nchar board[12][10];\nint  num[12][6];\n\nvoid drop(){\n  bool f = true;\n  while(f){\n    f=false;\n    for(int i=11; i>0; i--)\n      for(int j=0; j<6; j++)\n\tif(board[i][j] == '.' && board[i-1][j] != '.'){\n\t  f = true;\n\t  swap(board[i][j],board[i-1][j]);\n\t}\n  }\n}\n\nvoid check(int x, int y, int c, int k){\n  if(num[y][x] == 0 && board[y][x] == c){\n    num[y][x] = k;\n    if(x > 0)  check(x-1, y, c, k);\n    if(y > 0)  check(x, y-1, c, k);\n    if(x < 5)  check(x+1, y, c, k);\n    if(y < 11) check(x, y+1, c, k);\n  }\n}\n\nbool erase(){\n  bool ret = false;\n  int  c = 1;\n  int cnt[12*6] = {0};\n  memset(num, 0, sizeof(num));\n  REP(i,12) REP(j,6)\n    if(num[i][j] == 0) check(j,i,board[i][j],c++);\n  REP(i,12) REP(j,6) cnt[num[i][j]]++;\n\n  //REP(i,c) printf(\"cnt[%d] = %d\\n\",i,cnt[i]);\n  //REP(i,12) {REP(j,6) printf(\"%2d\",num[i][j]); puts(\"\");}\n\n  REP(i,12) REP(j,6)\n    if(board[i][j]!='.' && board[i][j]!='O' && cnt[num[i][j]] >= 4){\n      ret = true;\n      board[i][j] = '.';\n      if(i > 0  && board[i-1][j]=='O') board[i-1][j] = '.';\n      if(j > 0  && board[i][j-1]=='O') board[i][j-1] = '.';\n      if(i < 11 && board[i+1][j]=='O') board[i+1][j] = '.';\n      if(j < 5  && board[i][j+1]=='O') board[i][j+1] = '.';\n    }\n  return ret;\n}\n\nint main(){\n  int n; scanf(\"%d \",&n);\n  while(n-->0){\n    REP(i,12) fgets(board[i],sizeof(board[i]),stdin);\n    int cnt = 0;\n    while(erase()){ cnt++; drop(); }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\nchar map[12][6];\nchar color[5]={'R','G','B','Y','P'};\nint d1[4]={0,1,0,-1};\nint d2[4]={1,0,-1,0};\nint flg,c,dep;\nvoid swap(char *map1,char *map2){\n\tchar t;\n\tt=*map1;\n\t*map1=*map2;\n\t*map2=t;\n\treturn;\n}\nvoid fall(){\n\tint i,j,fl;\t\n\tfor(j=0;j<6;j++){\n\t\twhile(1){\t\n\t\t\tfl=0;\n\t\t\tfor(i=11;i>0;i--){\n\t\t\t\tif(map[i][j]=='.'&&map[i-1][j]!='.'){\n\t\t\t\t\tswap(&map[i][j],&map[i-1][j]);fl=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fl==0)break;\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs(char cl,int depth,int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&map[ny][nx]==cl){\n\t\t\tif(dep>=3){\n\t\t\t\tmap[ny][nx]='@';dep++;\n\t\t\t}else{\n\t\t\t\tmap[ny][nx]='#';dep++;\n\t\t\t}\n\t\t\tdfs(cl,depth+1,ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs2(int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&map[ny][nx]=='#'){\n\t\t\tmap[ny][nx]='*';dfs2(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid vanish(char cl){\n\tint i,j,k;\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tdep=0;\n\t\t\tif(map[i][j]==cl){\n\t\t\t\tdfs(cl,1,i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='@'){\n\t\t\t\tdfs2(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='*'||map[i][j]=='@'){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(map[i+d1[k]][j+d2[k]]=='O'&&0<=i+d1[k]&&i+d1[k]<12&&0<=j+d2[k]&&j+d2[k]<6){\n\t\t\t\t\t\tmap[i+d1[k]][j+d2[k]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[i][j]='.';flg=1;\n\t\t\t}else if(map[i][j]=='#'){\n\t\t\t\tmap[i][j]=cl;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint set;\n\tcin>>set;\n\tfor(set;set>0;set--){\n\t\tc=0;\n\t\tfor(int i=0;i<12;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\twhile(1){\n\t\t\tflg=0;\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tvanish(color[i]);\n\t\t\t}\n\t\t\tfall();\n\t\t\tif(flg==0)break;\n\t\t\tc++;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// UTPC2010 C. RpC\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nchar dx[] = {-1, 0, 1, 0};\nchar dy[] = {0, -1, 0, 1};\n\nint main(){\n\tstring s[12];\n\tbool visit[12][6], erase[12][6];\n        int T; cin >> T;\n\twhile(T--){\n\t\tfor(int i=0;i<12;i++) cin >> s[i];\n\t\tint ans = 0;\n\t\twhile(true){\n\t\t\tmemset(visit, false, sizeof(visit));\n\t\t\tmemset(erase, false, sizeof(erase));\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(!visit[i][j]&&s[i][j]!='.'&&s[i][j]!='O'){\n\t\t\t\t\t\tqueue< pair<int, int> > qu; qu.push(make_pair(i,j));\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\twhile(!qu.empty()){\n\t\t\t\t\t\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\t\t\t\t\t\tif(erase[p.first][p.second]) continue;\n\t\t\t\t\t\t\terase[p.first][p.second] = true;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\t\t\t\t\t\tif(nx < 0 || 12 <= nx || ny < 0 || 6 <= ny || s[p.first][p.second]!=s[nx][ny]) continue;\n\t\t\t\t\t\t\t\tqu.push(make_pair(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt >= 4) memcpy(visit, erase, sizeof(visit));\n\t\t\t\t\t\tmemcpy(erase, visit, sizeof(erase));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(s[i][j]!='O') continue;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\t\tif(nx < 0 || 12 <= nx || ny < 0 || 6 <= ny || !erase[nx][ny] || s[nx][ny] == 'O') continue;\n\t\t\t\t\t\terase[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool next = false;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(erase[i][j]){\n\t\t\t\t\t\tnext = true;\n\t\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tvector<char> vc;\n\t\t\t\tfor(int j=11;j>=0;j--){\n\t\t\t\t\tif(s[j][i]!='.') vc.push_back(s[j][i]);\n\t\t\t\t\ts[j][i] = '.';\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<vc.size();j++)\n\t\t\t\t\ts[11-j][i] = vc[j];\n\t\t\t}\n\t\t\tif(next) ans++;\n\t\t\telse     break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<queue>\n#include<string.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nchar cmap[13][13];\nbool used[13][13];\nint imap[13][13];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nint Cnt = 0;\n\nvoid dfs(int x,int y,char c,int cnt)\n{\n  used[y][x] = true; \n  int fcnt = 0;\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12&&cmap[ny][nx] == c && !used[ny][nx]){\n      fcnt++; Cnt++;\n      dfs(nx,ny,c,cnt+1);\n    }\n  }\n  if(fcnt == 0)imap[y][x] = Cnt;\n}\n\nvoid erase(int x,int y,char c)\n{\n  used[y][x] = true;\n  cmap[y][x] = '.';\n\n  queue<P> que;\n  que.push(P(x,y));\n\n  while(!que.empty())\n    {\n      P p = que.front(); que.pop();\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.F+dx[i],ny = p.S+dy[i];\n\n\t  if(0<=nx&&nx<6&&0<=ny&&ny<12&& (cmap[ny][nx] == c || cmap[ny][nx] == 'O') && !used[ny][nx])\n\t    {\n\t      cmap[ny][nx] = '.';\n\t      used[ny][nx] = true;\n\t      if(cmap[ny][nx] != 'O')que.push(P(nx,ny));\n\t    }\n\t}\n    }\n}\n\nvoid display()\n{\n\n  for(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << cmap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  /*\nfor(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << imap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  */\n  cout << endl;\n}\n\n\nvoid drop(int x,int y)\n{\n  //cout << \"x = \" << x << \", y = \" << y << endl;\n  int st,ed;\n  st = y;\n  ed = -1;\n  for(int i=y;i>=0;i--)\n    {\n      if(ed == -1 && cmap[i][x] != '.')\n\t{\n\t  ed = i+1;\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] =\" << cmap[st+ed-(i+1)][x] << \", cmpa[\"<<i<<\"][x] = \"<<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] != '.')\n\t{\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] = \" << cmap[st+ed-(i+1)][x] << \", cmap[\"<<i<<\"][x] = \" <<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] == '.')\n\t{\n\t  st = i;\n\t  ed = -1;\n\t}      \n\n    }\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  while(N-- > 0)\n    {\n      for(int i=0;i<12;i++)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  for(int j=0;j<s.length();j++)\n\t    {\n\t      cmap[i][j] = s[j];\n\t      used[i][j] = false;\n\t      imap[i][j] = -1;\n\t    }\n\t}\n\n      int cnt = 0;\n      while(true)\n\t{\n\t  //display();\n\t  int increase = 0;\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)\n\t\t\t\t {\n\t\t\t\t   imap[i][j] = -1;\n\t\t\t\t   used[i][j] = false;\n\t\t\t\t }\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(cmap[i][j] != '.' && cmap[i][j] != 'O' && !used[i][j])\n\t\t    {\n\t\t      Cnt=1;\n\t\t      dfs(j,i,cmap[i][j],1); //最大何マスつながっているか\n\t\t    }\n\t\t}\n\t    }\n\t\n\t  memset(used,0,sizeof(used));\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)used[i][j] = false;\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(!used[i][j] && imap[i][j] >= 4){\n\t\t    increase++;\n\t\t    erase(j,i,cmap[i][j]);\n\t\t  }\n\t\t}\n\t    }\n\t  //display();\n\t  if(increase == 0)\n\t    {\n\t      break;\n\t    }\n\t  cnt++;\n\n\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      for(int j=11;j>=0;j--)\n\t\t{\n\t\t  if(cmap[j][i] == '.')\n\t\t    {\n\t\t      drop(i,j);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t    }\n\n\n\n\n\n\t}\n\n      cout<< cnt << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#define P pair<int,int>\nusing namespace std;\n\nchar f[20][10];\nbool isCheck[20][10];\nvoid pr(){ for(int i=0;i<12;i++){ for(int j=0;j<6;j++) cout<<f[i][j];cout<<endl;}}\n\nint dx[4] = {0,0,1,-1}, dy[4] = {1,-1,0,0};\nint count(int y,int x){\n  if( isCheck[y][x] ) return 0;\n  isCheck[y][x] = true;\n  char c = f[y][x];\n\n  int nx,ny, rtn=1;\n  for( int i=0;i<4;i++ ){\n    nx=x+dx[i]; ny=y+dy[i];\n    if( nx<0 || nx>=6 ) continue;\n    if( ny<0 || ny>=12) continue;\n    if( f[ny][nx] == c )\n      rtn += count(ny,nx);\n  }\n  return rtn;\n}\nvoid erase( int y,int x ){\n  char c = f[y][x];\n  f[y][x] = '.';\n  int nx,ny;\n  for( int i=0;i<4;i++ ){\n    nx=x+dx[i]; ny=y+dy[i];\n    if( nx<0 || nx>=6 ) continue;\n    if( ny<0 || ny>=12) continue;\n    if( f[ny][nx]=='O' )     f[ny][nx]='.';\n    else if( f[ny][nx]==c )  erase( ny,nx );\n  }\n}\n\n\nint main(){\n  int datasetN;  cin >> datasetN;\n  while( datasetN-- ){\n    for( int i=0;i<12;i++ ) for( int j=0;j<6;j++ ) cin >> f[i][j];\n\n    int ans=0;\n    bool flag;\n    do{\n      flag=false;\n      for( int i=0;i<12;i++)for( int j=0;j<6;isCheck[i][j++]=false );\n      vector<P> v;\n      for( int i=0;i<12;i++ )\n\tfor( int j=0;j<6;j++ ){\n\t  if( f[i][j]=='O' || f[i][j]=='.' || isCheck[i][j] ) continue;\n\t  int cnt = count(i,j);\n\t  if( cnt>=4 ){ v.push_back( P(i,j) );   flag = true;\t  }\n\t}\n      if( flag ){ // 消去処理\n\tans++;\n\tfor( int i=0;i<(int)v.size();i++ ){\n\t  //\t  cout << \"erase \" << v[i].first << \" \" << v[i].second << endl;\n\t  erase( v[i].first,v[i].second );\n\t}\n\t// 落下処理\n\t//\tcout << ans << endl;\tpr();\n\tfor( int j=0;j<6;j++ ){\n\t  for( int i=11;i>=0;i-- ){\n\t    if( f[i][j]=='.' ){\n\t      for( int k=i-1;k>=0;k-- ){\n\t\tif( f[k][j]!='.' ){\n\t\t  f[i][j] = f[k][j];\n\t\t  f[k][j] = '.';\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\t//\tpr();\n      }\n    }while( flag );\n    cout << ans << endl;;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstring field[12];\nstring buf[12];\n\nvoid fall(){\n\tint i,j;\n\tbool update;\n\tfor(i=0;i<6;i++){\n\t\tupdate=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(j=11;j>0;j--){\n\t\t\t\tif(field[j][i]=='.'&&field[j-1][i]!='.'){\n\t\t\t\t\tfield[j][i]=field[j-1][i];\n\t\t\t\t\tfield[j-1][i]='.';\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint count(string str[],int x,int y,char c){\n\tif(x<0||6<=x||y<0||12<=y)return 0;\n\tif(str[y][x]!=c)return 0;\n\tint res=1;\n\tstr[y][x]='*';\n\tres+=count(str,x+1,y,c);\n\tres+=count(str,x-1,y,c);\n\tres+=count(str,x,y+1,c);\n\tres+=count(str,x,y-1,c);\n\treturn res;\n}\n\nbool bomb(){\n\tint i,j;\n\tbool res=false;\n\tfor(i=0;i<12;i++){\n\t\tbuf[i]=field[i];\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(buf[i][j]=='R'||buf[i][j]=='G'||buf[i][j]=='B'||buf[i][j]=='Y'||buf[i][j]=='P'){\n\t\t\t\tint c=count(buf,j,i,buf[i][j]);\n\t\t\t\tif(4<=c){\n\t\t\t\t\tcount(field,j,i,field[i][j]);\n\t\t\t\t\tres=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint xx[]={1,-1,0,0},yy[]={0,0,1,-1};\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(field[i][j]=='*'){\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\tif(i+yy[k]<0||i+yy[k]>=12||j+xx[k]<0||j+xx[k]>=6)continue;\n\t\t\t\t\tif(field[i+yy[k]][j+xx[k]]=='O')field[i+yy[k]][j+xx[k]]='.';\n\t\t\t\t}\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n=in();\n\twhile(n--){\n\t\tint i;\n\t\tfor(i=0;i<12;i++){\n\t\t\tcin>>field[i];\n\t\t}\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tif(!bomb())break;\n//for(i=0;i<12;i++){\n//cout<<field[i]<<endl;\n//}\n//cout<<endl;\n\t\t\tfall();\n//for(i=0;i<12;i++){\n//cout<<field[i]<<endl;\n//}\n//cout<<endl;\n\t\t\tres++;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nchar board[12][6];\nchar tmpb[12][6];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid print() {\n  int i,j;\n  rep(i,12) {\n    rep(j,6) {\n      cout<<board[i][j];\n    }\n    cout<<endl;\n  }\n}\n\nbool isok(int x,int y) {\n  return (x >= 0 && x < 6 && y >= 0 && y < 12);\n\t  }\n\nbool erase() {\n  bool isb[12][6];\n  int i,j,k,l;\n  bool update = false;\n  memset(isb, false, sizeof(isb));\n  rep(i,12) {\n    rep(j,6) {\n      if(isb[i][j]) continue;\n      isb[i][j] = true;\n      if(board[i][j] == '.' || board[i][j] == 'O') continue;\n\n      queue<pair<int,int> > Q;\n      vector<pair<int,int> > vv;\n      Q.push(make_pair(i,j)); vv.push_back(make_pair(i,j));\n      while(!Q.empty()) {\n\tpair<int,int> p = Q.front(); Q.pop();\n\tint x = p.second,y = p.first;\n\trep(k,4) {\n\t  if(isok(x+dx[k],y+dy[k]))\n\t    if(board[y+dy[k]][x+dx[k]] == board[y][x] && !isb[y+dy[k]][x+dx[k]]) {\n\t      Q.push(make_pair(y+dy[k],x+dx[k]));\n\t      isb[y+dy[k]][x+dx[k]] = true;\n\t      vv.push_back(make_pair(y+dy[k],x+dx[k]));\n\t    }\n\t}\n      }\n\n      if(vv.size() >= 4) {\n\tupdate = true;\n\trep(k,vv.size()) {\n\t  int x = vv[k].second,y = vv[k].first;\n\t  rep(l,4) {\n\t    if(isok(x+dx[l],y+dy[l]))\n\t      if(board[y+dy[l]][x+dx[l]] == 'O')\n\t\tboard[y+dy[l]][x+dx[l]] = '.';\n\t  }\n\t  board[vv[k].first][vv[k].second] = '.';\n\t}\n      }\n    }\n  }\n\n  return update;\n}\n\nvoid drop() {\n  int i,j,k;\n  for(i=11; i>=0; --i) {\n    rep(j,6) {\n      if(board[i][j] == '.') {\n\tk = i;\n\twhile(k >= 0) {\n\t  if(!(board[k][j] == '.')) {\n\t    board[i][j] = board[k][j];\n\t    board[k][j] = '.';\n\t    break;\n\t  }\n\t  k--;\n\t}\n      }\n    }\n  }\n}\n\nint solve() {\n  bool update = false;\n  int t = 0;\n  while(true) {\n    //cout<<t<<endl;\n    update = erase();\n    //cout<<\"end erase \"<<update<<endl;\n    //print();\n    if(!update) return t;\n    t++;\n    drop();\n    //cout<<\"end drop\"<<endl;\n    //print();\n  }\n}\n\nvoid input() {\n  int i,j;\n  string s;\n  rep(i,12) {\n    cin>>s;\n    rep(j,6)\n      board[i][j] = s.at(j);\n  }\n  return;\n}\n\nint main() {\n  int t;\n  cin>>t;\n  while(t--) {\n    memset(board,0,sizeof(board));\n    memset(tmpb, 0, sizeof(tmpb));\n    input();\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<iostream>\nusing namespace std;\nvector<string> puyos;\nint w,h;\nint ve[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\nvoid umel(int y,int x,char se){\n    puyos[y][x]='T';\n    for(int i=0;i<4;i++){\n        int ny=y+ve[i][0],nx=x+ve[i][1];\n        if(0<=nx && nx<w && 0<=ny && ny<h && puyos[ny][nx]==se){\n            umel(ny,nx,se);\n        }\n    }\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int inow=0;inow<n;inow++){\n        char t[10];\n        puyos=vector<string>(12);\n        for(int i=0;i<12;i++){\n            scanf(\"%s\\n\",t);\n            puyos[i]=string(t);\n        }\n        h=12;\n        w=6;\n        for(int ix=0;;ix++){\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    char nowc=puyos[i][j];\n                    if(nowc!='.'&&nowc!='O'&&nowc!='S'){\n                        umel(i,j,nowc);\n                        int num=0;\n                        for(int ky=0;ky<h;ky++){\n                            for(int kx=0;kx<w;kx++){\n                                if(puyos[ky][kx]=='T')num++;\n                            }\n                        }\n                        char daic;\n                        if(num>=4)daic='S';\n                        else daic=nowc;\n                            for(int ky=0;ky<h;ky++){\n                                for(int kx=0;kx<w;kx++){\n                                    if(puyos[ky][kx]=='T')puyos[ky][kx]=daic;\n                                }\n                            }\n                    }\n                }\n            }\n            for(int iy=0;iy<h;iy++){\n                for(int ix=0;ix<w;ix++){\n                    if(puyos[iy][ix]=='O'){\n                        for(int vi=0;vi<4;vi++){\n                            int ny=iy+ve[vi][0],nx=ix+ve[vi][1];\n                            if(0<=nx && nx<w && 0<=ny && ny<h && puyos[ny][nx]=='S'){\n                                puyos[iy][ix]='T';\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            bool iscont=false;\n            for(int ky=0;ky<h;ky++){\n                for(int kx=0;kx<w;kx++){\n                    if(puyos[ky][kx]=='S'||puyos[ky][kx]=='T'){\n                        puyos[ky][kx]='.';\n                        iscont=true;\n                    }\n                }\n            }\n            if(!iscont){\n                printf(\"%d\\n\",ix);\n                break;\n            }\n            vector<vector<char> > tates(w);\n            for(int ky=h-1;ky>=0;ky--){\n                for(int kx=0;kx<w;kx++){\n                    if(puyos[ky][kx]!='.') tates[kx].push_back(puyos[ky][kx]);\n                }\n            }\n            for(int ky=0;ky<h;ky++){\n                for(int kx=0;kx<w;kx++){\n                    puyos[ky][kx]='.';\n                }\n            }\n            for(int kx=0;kx<w;kx++){\n                for(int ky=0;ky<tates[kx].size();ky++){\n                    puyos[h-ky-1][kx]=tates[kx][ky];\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n\nconst int blank = 0;\nconst int red = 1;\nconst int green = 2;\nconst int blue = 3;\nconst int yellow = 4;\nconst int purple = 5;\nconst int  ojyama = -1;\n\nint field[8][14];\nbool chk[8][14];\nbool death[8][14];\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\n\nint is_sameblocks(int px,int py){\n  stack<int> st;\n  st.push(py*8+px);\n  int s = 0;\n  while(!st.empty()){\n    px = st.top()%8;\n    py = st.top()/8;\n    chk[px][py] = true;\n    st.pop();\n    s++;\n    for(int i=0;i<4;i++){\n      if(!chk[px+dx[i]][py+dy[i]]&&field[px+dx[i]][py+dy[i]]==field[px][py])\n\tst.push((py+dy[i])*8+px+dx[i]);\n    }\n  }\n  return s;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<string> puyo(12);\n  for(;n>0;n--){\n\n    for(int i=0;i<12;i++){\n      cin>>puyo[i];\n    }\n    for(int x=0;x<8;x++){\n      field[x][0] = blank;\n      field[x][13] = blank;\n    }\n    for(int y=0;y<14;y++){\n      field[0][y] = blank;\n      field[7][y] = blank;\n    }\n\n    //input\n    for(int y=0;y<12;y++){\n      for(int x=0;x<6;x++){\n\tswitch(puyo[y][x]){\n\tcase'R':\n\t  field[x+1][y+1] = red;\n\t  break;\n\tcase'G':\n\t  field[x+1][y+1] = green;\n\t  break;\n\tcase'B':\n\t  field[x+1][y+1] = blue;\n\t  break;\n\tcase'Y':\n\t  field[x+1][y+1] = yellow;\n\t  break;\n\tcase'P':\n\t  field[x+1][y+1] = purple;\n\t  break;\n\tcase'O':\n\t  field[x+1][y+1] = ojyama;\n\t  break;\n\tcase'.':\n\t  field[x+1][y+1] = blank;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      }\n    }\n    int chain = 0;\n    while(true){\n    //erase\n      bool erase = false;\n      for(int y=1;y<13;y++){\n\tfor(int x=1;x<7;x++){\n\t  for(int k=0;k<112;k++)\n\t    chk[k%8][k/8] = false;\n\t  if(field[x][y] > 0&&is_sameblocks(x,y)>=4)\n\t    death[x][y] = true;\n\t  else\n\t    death[x][y] = false;\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == ojyama){\n\t    for(int i=0;i<4;i++){\n\t      if(death[x+dx[i]][y+dy[i]])\n\t\tfield[x][y] = blank;\n\t    }\n\t  }\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(death[x][y]){\n\t    field[x][y] = blank;\n\t    erase = true;\n\t  }\n\t}\n      }\n      \n      if(!erase)break;\n    //fall\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == blank && field[x][y-1]!=blank){\n\t    field[x][y] = field[x][y-1];\n\t    field[x][y-1] = blank;\n\t    x=1,y=12;\n\t  }\n\t}\n      }\n      chain++;\n    }    \n    cout<<chain<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint checkfrom(int i, int j, char f[][6], bool c[][6]){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    c[i][j] = true;\n    memset(c,false,sizeof(c));\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !c[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                c[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    for(int x=0;x<n;x++){\n        char f[12][6];\n        bool checked[12][6];\n        memset(f, 0, sizeof(f));\n\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                cin >> f[i][j];\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=0;i<12;i++){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O'){\n                        max_deleted = max(checkfrom(i, j, f, checked), max_deleted);\n                    }\n                }\n            }\n            int hoge;\n            for(int i=10;i>=0;i--){\n                for(int j=0;j<6;j++){\n                    int tx = i, ty = j;\n                    while(tx <= 10 && f[tx][ty] != '.' && f[tx+1][ty] == '.'){\n                        f[tx+1][ty] = f[tx][ty];\n                        f[tx][ty] = '.';\n                        tx++;\n                    }\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<char, int>P;\n\nchar s[7];\nP f[12][6];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[12][6];\n\nint dfs(int x, int y) {\n\tused[x][y] = true;\n\tint res = 1;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < 12 && 0 <= ny&&ny < 6 && !used[nx][ny] && f[nx][ny].first == f[x][y].first)\n\t\t\tres += dfs(nx, ny);\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(i, 12) {\n\t\t\tscanf(\"%s\", s);\n\t\t\trep(j, 6)f[i][j] = P(s[j], 0);\n\t\t}\n\t\tint cnt = 0; bool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep(i, 12)rep(j, 6)f[i][j].second = 0;\n\t\t\trep(i, 12)rep(j, 6) {\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tif (f[i][j].first != '.'&&f[i][j].first != 'O'&&dfs(i, j) >= 4)\n\t\t\t\t\tf[i][j].second = 1;\n\t\t\t}\n\t\t\trep(i, 12)rep(j, 6) {\n\t\t\t\tif (f[i][j].first != 'O')continue;\n\t\t\t\tbool ok = false;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\tif (0 <= nx&&nx < 12 && 0 <= ny&&ny < 6 && f[nx][ny].first != 'O'&&f[nx][ny].second)ok = true;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tf[i][j].second = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 12)rep(j, 6) {\n\t\t\t\tif (f[i][j].second) {\n\t\t\t\t\tf[i][j].first = '.'; update = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 10; i >= 0; i--)rep(j, 6) {\n\t\t\t\tint k = i;\n\t\t\t\twhile (k <= 10 && f[k + 1][j].first == '.')swap(f[k][j], f[k + 1][j]), k++;\n\t\t\t}\n\t\t\tif (update)cnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tif(i+dy[k] >= 0 && i+dy[k] < 12 && j+dx[k] >= 0 && j+dx[k] < 6 \n\t\t\t&& area[i+dy[k]][j+dx[k]] == c && !used[i+dy[k]][j+dx[k]]){\n\t\t\tcounter += count(i+dy[k], j+dx[k], c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\n\nvector<string> field(6);\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool seen[6][12];\n\nvector<vector<pint> > ram;\nvector<pint> temp;\nvector<pint> oja;\n\nvoid dfs(int x, int y) {\n    seen[x][y] = true;\n    char c = field[x][y];\n    temp.PB(MP(x,y));\n    \n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < 6 && ny >= 0 && ny < 12) {\n            if (seen[nx][ny]) continue;\n            if (field[nx][ny] == c) {\n                dfs(nx, ny);\n            }\n            else if (field[nx][ny] == 'O') {\n                oja.PB(MP(nx,ny));\n            }\n        }\n    }\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    int N;\n    cin >> N;\n    \n    for (int id = 0; id < N; ++id) {\n        field.clear();\n        field.resize(6);\n        \n        char c;\n        for (int i = 0; i < 12; ++i) {\n            for (int j = 0; j < 6; ++j) {\n                cin >> c;\n                field[j].PB(c);\n            }\n        }\n        for (int i = 0; i < 6; ++i) reverse(ALL(field[i]));\n        \n        int con = 0;\n        while (true) {\n            //COUT(field);\n            \n            ram.clear();\n            memset(seen, 0, sizeof(seen));\n            for (int i = 0; i < 6; ++i) {\n                for (int j = 0; j < 12; ++j) {\n                    if (!seen[i][j] && field[i][j] != '.' && field[i][j] != 'O') {\n                        temp.clear(); oja.clear();\n                        dfs(i,j);\n                        if (temp.size() >= 4) {\n                            for (int k = 0; k < oja.size(); ++k) temp.PB(oja[k]);\n                            ram.PB(temp);\n                        }\n                    }\n                }\n            }\n            \n            if (ram.size() == 0) break;\n            \n            //COUT(ram);\n            \n            for (int i = 0; i < ram.size(); ++i) {\n                for (int j = 0; j < ram[i].size(); ++j) {\n                    field[ram[i][j].FI][ram[i][j].SE] = '-';\n                }\n            }\n            for (int i = 0; i < 6; ++i) {\n                for (int j = 0; j < field[i].size(); ++j) {\n                    if (field[i][j] == '-') {\n                        field[i].erase(field[i].begin() + j--);\n                    }\n                }\n            }\n            for (int i = 0; i < 6; ++i) {\n                while (field[i].size() < 12) field[i].PB('.');\n            }\n            \n            ++con; \n        }\n        \n        cout << con << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint checkfrom(int i, int j, char f[][6], bool c[][6]){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    c[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !c[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                c[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    for(int x=0;x<n;x++){\n        char f[12][6];\n        bool checked[12][6];\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                cin >> f[i][j];\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=0;i<12;i++){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j, f, checked), max_deleted);\n                    }\n                }\n            }\n            for(int i=10;i>=0;i--){\n                for(int j=0;j<6;j++){\n                    int tx = i, ty = j;\n                    while(tx <= 10 && f[tx][ty] != '.' && f[tx+1][ty] == '.'){\n                        f[tx+1][ty] = f[tx][ty];\n                        f[tx][ty] = '.';\n                        tx++;\n                    }\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\n\nconst int blank = 0;\nconst int red = 1;\nconst int green = 2;\nconst int blue = 3;\nconst int yellow = 4;\nconst int purple = 5;\nconst int  ojyama = -1;\n\nint field[8][14];\nbool chk[8][14];\nbool death[8][14];\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\n\nint is_sameblocks(int px,int py){\n  queue<int> qu;\n  qu.push(py*8+px);\n  int s = 0;\n  while(!qu.empty()){\n    px = qu.front()%8;\n    py = qu.front()/8;\n    chk[px][py] = true;\n    qu.pop();\n    s++;\n    for(int i=0;i<4;i++){\n      if(!chk[px+dx[i]][py+dy[i]]&&field[px+dx[i]][py+dy[i]]==field[px][py])\n\tqu.push((py+dy[i])*8+px+dx[i]);\n    }\n  }\n  return s;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<string> puyo(12);\n  for(;n>0;n--){\n\n    for(int i=0;i<12;i++){\n      cin>>puyo[i];\n    }\n    for(int x=0;x<8;x++){\n      field[x][0] = blank;\n      field[x][13] = blank;\n    }\n    for(int y=0;y<14;y++){\n      field[0][y] = blank;\n      field[7][y] = blank;\n    }\n\n    //input\n    for(int y=0;y<12;y++){\n      for(int x=0;x<6;x++){\n\tswitch(puyo[y][x]){\n\tcase'R':\n\t  field[x+1][y+1] = red;\n\t  break;\n\tcase'G':\n\t  field[x+1][y+1] = green;\n\t  break;\n\tcase'B':\n\t  field[x+1][y+1] = blue;\n\t  break;\n\tcase'Y':\n\t  field[x+1][y+1] = yellow;\n\t  break;\n\tcase'P':\n\t  field[x+1][y+1] = purple;\n\t  break;\n\tcase'O':\n\t  field[x+1][y+1] = ojyama;\n\t  break;\n\tcase'.':\n\t  field[x+1][y+1] = blank;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      }\n    }\n    int chain = 0;\n    while(true){\n    //erase\n      bool erase = false;\n      for(int y=1;y<13;y++){\n\tfor(int x=1;x<7;x++){\n\t  for(int k=0;k<112;k++)\n\t    chk[k%8][k/8] = false;\n\t  if(field[x][y] > 0&&is_sameblocks(x,y)>=4)\n\t    death[x][y] = true;\n\t  else\n\t    death[x][y] = false;\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == ojyama){\n\t    for(int i=0;i<4;i++){\n\t      if(death[x+dx[i]][y+dy[i]])\n\t\tdeath[x][y] = true;\n\t    }\n\t  }\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(death[x][y]){\n\t    field[x][y] = blank;\n\t    erase = true;\n\t  }\n\t}\n      }\n      \n      if(!erase)break;\n    //fall\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == blank && field[x][y-1]!=blank){\n\t    field[x][y] = field[x][y-1];\n\t    field[x][y-1] = blank;\n\t    x=1,y=12;\n\t  }\n\t}\n      }\n      chain++;\n    }    \n    cout<<chain<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n \nbool markBlock(bool toErase[12][6],char stage[12][6]){\n \n  bool res = false;\n  for(int y=0;y<12;y++){\n    for(int x=0;x<6;x++){\n      if(stage[y][x] == '.'\n\t || stage[y][x] == 'O') continue;\n \n      if(!toErase[y][x]){\n\tchar color = stage[y][x];\n\tint count = 0;\n\tbool tmp[12][6];\n\tmemcpy(tmp,toErase,sizeof(bool)*12*6);\n \n\tdfs(x,y,stage,toErase,color,&count);\n\tif(count < 4){\n\t  memcpy(toErase,tmp,sizeof(bool)*12*6);\n\t}\n\telse{\n\t  res = true;\n\t}\n      }\n    }\n  }\n \n  return res;\n}\n \nvoid eraseBlock(bool toErase[12][6],char stage[12][6]){\n  for(int x=0;x<6;x++){\n    for(int y=0;y<12;y++){\n      if(stage[y][x] == '.'){\n\ttoErase[y][x] = true;\n\tcontinue;\n      }\n      if(stage[y][x] == 'O'){\n\tfor(int i=0;i<4;i++){\n\t  int dx = x + tx[i];\n\t  int dy = y + ty[i];\n\t  if(dx < 0 || dx >= 6 \n\t     || dy < 0 || dy >= 12) continue;\n\t  if(toErase[dy][dx] == true\n                        && stage[dy][dx] != '.'\n\t     && stage[dy][dx] != 'O'){\n\t    toErase[y][x] = true;\n\t  }\n\t}\n      }\n    }\n  }\n \n  char nextStage[12][6];\n  for(int x=0;x<6;x++){\n    queue<char> que; \n    for(int y=12-1;y>=0;y--){\n      if(!toErase[y][x]){\n\tque.push(stage[y][x]);\n      }\n    }\n \n    int idx = 12-1;\n    while(!que.empty()){\n      nextStage[idx][x] = que.front();\n      que.pop();\n      idx--;\n    }\n    while(idx >= 0){\n      nextStage[idx][x] = '.';\n      idx--;\n    }\n  }\n \n  memcpy(stage,nextStage,sizeof(char)*12*6);\n}\n \nvoid printStage(char stage[12][6]){\n  for(int y=0;y<12;y++){\n    for(int x=0;x<6;x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n \nint main(){\n  int n;\n \n  while(~scanf(\"%d\",&n)){\n    for(int i=0;i<n;i++){\n      char stage[12][6];\n      bool toErase[12][6];\n      memset(toErase,0,sizeof(toErase));\n \n      for(int y=0;y<12;y++){\n\tstring str;\n\tcin >> str;\n\tfor(int x=0;x<6;x++){\n\t  stage[y][x] = str[x];\n\t}\n      }\n \n      //printStage(stage);\n      int res = 0;\n      while(markBlock(toErase,stage)){\n\teraseBlock(toErase,stage);\n\tmemset(toErase,0,sizeof(toErase));\n\tres++;\n\t//printStage(stage);\n      }\n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nbool check1[14][8];\nint check2[14][8];\nint block[14][8];\nvoid GetBlock(){\n  memset(block,0,sizeof(block));\n  for(int i=1; i<=12; i++){\n    for(int j=1; j<=6; j++){\n      block[i][j] = getchar();\n    }\n    getchar();\n  }\n}\nvoid Makecheck2(int x, int y){\n  REP(k,4){\n    if(check2[x+dx[k]][y+dy[k]]==false&&\n        block[x][y]==block[x+dx[k]][y+dy[k]]){\n      check1[x+dx[k]][y+dy[k]] = true;\n      check2[x+dx[k]][y+dy[k]] = true;\n      Makecheck2(x+dx[k], y+dy[k]);\n    }\n    if(check2[x+dx[k]][y+dy[k]]==false&&block[x+dx[k]][y+dy[k]]=='O')\n      check2[x+dx[k]][y+dy[k]] = 100;\n  }\n}\nint CheckNum(int x, int y){\n  int count = 0;\n  memset(check2,0,sizeof(check2));\n  check2[x][y] = true;\n  Makecheck2(x,y);\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j]==true) count++;\n  return count;\n}\nvoid Break(){\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j] == true || check2[i][j] == 100)\n        block[i][j] = '.';\n}\n\nbool CheckIsR(){\n  bool flag2 = false;\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check1[i][j]==false){\n        if(block[i][j]!='.'&&block[i][j]!='O'){\n          check1[i][j] = true;\n          if(CheckNum(i,j)>=4){\n            flag2 = true;\n            Break();\n          }\n        }else{\n          check1[i][j] = true;\n        }\n      }\n  return flag2;\n}\nbool Down(){\n  bool flag3;\n  do{\n    flag3 = false;\n    FOR(i,1,13)\n      FOR(j,1,7)\n        if(block[i][j] != '.' && block[i+1][j] == '.'){\n          swap(block[i][j],block[i+1][j]);\n          flag3 = true;\n        }\n  }while(flag3);\n}\n\nint main(void){  \n  GetBlock();\n  int count=0;\n  while(true){\n    memset(check1,0,sizeof(check1));\n    if(CheckIsR()) count++;\n    else break;\n    Down();\n  }\n  cout << count << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\nstruct Point{int x,y,c;};\nstruct xy{int x,y;};\nint main(){\n  int t;\n  cin >> t;\n  int i,j,k,a;\n  for(i=0;i<t;i++){\n    string str;\n    int b;\n    int o=0;\n    int st[6][12]={{}};\n    for(j=0;j<12;j++){\n      cin >> str;\n      for(k=0;k<6;k++){\n\tif(str[k]=='R') b=2;\n\tif(str[k]=='G') b=3;\n\tif(str[k]=='B') b=4;\n\tif(str[k]=='Y') b=5;\n\tif(str[k]=='P') b=6;\n\tif(str[k]=='O') b=1;\n\tif(str[k]=='.') b=0;\n\tst[k][j]=b;\n      }\n    }\n    queue<Point> q;\n    Point p,bu;\n\n    int ax[]={1,-1,0,0},ay[]={0,0,1,-1};\n    int f=0;\n    int s;\n    while(f==0){\n      o++;\n      f=1;\n      int v[6][12]={{}};\n      for(j=0;j<12;j++){\n\tfor(k=0;k<6;k++){\n\t  if(st[k][j]==0||st[k][j]==1||v[k][j]==1) continue;\n\t  p.x=k;p.y=j;p.c=st[k][j];\n\t  q.push(p);\n\t  vector <xy> vxy;\n\t  xy bxy;\n\t  bxy.x=k;bxy.y=j;\n\t  vxy.push_back(bxy);\n\t  v[k][j]=1;\n\t  s=1;\n\t  while(!q.empty()){\n\t    p=q.front();\n\t    q.pop();\n\t    for(a=0;a<4;a++){\n\t      bu.x=p.x+ax[a];\n\t      bu.y=p.y+ay[a];\n\t      if(bu.x<0||bu.x>=6||bu.y<0||bu.y>=12) continue;\n\t      bu.c=st[bu.x][bu.y];\n\t      if(bu.c==1) {\n\t\tbxy.x=bu.x;bxy.y=bu.y;\n\t\tvxy.push_back(bxy);\n\t\tcontinue;\n\t      }\n\t      \n\t      if(bu.c==p.c&&v[bu.x][bu.y]==0){\n\t\ts++;\n\t\tbxy.x=bu.x;bxy.y=bu.y;\n\t\tvxy.push_back(bxy);\n\t\tq.push(bu);\n\t\tv[bu.x][bu.y]=1;\n\t      }\n\t    }\n\t  }\n\t  //cout << k << \" \" << j << endl;\n\t  \n\t  if(s>=4){\n\t    for(a=0;a<vxy.size();a++){\n\t      st[vxy[a].x][vxy[a].y]=0;\n\t      //cout << vxy[a].x << \" \" << vxy[a].y << endl;\n\t      f=0;\n\t      \n\t    }\n\t    \n\t  }\n\t  //cout << endl;\n\t}\n      }\n      /*\n\n      for(j=0;j<12;j++){\n\tfor(k=0;k<6;k++){\n\t  cout << v[k][j];\n\t}\n\tcout << endl;\n      }\n\n      */\n      \n      for(k=0;k<6;k++){\n\tvector<int> data;\n\tfor(j=0;j<12;j++){\n\t  if(st[k][j]!=0) data.push_back(st[k][j]);\n\t}\n\tfor(j=0;j<12-data.size();j++) st[k][j]=0;\n\tfor(j=12-data.size();j<12;j++) st[k][j]=data[j+data.size()-12];\n\t\n      }\n      /*\n      for(j=0;j<12;j++){\n\tfor(k=0;k<6;k++){\n\t  cout << st[k][j];\n\t}\n\tcout << endl;\n      }\n      cout <<o<< endl;\n      */\n    }\n    \n    /*\n      cout << endl;\n    \n    for(j=0;j<12;j++){\n      for(k=0;k<6;k++){\n\tcout << st[k][j];\n      }\n      cout << endl;\n    }\n    */\n    cout << o-1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int H = 12;\nconst int W = 6;\n\nint my[] = {1, -1, 0, 0};\nint mx[] = {0, 0, 1, -1};\n\nvoid disp(vector<string> &v){\n  REP(i, H) cout <<v[i] <<endl;\n  cout <<\"-----------\" <<endl;\n}\n\nint count(vector<string> &v, vector< vector<bool> > &visited, int y, int x, char tar){\n  visited[y][x] = 1;\n  int res = 1;\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W && v[ny][nx] == tar && !visited[ny][nx]) res += count(v, visited, ny, nx, tar);\n  }\n  return res;\n}\n\nvoid remove(vector<string> &v, int y, int x, char tar){\n  v[y][x] = '.';\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n      if(v[ny][nx] == tar) remove(v, ny, nx, tar);\n      if(v[ny][nx] == 'O') v[ny][nx] = '.';\n    }\n  }\n}\n\nvoid fall(vector<string> &v){\n  REP(x, W){\n    for(int y = H - 1; y >= 0; --y){\n      if(v[y][x] == '.') continue;\n      int ty = y;\n      while(ty < H - 1 && v[ty + 1][x] == '.') { swap(v[ty][x], v[ty + 1][x]); ++ty; }\n    }\n  }\n}\n\n\nint check(vector<string> &v){\n  vector<string> bef = v;\n  vector< vector<bool> > visited(H, vector<bool>(W, 0));\n  REP(y, H){\n    REP(x, W){\n      if(visited[y][x] || v[y][x] == '.' || v[y][x] == 'O') continue;\n      int cnt = count(v, visited, y, x, v[y][x]);\n      if(cnt >= 4) remove(v, y, x, v[y][x]);\n    }\n  }\n  fall(v);\n  return v != bef;\n}\n\nint main() {\n  int T; cin >>T;\n  while(T--){\n    vector<string> v(H);\n    REP(i, H) cin >>v[i];\n    int ans = 0;\n    while(check(v)) ++ans;\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nchar G[12][6];\nint nseq, cnt;\nbool v[12][6];\n\nvoid reset(){ rep(i, 12) rep(j, 6) v[i][j] = false; }\n\nbool isColor( char c ){\n    return c == 'R' || c == 'G' || c == 'B' || c == 'Y' || c == 'P';\n}\n\nvoid dfs(int y, int x, char c){\n    cnt++;\n    int ni, nj;\n    v[y][x] = true;\n    rep(r, 4){\n\tni = y + di[r];\n\tnj = x + dj[r];\n\tif ( ni < 0 || nj < 0 || ni >= 12 || nj >= 6 ) continue;\n\tif ( !v[ni][nj] && c == G[ni][nj] ) dfs(ni, nj, c);\n    }\n}\n\nvoid parse(int y, int x, char c){\n    int ni, nj;\n    G[y][x] = 'X';\n    rep(r, 4){\n\tni = y + di[r];\n\tnj = x + dj[r];\n\tif ( ni < 0 || nj < 0 || ni >= 12 || nj >= 6 ) continue;\n\tif ( c == G[ni][nj] ) parse(ni, nj, c);\n    }\n}\n\nbool simulate(){\n  \n\n    bool isR = false;\n    rep(i, 12) rep(j, 6){\n\tcnt = 0;\n\tif ( isColor(G[i][j])){\n\t    reset();\n\t    dfs(i, j, G[i][j]);\n\t}\n\tif ( cnt >= 4 ){\n\t    reset();\n\t    parse(i, j, G[i][j]);\n\t    isR = true;\n\t}\n    }\n\n    \n    rep(i, 12) rep(j, 6){\n\tif ( G[i][j] != 'O' ) continue;\n\trep(r, 4){\n\t    int ni = i + di[r];\n\t    int nj = j + dj[r];\n\t    if ( ni < 0 || nj < 0 || ni >= 12 || nj >= 6 ) continue;\n\t    if ( G[ni][nj] == 'X' ) G[i][j] = 'x';\n\t}\n    }\n   \n    rep(i, 12) rep(j, 6) if ( G[i][j] == 'X' || G[i][j] == 'x' ) G[i][j] = '.';\n    \n  \n\n\n\n\n    for ( int j = 0; j < 6; j++ ){\n\twhile(1){\n\t    bool isChange = false;\n\t    for ( int i = 11; i >= 1; i-- ){\n\t\tif ( G[i][j] == '.' && G[i-1][j] != '.' ){\n\t\t    G[i][j] = G[i-1][j];\n\t\t    G[i-1][j] = '.';\n\t\t    isChange = true;\n\t\t    break;\n\t\t}\n\t    }\n\t    if ( !isChange ) break;\n\t}\n    }\n\n\n    return isR;\n}\n\nvoid compute(){\n    rep(i, 12) rep(j, 6) cin >> G[i][j];\n    nseq = 0;\n    while(simulate()){ nseq++; }\n    cout << nseq << endl;\n}\n\nmain(){\n    int tcase; cin >> tcase;\n    for ( int i = 0; i < tcase; i++ ) compute();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n\nconst int blank = 0;\nconst int red = 1;\nconst int green = 2;\nconst int blue = 3;\nconst int yellow = 4;\nconst int purple = 5;\nconst int  ojyama = -1;\n\nint field[8][14];\nbool chk[8][14];\nbool death[8][14];\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\n\nint is_sameblocks(int px,int py){\n  stack<int> st;\n  st.push(py*8+px);\n  int s = 0;\n  while(!st.empty()){\n    px = st.top()%8;\n    py = st.top()/8;\n    chk[px][py] = true;\n    st.pop();\n    s++;\n    for(int i=0;i<4;i++){\n      if(!chk[px+dx[i]][py+dy[i]]&&field[px+dx[i]][py+dy[i]]==field[px][py])\n\tst.push((py+dy[i])*8+px+dx[i]);\n    }\n  }\n  return s;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<string> puyo(12);\n  for(;n>0;n--){\n\n    for(int i=0;i<12;i++){\n      cin>>puyo[i];\n    }\n    for(int x=0;x<8;x++){\n      field[x][0] = blank;\n      field[x][13] = blank;\n    }\n    for(int y=0;y<14;y++){\n      field[0][y] = blank;\n      field[7][y] = blank;\n    }\n\n    //input\n    for(int y=0;y<12;y++){\n      for(int x=0;x<6;x++){\n\tswitch(puyo[y][x]){\n\tcase'R':\n\t  field[x+1][y+1] = red;\n\t  break;\n\tcase'G':\n\t  field[x+1][y+1] = green;\n\t  break;\n\tcase'B':\n\t  field[x+1][y+1] = blue;\n\t  break;\n\tcase'Y':\n\t  field[x+1][y+1] = yellow;\n\t  break;\n\tcase'P':\n\t  field[x+1][y+1] = purple;\n\t  break;\n\tcase'O':\n\t  field[x+1][y+1] = ojyama;\n\t  break;\n\tcase'.':\n\t  field[x+1][y+1] = blank;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      }\n    }\n    int chain = 0;\n    while(true){\n    //erase\n      bool erase = false;\n      for(int y=1;y<13;y++){\n\tfor(int x=1;x<7;x++){\n\t  for(int k=0;k<112;k++)\n\t    chk[k%8][k/8] = false;\n\t  if(field[x][y] > 0&&is_sameblocks(x,y)>=4)\n\t    death[x][y] = true;\n\t  else\n\t    death[x][y] = false;\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == ojyama){\n\t    for(int i=0;i<4;i++){\n\t      if(death[x+dx[i]][y+dy[i]])\n\t\tdeath[x][y] = true;\n\t    }\n\t  }\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(death[x][y]){\n\t    field[x][y] = blank;\n\t    erase = true;\n\t  }\n\t}\n      }\n      \n      if(!erase)break;\n    //fall\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == blank && field[x][y-1]!=blank){\n\t    field[x][y] = field[x][y-1];\n\t    field[x][y-1] = blank;\n\t    x=1,y=12;\n\t  }\n\t}\n      }\n      chain++;\n    }    \n    cout<<chain<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nbool check1[14][8];\nint check2[14][8];\nint block[14][8];\nvoid GetBlock(){\n  memset(block,0,sizeof(block));\n  for(int i=1; i<=12; i++){\n    for(int j=1; j<=6; j++){\n      block[i][j] = getchar();\n    }\n    getchar();\n  }\n}\nvoid Makecheck2(int x, int y){\n  REP(k,4){\n    if(check2[x+dx[k]][y+dy[k]]==false&&\n        block[x][y]==block[x+dx[k]][y+dy[k]]){\n      check1[x+dx[k]][y+dy[k]] = true;\n      check2[x+dx[k]][y+dy[k]] = true;\n      Makecheck2(x+dx[k], y+dy[k]);\n    }\n    if(check2[x+dx[k]][y+dy[k]]==false&&block[x+dx[k]][y+dy[k]]=='O')\n      check2[x+dx[k]][y+dy[k]] = 100;\n  }\n}\nint CheckNum(int x, int y){\n  int count = 0;\n  memset(check2,0,sizeof(check2));\n  check2[x][y] = true;\n  Makecheck2(x,y);\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j]==true) count++;\n  return count;\n}\nvoid Break(){\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j] == true || check2[i][j] == 100)\n        block[i][j] = '.';\n}\n\nbool CheckIsR(){\n  bool flag2 = false;\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check1[i][j]==false){\n        if(block[i][j]!='.'&&block[i][j]!='O'){\n          check1[i][j] = true;\n          if(CheckNum(i,j)>=4){\n            flag2 = true;\n            Break();\n          }\n        }else{\n          check1[i][j] = true;\n        }\n      }\n  return flag2;\n}\nbool Down(){\n  bool flag3;\n  do{\n    flag3 = false;\n    FOR(i,1,13)\n      FOR(j,1,7)\n        if(block[i][j] != '.' && block[i+1][j] == '.'){\n          swap(block[i][j],block[i+1][j]);\n          flag3 = true;\n        }\n  }while(flag3);\n}\n\nint main(void){  \n  GetBlock();\n  int count=0;\n  while(true){\n    memset(check1,0,sizeof(check1));\n    if(CheckIsR()) count++;\n    else break;\n    Down();\n  }\n  cout << count << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n\nusing namespace std;\nchar field[12][6];\nbool passed[12][6];\n\nint areaSize(int x, int y, char c){\n        if(x < 0 || x >= 6 || y < 0 || y >= 12){ return 0; }\n        if(field[y][x] != c || passed[y][x]){ return 0; }\n        passed[y][x] = true;\n        return\n                1 + areaSize(x - 1, y, c) + areaSize(x + 1, y, c) +\n                areaSize(x, y - 1, c) + areaSize(x, y + 1, c);\n}\nvoid paint(int x, int y, char c){\n        if(x < 0 || x >= 6 || y < 0 || y >= 12){ return; }\n        if(field[y][x] == 'O'){\n                field[y][x] = '.';\n                return;\n        }\n        if(field[y][x] != c){ return; }\n        field[y][x] = '.';\n        paint(x - 1, y, c);\n        paint(x + 1, y, c);\n        paint(x, y - 1, c);\n        paint(x, y + 1, c);\n}\n\nint main(){\n        int T;\n        cin >> T;\n        while(T--){\n                for(int i = 0; i < 12; ++i){\n                        string line;\n                        cin >> line;\n                        for(int j = 0; j < 6; ++j){ field[i][j] = line[j]; }\n                }\n                bool modified = true;\n                int answer = -1;\n                while(modified){\n                        modified = false;\n                        ++answer;\n                        memset(passed, 0, sizeof(passed));\n                        for(int i = 0; i < 12; ++i){\n                                for(int j = 0; j < 6; ++j){\n                                        if(field[i][j] == '.' || field[i][j] == 'O' || passed[i][j]){ continue; }\n                                        int s = areaSize(j, i, field[i][j]);\n                                        if(s < 4){ continue; }\n                                        modified = true;\n                                        paint(j, i, field[i][j]);\n                                }\n                        }\n                        for(int j = 0; j < 6; ++j){\n                                int p = 11;\n                                for(int i = 11; i >= 0; --i){\n                                        if(field[i][j] != '.'){\n                                                field[p--][j] = field[i][j];\n                                        }\n                                }\n                                for(; p >= 0; --p){ field[p][j] = '.'; }\n                        }\n                }\n                cout << answer << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst char p[7] = {'R','G','B','Y','P','O','.'};\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nstring f[12];\nint cnt = 0;\n\nvoid debug(){\n\tcout << endl;\n\tfor(int y=0 ; y<12 ; ++y )\n\t\tcout << f[y] << endl;\n\tcout << endl;\n}\n\nvoid downPuyo(int x,int y){\n\tchar t = f[y+1][x] ;\n\tf[y+1][x] = f[y][x];\n\tf[y][x] = t;\n\t\n\tif( y+1 != 11 && f[y+2][x] == '.' ){\n\t\tdownPuyo( x , y+1 );\n\t}\n}\n\nvoid checkPuyo(int x,int y,char color){\n\tf[y][x] += 'a' - 'A';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\t++cnt;\n\t\t\tcheckPuyo( mx , my , color );\n\t\t}\n\t}\n}\nvoid eracePuyo(int x,int y,char color){\n\tf[y][x] = '.';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\teracePuyo( mx , my , color );\n\t\t}\n\t\tif( f[my][mx] == 'O' ){\n\t\t\tf[my][mx] = '.';\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, chain;\n\t\n\tcin >> n;\n\tfor(int i=0 ; i<n ; ++i ){\n\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\tcin >> f[y];\n\t\t}\n\n\t\t//ú»\n\t\tbool flag = true;\n\t\tchain = 0;\n\n\t\t//Á¦éÕæªÈ­ÈéÜÅ[v\n\t\twhile( flag ){\n\t\t\tflag = false;\n\n\t\t\t/*cout << \"Á¦éO\" << endl;\n\t\t\tdebug();\n\t\t\tcout << endl;*/\n\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t//àµFÕæ¾Á½ç\n\t\t\t\t\t\tif( f[y][x] == p[i] ){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tcheckPuyo( x , y , p[i] );\n\t\t\t\t\t\t\t//àµSÂÈã­ÁÂ¢Ä¢½ç¯·\n\t\t\t\t\t\t\tif( cnt >= 4 ){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\teracePuyo( x , y , p[i] + ('a'-'A') );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//ú»\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tchar c = p[i] + ('a'-'A');\n\t\t\t\t\t\tif( f[y][x] == c ){\n\t\t\t\t\t\t\tf[y][x] -= ('a'-'A');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*cout << \"Á¦½ã\" << endl;\n\t\t\tdebug();\n\t\t\tcout << endl;*/\n\n\t\t\t//Á¦éÕæª éÆ«\n\t\t\tif( flag ){\n\t\t\t\tchain++;\n\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*cout << \"ºã\" << endl;\n\t\t\t\tdebug();\n\t\t\t\tcout << endl;*/\n\t\t\t}\t\t\n\t\t}\n\t\tcout << chain << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[8][14],b[8][14];\nint fn(int x,int y,int z){\n  int ct=0;\n  if(b[x][y]==-1){\n    if(0){\n    }else if(a[x][y]==z){\n      b[x][y]=1;\n      ct++;\n      ct+=fn(x-1,y,z);\n      ct+=fn(x+1,y,z);\n      ct+=fn(x,y-1,z);\n      ct+=fn(x,y+1,z);\n    }else if(a[x][y]=='O'){\n      b[x][y]=1;\n    }\n  }\n  return ct;\n}\nint main(){\n  int g,h,i,j,k,l,m;\n  int n;\n  cin>>n;\n  for(i=0;i<n;i++){\n    memset(a,-1,sizeof(a));\n    for(j=1;j<13;j++){\n      for(k=1;k<7;k++){\n\tchar s;\n\tcin>>s;\n\tif(s!='.')\n\t  a[k][j]=s;\n      }\n    }\n    h=1;    \n    for(g=-1;h;g++){\n      h=0;\n      for(j=1;j<13;j++){\n\tfor(k=1;k<7;k++){\n\t  if(a[k][j]!=-1&&a[k][j]!='O'){\n\t    memset(b,-1,sizeof(b));\n\t    if(fn(k,j,a[k][j])>3){\n\t      for(l=1;l<13;l++){\n\t\tfor(m=1;m<7;m++){\n\t\t  if(b[m][l]==1)\n\t\t    a[m][l]=-1;\n\t\t}\n\t      }\n\t      h=1;\n\t    }\n\t  }\n\t}\n      }\n      for(j=1;j<7;j++){\n\tfor(k=12;;){\n\t  for(;k>0&&a[j][k]!=-1;k--);\n\t  for(l=k;l>0&&a[j][l]==-1;l--);\n\t  if(l>0){\n\t    a[j][k]=a[j][l];\n\t    a[j][l]=-1;\n\t  }else\n\t    break;\n\t}\n      }\n    }\n    cout<<g<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W = 6, H = 12;\n\ntypedef vector<vector<char>> Field;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nint dfs_count(Field& f, int x, int y, char color) {\n    int blocks = 1;\n    f[y][x] = '.';\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (f[sy][sx] == color) {\n                blocks += dfs_count(f, sx, sy, color);\n            }\n        }\n    }\n    f[y][x] = color;\n    return blocks;\n}\n\nvoid dfs_disappear(Field& f, int x, int y, char color) {\n    f[y][x] = '.';\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (f[sy][sx] == 'O') {\n                f[sy][sx] = '.';\n            }\n            if (f[sy][sx] == color) {\n                dfs_disappear(f, sx, sy, color);\n            }\n        }\n    }\n}\n\nbool disappear(Field& f) {\n    bool update = false;\n    REP(y, 12) {\n        REP(x, 6) {\n            if (f[y][x] == '.') continue;\n            if (f[y][x] == 'O') continue;\n            int blocks = dfs_count(f, x, y, f[y][x]);\n            if (blocks >= 4) {\n                dfs_disappear(f, x, y, f[y][x]);\n                update = true;\n            }\n        }\n    }\n//    LOG(\"======\\n\");\n//    REP(y, H) {\n//        REP(x, W) {\n//            LOG(\"%c\", f[y][x]);\n//        }\n//        LOG(\"\\n\");\n//    }\n    // fall down\n    REP(x, 6) {\n        REDO:\n        int bottom = -1;\n        for (int y = 11; y >= 0; y--) {\n            if (bottom == -1 && f[y][x] == '.') {\n                bottom = y;\n            } else if (bottom != -1 && f[y][x] != '.') {\n                swap(f[bottom][x], f[y][x]);\n                goto REDO;\n            }\n        }\n    }\n    return update;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i, n) {\n        Field f(H, vector<char>(W));\n        REP(y, H) REP(x, W) cin >> f[y][x];\n        int chain = 0;\n        while (disappear(f)) {\n            chain++;\n//            LOG(\"------\\n\");\n//            REP(y, H) {\n//                REP(x, W) {\n//                    LOG(\"%c\", f[y][x]);\n//                }\n//                LOG(\"\\n\");\n//            }\n        }\n        cout << chain << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint main()\n{\n  int T;\n  while (cin >> T) {\n    for (int t = 0; t < T; ++t) {\n      vector<string> puyo(12);\n      for (int i = 0; i < 12; ++i)\n\tcin >> puyo[i];\n\n      int ans = 0;\n      for ( ; ; ) {\n\tbool update = false;\n\tvector<vector<int> > visited(puyo.size(), vector<int>(puyo[0].size(), 0));\n\tfor (unsigned int i = 0; i < puyo.size(); ++i) {\n\t  for (unsigned int j = 0; j < puyo[0].size(); ++j) {\n\t    if (puyo[i][j] != '.' && puyo[i][j] != 'O' && !visited[i][j]) {\n\t      int cnt = 0;\n\t      queue<pair<int, int> > que;\n\t      que.push(pair<int, int>(i, j));\n\t      while (!que.empty()) {\n\t\tconst pair<int, int> p = que.front();\n\t\tque.pop();\n\n\t\t++cnt;\n\t\tvisited[p.first][p.second] = 1;\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t  int ii = p.first + dy[d];\n\t\t  int jj = p.second + dx[d];\n\t\t  if (ii < 0 || ii >= puyo.size() || jj < 0 || jj >= puyo[0].size() || puyo[ii][jj] != puyo[i][j] || visited[ii][jj])\n\t\t      continue;\n\t\t  que.push(pair<int, int>(ii, jj));\n\t\t}\n\t      }\n\t      if (cnt >= 4) {\n\t\tupdate = true;\n\t\tchar color = puyo[i][j];\n\t\tque.push(pair<int, int>(i, j));\n\t\tvector<vector<int> > deleted(puyo.size(), vector<int>(puyo[0].size(), 0));\n\t\twhile (!que.empty()) {\n\t\t  const pair<int, int> p = que.front();\n\t\t  que.pop();\n\n\t\t  puyo[p.first][p.second] = '.';\n\t\t  deleted[p.first][p.second] = 1;\n\t\t  for (int d = 0; d < 4; ++d) {\n\t\t    int ii = p.first + dy[d];\n\t\t    int jj = p.second + dx[d];\n\t\t    if (ii < 0 || ii >= puyo.size() || jj < 0 || jj >= puyo[0].size() || deleted[ii][jj])\n\t\t      continue;\n\t\t    \n\t\t    if (puyo[ii][jj] == color) {\n\t\t      que.push(pair<int, int>(ii, jj));\n\t\t    } else if (puyo[ii][jj] == 'O')\n\t\t      puyo[ii][jj] = '.';\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\n\tif (!update)\n\t  break;\n\n\t++ans;\n\tfor (int i = puyo.size()-1; i >= 0; --i) {\n\t  for (unsigned int j = 0; j < puyo[0].size(); ++j) {\n\t    if (puyo[i][j] != '.') {\n\t      int ii = i + 1;\n\t      while (ii < puyo.size() && puyo[ii][j] == '.')\n\t\t++ii;\n\t      swap(puyo[i][j], puyo[ii-1][j]);\n\t    }\n\t  }\n\t}\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n \nusing namespace std;\n \nchar field[12][6],tmp[12][6];\nbool visited[12][6];\nint Bcnt;\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n \nbool inField(int y,int x){\n    return 0 <= y && y < 12 && 0 <= x && x < 6;\n}\n \nvoid CountBlock(int y,int x,char B){\n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i], ny = y + dy[i];\n\tif(!inField(ny,nx)) continue;\n\tif(visited[ny][nx]) continue;\n\tif(field[ny][nx] == B){\n\t    visited[ny][nx] = true;\n\t    Bcnt++;\n\t    CountBlock(ny,nx,B);\n\t}\n    }\n}\n \nvoid remove(int y,int x,char B){\n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i], ny = y + dy[i];\n\tif(!inField(ny,nx)) continue;\n\tif(field[ny][nx] == B){\n\t    field[ny][nx] = '.';\n\t    remove(ny,nx,B);\n\t}else if(field[ny][nx] == 'O'){\n\t    field[ny][nx] = '.';\n\t}\n    }\n}\n \nvoid FallBlock(){\n    for(int i = 0 ; i < 12 ; i++){\n\tfor(int j = 0 ; j < 6 ; j++){\n\t    tmp[i][j] = '.';\n\t}\n    }\n \n    for(int j = 0 ; j < 6 ; j++){\n\tint p = 11;\n\tfor(int i = 11 ; i >= 0 ; i--){\n\t    if(field[i][j] == '.') continue;\n\t    tmp[p--][j] = field[i][j];\n\t}\n    }\n \n    for(int i = 0 ; i < 12 ; i++){\n\tfor(int j = 0 ; j < 6 ; j++){\n\t    field[i][j] = tmp[i][j];\n\t}\n    }\n}\n \nint main(){\n    int Tc;\n \n    cin >> Tc;\n    while(Tc--){\n\tfor(int i = 0 ; i < 12 ; i++){\n\t    for(int j = 0 ; j < 6 ; j++){\n\t\tcin >> field[i][j];\n\t    }\n\t}\n \n\tint cnt = 0;\n\twhile(true){\n\t    bool flg = false;\n\t    memset(visited,false,sizeof(visited));\n\t    for(int i = 0 ; i < 12 ; i++){\n\t\tfor(int j = 0 ; j < 6 ; j++){\n\t\t    if(field[i][j] == '.' || field[i][j] == 'O') continue;\n\t\t    if(visited[i][j]) continue;\n\t\t    visited[i][j] = true;\n\t\t    Bcnt = 1; CountBlock(i,j,field[i][j]);\n\t\t    if(Bcnt >= 4){\n\t\t\tflg = true;\n\t\t\tremove(i,j,field[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t    if(!flg) break;\n\t    cnt++; FallBlock();\n\t}\n\tcout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nchar board[12][6];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid print() {\n  int i,j;\n  rep(i,12) {\n    rep(j,6)\n      cout<<board[i][j];\n    cout<<endl;\n  }\n}\n\nbool isok(int x,int y) {\n  return (x >= 0 && x < 6 && y >= 0 && y < 12);\n}\n\nbool erase() {\n  bool isb[12][6];\n  int i,j,k,l;\n  bool update = false;\n  memset(isb, false, sizeof(isb));\n  rep(i,12) {\n    rep(j,6) {\n      if(isb[i][j]) continue;\n      isb[i][j] = true;\n      if(board[i][j] == '.' || board[i][j] == 'O') continue;\n\n      queue<pair<int,int> > Q;\n      vector<pair<int,int> > vv;\n      Q.push(make_pair(i,j)); vv.push_back(make_pair(i,j));\n      while(!Q.empty()) {\n\tpair<int,int> p = Q.front(); Q.pop();\n\tint x = p.second,y = p.first;\n\trep(k,4) {\n\t  if(isok(x+dx[k],y+dy[k]))\n\t    if(board[y+dy[k]][x+dx[k]] == board[y][x] && !isb[y+dy[k]][x+dx[k]]) {\n\t      Q.push(make_pair(y+dy[k],x+dx[k]));\n\t      isb[y+dy[k]][x+dx[k]] = true;\n\t      vv.push_back(make_pair(y+dy[k],x+dx[k]));\n\t    }\n\t}\n      }\n\n      if(vv.size() >= 4) {\n\tupdate = true;\n\trep(k,vv.size()) {\n\t  int x = vv[k].second,y = vv[k].first;\n\t  rep(l,4) {\n\t    if(isok(x+dx[l],y+dy[l]))\n\t      if(board[y+dy[l]][x+dx[l]] == 'O')\n\t\tboard[y+dy[l]][x+dx[l]] = '.';\n\t  }\n\t  board[vv[k].first][vv[k].second] = '.';\n\t}\n      }\n    }\n  }\n\n  return update;\n}\n\nvoid drop() {\n  int i,j,k;\n  for(i=11; i>=0; --i) {\n    rep(j,6) {\n      if(board[i][j] == '.') {\n\tk = i;\n\twhile(k >= 0) {\n\t  if(!(board[k][j] == '.')) {\n\t    board[i][j] = board[k][j];\n\t    board[k][j] = '.';\n\t    break;\n\t  }\n\t  k--;\n\t}\n      }\n    }\n  }\n}\n\nint solve() {\n  bool update = false;\n  int t = 0;\n  while(true) {\n    update = erase();\n    if(!update) return t;\n    t++;\n    drop();\n  }\n}\n\nvoid input() {\n  int i,j;\n  string s;\n  rep(i,12) {\n    cin>>s;\n    rep(j,6)\n      board[i][j] = s.at(j);\n  }\n  return;\n}\n\nint main() {\n  int t;\n  cin>>t;\n  while(t--) {\n    memset(board,0,sizeof(board));\n    input();\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int W = 6;\nconst int H = 12;\nconst int HW = H * W;\n\nconst int DEL = 4;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, 1, 0, -1};\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef queue<pii> qpii;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\nchar flds[H][W];\nbool used[H][W];\n\n/* subroutines */\n\nbool del_blocks() {\n  bool deleted = false;\n  memset(used, false, sizeof(used));\n\n  for (int y0 = 0; y0 < H; y0++)\n    for (int x0 = 0; x0 < W; x0++) {\n      if (used[y0][x0]) continue;\n      used[y0][x0] = true;\n\n      char ch = flds[y0][x0];\n      if (ch == '.' || ch == 'O') continue;\n\n      qpii q;\n      vpii blk, oblk;\n\n      pii st(x0, y0);\n      q.push(st);\n      blk.push_back(st);\n\n      while (! q.empty()) {\n\tpii u = q.front(); q.pop();\n\tint& ux = u.first;\n\tint& uy = u.second;\n\n\tfor (int di = 0; di < 4; di++) {\n\t  int vx = ux + dxs[di], vy = uy + dys[di];\n\t  if (vx >= 0 && vx < W && vy >= 0 && vy < H) {\n\t    if (! used[vy][vx] && flds[vy][vx] == ch) {\n\t      used[vy][vx] = true;\n\t      pii v(vx, vy);\n\t      q.push(v);\n\t      blk.push_back(v);\n\t    }\n\t    else if (flds[vy][vx] == 'O') {\n\t      used[vy][vx] = true;\n\t      oblk.push_back(pii(vx, vy));\n\t    }\n\t  }\n\t}\n      }\n\n      if (blk.size() >= DEL) {\n\tdeleted = true;\n\tfor (vpii::iterator vit = blk.begin(); vit != blk.end(); vit++)\n\t  flds[vit->second][vit->first] = '.';\n\tfor (vpii::iterator vit = oblk.begin(); vit != oblk.end(); vit++)\n\t  flds[vit->second][vit->first] = '.';\n      }\n    }\n\n  return deleted;\n}\n\nvoid drop() {\n  for (int x = 0; x < W; x++) {\n    int y0, y1;\n    for (y0 = 0, y1 = 0; y0 < H; y0++)\n      if (flds[y0][x] != '.') flds[y1++][x] = flds[y0][x];\n    for (; y1 < H; y1++) flds[y1][x] = '.';\n  }\n}\n\nvoid print_fields() {\n  for (int y = H - 1; y >= 0; y--) {\n    for (int x = 0; x < W; x++) putchar(flds[y][x]);\n    putchar('\\n');\n  }\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  while (n--) {\n    for (int y = H - 1; y >= 0; y--) {\n      string line;\n      cin >> line;\n      for (int x = 0; x < W; x++) flds[y][x] = line[x];\n    }\n    //print_fields();\n\n    int seq = 0;\n\n    while (del_blocks()) {\n      seq++;\n      drop();\n      //print_fields();\n    }\n\n    cout << seq << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\n\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tint y = i+dy[k], x = j+dx[k];\n\t\tif(y >= 0 && y < 12 && x >= 0 && x < 6 \n\t\t\t&& area[y][x] == c && !used[y][x]){\n\t\t\tcounter += count(y, x, c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        for (int i = 0; i < vs.size(); i++) os << vs[i] << endl;\n        return os;\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {-1, 0, 1, 0};\n\n    const int H = 12;\n    const int W = 6;\n\n    vector<string> F;\n    void input() {\n        F.clear(); F.resize(12);\n        cin >> F;\n    }\n\n    bool step() {\n        bool del[H][W];\n        memset(del, 0, sizeof(del));\n\n        bool flag = false;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '.') continue;\n                if (F[i][j] == 'O') continue;\n                static bool used[H][W];\n                memset(used, 0, sizeof(used));\n                int count = 1;\n                queue< pair<int, int> > Q;\n                Q.push(make_pair(i, j));\n                used[i][j] = true;\n                while (not Q.empty()) { \n                    pair<int, int> c = Q.front(); Q.pop();\n                    int y = c.first;\n                    int x = c.second;\n                    for (int k = 0; k < 4; k++) {\n                        int ny = y + dy[k];\n                        int nx = x + dx[k];\n                        if (ny < 0 || ny >= H) continue;\n                        if (nx < 0 || nx >= W) continue;\n                        if (used[ny][nx]) continue;\n                        if (F[ny][nx] == F[i][j]) {\n                            used[ny][nx] = true;\n                            count++;\n                            Q.push(make_pair(ny, nx));\n                        } else if (F[ny][nx] == 'O') {\n                            used[ny][nx] = true;\n                        }\n                    }\n                }\n                if (count >= 4) {\n                    flag = true;\n                    for (int y = 0; y < H; y++) {\n                        for (int x = 0; x < W; x++) {\n                            if (used[y][x]) {\n                                del[y][x] = true;\n                                //cout << y << \",\" << x << endl;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        auto G = vector<string>(12, \"......\");\n        for (int j = 0; j < W; j++) {\n            string t;\n            for (int i = 0; i < H; i++) {\n                if (F[i][j] != '.' && (not del[i][j])) {\n                    t.push_back(F[i][j]);\n                }\n            }\n            reverse(t.begin(), t.end());\n            for (int i = 0; i < t.size(); i++) {\n                G[H - 1 - i][j] = t[i];\n            }\n        }\n        F = G;\n\n        return flag;\n    }\n\n    void solve() {\n        int c = 0;\n        while (step()) {\n            c++;\n        }\n        cout << c << endl;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int t = 0; t < T; t++) {\n        input(); solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nenum{AKI,RED,GREEN,BLUE,YELLOW,PURPLE,JAMA};\n\nint recmap[6][12];\nvector<int> map[6];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\ntypedef pair<int,int> P;\n\nint rec(int fillv,int x,int y,int col){\n     if( x<0 || x>5 || y<0 || y > 11) return 0;\n     if(recmap[x][y]>-1||map[x][y]!=col) return 0;\n     recmap[x][y]=fillv;\n     int sum=0;\n     for(int i=0;i<4;i++)sum+=rec(fillv,x+dx[i],y+dy[i],col);\n     ++sum;\n     return sum;\n}\nvoid recclear(){\n     for(int i=0;i<12;i++){\n\t  for(int j=0;j<6;j++){\n\t       recmap[j][i]=-1;\n\t  }\n     }\n}\n\nint main(){\n     int T;\n     cin>>T;\n     for(int time=0;time<T;time++){\n\t  for(int i=0;i<6;i++){\n\t       map[i].resize(12,0);\n\t  }\n\t  for(int i=11;i>-1;i--){\n\t       for(int j=0;j<6;j++){\n\t\t    char a;\n\t\t    cin>>a;\n\t\t    switch(a){\n\t\t    case 'R':\n\t\t\t map[j][i]=RED;\n\t\t\t break;\n\t\t    case 'G':\n\t\t\t map[j][i]=GREEN;\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t map[j][i]=BLUE;\n\t\t\t break;\n\t\t    case 'Y':\n\t\t\t map[j][i]=YELLOW;\n\t\t\t break;\n\t\t    case 'P':\n\t\t\t map[j][i]=PURPLE;\n\t\t\t break;\n\t\t    case 'O':\n\t\t\t map[j][i]=JAMA;\n\t\t\t break;\n\t\t    case '.':\n\t\t\t map[j][i]=AKI;\n\t\t    }\n\t       }\n\t  }\n\t  int count=0;\n\t  while(1){\n\t       vector<int> dels;\n\t       recclear();\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(map[i][j]==AKI||map[i][j]==JAMA)continue;\n\t\t\t if(rec(i+j*6,i,j,map[i][j])>3){\n\t\t\t      dels.push_back(i+j*6);\n\t\t\t }\n\t\t    }\n\t       }\n\t       if(dels.empty())break;\n\t       count++;\n\t       bool isdel[6][12]={};\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t for(int k=0;k<dels.size();k++){\n\t\t\t      if(recmap[i][j]==dels[k])isdel[i][j]=true;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(map[i][j]==JAMA){\n\t\t\t      bool flag=true;\n\t\t\t      for(int k=0;k<4;k++){\n\t\t\t\t   if(i+dx[k]<0||i+dx[k]>5||j+dy[k]<0||j+dy[k]>11)continue;\n\t\t\t\t   if(!isdel[i+dx[k]][j+dy[k]]){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t   }\n\t\t\t      }\n\t\t\t      if(flag)isdel[i][j]=true;\n\t\t\t }\n\t\t    }\n\t       }\n\t       //vector<P> deletelist;\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(isdel[i][j]){\n\t\t\t      map[i][j]=AKI;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    vector<int>::iterator endit=remove(map[i].begin(),map[i].end(),0);\n\t\t    map[i].resize(12,0);\n\t\t    fill(endit,map[i].end(),0);\n\t       }\n\t       /*for(int i=0;i<6;i++){\n\t\t    vector<int>::iterator itr=map[i].begin();\n\t\t    while(itr!=map[i].end()){\n\t\t\t cout<<*itr;\n\t\t\t itr++;\n\t\t    }\n\t\t    cout<<endl;\n\t       }\n\t       cout<<endl;*/\n\t  }\n\t  cout<<count<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\ntypedef pair<int,int> P;\nint n,used[12][6],cnt;\nchar mas[13][6];\nbool is_color(char s){\n  return (s != '.' && s != 'O');\n}\nbool no_over(int i,int j){\n  if(i < 0 || i >= 12 || j < 0 || j >= 6) return false;\n  return true;\n}\nvoid ELASE(){\n  for(int i=0;i<12;i++){\n    for(int j=0;j<6;j++){\n      if(used[i][j]){\n        mas[i][j] = '.';\n        for(int k=0;k<4;k++){\n          int nx = i + dx[k] , ny = j + dy[k];\n          if(mas[nx][ny] == 'O') mas[nx][ny] = '.';\n        }\n      }\n    }\n  }\n}\nint search(int x,int y,char m){\n  if(used[x][y]) return 0;\n  used[x][y] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i] , ny = y + dy[i];\n    if(no_over(nx,ny)){\n      if(mas[nx][ny] == m){\n        search(nx,ny,m);\n      }\n    }\n  }\n}\nvoid Down(){\n  for(int k=0;k<72;k++){\n    for(int i=0;i<12;i++){\n      for(int j=0;j<6;j++){\n        if(mas[i+1][j] == '.'){\n          swap(mas[i][j],mas[i+1][j]);\n        }\n      }\n    }\n  }\n}\nint solve(){\n  int rec; bool flg;\n  for(rec = -1 , flg = false ; !flg ; rec++){\n    flg = true;\n    Down();\n    for(int i=0;i<12;i++){\n      for(int j=0;j<6;j++){\n        if(is_color(mas[i][j])){\n          cnt = 0;\n          memset(used,false,sizeof(used));\n          search(i,j,mas[i][j]);\n          if(cnt >= 4){\n            flg = false;\n            ELASE();\n          }\n        }\n      }\n    }\n  }\n  return rec;\n}\nint main(){\n  cin >> n;\n  while(n--){\n    for(int i=0;i<12;i++){\n      for(int j=0;j<6;j++){\n        cin >> mas[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nchar data[12][6];\nbool vis[12][6];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nvoid drop(){\n  for(int j=0;j<6;j++){\n    int h = 11;\n    for(int i=11;i>=0;i--){\n      if(data[i][j] != '.'){\n        data[h][j] = data[i][j];\n        if(h != i) data[i][j] = '.';\n        h--;\n      }\n    }\n  }\n}\n\nint calcCount(int y, int x, char col){\n  int res = 1;\n  vis[y][x] = true;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny<0 || ny>=12) continue;\n    if(nx<0 || nx>=6) continue;\n    if(vis[ny][nx]) continue;\n    if(data[ny][nx] != col) continue;\n    res += calcCount(ny, nx, col);\n  }\n  return res;\n}\n\nvoid remove(int y, int x, char col){\n  data[y][x] = '.';\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny<0 || ny>=12) continue;\n    if(nx<0 || nx>=6) continue;\n    if(data[ny][nx] == 'O') data[ny][nx] = '.';\n    if(data[ny][nx] != col) continue;\n    remove(ny, nx, col);\n  }\n}\n\nbool clear(){\n  bool res = false;\n  fill(vis[0], vis[12], false);\n  for(int i=0;i<12;i++){\n    for(int j=0;j<6;j++){\n      if(data[i][j] != '.' && !vis[i][j] && data[i][j] != 'O'){\n        int cnt = calcCount(i, j, data[i][j]);\n        if(cnt >= 4){\n          remove(i, j, data[i][j]);\n          res = true;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(){\n  int res = 0;\n  while(clear()){\n    drop();\n    res++;\n  }\n  return res;\n}\n\nmain(){\n  int T;\n  cin >> T;\n  while(T--){\n    for(int i=0;i<12;i++){\n      for(int j=0;j<6;j++){\n        cin >> data[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// UTPC2010 C. RpC\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nchar dx[] = {-1, 0, 1, 0};\nchar dy[] = {0, -1, 0, 1};\n\nint main(){\n\tstring s[12];\n\tbool visit[12][6], erase[12][6];\n        int T; cin >> T;\n\twhile(T--){\n\t\tfor(int i=0;i<12;i++) cin >> s[i];\n\t\tint ans = 0;\n\t\twhile(true){\n\t\t\tmemset(visit, false, sizeof(visit));\n\t\t\tmemset(erase, false, sizeof(erase));\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(!visit[i][j]&&s[i][j]!='.'&&s[i][j]!='O'){\n\t\t\t\t\t\tqueue< pair<int, int> > qu; qu.push(make_pair(i,j));\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\twhile(!qu.empty()){\n\t\t\t\t\t\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\t\t\t\t\t\tif(erase[p.first][p.second]) continue;\n\t\t\t\t\t\t\terase[p.first][p.second] = true;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\t\t\t\t\t\tif(nx < 0 || 12 <= nx || ny < 0 || 6 <= ny || s[p.first][p.second]!=s[nx][ny]) continue;\n\t\t\t\t\t\t\t\tqu.push(make_pair(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt >= 4) memcpy(visit, erase, sizeof(visit));\n\t\t\t\t\t\tmemcpy(erase, visit, sizeof(erase));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(s[i][j]!='O') continue;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\t\tif(nx < 0 || 12 <= nx || ny < 0 || 6 <= ny || !erase[nx][ny]) continue;\n\t\t\t\t\t\terase[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool next = false;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(erase[i][j]){\n\t\t\t\t\t\tnext = true;\n\t\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tvector<char> vc;\n\t\t\t\tfor(int j=11;j>=0;j--){\n\t\t\t\t\tif(s[j][i]!='.') vc.push_back(s[j][i]);\n\t\t\t\t\ts[j][i] = '.';\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<vc.size();j++)\n\t\t\t\t\ts[11-j][i] = vc[j];\n\t\t\t}\n\t\t\tif(next) ans++;\n\t\t\telse     break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                scanf(\" %c\", &f[i][j]);\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        int upmost = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=11;i>=upmost;i--){\n                bool linecheck = true;\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.') linecheck = false;\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n                if(linecheck){\n                    upmost = i-1;\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(max_deleted == 0) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, -1, 1};\nint dx[] = {1, -1, 0, 0};\n\nvector<string> s(12);\nvector<bitset<6> > check;\n\nint countBlock(int y, int x)\n{\n    check[y][x] = true;\n\n    int ret = 1;\n    for(int i=0; i<4; ++i){\n        int y1 = y + dy[i];\n        int x1 = x + dx[i];\n        if(y1 < 0 || y1 >= 12 || x1 < 0 || x1 >= 6)\n            continue;\n        if(!check[y1][x1] && s[y][x] == s[y1][x1])\n            ret += countBlock(y1, x1);\n    }\n\n    return ret;\n}\n\nvoid eraseBlock(int y, int x)\n{\n    int color = s[y][x];\n    s[y][x] = '.';\n\n    for(int i=0; i<4; ++i){\n        int y1 = y + dy[i];\n        int x1 = x + dx[i];\n        if(y1 < 0 || y1 >= 12 || x1 < 0 || x1 >= 6)\n            continue;\n        if(s[y1][x1] == color)\n            eraseBlock(y1, x1);\n        if(s[y1][x1] == 'O')\n            s[y1][x1] = '.';\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        for(int i=0; i<12; ++i)\n            cin >> s[i];\n\n        int ret = 0;\n        for(;;){\n            bool change = false;\n            check.assign(12, 0);\n            for(int i=0; i<12; ++i){\n                for(int j=0; j<6; ++j){\n                    if(s[i][j] == 'O' || s[i][j] == '.')\n                        continue;\n                    if(countBlock(i, j) >= 4){\n                        eraseBlock(i, j);\n                        change = true;\n                    }\n                }\n            }\n            if(!change)\n                break;\n\n            vector<string> next(12, string(6, '.'));\n            for(int i=0; i<6; ++i){\n                int k = 11;\n                for(int j=11; j>=0; --j){\n                    if(s[j][i] != '.'){\n                        next[k][i] = s[j][i];\n                        -- k;\n                    }\n                }\n            }\n            s.swap(next);\n\n            ++ ret;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar g[12][6];\nbool ps[12][6];\nbool c[12][6];\n\nvoid cr(int y,int x,char p){\n  if(!c[y][x]&&g[y][x]==p){\n    c[y][x]=true;\n    for(int i=0;i<4;i++){\n      int dx[]={1,0,-1,0};\n      int dy[]={0,1,0,-1};\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(0<=nx&&nx<6&&0<=ny&&ny<12){\n\tcr(ny,nx,p);\n      }\n    }\n  }\n}\n\nint cn(int y,int x,char p){\n  if(p=='O'||p=='.'||p!=g[y][x]||ps[y][x]){\n    return 0;\n  }else{\n    ps[y][x]=true;\n    int c=0;\n    for(int i=0;i<4;i++){\n      int dx[]={1,0,-1,0};\n      int dy[]={0,1,0,-1};\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(0<=nx&&nx<6&&0<=ny&&ny<12){\n\tc+=cn(ny,nx,p);\n      }\n    }\n    return c+1;\n  }\n}\n\nint main(){\n  int t;\n  cin>>t;\n  while(t--){\n    for(int y=0;y<12;y++){\n      cin>>g[y];\n    }\n    for(int i=0;;i++){\n      fill(ps[0],ps[12],false);\n      fill(c[0],c[12],false);\n      bool co=false;\n      for(int y=0;y<12;y++){\n\tfor(int x=0;x<6;x++){\n\t  if(cn(y,x,g[y][x])>=4){\n\t    cr(y,x,g[y][x]);\n\t    co=true;\n\t  }\n\t}\n      }\n      if(!co){\n\tcout<<i<<endl;\n\tbreak;\n      }\n      for(int y=0;y<12;y++){\n\tfor(int x=0;x<6;x++){\n\t  if(c[y][x]){\n\t    g[y][x]='.';\n\t    for(int i=0;i<4;i++){\n\t      int dx[]={0,1,0,-1};\n\t      int dy[]={1,0,-1,0};\n\t      int nx=x+dx[i];\n\t      int ny=y+dy[i];\n\t      if(g[ny][nx]=='O'){\n\t\tg[ny][nx]='.';\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      for(int j=0;j<11;j++){\n\tfor(int y=0;y<11;y++){\n\t  for(int x=0;x<6;x++){\n\t    if(g[y][x]!='.'&&g[y+1][x]=='.'){\n\t      swap(g[y][x],g[y+1][x]);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar fie[20][20];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool chp(int x,int y){\n  if( x < 0 || y < 0 || x >= 6 || y>= 12 ) return false;\n  return true;\n}\n\nvoid fall(){\n  bool lp = true;\n  while( lp ){\n    lp = false;\n    for(int y=0;y<11;y++){\n      for(int x=0;x<6;x++){\n        if( fie[x][y] == '.' && fie[x][y+1] != '.'){\n          swap(fie[x][y], fie[x][y+1]);      \n          lp = true;\n        }\n      }\n    }\n  }\n\n}\n\nint check(int x,int y,char c){\n  if( fie[x][y] != c ) return 0;\n  int cnt = 1;\n  char tmp = fie[x][y];\n  fie[x][y] = 'x';\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !chp(nx,ny) ) continue;\n    cnt += check( nx, ny, c );\n  }\n  fie[x][y] = tmp;\n  return cnt;\n}\n\nvoid ume(int x,int y,char c){\n  if( fie[x][y] != c ) return;\n  fie[x][y] = 'x';\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !chp(nx,ny) ) continue;\n    ume( nx, ny, c );\n  }\n}\n\nbool del(){\n  bool f = false;\n  for(int y=0;y<12;y++){\n    for(int x=0;x<6;x++){\n      if( fie[x][y] != 'O' &&\n          fie[x][y] != '.' &&\n          fie[x][y] != 'x' ) {\n        if( check( x,y,fie[x][y] ) >= 4 ){\n          ume( x, y, fie[x][y] ); \n          f = true;\n        } \n      }\n    }\n  }\n  return f;\n}\n\nvoid ozm(){\n  for(int y=0;y<12;y++){\n    for(int x=0;x<6;x++){\n      for(int i=0;i<4;i++){\n        if( fie[x][y] == 'O' ){\n          int nx = x+dx[i], ny = y + dy[i];\n          if( chp(nx,ny) ){\n            if( fie[nx][ny] ==  'x' ) \n              fie[x][y] = '.';            \n          }\n        }\n      }\n    }\n  }\n  for(int y=0;y<12;y++)\n    for(int x=0;x<6;x++)\n      if( fie[x][y] == 'x' ) fie[x][y] = '.';\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while( T-- ){\n\n    for(int i=0;i<12;i++){\n      for(int j=0;j<6;j++) cin >> fie[j][11-i];\n    }\n    int res = 0;\n    fall();\n    while( del() ){\n      res++;\n      ozm();\n      fall();\n    }\n    cout << res << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint field[12][6];\nbool visit[12][6];\nbool erase[12][6];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nvoid fall() {\n  REP(iter, 12) {\n    for (int y = 11; y > 0; y--) {\n      REP(x, 6) {\n        if (field[y][x] == -1) {\n          field[y][x] = field[y - 1][x];\n          field[y - 1][x] = -1;\n        }\n      }\n    }\n  }\n}\n\nint dfs1(int y, int x, int color) {\n  if (visit[y][x] || field[y][x] != color) { return 0; }\n  visit[y][x] = true;\n  int ret = 1;\n  REP(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (nx < 0 || nx >= 6 || ny < 0 || ny >= 12) { continue; }\n    ret += dfs1(ny, nx, color);\n  }\n  return ret;\n}\n\nvoid dfs2(int y, int x, int color) {\n  if (erase[y][x]) { return; }\n  if (field[y][x] == 5 || field[y][x] == color) {\n    erase[y][x] = true;\n  }\n  if (field[y][x] != color) { return; }\n  REP(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (nx < 0 || nx >= 6 || ny < 0 || ny >= 12) { continue; }\n    dfs2(ny, nx, color);\n  }\n}\n\nint main() {\n  int mapto[300];\n  mapto[(int)'R'] = 0;\n  mapto[(int)'G'] = 1;\n  mapto[(int)'B'] = 2;\n  mapto[(int)'Y'] = 3;\n  mapto[(int)'P'] = 4;\n  mapto[(int)'O'] = 5;\n  mapto[(int)'.'] = -1;\nint test;\nscanf(\"%d\", &test);\nwhile (test--) {\n  REP(y, 12) {\n    REP(x, 6) {\n      char c;\n      scanf(\" %c \", &c);\n      field[y][x] = mapto[(int)c];\n    }\n  }\n  int chain;\n  for (chain = 0;; chain++) {\n    bool end = true;\n    MEMSET(visit, false);\n    MEMSET(erase, false);\n    REP(y, 12) {\n      REP(x, 6) {\n        if (field[y][x] != -1 && field[y][x] != 5) {\n          if (dfs1(y, x, field[y][x]) >= 4) {\n            dfs2(y, x, field[y][x]);\n          }\n        }\n      }\n    }\n    REP(y, 12) {\n      REP(x, 6) {\n        if (erase[y][x]) {\n          field[y][x] = -1;\n          end = false;\n        }\n      }\n    }\n    fall();\n    if (end) { break; }\n  }\n  printf(\"%d\\n\", chain);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nchar field[12][6],tmp[12][6];\nbool visited[12][6];\nint Bcnt;\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n\nbool inField(int y,int x){\n  return 0 <= y && y < 12 && 0 <= x && x < 6;\n}\n\nvoid CountBlock(int y,int x,char B){\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!inField(ny,nx)) continue;\n    if(visited[ny][nx]) continue;\n    if(field[ny][nx] == B){\n      visited[ny][nx] = true;\n      Bcnt++;\n      CountBlock(ny,nx,B);\n    }\n  }\n}\n\nvoid remove(int y,int x,char B){\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!inField(ny,nx)) continue;\n    if(field[ny][nx] == B){\n      field[ny][nx] = '.';\n      remove(ny,nx,B);\n    }else if(field[ny][nx] == 'O'){\n      field[ny][nx] = '.';\n    }\n  }\n}\n\nvoid FallBlock(){\n  for(int i = 0 ; i < 12 ; i++){\n    for(int j = 0 ; j < 6 ; j++){\n      tmp[i][j] = '.';\n    }\n  }\n\n  for(int j = 0 ; j < 6 ; j++){\n    int p = 11;\n    for(int i = 11 ; i >= 0 ; i--){\n      if(field[i][j] == '.') continue;\n      tmp[p--][j] = field[i][j];\n    }\n  }\n\n  for(int i = 0 ; i < 12 ; i++){\n    for(int j = 0 ; j < 6 ; j++){\n      field[i][j] = tmp[i][j];\n    }\n  }\n}\n\nint main(){\n  int Tc;\n\n  cin >> Tc;\n  while(Tc--){\n    for(int i = 0 ; i < 12 ; i++){\n      for(int j = 0 ; j < 6 ; j++){\n        cin >> field[i][j];\n      }\n    }\n\n    int cnt = 0;\n    while(true){\n      bool flg = false;\n      memset(visited,false,sizeof(visited));\n      for(int i = 0 ; i < 12 ; i++){\n        for(int j = 0 ; j < 6 ; j++){\n          if(field[i][j] == '.' || field[i][j] == 'O') continue;\n          if(visited[i][j]) continue;\n          visited[i][j] = true;\n          Bcnt = 1; CountBlock(i,j,field[i][j]);\n          if(Bcnt >= 4){\n            flg = true;\n            remove(i,j,field[i][j]);\n          }\n        }\n      }\n      if(!flg) break;\n      cnt++; FallBlock();\n    }\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nchar p[12][7];\nint f[12][6];\nchar memo;\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint dfs(int y, int x, int c){\n  //  fprintf(stderr, \"%d %d %d\\n\", y, x, c);\n  int ret = c;\n  bool flag = 0;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= 12 || nx >= 6 || f[ny][nx]) continue;\n    if(p[ny][nx] == memo){\n      flag = 1;\n      f[ny][nx] = 1;\n      //    fprintf(stderr, \"%d %d %d\\n\", ny, nx, 1);\n      ret += dfs(ny, nx, 1);\n    }else if(p[ny][nx] == 'O'){\n      f[ny][nx] = 1;\n    }\n  }\n  //  printf(\"%d %d %d\\n\", y, x, ret);\n  return ret;\n}\n\nvoid ojama(){\n  rep(i, 12) rep(j, 7){\n    if(p[i][j] != 'O') continue;\n    //    printf(\"%d %d\\n\", i, j);\n    rep(d, 4){\n      int ny = i + dy[d], nx = j + dx[d];\n      if(ny < 0 || nx < 0 || ny >= 12 || nx >= 6 || !f[ny][nx]) continue;\n      f[i][j] = 1;\n      break;\n    }\n  }\n  return;\n}\n\nvoid del(){\n  rep(i, 12) rep(j, 6){\n    if(!f[i][j]) continue;\n    p[i][j] = '.';\n  }\n  return;\n}\n\nvoid next(){\n  /*  rep(i, 12){\n    rep(j, 6) printf(\"%d \", f[i][j]); puts(\"\");\n    }*/\n\n  for(int i = 11; i >= 0; i--) rep(j, 6){\n      if(p[i][j] != '.') continue;\n      for(int k = i; k >= 0; k--){\n\tif(p[k][j] == '.') continue;\n\tp[i][j] = p[k][j];\n\tp[k][j] = '.';\n\tbreak;\n      }\n    }\n\n  /*  rep(i, 12){\n    puts(p[i]);\n    }*/\n  return;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  while(n--){\n    //    puts(\"in\");\n    rep(i, 12){\n      scanf(\"%s\", p[i]);\n    }\n\n    int res = 0;\n    while(true){\n      //      fprintf(stderr, \"%d\\n\", res);\n      int judge = 0;\n\n      rep(i, 12) rep(j, 6){\n\tmemset(f, 0, sizeof(f));\n\t//\tfprintf(stderr, \"%d %d\\n\", i, j);\n\tif(p[i][j] == '.' || p[i][j] == 'O'|| f[i][j]) continue;\n\t//\tfprintf(stderr, \"%d %d\\n\", i, j);\n\tmemo = p[i][j];\n\tf[i][j] = 1;\n\tif(dfs(i, j, 1) >= 4){\n\t  //\t  printf(\"%d %d\\n\", i, j);\n\t  judge = 1;\n\t  /*\t  rep(i, 12){\n\t    rep(j, 6) printf(\"%d \", f[i][j]); puts(\"\");\n\t    }*/\n\t  del();\n\t//\tfprintf(stderr, \"%d\\n\", judge);\n\t}\n      }\n      //     printf(\"%d\\n\", judge);\n      if(!judge) break;\n      //      ojama();\n      //      fprintf(stderr, \"ojama\\n\");\n      //      del();\n      //      fprintf(stderr, \"del\\n\");\n      next();\n      //      fprintf(stderr, \"next\\n\");\n      res++;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint di[] = {1,-1,0,0};\nint dj[] = {0,0,1,-1};\nchar t[12][7];\n\nvoid printMap(void){\n\trep(i,12){cout<<t[i]<<endl;}\n}\n\nvoid fallPuyo(void){\n\tfor(int i=10;i>=0;i--){\n\t\trep(j,6){\n\t\t\tif(t[i][j] != '.'){\n\t\t\t\tint k;\n\t\t\t\tfor(k=i+1;k<12 && t[k][j]=='.';k++);\n\t\t\t\tk--;\n\t\t\t\tif(t[k][j] == '.'){\n\t\t\t\t\tt[k][j] = t[i][j];\n\t\t\t\t\tt[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid deletePuyo(int ti,int tj,char c){\n\tt[ti][tj] = '.';\n\trep(i,4){\n\t\tint ni = ti + di[i];\n\t\tint nj = tj + dj[i];\n\n\t\tif(ni>=0 && ni<12 && nj>=0 && nj<6){\n\t\t\tif(t[ni][nj] == 'O') t[ni][nj] = '.';\n\t\t\telse if(t[ni][nj] == c) deletePuyo(ni,nj,c);\n\t\t}\n\t}\n}\n\nint countPuyo(int ti,int tj,char c){\n\tint res = 0;\n\n\tt[ti][tj] = '.';\n\trep(i,4){\n\t\tint ni = ti + di[i];\n\t\tint nj = tj + dj[i];\n\n\t\tif(ni>=0 && ni<12 && nj>=0 && nj<6 && t[ni][nj]==c) res += countPuyo(ni,nj,c);\n\t}\n\tt[ti][tj] = c;\n\n\treturn res + 1;\n}\n\nint main(void){\n\tint n;\n\tcin>>n;\n\n\twhile(n--){\n\t\trep(i,12)cin>>t[i];\n\n\t\tint rensa = 0;\n\t\tbool finishFlg = false;\n\n\t\twhile(!finishFlg){\n\t\t\tfinishFlg = true;\n\n\t\t\trep(i,12)rep(j,6){\n\t\t\t\tif(t[i][j] != 'O' && t[i][j] != '.'){\n\t\t\t\t\tif(countPuyo(i,j,t[i][j]) >= 4){\n\t\t\t\t\t\tdeletePuyo(i,j,t[i][j]);\n\t\t\t\t\t\tif(finishFlg){\n\t\t\t\t\t\t\tfinishFlg = false;\n\t\t\t\t\t\t\trensa++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallPuyo();\n\t\t}\n\n\t\tcout<<rensa<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<char> vec;\nchar tab[20][20];\nint ans,pre,dx[]={0,0,1,-1},dy[]={1,-1,0,0},pl,used[20][20];\nvoid are1(int y,int x,char c){\n\tpre++;\n\tused[y][x]=1;\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=dy[i]+y;nx=dx[i]+x;\n\t\tif(ny>=0&&ny<12&&nx>=0&&nx<6){\n\t\tif(tab[ny][nx]==c&&used[ny][nx]==0)\n\t\t\tare1(ny,nx,c);\n\t\t}\n\t}\n}\nvoid are2(int y,int x,char c){\n\tint ny,nx;\n\ttab[y][x]='.';\n\tfor(int i=0;i<4;i++){\n\t\tny=dy[i]+y;nx=dx[i]+x;\n\t\tif(ny>=0&&ny<12&&nx>=0&&nx<6){\n\t\t\tif(tab[ny][nx]==c)\n\t\t\t\tare2(ny,nx,c);\n\t\t\telse if(tab[ny][nx]=='O')\n\t\t\t\ttab[ny][nx]='.';\n\t\t}\n\t}\n}\nvoid rensa(){\n\tfor(int i=0;i<12;i++)\n\tfor(int j=0;j<6;j++)\n\tused[i][j]=0;\n\tfor(int i=0;i<12;i++)\n\tfor(int j=0;j<6;j++){\n\t\tif(tab[i][j]!='O'&&tab[i][j]!='.'){\n\t\t\tpre=0;\n\t\t\tare1(i,j,tab[i][j]);\n\t\t\tif(pre>=4){\n\t\t\t\tare2(i,j,tab[i][j]);\n\t\t\t\tpl++;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid liset(){\n\tint k;\n\tfor(int i=0;i<6;i++){\n\t\tk=0;\n\t\tfor(int j=11;j>=0;j--){\n\t\t\tif(tab[j][i]!='.')\n\t\t\tvec.push_back(tab[j][i]);\n\t\t}\n\t\tfor(int j=11;(int)11-j<(int)vec.size();j--)\n\t\t\ttab[j][i]=vec[k++];\n\t\tfor(int j=(int)11-vec.size();j>=0;j--)\n\t\t\ttab[j][i]='.';\n\t\tvec.clear();\n\t}\n}\nvoid solve(){\n\tdo{\n\t\tpl=0;\n\t\trensa();\n\t\tif(pl){\n\t\tliset();\n\t\tans++;\n\t\t}\n\t}while(pl);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n-->0){\n\t\tans=0;\n\t\tfor(int i=0;i<12;i++)\n\t\tcin>>tab[i];\n\t\tsolve();\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tif(i+dy[k] >= 0 && i+dy[k] < 12 && j+dx[k] >= 0 && j+dx[k] < 6 \n\t\t\t&& area[i+dy[k]][j+dx[k]] == c && !used[i+dy[k]][j+dx[k]]){\n\t\t\tcounter += count(i+dy[k], j+dx[k], c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tmemset(used, false, sizeof(used));\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint dx[]={0,1,0,-1,0};\nchar m[14][8];\nbool f[14][8];\nint F(int x,int y,char t)\n{\n\tif(m[y][x]-t||f[y][x])return 0;\n\tf[y][x]=1;\n\tint r=1,i;\n\tfor(i=0;i<4;++i)r+=F(x+dx[i],y+dx[i+1],t);\n\tf[y][x]=0;\n\treturn r;\n}\nvoid G(int x,int y,char t)\n{\n\tif(m[y][x]=='0')m[y][x]=0;\n\telse if(m[y][x]==t)\n\t{\n\t\tm[y][x]=0;\n\t\tfor(int i=0;i<4;++i)G(x+dx[i],y+dx[i+1],t);\n\t}\n}\nint H(int t)\n{\n\treturn t&&strchr(\"RGBYP\",t);\n}\nint main()\n{\n\tint i,j,s,x,n,c,d;\n\tfor(scanf(\"%d\",&n);n--;)\n\t{\n\t\tfor(i=0;i<12;++i)scanf(\"%s\",m[i+1]+1);\n\t\tfor(s=0;;)\n\t\t{\n\t\t\tx=0;\n\t\t\tfor(i=1;i<=12;++i)for(j=1;j<=6;++j)\n\t\t\t\tif(c=m[i][j], H(c)&&F(j,i,c)>3)\n\t\t\t\t\tG(j,i,c),++x;\n\t\t\tif(!x)break;\n\t\t\t++s;\n\t\t\tfor(j=1;j<=6;++j)\n\t\t\t{\n\t\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\t\tx=0;\n\t\t\t\t\tfor(i=11;i>0;--i)\n\t\t\t\t\t{\n\t\t\t\t\t\tc=m[i+1][j];\n\t\t\t\t\t\td=m[i][j];\n\t\t\t\t\t\tif(!H(c)&&H(d))m[i+1][j]=d,m[i][j]=0,++x;\n\t\t\t\t\t}\n\t\t\t\t\tif(!x)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nbool check1[14][8];\nint check2[14][8];\nint block[14][8];\nvoid GetBlock(){\n  memset(block,0,sizeof(block));\n  for(int i=1; i<=12; i++){\n    for(int j=1; j<=6; j++){\n      block[i][j] = getchar();\n    }\n    getchar();\n  }\n}\nvoid Makecheck2(int x, int y){\n  REP(k,4){\n    if(check2[x+dx[k]][y+dy[k]]==0&&\n        block[x][y]==block[x+dx[k]][y+dy[k]]){\n      check1[x+dx[k]][y+dy[k]] = true;\n      check2[x+dx[k]][y+dy[k]] = 1;\n      Makecheck2(x+dx[k], y+dy[k]);\n    }\n    if(check2[x+dx[k]][y+dy[k]]==0&&block[x+dx[k]][y+dy[k]]=='O')\n      check2[x+dx[k]][y+dy[k]] = 100;\n  }\n}\nint CheckNum(int x, int y){\n  int count = 0;\n  memset(check2,0,sizeof(check2));\n  check2[x][y] = 1;\n  Makecheck2(x,y);\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j]==1) count++;\n  return count;\n}\nvoid Break(){\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check2[i][j] == 1 || check2[i][j] == 100)\n        block[i][j] = '.';\n  memset(check2,0,sizeof(check2));\n}\n\nbool CheckIsR(){\n  bool flag2 = false;\n  FOR(i,1,13)\n    FOR(j,1,7)\n      if(check1[i][j]==false){\n        if(block[i][j]!='.'&&block[i][j]!='O'){\n          check1[i][j] = true;\n          if(CheckNum(i,j)>=4){\n            flag2 = true;\n            Break();\n          }\n        }else{\n          check1[i][j] = true;\n        }\n      }\n  return flag2;\n}\nbool Down(){\n  bool flag3;\n  do{\n    flag3 = false;\n    FOR(i,1,13)\n      FOR(j,1,7)\n        if(block[i][j] != '.' && block[i+1][j] == '.'){\n          swap(block[i][j],block[i+1][j]);\n          flag3 = true;\n        }\n  }while(flag3);\n  memset(check1,0,sizeof(check1));\n}\nvoid Out(){\n  FOR(i,1,13){\n    FOR(j,1,7)\n      printf(\"%c\",block[i][j]);\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\nint main(void){  \n  GetBlock();\n  int count=0;\n  while(true){\n    memset(check1,0,sizeof(check1));\n    if(CheckIsR()) count++;\n    else break;\n    Down();\n  }\n  cout << count << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 12\n#define W 6\nusing namespace std;\nbool del[H][W],used[H][W];\nstring s[H];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nvoid mark(){\n  int cnt=0;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(used[i][j])cnt++;\n  if(cnt<4)return;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(used[i][j])del[i][j]=true;\n}\n\nvoid mark2(){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++){\n      if(s[i][j]!='O')continue;\n      for(int k=0;k<4;k++){\n\tint ni=i+dy[k],nj=j+dx[k];\n\tif(ni<0||nj<0||H<=ni||W<=nj)continue;\n\tif(del[ni][nj])del[i][j]=true;\n      }\n    }\n}\n\nvoid dfs(int y,int x,char c){\n  used[y][x]=true;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0||H<=ny||W<=nx)continue;\n    if(used[ny][nx])continue;\n    if(s[ny][nx]==c)dfs(ny,nx,c);\n  }\n}\n\nbool Del(){\n  bool res=false;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(del[i][j])s[i][j]='.',res=true;\n  while(1){\n    int flag=0;\n    for(int i=H-1;i>=1;i--)\n      for(int j=0;j<W;j++)\n\tif(s[i][j]=='.'&&s[i-1][j]!='.')\n\t  swap(s[i][j],s[i-1][j]),flag=1;\n    if(!flag)break;\n  }\n  return res;\n}\n\nint solve(){\n  int res=0;\n  while(1){\n    memset(del,0,sizeof(del));\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++){\n\tif(del[i][j])continue;\n\tif(s[i][j]=='.')continue;\n\tif(s[i][j]=='O')continue;\n\tmemset(used,0,sizeof(used));\n\tdfs(i,j,s[i][j]);\n\tmark();\n      }\n    mark2();\n    if(Del())res++;\n    else break;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    for(int i=0;i<H;i++)cin>>s[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W = 6, H = 12;\n\ntypedef vector<vector<char>> Field;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nint dfs_count(Field& f, int x, int y, char color) {\n    int blocks = 1;\n    f[y][x] = '.';\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (f[sy][sx] == color) {\n                blocks += dfs_count(f, sx, sy, color);\n            }\n        }\n    }\n    f[y][x] = color;\n    return blocks;\n}\n\nvoid dfs_disappear(Field& f, int x, int y, char color) {\n    f[y][x] = '.';\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (f[sy][sx] == color || f[sy][sx] == 'O') {\n                dfs_disappear(f, sx, sy, color);\n            }\n        }\n    }\n}\n\nbool disappear(Field& f) {\n    bool update = false;\n    REP(y, 12) {\n        REP(x, 6) {\n            if (f[y][x] == '.') continue;\n            if (f[y][x] == 'O') continue;\n            int blocks = dfs_count(f, x, y, f[y][x]);\n            if (blocks >= 4) {\n                dfs_disappear(f, x, y, f[y][x]);\n                update = true;\n            }\n        }\n    }\n    // fall down\n    REP(x, 6) {\n        REDO:\n        int bottom = -1;\n        for (int y = 11; y >= 0; y--) {\n            if (bottom == -1 && f[y][x] == '.') {\n                bottom = y;\n            } else if (bottom != -1 && f[y][x] != '.' && f[y][x] != 'O') {\n                swap(f[bottom][x], f[y][x]);\n                goto REDO;\n            }\n        }\n    }\n    return update;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i, n) {\n        Field f(H, vector<char>(W));\n        REP(y, H) REP(x, W) cin >> f[y][x];\n        int chain = 0;\n        while (disappear(f)) {\n            chain++;\n//            LOG(\"-----\\n\");\n//            REP(y, H) {\n//                REP(x, W) {\n//                    LOG(\"%c\", f[y][x]);\n//                }\n//                LOG(\"\\n\");\n//            }\n        }\n        cout << chain << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nchar area[12][6];\nbool used[12][6];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\n\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tint y = i+dy[k], x = j+dx[k];\n\t\tif(y >= 0 && y < 12 && x >= 0 && x < 6 \n\t\t\t&& area[y][x] == c && !used[y][x]){\n\t\t\tcounter += count(y, x, c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\tcin >> area[j][k];\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  string in[12];\n  int n;\n  cin>>n;\n  while(n--){\n    rep(i,12)cin>>in[i];\n\n    int ans=0;\n\n    while(true){\n      bool end=true;\n\n      rep(i,12)rep(j,6){\n        if(in[i][j]=='.' || in[i][j]=='O')continue;\n        queue<PI> Q;\n        Q.push(mp(i,j));\n        set<PI> dis;\n        dis.insert(mp(i,j));\n        //cout<<i<<\" \"<<j<<endl;\n        int dou=0;\n        while(!Q.empty()){\n          int cx=Q.front().F,cy=Q.front().S;Q.pop();\n          ++dou;\n          rep(i,4){\n            int nx=cx+dx[i],ny=cy+dy[i];\n            if(dis.count(mp(nx,ny)) || nx<0 || nx>=12 || ny<0 || ny>=6 || (in[nx][ny]!='O' && in[nx][ny]!=in[cx][cy]))continue;\n            if(in[nx][ny]!='O')Q.push(mp(nx,ny));\n            dis.insert(mp(nx,ny));\n          }\n        }\n\n        if(dou>3){\n          end=false;\n          FOR(siter,dis){\n            int tx=siter->first,ty=siter->second;\n            in[tx][ty]='.';\n          }\n        }\n      }\n\n      if(end)break;\n      ++ans;\n\n      for(int i=11;i>=0;i--){\n        rep(j,6){\n          if(in[i][j]!='.'){\n            int ti=i;\n            while(ti<11 && in[ti+1][j]=='.'){\n              in[ti+1][j]=in[ti][j];\n              in[ti][j]='.';\n              ++ti;\n            }\n          }\n        }\n      }\n      //rep(i,12)cout<<in[i]<<endl;\n      //cout<<endl;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\nchar map[12][6];\nchar color[5]={'R','G','B','Y','P'};\nint d1[4]={0,1,0,-1};\nint d2[4]={1,0,-1,0};\nint flg,c;\nvoid swap(char *map1,char *map2){\n\tchar t;\n\tt=*map1;\n\t*map1=*map2;\n\t*map2=t;\n\treturn;\n}\nvoid fall(){\n\tint i,j,fl;\t\n\tfor(j=0;j<6;j++){\n\t\twhile(1){\t\n\t\t\tfl=0;\n\t\t\tfor(i=11;i>0;i--){\n\t\t\t\tif(map[i][j]=='.'&&map[i-1][j]!='.'){\n\t\t\t\t\tswap(&map[i][j],&map[i-1][j]);fl=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fl==0)break;\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs(char cl,int depth,int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&map[ny][nx]==cl){\n\t\t\tif(depth>=3){\n\t\t\t\tmap[ny][nx]='@';dfs(cl,depth+1,ny,nx);\n\t\t\t}else{\n\t\t\t\tmap[ny][nx]='#';dfs(cl,depth+1,ny,nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs2(int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&(map[ny][nx]=='#'||map[ny][nx]=='@')){\n\t\t\tmap[ny][nx]='*';dfs2(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid vanish(char cl){\n\tint i,j,k;\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]==cl){\n\t\t\t\tdfs(cl,1,i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='@'){\n\t\t\t\tdfs2(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='*'){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(map[i+d1[k]][j+d2[k]]=='O'&&0<=i+d1[k]&&i+d1[k]<12&&0<=j+d2[k]&&j+d2[k]<6){\n\t\t\t\t\t\tmap[i+d1[k]][j+d2[k]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[i][j]='.';flg=1;\n\t\t\t}else if(map[i][j]=='#'){\n\t\t\t\tmap[i][j]=cl;\n\t\t\t}else if(map[i][j]=='@'){\n\t\t\t\tsystem(\"pause\");\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint set;\n\tcin>>set;\n\tfor(set;set>0;set--){\n\t\tc=0;\n\t\tfor(int i=0;i<12;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\twhile(1){\n\t\t\tflg=0;\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tvanish(color[i]);\n\t\t\t}\n\t\t\tfall();\n\t\t\tif(flg==0)break;\n\t\t\tc++;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint checkfrom(int i, int j, char f[][6], bool c[][6]){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    c[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !c[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                c[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    for(int x=0;x<n;x++){\n        char f[12][6];\n        bool checked[12][6];\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                cin >> f[i][j];\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=0;i<12;i++){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j, f, checked), max_deleted);\n                    }\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                scanf(\" %c\", &f[i][j]);\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        int upmost = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=11;i>=upmost;i--){\n                bool linecheck = true;\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.') linecheck = false;\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n                if(linecheck){\n                    upmost = i-1;\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nconstexpr int H = 12;\nconstexpr int W = 6;\ntypedef array<string, H> field;\n\nconstexpr array<int, 4> dx{1, -1, 0, 0};\nconstexpr array<int, 4> dy{0, 0, 1, -1};\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= W || y >= H;\n}\n\nvoid fall(field &state) {\n\tfor(int x = 0; x < W; ++x) {\n\t\tfor(int y = 1; y < H; ++y) {\n\t\t\tif(state[y][x] == '.') {\n\t\t\t\tfor(int ny = y - 1; ny >= 0; --ny) {\n\t\t\t\t\tif(state[ny][x] == '.') break;\n\t\t\t\t\tswap(state[ny][x], state[ny + 1][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfield puyo_puyo(const field &state) {\n\tfield res(state);\n\n\tvector<vector<int>> label(H, vector<int>(W, -1));\n\tvector<int> cnt(H * W, 0);\n\tint next_index = 0;\n\n\tfor(int i = 0; i < H; ++i) {\n\t\tfor(int j = 0; j < W; ++j) {\n\t\t\tif(label[i][j] == -1 && res[i][j] != 'O' && res[i][j] != '.') {\n\t\t\t\tstack<pair<int, int>> sta;\n\t\t\t\tsta.push({j, i});\n\t\t\t\tlabel[i][j] = next_index++;\n\n\t\t\t\twhile(!sta.empty()) {\n\t\t\t\t\tconst int x = sta.top().first, y = sta.top().second;\n\t\t\t\t\tsta.pop();\n\t\t\t\t\t++cnt[label[y][x]];\n\n\t\t\t\t\tfor(unsigned d = 0; d < dx.size(); ++d) {\n\t\t\t\t\t\tconst int nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\t\tif(out(nx, ny)) continue;\n\t\t\t\t\t\tif(res[ny][nx] == res[y][x] && label[ny][nx] == -1) {\n\t\t\t\t\t\t\tsta.push({nx, ny});\n\t\t\t\t\t\t\tlabel[ny][nx] = label[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; ++i) {\n\t\tfor(int j = 0; j < W; ++j) {\n\t\t\tif(label[i][j] != -1 && cnt[label[i][j]] >= 4) {\n\t\t\t\tres[i][j] = '.';\n\t\t\t\tfor(unsigned d = 0; d < dx.size(); ++d) {\n\t\t\t\t\tconst int nx = j + dx[d], ny = i + dy[d];\n\t\t\t\t\tif(out(nx, ny)) continue;\n\t\t\t\t\tif(res[ny][nx] == 'O') res[ny][nx] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfall(res);\n\treturn res;\n}\n\nint solve() {\n\tfield current;\n\tfor(auto &line : current) cin >> line;\n\n\tfor(int i = 0;; ++i) {\n\t\tfield next = puyo_puyo(current);\n\t\tif(next == current) return i;\n\t\tcurrent = move(next);\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) cout << solve() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<queue>\n#include<string.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nchar cmap[13][13];\nbool used[13][13];\nint imap[13][13];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nint Cnt = 0;\n\nvoid dfs(int x,int y,char c,int cnt)\n{\n  used[y][x] = true; \n  int fcnt = 0;\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12&&cmap[ny][nx] == c && !used[ny][nx]){\n      fcnt++; Cnt++;\n      dfs(nx,ny,c,cnt+1);\n    }\n  }\n  if(fcnt == 0)imap[y][x] = Cnt;\n}\n\nvoid erase(int x,int y,char c)\n{\n  used[y][x] = true;\n  cmap[y][x] = '.';\n\n  queue<P> que;\n  que.push(P(x,y));\n\n  while(!que.empty())\n    {\n      P p = que.front(); que.pop();\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.F+dx[i],ny = p.S+dy[i];\n\n\t  if(0<=nx&&nx<6&&0<=ny&&ny<12&& ((!used[ny][nx] && cmap[ny][nx] == c) || cmap[ny][nx] == 'O'))\n\t    {\n\t      if(cmap[ny][nx] != 'O')que.push(P(nx,ny));\n\t      cmap[ny][nx] = '.';\n\t      used[ny][nx] = true;\n\t      \n\t    }\n\t}\n    }\n}\n\nvoid display()\n{\n\n  for(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << cmap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  /*\nfor(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << imap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  */\n  cout << endl;\n}\n\n\nvoid drop(int x,int y)\n{\n  //cout << \"x = \" << x << \", y = \" << y << endl;\n  int st,ed;\n  st = y;\n  ed = -1;\n  for(int i=y;i>=0;i--)\n    {\n      if(ed == -1 && cmap[i][x] != '.')\n\t{\n\t  ed = i+1;\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] =\" << cmap[st+ed-(i+1)][x] << \", cmpa[\"<<i<<\"][x] = \"<<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] != '.')\n\t{\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] = \" << cmap[st+ed-(i+1)][x] << \", cmap[\"<<i<<\"][x] = \" <<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] == '.')\n\t{\n\t  for(int k=11;k>=0;k--)\n\t    {\n\t      if(cmap[k][x] == '.')\n\t\t{\n\t\t  st = k;\n\t\t  break;\n\t\t}\n\t    }\n       \n\t  ed = -1;\n\t}      \n\n    }\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  while(N-- > 0)\n    {\n      for(int i=0;i<12;i++)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  for(int j=0;j<s.length();j++)\n\t    {\n\t      cmap[i][j] = s[j];\n\t      used[i][j] = false;\n\t      imap[i][j] = -1;\n\t    }\n\t}\n\n      int cnt = 0;\n      while(true)\n\t{\n\t  //display();\n\t  int increase = 0;\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)\n\t\t\t\t {\n\t\t\t\t   imap[i][j] = -1;\n\t\t\t\t   used[i][j] = false;\n\t\t\t\t }\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(cmap[i][j] != '.' && cmap[i][j] != 'O' && !used[i][j])\n\t\t    {\n\t\t      Cnt=1;\n\t\t      dfs(j,i,cmap[i][j],1); //最大何マスつながっているか\n\t\t    }\n\t\t}\n\t    }\n\t\n\t  \n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)used[i][j] = false;\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(!used[i][j] && imap[i][j] >= 4){\n\t\t    increase++;\n\t\t    erase(j,i,cmap[i][j]);\n\t\t  }\n\t\t}\n\t    }\n\t  //display();\n\t  if(increase == 0)\n\t    {\n\t      break;\n\t    }\n\t  cnt++;\n\n\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      for(int j=11;j>=0;j--)\n\t\t{\n\t\t  if(cmap[j][i] == '.')\n\t\t    {\n\t\t      drop(i,j);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t    }\n\n\n\n\n\n\t}\n\n      cout<< cnt << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// UTPC2010 C. RpC\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nchar dx[] = {-1, 0, 1, 0};\nchar dy[] = {0, -1, 0, 1};\n\nint main(){\n\tstring s[12];\n\tbool visit[12][6], erase[12][6];\n\twhile(cin >> s[0]){\n\t\tfor(int i=1;i<12;i++) cin >> s[i];\n\t\tint ans = 0;\n\t\twhile(true){\n\t\t\tmemset(visit, false, sizeof(visit));\n\t\t\tmemset(erase, false, sizeof(erase));\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(!visit[i][j]&&s[i][j]!='.'&&s[i][j]!='O'){\n\t\t\t\t\t\tqueue< pair<int, int> > qu; qu.push(make_pair(i,j));\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\twhile(!qu.empty()){\n\t\t\t\t\t\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\t\t\t\t\t\tif(erase[p.first][p.second]) continue;\n\t\t\t\t\t\t\terase[p.first][p.second] = true;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\t\t\t\t\t\tif(nx < 0 || 12 <= nx || ny < 0 || 6 <= ny || s[p.first][p.second]!=s[nx][ny]) continue;\n\t\t\t\t\t\t\t\tqu.push(make_pair(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt >= 4) memcpy(visit, erase, sizeof(visit));\n\t\t\t\t\t\tmemcpy(erase, visit, sizeof(erase));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(s[i][j]!='O') continue;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\t\tif(nx < 0 || 12 <= nx || ny < 0 || 6 <= ny || !erase[nx][ny]) continue;\n\t\t\t\t\t\terase[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool next = false;\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(erase[i][j]){\n\t\t\t\t\t\tnext = true;\n\t\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tvector<char> vc;\n\t\t\t\tfor(int j=11;j>=0;j--){\n\t\t\t\t\tif(s[j][i]!='.') vc.push_back(s[j][i]);\n\t\t\t\t\ts[j][i] = '.';\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<vc.size();j++)\n\t\t\t\t\ts[11-j][i] = vc[j];\n\t\t\t}\n\t\t\tif(next) ans++;\n\t\t\telse     break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint dy[]={-1,0,1,0},dx[]={0,1,0,-1};\nint h=12,w=6;\nchar f[12][9];\n\nint rec(int y,int x,bool e)\n{\n\tchar c=f[y][x]; int ret=1;\n\tf[y][x]='.';\n\trep(d,4)\n\t{\n\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\tif(ny<0||ny>=h||nx<0&&nx>=w)continue;\n\t\tif(e&&f[ny][nx]=='O')f[ny][nx]='.',ret++;\n\t\tif(f[ny][nx]==c)ret+=rec(ny,nx,e);\n\t}\n\tif(!e)f[y][x]=c;\n\treturn ret;\n}\n\nint main()\n{\n\tint CS; scanf(\"%d\",&CS);\n\trep(cs,CS)\n\t{\n\t\trep(i,h)scanf(\"%s\",f[i]);\n\t\tint ans=0;\n\t\tfor(;;ans++)\n\t\t{\n\t\t\tbool e=0;\n\t\t\trep(i,h)rep(j,w)if(f[i][j]!='.'&&f[i][j]!='O')\n\t\t\t{\n\t\t\t\tif(rec(i,j,0)>3)e=1,rec(i,j,1);\n\t\t\t}\n\t\t\tif(!e)break;\n\t\t\t\n\t\t\trep(j,w)for(int i=10;i>=0;i--)if(f[i][j]!='.')\n\t\t\t{\n\t\t\t\tint k=i+1; for(;k<12&&f[k][j]=='.';k++);\n\t\t\t\tswap(f[i][j],f[k-1][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint dx[]={0,1,0,-1,0};\nchar m[14][8];\t//ツ氾板閉コツつソツづ。ツづア\nbool f[14][8];\nint F(int x,int y,char t)\n{\n\tif(m[y][x]-t||f[y][x])return 0;\n\tf[y][x]=1;\n\tint r=1,i;\n\tfor(i=0;i<4;++i)r+=F(x+dx[i],y+dx[i+1],t);\n\treturn r;\n}\nvoid G(int x,int y,char t)\n{\n\tif(m[y][x]=='O')m[y][x]=0;\n\telse if(m[y][x]==t)\n\t{\n\t\tm[y][x]=0;\n\t\tfor(int i=0;i<4;++i)G(x+dx[i],y+dx[i+1],t);\n\t}\n}\nint H(int t)\n{\n\treturn t&&strchr(\"RGBYP\",t);\n}\nint I(int t)\n{\n\treturn H(t)||(t=='O');\n}\nint main()\n{\n\tint i,j,s,x,n,c,d;\n\tfor(scanf(\"%d\",&n);n--;)\n\t{\n\t\tfor(i=0;i<12;++i)scanf(\"%s\",m[i+1]+1);\n\t\tfor(s=0;;)\n\t\t{\n\t\t\tx=0;\n\t\t\tfor(i=1;i<=12;++i)for(j=1;j<=6;++j)\n\t\t\t{\n\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\tif(c=m[i][j], H(c)&&F(j,i,c)>3)\n\t\t\t\t\tG(j,i,c),++x;\n\t\t\t}\n\t\t\tif(!x)break;\n\t\t\t++s;\n\t\t\tfor(j=1;j<=6;++j)\n\t\t\t{\n\t\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\t\tx=0;\n\t\t\t\t\tfor(i=11;i>0;--i)\n\t\t\t\t\t{\n\t\t\t\t\t\tc=m[i+1][j];\n\t\t\t\t\t\td=m[i][j];\n\t\t\t\t\t\tif(!I(c)&&I(d))m[i+1][j]=d,m[i][j]=0,++x;\n\t\t\t\t\t}\n\t\t\t\t\tif(!x)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint checkfrom(int i, int j, char f[][6], bool c[][6]){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    c[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !c[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                c[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid debug_print(char f[12][6]){\n    for(int i=0;i<12;i++){\n        for(int j=0;j<6;j++){\n            cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    for(int x=0;x<n;x++){\n        char f[12][6];\n        bool checked[12][6];\n        memset(f, 0, sizeof(f));\n\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                cin >> f[i][j];\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=0;i<12;i++){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O'){\n                        max_deleted = max(checkfrom(i, j, f, checked), max_deleted);\n                    }\n                }\n            }\n            int hoge;\n            for(int i=10;i>=0;i--){\n                for(int j=0;j<6;j++){\n                    int tx = i, ty = j;\n                    while(tx <= 10 && f[tx][ty] != '.' && f[tx+1][ty] == '.'){\n                        f[tx+1][ty] = f[tx][ty];\n                        f[tx][ty] = '.';\n                        tx++;\n                    }\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<iostream>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n#define\tY\tfirst\t\n#define\tX\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nchar field[12][7];\n\nbool vanish(){\n\tbool vanished=false;\n\n\tfor(int i=0;i<12;i++)for(int j=0;j<6;j++){\n\t\tif(field[i][j]=='.' || field[i][j]=='O' || field[i][j]=='*')\tcontinue;\n\n\t\tbool chk[12][6]={};\n\t\tvector<pii> puyo;\n\t\tqueue<pii> qu;\tqu.push(mp(i,j));\n\t\twhile(!qu.empty()){\t// BFS\n\t\t\tpii a=qu.front();\tqu.pop();\n\t\t\tif(chk[a.Y][a.X])\tcontinue;\n\t\t\tchk[a.Y][a.X]=true;\n\t\t\tpuyo.pb(a);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint yy=a.Y+dy[k],xx=a.X+dx[k];\n\t\t\t\tif(0<=yy && yy<12 && 0<=xx && xx<6\n\t\t\t\t&& field[yy][xx]==field[i][j] && !chk[yy][xx])\n\t\t\t\t\tqu.push(mp(yy,xx));\n\t\t\t}\n\t\t}\n\n\t\tif(puyo.size()>=4){\n\t\t\tfor(int k=0;k<puyo.size();k++)\tfield[puyo[k].Y][puyo[k].X]='*';\n\t\t\tvanished=true;\n\t\t}\n\t}\n\n\tif(!vanished)\treturn false;\n\n\tfor(int i=0;i<12;i++)for(int j=0;j<6;j++){\n\t\tif(field[i][j]=='O'){\n\t\t\tbool flg=false;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint yy=i+dy[k],xx=j+dx[k];\n\t\t\t\tif(0<=yy && yy<12 && 0<=xx && xx<6 && field[yy][xx]=='*')\n\t\t\t\t\tflg=true;\n\t\t\t}\n\t\t\tif(flg)\tfield[i][j]='.';\n\t\t}\n\t}\n\tfor(int i=0;i<12;i++)for(int j=0;j<6;j++){\n\t\tif(field[i][j]=='*')\tfield[i][j]='.';\n\t}\n\n\treturn true;\n}\n\nvoid fall(){\n\tchar col[12];\n\tfor(int j=0;j<6;j++){\n\t\tfor(int i=11;i>=0;i--)\tcol[i]=field[i][j];\n\t\tint k=11;\n\t\tfor(int i=11;i>=0;i--)\tif(col[i]!='.')\tfield[k--][j]=col[i];\n\t\tfor(;k>=0;k--)\tfield[k][j]='.';\n\t}\n\treturn;\n}\n\nint main(){\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tfor(int i=0;i<12;i++)\tcin>>field[i];\n\t\tint cnt=0;\n\t\tfor(;;cnt++){\n\t\t\tif(!vanish())\tbreak;\n\t\t\tfall();\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 17 52 ¨@WA18 -> 25´öª©Á½? ->@ÏÈfoOÉYÜ³ê31ªño \n\n\n#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\nstring data[12];\n\n/* ûüpÏ */\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,-1,1};\n\n/* »èÖ */\nbool iscorrect(int y,int x){\n\tif(y>11 || y<0)return false;\n\tif(x<0 || x>5)return false;\n\treturn true;\n}\nbool ispuyo(int i,int j){\n\treturn data[i][j] != 'O' && data[i][j] != '.';\n}\n\n/* Âð¦é */\nint chainCount;\nbool done[12][6];\nvoid search(int y,int x,int c){\n\tif(data[y][x] != c)return;\n\t\n\tif(done[y][x])return;\n\tchainCount++;\n\tdone[y][x] = true;\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx))search(ny,nx,c);\n\t}\n}\n\n/* í·é */\nvoid del(int y,int x,int c){\n\tif(data[y][x] != c)return;\n\tdata[y][x] = '.';\n\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx)){\n\t\t\tif(data[ny][nx]=='O') data[ny][nx]='.'; //×ÚµÄ¢½çÂ¢ÅÉÁ·\n\t\t\tdel(ny,nx,c);\n\t\t}\n\t}\n\t\n}\n\n/* º³¹é */\nvoid down(){\n\trep(x,12){\n\t\trep(w,6){\n\t\t\trep(i,12-1){\n\t\t\t\tif(data[i+1][w] == '.'){\n\t\t\t\t\tswap(data[i+1][w],data[i][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\n\nint main(){\n\tint n;\n\tcin >>n;\n\twhile(n--){\n\t\n\t\trep(i,12)cin >> data[i];\n\t\tdown();\n\t\t\n\t\tfor(int retCount = 0;;retCount++){\n\t\t\tbool flag = true;\n\t\t\t\n\t\t\trep(i,12)rep(j,6){\n\t\t\t\tif( ispuyo(i,j)){\n\t\t\t\t\n\t\t\t\t\tmemset(done,0,12*6), chainCount = 0, search(i,j,data[i][j]);\n\t\t\t\t\t\n\t\t\t\t\tif(chainCount >= 4){\n\t\t\t\t\t\tdel(i,j,data[i][j]);\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tcout << retCount << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdown();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint T;\nchar N[12][7];\nint tmp[12][6];\nint cnt;\nchar c;\n\nvoid init() {\n  scanf(\"%d\", &T);\n}\n\nbool input() {\n  int i;\n\n  if(!T) return false;\n  T--;\n  for (i = 0; i < 12; i++) {\n    scanf(\" %s\", N[i]);\n  }\n  return true;\n}\n\nvoid jama(int y, int x) {\n  if (x < 0 || 6 <= x || y < 0 || 12 <= y) return;\n  if (N[y][x] == 'O') {\n    tmp[y][x] = 2;\n  }\n\n  return;\n}\n\nvoid funk(int y, int x) {\n  if (x < 0 || 6 <= x || y < 0 || 12 <= y) return;\n  if (tmp[y][x] != 0 || N[y][x] != c) return;\n  tmp[y][x] = 1;\n  cnt++;\n  funk(y - 1, x    );\n  funk(y + 1, x    );\n  funk(y    , x - 1);\n  funk(y    , x + 1);\n}\n\nbool kesu() {\n  int i, j, k;\n  bool flag = false;\n\n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 6; j++) {\n      if (tmp[i][j] == 2) {\n        flag = true;\n        N[i][j] = '.';\n      }\n    }\n  }\n  for (k = 0; k < 12; k++)\n    for (i = 11; i > 0; i--) {\n      for (j = 0; j < 6; j++) {\n        if (N[i][j] == '.') {\n          N[i    ][j] = N[i - 1][j];\n          N[i - 1][j] = '.';\n        }\n      }\n    }\n    return flag;\n}\n\nint main() {\n  int i, j, k, a, b;\n  long long int sum;\n  bool flag;\n\n  init();\n  while (input()) {\n    sum = 0;\n    flag = true;\n    while (flag) {\n      fill(tmp[0], tmp[0] + 12 * 6, 0);\n      for (i = 0; i < 12; i++) {\n        for (j = 0; j < 6; j++) {\n          if (N[i][j] != 'O' && N[i][j] != '.') {\n            c = N[i][j];\n            cnt = 0;\n            funk(i, j);\n\n\n            if (cnt > 3) {\n              for (a = 0; a < 12; a++) {\n                for (b = 0; b < 6; b++) {\n                  if(tmp[a][b] == 1)\n                    tmp[a][b] = 2;\n                  jama(a - 1, b    );\n                  jama(a + 1, b    );\n                  jama(a    , b - 1);\n                  jama(a    , b + 1);\n                }\n              }\n            } else {\n              for (a = 0; a < 12; a++) {\n                for (b = 0; b < 6; b++) {\n                  if(tmp[a][b] == 1)\n                    tmp[a][b] = 3;\n                }\n              }\n            }\n\n\n          }\n        }\n      }\n\n\n      flag = kesu();\n      if (flag) sum++;\n    }\n    /*\n    for (i = 0; i < 12; i++) {\n      printf(\"%s \", N[i]);\n      for (j = 0; j < 6; j++) {\n        printf(\"%d\", tmp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    printf(\"%d\\n\", sum);\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring board[12];\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst int H = 12;\nconst int W = 6;\n\nvoid print_board()\n{\n  for (int y = 0; y < H; y++) {\n    for (int x = 0; x < W; x++)\n      cout << board[y][x];\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nint dfs(int x, int y, bool flag)\n{\n  char ch = board[y][x];\n  int ret = 1;\n\n  board[y][x] = '.';\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    \n    if (nx < 0 || nx >= W || ny < 0 || ny >= H)\n      continue;\n    \n    if (flag && board[ny][nx] == 'O') {\n      board[ny][nx] = '.';\n      ret++;\n    }\n\n    if (board[ny][nx] == ch)\n      ret += dfs(nx, ny, flag);\n  }\n  if (!flag)\n    board[y][x] = ch;\n  \n  return ret;\n}\n\nvoid drop()\n{\n  for (int x = 0; x < W; x++) {\n    int s, i;\n    s = i = H - 1;\n    while (s >= 0) {\n      if (board[s][x] != '.') {\n\tswap(board[s][x], board[i][x]);\n\ti--;\n      }\n      s--;\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  \n  cin >> T;\n  while (T--) {\n    // Input\n    for (int i = 0; i < H; i++)\n      cin >> board[i];\n\n    int ans = 0;\n    while (true) {\n      bool flag = false;\n\n      for (int y = 0; y < H; y++) \n\tfor (int x = 0; x < W; x++)\n\t  if (board[y][x] != '.' && board[y][x] != 'O')\n\t    if (dfs(x, y, false) > 3) {\n\t      flag = true;\n\t      dfs(x, y, true);\n\t    }\n\n      if (!flag)\n\tbreak;\n      drop();\n      ans++;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nchar board[12][6];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid print() {\n  int i,j;\n  rep(i,12) {\n    rep(j,6)\n      cout<<board[i][j];\n    cout<<endl;\n  }\n}\n\nbool isok(int x,int y) {\n  return (x >= 0 && x < 6 && y >= 0 && y < 12);\n}\n\nbool erase() {\n  bool isb[12][6];\n  int i,j,k,l;\n  bool update = false;\n  memset(isb, false, sizeof(isb));\n  rep(i,12) {\n    rep(j,6) {\n      if(isb[i][j]) continue;\n      isb[i][j] = true;\n      if(board[i][j] == '.' || board[i][j] == 'O') continue;\n\n      queue<pair<int,int> > Q;\n      vector<pair<int,int> > vv;\n      Q.push(make_pair(i,j)); vv.push_back(make_pair(i,j));\n      while(!Q.empty()) {\n\tpair<int,int> p = Q.front(); Q.pop();\n\tint x = p.second,y = p.first;\n\trep(k,4) {\n\t  if(isok(x+dx[k],y+dy[k]))\n\t    if(board[y+dy[k]][x+dx[k]] == board[y][x] && !isb[y+dy[k]][x+dx[k]]) {\n\t      Q.push(make_pair(y+dy[k],x+dx[k]));\n\t      isb[y+dy[k]][x+dx[k]] = true;\n\t      vv.push_back(make_pair(y+dy[k],x+dx[k]));\n\t    }\n\t}\n      }\n\n      if(vv.size() >= 4) {\n\tupdate = true;\n\trep(k,vv.size()) {\n\t  int x = vv[k].second,y = vv[k].first;\n\t  rep(l,4) {\n\t    if(isok(x+dx[l],y+dy[l]))\n\t      if(board[y+dy[l]][x+dx[l]] == 'O')\n\t\tboard[y+dy[l]][x+dx[l]] = '.';\n\t  }\n\t  board[vv[k].first][vv[k].second] = '.';\n\t}\n      }\n    }\n  }\n\n  return update;\n}\n\nvoid drop() {\n  int i,j,k;\n  for(i=11; i>=0; --i) {\n    rep(j,6) {\n      if(board[i][j] == '.') {\n\tk = i;\n\twhile(k >= 0) {\n\t  if(!(board[k][j] == '.')) {\n\t    board[i][j] = board[k][j];\n\t    board[k][j] = '.';\n\t    break;\n\t  }\n\t  k--;\n\t}\n      }\n    }\n  }\n}\n\nint solve() {\n  bool update = false;\n  int t = 0;\n  while(true) {\n    update = erase();\n    if(!update) return t;\n    t++;\n    drop();\n  }\n}\n\nvoid input() {\n  int i,j;\n  string s;\n  rep(i,12) {\n    cin>>s;\n    rep(j,6)\n      board[i][j] = s.at(j);\n  }\n  return;\n}\n\nint main() {\n  int t;\n  cin>>t;\n  while(t--) {\n    memset(board,0,sizeof(board));\n    memset(tmpb, 0, sizeof(tmpb));\n    input();\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint dx[]={0,1,0,-1,0};\nchar m[14][8];\nbool f[14][8];\nint F(int x,int y,char t)\n{\n\tif(m[y][x]-t||f[y][x])return 0;\n\tf[y][x]=1;\n\tint r=1,i;\n\tfor(i=0;i<4;++i)r+=F(x+dx[i],y+dx[i+1],t);\n\treturn r;\n}\nvoid G(int x,int y,char t)\n{\n\tif(m[y][x]=='0')m[y][x]=0;\n\telse if(m[y][x]==t)\n\t{\n\t\tm[y][x]=0;\n\t\tfor(int i=0;i<4;++i)G(x+dx[i],y+dx[i+1],t);\n\t}\n}\nint H(int t)\n{\n\treturn t&&strchr(\"RGBYP\",t);\n}\nint main()\n{\n\tint i,j,s,x,n,c,d;\n\tfor(scanf(\"%d\",&n);n--;)\n\t{\n\t\tfor(i=0;i<12;++i)scanf(\"%s\",m[i+1]+1);\n\t\tfor(s=0;;)\n\t\t{\n\t\t\tx=0;\n\t\t\tfor(i=1;i<=12;++i)for(j=1;j<=6;++j)\n\t\t\t{\n\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\tif(c=m[i][j], H(c)&&F(j,i,c)>3)\n\t\t\t\t\tG(j,i,c),++x;\n\t\t\t}\n\t\t\tif(!x)break;\n\t\t\t++s;\n\t\t\tfor(j=1;j<=6;++j)\n\t\t\t{\n\t\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\t\tx=0;\n\t\t\t\t\tfor(i=11;i>0;--i)\n\t\t\t\t\t{\n\t\t\t\t\t\tc=m[i+1][j];\n\t\t\t\t\t\td=m[i][j];\n\t\t\t\t\t\tif(!H(c)&&H(d))m[i+1][j]=d,m[i][j]=0,++x;\n\t\t\t\t\t}\n\t\t\t\t\tif(!x)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\nint main(){\n\n\tconst int dy[]={-1,0,0,1};\n\tconst int dx[]={0,1,-1,0};\n\n\tint t;\n\tcin>>t;\n\tchar field[12][6];\n\twhile(t--){\n\t\tfor(int i = 0; i < 12; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tcin>>field[i][j];\n\t\tbool fin=false;\n\t\tbool isCheck[12][6];\n\t\tint loopNum=-1;\n\t\twhile(!fin){\n\t\t\tmemset(isCheck,0,sizeof(isCheck));\n\n\t\t\tfin=true;\n\t\t\tfor(int i = 0; i < 12; i++){\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tif(!isCheck[i][j]&&field[i][j]!='.'&&field[i][j]!='O'){\n\t\t\t\t\t\tchar col=field[i][j];\n\t\t\t\t\t\tvector<pair<int,int> > vpii;\n\t\t\t\t\t\tqueue<pair<int,int> > q;\n\t\t\t\t\t\tq.push(make_pair(i,j));\n\n\t\t\t\t\t\twhile(q.size()){\n\t\t\t\t\t\t\tpair<int,int> cp=q.front();q.pop();\n\t\t\t\t\t\t\tif(isCheck[cp.first][cp.second]||field[cp.first][cp.second]!=col)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tisCheck[cp.first][cp.second]=true;\n\t\t\t\t\t\t\tvpii.push_back(cp);\n\t\t\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\t\t\tint ny=cp.first+dy[k];\n\t\t\t\t\t\t\t\tint nx=cp.second+dx[k];\n\t\t\t\t\t\t\t\tif(ny>=0&&nx>=0&&ny<12&&nx<6)\n\t\t\t\t\t\t\t\t\tq.push(make_pair(ny,nx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 4ÂÈã¯¶FÌÕæªAµÄ¢êÎAÁ·\n\t\t\t\t\t\t// »ÌÛ»ê¼êÌÕæÌlûüÉ é¨¶áÜàª«Þ\n\t\t\t\t\t\tif(vpii.size()>=4){\n\t\t\t\t\t\t\tfor(int k = 0; k < vpii.size(); k++){\n\t\t\t\t\t\t\t\tpair<int,int> p=vpii[k];\n\t\t\t\t\t\t\t\tfield[p.first][p.second]='.';\n\t\t\t\t\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\t\t\t\t\tint ny=p.first+dy[l];\n\t\t\t\t\t\t\t\t\tint nx=p.second+dx[l];\n\t\t\t\t\t\t\t\t\tif(ny>=0&&nx>=0&&ny<12&&nx<6)\n\t\t\t\t\t\t\t\t\t\tif(field[ny][nx]=='O')\n\t\t\t\t\t\t\t\t\t\t\tfield[ny][nx]='.';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfin=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int i = 12-1; i >= 0; i--){\n\t\t\t\t\tif(field[i][j]!='.'){\n\t\t\t\t\t\tfield[11-cnt][j]=field[i][j];\n\t\t\t\t\t\tif(11-cnt!=i)\n\t\t\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tloopNum++;\n\t\t}\n\t\tcout<<loopNum<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nenum{AKI,RED,GREEN,BLUE,YELLOW,PURPLE,JAMA};\n\nint recmap[6][12];\nvector<int> map[6];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\ntypedef pair<int,int> P;\n\nint rec(int fillv,int x,int y,int col){\n     if( x<0 || x>5 || y<0 || y > 11) return 0;\n     if(recmap[x][y]>-1||map[x][y]!=col) return 0;\n     recmap[x][y]=fillv;\n     int sum=0;\n     for(int i=0;i<4;i++)sum+=rec(fillv,x+dx[i],y+dy[i],col);\n     ++sum;\n     return sum;\n}\nvoid recclear(){\n     for(int i=0;i<12;i++){\n\t  for(int j=0;j<6;j++){\n\t       recmap[j][i]=-1;\n\t  }\n     }\n}\n\nint main(){\n     int T;\n     cin>>T;\n     for(int time=0;time<T;time++){\n\t  for(int i=0;i<6;i++){\n\t       map[i].resize(12,0);\n\t  }\n\t  for(int i=11;i>-1;i--){\n\t       for(int j=0;j<6;j++){\n\t\t    char a;\n\t\t    cin>>a;\n\t\t    switch(a){\n\t\t    case 'R':\n\t\t\t map[j][i]=RED;\n\t\t\t break;\n\t\t    case 'G':\n\t\t\t map[j][i]=GREEN;\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t map[j][i]=BLUE;\n\t\t\t break;\n\t\t    case 'Y':\n\t\t\t map[j][i]=YELLOW;\n\t\t\t break;\n\t\t    case 'P':\n\t\t\t map[j][i]=PURPLE;\n\t\t\t break;\n\t\t    case 'O':\n\t\t\t map[j][i]=JAMA;\n\t\t\t break;\n\t\t    case '.':\n\t\t\t map[j][i]=AKI;\n\t\t    }\n\t       }\n\t  }\n\t  int count=0;\n\t  while(1){\n\t       vector<int> dels;\n\t       recclear();\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(map[i][j]==AKI||map[i][j]==JAMA)continue;\n\t\t\t if(rec(i+j*6,i,j,map[i][j])>3){\n\t\t\t      dels.push_back(i+j*6);\n\t\t\t }\n\t\t    }\n\t       }\n\t       if(dels.empty())break;\n\t       count++;\n\t       bool isdel[6][12]={};\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t for(int k=0;k<dels.size();k++){\n\t\t\t      if(recmap[i][j]==dels[k])isdel[i][j]=true;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(map[i][j]==JAMA){\n\t\t\t      bool flag=false;\n\t\t\t      for(int k=0;k<4;k++){\n\t\t\t\t   if(i+dx[k]<0||i+dx[k]>5||j+dy[k]<0||j+dy[k]>11)continue;\n\t\t\t\t   if(isdel[i+dx[k]][j+dy[k]]&&map[i+dx[k]][j+dy[k]]!=JAMA){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t   }\n\t\t\t      }\n\t\t\t      if(flag)isdel[i][j]=true;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(isdel[i][j]){\n\t\t\t      map[i][j]=AKI;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    vector<int>::iterator endit=remove(map[i].begin(),map[i].end(),0);\n\t\t    map[i].resize(12,0);\n\t\t    fill(endit,map[i].end(),0);\n\t       }\n\t       /*for(int i=0;i<6;i++){\n\t\t vector<int>::iterator itr=map[i].begin();\n\t\t while(itr!=map[i].end()){\n\t\t cout<<*itr;\n\t\t itr++;\n\t\t }\n\t\t cout<<endl;\n\t\t }\n\t\t cout<<endl;*/\n\t  }\n\t  cout<<count<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\nchar map[12][6];\nchar color[5]={'R','G','B','Y','P'};\nint d1[4]={0,1,0,-1};\nint d2[4]={1,0,-1,0};\nint flg,c,a;\nvoid swap(char *map1,char *map2){\n\tchar t;\n\tt=*map1;\n\t*map1=*map2;\n\t*map2=t;\n\treturn;\n}\nvoid fall(){\n\tint i,j,fl;\t\n\tfor(j=0;j<6;j++){\n\t\twhile(1){\t\n\t\t\tfl=0;\n\t\t\tfor(i=11;i>0;i--){\n\t\t\t\tif(map[i][j]=='.'&&map[i-1][j]!='.'){\n\t\t\t\t\tswap(&map[i][j],&map[i-1][j]);fl=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fl==0)break;\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs(char cl,int y,int x){//再帰の深さ＞＝４で考えるとWA\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&map[ny][nx]==cl){\n\t\t\tif(a>=3){\n\t\t\t\tmap[ny][nx]='@';a++;\n\t\t\t}else{\n\t\t\t\tmap[ny][nx]='#';a++;\n\t\t\t}\n\t\t\tdfs(cl,ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid dfs2(int y,int x){\n\tint ny,nx;\n\tfor(int i=0;i<4;i++){\n\t\tny=y+d1[i];nx=x+d2[i];\n\t\tif(0<=ny&&ny<12&&0<=nx&&nx<6&&map[ny][nx]=='#'){\n\t\t\tmap[ny][nx]='*';dfs2(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid vanish(char cl){\n\tint i,j,k;\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\ta=0;\n\t\t\tif(map[i][j]==cl){\n\t\t\t\tdfs(cl,i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='@'){\n\t\t\t\tdfs2(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<12;i++){\n\t\tfor(j=0;j<6;j++){\n\t\t\tif(map[i][j]=='*'||map[i][j]=='@'){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(map[i+d1[k]][j+d2[k]]=='O'&&0<=i+d1[k]&&i+d1[k]<12&&0<=j+d2[k]&&j+d2[k]<6){\n\t\t\t\t\t\tmap[i+d1[k]][j+d2[k]]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[i][j]='.';flg=1;\n\t\t\t}else if(map[i][j]=='#'){\n\t\t\t\tmap[i][j]=cl;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint set;\n\tcin>>set;\n\tfor(set;set>0;set--){\n\t\tc=0;\n\t\tfor(int i=0;i<12;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\twhile(1){\n\t\t\tflg=0;\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tvanish(color[i]);\n\t\t\t}\n\t\t\tfall();\n\t\t\tif(flg==0)break;\n\t\t\tc++;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int w = 6;\nconst int h = 12;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst int dd[] = {2, 3, 0, 1};\n\nchar m[h][w + 1];\nchar c[h][w + 1];\n\nvoid rec_check(int y, int x, char p, int d) {\n    if (y < 0 || h <= y || x < 0 || w <= x || c[y][x] > 0) {\n        return;\n    }\n\n    if (m[y][x] == 'O') {\n        c[y][x] = 2;\n        return;\n    } else if (m[y][x] != p) {\n        c[y][x] = 3;\n        return;\n    }\n\n    c[y][x] = 1;\n    for (int i = 0; i < 4; i++) {\n        if (i != d) {\n            rec_check(y + dy[i], x + dx[i], p, dd[i]);\n        }\n    }\n}\n\n\nbool clear(int cx, int cy) {\n    memset(c, 0, sizeof(c));\n    rec_check(cy, cx, m[cy][cx], -1);\n\n    int counter = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (c[y][x] == 1) {\n                counter++;\n            }\n        }\n    }\n    if (counter < 4) {\n        return false;\n    }\n\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (c[y][x] == 1 || c[y][x] == 2) {\n                m[y][x] = '.';\n            }\n        }\n    }\n    return true;\n}\n\nbool run() {\n    bool c = false;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (m[y][x] == '.' || m[y][x] == 'O') {\n                continue;\n            }\n            if ((x+1 < w && m[y][x] == m[y][x+1]) || (y+1 < h && m[y][x] == m[y+1][x])) {\n                c |= clear(x, y);\n            }\n        }\n    }\n    return c;\n}\n\nvoid down() {\n    for (int x = 0; x < w; x++) {\n        for (int y = h - 1, iy = h - 1; y >= 0; y--) {\n            if (m[y][x] != '.') {\n                m[iy][x] = m[y][x];\n                if (y != iy) {\n                    m[y][x] = '.';\n                }\n                iy--;\n            }\n        }\n    }\n}\n\nint main () {\n    int t;\n    cin >> t;\n    while (t--) {\n        for (int i = 0; i < h; i++) {\n            cin >> m[i];\n        }\n\n        int counter = 0;\n        while (run()) {\n            down();\n            counter++;\n        }\n        cout << counter << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nchar p[12][7];\nint f[12][6], dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\n\nint main(void){\n\tint a, b, i, j, k, l, g, n, flag, cnt, m;\n\tqueue<pair<int,int> > que;\n\tscanf(\"%d%*c\",&n);\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = 0;j < 12;j++)\n\t\t\tgets(p[j]);\n\t\tm = 0;\n\t\twhile(1){\n\t\t\tflag = 1;\n\t\t\tmemset(f,0,sizeof(f));\n\t\t\tfor(j = 0;j < 12;j++){\n\t\t\t\tfor(k = 0;k < 6;k++){\n\t\t\t\t\tif(p[j][k] != '.' && p[j][k] != 'O' && !f[j][k]){\n\t\t\t\t\t\tque.push(pair<int,int>(j,k));\n\t\t\t\t\t\tf[j][k] = 1;\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\twhile(que.size()){\n\t\t\t\t\t\t\ta = que.front().first;\n\t\t\t\t\t\t\tb = que.front().second;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tprintf(\"%d %d\\n\",a,b);\n\t\t\t\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\t\t\t\tif(a + dy[l] >= 0 && a + dy[l] < 12 && b + dx[l] >= 0 && b + dx[l] < 6 && !f[a + dy[l]][b + dx[l]] && p[j][k] == p[a + dy[l]][b + dx[l]]){\n\t\t\t\t\t\t\t\t\tf[a + dy[l]][b + dx[l]] = 1;\n\t\t\t\t\t\t\t\t\tque.push(pair<int,int>(a + dy[l],b + dx[l]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt >= 4){\n\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\tque.push(pair<int,int>(j,k));\n\t\t\t\t\t\t\tchar c = p[j][k];\n\t\t\t\t\t\t\tp[j][k] = '.';\n\t\t\t\t\t\t\twhile(que.size()){\n\t\t\t\t\t\t\t\ta = que.front().first;\n\t\t\t\t\t\t\t\tb = que.front().second;\n\t\t\t\t\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\t\t\t\t\tif(a + dy[l] >= 0 && a + dy[l] < 12 && b + dx[l] >= 0 && b + dx[l] < 6){\n\t\t\t\t\t\t\t\t\t\tif(c == p[a + dy[l]][b + dx[l]]){\n\t\t\t\t\t\t\t\t\t\t\tque.push(pair<int,int>(a + dy[l],b + dx[l]));\n\t\t\t\t\t\t\t\t\t\t\tp[a + dy[l]][b + dx[l]] = '.';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if(p[a + dy[l]][b + dx[l]] == 'O')\n\t\t\t\t\t\t\t\t\t\t\tp[a + dy[l]][b + dx[l]] = '.';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tfor(j = 10;j >= 0;j--){\n\t\t\t\tfor(k = 0;k < 6;k++){\n\t\t\t\t\tif(p[j][k] != '.' && p[j + 1][k] == '.'){\n\t\t\t\t\t\tfor(l = j;p[l + 1][k] == '.' && l < 11;l++);\n\t\t\t\t\t\tp[l][k] = p[j][k];\n\t\t\t\t\t\tp[j][k] = '.';\n\t\t\t\t\t\tfor(l = 0;l < 12;l++)\n\t\t\t\t\t\t\tprintf(\"%s\\n\",p[l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm++;\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nchar ba[12][6];\n\ntypedef pair<int, int> pii;\nbool visited[2][12][6];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint rec(int y, int x, char c, bool f) {\n//  cout << y << \" \" << x << endl;\n  if (f) ba[y][x] = '*';\n  int res = 1;\n  visited[f][y][x] = 1;\n  REP(k,4) {\n    int yy = y+dy[k];\n    int xx = x+dx[k];\n    if (yy<0||yy>=12||xx<0||xx>=6) continue;\n    if (visited[f][yy][xx]) continue;\n    if (ba[yy][xx] == c) {\n      res += rec(yy,xx,c,f);\n    }\n    if (f&&ba[yy][xx] == 'O')\n      ba[yy][xx] = '*';\n  }\n  return res;\n}\n\nint solve() {\n  bool del = 0;\n\n  memset(visited,0,sizeof(visited));\n  REP(i, 12) {\n    REP(j, 6) {\n      if (ba[i][j] != '.' && ba[i][j] != 'O' && !visited[0][i][j]) {\n        if (rec(i, j, ba[i][j], 0) >= 4) {\n          rec(i, j, ba[i][j], 1);\n          del = 1;\n        }\n      }\n    }\n  }\n  if (!del) return 0;\n\n  REP(j, 6) {\n    vector<char> v;\n    for (int i=11; i>=0; --i) {\n      if (ba[i][j] == '.') break;\n      if (ba[i][j] != '*')\n        v.push_back(ba[i][j]);\n    }\n    for (int i=11; i>=0; --i) {\n      if (11-i < v.size())\n        ba[i][j] = v[11-i];\n      else\n        ba[i][j] = '.';\n    }\n  }\n  // REP(i,12) {\n  //   REP(j,6) {\n  //     cout << ba[i][j];\n  //   }\n  //   cout << endl;\n  // }cout << endl;\n\n  return 1 + solve();\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    REP(i, 12) {\n      REP(j, 6) {\n        cin >> ba[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int H=12,W=6;\n\nint count(char grid[][W+1],int i,int j,char c,bool vis[][W])\n{\n\tif(i<0 || H<=i || j<0 || W<=j || vis[i][j] || grid[i][j]!=c)\n\t\treturn 0;\n\tvis[i][j]=1;\n\tint res=1;\n\tfor(int k=0;k<4;k++)\n\t\tres+=count(grid,i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],c,vis);\n\treturn res;\n}\n\nvoid reset(char grid[][W+1],int i,int j,char c)\n{\n\tif(i<0 || H<=i || j<0 || W<=j || grid[i][j]!=c && grid[i][j]!='O')\n\t\treturn;\n\tif(grid[i][j]=='O')\n\t\tgrid[i][j]='.';\n\telse{\n\t\tgrid[i][j]='.';\n\t\tfor(int k=0;k<4;k++)\n\t\t\treset(grid,i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],c);\n\t}\n}\n\nvoid drop(char grid[][W+1])\n{\n\tfor(int j=0;j<W;j++)\n\t\tfor(int i=H-1,k=H-1;i>=0;i--)\n\t\t\tif(grid[i][j]!='.')\n\t\t\t\tswap(grid[k--][j],grid[i][j]);\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tchar grid[H][W+1];\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin>>grid[i];\n\t\t\n\t\tint res=0;\n\t\tfor(;;res++){\n\t\t\tbool updated=false;\n\t\t\tbool vis[H][W]={};\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(grid[i][j]=='.' || grid[i][j]=='O'\n\t\t\t\t\t|| count(grid,i,j,grid[i][j],vis)<4)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treset(grid,i,j,grid[i][j]);\n\t\t\t\t\tupdated=true;\n\t\t\t\t}\n\t\t\tif(!updated)\n\t\t\t\tbreak;\n\t\t\tdrop(grid);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tchar color;\n\tint num;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\n\nInfo info[12][6];\nchar table[12][7];\nbool check[12][6];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 11 && col >= 0 && col <= 5)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int row = 11; row >= 0; row--){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < 6; col++){\n\t\t\tinfo[row][col].color = table[row][col];\n\t\t\tinfo[row][col].num = -1;\n\t\t}\n\t}\n\n\tbool FLG;\n\tint chain_num = 0;\n\tint adj_row,adj_col;\n\tqueue<Data> Q;\n\tvector<Data> V;\n\n\twhile(true){\n\n\t\tfor(int row = 0; row < 12; row++){\n\t\t\tfor(int col = 0; col < 6; col++)check[row][col] = false;\n\t\t}\n\n\t\tfor(int row = 0; row < 12; row++){\n\t\t\tfor(int col = 0; col < 6; col++){\n\t\t\t\tif(info[row][col].color == '.' || info[row][col].color == 'O' || check[row][col] == true)continue;\n\t\t\t\tV.clear();\n\n\t\t\t\tcheck[row][col] = true;\n\n\t\t\t\tQ.push(Data(row,col));\n\t\t\t\tV.push_back(Data(row,col));\n\n\t\t\t\twhile(!Q.empty()){\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || check[adj_row][adj_col] == true)continue;\n\n\t\t\t\t\t\tif(info[adj_row][adj_col].color == info[row][col].color){\n\t\t\t\t\t\t\tcheck[adj_row][adj_col] = true;\n\t\t\t\t\t\t\tV.push_back(Data(adj_row,adj_col));\n\t\t\t\t\t\t\tQ.push(Data(adj_row,adj_col));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tQ.pop();\n\t\t\t\t}\n\n\t\t\t\tif(V.size() >= 4){\n\t\t\t\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\t\t\t\tinfo[V[i].row][V[i].col].num = (int)V.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFLG = false;\n\n\t\tfor(int row = 0; row < 12; row++){\n\t\t\tfor(int col = 0; col < 6; col++){\n\t\t\t\tif(info[row][col].color != 'O')continue;\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tadj_row = row+diff_row[i];\n\t\t\t\t\tadj_col = col+diff_col[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(info[adj_row][adj_col].num >= 4){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tinfo[row][col].color = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = 0; row < 12; row++){\n\t\t\tfor(int col = 0; col < 6; col++){\n\t\t\t\tif(info[row][col].num >= 4){\n\t\t\t\t\tinfo[row][col].color = '.';\n\t\t\t\t\tFLG = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tchain_num++;\n\n\t\tint tmp_row;\n\n\t\tfor(int col = 0; col < 6; col++){\n\t\t\tfor(int row = 0; row < 11; row++){\n\t\t\t\tif(info[row][col].color == '.'){\n\t\t\t\t\ttmp_row = row+1;\n\t\t\t\t\twhile(tmp_row <= 11 && info[tmp_row][col].color == '.')tmp_row++;\n\n\t\t\t\t\tif(tmp_row == 12)break;\n\n\t\t\t\t\tinfo[row][col].color = info[tmp_row][col].color;\n\t\t\t\t\tinfo[tmp_row][col].color = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = 0; row < 12; row++){\n\t\t\tfor(int col = 0; col < 6; col++){\n\t\t\t\tinfo[row][col].num = -1;\n\t\t\t\tcheck[row][col] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",chain_num);\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 17 52\n\n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<string> data(12);\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,-1,1};\n\nbool iscorrect(int y,int x){\n\tif(y>11 || y<0)return false;\n\tif(x<0 || x>5)return false;\n\treturn true;\n}\n\nint cnt;\nbool done[12][6];\nvoid search(int y,int x,int c){\n\tif(data[y][x] != c)return;\n\t\n\tif(done[y][x])return;\n\tcnt++;\n\tdone[y][x] = true;\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx))search(ny,nx,c);\n\t}\n}\nvoid del(int y,int x,int c){\n\tif(data[y][x] != c && data[y][x] != 'O')return;\n\tdata[y][x] = '.';\n\trep(i,4){\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(iscorrect(ny,nx))del(ny,nx,c);\n\t}\n\t\n}\nvoid down(){\n\trep(x,12){\n\t\trep(w,6){\n\t\t\tfor(int i=0;i+1<12;i++){\n\t\t\t\tif(data[i+1][w] == '.'){\n\t\t\t\t\tswap(data[i+1][w],data[i][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \n\nbool iscell(int i,int j){\n\treturn data[i][j] != 'O' && data[i][j] != '.';\n}\nint main(){\n\tint n;\n\tcin >>n;\n\twhile(n--){\n\t\trep(i,12){cin >> data[i];}\n\t\tdown();\n\t\t\n\t\t/*rep(i,12){\n\t\t\trep(j,6)cout << data[i][j];\n\t\t\tcout << endl;\n\t\t}*/\n\t\tvector<string> prev = data;\n\t\trep(O,73){\n\t\t\trep(i,12)rep(j,6){\n\t\t\t\tif(iscell(i,j)){\n\t\t\t\t\trep(p,12)rep(q,6)done[p][q] = false;\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tsearch(i,j,data[i][j]);\n\t\t\t\t\t//cerr << cnt << endl;\n\t\t\t\t\tif(cnt>=4){\n\t\t\t\t\t\tdel(i,j,data[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdown();\n\t\t\tif(prev == data){\n\t\t\t\tcout << O << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = data;\n\t\t}\n\t\t/*rep(i,12){\n\t\t\trep(j,6)cout << data[i][j];\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define H 12\n#define W 6\ntypedef vector <string> VS;\n\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\nVS field;\n\nint calc( char c, int row, int col )\n{\n\tint s = 0;\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tint nr = row + dr[i];\n\t\tint nc = col + dc[i];\n\t\tif ( nr < 0 || nr >= H || nc < 0 || nc >= W ) continue;\n\t\tif ( c == field[nr][nc] )\n\t\t{\n\t\t\tfield[nr][nc] = '.';\n\t\t\ts += calc( c, nr, nc );\n\t\t\tfield[nr][nc] = c;\n\t\t}\n\t}\n\treturn 1 + s;\n}\n\nvoid remove( char c, int row, int col )\n{\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tint nr = row + dr[i];\n\t\tint nc = col + dc[i];\n\t\tif ( nr < 0 || nr >= H || nc < 0 || nc >= W ) continue;\n\t\tif ( 'O' == field[nr][nc] ) field[nr][nc] = '.';\n\t\tif ( c == field[nr][nc] )\n\t\t{\n\t\t\tfield[nr][nc] = '.';\n\t\t\tremove( c, nr, nc );\n\t\t}\n\t}\n}\n\nbool check()\n{\n\tbool removed = false;\n\tfor ( int i = 0; i < H; i++ )\n\t{\n\t\tfor ( int j = 0; j < W; j++ )\n\t\t{\n\t\t\tif ( field[i][j] == 'O' || field[i][j] == '.' ) continue;\n\t\t\tchar c = field[i][j];\n\t\t\tfield[i][j] = '.';\n\t\t\tif ( calc( c, i, j ) >= 4 )\n\t\t\t{\n\t\t\t\tremove( c, i, j );\n\t\t\t\tremoved = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfield[i][j] = c;\n\t\t}\n\t}\n\treturn removed;\n}\n\nbool update()\n{\n\tbool more = false;\n\tbool updated = true;\n\twhile ( updated )\n\t{\n\t\tupdated = false;\n\t\tfor ( int i = 0; i + 1 < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\tif ( field[i][j] != '.' && field[i+1][j] == '.' )\n\t\t\t\t{\n\t\t\t\t\tswap( field[i][j], field[i+1][j] );\n\t\t\t\t\tupdated = true;\n\t\t\t\t\tmore = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn more;\n}\n\nint main( void )\n{\n\tint n;\n\tcin >> n;\n\tcin.clear();\n\tcin.ignore();\n\n\tfor ( int lpc = 0; lpc < n; lpc++ )\n\t{\n\t\tfield = VS( H );\n\t\tfor ( int i = 0; i < H; i++ ) cin >> field[i];\n\n\t\tint answer = 0;\n\t\tdo {\n\t\t\tif ( check() ) answer++;\n\t\t} while ( update() );\n\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<queue>\n#include<string.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nchar cmap[13][13];\nbool used[13][13];\nint imap[13][13];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nint Cnt = 0;\n\nvoid dfs(int x,int y,char c,int cnt)\n{\n  used[y][x] = true; \n  int fcnt = 0;\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(0<=nx&&nx<6&&0<=ny&&ny<12&&cmap[ny][nx] == c && !used[ny][nx]){\n      fcnt++; Cnt++;\n      dfs(nx,ny,c,cnt+1);\n    }\n  }\n  if(fcnt == 0)imap[y][x] = Cnt;\n}\n\nvoid erase(int x,int y,char c)\n{\n  used[y][x] = true;\n  cmap[y][x] = '.';\n\n  queue<P> que;\n  que.push(P(x,y));\n\n  while(!que.empty())\n    {\n      P p = que.front(); que.pop();\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.F+dx[i],ny = p.S+dy[i];\n\t  if(0<=nx&&nx<6&&0<=ny&&ny<12&& (cmap[ny][nx] == c || cmap[ny][nx] == 'O') && !used[ny][nx])\n\t    {\n\t      cmap[ny][nx] = '.';\n\t      used[ny][nx] = true;\n\t      que.push(P(nx,ny));\n\t    }\n\t}\n    }\n}\n\nvoid display()\n{\n\n  for(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << cmap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\nfor(int i=0;i<12;i++)\n    {\n      for(int j=0;j<6;j++)\n\t{\n\t  cout << imap[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n  cout << endl;\n}\n\n\nvoid drop(int x,int y)\n{\n  //cout << \"x = \" << x << \", y = \" << y << endl;\n  int st,ed;\n  st = y;\n  ed = -1;\n  for(int i=y;i>=0;i--)\n    {\n      if(ed == -1 && cmap[i][x] != '.')\n\t{\n\t  ed = i+1;\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] =\" << cmap[st+ed-(i+1)][x] << \", cmpa[\"<<i<<\"][x] = \"<<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] != '.')\n\t{\n\t  //cout << \"cmap[\"<<st-ed+(i+1)<<\"][x] = \" << cmap[st+ed-(i+1)][x] << \", cmap[\"<<i<<\"][x] = \" <<  cmap[i][x] << endl;\n\t  cmap[st-ed+(i+1)][x] = cmap[i][x];\n\t  cmap[i][x] = '.';\n\t}\n      else if(ed != -1 && cmap[i][x] == '.')\n\t{\n\t  st = i;\n\t  ed = -1;\n\t}      \n\n    }\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  while(N-- > 0)\n    {\n      for(int i=0;i<12;i++)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  for(int j=0;j<s.length();j++)\n\t    {\n\t      cmap[i][j] = s[j];\n\t      used[i][j] = false;\n\t      imap[i][j] = -1;\n\t    }\n\t}\n\n      int cnt = 0;\n      while(true)\n\t{\n\t  //display();\n\t  int increase = 0;\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)\n\t\t\t\t {\n\t\t\t\t   imap[i][j] = -1;\n\t\t\t\t   used[i][j] = false;\n\t\t\t\t }\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(cmap[i][j] != '.' && cmap[i][j] != 'O' && !used[i][j])\n\t\t    {\n\t\t      Cnt=1;\n\t\t      dfs(j,i,cmap[i][j],1); //最大何マスつながっているか\n\t\t    }\n\t\t}\n\t    }\n\t\n\t  memset(used,0,sizeof(used));\n\t  for(int i=0;i<12;i++)for(int j=0;j<6;j++)used[i][j] = false;\n\t  for(int i=0;i<12;i++)\n\t    {\n\t      for(int j=0;j<6;j++)\n\t\t{\n\t\t  if(!used[i][j] && imap[i][j] >= 4){\n\t\t    increase++;\n\t\t    erase(j,i,cmap[i][j]);\n\t\t  }\n\t\t}\n\t    }\n\t  //display();\n\t  if(increase == 0)\n\t    {\n\t      break;\n\t    }\n\t  cnt++;\n\n\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      for(int j=11;j>=0;j--)\n\t\t{\n\t\t  if(cmap[j][i] == '.')\n\t\t    {\n\t\t      drop(i,j);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t    }\n\n\n\n\n\n\t}\n\n      cout<< cnt << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <string>\n#include <map>\n#include <cctype>\nusing namespace std;\n\nstring area[12];\nbool used[12][6];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\n\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nint count(int i, int j, char c){\n\tint counter = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tif(i+dy[k] >= 0 && i+dy[k] < 12 && j+dx[k] >= 0 && j+dx[k] < 6 \n\t\t\t&& area[i+dy[k]][j+dx[k]] == c && !used[i+dy[k]][j+dx[k]]){\n\t\t\tcounter += count(i+dy[k], j+dx[k], c);\n\t\t}\n\t}\n\treturn counter;\n}\n\nvoid rem(int i, int j, char c){\n\tarea[i][j] = '.';\n\tfor(int k = 0; k < 4; k++){\n\t\tint y2 = i+dy[k], x2 = j+dx[k];\n\t\tif(y2 >= 0 && y2 < 12 && x2 >= 0 && x2 < 6){\n\t\t\tif(area[y2][x2] == c) rem(y2, x2, c);\n\t\t\tif(area[y2][x2] == 'O') area[y2][x2] = '.';\n\t\t}\n\t}\n}\n\nbool puyo_delete(){\n\tbool f = false;\n\tfor(int i = 0; i < 12; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tif(area[i][j] != '.' && area[i][j] != 'O'){\n\t\t\t\tfor(int k = 0; k < 12; k++){\n\t\t\t\t\tfor(int l = 0; l < 6; l++){\n\t\t\t\t\t\tused[k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count(i, j, area[i][j]) >= 4){\n\t\t\t\t\trem(i, j, area[i][j]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid puyo_drop(){\n\tbool f = true;\n\twhile(f){\n\t\tf = false;\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif(area[i][j] != '.' && area[i+1][j] == '.'){\n\t\t\t\t\tarea[i+1][j] = area[i][j];\n\t\t\t\t\tarea[i][j] = '.';\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 12; j++){\n\t\t\tcin >> area[j];\n\t\t}\n\t\tint count = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = puyo_delete();\n\t\t\tpuyo_drop();\n\t\t\tif(update) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nenum{AKI,RED,GREEN,BLUE,YELLOW,PURPLE,JAMA};\n\nint recmap[6][12];\nvector<int> map[6];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\ntypedef pair<int,int> P;\n\nint rec(int fillv,int x,int y,int col){\n     if( x<0 || x>5 || y<0 || y > 11) return 0;\n     if(recmap[x][y]>-1||map[x][y]!=col) return 0;\n     recmap[x][y]=fillv;\n     int sum=0;\n     for(int i=0;i<4;i++)sum+=rec(fillv,x+dx[i],y+dy[i],col);\n     ++sum;\n     return sum;\n}\nvoid recclear(){\n     for(int i=0;i<12;i++){\n\t  for(int j=0;j<6;j++){\n\t       recmap[j][i]=-1;\n\t  }\n     }\n}\n\nint main(){\n     int T;\n     cin>>T;\n     for(int time=0;time<T;time++){\n\t  for(int i=0;i<6;i++){\n\t       map[i].resize(12,0);\n\t  }\n\t  for(int i=11;i>-1;i--){\n\t       for(int j=0;j<6;j++){\n\t\t    char a;\n\t\t    cin>>a;\n\t\t    switch(a){\n\t\t    case 'R':\n\t\t\t map[j][i]=RED;\n\t\t\t break;\n\t\t    case 'G':\n\t\t\t map[j][i]=GREEN;\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t map[j][i]=BLUE;\n\t\t\t break;\n\t\t    case 'Y':\n\t\t\t map[j][i]=YELLOW;\n\t\t\t break;\n\t\t    case 'P':\n\t\t\t map[j][i]=PURPLE;\n\t\t\t break;\n\t\t    case 'O':\n\t\t\t map[j][i]=JAMA;\n\t\t\t break;\n\t\t    case '.':\n\t\t\t map[j][i]=AKI;\n\t\t    }\n\t       }\n\t  }\n\t  int count=0;\n\t  while(1){\n\t       vector<int> dels;\n\t       recclear();\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(map[i][j]==AKI||map[i][j]==JAMA)continue;\n\t\t\t if(rec(i+j*6,i,j,map[i][j])>3){\n\t\t\t      dels.push_back(i+j*6);\n\t\t\t }\n\t\t    }\n\t       }\n\t       if(dels.empty())break;\n\t       count++;\n\t       bool isdel[6][12]={};\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t for(int k=0;k<dels.size();k++){\n\t\t\t      if(recmap[i][j]==dels[k])isdel[i][j]=true;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(map[i][j]==JAMA){\n\t\t\t      bool flag=false;\n\t\t\t      for(int k=0;k<4;k++){\n\t\t\t\t   if(i+dx[k]<0||i+dx[k]>5||j+dy[k]<0||j+dy[k]>11)continue;\n\t\t\t\t   if(isdel[i+dx[k]][j+dy[k]]){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t   }\n\t\t\t      }\n\t\t\t      if(flag)isdel[i][j]=true;\n\t\t\t      }\n\t\t    }\n\t       }\n\t       //vector<P> deletelist;\n\t       for(int i=0;i<6;i++){\n\t\t    for(int j=0;j<12;j++){\n\t\t\t if(isdel[i][j]){\n\t\t\t      map[i][j]=AKI;\n\t\t\t }\n\t\t    }\n\t       }\n\t       for(int i=0;i<6;i++){\n\t\t    vector<int>::iterator endit=remove(map[i].begin(),map[i].end(),0);\n\t\t    map[i].resize(12,0);\n\t\t    fill(endit,map[i].end(),0);\n\t       }\n\t       /*for(int i=0;i<6;i++){\n\t\t    vector<int>::iterator itr=map[i].begin();\n\t\t    while(itr!=map[i].end()){\n\t\t\t cout<<*itr;\n\t\t\t itr++;\n\t\t    }\n\t\t    cout<<endl;\n\t       }\n\t       cout<<endl;*/\n\t  }\n\t  cout<<count<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n\nconst int blank = 0;\nconst int red = 1;\nconst int green = 2;\nconst int blue = 3;\nconst int yellow = 4;\nconst int purple = 5;\nconst int  ojyama = -1;\n\nint field[8][14];\nbool chk[8][14];\nbool death[8][14];\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\n\nint is_sameblocks(int px,int py){\n  stack<int> st;\n  st.push(py*8+px);\n  int s = 0;\n  while(!st.empty()){\n    px = st.top()%8;\n    py = st.top()/8;\n    chk[px][py] = true;\n    st.pop();\n    s++;\n    for(int i=0;i<4;i++){\n      if(!chk[px+dx[i]][py+dy[i]]&&field[px+dx[i]][py+dy[i]]==field[px][py])\n\tst.push((py+dy[i])*8+px+dx[i]);\n    }\n  }\n  return s;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<string> puyo(12);\n  for(;n>0;n--){\n\n    for(int i=0;i<12;i++){\n      cin>>puyo[i];\n    }\n    for(int x=0;x<8;x++){\n      field[x][0] = blank;\n      field[x][13] = blank;\n    }\n    for(int y=0;y<14;y++){\n      field[0][y] = blank;\n      field[7][y] = blank;\n    }\n\n    //input\n    for(int y=0;y<12;y++){\n      for(int x=0;x<6;x++){\n\tswitch(puyo[y][x]){\n\tcase'R':\n\t  field[x+1][y+1] = red;\n\t  break;\n\tcase'G':\n\t  field[x+1][y+1] = green;\n\t  break;\n\tcase'B':\n\t  field[x+1][y+1] = blue;\n\t  break;\n\tcase'Y':\n\t  field[x+1][y+1] = yellow;\n\t  break;\n\tcase'P':\n\t  field[x+1][y+1] = purple;\n\t  break;\n\tcase'O':\n\t  field[x+1][y+1] = ojyama;\n\t  break;\n\tcase'.':\n\t  field[x+1][y+1] = blank;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      }\n    }\n    int chain = 0;\n    while(true){\n    //erase\n      bool erase = false;\n      for(int y=1;y<13;y++){\n\tfor(int x=1;x<7;x++){\n\t  for(int k=0;k<112;k++)\n\t    chk[k%8][k/8] = false;\n\t  if(field[x][y] > 0&&is_sameblocks(x,y)>=4)\n\t    death[x][y] = true;\n\t  else\n\t    death[x][y] = false;\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(field[x][y] == ojyama){\n\t    for(int i=0;i<4;i++){\n\t      if(death[x+dx[i]][y+dy[i]])\n\t\tfield[x][y] = blank;\n\t    }\n\t  }\n\t}\n      }\n      for(int y=12;y>0;y--){\n\tfor(int x=1;x<7;x++){\n\t  if(death[x][y]){\n\t    field[x][y] = blank;\n\t    erase = true;\n\t  }\n\t}\n      }\n      \n      if(!erase)break;\n    //fall\n      while(erase){\n\terase = false;\n\tfor(int y=12;y>0;y--){\n\t  for(int x=1;x<7;x++){\n\t    if(field[x][y] == blank && field[x][y-1]!=blank){\n\t      field[x][y] = field[x][y-1];\n\t      field[x][y-1] = blank;\n\t      erase = true;\n\t    }\n\t  }\n\t}\n      }\n      chain++;\n    }    \n    cout<<chain<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst char p[7] = {'R','G','B','Y','P','O','.'};\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nstring f[12];\nint cnt = 0;\n\nvoid debug(){\n\tcout << endl;\n\tfor(int y=0 ; y<12 ; ++y )\n\t\tcout << f[y] << endl;\n\tcout << endl;\n}\n\nvoid downPuyo(int x,int y){\n\tchar t = f[y+1][x] ;\n\tf[y+1][x] = f[y][x];\n\tf[y][x] = t;\n\t\n\tif( y+1 != 11 && f[y+2][x] == '.' ){\n\t\tdownPuyo( x , y+1 );\n\t}\n}\n\nvoid checkPuyo(int x,int y,char color){\n\tf[y][x] += 'a' - 'A';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\t++cnt;\n\t\t\tcheckPuyo( mx , my , color );\n\t\t}\n\t}\n}\nvoid eracePuyo(int x,int y,char color){\n\tf[y][x] = '.';\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\n\t\tif( mx < 0 || my < 0 || mx >= 6 || my >= 12 )\n\t\t\tcontinue;\n\n\t\tif( f[my][mx] == color ){\n\t\t\teracePuyo( mx , my , color );\n\t\t}\n\t\tif( f[my][mx] == 'O' ){\n\t\t\tf[my][mx] = '.';\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, chain;\n\t\n\tcin >> n;\n\tfor(int i=0 ; i<n ; ++i ){\n\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\tcin >> f[y];\n\t\t}\n\n\t\t//ú»\n\t\tbool flag = true;\n\t\tchain = 0;\n\n\t\t//Á¦éÕæªÈ­ÈéÜÅ[v\n\t\twhile( flag ){\n\t\t\tflag = false;\n\n\t\t\t/*cout << \"Á¦éO\" << endl;\n\t\t\tdebug();\n\t\t\tcout << endl;*/\n\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\t//àµFÕæ¾Á½ç\n\t\t\t\t\t\tif( f[y][x] == p[i] ){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tcheckPuyo( x , y , p[i] );\n\t\t\t\t\t\t\t//àµSÂÈã­ÁÂ¢Ä¢½ç¯·\n\t\t\t\t\t\t\tif( cnt >= 4 ){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\teracePuyo( x , y , p[i] + ('a'-'A') );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//ú»\n\t\t\tfor(int i=0 ; i<5 ; ++i ){\n\t\t\t\tfor(int y=0 ; y<12 ; ++y ){\n\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\tchar c = p[i] + ('a'-'A');\n\t\t\t\t\t\tif( f[y][x] == c ){\n\t\t\t\t\t\t\tf[y][x] -= ('a'-'A');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*cout << \"Á¦½ã\" << endl;\n\t\t\tdebug();\n\t\t\tcout << endl;*/\n\n\t\t\t//Á¦éÕæª éÆ«\n\t\t\tif( flag ){\n\t\t\t\tchain++;\n\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0 ; i<6 ; ++i ){\n\t\t\t\t\tfor(int y=10 ; y>=0 ; --y ){\n\t\t\t\t\t\tfor(int x=0 ; x<6 ; ++x ){\n\t\t\t\t\t\t\tif( f[y][x] == p[i] && f[y+1][x] == '.' ){\n\t\t\t\t\t\t\t\tdownPuyo( x , y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*cout << \"ºã\" << endl;\n\t\t\t\tdebug();\n\t\t\t\tcout << endl;*/\n\t\t\t}\t\t\n\t\t}\n\t\tcout << chain << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nvoid dfs(int sx,int sy,char stage[12][6],bool toErase[12][6],char color,int* count){\n  if(toErase[sy][sx]) return;\n  toErase[sy][sx] = true;\n  (*count)++;\n  for(int i=0;i<4;i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n \n    if(dx < 0 || dx >= 6 \n       || dy < 0 || dy >= 12) continue;\n    if(stage[dy][dx] != color) continue;\n         \n    dfs(dx,dy,stage,toErase,color,count);\n  }\n}\n \nbool markBlock(bool toErase[12][6],char stage[12][6]){\n \n  bool res = false;\n  for(int y=0;y<12;y++){\n    for(int x=0;x<6;x++){\n      if(stage[y][x] == '.'\n\t || stage[y][x] == 'O') continue;\n \n      if(!toErase[y][x]){\n\tchar color = stage[y][x];\n\tint count = 0;\n\tbool tmp[12][6];\n\tmemcpy(tmp,toErase,sizeof(bool)*12*6);\n \n\tdfs(x,y,stage,toErase,color,&count);\n\tif(count < 4){\n\t  memcpy(toErase,tmp,sizeof(bool)*12*6);\n\t}\n\telse{\n\t  res = true;\n\t}\n      }\n    }\n  }\n \n  return res;\n}\n \nvoid eraseBlock(bool toErase[12][6],char stage[12][6]){\n  for(int x=0;x<6;x++){\n    for(int y=0;y<12;y++){\n      if(stage[y][x] == '.'){\n\ttoErase[y][x] = true;\n\tcontinue;\n      }\n      if(stage[y][x] == 'O'){\n\tfor(int i=0;i<4;i++){\n\t  int dx = x + tx[i];\n\t  int dy = y + ty[i];\n\t  if(dx < 0 || dx >= 6 \n\t     || dy < 0 || dy >= 12) continue;\n\t  if(toErase[dy][dx] == true\n                        && stage[dy][dx] != '.'\n\t     && stage[dy][dx] != 'O'){\n\t    toErase[y][x] = true;\n\t  }\n\t}\n      }\n    }\n  }\n \n  char nextStage[12][6];\n  for(int x=0;x<6;x++){\n    queue<char> que; \n    for(int y=12-1;y>=0;y--){\n      if(!toErase[y][x]){\n\tque.push(stage[y][x]);\n      }\n    }\n \n    int idx = 12-1;\n    while(!que.empty()){\n      nextStage[idx][x] = que.front();\n      que.pop();\n      idx--;\n    }\n    while(idx >= 0){\n      nextStage[idx][x] = '.';\n      idx--;\n    }\n  }\n \n  memcpy(stage,nextStage,sizeof(char)*12*6);\n}\n \nvoid printStage(char stage[12][6]){\n  for(int y=0;y<12;y++){\n    for(int x=0;x<6;x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n \nint main(){\n  int n;\n \n  while(~scanf(\"%d\",&n)){\n    for(int i=0;i<n;i++){\n      char stage[12][6];\n      bool toErase[12][6];\n      memset(toErase,0,sizeof(toErase));\n \n      for(int y=0;y<12;y++){\n\tstring str;\n\tcin >> str;\n\tfor(int x=0;x<6;x++){\n\t  stage[y][x] = str[x];\n\t}\n      }\n \n      //printStage(stage);\n      int res = 0;\n      while(markBlock(toErase,stage)){\n\teraseBlock(toErase,stage);\n\tmemset(toErase,0,sizeof(toErase));\n\tres++;\n\t//printStage(stage);\n      }\n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar str[15][10];\nint UF[100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tfor(int i=0;i<12;i++)scanf(\"%s\",str[i]);\n\t\tbool chg;\n\t\tint ret=0;\n\t\tdo{\n\t\t\tchg=false;\n\t\t\tfor(int i=0;i<72;i++)UF[i]=-1;\n\t\t\tfor(int i=0;i<12;i++)for(int j=0;j<6;j++){\n\t\t\t\tif(str[i][j]=='.'||str[i][j]=='O')continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<12&&0<=j+dy[k]&&j+dy[k]<6&&str[i][j]==str[i+dx[k]][j+dy[k]]){\n\t\t\t\t\t\tUNION(i*6+j,(i+dx[k])*6+j+dy[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(str[i][j]=='.')continue;\n\t\t\t\t\tif(str[i][j]=='O'){\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<12&&0<=j+dy[k]&&j+dy[k]<6&&UF[FIND((i+dx[k])*6+j+dy[k])]<=-4){\n\t\t\t\t\t\t\t\tstr[i][j]='.';chg=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(UF[FIND(i*6+j)]<=-4){str[i][j]='.';chg=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint at=11;\n\t\t\t\tfor(int j=11;j>=0;j--){\n\t\t\t\t\tif(str[j][i]!='.'){\n\t\t\t\t\t\tstr[at--][i]=str[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<at;j++)str[j][i]='.';\n\t\t\t}\n\t\t\tif(chg)ret++;\n\t\t}while(chg);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 12\n#define W 6\nusing namespace std;\nbool del[H][W],used[H][W];\nstring s[H];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nvoid mark(){\n  int cnt=0;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(used[i][j])cnt++;\n  if(cnt<4)return;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(used[i][j])del[i][j]=true;\n}\n\nvoid mark2(){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++){\n      if(s[i][j]!='O')continue;\n      for(int k=0;k<4;k++){\n\tint ni=i+dy[k],nj=j+dx[k];\n\tif(ni<0||nj<0||H<=ni||W<=nj)continue;\n\tif(del[ni][nj]&&s[ni][nj]!='O')del[i][j]=true;\n      }\n    }\n}\n\nvoid dfs(int y,int x,char c){\n  used[y][x]=true;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0||H<=ny||W<=nx)continue;\n    if(used[ny][nx])continue;\n    if(s[ny][nx]==c)dfs(ny,nx,c);\n  }\n}\n\nbool Del(){\n  bool res=false;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(del[i][j])s[i][j]='.',res=true;\n  while(1){\n    int flag=0;\n    for(int i=H-1;i>=1;i--)\n      for(int j=0;j<W;j++)\n\tif(s[i][j]=='.'&&s[i-1][j]!='.')\n\t  swap(s[i][j],s[i-1][j]),flag=1;\n    if(!flag)break;\n  }\n  return res;\n}\n\nint solve(){\n  int res=0;\n  while(1){\n    memset(del,0,sizeof(del));\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++){\n\tif(del[i][j])continue;\n\tif(s[i][j]=='.')continue;\n\tif(s[i][j]=='O')continue;\n\tmemset(used,0,sizeof(used));\n\tdfs(i,j,s[i][j]);\n\tmark();\n      }\n    mark2();\n    if(Del())res++;\n    else break;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    for(int i=0;i<H;i++)cin>>s[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint cnt;\nchar f[16][16];\nbool v[16][16];\n\nint dx[] = { 0, 0, 1,-1};\nint dy[] = { 1,-1, 0, 0};\n\nvoid chk(int x, int y, char c)\n{\n\tif(c!=f[y][x]) return;\n\tv[y][x] = 1;\n\n\tcnt++;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\n\t\tif(nx<0 || 6<=nx || ny<0 || 12<=ny) continue;\n\t\tif(v[ny][nx]) continue;\n\n\t\tchk(nx, ny, c);\n\t}\n}\n\nvoid ers(int x, int y, char c)\n{\n\tif(c!=f[y][x])\n\t{\n\t\tif(f[y][x] == 'O')\n\t\t{\n\t\t\tf[y][x] = '.';\n\t\t}\n\t\treturn;\n\t}\n\tf[y][x] = '.';\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\n\t\tif(nx<0 || 6<=nx || ny<0 || 12<=ny) continue;\n\n\t\ters(nx, ny, c);\n\t}\n}\n\nvoid g(int x)\n{\n\tint b=12;\n\n\tfor(int y=11; y>=0; y--)\n\t{\n\t\tif(f[y][x]!='.')\n\t\t{\n\t\t\tb--;\n\t\t\tf[b][x] = f[y][x];\n\t\t\tif(b!=y) f[y][x] = '.';\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\twhile(N--)\n\t{\n\t\tfor(int y=0; y<12; y++)\n\t\t{\n\t\t\tcin >> f[y];\n\t\t}\n\n\t\tint  ans=0;\n\t\tbool flag;\n\n\t\tdo\n\t\t{\n\t\t\tflag=false;\n\n\t\t\tfor(int y=0; y<12; y++)\n\t\t\tfor(int x=0; x<6;  x++)\n\t\t\t{\n\t\t\t\tif(f[y][x]=='.' || f[y][x]=='O') continue;\n\n\t\t\t\tcnt=0;\n\t\t\t\tmemset(v,0,sizeof(v));\n\t\t\t\tchk(x,y,f[y][x]);\n\n\t\t\t\tif(cnt>=4)\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t\ters(x,y,f[y][x]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int x=0; x<6; x++)\n\t\t\tg(x);\n\n\t\t\tif(flag) ans++;\n\t\t}\n\t\twhile(flag);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n\nvector< vector<char> >V,C;\nint count=0;\n\nbool in(int x,int y){\n\treturn x>=0 && y>=0 && x<6 && y<12;\n}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nvoid kesu(int x,int y,char col){\n\tif(C[y][x]!=col){\n\t\tif(C[y][x]=='O')\n\t\t\tC[y][x]='.';\n\t\treturn;\n\t}\n\tcount++;\n\tC[y][x]='.';\n\tfor(int d=0;d<4;d++){\n\t\tif(in(x+dx[d],y+dy[d]))\n\t\t\tkesu(x+dx[d],y+dy[d],col);\n\t}\n}\n\nvoid otosu(){\n\tfor(int y=10;y>=0;y--){\n\t\tfor(int x=0;x<6;x++){\n\t\t\tif(V[y][x]=='.')\n\t\t\t\tcontinue;\n\t\t\tint ty=y;\n\t\t\tchar temp=V[y][x];\n\t\t\tV[y][x]='.';\n\t\t\twhile(ty<=11 && V[ty][x]=='.')\n\t\t\t\tty++;\n\t\t\tty--;\n\t\t\tV[ty][x]=temp;\n\t\t}\n\t}\n}\n\nvoid print(){\n\tfor(int y=0;y<12;y++){\n\t\tfor(int x=0;x<6;x++){\n\t\t\tcout<<V[y][x];\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n\nvoid solve()\n{\n\tV.clear();\n\tV.resize(12,vector<char>(6));\n\tfor(int y=0;y<12;y++){\n\t\tstring now;\n\t\tcin>>now;\n\t\tfor(int x=0;x<6;x++)\n\t\t\tV[y][x]=now[x];\n\t}\n\tbool update=true;\n\tint res=-1;\n\twhile(update){\n\t\tupdate=false;\n\t\tres++;\n\t\tfor(int y=0;y<12;y++){\n\t\t\tfor(int x=0;x<6;x++){\n\t\t\t\tif(V[y][x]=='.' || V[y][x]=='O')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcount=0;\n\t\t\t\tC=V;\n\t\t\t\tkesu(x,y,V[y][x]);\n\t\t\t\tif(count>=4){\n\t\t\t\t\tV=C;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\totosu();\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\tint t;\n\tcin>>t;\n\tfor(int i=0;i<t;i++)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\n\nvoid dfs(int sx,int sy,char stage[12][6],bool toErase[12][6],char color,int* count){\n\tif(toErase[sy][sx]) return;\n\ttoErase[sy][sx] = true;\n\t(*count)++;\n\tfor(int i=0;i<4;i++){\n\t\tint dx = sx + tx[i];\n\t\tint dy = sy + ty[i];\n\n\t\tif(dx < 0 || dx >= 6 \n\t\t\t|| dy < 0 || dy >= 12) continue;\n\t\tif(stage[dy][dx] != color) continue;\n\t\t\n\t\tdfs(dx,dy,stage,toErase,color,count);\n\t}\n}\n\nbool markBlock(bool toErase[12][6],char stage[12][6]){\n\n\tbool res = false;\n\tfor(int y=0;y<12;y++){\n\t\tfor(int x=0;x<6;x++){\n\t\t\tif(stage[y][x] == '.'\n\t\t\t\t|| stage[y][x] == 'O') continue;\n\n\t\t\tif(!toErase[y][x]){\n\t\t\t\tchar color = stage[y][x];\n\t\t\t\tint count = 0;\n\t\t\t\tbool tmp[12][6];\n\t\t\t\tmemcpy(tmp,toErase,sizeof(bool)*12*6);\n\n\t\t\t\tdfs(x,y,stage,toErase,color,&count);\n\t\t\t\tif(count < 4){\n\t\t\t\t\tmemcpy(toErase,tmp,sizeof(bool)*12*6);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tres = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid eraseBlock(bool toErase[12][6],char stage[12][6]){\n\tfor(int x=0;x<6;x++){\n\t\tfor(int y=0;y<12;y++){\n\t\t\tif(stage[y][x] == '.'){\n\t\t\t\ttoErase[y][x] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(stage[y][x] == 'O'){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint dx = x + tx[i];\n\t\t\t\t\tint dy = y + ty[i];\n\t\t\t\t\tif(dx < 0 || dx >= 6 \n\t\t\t\t\t\t|| dy < 0 || dy >= 12) continue;\n\t\t\t\t\tif(toErase[dy][dx] == true\n\t\t\t\t\t\t&& stage[dy][dx] != '.'\n\t\t\t\t\t\t&& stage[dy][dx] != 'O'){\n\t\t\t\t\t\t\ttoErase[y][x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tchar nextStage[12][6];\n\tfor(int x=0;x<6;x++){\n\t\tqueue<char> que; \n\t\tfor(int y=12-1;y>=0;y--){\n\t\t\tif(!toErase[y][x]){\n\t\t\t\tque.push(stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tint idx = 12-1;\n\t\twhile(!que.empty()){\n\t\t\tnextStage[idx][x] = que.front();\n\t\t\tque.pop();\n\t\t\tidx--;\n\t\t}\n\t\twhile(idx >= 0){\n\t\t\tnextStage[idx][x] = '.';\n\t\t\tidx--;\n\t\t}\n\t}\n\n\tmemcpy(stage,nextStage,sizeof(char)*12*6);\n}\n\nvoid printStage(char stage[12][6]){\n\tfor(int y=0;y<12;y++){\n\t\tfor(int x=0;x<6;x++){\n\t\t\tprintf(\"%c\",stage[y][x]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tint n;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar stage[12][6];\n\t\t\tbool toErase[12][6];\n\t\t\tmemset(toErase,0,sizeof(toErase));\n\n\t\t\tfor(int y=0;y<12;y++){\n\t\t\t\tstring str;\n\t\t\t\tcin >> str;\n\t\t\t\tfor(int x=0;x<6;x++){\n\t\t\t\t\tstage[y][x] = str[x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//printStage(stage);\n\t\t\tint res = 0;\n\t\t\twhile(markBlock(toErase,stage)){\n\t\t\t\teraseBlock(toErase,stage);\n\t\t\t\tmemset(toErase,0,sizeof(toErase));\n\t\t\t\tres++;\n\t\t\t\t//printStage(stage);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nchar m[14][9];\n\nvoid dfs(int i, int j, vector<pair<int,int> >&v, vector<pair<int,int> >&w){\n  v.push_back(make_pair(i,j));\n  if(m[i-1][j]==m[i][j]&&find(v.begin(),v.end(),make_pair(i-1,j))==v.end())dfs(i-1,j,v,w);\n  if(m[i+1][j]==m[i][j]&&find(v.begin(),v.end(),make_pair(i+1,j))==v.end())dfs(i+1,j,v,w);\n  if(m[i][j-1]==m[i][j]&&find(v.begin(),v.end(),make_pair(i,j-1))==v.end())dfs(i,j-1,v,w);\n  if(m[i][j+1]==m[i][j]&&find(v.begin(),v.end(),make_pair(i,j+1))==v.end())dfs(i,j+1,v,w);\n  if(m[i-1][j]=='O'&&find(w.begin(),w.end(),make_pair(i-1,j))==w.end())w.push_back(make_pair(i-1,j));\n  if(m[i+1][j]=='O'&&find(w.begin(),w.end(),make_pair(i+1,j))==w.end())w.push_back(make_pair(i+1,j));\n  if(m[i][j-1]=='O'&&find(w.begin(),w.end(),make_pair(i,j-1))==w.end())w.push_back(make_pair(i,j-1));\n  if(m[i][j+1]=='O'&&find(w.begin(),w.end(),make_pair(i,j+1))==w.end())w.push_back(make_pair(i,j+1));\n}\n\nvoid main2(){\n  int i,j,k,r=0,f;\n  memset(m,'X',sizeof(m)); //Iron Puyo\n  for(i=1;i<13;i++)scanf(\"%s\",m[i]+1);\n  for(i=0;i<14;i++)m[i][7]='X',m[i][8]=0;\n  for(i=1;i<7;i++)m[0][i]='.';\n  for(;;){\n    f=0;\n    vector<pair<int,int> >v,w;\n    for(i=1;i<13;i++)\n      for(j=1;j<7;j++){\n        if(m[i][j]=='R'||m[i][j]=='G'||m[i][j]=='B'||m[i][j]=='Y'||m[i][j]=='P'){\n          dfs(i,j,v,w);\n          if(v.size()>3){\n            f=1;\n            for(k=0;k<v.size();k++)\n              m[v[k].first][v[k].second]='.';\n            for(k=0;k<w.size();k++)\n              m[w[k].first][w[k].second]='.';\n          }\n          v.clear(),w.clear();\n        }\n      }\n    if(f){\n      for(j=1;j<7;j++)\n        for(i=12;i;i--){\n          for(k=i;k&&m[k][j]=='.';k--);\n          swap(m[i][j],m[k][j]);\n        }\n      r++;\n      continue;\n    }\n    break;\n  }\n  printf(\"%d\\n\",r);\n}\nmain(){int n;for(scanf(\"%d\",&n);n;n--)main2();}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                scanf(\" %c\", &f[i][j]);\n            }\n        }\n        int max_deleted = 0;\n        int res = 0,tx,ty;\n        bool shouldsearch;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=11;i>=0;i--){\n                for(int j=0;j<6;j++){\n                    shouldsearch = false;\n                    for(int k=0;k<4;k++){\n                        tx = i+dx[k];\n                        ty = j+dy[k];\n                        if(0 <= tx && tx < 12 &&\n                           0 <= ty && ty < 6 && f[i][j] == f[tx][ty]){\n                            shouldsearch = true;\n                        }\n                    }\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j] && shouldsearch){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(max_deleted == 0) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n\nvector< vector<char> >V,C;\nint count=0;\n\nbool in(int x,int y){\n\treturn x>=0 && y>=0 && x<6 && y<12;\n}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nvoid kesu(int x,int y,char col){\n\tif(C[y][x]!=col){\n\t\treturn;\n\t}\n\tcount++;\n\tC[y][x]='.';\n\tfor(int d=0;d<4;d++){\n\t\tif(in(x+dx[d],y+dy[d]))\n\t\t\tkesu(x+dx[d],y+dy[d],col);\n\t}\n}\n\nvoid otosu(){\n\tfor(int y=10;y>=0;y--){\n\t\tfor(int x=0;x<6;x++){\n\t\t\tif(V[y][x]=='.')\n\t\t\t\tcontinue;\n\t\t\tint ty=y;\n\t\t\tchar temp=V[y][x];\n\t\t\tV[y][x]='.';\n\t\t\twhile(ty<=11 && V[ty][x]=='.')\n\t\t\t\tty++;\n\t\t\tty--;\n\t\t\tV[ty][x]=temp;\n\t\t}\n\t}\n}\n\nvoid print(){\n\tfor(int y=0;y<12;y++){\n\t\tfor(int x=0;x<6;x++){\n\t\t\tcout<<V[y][x];\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n\nvoid solve()\n{\n\tV.clear();\n\tV.resize(12,vector<char>(6));\n\tfor(int y=0;y<12;y++){\n\t\tstring now;\n\t\tcin>>now;\n\t\tfor(int x=0;x<6;x++)\n\t\t\tV[y][x]=now[x];\n\t}\n\tbool update=true;\n\tint res=-1;\n\twhile(update){\n\t\tupdate=false;\n\t\tres++;\n\t\tfor(int y=0;y<12;y++){\n\t\t\tfor(int x=0;x<6;x++){\n\t\t\t\tif(V[y][x]=='.' || V[y][x]=='O')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcount=0;\n\t\t\t\tC=V;\n\t\t\t\tkesu(x,y,V[y][x]);\n\t\t\t\tif(count>=4){\n\t\t\t\t\tV=C;\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\totosu();\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\tint t;\n\tcin>>t;\n\tfor(int i=0;i<t;i++)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int n,ny,nx,t,r,i,j,k,c,f,e,y[200],x[200],d[20][10]={0};\n  char s[20][10]={0};\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<12;i++)scanf(\"%s\",s[i+1]+1);\n    for(c=0;f=1;c++){\n      for(i=1;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  if(d[i+1][j+1]||s[i+1][j+1]=='.'||s[i+1][j+1]=='O')continue;\n\t  d[y[t=0]=i+1][x[0]=j+1]=1;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]-s[y[0]][x[0]]||d[ny][nx])continue;\n\t      d[y[r]=ny][x[r]=nx]=1;\n\t      r++;\n\t    }\n\t  }\n\t  if(r<4)continue;\n\t  for(t=f=0;t<r;t++){\n\t    d[y[t]][x[t]]=2;\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]=='O')d[ny][nx]=2;\n\t    }\n\t  }\n\t}\n      }\n      if(f)break;\n      for(j=1;j<7;j++){\n\te=0;\n\tfor(i=13;i>0;i--){\n\t  s[i+e][j]=s[i][j];\n\t  if(d[i][j]==2)e++;\n\t  d[i][j]=0;\n\t}\n\tfor(;i+e>0;i--)s[i+e][j]='.';\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nchar f[12][6];\nbool checked[12][6];\n\nint checkfrom(int i, int j){\n    pair<int,int> tmp;\n    deque<pair<int,int> > q;\n    vector<pair<int,int> > modi;\n    int cnt = 0,nx,ny;\n    char color = f[i][j];\n    int dx[4] = {0,-1,0,1};\n    int dy[4] = {1,0,-1,0};\n\n    q.push_back(make_pair(i,j));\n    checked[i][j] = true;\n    while(!q.empty()){\n        tmp = q.front();\n        q.pop_front();\n        modi.push_back(tmp);\n        cnt++;\n        for(int i=0;i<4;i++){\n            nx = tmp.first + dx[i];\n            ny = tmp.second + dy[i];\n            if(0 <= nx && nx < 12 &&\n               0 <= ny && ny < 6 &&\n               !checked[nx][ny] &&\n               f[nx][ny] == color){\n                q.push_back(make_pair(nx,ny));\n                checked[nx][ny] = true;\n            }\n        }\n    }\n    if(cnt >= 4){\n        for(int i=0;i<modi.size();i++){\n            f[modi[i].first][modi[i].second] = '.';\n            for(int j=0;j<4;j++){\n                if(f[modi[i].first + dx[j]][modi[i].second + dy[j]] == 'O'){\n                    f[modi[i].first + dx[j]][modi[i].second + dy[j]] = '.';\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n\n\n\n    for(int x=0;x<n;x++){\n        memset(f, 0, sizeof(f));\n\n        for(int i=0;i<12;i++){\n            for(int j=0;j<6;j++){\n                scanf(\" %c\", &f[i][j]);\n            }\n        }\n        int max_deleted = 0;\n        int res = 0;\n        while(1){\n            max_deleted = 0;\n            memset(checked, false, sizeof(checked));\n            for(int i=0;i<12;i++){\n                for(int j=0;j<6;j++){\n                    if(f[i][j] != '.' && f[i][j] != 'O' && !checked[i][j]){\n                        max_deleted = max(checkfrom(i, j), max_deleted);\n                    }\n                }\n            }\n            for(int i=0;i<6;i++){\n                int base = 11;\n                for(int j=11;j>=0;j--){\n                    if(f[j][i] != '.'){\n                        f[base][i] = f[j][i];\n                        base--;\n                    }\n                }\n                while(base >= 0){\n                    f[base][i] = '.';\n                    base--;\n                }\n            }\n            \n            if(!max_deleted) break;\n            res++;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\nchar board[12][6];\nint updboard[12][6];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint solve() {\n  int res = 0;\n  bool update = false;\n\n  while(1) {\n\n    update = false;\n    for(int i=0; i<12; ++i)\n      for(int j=0; j<6; ++j)\n\tupdboard[i][j] = 0;\n\n    //4ツづつ暗按湘」ツづつづ按つェツづづつ「ツづゥツ閉板閉ェツづーツ湘つキ\n    for(int i=0; i<12; ++i) {\n      for(int j=0; j<6; ++j) {\n\tif(updboard[i][j]) continue;\n\tif(board[i][j] == 'O' || board[i][j] == '.') continue;\n\tqueue< pair<int,int> > Q;\n\tQ.push(pair<int,int>(i,j));\n\tint samecolors = 1;\n\twhile(!Q.empty()) {\n\t  pair<int,int> np = Q.front(); Q.pop();\n\t  updboard[np.first][np.second] = 2;\n\t  for(int k=0; k<4; ++k) {\n\t    int nx = np.first+dx[k],ny = np.second+dy[k];\n\t    if(nx >= 0 && nx < 12 && ny >= 0 && ny < 6\n\t       && board[nx][ny] == board[i][j] && updboard[nx][ny] == 0) {\n\t      samecolors++;\n\t      Q.push(pair<int,int>(nx,ny));\n\t    }\n\t  }\n\t}\n\n\tif(samecolors >= 4) update = true;\n\n\tfor(int k=0; k<12; ++k)\n\t  for(int l=0; l<6; ++l)\n\t    if(updboard[k][l] == 2) {\n\t      if(samecolors >= 4) {\n\t\tboard[k][l] = '.';\n\t\tfor(int p=0; p<4; ++p)\n\t\t  for(int q=0; q<4; ++q)\n\t\t    if(k+dx[p] >= 0 && k+dx[p] < 12\n\t\t       && l+dy[q] >= 0 && l+dy[q] < 6\n\t\t       && board[k+dx[p]][l+dy[q]] == 'O')\n\t\t      board[k+dx[p]][l+dy[q]] = '.';\n\t      }\n\t      updboard[k][l] = 1;\n\t    }\n\n      }\n    }\n\n    //ツ猟篠づつキ\n    for(int k=0; k<12; ++k)\n      for(int i=0; i<11; ++i)\n\tfor(int j=0; j<6; ++j)\n\t  if(board[i][j] != '.' && board[i+1][j] == '.') {\n\t    board[i+1][j] = board[i][j];\n\t    board[i][j] = '.';\n\t  }\n\n    if(!update) break;\n\n    /*\n    for(int i=0; i<12; ++i) {\n      for(int j=0; j<6; ++j) {\n\tcout<<board[i][j];\n      }\n      cout<<endl;\n    }\n    //cout<<res<<endl;\n    */\n    res++;\n  }\n\n  if(res == -1) res = 0;\n  return res;\n}\n\nint main() {\n  int n;\n  string in;\n  cin>>n;\n  for(int k=0; k<n; ++k) {\n    for(int j=0; j<12; ++j) {\n      cin>>in;\n      for(int i=0; i<6; ++i)\n\tboard[j][i] = in.at(i);\n    }\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\nstruct Point{int x,y,c;};\nstruct xy{int x,y;};\nint main(){\n  int t;\n  cin >> t;\n  int i,j,k,a;\n  for(i=0;i<t;i++){\n    string str;\n    int b;\n    int o=0;\n    int st[6][12]={{}};\n    for(j=0;j<12;j++){\n      cin >> str;\n      for(k=0;k<6;k++){\n\tif(str[k]=='R') b=2;\n\tif(str[k]=='G') b=3;\n\tif(str[k]=='B') b=4;\n\tif(str[k]=='Y') b=5;\n\tif(str[k]=='P') b=6;\n\tif(str[k]=='O') b=1;\n\tif(str[k]=='.') b=0;\n\tst[k][j]=b;\n      }\n    }\n    queue<Point> q;\n    Point p,bu;\n\n    int ax[]={1,-1,0,0},ay[]={0,0,1,-1};\n    int f=0;\n    int s;\n    while(f==0){\n      o++;\n      f=1;\n      int v[6][12]={{}};\n      for(j=0;j<12;j++){\n\tfor(k=0;k<6;k++){\n\t  if(st[k][j]==0||st[k][j]==1||v[k][j]==1) continue;\n\t  p.x=k;p.y=j;p.c=st[k][j];\n\t  q.push(p);\n\t  vector <xy> vxy;\n\t  xy bxy;\n\t  bxy.x=k;bxy.y=j;\n\t  vxy.push_back(bxy);\n\t  v[k][j]=1;\n\t  s=1;\n\t  while(!q.empty()){\n\t    p=q.front();\n\t    q.pop();\n\t    for(a=0;a<4;a++){\n\t      bu.x=p.x+ax[a];\n\t      bu.y=p.y+ay[a];\n\t      if(bu.x<0||bu.x>=6||bu.y<0||bu.y>=12) continue;\n\t      bu.c=st[bu.x][bu.y];\n\t      if(bu.c==1) {\n\t\tbxy.x=bu.x;bxy.y=bu.y;\n\t\tvxy.push_back(bxy);\n\t\tcontinue;\n\t      }\n\t      \n\t      if(bu.c==p.c&&v[bu.x][bu.y]==0){\n\t\ts++;\n\t\tbxy.x=bu.x;bxy.y=bu.y;\n\t\tvxy.push_back(bxy);\n\t\tq.push(bu);\n\t\tv[bu.x][bu.y]=1;\n\t      }\n\t    }\n\t  }\n\t  //cout << k << \" \" << j << endl;\n\t  \n\t  if(s>=4){\n\t    for(a=0;a<vxy.size();a++){\n\t      st[vxy[a].x][vxy[a].y]=0;\n\t      //cout << vxy[a].x << \" \" << vxy[a].y << endl;\n\t      f=0;\n\t      \n\t    }\n\t    \n\t  }\n\t  //cout << endl;\n\t}\n      }\n      /*\n\n      for(j=0;j<12;j++){\n\tfor(k=0;k<6;k++){\n\t  cout << v[k][j];\n\t}\n\tcout << endl;\n      }\n\n      */\n      \n      for(k=0;k<6;k++){\n\tvector<int> data;\n\tfor(j=0;j<12;j++){\n\t  if(st[k][j]!=0) data.push_back(st[k][j]);\n\t}\n\tfor(j=0;j<12-data.size();j++) st[k][j]=0;\n\tfor(j=12-data.size();j<12;j++) st[k][j]=data[j+data.size()-12];\n\t\n      }\n      /*\n      for(j=0;j<12;j++){\n\tfor(k=0;k<6;k++){\n\t  cout << st[k][j];\n\t}\n\tcout << endl;\n      }\n      cout <<o<< endl;\n      */\n    }\n    \n    /*\n      cout << endl;\n    \n    for(j=0;j<12;j++){\n      for(k=0;k<6;k++){\n\tcout << st[k][j];\n      }\n      cout << endl;\n    }\n    */\n    cout << o-1 << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\nenum { YET, ALREADY };\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( void );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 };\nconst int dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ HEIGHT * WIDTH ];\nint sp;\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\t\tfield[ i ][ j ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup();\n\t\t\t\t}\n\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tstack[ sp++ ] = i * WIDTH + j;\n\tfield[ i ][ j ].state = ALREADY;\n\n\tfindGroup_body( i, j - 1, field[ i ][ j ].color, 2 );\n\tfindGroup_body( i - 1, j, field[ i ][ j ].color, 3 );\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, 0 ) + findGroup_body( i + 1, j, field[ i ][ j ].color, 1 ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tint sum, d;\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color && field[ i ][ j ].color != 'O' )\n\t\treturn 0;\n\n\tstack[ sp++ ] = i * WIDTH + j;\n\n\tif ( field[ i ][ j ].color == 'O' )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( d = 0; d < 4; d++ )\n\t\tif ( d != comeDir )\n\t\t\tsum += findGroup_body( i + dy[ d ], j + dx[ d ], color, d + 2 & 3 );\n\t\n\treturn sum + 1;\n}\n\nvoid deleteGroup( void ) {\n\twhile ( sp-- )\n\t\tfield[ stack[ sp ] / WIDTH ][ stack[ sp ] % WIDTH ].color = '.';\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH ][ HEIGHT ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ];\nint sp;\n\nint main( void ) {\n\tint x, y, n, chain;\n\n\tscanf( \"%d\", &n );\n\twhile ( n-- ) {\n\t\tfor ( y = 0; y < HEIGHT; y++ )\n\t\t\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); chain++ )\n\t\t\tfall();\n\n\t\tprintf( \"%d\\n\", chain );\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( x = 0; x < WIDTH; x++ )\n\t\tfor ( y = 0; y < HEIGHT; y++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / HEIGHT ][ stack[ sp ] % HEIGHT ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * HEIGHT + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 0; i < 4; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT && field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * HEIGHT + ny;\n\t\t\telse\n\t\t\t\tsum += search_body( nx, ny, color );\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y, cnt;\n\n\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\tcnt = 0;\n\t\tfor ( y = HEIGHT - 1; y >= 0; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt - 1; y >= 0; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH ][ HEIGHT ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ];\nint sp;\n\nint main( void ) {\n\tint x, y, n, chain;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( y = 0; y < HEIGHT; y++ ) {\n\t\t\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\t\t\tscanf( \"%c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tfor ( chain = 0; deleteBlock(); chain++ )\n\t\t\tfallBlock();\n\n\t\tprintf( \"%d\\n\", chain );\n\t}\n\n\treturn 0;\n}\n\nint deleteBlock( void ) {\n\tint x, y, del;\n\n\tdel = 0;\n\tfor ( x = 0; x < WIDTH; x++ )\n\t\tfor ( y = 0; y < HEIGHT; y++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( findGroup( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / HEIGHT ][ stack[ sp ] % HEIGHT ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint findGroup( int x, int y ) {\n\treturn findGroup_body( x, y, field[ x ][ y ].color );\n}\n\nint findGroup_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * HEIGHT + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 0; i < 4; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT && field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * HEIGHT + ny;\n\t\t\telse\n\t\t\t\tsum += findGroup_body( nx, ny, color );\t\t\t\n\t}\n\t\n\treturn sum + 1;\n}\n\nvoid fallBlock( void ) {\n\tint x, y, cnt;\n\n\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\tcnt = 0;\n\t\tfor ( y = HEIGHT - 1; y >= 0; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt - 1; y >= 0; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\n#define YET 0\n#define ALREADY 1\n\n#define LEFT 0\n#define UP 1\n#define RIGHT 2\n#define DOWN 3\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, char, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tfield[ i ][ j ].state = ALREADY;\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, LEFT ) + findGroup_body( i + 1, j, field[ i ][ j ].color, UP ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\treturn findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase UP:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase RIGHT:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase DOWN:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + 1;\n\t}\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint color = field[ i ][ j ].color;\n\n\tfield[ i ][ j ].color = '.';\n\n\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\tdeleteGroup_body( i - 1, j, color, DOWN );\n\tdeleteGroup_body( i, j + 1, color, LEFT );\n\tdeleteGroup_body( i + 1, j, color, UP );\n}\n\nvoid deleteGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].color != color ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tbreak;\n\t}\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\n#define YET 0\n#define ALREADY 1\n\n#define LEFT 0\n#define UP 1\n#define RIGHT 2\n#define DOWN 3\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, char, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tfield[ i ][ j ].state = ALREADY;\n\n\treturn findGroup_body( i - 1, j, field[ i ][ j ].color, DOWN ) + findGroup_body( i, j + 1, field[ i ][ j ].color, LEFT ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\treturn findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase UP:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase RIGHT:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase DOWN:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + 1;\n\t}\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint color = field[ i ][ j ].color;\n\n\tfield[ i ][ j ].color = '.';\n\n\tdeleteGroup_body( i - 1, j, color, DOWN );\n\tdeleteGroup_body( i, j + 1, color, LEFT );\n}\n\nvoid deleteGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].color != color ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tbreak;\n\t}\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "char m[7*14],v[7*14];\nC(i,c){\n\tif(m[i]==c&&!v[i]){\n\t\tv[i]=1;\n\t\treturn 1+C(i+1,c)+C(i-1,c)+C(i+7,c)+C(i-7,c);\n\t}\n\treturn 0;\n}\nE(i,c){\n\tif(m[i]=='O')\n\t\tm[i]='.';\n\telse if(m[i]==c){\n\t\tm[i]='.';\n\t\tE(i+1,c),E(i-1,c),E(i+7,c),E(i-7,c);\n\t}\n}\nmain(){\n\tint N,i,j,e,n;\n\tscanf(\"%d\\n\",&N);\n\tfor(;N--;){\n\t\tfor(i=0;i<7*12;i++)\n\t\t\tm[7+i]=getchar();\n\t\tfor(n=0;;n++){\n\t\t\te=0;\n\t\t\tmemset(v,0,sizeof(v));\n\t\t\tfor(i=0;i<7*12;i++){\n\t\t\t\tif(strchr(\"RGBYP\",m[7+i])&&C(7+i,m[7+i])>=4){\n\t\t\t\t\te=1;\n\t\t\t\t\tE(7+i,m[7+i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!e)\n\t\t\t\tbreak;\n\t\t\tfor(i=0;i<11;i++){\n\t\t\t\tfor(j=7*12;j--;){\n\t\t\t\t\tif(m[7+j]=='.'){\n\t\t\t\t\t\tm[7+j]=m[j];\n\t\t\t\t\t\tm[j]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",n);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<ctype.h>\nint count,d;\nchar screen[12][7];\n\nvoid manuver(int x,int y,char c);\nvoid delete(int x,int y,char c);\nvoid recover(void);\nvoid fall(int x,int y,char c);\n\nint main(void){\n  int i,j,p,q,t,del,block,ok,chain;\n  scanf(\"%d\",&t);\n  while(t--){\n    chain=0;\n    for(i=0;i<12;i++) scanf(\"%s%*c\",screen[i]);\n    ok=1;\n    while(ok){\n      ok--;\n      for(i=0;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  //printf(\"%d %d\\n\",i,j);\n\t  if(screen[i][j]!='.'&&screen[i][j]!='O'&&(del=isupper(screen[i][j]))!=0){\n\t    block=screen[i][j];\n\t    screen[i][j]=tolower(screen[i][j]);\n\t    count=0;\n\t    manuver(i,j,block);\n\t    if(count>=3){\n\t      if(ok==0) ok++;\n\t      delete(i,j,screen[i][j]);\n\t    }\n\t  }\n\t  //puts(\"ok\");\n\t}\n      }\n      if(ok==0) break;\n      recover();\n      chain++;\n      for(j=0;j<6;j++){\n\tfor(i=10;i>=0;i--){\n\t  if(screen[i][j]!='.'&&screen[i+1][j]=='.')\n\t    fall(i,j,screen[i][j]);\n\t}\n      }\n      /*printf(\"%d\\n\",chain);\n      for(i=0;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  putchar(screen[i][j]);\n\t}\n\tputchar('\\n');\n      }\n      putchar('\\n');*/\n      //printf(\"%d\\n\",ok);\n    }\n    printf(\"%d\\n\",chain);\n  }\n  return 0;\n}\n    \nvoid manuver(int x,int y,char c){\n  //printf(\"%c\\n\",c);\n  if(x!=11&&screen[x+1][y]==c){\n    count++;\n    //printf(\"%d %d\\n\",x,y);\n    screen[x+1][y]=tolower(screen[x+1][y]);;\n    manuver(x+1,y,c);\n  }\n  if(x!=0&&screen[x-1][y]==c){\n    //printf(\"%d %d\\n\",x,y);\n    count++;\n    screen[x-1][y]=tolower(screen[x-1][y]);\n    manuver(x-1,y,c);\n  }\n  if(y!=0&&screen[x][y-1]==c){\n    count++;\n   //printf(\"%d %d\\n\",x,y);\n    screen[x][y-1]=tolower(screen[x][y-1]);\n    manuver(x,y-1,c);\n  }\n  if(y!=5&&screen[x][y+1]==c){\n    count++;\n    //printf(\"%d %d\\n\",x,y);\n    screen[x][y+1]=tolower(screen[x][y+1]);\n    manuver(x,y+1,c);\n  }\n}\n\nvoid delete(int x,int y,char c){\n  char o='O';\n  if(x!=11&&screen[x+1][y]==c){\n    screen[x+1][y]='.';\n    delete(x+1,y,c);\n  }\n  if(x!=0&&screen[x-1][y]==c){\n    screen[x-1][y]='.';\n    delete(x-1,y,c);\n  }\n  if(y!=0&&screen[x][y-1]==c){\n    screen[x][y-1]='.';\n    delete(x,y-1,c);\n  }\n  if(y!=5&&screen[x][y+1]==c){\n    screen[x][y+1]='.';\n    delete(x,y+1,c);\n  }\n  if(x!=11&&screen[x+1][y]==o){\n    screen[x+1][y]='.';\n  }\n  if(x!=0&&screen[x-1][y]==o){\n    screen[x-1][y]='.';\n  }\n  if(y!=0&&screen[x][y-1]==o){\n    screen[x][y-1]='.';\n  }\n  if(y!=5&&screen[x][y+1]==o){\n    screen[x][y+1]='.';\n  }\n}\n\nvoid recover(void){\n  int i,j;\n  for(i=0;i<12;i++){\n    for(j=0;j<6;j++){\n      screen[i][j]=toupper(screen[i][j]);\n    }\n  }\n}\n\nvoid fall(int x,int y,char c){\n  screen[x+1][y]=c;\n  screen[x][y]='.';\n  if(x!=10&&screen[x+2][y]=='.') fall(x+1,y,c);\n}\n      "
  },
  {
    "language": "C",
    "code": "char*m,c;C(char*i){return*i==c&!i[98]?i[98]=1,1+C(i+1)+C(i-1)+C(i+7)+C(i-7):0;}E(char*i){*i==79?*i=0:*i==c?*i=0,E(i+1),E(i-1),E(i+7),E(i-7):0;}e,n;main(i,M){for(read(0,m=M,3);read(0,m+7,84);printf(\"%d\\n\",n))for(e=n=-1;e;n++){for(i=924;i--;m[7+e]<47?m[7+e]=m[e],m[e]=0:0)m[98+7+(e=i%84)]=0;for(i=6;++i<7*13;c&&strchr(\"RGBYP\",c)&&C(i)>3&&E(e=m+i))c=m[i];}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ], sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tfor ( scanf( \"%d\", &n ); n--; printf( \"%d\\n\", chain ) ) {\n\t\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\t\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); fall(), chain++ ) ;\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\tfor ( x = 1; x <= WIDTH; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 4; i--;  ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t\t\telse\n\t\t\t\tsum += search_body( nx, ny, color );\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT; y; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt; y; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ] = {};\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ], sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tfor ( scanf( \"%d\", &n ); n--; printf( \"%d\\n\", chain ) ) {\n\t\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\t\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); chain++ )\n\t\t\tfall();\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\tfor ( x = 1; x <= WIDTH; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel++;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 4; i--;  ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET )\n\t\t\tif ( field[ nx ][ ny ].color == color )\n\t\t\t\tsum += search_body( nx, ny, color );\n\t\t\telse if ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT; y; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt; y; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "char m[7*14],v[7*14];\nC(i,c){\n\tif(m[i]==c&&!v[i]){\n\t\tv[i]=1;\n\t\treturn 1+C(i+1,c)+C(i-1,c)+C(i+7,c)+C(i-7,c);\n\t}\n\treturn 0;\n}\nE(i,c){\n\tif(m[i]=='O')\n\t\tm[i]='.';\n\telse if(m[i]==c){\n\t\tm[i]='.';\n\t\tE(i+1,c),E(i-1,c),E(i+7,c),E(i-7,c);\n\t}\n}\nmain(){\n\tint N,i,j,e,n;\n\tscanf(\"%d\",&N);\n\tif(N>9)\n\t\texit(1);\n\tfor(;N--;){\n\t\tfor(i=0;i<7*12;i++)\n\t\t\tm[7+i]=getchar();\n\t\tfor(n=0;;n++){\n\t\t\te=0;\n\t\t\tmemset(v,0,sizeof(v));\n\t\t\tfor(i=0;i<7*12;i++){\n\t\t\t\tif(strchr(\"RGBYP\",m[7+i])&&C(7+i,m[7+i])>=4){\n\t\t\t\t\te=1;\n\t\t\t\t\tE(7+i,m[7+i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!e)\n\t\t\t\tbreak;\n\t\t\tfor(i=0;i<11;i++){\n\t\t\t\tfor(j=7*12;j--;){\n\t\t\t\t\tif(m[7+j]=='.'){\n\t\t\t\t\t\tm[7+j]=m[j];\n\t\t\t\t\t\tm[j]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",n);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tint color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH ][ HEIGHT ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ];\nint sp;\n\nint main( void ) {\n\tint x, y, n, chain;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( y = 0; y < HEIGHT; y++ ) {\n\t\t\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\t\t\tscanf( \"%c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tfor ( chain = 0; deleteBlock(); chain++ )\n\t\t\tfallBlock();\n\n\t\tprintf( \"%d\\n\", chain );\n\t}\n\n\treturn 0;\n}\n\nint deleteBlock( void ) {\n\tint x, y, del;\n\n\tdel = 0;\n\tfor ( x = 0; x < WIDTH; x++ )\n\t\tfor ( y = 0; y < HEIGHT; y++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( findGroup( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / HEIGHT ][ stack[ sp ] % HEIGHT ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint findGroup( int x, int y ) {\n\treturn findGroup_body( x, y, field[ x ][ y ].color );\n}\n\nint findGroup_body( int x, int y, int color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * HEIGHT + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 0; i < 4; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT && field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * HEIGHT + ny;\n\t\t\telse\n\t\t\t\tsum += findGroup_body( nx, ny, color );\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fallBlock( void ) {\n\tint x, y, cnt;\n\n\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\tcnt = 0;\n\t\tfor ( y = HEIGHT - 1; y >= 0; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt - 1; y >= 0; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "char m[98],v[98],c;C(i){return m[i]==c&!v[i]?v[i]=1,1+C(i+1)+C(i-1)+C(i+7)+C(i-7):0;}E(i){m[i]==79?m[i]=0:m[i]==c?m[i]=0,E(i+1),E(i-1),E(i+7),E(i-7):0;}main(i,e,n){for(read(0,m+7,3);read(0,m+7,84);printf(\"%d\\n\",n))for(e=n=-1;e;n++){for(i=11*84;i--;m[7+e]<47?m[7+e]=m[e],m[e]=0:0)e=i%84;memset(v,e=0,98);for(i=6;++i<7*13;c&&strchr(\"RGBYP\",c)&&C(i)>3&&E(e=i))c=m[i];}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\n#define YET 0\n#define ALREADY 1\n\n#define LEFT 0\n#define UP 1\n#define RIGHT 2\n#define DOWN 3\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, char, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\t\tfield[ i ][ j ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tfield[ i ][ j ].state = ALREADY;\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, LEFT ) + findGroup_body( i + 1, j, field[ i ][ j ].color, UP ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\treturn findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase UP:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase RIGHT:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase DOWN:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + 1;\n\t}\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint color = field[ i ][ j ].color;\n\n\tfield[ i ][ j ].color = '.';\n\n\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\tdeleteGroup_body( i - 1, j, color, DOWN );\n\tdeleteGroup_body( i, j + 1, color, LEFT );\n\tdeleteGroup_body( i + 1, j, color, UP );\n}\n\nvoid deleteGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].color != color ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tbreak;\n\t}\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "char m[7*14],v[7*14];\nC(i,c){\n\tif(m[i]==c&&!v[i]){\n\t\tv[i]=1;\n\t\treturn 1+C(i+1,c)+C(i-1,c)+C(i+7,c)+C(i-7,c);\n\t}\n\treturn 0;\n}\nE(i,c){\n\tif(m[i]=='O')\n\t\tm[i]='.';\n\telse if(m[i]==c){\n\t\tm[i]='.';\n\t\tE(i+1,c),E(i-1,c),E(i+7,c),E(i-7,c);\n\t}\n}\nmain(){\n\tint N,i,j,e,n;\n\tscanf(\"%d\",&N);\n\tif(N>99)\n\t\texit(1);\n\tfor(;N--;){\n\t\tfor(i=0;i<7*12;i++)\n\t\t\tm[7+i]=getchar();\n\t\tfor(n=0;;n++){\n\t\t\te=0;\n\t\t\tmemset(v,0,sizeof(v));\n\t\t\tfor(i=0;i<7*12;i++){\n\t\t\t\tif(strchr(\"RGBYP\",m[7+i])&&C(7+i,m[7+i])>=4){\n\t\t\t\t\te=1;\n\t\t\t\t\tE(7+i,m[7+i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!e)\n\t\t\t\tbreak;\n\t\t\tfor(i=0;i<11;i++){\n\t\t\t\tfor(j=7*12;j--;){\n\t\t\t\t\tif(m[7+j]=='.'){\n\t\t\t\t\t\tm[7+j]=m[j];\n\t\t\t\t\t\tm[j]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",n);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ];\nint sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tscanf( \"%d\", &n );\n\twhile ( n-- ) {\n\t\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\t\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); chain++ )\n\t\t\tfall();\n\n\t\tprintf( \"%d\\n\", chain );\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\tfor ( x = 1; x <= WIDTH; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 0; i < 4; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t\t\telse\n\t\t\t\tsum += search_body( nx, ny, color );\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT; y > 0; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt; y > 0; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nshort erase[12][6];\nchar board[12][7];\n\nint dec_delete(int x,int y);\nvoid make_delete(int x,int y);\nvoid delete(void);\nvoid down(void);\n\nint main(void){\n  int T,i,j,k,num,tmp[2];\n  scanf(\"%d%*c\",&T);\n  while(T--){\n    for(i=0;i<12;i++) scanf(\"%6s%*c\",board[i]);\n    num=0;\n    do{\n      num++;\n      tmp[0]=tmp[1]=0;\n      for(i=0;i<12;i++) for(j=0;j<6;j++) erase[i][j]=0;     \n      for(i=0;i<12;i++) for(j=0;j<6;j++) if(board[i][j]!='O' && board[i][j]!='.' && erase[i][j]==0) dec_delete(i,j);     \n      for(i=0;i<12;i++) for(j=0;j<6;j++) tmp[0]+=(board[i][j]=='.');\n      for(i=0;i<12;i++) for(j=0;j<6;j++)  if(erase[i][j]>=4) make_delete(i,j);\n      delete();\n      for(i=0;i<12;i++) for(j=0;j<6;j++) tmp[1]+=(board[i][j]=='.');\n      down();\n    }while(tmp[1]!=tmp[0]);\n    printf(\"%d\\n\",num-1);\n  }\n  return 0;\n}\n\nint dec_delete(int x,int y){\n  int tmp=1;\n  erase[x][y]=1;\n  if(x!=0 && board[x-1][y]==board[x][y] && erase[x-1][y]==0) tmp+=dec_delete(x-1,y);\n  if(y!=0 && board[x][y-1]==board[x][y] && erase[x][y-1]==0) tmp+=dec_delete(x,y-1);\n  if(x!=11 && board[x+1][y]==board[x][y] && erase[x+1][y]==0) tmp+=dec_delete(x+1,y);\n  if(y!=5 && board[x][y+1]==board[x][y] && erase[x][y+1]==0) tmp+=dec_delete(x,y+1);\n  erase[x][y]=tmp;\n  return tmp;\n}\n  \nvoid make_delete(int x,int y){\n  if(erase[x][y]==100) return;\n  erase[x][y]=100;\n  if(x!=0){\n    if(board[x-1][y]==board[x][y])make_delete(x-1,y);\n    else if(board[x-1][y]=='O') erase[x-1][y]=100;\n  }\n  if(y!=0){\n    if(board[x][y-1]==board[x][y]) make_delete(x,y-1);\n    else if(board[x][y-1]=='O') erase[x][y-1]=100;\n  }\n  if(x!=11){\n    if(board[x+1][y]==board[x][y]) make_delete(x+1,y);\n    else if(board[x+1][y]=='O') erase[x+1][y]=100;\n  }\n  if(y!=5){\n    if(board[x][y+1]==board[x][y]) make_delete(x,y+1);\n    else if(board[x][y+1]=='O') erase[x][y+1]=100;\n  }\n}\n\nvoid delete(void){\n  int i,j;\n  for(i=0;i<12;i++) for(j=0;j<6;j++) if(erase[i][j]==100) board[i][j]='.';\n}\n\nvoid down(void){\n  int i,j,num;\n  for(i=0;i<6;i++){\n    num=0;\n    for(j=11;j>=0;j--){\n      if(board[j][i]=='.') num++;\n      else board[j+num][i]=board[j][i];\n    }\n    for(j=num-1;j>=0;j--) board[j][i]='.';\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ] = {};\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ], sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tfor ( scanf( \"%d\", &n ); n--; printf( \"%d\\n\", chain ) ) {\n\t\tfor ( y = 1; y < HEIGHT + 1; y++ )\n\t\t\tfor ( x = 1; x < WIDTH + 1; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); chain++ )\n\t\t\tfall();\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y < HEIGHT + 1; y++ )\n\t\tfor ( x = 1; x < WIDTH + 1; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel++;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 4; i--;  ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET )\n\t\t\tif ( field[ nx ][ ny ].color == color )\n\t\t\t\tsum += search_body( nx, ny, color );\n\t\t\telse if ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = WIDTH + 1; x-- > 1;  ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT + 1; y-- > 1;  )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( ; cnt--; field[ x ][ cnt + 1 ].color = '.' ) ;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2206\nTitle:Compile\n*/\n#include <stdio.h>\n#include <string.h>\n#define WIDTH 6\n#define HEIGHT 12\n//Global data section\nint  t;\nchar block[HEIGHT][WIDTH+1];\nchar area[HEIGHT][WIDTH+1];\nint  hist[HEIGHT*WIDTH];\nint rensa;\nint max_rin;\n// const\nchar any_color[]=\"RGBYP\";\n//\nextern int paint(int,int,char,int);\nvoid shift_empty()\n{\n  int i,j1,j2,k;\n  char buf[HEIGHT];\n\n  for(i=0;i<WIDTH;i++)\n    {\n      for(j1=j2=HEIGHT-1;j2>=0;j2--)\n\t{\n\t  if(block[j2][i] != '.')\n\t    {\n\t      block[j1][i]=block[j2][i];\n\t      j1--;\n\t    }\n\t}\n      if(j1>0)\n\tfor(k=j1;k>=0;k--)\n\t  block[k][i]='.';\t\n    }\n}\nvoid erase_block()\n{\n  int i,j,c;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n\tif(i>0 && hist[area[i][j]]>3)\n\t  block[i][j]='.';\n      }\n\n}\nvoid erasable_ojama()\n{\n  int i,j,c;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n\tif(block[i][j] != 'O')\n\t  continue;\n\tif(i>0 && hist[area[i-1][j]]>3)\n\t  block[i][j]='.';\n\tif(i<HEIGHT-1 && hist[area[i+1][j]]>3)\n\t  block[i][j]='.';\n\tif(j>0 && hist[area[i][j-1]]>3)\n\t  block[i][j]='.';\n\tif(j<WIDTH-1 && hist[area[i][j+1]]>3)\n\t  block[i][j]='.';\n      }\n}\nvoid make_hist()\n{\n int i,j;\n for(i=0;i<HEIGHT*WIDTH;i++)\n   hist[i]=0;\n for(i=0;i<HEIGHT;i++)\n   for(j=0;j<WIDTH;j++)\n     if(area[i][j])\n       hist[area[i][j]]++;\n}\nint chk_rinsetu()\n{\n  int y,x,val,col,maxhist,i;\n\n  x=0;y=0;val=0;\n  while(col=search_next(&y,&x))\n    {\n      val++;\n      paint(y,x,col,val);\n    }\n  make_hist();\n  maxhist=0;\n for(i=0;i<HEIGHT*WIDTH;i++)\n   if(hist[i]>maxhist)\n     maxhist=hist[i];\n return(maxhist);\n}\nvoid clear_area()\n{\n int i,j;\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      area[i][j]=0;\n}\n\n\nint search_next(int *sy,int *sx)\n{\n  int i,j;\n  i=*sy;j=*sx;goto LOOP;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n      LOOP:\n\tif(area[i][j]==0 && strchr(any_color,block[i][j]))\n\t  {\n\t    *sy=i;*sx=j;return(block[i][j]);\n\t  }\n      }\n  return(0);\n}\nint paint(int y,int x,char col,int val)\n{\n  if(area[y][x]==0)\n    {\n      area[y][x] = val;\n      if(y < HEIGHT-1 && block[y+1][x]==col)\n\tpaint(y+1,x,col,val);\n      if(y > 0 && block[y-1][x]==col)\n\tpaint(y-1,x,col,val);\n      if(x < WIDTH-1 && block[y][x+1]==col)\n\tpaint(y,x+1,col,val);\n      if(x > 0 && block[y][x-1]==col)\n\tpaint(y,x-1,col,val);\n    }\n\n}\nvoid count_rensa()\n{\n  //int i;\n\n   rensa=0;\n   while(1)\n     //for(i=0;i<3;i++)\n    {\n      clear_area();\t\n      max_rin=chk_rinsetu();\n      //printf(\"RINSETU %d\\n\",max_rin);\n      if(max_rin > 3)\n\trensa++;\n      else\n\tgoto EXIT;\n \n\terasable_ojama();\n\terase_block();\n\tshift_empty();\n#ifdef DEBUG\n\tshow();\n#endif      \n    }\n  \n EXIT:\n    ;\n    //show();        \n}\n// debug write\nshow()\n{\n  int i,j;\n  for(i=0;i<HEIGHT;i++)\n    {\n      for(j=0;j<WIDTH;j++)\n\tprintf(\"%c\",block[i][j]);\n      printf(\"|  \");\n      for(j=0;j<WIDTH;j++)\n   \tprintf(\"%02d\",area[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"------   ------------\\n\");\n}\nmain()\n{\n  int i,j,ret;\n\n  while(EOF!=scanf(\"%d\",&t))\n    for(i=0;i<t;i++)\n      {\n\tfor(j=0;j<HEIGHT;j++)\n\t  scanf(\"%s\",&(block[j][0]));\n\n\tcount_rensa();\n\tprintf(\"%d\\n\",rensa);\n\n      }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH ][ HEIGHT ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ];\nint sp;\n\nint main( void ) {\n\tint x, y, n, chain;\n\n\tscanf( \"%d \", &n );\n\twhile ( n-- ) {\n\t\tfor ( y = 0; y < HEIGHT; y++ )\n\t\t\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\t\t\tscanf( \"%c \", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; deleteBlock(); chain++ )\n\t\t\tfallBlock();\n\n\t\tprintf( \"%d\\n\", chain );\n\t}\n\n\treturn 0;\n}\n\nint deleteBlock( void ) {\n\tint x, y, del = 0;\n\n\tfor ( x = 0; x < WIDTH; x++ )\n\t\tfor ( y = 0; y < HEIGHT; y++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( findGroup( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / HEIGHT ][ stack[ sp ] % HEIGHT ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint findGroup( int x, int y ) {\n\treturn findGroup_body( x, y, field[ x ][ y ].color );\n}\n\nint findGroup_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * HEIGHT + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 0; i < 4; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT && field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * HEIGHT + ny;\n\t\t\telse\n\t\t\t\tsum += findGroup_body( nx, ny, color );\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fallBlock( void ) {\n\tint x, y, cnt;\n\n\tfor ( x = 0; x < WIDTH; x++ ) {\n\t\tcnt = 0;\n\t\tfor ( y = HEIGHT - 1; y >= 0; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt - 1; y >= 0; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "char m[98],v[98],c;C(i){return m[i]==c&!v[i]?v[i]=1,1+C(i+1)+C(i-1)+C(i+7)+C(i-7):0;}E(i){m[i]==79?m[i]=0:m[i]==c?m[i]=0,E(i+1),E(i-1),E(i+7),E(i-7):0;}main(i,e,n){for(read(0,m+7,3);read(0,m+7,84);printf(\"%d\\n\",n))for(e=n=-1;e;n++){for(i=924;i--;m[7+e]<47?m[7+e]=m[e],m[e]=0:0)v[7+(e=i%84)]=0;for(i=6;++i<91;c&&strchr(\"RGBYP\",c)&&C(i)>3&&E(e=i))c=m[i];}}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2206\nTitle:Compile\n*/\n#include <stdio.h>\n#include <string.h>\n#define WIDTH 6\n#define HEIGHT 12\n//Global data section\nint  t;\nchar block[HEIGHT][WIDTH+1];\nchar area[HEIGHT][WIDTH+1];\nint  hist[HEIGHT*WIDTH];\nint rensa;\nint max_rin;\n// const\nchar any_color[]=\"RGBYP\";\n//\nextern int paint(int,int,char,int);\nvoid shift_empty()\n{\n  int i,j1,j2,k;\n  char buf[HEIGHT];\n\n  for(i=0;i<WIDTH;i++)\n    {\n      for(j1=j2=HEIGHT-1;j2>=0;j2--)\n\t{\n\t  if(block[j2][i] != '.')\n\t    {\n\t      block[j1][i]=block[j2][i];\n\t      j1--;\n\t    }\n\t}\n      if(j1>0)\n\tfor(k=j1;k>=0;k--)\n\t  block[k][i]='.';\t\n    }\n}\nvoid erase_block()\n{\n  int i,j,c;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n\tif(i>0 && hist[area[i][j]]>3)\n\t  block[i][j]='.';\n      }\n\n}\nvoid erasable_ojama()\n{\n  int i,j,c;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n\tif(block[i][j] != 'O')\n\t  continue;\n\tif(i>0 && hist[area[i-1][j]]>3)\n\t  block[i][j]='.';\n\tif(i<HEIGHT && hist[area[i+1][j]]>3)\n\t  block[i][j]='.';\n\tif(j>0 && hist[area[i][j-1]]>3)\n\t  block[i][j]='.';\n\tif(j<WIDTH && hist[area[i][j+1]]>3)\n\t  block[i][j]='.';\n      }\n}\nvoid make_hist()\n{\n int i,j;\n for(i=0;i<HEIGHT*WIDTH;i++)\n   hist[i]=0;\n for(i=0;i<HEIGHT;i++)\n   for(j=0;j<WIDTH;j++)\n     if(area[i][j])\n       hist[area[i][j]]++;\n}\nint chk_rinsetu()\n{\n  int y,x,val,col,maxhist,i;\n\n  x=0;y=0;val=0;\n  while(col=search_next(&y,&x))\n    {\n      val++;\n      paint(y,x,col,val);\n    }\n  make_hist();\n  maxhist=0;\n for(i=0;i<HEIGHT*WIDTH;i++)\n   if(hist[i]>maxhist)\n     maxhist=hist[i];\n return(maxhist);\n}\nvoid clear_area()\n{\n int i,j;\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      area[i][j]=0;\n}\n\n\nint search_next(int *sy,int *sx)\n{\n  int i,j;\n  i=*sy;j=*sx;goto LOOP;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n      LOOP:\n\tif(area[i][j]==0 && strchr(any_color,block[i][j]))\n\t  {\n\t    *sy=i;*sx=j;return(block[i][j]);\n\t  }\n      }\n  return(0);\n}\nint paint(int y,int x,char col,int val)\n{\n  if(area[y][x]==0)\n    {\n      area[y][x] = val;\n      if(y < HEIGHT && block[y+1][x]==col)\n\tpaint(y+1,x,col,val);\n      if(y > 0 && block[y-1][x]==col)\n\tpaint(y-1,x,col,val);\n      if(x < WIDTH && block[y][x+1]==col)\n\tpaint(y,x+1,col,val);\n      if(x > 0 && block[y][x-1]==col)\n\tpaint(y,x-1,col,val);\n    }\n\n}\nvoid count_rensa()\n{\n  //int i;\n\n   rensa=0;\n   while(1)\n     //for(i=0;i<3;i++)\n    {\n      clear_area();\t\n      max_rin=chk_rinsetu();\n      //printf(\"RINSETU %d\\n\",max_rin);\n      if(max_rin > 3)\n\trensa++;\n      else\n\tgoto EXIT;\n \n\terasable_ojama();\n\terase_block();\n\tshift_empty();\n\t//show();      \n    }\n  \n EXIT:\n    ;\n    //show();        \n}\n// debug write\nshow()\n{\n  int i,j;\n  for(i=0;i<HEIGHT;i++)\n    {\n      for(j=0;j<WIDTH;j++)\n\tprintf(\"%c\",block[i][j]);\n      printf(\"|  \");\n      for(j=0;j<WIDTH;j++)\n   \tprintf(\"%02d\",area[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"------   ------------\\n\");\n}\nmain()\n{\n  int i,j,ret;\n\n  while(EOF!=scanf(\"%d\",&t))\n    for(i=0;i<t;i++)\n      {\n\tfor(j=0;j<HEIGHT;j++)\n\t  scanf(\"%s\",&(block[j][0]));\n\n\tcount_rensa();\n\tprintf(\"%d\\n\",rensa);\n\n      }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\nenum { YET, ALREADY, LEFT, UP, RIGHT, DOWN };\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, char, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\t\tfield[ i ][ j ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tfield[ i ][ j ].state = ALREADY;\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, LEFT ) + findGroup_body( i + 1, j, field[ i ][ j ].color, UP ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tint tmp;\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\ttmp = 0;\n\tif ( comeDir != LEFT )\n\t\ttmp += findGroup_body( i, j - 1, color, RIGHT );\n\tif ( comeDir != UP )\n\t\ttmp += findGroup_body( i - 1, j, color, DOWN );\n\tif ( comeDir != RIGHT )\n\t\ttmp += findGroup_body( i, j + 1, color, LEFT );\n\tif ( comeDir != DOWN )\n\t\ttmp += findGroup_body( i + 1, j, color, UP );\n\t\n\treturn tmp + 1;\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint color = field[ i ][ j ].color;\n\n\tfield[ i ][ j ].color = '.';\n\n\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\tdeleteGroup_body( i - 1, j, color, DOWN );\n\tdeleteGroup_body( i, j + 1, color, LEFT );\n\tdeleteGroup_body( i + 1, j, color, UP );\n}\n\nvoid deleteGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].color != color ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\n\tif ( comeDir != LEFT )\n\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\tif ( comeDir != UP )\n\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\tif ( comeDir != RIGHT )\n\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\tif ( comeDir != DOWN )\n\t\tdeleteGroup_body( i + 1, j, color, UP );\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\n#define YET 0\n#define ALREADY 1\n\n#define LEFT 0\n#define UP 1\n#define RIGHT 2\n#define DOWN 3\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, char, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tfield[ i ][ j ].state = ALREADY;\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, LEFT ) + findGroup_body( i + 1, j, field[ i ][ j ].color, UP ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\treturn findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase UP:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i, j + 1, color, LEFT ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase RIGHT:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i + 1, j, color, UP ) + 1;\n\t\tcase DOWN:\n\t\t\treturn findGroup_body( i, j - 1, color, RIGHT ) + findGroup_body( i - 1, j, color, DOWN ) + findGroup_body( i, j + 1, color, LEFT ) + 1;\n\t}\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint color = field[ i ][ j ].color;\n\n\tfield[ i ][ j ].color = '.';\n\n\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\tdeleteGroup_body( i - 1, j, color, DOWN );\n\tdeleteGroup_body( i, j + 1, color, LEFT );\n\tdeleteGroup_body( i + 1, j, color, UP );\n}\n\nvoid deleteGroup_body( int i, int j, char color, int comeDir ) {\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].color != color ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\n\tswitch ( comeDir ) {\n\t\tcase LEFT:\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i + 1, j, color, UP );\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tdeleteGroup_body( i, j - 1, color, RIGHT );\n\t\t\tdeleteGroup_body( i - 1, j, color, DOWN );\n\t\t\tdeleteGroup_body( i, j + 1, color, LEFT );\n\t\t\tbreak;\n\t}\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ] = {};\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ], sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tfor ( scanf( \"%d\", &n ); n--; printf( \"%d\\n\", chain ) ) {\n\t\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\t\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); chain++ )\n\t\t\tfall();\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\tfor ( x = 1; x <= WIDTH; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel++;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 4; i--;  ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET )\n\t\t\tif ( field[ nx ][ ny ].color == color )\n\t\t\t\tsum += search_body( nx, ny, color );\n\t\t\telse if ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT; y; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt; y; field[ x ][ y-- ].color = '.' ) ;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[12][6];\nchar input_map[12][8];\n\nint group_num;\nint group[12*6][2];\n\nvoid tansaku(int x,int y,char color) {\n\tif(x<0 || x>=6 || y<0 || y>=12)return;\n\tif(map[y][x]!=0 || input_map[y][x]!=color)return;\n\tgroup[group_num][0]=y;\n\tgroup[group_num][1]=x;\n\tgroup_num++;\n\tmap[y][x]=1;\n\ttansaku(x-1,y,color);\n\ttansaku(x+1,y,color);\n\ttansaku(x,y-1,color);\n\ttansaku(x,y+1,color);\n}\n\nint main(void) {\n\tint data_num,cur_data;\n\tint i,j,k;\n\tint rensa,deleted;\n\tscanf(\"%d\",&data_num);\n\tfor(cur_data=0;cur_data<data_num;cur_data++) {\n\t\tfor(i=0;i<12;i++)scanf(\"%s\",input_map[i]);\n\t\tfor(rensa=0;;rensa++) {\n\t\t\tmemset(map,0,sizeof(map));\n\t\t\tfor(i=0;i<12;i++) {\n\t\t\t\tfor(j=0;j<6;j++) {\n\t\t\t\t\tif(input_map[i][j]=='.' || input_map[i][j]=='O') {\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup_num=0;\n\t\t\t\t\t\ttansaku(j,i,input_map[i][j]);\n\t\t\t\t\t\tfor(k=0;k<group_num;k++) {\n\t\t\t\t\t\t\tmap[group[k][0]][group[k][1]]=group_num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeleted=0;\n\t\t\tfor(i=0;i<12;i++) {\n\t\t\t\tfor(j=0;j<6;j++) {\n\t\t\t\t\tif(map[i][j]>=4) {\n\t\t\t\t\t\tinput_map[i][j]='.';\n\t\t\t\t\t\tif(i>0 && input_map[i-1][j]=='O')input_map[i-1][j]='.';\n\t\t\t\t\t\tif(i<11 && input_map[i+1][j]=='O')input_map[i+1][j]='.';\n\t\t\t\t\t\tif(j>0 && input_map[i][j-1]=='O')input_map[i][j-1]='.';\n\t\t\t\t\t\tif(j<5 && input_map[i][j+1]=='O')input_map[i][j+1]='.';\n\t\t\t\t\t\tdeleted=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!deleted)break;\n\t\t\tfor(i=11;i>0;i--) {\n\t\t\t\tfor(j=0;j<6;j++) {\n\t\t\t\t\tif(input_map[i][j]=='.') {\n\t\t\t\t\t\tfor(k=i;k>=0;k--) {\n\t\t\t\t\t\t\tif(input_map[k][j]!='.') {\n\t\t\t\t\t\t\t\tinput_map[i][j]=input_map[k][j];\n\t\t\t\t\t\t\t\tinput_map[k][j]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",rensa);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<ctype.h>\nint count,d;\nchar screen[12][7];\n\nvoid manuver(int x,int y,char c);\nvoid delete(int x,int y,char c);\nvoid recover(int x,int y,char c);\nvoid fall(int x,int y,char c);\n\nint main(void){\n  int i,j,p,q,t,del,block,ok,chain;\n  scanf(\"%d\",&t);\n  while(t--){\n    chain=0;\n    for(i=0;i<12;i++) scanf(\"%s%*c\",screen[i]);\n    /*for(i=0;i<12;i++){\n      for(j=0;j<6;j++){\n\tputchar(screen[i][j]);\n      }\n      putchar('\\n');\n      }*/\n    ok=1;\n    while(ok){\n      ok--;\n      for(i=0;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  //if(i==11) printf(\"%d %d\\n\",i,j);\n\t  if(screen[i][j]!='.'&&screen[i][j]!='O'){\n\t    if(ok==0) ok++;\n\t    //puts(\"ok\");\n\t    block=screen[i][j];\n\t    screen[i][j]=tolower(screen[i][j]);\n\t    count=0;\n\t    manuver(i,j,block);\n\t    //printf(\"count:%d\\n\",count);\n\t    /*puts(\"before\");\n\t    for(p=0;p<12;p++){\n\t      for(q=0;q<6;q++){\n\t      putchar(screen[p][q]);\n\t      }\n\t      putchar('\\n');\n\t    }\n\t    putchar('\\n');*/\n\t    if(count>=3) delete(i,j,screen[i][j]);\n\t    else{\n\t      block=screen[i][j];\n\t      screen[i][j]=toupper(screen[i][j]);\n\t      recover(i,j,block);\n\t    }\n\t    //puts(\"after\");\n\t    /*for(p=0;p<12;p++){\n\t      for(q=0;q<6;q++){\n\t      putchar(screen[p][q]);\n\t      }\n\t      putchar('\\n');\n\t    }\n\t    putchar('\\n');*/\n\t  }\n\t  //puts(\"ok\");\n\t}\n      }\n      if(ok==0) break;\n      chain++;\n      for(j=0;j<6;j++){\n\tfor(i=10;i>=0;i--){\n\t  if(screen[i][j]!='.'&&screen[i+1][j]=='.')\n\t    fall(i,j,screen[i][j]);\n\t}\n      }\n      /*printf(\"%d\\n\",chain);\n      for(i=0;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  putchar(screen[i][j]);\n\t}\n\tputchar('\\n');\n      }\n      putchar('\\n');*/\n    }\n      //puts(\"ok\");\n    /* for(i=0;i<12;i++){\n      for(j=0;j<6;j++){\n\tputchar(screen[i][j]);\n      }\n      putchar('\\n');\n      }*/\n    printf(\"%d\\n\",chain);\n  }\n    //puts(\"ok\");\n  return 0;\n}\n    \nvoid manuver(int x,int y,char c){\n  //printf(\"%c\\n\",c);\n  if(x!=11&&screen[x+1][y]==c){\n    count++;\n    //printf(\"%d %d\\n\",x,y);\n    screen[x+1][y]=tolower(screen[x+1][y]);;\n    manuver(x+1,y,c);\n  }\n  if(x!=0&&screen[x-1][y]==c){\n    //printf(\"%d %d\\n\",x,y);\n    count++;\n    screen[x-1][y]=tolower(screen[x-1][y]);\n    manuver(x-1,y,c);\n  }\n  if(y!=0&&screen[x][y-1]==c){\n    count++;\n   //printf(\"%d %d\\n\",x,y);\n    screen[x][y-1]=tolower(screen[x][y-1]);\n    manuver(x,y-1,c);\n  }\n  if(y!=5&&screen[x][y+1]==c){\n    count++;\n    //printf(\"%d %d\\n\",x,y);\n    screen[x][y+1]=tolower(screen[x][y+1]);\n    manuver(x,y+1,c);\n  }\n}\n\nvoid delete(int x,int y,char c){\n  char o='O';\n  if(x!=11&&screen[x+1][y]==c){\n    screen[x+1][y]='.';\n    delete(x+1,y,c);\n  }\n  if(x!=0&&screen[x-1][y]==c){\n    screen[x-1][y]='.';\n    delete(x-1,y,c);\n  }\n  if(y!=0&&screen[x][y-1]==c){\n    screen[x][y-1]='.';\n    delete(x,y-1,c);\n  }\n  if(y!=5&&screen[x][y+1]==c){\n    screen[x][y+1]='.';\n    delete(x,y+1,c);\n  }\n  if(x!=11&&screen[x+1][y]==o){\n    screen[x+1][y]='.';\n  }\n  if(x!=0&&screen[x-1][y]==o){\n    screen[x-1][y]='.';\n  }\n  if(y!=0&&screen[x][y-1]==o){\n    screen[x][y-1]='.';\n  }\n  if(y!=5&&screen[x][y+1]==o){\n    screen[x][y+1]='.';\n  }\n}\n\nvoid recover(int x,int y,char c){\n    if(x!=11&&screen[x+1][y]==c){\n    //printf(\"%d %d\\n\",x,y);\n    screen[x+1][y]=toupper(screen[x+1][y]);;\n    recover(x+1,y,c);\n  }\n  if(x!=0&&screen[x-1][y]==c){\n    //printf(\"%d %d\\n\",x,y);\n    screen[x-1][y]=toupper(screen[x-1][y]);\n    recover(x-1,y,c);\n  }\n  if(y!=0&&screen[x][y-1]==c){\n   //printf(\"%d %d\\n\",x,y);\n    screen[x][y-1]=toupper(screen[x][y-1]);\n    recover(x,y-1,c);\n  }\n  if(y!=5&&screen[x][y+1]==c){\n    //printf(\"%d %d\\n\",x,y);\n    screen[x][y+1]=toupper(screen[x][y+1]);\n    recover(x,y+1,c);\n  }\n}\n\nvoid fall(int x,int y,char c){\n  screen[x+1][y]=c;\n  screen[x][y]='.';\n  if(x!=10&&screen[x+2][y]=='.') fall(x+1,y,c);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2206: Compile\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar m[12][7], t[12][7];\n\nint same(char a, int r, int c)\n{\n\tint dr, dc;\n\tint ans = 1;\n\n\tfor (dc = -1; dc <= 1; dc++) for (dr = -1; dr <= 1; dr++) {\n\t\tif (dr == dc || dr && dc) continue;\n\t\tif (c + dc < 0 || c + dc >= 6 || r + dr < 0 || r + dr >= 12) continue;\n\t\tif (t[r+dr][c+dc] == a) {\n\t\t\tt[r+dr][c+dc] = 'x';\n\t\t\tans += same(a, r+dr, c+dc);\n\t\t} else if (t[r+dr][c+dc] == 'O') t[r+dr][c+dc] = 'x';\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint cno, r, c, f, ans;\n\tchar a;\n\n\tscanf(\"%d\", &cno);\n\twhile (cno--) {\n\t\tfor (r = 0; r < 12; r++)  scanf(\"%s\", m[r]);\n\n\t\tans = 0, f = 1;\n\t\twhile (f) {\n\t\t\tf = 0;\n\t\t\tfor (c = 0; c < 6; c++) for (r = 11; r >= 0; r--) {\n\t\t\t\tmemcpy(t, m, sizeof(m));\n\t\t\t\ta = m[r][c];\n\t\t\t\tif (a == 'O' || a == '.' || a == 'x') continue;\n\t\t\t\tt[r][c] = 'x';\n\t\t\t\tif (same(a, r, c) >= 4) {\n\t\t\t\t\tmemcpy(m, t, sizeof(m));\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tans++;\n\t\t\t\tfor (c = 0; c < 6; c++) {\n\t\t\t\t\tfor (r = 11; r >= 0; r--) {\n\t\t\t\t\t\tint rr;\n\t\t\t\t\t\tif (m[r][c] != 'x') continue;\n\t\t\t\t\t\trr = r-1;\n\t\t\t\t\t\twhile (rr >= 0 && m[rr][c] == 'x') rr--;\n\t\t\t\t\t\tif (rr < 0) m[r][c] = '.';\n\t\t\t\t\t\telse m[r][c] = m[rr][c], m[rr][c] = 'x';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int n,ny,nx,t,r,i,j,k,c,f,e,y[200],x[200];\n  char s[20][10]={0};\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<12;i++)scanf(\"%s\",s[i+1]+1);\n    for(c=0;f=1;c++){\n      int d[20][10]={0};\n      for(i=1;i<13;i++){\n\tfor(j=1;j<7;j++){\n\t  if(d[i][j]||s[i][j]=='.'||s[i][j]=='O')continue;\n\t  d[y[t=0]=i][x[0]=j]=1;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]-s[y[0]][x[0]]||d[ny][nx])continue;\n\t      d[y[r]=ny][x[r]=nx]=1;\n\t      r++;\n\t    }\n\t  }\n\t  if(r<4)continue;\n\t  for(t=f=0;t<r;t++){\n\t    d[y[t]][x[t]]=2;\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]=='O')d[ny][nx]=2;\n\t    }\n\t  }\n\t}\n      }\n      if(f)break;\n      for(j=1;j<7;j++){\n\te=0;\n\tfor(i=13;i;i--){\n\t  s[i+e][j]=s[i][j];\n\t  if(d[i][j]==2)e++;//,printf(\"%d %d\\n\",i,j);\n\t}\n\tfor(i=e;i;i--)s[i][j]='.';\n      }\n      //for(i=0;i<12;i++)printf(\"%s\\n\",s[i+1]+1);//break;\n    }\n    //for(i=0;i<12;i++)printf(\"%s\\n\",s[i+1]+1);//break;\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,i,j,c[13][7],mv[5]={0,1,0,-1,0};\nchar M[13][7],t;\n\n\nint ch(int h,int w,char p)\n{\n\tint i,j,nh,nw,r=1;\n\tc[h][w]=1;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tnh=h+mv[i];nw=w+mv[i+1];\n\t\tif(M[nh][nw]==p&&!c[nh][nw])\n\t\t{\n\t\t\tc[nh][nw]=1;\n\t\t\tr+=ch(nh,nw,p);\n\t\t}\n\t}\n\treturn r;\n}\n\nvoid del(int h,int w,char p)\n{\n\tint i,j,nh,nw;\n\tM[h][w]='.';\n\tfor(i=0;i<4;i++)\n\t{\n\t\tnh=h+mv[i];nw=w+mv[i+1];\n\t\tif(M[nh][nw]==p)\n\t\t\tdel(nh,nw,p);\n\t\telse if(M[nh][nw]=='O')\n\t\t\tM[nh][nw]='.';\n\t}\n}\n\nint sh()\n{\n\tint f=0,i,j;\n\tfor(i=0;i<12;i++)\n\t\tfor(j=0;j<6;j++)\n\t\t{\n\t\t\tif(M[i][j]=='.'||M[i][j]=='O')continue;\n\t\t\tmemset(c,0,sizeof(c));\n\t\t\tif(ch(i,j,M[i][j])>=4)\n\t\t\t{\n\t\t\t\tdel(i,j,M[i][j]);\n\t\t\t\tf=1;\n\t\t\t\t//dbg();\n\t\t\t}\n\t\t}\n\treturn f;\n}\n\nint main()\n{\n\tscanf(\"%d\\n\",&N);\n\tfor(;N--;)\n\t{\n\t\tint c=0,i,j,a,b;\n\t\tfor(i=0;i<12;i++)gets(M[i]);\n\t\t//dbg();\n\t\tfor(;sh();c++)\n\t\t{\n\t\t\tfor(i=11;i>=0;i--)\n\t\t\t\tfor(j=0;j<6;j++)\n\t\t\t\t{\n\t\t\t\t\tif(M[i][j]=='.')\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(a=0;M[i][j]=='.'&&a<i;a++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(b=i;b>0;b--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt=M[b-1][j];\n\t\t\t\t\t\t\t\tM[b-1][j]=M[b][j];\n\t\t\t\t\t\t\t\tM[b][j]=t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//dbg();\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2206\nTitle:Compile\n*/\n#include <stdio.h>\n#include <string.h>\n#define WIDTH 6\n#define HEIGHT 12\n//Global data section\nint  t;\nchar block[HEIGHT][WIDTH+1];\nchar area[HEIGHT][WIDTH+1];\nint  hist[HEIGHT*WIDTH];\nint rensa;\nint max_rin;\n// const\nchar any_color[]=\"RGBYP\";\n//\nextern int paint(int,int,char,int);\nvoid shift_empty()\n{\n  int i,j1,j2,k;\n  char buf[HEIGHT];\n\n  for(i=0;i<WIDTH;i++)\n    {\n      for(j1=j2=HEIGHT-1;j2>=0;j2--)\n\t{\n\t  if(block[j2][i] != '.')\n\t    {\n\t      block[j1][i]=block[j2][i];\n\t      j1--;\n\t    }\n\t}\n      if(j1>0)\n\tfor(k=j1;k>=0;k--)\n\t  block[k][i]='.';\t\n    }\n}\nvoid erase_block()\n{\n  int i,j,c;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n\tif(hist[area[i][j]]>3)\n\t  block[i][j]='.';\n      }\n\n}\nvoid erasable_ojama()\n{\n  int i,j,c;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n\tif(block[i][j] != 'O')\n\t  continue;\n\tif(i>0 && hist[area[i-1][j]]>3)\n\t  block[i][j]='.';\n\tif(i<HEIGHT-1 && hist[area[i+1][j]]>3)\n\t  block[i][j]='.';\n\tif(j>0 && hist[area[i][j-1]]>3)\n\t  block[i][j]='.';\n\tif(j<WIDTH-1 && hist[area[i][j+1]]>3)\n\t  block[i][j]='.';\n      }\n}\nvoid make_hist()\n{\n int i,j;\n for(i=0;i<HEIGHT*WIDTH;i++)\n   hist[i]=0;\n for(i=0;i<HEIGHT;i++)\n   for(j=0;j<WIDTH;j++)\n     if(area[i][j])\n       hist[area[i][j]]++;\n}\nint chk_rinsetu()\n{\n  int y,x,val,col,maxhist,i;\n\n  x=0;y=0;val=0;\n  while(col=search_next(&y,&x))\n    {\n      //printf(\"SN %d %d \\n\",y,x);\n      val++;\n      paint(y,x,col,val);\n    }\n  make_hist();\n  maxhist=0;\n for(i=0;i<HEIGHT*WIDTH;i++)\n   if(hist[i]>maxhist)\n     maxhist=hist[i];\n return(maxhist);\n}\nvoid clear_area()\n{\n int i,j;\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      area[i][j]=0;\n}\n\n\nint search_next(int *sy,int *sx)\n{\n  int i,j;\n  i=*sy;j=*sx;goto LOOP;\n\n  for(i=0;i<HEIGHT;i++)\n    for(j=0;j<WIDTH;j++)\n      {\n      LOOP:\n\tif(area[i][j]==0 && strchr(any_color,block[i][j]))\n\t  {\n\t    *sy=i;*sx=j;return(block[i][j]);\n\t  }\n      }\n  return(0);\n}\nint paint(int y,int x,char col,int val)\n{\n  if(area[y][x]==0)\n    {\n      area[y][x] = val;\n      if(y < HEIGHT-1 && block[y+1][x]==col)\n\tpaint(y+1,x,col,val);\n      if(y > 0 && block[y-1][x]==col)\n\tpaint(y-1,x,col,val);\n      if(x < WIDTH-1 && block[y][x+1]==col)\n\tpaint(y,x+1,col,val);\n      if(x > 0 && block[y][x-1]==col)\n\tpaint(y,x-1,col,val);\n    }\n\n}\nvoid count_rensa()\n{\n  //int i;\n\n   rensa=0;\n   while(1)\n     //for(i=0;i<3;i++)\n    {\n      clear_area();\t\n      max_rin=chk_rinsetu();\n      //printf(\"RINSETU %d\\n\",max_rin);\n      if(max_rin > 3)\n\trensa++;\n      else\n\tgoto EXIT;\n \n\terasable_ojama();\n\terase_block();\n\tshift_empty();\n#ifdef DEBUG\n\tshow();\n#endif      \n    }\n  \n EXIT:\n    ;\n    //show();        \n}\n// debug write\nshow()\n{\n  int i,j;\n  for(i=0;i<HEIGHT;i++)\n    {\n      for(j=0;j<WIDTH;j++)\n\tprintf(\"%c\",block[i][j]);\n      printf(\"|  \");\n      for(j=0;j<WIDTH;j++)\n   \tprintf(\"%02d\",area[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"------   ------------\\n\");\n}\nmain()\n{\n  int i,j,ret;\n\n  while(EOF!=scanf(\"%d\",&t))\n    for(i=0;i<t;i++)\n      {\n\tfor(j=0;j<HEIGHT;j++)\n\t  scanf(\"%s\",&(block[j][0]));\n\n\tcount_rensa();\n\tprintf(\"%d\\n\",rensa);\n\n      }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ] = {};\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ], sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tfor ( scanf( \"%d\", &n ); n--; printf( \"%d\\n\", chain ) ) {\n\t\tfor ( y = 1; y < HEIGHT + 1; y++ )\n\t\t\tfor ( x = 1; x < WIDTH + 1; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); chain++ )\n\t\t\tfall();\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y < HEIGHT + 1; y++ )\n\t\tfor ( x = 1; x < WIDTH + 1; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel++;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 4; i--;  ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET )\n\t\t\tif ( field[ nx ][ ny ].color == color )\n\t\t\t\tsum += search_body( nx, ny, color );\n\t\t\telse if ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = WIDTH + 1; x-- > 1;  ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT + 1; y-- > 1;  )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( ; y--; field[ x ][ y + 1 ].color = '.' ) ;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int n,ny,nx,t,r,i,j,k,c,f,e,y[200],x[200],d[20][10]={0};\n  char s[20][10]={0};\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<12;i++)scanf(\"%s\",s[i+1]+1);\n    for(c=0;f=1;c++){\n      for(i=1;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  if(d[i+1][j+1]||s[i+1][j+1]=='.'||s[i+1][j+1]=='O')continue;\n\t  d[y[t=0]=i+1][x[0]=j+1]=1;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]-s[y[0]][x[0]]||d[ny][nx])continue;\n\t      d[y[r]=ny][x[r]=nx]=1;\n\t      r++;\n\t    }\n\t  }\n\t  if(r<4)continue;\n\t  for(t=f=0;t<r;t++){\n\t    d[y[t]][x[t]]=2;\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]=='O')d[ny][nx]=2;\n\t    }\n\t  }\n\t}\n      }/*printf(\"a\\n\");\n      for(i=0;i<12;i++){\n\tfor(j=0;j<6;j++)printf(\"%d\",d[i+1][j+1]);\n\tprintf(\"\\n\");\n\t}printf(\"\\n\");//*/\n      if(f)break;\n      for(j=1;j<7;j++){\n\te=0;\n\tfor(i=13;i>0;i--){\n\t  s[i+e][j]=s[i][j];\n\t  if(d[i][j]==2)e++;//,printf(\"%d %d\\n\",i,j);\n\t  d[i][j]=0;\n\t}\n\tfor(;i+e>0;i--)s[i+e][j]='.';\n      }\n      //for(i=0;i<12;i++)printf(\"%s\\n\",s[i+1]+1);//break;\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\nenum { YET, ALREADY };\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, char, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 };\nconst int dy[ 4 ] = { 0, -1, 0, 1 };\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\t\tfield[ i ][ j ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tfield[ i ][ j ].state = ALREADY;\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, 0 ) + findGroup_body( i + 1, j, field[ i ][ j ].color, 1 ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tint tmp, d;\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\ttmp = 0;\n\tfor ( d = 0; d < 4; d++ )\n\t\tif ( d != comeDir )\n\t\t\ttmp += findGroup_body( i + dy[ d ], j + dx[ d ], color, d + 2 & 3 );\n\t\n\treturn tmp + 1;\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint color = field[ i ][ j ].color, d;\n\n\tfield[ i ][ j ].color = '.';\n\n\tfor ( d = 0; d < 4; d++ )\n\t\tdeleteGroup_body( i + dy[ d ], j + dx[ d ], color, d + 2 & 3 );\n}\n\nvoid deleteGroup_body( int i, int j, char color, int comeDir ) {\n\tint d;\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].color != color ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\n\tfor ( d = 0; d < 4; d++ )\n\t\tif ( d != comeDir )\n\t\t\tdeleteGroup_body( i + dy[ d ], j + dx[ d ], color, d + 2 & 3 );\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\nenum { YET, ALREADY };\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int );\nvoid deleteGroup( void );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 };\nconst int dy[ 4 ] = { 0, -1, 0, 1 };\n\ntypedef struct {\n\tint i;\n\tint j;\n} INDEX;\n\nINDEX stack[ HEIGHT * WIDTH ];\nint sp;\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\t\tfield[ i ][ j ].state = YET;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup();\n\t\t\t\t}\n\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tINDEX tmp = { i, j };\n\n\tstack[ sp++ ] = tmp;\n\tfield[ i ][ j ].state = ALREADY;\n\n\tfindGroup_body( i, j - 1, field[ i ][ j ].color, 2 );\n\tfindGroup_body( i - 1, j, field[ i ][ j ].color, 3 );\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, 0 ) + findGroup_body( i + 1, j, field[ i ][ j ].color, 1 ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int comeDir ) {\n\tint sum, d;\n\tINDEX tmp = { i, j };\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == ALREADY || field[ i ][ j ].color != color && field[ i ][ j ].color != 'O' )\n\t\treturn 0;\n\n\tstack[ sp++ ] = tmp;\n\n\tif ( field[ i ][ j ].color == 'O' )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( d = 0; d < 4; d++ )\n\t\tif ( d != comeDir )\n\t\t\tsum += findGroup_body( i + dy[ d ], j + dx[ d ], color, d + 2 & 3 );\n\t\n\treturn sum + 1;\n}\n\nvoid deleteGroup( void ) {\n\twhile ( sp-- )\n\t\tfield[ stack[ sp ].i ][ stack[ sp ].j ].color = '.';\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = YET;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- )\n\t\t\tfield[ i ][ j ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1};\nint X[]={1,0,-1,0};\nint main(){\n  int n,ny,nx,t,r,i,j,k,c,f,e,y[200],x[200],d[20][10]={0};\n  char s[20][10]={0};\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<12;i++)scanf(\"%s\",s[i+1]+1);\n    for(c=0;f=1;c++){\n      for(i=0;i<12;i++){\n\tfor(j=0;j<6;j++){\n\t  if(d[i+1][j+1]||s[i+1][j+1]=='.'||s[i+1][j+1]=='O')continue;\n\t  d[y[t=0]=i+1][x[0]=j+1]=1;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]-s[y[0]][x[0]]||d[ny][nx])continue;\n\t      d[y[r]=ny][x[r]=nx]=1;\n\t      r++;\n\t    }\n\t  }\n\t  if(r<4)continue;\n\t  for(t=f=0;t<r;t++){\n\t    d[y[t]][x[t]]=2;\n\t    for(k=0;k<4;k++){\n\t      ny=y[t]+Y[k];\n\t      nx=x[t]+X[k];\n\t      if(s[ny][nx]=='O')d[ny][nx]=2;\n\t    }\n\t  }\n\t}\n      }\n      if(f)break;\n      for(j=1;j<7;j++){\n\te=0;\n\tfor(i=13;i>0;i--){\n\t  s[i+e][j]=s[i][j];\n\t  if(d[i][j]==2)e++;//,printf(\"%d %d\\n\",i,j);\n\t  d[i][j]=0;\n\t}\n\tfor(;i+e>0;i--)s[i+e][j]='.';\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 6\n#define HEIGHT 12\n\nenum { YET, ALREADY };\n\nint del( void );\nint search( int, int );\nint search_body( int, int, char );\nvoid fall( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ WIDTH + 2 ][ HEIGHT + 2 ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 }, dy[ 4 ] = { 0, -1, 0, 1 };\n\nint stack[ WIDTH * HEIGHT ];\nint sp;\n\nint main( void ) {\n\tint n, x, y, chain;\n\n\tfor ( scanf( \"%d\", &n ); n--; printf( \"%d\\n\", chain ) ) {\n\t\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\t\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\t\t\tscanf( \" %c\", &field[ x ][ y ].color );\n\t\t\t\tfield[ x ][ y ].state = YET;\n\t\t\t}\n\n\t\tfor ( chain = 0; del(); fall(), chain++ ) ;\n\t}\n\n\treturn 0;\n}\n\nint del( void ) {\n\tint x, y, del = 0;\n\n\tfor ( y = 1; y <= HEIGHT; y++ )\n\t\tfor ( x = 1; x <= WIDTH; x++ )\n\t\t\tif ( field[ x ][ y ].color != '.' && field[ x ][ y ].color != 'O' && field[ x ][ y ].state == YET ) {\n\t\t\t\tsp = 0;\n\t\t\t\tif ( search( x, y ) >= 4 ) {\n\t\t\t\t\twhile ( sp-- )\n\t\t\t\t\t\tfield[ stack[ sp ] / ( HEIGHT + 2 ) ][ stack[ sp ] % ( HEIGHT + 2 ) ].color = '.';\n\n\t\t\t\t\tdel = 1;\n\t\t\t\t}\n\t\t\t}\n\n\treturn del;\n}\n\nint search( int x, int y ) {\n\treturn search_body( x, y, field[ x ][ y ].color );\n}\n\nint search_body( int x, int y, char color ) {\n\tint i, sum;\n\n\tstack[ sp++ ] = x * ( HEIGHT + 2 ) + y;\n\tfield[ x ][ y ].state = ALREADY;\n\n\tsum = 0;\n\tfor ( i = 0; i < 4; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].state == YET && ( field[ nx ][ ny ].color == color || field[ nx ][ ny ].color == 'O' ) )\n\t\t\tif ( field[ nx ][ ny ].color == 'O' )\n\t\t\t\tstack[ sp++ ] = nx * ( HEIGHT + 2 ) + ny;\n\t\t\telse\n\t\t\t\tsum += search_body( nx, ny, color );\n\t}\n\n\treturn sum + 1;\n}\n\nvoid fall( void ) {\n\tint x, y;\n\n\tfor ( x = 1; x <= WIDTH; x++ ) {\n\t\tint cnt = 0;\n\n\t\tfor ( y = HEIGHT; y > 0; y-- )\n\t\t\tif ( field[ x ][ y ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ x ][ y + cnt ].color = field[ x ][ y ].color;\n\t\t\t\tfield[ x ][ y + cnt ].state = YET;\n\t\t\t}\n\n\t\tfor ( y = cnt; y > 0; y-- )\n\t\t\tfield[ x ][ y ].color = '.';\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define HEIGHT 12\n#define WIDTH 6\n\nint calcChain( void );\nint deleteBlock( void );\nint findGroup( int, int );\nint findGroup_body( int, int, char, int, int );\nvoid deleteGroup( int, int );\nvoid deleteGroup_body( int, int, int, int );\nvoid fallBlock( void );\n\ntypedef struct {\n\tchar color;\n\tint state;\n} FIELD;\n\nFIELD field[ HEIGHT ][ WIDTH ];\nconst int dx[ 4 ] = { -1, 0, 1, 0 };\nconst int dy[ 4 ] = { 0, -1, 0, 1 };\n\nint main( void ) {\n\tint i, j, n;\n\n\tscanf( \"%d%*c\", &n );\n\twhile ( n-- ) {\n\t\tfor ( i = 0; i < HEIGHT; i++ ) {\n\t\t\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\t\t\tscanf( \"%c\", &field[ i ][ j ].color );\n\t\t\t\tfield[ i ][ j ].state = -1;\n\t\t\t}\n\n\t\t\tscanf( \"%*c\" );\n\t\t}\n\n\t\tprintf( \"%d\\n\", calcChain() );\n\t}\n\n\treturn 0;\n}\n\nint calcChain( void ) {\n\tint chain;\n\n\tfor ( chain = 0; ; chain++ ) {\n\t\tif ( !deleteBlock() )\n\t\t\tbreak;\n\n\t\tfallBlock();\n\t}\n\n\treturn chain;\n}\n\nint deleteBlock( void ) {\n\tint i, j, deleted;\n\n\tdeleted = 0;\n\tfor ( i = 0; i < HEIGHT; i++ )\n\t\tfor ( j = 0; j < WIDTH; j++ )\n\t\t\tif ( field[ i ][ j ].color != '.' && field[ i ][ j ].color != 'O' && field[ i ][ j ].state == -1 )\n\t\t\t\tif ( findGroup( i, j ) >= 4 ) {\n\t\t\t\t\tdeleted = 1;\n\t\t\t\t\tdeleteGroup( i, j );\n\t\t\t\t}\n\n\treturn deleted;\n}\n\nint findGroup( int i, int j ) {\n\tint id = i * WIDTH + j;\n\n\tfield[ i ][ j ].state = id;\n\n\treturn findGroup_body( i, j + 1, field[ i ][ j ].color, id, 0 ) + findGroup_body( i + 1, j, field[ i ][ j ].color, id, 1 ) + 1;\n}\n\nint findGroup_body( int i, int j, char color, int id, int comeDir ) {\n\tint tmp, d;\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH || field[ i ][ j ].state == id || field[ i ][ j ].color != color )\n\t\treturn 0;\n\n\tfield[ i ][ j ].state = id;\n\n\ttmp = 0;\n\tfor ( d = 0; d < 4; d++ )\n\t\tif ( d != comeDir )\n\t\t\ttmp += findGroup_body( i + dy[ d ], j + dx[ d ], color, id, d + 2 & 3 );\n\t\n\treturn tmp + 1;\n}\n\nvoid deleteGroup( int i, int j ) {\n\tint id = i * WIDTH + j, d;\n\n\tfield[ i ][ j ].color = '.';\n\n\tfor ( d = 0; d < 4; d++ )\n\t\tdeleteGroup_body( i + dy[ d ], j + dx[ d ], id, d + 2 & 3 );\n}\n\nvoid deleteGroup_body( int i, int j, int id, int comeDir ) {\n\tint d;\n\n\tif ( i < 0 || i >= HEIGHT || j < 0 || j >= WIDTH )\n\t\treturn;\n\n\tif ( field[ i ][ j ].state != id ) {\n\t\tif ( field[ i ][ j ].color == 'O' )\n\t\t\tfield[ i ][ j ].color = '.';\n\n\t\treturn;\n\t}\n\n\tfield[ i ][ j ].color = '.';\n\tfield[ i ][ j ].state = -1;\n\n\tfor ( d = 0; d < 4; d++ )\n\t\tif ( d != comeDir )\n\t\t\tdeleteGroup_body( i + dy[ d ], j + dx[ d ], id, d + 2 & 3 );\n}\n\nvoid fallBlock( void ) {\n\tint i, j, cnt;\n\n\tfor ( j = 0; j < WIDTH; j++ ) {\n\t\tcnt = 0;\n\t\tfor ( i = HEIGHT - 1; i >= 0; i-- )\n\t\t\tif ( field[ i ][ j ].color == '.' )\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\tfield[ i + cnt ][ j ].color = field[ i ][ j ].color;\n\t\t\t\tfield[ i + cnt ][ j ].state = -1;\n\t\t\t}\n\n\t\tfor ( i = cnt - 1; i >= 0; i-- ) {\n\t\t\tfield[ i ][ j ].color = '.';\n\t\t\tfield[ i ][ j ].state = -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nfun main(args:Array<String>):Unit {\n    repeat(readLine()!!.toInt()){\n        println(countRensa(Array(12){readLine()!!.trim()}))\n    }\n}\nclass UnionFindTree{\n    private var mRank:Int = 1\n    private var mParent:UnionFindTree? = null\n    private fun parent():UnionFindTree {\n        return when(mParent){\n            null -> this\n            else -> {\n                mParent = mParent?.parent()\n                mParent!!\n            }\n        }\n    }\n    fun rank():Int {\n        return when(mParent){\n            null -> mRank\n            else -> parent().rank()\n        }\n    }\n    fun isSameUnion(other:UnionFindTree):Boolean {\n        return parent() == other.parent()\n    }\n    fun merge(other:UnionFindTree):Unit {\n        if (!isSameUnion(other)){\n            val newRank = rank() + other.rank()\n            parent().mParent = other.parent()\n            parent().mRank = newRank\n        }\n    }\n}\ndata class Point(val x:Int, val y:Int) {\n    fun neighbors():Iterable<Point> = listOf(Point(x - 1, y), Point(x + 1, y), Point(x, y - 1), Point(x, y + 1))\n}\ndata class Puyo(val point:Point, val color:Char){\n    fun down():Puyo = Puyo(Point(point.x, point.y + 1), color)\n}\nfun countRensa(state:Array<String>):Int {\n    //println(state.joinToString(\"\\n\", postfix = \"\\n\"))\n    val puyo = state.map{it.map{UnionFindTree()}}\n    val moved = state.map(String::toCharArray).toTypedArray()\n    for (i in 1 until state.size) for (j in 0 until state[0].length) {\n        if (state[i][j] !in listOf('O', '.') && state[i - 1][j] == state[i][j]){\n            puyo[i][j].merge(puyo[i - 1][j])\n        }\n    }\n    for (i in 0 until state.size) for (j in 1 until state[0].length){\n        if (state[i][j] !in listOf('O', '.') && state[i][j - 1] == state[i][j]){\n            puyo[i][j].merge(puyo[i][j - 1])\n        }\n    }\n    for (i in 0 until state.size) for (j in 0 until state[0].length){\n        if (puyo[i][j].rank() >= 4){\n            moved[i][j] = '.'\n            Point(j, i).neighbors().filter{it.y in 0 until state.size && it.x in 0 until state[0].length}.filter { state[it.y][it.x] == 'O' }.forEach {\n                moved[it.y][it.x] = '.'\n            }\n        }\n    }\n    var movable = (0 until state.size).flatMap{y -> (0 until state[0].length).filter{x -> moved[y][x] != '.'}.map{x -> Puyo(Point(x, y), moved[y][x])}}\n    while(movable.count{\n                it.point.y + 1 < state.size && moved[it.point.y + 1][it.point.x] == '.'\n            } != 0)  {\n        val m = movable.filter{it.point.y + 1 < state.size && moved[it.point.y + 1][it.point.x] == '.'}\n        movable = movable.map{\n            if (it.point.y + 1 < state.size && moved[it.point.y + 1][it.point.x] == '.') {\n                Puyo(it.point.copy(y = it.point.y + 1), it.color)\n            }else{\n                it\n            }\n        }\n        m.forEach {\n            moved[it.point.y][it.point.x] = '.'\n            moved[it.point.y + 1][it.point.x] = it.color\n        }\n    }\n    return if (puyo.any{it.any{it.rank() >= 4}}) 1 + countRensa(moved.map{it.joinToString(\"\")}.toTypedArray())\n        else 0\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t = scanner.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tg = new char[12][6];\n\t\t\tps = new boolean[12][6];\n\t\t\tfor (int y = 0; y < 12; y++)\n\t\t\t\tg[y] = scanner.next().toCharArray();\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tboolean co = false;\n\t\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\t\tArrays.fill(ps[j], false);\n\t\t\t\t}\n\n\t\t\t\tfor (int y = 0; y < 12; y++) {\n\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\tstep = 0;\n\t\t\t\t\t\tif (!cn(y, x, g[y][x]))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcr(y, x, g[y][x]);\n\t\t\t\t\t\tco = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!co) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 11; j++)\n\t\t\t\t\tfor (int y = 0; y < 11; y++)\n\t\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\t\tif (g[y][x] != '.' && g[y + 1][x] == '.') {\n\t\t\t\t\t\t\t\tchar tmp = g[y][x];\n\t\t\t\t\t\t\t\tg[y][x] = g[y + 1][x];\n\t\t\t\t\t\t\t\tg[y + 1][x] = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void cr(int y, int x, char p) {\n\t\tif (g[y][x] != p)\n\t\t\treturn;\n\t\tg[y][x] = '.';\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\t\t\tif (g[ny][nx] == 'O') {\n\t\t\t\tg[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcr(ny, nx, p);\n\n\t\t}\n\t}\n\n\tprivate boolean cn(int y, int x, char p) {\n\t\tif (p == 'O' || p == '.' || p != g[y][x] || ps[y][x])\n\t\t\treturn false;\n\t\tstep++;\n\t\tif (step == 4)\n\t\t\treturn true;\n\t\tps[y][x] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (cn(ny, nx, p))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int nx, int ny) {\n\t\treturn 0 <= nx && nx < 6 && 0 <= ny && ny < 12;\n\t}\n\tint step;\n\tchar[][] g;\n\tboolean[][] ps;\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[][] field;\n    int[] dx = {1, -1, 0, 0};\n    int[] dy = {0, 0, 1, -1};\n    int h = 12, w = 6;\n    ArrayList<int[]> clearList;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int dataset = sc.nextInt();\n        while(dataset-->0){\n            field = new char[h][w];\n            for(int i=0; i<h; i++){\n                field[i] = sc.next().toCharArray();\n            }\n\n            int cnt = 0;\n            while(true){\n                clearList = new ArrayList<int[]>();\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        if(field[i][j]!='.' && field[i][j]!='O') find(i, j);\n                    }\n                }\n                if(clearList.size()==0) break;\n                clear(clearList);\n                down();\n                cnt++;\n            }\n            System.out.println(cnt);\n        }\n    }\n\n    boolean find(int y, int x){\n        char clear = field[y][x];\n        ArrayList<int[]> clearList2 = new ArrayList<int[]>();\n        LinkedList<int[]> list = new LinkedList<int[]>();\n        boolean[][] v = new boolean[h][w];\n        list.add(new int[]{x, y});\n\n        while(list.size()>0){\n            int[] qq = list.poll();\n            int xx = qq[0], yy = qq[1];\n\n            if(v[yy][xx]) continue;\n            v[yy][xx] = true;\n            clearList2.add(new int[]{xx, yy});\n\n            for(int i=0; i<4; i++){\n                int nx = xx + dx[i], ny = yy + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || field[ny][nx]!=clear) continue;\n                list.add(new int[]{nx, ny});\n            }\n        }\n\n        if(clearList2.size()>=4){\n            for(int[] xy : clearList2) clearList.add(xy);\n        }\n        return false;\n    }\n\n    void print(){\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(field[i]));\n        System.out.println(\"------\");\n    }\n\n    void clear(ArrayList<int[]> clearList1){\n        for(int[] xy : clearList1){\n            int x = xy[0], y = xy[1];\n            field[y][x] = '.';\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || field[ny][nx]!='O') continue;\n                field[ny][nx] = '.';\n            }\n        }\n    }\n\n    void down(){\n        for(int k=0; k<w; k++){\n            for(int i=h-1; i>=0; i--){\n                if(field[i][k]!='.') continue;\n                int idx = -1;\n                for(int j=i; j>=0; j--){\n                    if(field[j][k]!='.'){\n                        idx = j;\n                        break;\n                    }\n                }\n                if(idx==-1) break;\n                else{\n                    char tmp = field[i][k];\n                    field[i][k] = field[idx][k];\n                    field[idx][k] = tmp;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();sc.nextLine();\n\t\t\tif(n ==0 ) break;\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint[][] map;\n\tString rp = \".OPYBGR\";\n\tint w = 6, h = 12;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(;t>0;t--) {\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=12;i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j=0;j<rp.length();j++) s = s.replace(rp.charAt(j), (char)('0' + j));\n\t\t\t\tfor(int j=1;j<=6;j++) map[i][j] = s.charAt(j-1) - '0';\n\t\t\t}\n\t\t\tboolean ch = true;\n\t\t\tint c = 0;\n//\t\t\tfor(int[] a: map) debug(a);\n\t\t\tfor(;;c++) {\n\t\t\t\tch = false;\n\t\t\t\ttmp = new int[h+2][w+2];\n\t\t\t\tfor(int i=0;i<w+2;i++) for(int j=0;j<h+2;j++) tmp[j][i] = map[j][i];\n\t\t\t\tfor(int i=1;i<=w;i++) for(int j=1;j<h;j++) if(map[j][i] > 1) {\n\t\t\t\t\tint cnt = dfs(i, j, map[j][i]);\n\t\t\t\t\tif(cnt >= 4) { del(i, j, map[j][i]); ch = true; }\n//\t\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t}\n\t\t\t\tif(!ch) break;\n\t\t\t\tdown();\n//\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1};\n\tint[][] tmp;\n\tint dfs(int x, int y, int c) {\n//\t\tdebug(x, y);\n\t\ttmp[y][x] = 0;\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if(tmp[y+dy[i]][x+dx[i]] == c) cnt += dfs(x+dx[i], y+dy[i], c);\n\t\treturn cnt;\n\t}\n\t\n\tvoid del(int x, int y, int c) {\n\t\tmap[y][x] = 0;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(map[y+dy[i]][x+dx[i]] == c) del(x+dx[i], y+dy[i], c);\n\t\t\tif(map[y+dy[i]][x+dx[i]] == 1) map[y+dy[i]][x+dx[i]] = 0;\n\t\t}\n\t}\n\t\n\tvoid down() {\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tfor(int k=0;k<=h+2;k++) for(int i=0;i<=h-1;i++) \n\t\t\t\tif(map[i+1][j] == 0) { map[i+1][j] = map[i][j]; map[i][j] = 0;}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t = scanner.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tmap = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\tint ans = 0;\n\t\t\tv = new boolean[h][w];\n\t\t\twhile (true) {\n\t\t\t\tboolean flag = false;\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tArrays.fill(v[i], false);\n\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\t\tif (map[y][x] == '.' || map[y][x] == 'O' || v[y][x])\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstep = 0;\n\t\t\t\t\t\tif (!slove(y, x, map[y][x]))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tdfs(y, x, map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t\tfor (int i = 0; i < 11; i++) {\n\t\t\t\t\tfor (int y = 0; y < 11; y++) {\n\t\t\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\t\t\tif (map[y][x] != '.' && map[y + 1][x] == '.') {\n\t\t\t\t\t\t\t\tmap[y + 1][x] = map[y][x];\n\t\t\t\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dfs(int y, int x, char c) {\n\t\tmap[y][x] = '.';\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == 'O') {\n\t\t\t\tmap[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (map[ny][nx] != c)\n\t\t\t\tcontinue;\n\t\t\tdfs(ny, nx, c);\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int y, int x, char c) {\n\t\tstep++;\n\t\tv[y][x] = true;\n\t\tif (step == 4)\n\t\t\treturn true;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] != c || v[ny][nx])\n\t\t\t\tcontinue;\n\t\t\tif (slove(ny, nx, c))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint h = 12, w = 6;\n\tint step;\n\tchar[][] map;\n\tboolean[][] v;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint[][] map;\n\tString rp = \".OPYBGR\";\n\tint w = 6, h = 12;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(;t>0;t--) {\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=12;i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j=0;j<rp.length();j++) s = s.replace(rp.charAt(j), (char)('0' + j));\n\t\t\t\tfor(int j=1;j<=6;j++) map[i][j] = s.charAt(j-1) - '0';\n\t\t\t}\n\t\t\tboolean ch = true;\n\t\t\tint c = 0;\n//\t\t\tfor(int[] a: map) debug(a);\n\t\t\tfor(;;c++) {\n\t\t\t\tch = false;\n\t\t\t\tfor(int i=1;i<=w;i++) for(int j=1;j<h;j++) if(map[j][i] > 1) {\n\t\t\t\t\tint cnt = dfs(i, j, map[j][i]);\n\t\t\t\t\tif(cnt >= 4) { del(i, j, map[j][i]); ch = true; }\n//\t\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t}\n\t\t\t\tif(!ch) break;\n\t\t\t\tdown();\n//\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1};\n\tint dfs(int x, int y, int c) {\n//\t\tdebug(x, y);\n\t\tmap[y][x] = 0;\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if(map[y+dy[i]][x+dx[i]] == c) cnt += dfs(x+dx[i], y+dy[i], c);\n\t\tmap[y][x] = c;\n\t\treturn cnt;\n\t}\n\t\n\tvoid del(int x, int y, int c) {\n\t\tmap[y][x] = 0;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(map[y+dy[i]][x+dx[i]] == c) del(x+dx[i], y+dy[i], c);\n\t\t\tif(map[y+dy[i]][x+dx[i]] == 1) map[y+dy[i]][x+dx[i]] = 0;\n\t\t}\n\t}\n\t\n\tvoid down() {\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tfor(int k=0;k<=h;k++) for(int i=0;i<=h-2;i++) \n\t\t\t\tif(map[i+1][j] == 0) { map[i+1][j] = map[i][j]; map[i][j] = 0;}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint[][] map;\n\tString rp = \".OPYBGR\";\n\tint w = 6, h = 12;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(;t>0;t--) {\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=12;i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j=0;j<rp.length();j++) s = s.replace(rp.charAt(j), (char)('0' + j));\n\t\t\t\tfor(int j=1;j<=6;j++) map[i][j] = s.charAt(j-1) - '0';\n\t\t\t}\n\t\t\tboolean ch = true;\n\t\t\tint c = 0;\n//\t\t\tfor(int[] a: map) debug(a);\n\t\t\tfor(;;c++) {\n\t\t\t\tch = false;\n\t\t\t\tfor(int i=1;i<=w;i++) for(int j=1;j<=h;j++) if(map[j][i] > 1) {\n\t\t\t\t\tint cnt = dfs(i, j, map[j][i]);\n\t\t\t\t\tif(cnt >= 4) { del(i, j, map[j][i]); ch = true; }\n//\t\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t}\n\t\t\t\tif(!ch) break;\n\t\t\t\tdown();\n//\t\t\t\tfor(int[] a: map) debug(a);\n\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\n\tint dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1};\n\tint dfs(int x, int y, int c) {\n//\t\tdebug(x, y);\n\t\tmap[y][x] = 0;\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if(map[y+dy[i]][x+dx[i]] == c) cnt += dfs(x+dx[i], y+dy[i], c);\n\t\tmap[y][x] = c;\n\t\treturn cnt;\n\t}\n\n\tvoid del(int x, int y, int c) {\n\t\tmap[y][x] = 0;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(map[y+dy[i]][x+dx[i]] == c) del(x+dx[i], y+dy[i], c);\n\t\t\tif(map[y+dy[i]][x+dx[i]] == 1) map[y+dy[i]][x+dx[i]] = 0;\n\t\t}\n\t}\n\n\tvoid down() {\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tfor(int k=0;k<=h+2;k++) for(int i=0;i<=h-1;i++)\n\t\t\t\tif(map[i+1][j] == 0) { map[i+1][j] = map[i][j]; map[i][j] = 0;}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint[][] map;\n\tString rp = \".OPYBGR\";\n\tint w = 6, h = 12;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(;t>0;t--) {\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=12;i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j=0;j<rp.length();j++) s = s.replace(rp.charAt(j), (char)('0' + j));\n\t\t\t\tfor(int j=1;j<=6;j++) map[i][j] = s.charAt(j-1) - '0';\n\t\t\t}\n\t\t\tboolean ch = true;\n\t\t\tint c = 0;\n//\t\t\tfor(int[] a: map) debug(a);\n\t\t\tfor(;;c++) {\n\t\t\t\tch = false;\n\t\t\t\tfor(int i=1;i<=w;i++) for(int j=1;j<h;j++) if(map[j][i] > 1) {\n\t\t\t\t\tint cnt = dfs(i, j, map[j][i]);\n\t\t\t\t\tif(cnt >= 4) { del(i, j, map[j][i]); ch = true; }\n//\t\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t}\n\t\t\t\tif(!ch) break;\n\t\t\t\tdown();\n//\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1};\n\tint dfs(int x, int y, int c) {\n//\t\tdebug(x, y);\n\t\tmap[y][x] = 0;\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if(map[y+dy[i]][x+dx[i]] == c) cnt += dfs(x+dx[i], y+dy[i], c);\n\t\tmap[y][x] = c;\n\t\treturn cnt;\n\t}\n\t\n\tvoid del(int x, int y, int c) {\n\t\tmap[y][x] = 0;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(map[y+dy[i]][x+dx[i]] == c) del(x+dx[i], y+dy[i], c);\n\t\t\tif(map[y+dy[i]][x+dx[i]] == 1) map[y+dy[i]][x+dx[i]] = 0;\n\t\t}\n\t}\n\t\n\tvoid down() {\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tfor(int k=0;k<=h;k++) for(int i=0;i<=h-1;i++) \n\t\t\t\tif(map[i+1][j] == 0) { map[i+1][j] = map[i][j]; map[i][j] = 0;}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Compile\npublic class Main{\n\n\tpublic static char[][] map;\n\tpublic static boolean[][] mark;\n\tpublic static int count;\n\tpublic static int[][] move = {{1,0}, {0,1}, {-1,0}, {0, -1}};\n\n\tpublic static void dfs(int i, int j, char ch){\n\t\tmark[i][j] = true;\n\t\tcount++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint i2 = i + move[k][0];\n\t\t\tint j2 = j + move[k][1];\n\t\t\tif(0<=i2&&i2<12&&0<=j2&&j2<6&&!mark[i2][j2]&&map[i2][j2]==ch){\n\t\t\t\tdfs(i2, j2, ch);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean delete(int i, int j, char ch){\n\t\tif(ch=='O')return false;\n\t\tmark = new boolean[12][6];\n\t\tcount = 0;\n\t\tdfs(i,j,ch);\n\t\tif(count<4)return false;\n\t\tfor(int m=0;m<12;m++){\n\t\t\tfor(int n=0;n<6;n++){\n\t\t\t\tif(mark[m][n]){\n\t\t\t\t\tmap[m][n] = '.';\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint m2 = m + move[k][0];\n\t\t\t\t\t\tint n2 = n + move[k][1];\n\t\t\t\t\t\tif(0<=m2&&m2<12&&0<=n2&&n2<6&&map[m2][n2]=='O')\n\t\t\t\t\t\t\tmap[m2][n2] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\tmap = new char[12][6];\n\t\t\tfor(int i=0;i<12;i++)map[i]=sc.next().toCharArray();\n\t\t\tint chain = 0;\n\t\t\twhile(true){\n\t\t\t\tboolean f = false;\n\t\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\t\tif(map[i][j]!='.')\n\t\t\t\t\t\t\tf |= delete(i,j,map[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)break;\n\t\t\t\tchain++;\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tfor(int i=11;i>=1;i--){\n\t\t\t\t\t\tif(map[i][j]=='.'){\n\t\t\t\t\t\t\tint k = i-1;\n\t\t\t\t\t\t\twhile(k>=0&&map[k][j]=='.')k--;\n\t\t\t\t\t\t\tif(k<0)break;\n\t\t\t\t\t\t\tfor(int m=k;m<i;m++){\n\t\t\t\t\t\t\t\tmap[m+1][j] = map[m][j];\n\t\t\t\t\t\t\t\tmap[m][j] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(chain);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t = scanner.nextInt();\n\t\tStringBuilder builder = new StringBuilder();\n\t\twhile (t-- > 0) {\n\t\t\tg = new char[12][6];\n\t\t\tps = new boolean[12][6];\n\t\t\tfor (int y = 0; y < 12; y++)\n\t\t\t\tg[y] = scanner.next().toCharArray();\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tboolean co = false;\n\t\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\t\tArrays.fill(ps[j], false);\n\t\t\t\t}\n\n\t\t\t\tfor (int y = 0; y < 12; y++) {\n\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\tstep = 0;\n\t\t\t\t\t\tif (!cn(y, x, g[y][x]))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcr(y, x, g[y][x]);\n\t\t\t\t\t\tco = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!co) {\n\t\t\t\t\tbuilder.append(i).append('\\n');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 11; j++)\n\t\t\t\t\tfor (int y = 0; y < 11; y++)\n\t\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\t\tif (g[y][x] != '.' && g[y + 1][x] == '.') {\n\t\t\t\t\t\t\t\tg[y + 1][x] = g[y][x];\n\t\t\t\t\t\t\t\tg[y][x] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tSystem.out.print(builder);\n\t}\n\n\tprivate void cr(int y, int x, char p) {\n\t\tif (g[y][x] != p)\n\t\t\treturn;\n\t\tg[y][x] = '.';\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\t\t\tif (g[ny][nx] == 'O') {\n\t\t\t\tg[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcr(ny, nx, p);\n\n\t\t}\n\t}\n\n\tprivate boolean cn(int y, int x, char p) {\n\t\tif (p == 'O' || p == '.' || p != g[y][x] || ps[y][x])\n\t\t\treturn false;\n\t\tstep++;\n\t\tif (step == 4)\n\t\t\treturn true;\n\t\tps[y][x] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\n\t\t\tif (cn(ny, nx, p))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int nx, int ny) {\n\t\treturn 0 <= nx && nx < 6 && 0 <= ny && ny < 12;\n\t}\n\n\tint step;\n\tchar[][] g;\n\tboolean[][] ps;\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t = scanner.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tg = new char[12][6];\n\t\t\tps = new boolean[12][6];\n\t\t\tfor (int y = 0; y < 12; y++)\n\t\t\t\tg[y] = scanner.next().toCharArray();\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tboolean co = false;\n\t\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\t\tArrays.fill(ps[j], false);\n\t\t\t\t}\n\n\t\t\t\tfor (int y = 0; y < 12; y++) {\n\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\tif (cn(y, x, g[y][x]) < 4)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcr(y, x, g[y][x]);\n\t\t\t\t\t\tco = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!co) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 11; j++)\n\t\t\t\t\tfor (int y = 0; y < 11; y++)\n\t\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\t\tif (g[y][x] != '.' && g[y + 1][x] == '.') {\n\t\t\t\t\t\t\t\tchar tmp = g[y][x];\n\t\t\t\t\t\t\t\tg[y][x] = g[y + 1][x];\n\t\t\t\t\t\t\t\tg[y + 1][x] = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void cr(int y, int x, char p) {\n\t\tif (g[y][x] != p)\n\t\t\treturn;\n\t\tg[y][x] = '.';\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\t\t\tif (g[ny][nx] == 'O') {\n\t\t\t\tg[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcr(ny, nx, p);\n\n\t\t}\n\t}\n\n\tprivate int cn(int y, int x, char p) {\n\t\tint cc = 0;\n\t\tif (p == 'O' || p == '.' || p != g[y][x] || ps[y][x])\n\t\t\treturn 0;\n\t\telse {\n\t\t\tps[y][x] = true;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (!isOK(nx, ny))\n\t\t\t\t\tcontinue;\n\t\t\t\tcc += cn(ny, nx, p);\n\t\t\t}\n\t\t}\n\t\treturn cc + 1;\n\t}\n\n\tprivate boolean isOK(int nx, int ny) {\n\t\treturn 0 <= nx && nx < 6 && 0 <= ny && ny < 12;\n\t}\n\n\tchar[][] g;\n\tboolean[][] ps;\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t = scanner.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tg = new char[12][6];\n\t\t\tps = new boolean[12][6];\n\t\t\tfor (int y = 0; y < 12; y++)\n\t\t\t\tg[y] = scanner.next().toCharArray();\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tboolean co = false;\n\t\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\t\tArrays.fill(ps[j], false);\n\t\t\t\t}\n\n\t\t\t\tfor (int y = 0; y < 12; y++) {\n\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\tstep = 0;\n\t\t\t\t\t\tif (!cn(y, x, g[y][x]))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcr(y, x, g[y][x]);\n\t\t\t\t\t\tco = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!co) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 11; j++)\n\t\t\t\t\tfor (int y = 0; y < 11; y++)\n\t\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\t\tif (g[y][x] != '.' && g[y + 1][x] == '.') {\n\t\t\t\t\t\t\t\tg[y + 1][x] = g[y][x];\n\t\t\t\t\t\t\t\tg[y][x] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void cr(int y, int x, char p) {\n\t\tif (g[y][x] != p)\n\t\t\treturn;\n\t\tg[y][x] = '.';\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\t\t\tif (g[ny][nx] == 'O') {\n\t\t\t\tg[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcr(ny, nx, p);\n\n\t\t}\n\t}\n\n\tprivate boolean cn(int y, int x, char p) {\n\t\tif (p == 'O' || p == '.' || p != g[y][x] || ps[y][x])\n\t\t\treturn false;\n\t\tstep++;\n\t\tif (step == 4)\n\t\t\treturn true;\n\t\tps[y][x] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\n\t\t\tif (cn(ny, nx, p))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int nx, int ny) {\n\t\treturn 0 <= nx && nx < 6 && 0 <= ny && ny < 12;\n\t}\n\n\tint step;\n\tchar[][] g;\n\tboolean[][] ps;\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    boolean debug = false;\n\n    char[][] f;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n    int d;\n    int rensa;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        while(n-->0){\n            f = new char[12][6];\n            for(int i=0; i<12; i++){\n                f[i] = sc.next().toCharArray();\n            }\n\n            rensa = 0;\n            delete();\n            calc();\n            System.out.println(rensa);\n        }\n    }\n\n    void calc(){\n        d = 1;\n        while(d!=0){\n            d = 0;\n            for(int i=0; i<12; i++){\n                for(int j=0; j<6; j++){\n                    if(f[i][j]!='.' && f[i][j]!='O' && f[i][j]!='x'){\n                        bfs(f[i][j],j,i);\n                    }\n                }\n            }\n            \n            if(d!=0){\n                delete();\n                rensa++;\n                if(debug){\n                    for(int i=0; i<12; i++){\n                        System.out.println(Arrays.toString(f[i]));\n                    }\n                }\n            }else break;\n        }\n    }\n\n    void bfs(char c, int sx, int sy){\n        Queue<int[]> q = new LinkedList<int[]>();\n        Queue<int[]> qq = new LinkedList<int[]>();\n        q.add(new int[]{sx,sy});\n        qq.add(new int[]{sx,sy});\n        int cnt = 0;\n        boolean[][] v = new boolean[12][6];\n        v[sy][sx] = true;\n\n        while(q.size()>0){\n            int[] xy = q.poll();\n            int x = xy[0], y = xy[1];\n\n            for(int i=0; i<4; i++){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(nx>=0 && nx<6 && ny>=0 && ny<12 \n                   && f[ny][nx]==c && !v[ny][nx]){\n                    q.add(new int[]{nx,ny});\n                    qq.add(new int[]{nx,ny});\n                    v[ny][nx] = true;\n                }\n            }\n        }\n\n        if(debug) System.out.println(c+\" \"+qq.size());\n\n        if(qq.size()>=4){\n            d++;\n            while(qq.size()>0){\n                int[] xy = qq.poll();\n                f[xy[1]][xy[0]] = 'x';\n                for(int i=0; i<4; i++){\n                    int nx = xy[0]+dx[i], ny = xy[1]+dy[i];\n                    if(nx>=0 && nx<6 && ny>=0 && ny<12 \n                       && f[ny][nx]=='O'){\n                        f[ny][nx] = 'x'; \n                    }\n                }\n            }\n        }\n    }\n\n    void delete(){\n        for(int i=0; i<6; i++){\n            Queue<Character> q = new LinkedList<Character>();\n            for(int j=11; j>=0; j--){\n                if(f[j][i]!='x' && f[j][i]!='.'){\n                    q.add(f[j][i]);\n                }\n            }\n            for(int j=11; j>=0; j--){\n                if(q.size()>0) f[j][i] = q.poll();\n                else f[j][i] = '.';\n            }\n        }\n    }\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t = scanner.nextInt();\n\t\tStringBuilder builder = new StringBuilder();\n\t\twhile (t-- > 0) {\n\t\t\tg = new char[12][6];\n\t\t\tps = new boolean[12][6];\n\t\t\tfor (int y = 0; y < 12; y++)\n\t\t\t\tg[y] = scanner.next().toCharArray();\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tboolean co = false;\n\t\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\t\tArrays.fill(ps[j], false);\n\t\t\t\t}\n\n\t\t\t\tfor (int y = 0; y < 12; y++) {\n\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\tstep = 0;\n\t\t\t\t\t\tif (!cn(y, x, g[y][x]))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcr(y, x, g[y][x]);\n\t\t\t\t\t\tco = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!co) {\n\t\t\t\t\tbuilder.append(i).append('\\n');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 11; j++)\n\t\t\t\t\tfor (int y = 0; y < 11; y++)\n\t\t\t\t\t\tfor (int x = 0; x < 6; x++) {\n\t\t\t\t\t\t\tif (g[y][x] != '.' && g[y + 1][x] == '.') {\n\t\t\t\t\t\t\t\tg[y + 1][x] = g[y][x];\n\t\t\t\t\t\t\t\tg[y][x] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(builder);\n\t\t}\n\t}\n\n\tprivate void cr(int y, int x, char p) {\n\t\tif (g[y][x] != p)\n\t\t\treturn;\n\t\tg[y][x] = '.';\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\t\t\tif (g[ny][nx] == 'O') {\n\t\t\t\tg[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcr(ny, nx, p);\n\n\t\t}\n\t}\n\n\tprivate boolean cn(int y, int x, char p) {\n\t\tif (p == 'O' || p == '.' || p != g[y][x] || ps[y][x])\n\t\t\treturn false;\n\t\tstep++;\n\t\tif (step == 4)\n\t\t\treturn true;\n\t\tps[y][x] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!isOK(nx, ny))\n\t\t\t\tcontinue;\n\n\t\t\tif (cn(ny, nx, p))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int nx, int ny) {\n\t\treturn 0 <= nx && nx < 6 && 0 <= ny && ny < 12;\n\t}\n\n\tint step;\n\tchar[][] g;\n\tboolean[][] ps;\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    boolean debug = false;\n\n    char[][] f;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n    int d;\n    int rensa;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        while(n-->0){\n            f = new char[12][6];\n            for(int i=0; i<12; i++){\n                f[i] = sc.next().toCharArray();\n            }\n\n            rensa = 0;\n            calc();\n            System.out.println(rensa);\n        }\n    }\n\n    void calc(){\n        d = 1;\n        while(d!=0){\n            d = 0;\n            for(int i=0; i<12; i++){\n                for(int j=0; j<6; j++){\n                    if(f[i][j]!='.' && f[i][j]!='O' && f[i][j]!='x'){\n                        bfs(f[i][j],j,i);\n                    }\n                }\n            }\n            \n            if(d!=0){\n                delete();\n                rensa++;\n                if(debug){\n                    for(int i=0; i<12; i++){\n                        System.out.println(Arrays.toString(f[i]));\n                    }\n                }\n            }else break;\n        }\n    }\n\n    void bfs(char c, int sx, int sy){\n        Queue<int[]> q = new LinkedList<int[]>();\n        Queue<int[]> qq = new LinkedList<int[]>();\n        q.add(new int[]{sx,sy});\n        qq.add(new int[]{sx,sy});\n        int cnt = 0;\n        boolean[][] v = new boolean[12][6];\n        v[sy][sx] = true;\n\n        while(q.size()>0){\n            int[] xy = q.poll();\n            int x = xy[0], y = xy[1];\n\n            for(int i=0; i<4; i++){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(nx>=0 && nx<6 && ny>=0 && ny<12 \n                   && f[ny][nx]==c && !v[ny][nx]){\n                    q.add(new int[]{nx,ny});\n                    qq.add(new int[]{nx,ny});\n                    v[ny][nx] = true;\n                }\n            }\n        }\n\n        if(debug) System.out.println(c+\" \"+qq.size());\n\n        if(qq.size()>=4){\n            d++;\n            while(qq.size()>0){\n                int[] xy = qq.poll();\n                f[xy[1]][xy[0]] = 'x';\n                for(int i=0; i<4; i++){\n                    int nx = xy[0]+dx[i], ny = xy[1]+dy[i];\n                    if(nx>=0 && nx<6 && ny>=0 && ny<12 \n                       && f[ny][nx]=='O'){\n                        f[ny][nx] = 'x'; \n                    }\n                }\n            }\n        }\n    }\n\n    void delete(){\n        for(int i=0; i<6; i++){\n            Queue<Character> q = new LinkedList<Character>();\n            for(int j=11; j>=0; j--){\n                if(f[j][i]!='x' && f[j][i]!='O' && f[j][i]!='.'){\n                    q.add(f[j][i]);\n                }\n            }\n            for(int j=11; j>=0; j--){\n                if(q.size()>0) f[j][i] = q.poll();\n                else f[j][i] = '.';\n            }\n        }\n    }\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint[][] map;\n\tString rp = \".OPYBGR\";\n\tint w = 6, h = 12;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(;t>0;t--) {\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=12;i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j=0;j<rp.length();j++) s = s.replace(rp.charAt(j), (char)('0' + j));\n\t\t\t\tfor(int j=1;j<=6;j++) map[i][j] = s.charAt(j-1) - '0';\n\t\t\t}\n\t\t\tboolean ch = true;\n\t\t\tint c = 0;\n//\t\t\tfor(int[] a: map) debug(a);\n\t\t\tfor(;;c++) {\n\t\t\t\tch = false;\n\t\t\t\tfor(int i=1;i<=w;i++) for(int j=1;j<=h;j++) if(map[j][i] > 1) {\n\t\t\t\t\tint cnt = dfs(i, j, map[j][i]);\n\t\t\t\t\tif(cnt >= 4) { del(i, j, map[j][i]); ch = true; }\n//\t\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\t}\n\t\t\t\tif(!ch) break;\n\t\t\t\tdown();\n//\t\t\t\tfor(int[] a: map) debug(a);\n\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\n\tint dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1};\n\tint dfs(int x, int y, int c) {\n//\t\tdebug(x, y);\n\t\tmap[y][x] = 0;\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if(map[y+dy[i]][x+dx[i]] == c) cnt += dfs(x+dx[i], y+dy[i], c);\n\t\tmap[y][x] = c;\n\t\treturn cnt;\n\t}\n\n\tvoid del(int x, int y, int c) {\n\t\tmap[y][x] = 0;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(map[y+dy[i]][x+dx[i]] == c) del(x+dx[i], y+dy[i], c);\n\t\t\tif(map[y+dy[i]][x+dx[i]] == 1) map[y+dy[i]][x+dx[i]] = 0;\n\t\t}\n\t}\n\n\tvoid down() {\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tfor(int k=0;k<=h+2;k++) for(int i=0;i<=h-1;i++)\n\t\t\t\tif(map[i+1][j] == 0) { map[i+1][j] = map[i][j]; map[i][j] = 0;}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int X_MAX = 6;\n\tpublic static final int Y_MAX = 12;\n\n\tpublic static final int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static boolean is_ok(int x, int y){\n\t\tif(x < 0 || x >= X_MAX || y < 0 || y >= Y_MAX){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static int detect(int x, int y, char[][] map, boolean[][] visited){\n\t\tvisited[y][x] = true;\n\t\t\n\t\tint ret = 1;\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(!is_ok(nx, ny)){\n\t\t\t\tcontinue;\n\t\t\t}else if(visited[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[y][x] != map[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tret += detect(nx, ny, map, visited);\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void erase_dfs(int x, int y, char[][] map){\n\t\tchar old = map[y][x];\n\t\tmap[y][x] = '.';\n\t\t\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(!is_ok(nx, ny)){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == 'O'){\n\t\t\t\tmap[ny][nx] = '.';\n\t\t\t\tcontinue;\n\t\t\t}else if(old != map[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\terase_dfs(nx, ny, map);\n\t\t}\n\t}\n\t\n\tpublic static boolean erase(char[][] map, boolean[][] checked){\n\t\tfor(int i = 0; i < Y_MAX; i++){\n\t\t\tArrays.fill(checked[i], false);\n\t\t}\n\t\t\n\t\tboolean erased = false;\n\t\t\n\t\tfor(int y = 0; y < Y_MAX; y++){\n\t\t\tfor(int x = 0; x < X_MAX; x++){\n\t\t\t\tif(map[y][x] == 'O' || map[y][x] == '.'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(checked[y][x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint chain = detect(x, y, map, checked);\n\t\t\t\t\n\t\t\t\tif(chain >= 4){\n\t\t\t\t\terase_dfs(x, y, map);\n\t\t\t\t\terased = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn erased;\n\t}\n\t\n\tpublic static void fall(char[][] map){\n\t\tfor(int x = 0; x < X_MAX; x++){\n\t\t\tboolean found = false;\n\t\t\t\n\t\t\tfor(int y = 0; y < Y_MAX - 1; y++){\n\t\t\t\tif(map[y][x] != '.' && map[y + 1][x] == '.'){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tmap[y+1][x] = map[y][x];\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(found){\n\t\t\t\tx--;\n\t\t\t}\n\t\t\t//print(map);\n\t\t}\n\t}\n\t\n\tpublic static void print(char[][] map){\n\t\tfor(int i = 0; i < Y_MAX; i++){\n\t\t\tfor(int j = 0; j < X_MAX; j++){\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"-------------\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tchar[][] map = new char[Y_MAX][X_MAX];\n\t\tboolean[][] checked = new boolean[Y_MAX][X_MAX];\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int t = 0; t < T; t++){\n\t\t\tfor(int i = 0; i < Y_MAX; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < X_MAX; j++){\n\t\t\t\t\tmap[i][j] = input[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t//print(map);\n\t\t\twhile(true){\n\t\t\t\tboolean ok = erase(map, checked);\n\t\t\t\t\n\t\t\t\tif(!ok){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//print(map);\n\t\t\t\tfall(map);\n\t\t\t\t//print(map);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\n\npublic class Main {\n\t\n\tint n;\n\tString[] strs;\n\tHashMap<String, Integer> map;\n\tString[] ind2str;\n\tint NONVAL = (1<<28);\n\tint[][] d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();sc.nextLine();\n\t\t\tif(n ==0 ) break;\n\t\t\tstrs = new String[n];\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) strs[i] = sc.nextLine();\n\t\t\t\n\t\t\tint p = 0;\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tif(!map.containsKey(sp[1])) map.put(sp[1], p++);\n\t\t\t\tif(!map.containsKey(sp[4])) map.put(sp[4], p++);\n\t\t\t}\n\t\t\tint size = map.size();\n\t\t\td = new int[size][size];\n\t\t\tfor(int[] a: d) fill(a, NONVAL);\n\t\t\tfor(String str: strs) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\td[map.get(sp[1])][map.get(sp[4])] = Integer.parseInt(sp[3].substring(3));\n\t\t\t\td[map.get(sp[4])][map.get(sp[1])] = -Integer.parseInt(sp[3].substring(3));\n\t\t\t}\n\t\t\t\n\t\t\tn = size;\n\t\t\tfor(int i=0;i<n;i++) d[i][i] = 0;\n//\t\t\tdebug(d);\n\t\t\tboolean flg = true;\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n\t\t\t}\n//\t\t\tdebug(d);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tflg &= d[i][i] < 0 ;\n\t\t\t}\n\t\t\tSystem.out.println((flg? \"No\": \"Yes\"));\n\t\t}\n\t\t\n\t}\n\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n  public static final int HEIGHT = 12;\n  public static final int WIDTH = 6;\n  public static final int dx[] = {1, -1, 0, 0};\n  public static final int dy[] = {0, 0, 1, -1};\n\n  /**\n   * テ、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツ?淌・ツコツァテヲツィツ凖」ツ?古」ツδ陛」ツつ」テ」ツδシテ」ツδォテ」ツδ嘉」ツ?ョテァツッツ?・ツ崢イテ・ツ??」ツ?ォテ・ツ渉偲」ツ?セテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?凝・ツ按、テ・ツョツ堙」ツ?凖」ツつ凝」ツ??\n   * @param x テヲツィツェティツサツク(0-index)\n   * @param y テァツクツヲティツサツク(0-index)\n   * @return (x,y)テ」ツ?古ァツッツ?・ツ崢イテ・ツ??」ツ?ォテ・ツ渉偲」ツ?セテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ古」ツ?ーtrue\n   */\n  public static boolean withinRange(int x, int y){\n    return 0 <= x && x < WIDTH && 0 <= y && y < HEIGHT;\n  }\n\n  /**\n   * field[y][x]テ」ツ?凝」ツつ嘉ァツケツ凝」ツ?古」ツつ凝・ツ青古」ツ?佚ァツィツョテゥツ。ツ榲」ツ?ョテ」ツ?キテ」ツつ暗」ツつ津ヲツカツ暗」ツ?凖」ツ?づ」ツ?陛」ツつ嘉」ツ?ォテゥツ堋」テヲツ篠・テ」ツ?凖」ツつ凝」ツ?甘ゥツつェテゥツュツ氾」ツ?キテ」ツつ暗」ツ?古」ツ?づ」ツつ古」ツ?ーテ・ツ可甘ゥツ卍、テ」ツ?凖」ツつ凝」ツ??\n   * @param field テ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテ」ツδ陛」ツつ」テ」ツδシテ」ツδォテ」ツδ?\n   * @param x テヲツィツェティツサツク(0-index)\n   * @param y テァツクツヲティツサツク(0-index)\n   * @param kind field[y][x]テ」ツ?ョテ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテァツィツョテゥツ。ツ?\n   */\n  public static void deleteConnectedPuyo(char[][] field, int x, int y, char kind){\n    field[y][x] = '.';\n\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n\n      if(!withinRange(nx, ny)) continue;\n      if(field[ny][nx] == 'O'){\n        field[ny][nx] = '.';\n      }\n      else if(field[ny][nx] == kind){\n        deleteConnectedPuyo(field, nx, ny, kind);\n      }\n    }\n  }\n\n  /**\n   * field[y][x]テ」ツ?凝」ツつ嘉ァツケツ凝」ツ?古」ツつ凝・ツ青古」ツ?佚ァツィツョテゥツ。ツ榲」ツ?ョテ」ツ?キテ」ツつ暗」ツ?ョテヲツ閉ーテ」ツつ津ヲツ閉ーテ」ツ?暗」ツつ?\n   * @param field テ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテ」ツδ陛」ツつ」テ」ツδシテ」ツδォテ」ツδ?\n   * @param x テヲツィツェティツサツク(0-index)\n   * @param y テァツクツヲティツサツク(0-index)\n   * @param kind field[y][x]テ」ツ?ョテ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテァツィツョテゥツ。ツ?\n   * @return field[y][x]テ」ツ?凝」ツつ嘉ァツケツ凝」ツ?古」ツつ凝・ツ青古」ツ?佚ァツィツョテゥツ。ツ榲」ツ?ョテ」ツ?キテ」ツつ暗」ツ?ョテヲツ閉ー\n   */\n  public static int countConnectedPuyo(char[][] field, int x, int y, char kind){\n    field[y][x] = '.';\n\n    int connectedPuyo = 1;\n\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n\n      if(!withinRange(nx, ny)) continue;\n      if(field[ny][nx] != kind) continue;\n\n      connectedPuyo += countConnectedPuyo(field, nx, ny, kind);\n    }\n\n    field[y][x] = kind;\n\n    return connectedPuyo;\n  }\n\n  /**\n   * テ・ツ?ィテ」ツ?ヲテ」ツ?ョテ」ツ?キテ」ツつ暗」ツつ津・ツ崢コテ・ツョツ堙」ツ?ァテ」ツ?催」ツつ凝、ツスツ催ァツスツョテ」ツ?セテ」ツ?ァティツ青ステ」ツ?ィテ」ツ?凖」ツ??\n   * @param field テ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテ」ツδ陛」ツつ」テ」ツδシテ」ツδォテ」ツδ?\n   */\n  public static void dropPuyo(char[][] field){\n    for(int i = HEIGHT - 1; i > 0; i--){\n      for(int j = 0; j < WIDTH; j++){\n        if(field[i][j] != '.') continue;\n\n        for(int ni = i - 1; ni >= 0; ni--){\n          if(field[ni][j] != '.'){\n            field[i][j] = field[ni][j];\n            field[ni][j] = '.';\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * テ、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツ?淌」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテ」ツδ陛」ツつ」テ」ツδシテ」ツδォテ」ツδ嘉」ツ?ョテゥツ?」テゥツ篠姪ヲツ閉ーテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n   * @param field テ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテ」ツδ陛」ツつ」テ」ツδシテ」ツδォテ」ツδ?\n   * @return テ」ツ?キテ」ツつ暗」ツ?キテ」ツつ暗」ツ?ョテゥツ?」テゥツ篠姪ヲツ閉ー\n   */\n  public static int getChain(char[][] field){\n    int chain = 0;\n\n    while(true){\n      boolean deleteFlg = false;\n\n      for(int i = 0; i < HEIGHT; i++){\n        for(int j = 0; j < WIDTH; j++){\n          if(field[i][j] == '.') continue;\n          if(field[i][j] == 'O') continue;\n          if(countConnectedPuyo(field, j, i, field[i][j]) < 4) continue;\n\n          deleteConnectedPuyo(field, j, i, field[i][j]);\n          deleteFlg = true;\n        }\n      }\n\n      if(!deleteFlg){\n        break;\n      }\n      \n      dropPuyo(field);\n      chain++;\n    }\n\n    return chain;\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int T = sc.nextInt();\n\n    while(T-- > 0){\n      char[][] field = new char[HEIGHT][WIDTH];\n\n      for(int i = 0; i < HEIGHT; i++){\n        field[i] = sc.next().toCharArray();\n      }\n\n      System.out.println(getChain(field));\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[][] map;\n\tboolean[][] visit;\n\tint cnt;\n\tboolean flag;\n\t\n\tvoid drop(){\n\t\tfor(int i=0;i<6;i++){\n\t\t\tchar[] temp = new char[12];\n\t\t\tArrays.fill(temp, '.');\n\t\t\tint k = 0;\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tif(map[j][i]!='.'){\n\t\t\t\t\ttemp[k] = map[j][i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<12;j++) map[j][i] = temp[j];\n\t\t}\n\t}\n\t\n\tvoid func(){\n\t\tLinkedList<Integer> x = new LinkedList<Integer>();\n\t\tLinkedList<Integer> y = new LinkedList<Integer>();\n\t\tLinkedList<Integer> sx = new LinkedList<Integer>();\n\t\tLinkedList<Integer> sy = new LinkedList<Integer>();\t\t\n\t\tint cnt, p, q;\n\t\t\n\t\tfor(int z=0;;z++){\n\t\t\tflag = false;\n\t\t\tvisit = new boolean[12][6];\n\t\t\tfor(int i=0;i<12;i++){\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(map[i][j]=='R' || map[i][j]=='G' || map[i][j]=='B' || map[i][j]=='Y' || map[i][j]=='P'){\n\t\t\t\t\t\t\n\t\t\t\t\t\tx.offer(j);\n\t\t\t\t\t\ty.offer(i);\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\twhile(x.size()!=0){\n\t\t\t\t\t\t\tp = x.poll();\n\t\t\t\t\t\t\tq = y.poll();\n\t\t\t\t\t\t\tsx.offer(p);\n\t\t\t\t\t\t\tsy.offer(q);\n\t\t\t\t\t\t\tvisit[q][p] = true;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(p-1>=0 && visit[q][p-1]==false && map[q][p-1]==map[i][j]){\n\t\t\t\t\t\t\t\tx.offer(p-1);\n\t\t\t\t\t\t\t\ty.offer(q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p+1<6 && visit[q][p+1]==false && map[q][p+1]==map[i][j]){\n\t\t\t\t\t\t\t\tx.offer(p+1);\n\t\t\t\t\t\t\t\ty.offer(q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(q-1>=0 && visit[q-1][p]==false && map[q-1][p]==map[i][j]){\n\t\t\t\t\t\t\t\tx.offer(p);\n\t\t\t\t\t\t\t\ty.offer(q-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(q+1<12 && visit[q+1][p]==false && map[q+1][p]==map[i][j]){\n\t\t\t\t\t\t\t\tx.offer(p);\n\t\t\t\t\t\t\t\ty.offer(q+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=4){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\twhile(sx.size()!=0){\n\t\t\t\t\t\t\t\tp = sx.poll();\n\t\t\t\t\t\t\t\tq = sy.poll();\n\t\t\t\t\t\t\t\tmap[q][p] = '.';\n\t\t\t\t\t\t\t\tif(p-1>=0 && map[q][p-1]=='O') map[q][p-1] = '.';\n\t\t\t\t\t\t\t\tif(p+1<6 && map[q][p+1]=='O') map[q][p+1] = '.';\n\t\t\t\t\t\t\t\tif(q-1>=0 && map[q-1][p]=='O') map[q-1][p] = '.';\n\t\t\t\t\t\t\t\tif(q+1<12 && map[q+1][p]=='O') map[q+1][p] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tsx.clear();\n\t\t\t\t\t\t\tsy.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false){\n\t\t\t\tSystem.out.println(z);\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tdrop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint T = sc.nextInt();\n\t\tfor(int t=0;t<T;t++){\n\t\t\tmap = new char[12][6];\n\t\t\tfor(int i=11;i>=0;i--) map[i] = sc.next().toCharArray();\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color,cnt){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         cnt++;\n         if(cnt==4)p.push([yy,xx]);\n         yx[yy][xx]=color+0;\n         bomb(yy,xx,color,cnt);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){yx[i][j]=\"R\"+0;bomb(i,j,\"R\",1);}\n                  if(yx[i][j]==\"G\"){yx[i][j]=\"G\"+0;bomb(i,j,\"G\",1);}\n                  if(yx[i][j]==\"B\"){yx[i][j]=\"B\"+0;bomb(i,j,\"B\",1);}\n                  if(yx[i][j]==\"Y\"){yx[i][j]=\"Y\"+0;bomb(i,j,\"Y\",1);}\n                  if(yx[i][j]==\"P\"){yx[i][j]=\"P\"+0;bomb(i,j,\"P\",1);}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            if(color!=\".\")BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color,cnt){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=12)continue;\n      if(yx[yy][xx]==color) {\n         cnt++;\n         if(cnt==4)p.push([yy,xx]);\n         yx[yy][xx]=color+0;\n         bomb(yy,xx,color,cnt);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color || yx[yy][xx]==\"O\") {\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){yx[i][j]=\"R\"+0;bomb(i,j,\"R\",1);}\n                  if(yx[i][j]==\"G\"){yx[i][j]=\"G\"+0;bomb(i,j,\"G\",1);}\n                  if(yx[i][j]==\"B\"){yx[i][j]=\"B\"+0;bomb(i,j,\"B\",1);}\n                  if(yx[i][j]==\"Y\"){yx[i][j]=\"Y\"+0;bomb(i,j,\"Y\",1);}\n                  if(yx[i][j]==\"P\"){yx[i][j]=\"P\"+0;bomb(i,j,\"P\",1);}\n               }\n         }\n         if(p.length==0)break;\n         result++; \n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         CNT++;\n         if(CNT==4)p.push([yy,xx]);\n         yx[yy][xx]=color+CNT;\n         bomb(yy,xx,color);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n        var CNT;\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){CNT=1;yx[i][j]=\"R\"+CNT;bomb(i,j,\"R\");}\n                  if(yx[i][j]==\"G\"){CNT=1;yx[i][j]=\"G\"+CNT;bomb(i,j,\"G\");}\n                  if(yx[i][j]==\"B\"){CNT=1;yx[i][j]=\"B\"+CNT;bomb(i,j,\"B\");}\n                  if(yx[i][j]==\"Y\"){CNT=1;yx[i][j]=\"Y\"+CNT;bomb(i,j,\"Y\");}\n                  if(yx[i][j]==\"P\"){CNT=1;yx[i][j]=\"P\"+CNT;bomb(i,j,\"P\");}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            if(color!=\".\")BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         CNT++;\n         if(CNT==4)p.push([yy,xx]);\n         yx[yy][xx]=color+CNT;\n         bomb(yy,xx,color);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n        var CNT;\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){CNT=1;yx[i][j]=\"R\"+CNT;bomb(i,j,\"R\");}\n                  if(yx[i][j]==\"G\"){CNT=1;yx[i][j]=\"G\"+CNT;bomb(i,j,\"G\");}\n                  if(yx[i][j]==\"B\"){CNT=1;yx[i][j]=\"B\"+CNT;bomb(i,j,\"B\");}\n                  if(yx[i][j]==\"Y\"){CNT=1;yx[i][j]=\"Y\"+CNT;bomb(i,j,\"Y\");}\n                  if(yx[i][j]==\"P\"){CNT=1;yx[i][j]=\"P\"+CNT;bomb(i,j,\"P\");}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            if(color!=\".\")BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color,cnt){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=12)continue;\n      if(yx[yy][xx]==color) {\n         cnt++;\n         if(cnt==4)p.push([yy,xx]);\n         yx[yy][xx]=color+0;\n         bomb(yy,xx,color,cnt);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color || yx[yy][xx]==\"O\") {\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){yx[i][j]=\"R\"+0;bomb(i,j,\"R\",1);}\n                  if(yx[i][j]==\"G\"){yx[i][j]=\"G\"+0;bomb(i,j,\"G\",1);}\n                  if(yx[i][j]==\"B\"){yx[i][j]=\"B\"+0;bomb(i,j,\"B\",1);}\n                  if(yx[i][j]==\"Y\"){yx[i][j]=\"Y\"+0;bomb(i,j,\"Y\",1);}\n                  if(yx[i][j]==\"P\"){yx[i][j]=\"P\"+0;bomb(i,j,\"P\",1);}\n               }\n         }\n         if(p.length==0)break;\n         result++; \n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         CNT++;\n         if(CNT==4)p.push([yy,xx]);\n         yx[yy][xx]=color+0;\n         bomb(yy,xx,color);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n        var CNT;\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){yx[i][j]=\"R\"+0;CNT=1;bomb(i,j,\"R\");}\n                  if(yx[i][j]==\"G\"){yx[i][j]=\"G\"+0;CNT=1;bomb(i,j,\"G\");}\n                  if(yx[i][j]==\"B\"){yx[i][j]=\"B\"+0;CNT=1;bomb(i,j,\"B\");}\n                  if(yx[i][j]==\"Y\"){yx[i][j]=\"Y\"+0;CNT=1;bomb(i,j,\"Y\");}\n                  if(yx[i][j]==\"P\"){yx[i][j]=\"P\"+0;CNT=1;bomb(i,j,\"P\");}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            if(color!=\".\")BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color,cnt){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         cnt++;\n         if(cnt==4)p.push([yy,xx]);\n         yx[yy][xx]=color+0;\n         bomb(yy,xx,color,cnt);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){yx[i][j]=\"R\"+0;bomb(i,j,\"R\",1);}\n                  if(yx[i][j]==\"G\"){yx[i][j]=\"G\"+0;bomb(i,j,\"G\",1);}\n                  if(yx[i][j]==\"B\"){yx[i][j]=\"B\"+0;bomb(i,j,\"B\",1);}\n                  if(yx[i][j]==\"Y\"){yx[i][j]=\"Y\"+0;bomb(i,j,\"Y\",1);}\n                  if(yx[i][j]==\"P\"){yx[i][j]=\"P\"+0;bomb(i,j,\"P\",1);}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            if(color!=\".\")BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color) {\n         CNT++;\n         if(CNT==4)p.push([yy,xx]);\n         yx[yy][xx]=color+CNT;\n         bomb(yy,xx,color);\n      }\n   }\n}\nfunction BOMB(y,x,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || xx<0 || yy>=12 || xx>=6)continue;\n      if(yx[yy][xx]==color){\n         yx[yy][xx]=\".\";\n         BOMB(yy,xx,color);\n      }else if(yx[yy][xx]==\"O\"){\n         yx[yy][xx]=\".\";\n      }\n   }\n}\nfunction up(y,x){\n   var yy=y;\n   while(y>0){\n      y--;\n      if(yx[y][x]!=\".\"){\n         yx[yy][x]=yx[y][x];\n         yx[y][x]=\".\";\n         break;\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nfor(var I=0;I<n;I++){\n   var yx=[];\n   for(var i=0;i<12;i++){\n      var arr=(Arr.shift()).split(\"\");\n      yx.push(arr);\n   }\n   var result=0;  \n   while(true){\n        var p=[];\n        var CNT;\n         for(var i=0;i<12;i++){\n               for(var j=0;j<6;j++){\n                  if(yx[i][j]==\"R\"){CNT=1;yx[i][j]=\"R\"+CNT;bomb(i,j,\"R\");}\n                  if(yx[i][j]==\"G\"){CNT=1;yx[i][j]=\"G\"+CNT;bomb(i,j,\"G\");}\n                  if(yx[i][j]==\"B\"){CNT=1;yx[i][j]=\"B\"+CNT;bomb(i,j,\"B\");}\n                  if(yx[i][j]==\"Y\"){CNT=1;yx[i][j]=\"Y\"+CNT;bomb(i,j,\"Y\");}\n                  if(yx[i][j]==\"P\"){CNT=1;yx[i][j]=\"P\"+CNT;bomb(i,j,\"P\");}\n               }\n         }\n         for(var i=0;i<12;i++){\n            for(var j=0;j<6;j++){\n               yx[i][j]=yx[i][j].slice(0,1);\n            }\n         }\n         if(p.length==0)break;\n         result++; \n         p.forEach(function(v){\n            var i=v[0];\n            var j=v[1];\n            var color=yx[i][j];\n            BOMB(i,j,color);\n         });\n         for(var i=11;i>0;i--){\n            for(var j=0;j<6;j++){\n               if(yx[i][j]==\".\")up(i,j);\n            }\n         }\n   }\n   console.log(result);\n}"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(old, cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      unless check[i][j] || old[i][j] == 'O' || old[i][j] == '.'\n        puyo_connector(i, j, old){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if old[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n #check.each{ |c| c.each{ |d| print d ? 1 : 0}; puts}\n #puts\n  fld = puyo_eraser(old, check)\n  if res == 1 then puyo_rensa(fld, cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ndef puyo_eraser(fld, check)\n  fld = fld.transpose\n  nfld = 8.times.map{ [] }\n  8.times do |i|\n    13.downto(0) do |j|\n      unless check.transpose[i][j]\n        nfld[i] << fld[i][j]\n      end\n    end\n    (14 - nfld[i].size).times{ nfld[i] << '.' }\n    nfld[i].reverse!\n  end\n  nfld.transpose\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(fld, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "def puyo_rensa(cnt, fld)\n  erase = 8.times.map{ [nil] * 14 }\n  (1..6).each do |i|\n    (1..12).each do |j|\n      if erase[i][j].nil? && fld[i][j] =~ /[^O.]/\n        erase[i][j] = false\n        puyo_connector(i, j, fld, erase){ |arr|\n          arr.each do |s, t|\n            drct(s, t).each do |p, q|\n              erase[p][q] = true if fld[p][q] == 'O'\n            end\n            erase[s][t] = true\n          end\n        }\n      end\n    end\n  end\n  if erase.flatten.any?{ |v| v } then puyo_rensa(cnt + 1, puyo_eraser(fld, erase))\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld, erase)\n  arr = [[i, j]]\n  ret = [[i, j]]\n  until arr.empty?\n    i, j = arr.shift\n    drct(i, j).each do |p, q|\n      if erase[p][q].nil? && fld[i][j] == fld[p][q]\n        erase[p][q] = false\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret) if ret.size >= 4\nend\n\ndef puyo_eraser(fld, erase)\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless erase[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  fld\nend\n\ndef drct(x, y)\n  [[-1, 0], [1, 0], [0, -1], [0, 1]].map{ |p, q| [p + x, q + y] }\nend\n\ngets.to_i.times do\n  fld = 8.times.map{ ['.'] * 14 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[j + 1][i + 1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt, fld)\n  erase = 8.times.map{ [false] * 14 }\n  visit = 8.times.map{ [false] * 14 }\n  res = 0\n  (1..6).each do |i|\n    (1..12).each do |j|\n      if !visit[i][j] && fld[i][j] =~ /[^O.]/\n        puyo_connector(i, j, fld, visit){ |arr|\n          arr.each do |s, t|\n            D.each do |x, y|\n              p, q = s + x, t + y\n              erase[p][q] = true if fld[p][q] == 'O'\n            end\n            erase[s][t] = true\n          end\n          res = 1\n        }\n      end\n    end\n  end\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless erase[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  if res == 1 then puyo_rensa(cnt + 1, fld)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld, visit)\n  arr = [[i, j]]\n  ret = [[i, j]]\n  visit[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !visit[p][q] && fld[i][j] == fld[p][q]\n        visit[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret) if ret.size >= 4\nend\n\ngets.to_i.times do\n  fld = 8.times.map{ ['.'] * 14 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[j+1][i+1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt, fld)\n  erase = 8.times.map{ [-1] * 14 }\n  (1..6).each do |i|\n    (1..12).each do |j|\n      if fld[i][j] =~ /[^O.]/ && erase[i][j] < 0\n        puyo_connector(i, j, fld, erase){ |arr|\n          arr.each do |s, t|\n            D.each do |x, y|\n              p, q = s + x, t + y\n              erase[p][q] += 2 if fld[p][q] == 'O'\n            end\n            erase[s][t] += 1\n          end\n        }\n      end\n    end\n  end\n  if erase.flatten.any?{ |v| v >= 1 } then puyo_rensa(cnt + 1, puyo_eraser(fld, erase))\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld, visit)\n  arr = [[i, j]]\n  ret = [[i, j]]\n  visit[i][j] += 1\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if visit[p][q] < 0 && fld[i][j] == fld[p][q]\n        visit[p][q] += 1\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret) if ret.size >= 4\nend\n\ndef puyo_eraser(fld, erase)\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless erase[i][j] >= 1 }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  fld\nend\n\ngets.to_i.times do\n  fld = 8.times.map{ ['.'] * 14 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[j+1][i+1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(old, cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      if !check[i][j] && old[i][j] =~ /[^O.]/\n        puyo_connector(i, j, old){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if old[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n  fld = puyo_eraser(old, check)\n  if res == 1 then puyo_rensa(fld, cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ndef puyo_eraser(fld, check)\n  fld = fld.transpose\n  check = check.transpose\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless check[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  fld.transpose\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(fld, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(old, cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      if !check[i][j] && old[i][j] =~ /[^O.]/\n        puyo_connector(i, j, old){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if old[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n  fld = puyo_eraser(old, check)\n  if res == 1 then puyo_rensa(fld, cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ndef puyo_eraser(fld, check)\n  nfld = 14.times.map{ |i| fld[i].dup }\n  pos = [0] * 7\n  13.downto(0) do |i|\n    (1..6).each do |j|\n      if check[i][j]\n        (1..i).each do |k|\n          nfld[k + pos[j]][j] = fld[k - 1][j]\n        end\n        nfld[pos[j]][j] = '.'\n        pos[j] += 1\n      end\n    end\n  end\n  nfld\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(fld, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt, fld)\n  erase = 8.times.map{ [false] * 14 }\n  visit = 8.times.map{ [false] * 14 }\n  res = 0\n  (1..6).each do |i|\n    (1..12).each do |j|\n      if fld[i][j] =~ /[^O.]/ && !visit[i][j]\n        puyo_connector(i, j, fld, visit){ |arr|\n          arr.each do |s, t|\n            D.each do |x, y|\n              p, q = s + x, t + y\n              erase[p][q] = true if fld[p][q] == 'O'\n            end\n            erase[s][t] = true\n          end\n          res = 1\n        }\n      end\n    end\n  end\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless erase[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  if res == 1 then puyo_rensa(cnt + 1, fld)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld, visit)\n  arr = [[i, j]]\n  ret = [[i, j]]\n  visit[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !visit[p][q] && fld[i][j] == fld[p][q]\n        visit[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret) if ret.size >= 4\nend\n\ngets.to_i.times do\n  fld = 8.times.map{ ['.'] * 14 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[j+1][i+1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt, fld)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      if !check[i][j] && fld[i][j] =~ /[^O.]/\n        puyo_connector(i, j,fld){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if fld[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n  fld = fld.transpose\n  check = check.transpose\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless check[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  fld = fld.transpose\n  if res == 1 then puyo_rensa(cnt + 1, fld)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(old, cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      unless check[i][j] || old[i][j] == 'O' || old[i][j] == '.'\n        puyo_connector(i, j, old){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if old[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n  fld = puyo_eraser(old, check)\n  if res == 1 then puyo_rensa(fld, cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ndef puyo_eraser(fld, check)\n  nfld = 14.times.map{ |i| fld[i].dup }\n  pos = [0] * 7\n  13.downto(0) do |i|\n    (1..6).each do |j|\n      if check[i][j]\n        (1..i).each do |k|\n          nfld[k + pos[j]][j] = fld[k - 1][j]\n        end\n        nfld[pos[j]][j] = '.'\n        pos[j] += 1\n      end\n    end\n  end\n  nfld\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(fld, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt, fld)\n  erase = 8.times.map{ [nil] * 14 }\n  (1..6).each do |i|\n    (1..12).each do |j|\n      if fld[i][j] =~ /[^O.]/ && erase[i][j].nil?\n        erase[i][j] = false\n        puyo_connector(i, j, fld, erase){ |arr|\n          arr.each do |s, t|\n            D.each do |x, y|\n              p, q = s + x, t + y\n              erase[p][q] = true if fld[p][q] == 'O'\n            end\n            erase[s][t] = true\n          end\n        }\n      end\n    end\n  end\n  if erase.flatten.any?{ |v| v } then puyo_rensa(cnt + 1, puyo_eraser(fld, erase))\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld, erase)\n  arr = [[i, j]]\n  ret = [[i, j]]\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if erase[p][q].nil? && fld[i][j] == fld[p][q]\n        erase[p][q] = false\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret) if ret.size >= 4\nend\n\ndef puyo_eraser(fld, erase)\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless erase[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  fld\nend\n\ngets.to_i.times do\n  fld = 8.times.map{ ['.'] * 14 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[j+1][i+1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Ruby",
    "code": "H = 12\nW = 6\nX = \".\"\nO = \"O\"\n\ndef count!(field, y, x)\n  color = field[y][x]\n  field[y][x] = X\n  nex = [[-1, 0], [1, 0], [0, -1], [0, 1]].map{|dy, dx| [y + dy, x + dx]}\n  1 + nex.map{|ny, nx| field[ny][nx] != color ? 0 : count!(field, ny, nx)}.inject(:+)\nend\n\ndef count(field, y, x)\n  count!(Marshal.load(Marshal.dump(field)), y, x)\nend\n\ndef vanish!(field, y, x)\n  color = field[y][x]\n  field[y][x] = X\n  nex = [[-1, 0], [1, 0], [0, -1], [0, 1]].map{|dy, dx| [y + dy, x + dx]}\n  nex.each do |ny, nx|\n    field[ny][nx] = X if field[ny][nx] == O\n    vanish!(field, ny, nx) if field[ny][nx] == color\n  end\nend\n\ndef uyenimo!(field)\n  done = false\n  1.upto(H) do |y|\n    1.upto(W) do |x|\n      next if field[y][x] == X || field[y][x] == O\n      next if count(field, y, x) < 4\n      vanish!(field, y, x)\n      done = true\n    end\n  end\n  done\nend\n\ndef fall!(field)\n  1.upto(W) do |x|\n    H.downto(1) do |y|\n      next unless field[y][x] == X\n      y.downto(1) do |i|\n        next if field[i][x] == X\n        field[y][x], field[i][x] = field[i][x], field[y][x]\n        break\n      end\n    end\n  end\nend\n\ngets.to_i.times do\n  field = Array.new(H + 2){X * (W + 2)}\n  field[1, H] = H.times.map{X + gets.chomp + X}\n  chain = 0\n  while uyenimo!(field) do\n    fall!(field)\n    chain += 1\n  end\n  puts chain\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      if !check[i][j] && $fld[i][j] =~ /[^O.]/\n        puyo_connector(i, j){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if $fld[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n  fld = $fld.transpose\n  check = check.transpose\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless check[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  $fld = fld.transpose\n  if res == 1 then puyo_rensa(cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && $fld[i][j] == $fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ngets.to_i.times do\n  $fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      $fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(0)\nend"
  },
  {
    "language": "Ruby",
    "code": "def count(field, y, x)\n  result = 1\n  color = field[y][x]\n  field[y][x] = \".\"\n  dy = [-1, 1, 0, 0]\n  dx = [0, 0, -1, 1]\n  for i in 0...4 do\n    result += count(field, y + dy[i], x + dx[i]) if field[y + dy[i]][x + dx[i]] == color\n  end\n  field[y][x] = color\n  result\nend\n\ndef vanish(field, y, x)\n  color = field[y][x]\n  field[y][x] = \".\"\n  dy = [-1, 1, 0, 0]\n  dx = [0, 0, -1, 1]\n  for i in 0...4 do\n    vanish(field, y + dy[i], x + dx[i]) if field[y + dy[i]][x + dx[i]] == color\n    field[y + dy[i]][x + dx[i]] = \".\" if field[y + dy[i]][x + dx[i]] == \"O\"\n  end\nend\n\ndef delete!(field)\n  deleted = false\n  for i in 1..H do\n    for j in 1..W do\n      next if field[i][j] == \".\" || field[i][j] == \"O\"\n      next if count(field, i, j) < 4\n      vanish(field, i, j)\n      deleted = true\n    end\n  end\n  deleted\nend\n\ndef fall!(field)\n  for j in 1..W do\n    H.downto(1) do |i|\n      next if field[i][j] != \".\"\n      i.downto(1) do |k|\n        next if field[k][j] == \".\"\n        field[i][j], field[k][j] = field[k][j], field[i][j]\n        break\n      end\n    end\n  end\nend\n\nH = 12\nW = 6\ngets.to_i.times do\n  field = Array.new(H + 2) {Array.new(W + 2, \".\")}\n  for i in 1..H do\n    field[i][1, W] = gets.chomp.chars\n  end\n\n  chain = 0\n  while delete!(field) do\n    fall!(field)\n    chain += 1\n  end\n  puts chain\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(old, cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      unless check[i][j] || old[i][j] == 'O' || old[i][j] == '.'\n        puyo_connector(i, j, old){ |arr|\n          if arr.size >= 4\n            arr.each do |x, y|\n              check[x][y] = true\n              res = 1\n            end\n          end\n        }\n      end\n    end\n  end\n\n  (1..12).each do |i|\n    (1..6).each do |j|\n      if check[i][j]\n        D.each do |x, y|\n          p, q = i + x, j + y\n          check[p][q] = true if old[p][q] == 'O'\n        end\n      end\n    end\n  end\n  fld = puyo_erase(old, check)\n  if res == 1 then puyo_rensa(fld, cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ndef puyo_erase(fld, check)\n  fld = fld.transpose\n  nfld = 8.times.map{ [] }\n  8.times do |i|\n    13.downto(0) do |j|\n      unless check.transpose[i][j]\n        nfld[i] << fld[i][j]\n      end\n    end\n    (14 - nfld[i].size).times{ nfld[i] << '.' }\n    nfld[i].reverse!\n  end\n  nfld.transpose\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(fld, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(old, cnt)\n  check = 14.times.map{ [false] * 8 }\n  res = 0\n  (1..12).each do |i|\n    (1..6).each do |j|\n      unless check[i][j] || old[i][j] == 'O' || old[i][j] == '.'\n        puyo_connector(i, j, old){ |arr|\n          if arr.size >= 4\n            arr.each do |x, y|\n              check[x][y] = true\n              res = 1\n            end\n          end\n        }\n      end\n    end\n  end\n\n  buf = []\n  (1..12).each do |i|\n    (1..6).each do |j|\n      if check[i][j]\n        D.each do |x, y|\n          p, q = i + x, j + y\n          buf << [p, q] if old[p][q] == 'O'\n        end\n      end\n    end\n  end\n  buf.each{ |x, y| check[x][y] = true }\n  fld = puyo_erase(old, check)\n  if res == 1 then puyo_rensa(fld, cnt + 1)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 14.times.map{ [false] * 8 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ndef puyo_erase(fld, check)\n  fld = fld.transpose\n  nfld = 8.times.map{ [] }\n  8.times do |i|\n    13.downto(0) do |j|\n      unless check.transpose[i][j]\n        nfld[i] << fld[i][j]\n      end\n    end\n    (14 - nfld[i].size).times{ nfld[i] << '.' }\n    nfld[i].reverse!\n  end\n  nfld.transpose\nend\n\ngets.to_i.times do\n  fld = 14.times.map{ ['.'] * 8 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[i+1][j+1] = c\n    end\n  end\n  p puyo_rensa(fld, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\ndef puyo_rensa(cnt, fld)\n  check = 8.times.map{ [false] * 14 }\n  res = 0\n  (1..6).each do |i|\n    (1..12).each do |j|\n      if !check[i][j] && fld[i][j] =~ /[^O.]/\n        puyo_connector(i, j,fld){ |arr|\n          if arr.size >= 4\n            arr.each do |s, t|\n              D.each do |x, y|\n                p, q = s + x, t + y\n                check[p][q] = true if fld[p][q] == 'O'\n              end\n              check[s][t] = true\n            end\n            res = 1\n          end\n        }\n      end\n    end\n  end\n  (1..6).each do |i|\n    fld[i].map!.with_index{ |c, j| c unless check[i][j] }.compact!\n    (14 - fld[i].size).times{ fld[i].unshift('.') }\n  end\n  if res == 1 then puyo_rensa(cnt + 1, fld)\n  else cnt\n  end\nend\n\ndef puyo_connector(i, j, fld)\n  check = 8.times.map{ [false] * 14 }\n  arr = [[i, j]]\n  ret = [[i, j]]\n  check[i][j] = true\n  until arr.empty?\n    i, j = arr.shift\n    D.each do |x, y|\n      p, q = i + x,  j + y\n      if !check[p][q] && fld[i][j] == fld[p][q]\n        check[p][q] = true\n        arr << [p, q]\n        ret << [p, q]\n      end\n    end\n  end\n  yield(ret)\nend\n\ngets.to_i.times do\n  fld = 8.times.map{ ['.'] * 14 }\n  12.times do |i|\n    gets.chomp.split('').each_with_index do |c, j|\n      fld[j+1][i+1] = c\n    end\n  end\n  p puyo_rensa(0, fld)\nend"
  },
  {
    "language": "Python",
    "code": "t = int(input())\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\nfor _ in range(t):\n  def check(x, y, lst, checked):\n    checked[y][x] = False\n    color = mp[y][x]\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if color == mp[ny][nx] and checked[ny][nx] == None:\n        lst.append((nx, ny))\n        check(nx, ny, lst, checked)\n  \n  mp = [list(\"X\" * 8)] + [list(\"X\" + input() + \"X\") for _ in range(12)] + [list(\"X\" * 8)]\n  cnt = 0\n  \n  while True:\n    checked = [[None] * 8 for _ in range(14)]\n    for y in range(1, 13):\n      for x in range(1, 7):\n        if mp[y][x] in (\"O\", \".\", \"X\"):\n          checked[y][x] = False\n        elif checked[y][x] == None:\n          lst = [(x, y)]\n          check(x, y, lst, checked)\n          length = len(lst)\n          if length < 4:continue\n          for nx, ny in lst:\n            checked[ny][nx] = True\n  \n    if not any(any(lst) for lst in checked):\n      break\n    \n    for y in range(1, 13):\n      for x in range(1, 7):\n        if mp[y][x] == \"O\":\n          for dx, dy in vec:\n            nx, ny = x + dx, y + dy\n            if mp[ny][nx] != \"O\" and checked[ny][nx]:\n              checked[y][x] = True\n    \n    for y in range(1, 13):\n      for x in range(1, 7):\n        if checked[y][x]:\n          mp[y][x] = \".\"\n  \n    for x in range(1, 7):\n      s = \"\"\n      for y in range(12, 0, -1):\n        s = mp[y][x] + s\n      s = s.replace(\".\", \"\")\n      s = \".\" * (12 - len(s)) + s\n      for y in range(12, 0, -1):\n        mp[y][x] = s[y - 1]\n  \n    cnt += 1\n  \n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "def kesu(x, s, c, h):\n    global n\n    if (x[0] - 1, x[1]) not in s and a[x[0] - 1][x[1]] == c:\n        s.add((x[0] - 1, x[1]))\n        kesu((x[0] - 1, x[1]), s, c, h + 1) \n    if (x[0] + 1, x[1]) not in s and a[x[0] + 1][x[1]] == c:\n        s.add((x[0] + 1, x[1]))\n        kesu((x[0] + 1, x[1]), s, c, h + 1) \n    if (x[0], x[1] - 1) not in s and a[x[0]][x[1] - 1] == c:\n        s.add((x[0], x[1] - 1))\n        kesu((x[0], x[1] - 1), s, c, h + 1) \n    if (x[0], x[1] + 1) not in s and a[x[0]][x[1] + 1] == c:\n        s.add((x[0], x[1] + 1))\n        kesu((x[0], x[1] + 1), s, c, h + 1)\n    if h == 0 and len(s) > 3:\n        for i in s:a[i[0]][i[1]] = \".\"\n        n |= s\n\ndef otosu():\n    for i in range(1,12)[::-1]:\n        for j in range(1, 7):\n            n = 0\n            while i + n < 12:\n                if a[i + n][j] != \".\" and a[i + n + 1][j] == \".\":\n                    a[i + n][j], a[i + n + 1][j] = a[i + n + 1][j], a[i + n][j]\n                    n += 1\n                else:break\n                \n\nfor _ in range(int(input())):\n    a = [[\".\" for _ in range(8)]] + [[\".\"] + list(input()) + [\".\"] for _ in range(12)] + [[\".\" for _ in range(8)]]\n    rensa = 0\n    while 1:\n        n = set()\n        for i in range(1, 13):\n            for j in range(1, 7):\n                if a[i][j] in (\"RGBYP\"):\n                    kesu((i, j), set(), a[i][j], 0)\n        if n == set():break\n        else:\n            rensa += 1\n            for i in range(1, 13):\n                for j in range(1, 7):\n                    if a[i][j] == \"O\":\n                        if (i - 1, j) in n or (i + 1, j) in n or (i, j - 1) in n or (i, j + 1) in n:a[i][j] = \".\"\n        otosu()\n    print(rensa)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\nLOOP = input()\nfor loop in range(LOOP):\n    puyo = []\n    for i in range(12):\n        puyo.append(list(raw_input()))\n    \n    for cnt in range(20):\n        used = [[False] * 6 for i in range(12)]\n        def func(y, x, c):\n            if y < 0 or x < 0 or y >= 12 or x >= 6:\n                return 0\n            if puyo[y][x] != c or used[y][x]:\n                return 0\n            used[y][x] = True\n            ret = 1\n            ret += func(y - 1, x, c)\n            ret += func(y + 1, x, c)\n            ret += func(y, x - 1, c)\n            ret += func(y, x + 1, c)\n            return ret\n\n        def erase(y, x, c):\n            if y < 0 or x < 0 or y >= 12 or x >= 6:\n                return\n            if puyo[y][x] == 'O':\n                puyo[y][x] = '.'\n                return\n            if puyo[y][x] != c:\n                return\n            puyo[y][x] = '.'\n            erase(y - 1, x, c)\n            erase(y + 1, x, c)\n            erase(y, x - 1, c)\n            erase(y, x + 1, c)\n\n        flag = True\n        for i in range(12):\n            for j in range(6):\n                if puyo[i][j] in \"RGBYP\":\n                    num = func(i, j, puyo[i][j])\n                    if num >= 4:\n                        flag = False\n                        erase(i, j, puyo[i][j])\n        for t in range(50):\n            for i in range(1, 12):\n                for j in range(6):\n                    if puyo[i][j] == '.':\n                        puyo[i][j], puyo[i - 1][j] = puyo[i - 1][j], puyo[i][j]\n        if flag:\n            print cnt\n            break\n"
  },
  {
    "language": "Python",
    "code": "t = int(input())\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\nfor _ in range(t):\n  def check(x, y, lst, checked):\n    checked[y][x] = False\n    color = mp[y][x]\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if color == mp[ny][nx] and checked[ny][nx] == None:\n        lst.append((nx, ny))\n        check(nx, ny, lst, checked)\n  \n  mp = [list(\"X\" * 8)] + [list(\"X\" + input() + \"X\") for _ in range(12)] + [list(\"X\" * 8)]\n  cnt = 0\n  \n  while True:\n    checked = [[None] * 8 for _ in range(14)]\n    for y in range(1, 13):\n      for x in range(1, 7):\n        if mp[y][x] in (\"O\", \".\", \"X\"):\n          checked[y][x] = False\n        elif checked[y][x] == None:\n          lst = [(x, y)]\n          check(x, y, lst, checked)\n          length = len(lst)\n          if length < 4:continue\n          for nx, ny in lst:\n            checked[ny][nx] = True\n  \n    if not any(any(lst) for lst in checked):\n      break\n    \n    for y in range(1, 13):\n      for x in range(1, 7):\n        if mp[y][x] == \"O\":\n          for dx, dy in vec:\n            nx, ny = x + dx, y + dy\n            if mp[ny][nx] != \"0\" and checked[ny][nx]:\n              checked[y][x] = True\n    \n    for y in range(1, 13):\n      for x in range(1, 7):\n        if checked[y][x]:\n          mp[y][x] = \".\"\n  \n    for x in range(1, 7):\n      s = \"\"\n      for y in range(12, 0, -1):\n        s = mp[y][x] + s\n      s = s.replace(\".\", \"\")\n      s = \".\" * (12 - len(s)) + s\n      for y in range(12, 0, -1):\n        mp[y][x] = s[y - 1]\n  \n    cnt += 1\n  \n  print(cnt)\n"
  }
]