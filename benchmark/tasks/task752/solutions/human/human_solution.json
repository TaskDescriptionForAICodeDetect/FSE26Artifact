[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 160;\ntypedef long long LL;\nint mod;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint solve1(int n, int K) {\n\tstatic int f[MAXN][MAXN];\n\tmemset(f, 0, sizeof f);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemcpy(f[i] + 1, f[i - 1], K << 2);\n\t\tfor (int j = 0; j < K; ++j)\n\t\t\tf[i][0] = std::accumulate(f[i - 1], f[i], 0ll) % mod;\n\t}\n\treturn std::accumulate(f[n], f[n + 1], 0ll) % mod;\n}\nint n, K;\nstruct status {\n\tint l, r, ll, rl;\n\tbool operator < (const status & b) const {\n\t\tif (l != b.l) return l < b.l;\n\t\tif (r != b.r) return r < b.r;\n\t\tif (ll != b.ll) return ll < b.ll;\n\t\treturn rl < b.rl;\n\t}\n} ;\nstd::map<status, int> dp[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> K >> mod;\n\tint ans = 0;\n\tif (K % 2 == 0)\n\t\tans = (LL) solve1(n >> 1, K >> 1) * solve1(n - (n >> 1), K >> 1) % mod;\n\telse {\n\t\tint now = 1, lst = 0;\n\t\tdp[now][(status) {0, 0, n + 1, n + 1}] = 1;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::swap(now, lst); dp[now].clear();\n\t\t\tfor (auto j : dp[lst]) {\n\t\t\t\tauto t = j.first; int v = j.second;\n\t\t\t\tif (i & 1) {\n\t\t\t\t\treduce(dp[now][(status) {0, t.r, n + 1, t.rl}] += v - mod);\n\t\t\t\t\tif (t.ll > i + 1) {\n\t\t\t\t\t\tint tl = t.rl;\n\t\t\t\t\t\tif (i + 2 - 2 * t.r + K <= i + 1)\n\t\t\t\t\t\t\ttl = std::min(tl, i + 1 - 2 * t.l + K);\n\t\t\t\t\t\treduce(dp[now][(status) {t.l + 1, t.r, t.ll, tl}] += v - mod);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treduce(dp[now][(status) {t.l, 0, t.ll, n + 1}] += v - mod);\n\t\t\t\t\tif (t.rl > i + 1) {\n\t\t\t\t\t\tint tl = t.ll;\n\t\t\t\t\t\tif (i + 2 - 2 * t.l + K <= i + 1)\n\t\t\t\t\t\t\ttl = std::min(tl, i + 1 - 2 * t.r + K);\n\t\t\t\t\t\treduce(dp[now][(status) {t.l, t.r + 1, tl, t.rl}] += v - mod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto t : dp[now]) reduce(ans += t.second - mod);\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 150\nint n,s,p,dp1[N],dp2[N][N][N],pw[N];\nint solve(int m)\n{\n\tdp1[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(i>s/2+1)dp1[i]=(2ll*dp1[i-1]-dp1[i-s/2-2]+p)%p;\n\t\telse if(i==s/2+1)dp1[i]=(2ll*dp1[i-1]-1+p)%p;\n\t\telse dp1[i]=2ll*dp1[i-1]%p;\n\t}\n\treturn dp1[m];\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&s,&p);\n\tpw[0]=1;for(int i=1;i<=150;i++)pw[i]=pw[i-1]*2%p;\n\tif(~s&1)printf(\"%lld\\n\",1ll*solve(n/2)*solve(n-n/2)%p);\n\telse \n\tif(s==1) s=4,printf(\"%d\\n\",solve(n));\n\telse \n\t{\n\t\tint l2=n/2,l1=n-n/2;\n\t\tif(n<=s){int as=1;for(int i=1;i<=n;i++)as=as*2%p;printf(\"%d\\n\",as);return 0;}\n\t\tfor(int i=0;i<=(s+1)/2;i++)dp2[0][0][i]=(s+1)/2==i?1:pw[(s+1)/2-i-1];\n\t\tfor(int i=0;i<l1-(s+1)/2;i++)\n\t\tfor(int j=0;j<=s+1;j++)\n\t\tfor(int k=0;k<=n;k++)\n\t\tif(dp2[i][j][k])\n\t\t{\n\t\t\tdp2[i+1][0][0]=(dp2[i+1][0][0]+dp2[i][j][k])%p;\n\t\t\tdp2[i+1][0][k+1]=(dp2[i+1][0][k+1]+dp2[i][j][k])%p;\n\t\t\tif(j<s+1)\n\t\t\t{\n\t\t\t\tdp2[i+1][j==0?0:j+1][0]=(dp2[i+1][j==0?j:j+1][0]+dp2[i][j][k])%p;\n\t\t\t\tint st=j<k+1?k+2:j+1;\n\t\t\t\tif(st<=s+1)dp2[i+1][st][k+1]=(dp2[i+1][st][k+1]+dp2[i][j][k])%p;\n\t\t\t}\n\t\t}\n\t\tint as=0,ls=l2-(l1-(s+1)/2);\n\t\tfor(int i=0;i<=s+1;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tint tp=dp2[l1-(s+1)/2][i][j],s1=pw[ls];\n\t\t\tif(ls-(s+2-i)>=0)\n\t\t\ts1=(s1-pw[ls-(s+2-i)]+p)%p;\n\t\t\tas=(as+1ll*tp*s1)%p;\n\t\t}\n\t\tprintf(\"%d\\n\",as);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=155;\nint n,k,mod;\nint f[maxn][maxn][maxn];\nmap<pii,int>g[maxn][maxn][maxn];\nvoid Add(int &a,int b){a+=b;if(a>=mod)a-=mod;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tif(k%2==0){\n\t\tk/=2;\n\t\tf[0][0][0]=1;\n\t\trep(i,n)rep(p,k+1)rep(q,k+1){\n\t\t\tint cur=f[i][p][q];\n\t\t\tif(!cur)continue;\n\t\t\tAdd(f[i+1][q+1][p],cur);\n\t\t\tAdd(f[i+1][0][p],cur);\n\t\t}\n\t\tint ans=0;\n\t\trep(p,k+1)rep(q,k+1)Add(ans,f[n][p][q]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\telse{\n\t\tg[0][0][0][mp(n+1,n+1)]=1;\n\t\trep(i,n)rep(p,i/2+2)rep(q,i/2+2){\n\t\t\tfor(map<pii,int>::iterator it=g[i][p][q].begin();it!=g[i][p][q].end();it++){\n\t\t\t\tint fp=(it->fst).fst,fq=(it->fst).snd,cur=it->snd;\n\t\t\t\tif(!(i&1)){\n\t\t\t\t\tAdd(g[i+1][0][q][mp(n+1,fq)],cur);\n\t\t\t\t\tif(i+1<fp){\n\t\t\t\t\t\tif(i+1-k>=i-2*(q-1))Add(g[i+1][p+1][q][mp(fp,min(fq,i+1-2*p+k))],cur);\n\t\t\t\t\t\telse Add(g[i+1][p+1][q][mp(fp,fq)],cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tAdd(g[i+1][p][0][mp(fp,n+1)],cur);\n\t\t\t\t\tif(i+1<fq){\n\t\t\t\t\t\tif(i+1-k>=i-2*(p-1))Add(g[i+1][p][q+1][mp(min(fp,i+1-2*q+k),fq)],cur);\n\t\t\t\t\t\telse Add(g[i+1][p][q+1][mp(fp,fq)],cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(p,n/2+2)rep(q,n/2+2)\n\t\t\tfor(map<pii,int>::iterator it=g[n][p][q].begin();it!=g[n][p][q].end();it++)\n\t\t\t\tAdd(ans,it->snd);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define mem(a) memset((a),0,sizeof(a))\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nconst int N=155;\nint dp[N][N][N],mod,DP[N];\ninline void add(int &a,int b){\n\ta=a+b>=mod?a+b-mod:a+b;\n}\nll solve1(int n,int k){\n\tDP[0]=1; \n\t\n\tFor(i,1,n+1){\n\t\tDP[i]=0;\n\t\tFor(j,0,i-1)if(i-j-1<=k)DP[i]=(DP[i]+DP[j])%mod;\n\t}\n\t//cout<<ans<<\" \"<<DP[1]<<\" \"<<DP[2]<<\" \"<<DP[3]<<\" \"<<DP[4]<<endl;\n\treturn DP[n+1];\n}\nint solve2(int n,int k){\n\tdp[1][0][0]=1;\n\tfor(int i=1;i*2-k<=n;i++){//cout<<n<<\" \"<<k<<\" \"<<i<<endl;\n\t\tFor(j,0,k+1){\n\t\t\tFor(l,0,k)if(dp[i][j][l]){//cout<<dp[i][j][l]<<endl;\n\t\t\t\tadd(dp[i+1][0][0],dp[i][j][l]);\n\t\t\t\tif(2*i-k>=1){\n\t\t\t\t\tadd(dp[i+1][j?j+1:0][0],dp[i][j][l]);\n\t\t\t\t}\n\t\t\t\tif(2*i<=n){\n\t\t\t\t\tadd(dp[i+1][0][min(l+1,k)],dp[i][j][l]);\n\t\t\t\t}\n\t\t\t\tif(2*i-k>=1&&2*i<=n)add(dp[i+1][max(j+1,2+l)][min(l+1,k)],dp[i][j][l]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tFor(i,0,k+1)For(j,0,k)ans=(ans+dp[(n+k)/2+1][i][j])%mod;\n\treturn ans;\n}\nint main(){\n\tint n=read(),k=read(); mod=read();\n\tif(k%2==0){\n\t\tcout<<solve1(n/2,k/2)*solve1(n-n/2,k/2)%mod<<endl;\n\t}else{\n\t\tcout<<solve2(n,k)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-28 17:46:12\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200;\nint n,m,mod;\ni64 &Add(i64 &a,i64 b){ return a=(a+b)%mod; }\nnamespace m2\n{\n\ti64 f[N],F[N];\n\tint main(int n)\n\t{\n\t\texit(1);\n\t\ti64 ans=0; memset(f,0,sizeof(f)); f[0]=1;\n\t\tfr(i,1,n)\n\t\t{\n\t\t\tfr(j,0,m/2){ F[j]=f[j]; f[j]=0; }\n\t\t\tfr(j,0,m/2){ Add(f[0],F[j]); Add(f[j+1],F[j]); }\n\t\t}\n\t\tfr(i,0,m/2) Add(ans,f[i]);\n\t\treturn ans;\n\t}\n}\nnamespace m1\n{\n\ti64 f[N][N],F[N][N];\n\tint a[N],b[N],n;\n\tint main(int _n)\n\t{\n\t\ti64 ans=0; memset(f,0,sizeof(f)); f[0][0]=1;\n\t\tfd(i,_n,1) if(i&1){ n++; a[n]=1; b[n]=(i+m<=_n); }\n\t\tfr(i,1,m) if(!(i&1)) b[++n]=1;\n\t\tfr(i,1,n)\n\t\t{\n//\t\t\tputchar(10);\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",f[j][k],k==m?'\\n':' ');\n\t\t\tfr(j,0,m+1) fr(k,0,m) F[j][k]=0;\n\t\t\tfr(j,0,m+1) fr(k,0,m){ Add(F[std::min(j,m)][k],f[j][k]); f[j][k]=0; }\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",F[j][k],k==m?'\\n':' ');\n\t\t\tfr(j,0,m) fr(k,0,m) fr(A,0,a[i]) fr(B,0,b[i])\n\t\t\t{\n\t\t\t\tif(A&&B) Add(f[j+1][std::max(j,k)+1],F[j][k]);\n\t\t\t\tif(A&&!B) Add(f[j+1][0],F[j][k]);\n\t\t\t\tif(!A&&B) Add(f[0][k?k+1:0],F[j][k]);\n\t\t\t\tif(!A&&!B) Add(f[0][0],F[j][k]);\n\t\t\t}\n//\t\t\tprintf(\"%d  %d %d\\n\",i,a[i],b[i]);\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",f[j][k],k==m?'\\n':' ');\n\t\t}\n\t\tfr(i,0,m+1) fr(j,0,m) Add(ans,f[i][j]);\n\t\treturn ans;\n\t}\n}\nint main()\n{\n\tn=read(); m=read(); mod=read();\n\tif(m%2==0) printf(\"%d\\n\",int(m2::main(n/2)*m2::main((n+1)/2)%mod));\n\telse printf(\"%d\\n\",int(m1::main(n)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nint mod;\nint n,k,m,i,j,p,f[155][155],g[155][155][155],s1,s2;\nint main(){\n\tcin>>n>>k>>mod;\n\tif(!(k&1)){\n\t\tf[0][0]=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<=min(i,k/2);j++){\n\t\t\t\t(f[i+1][j+1]+=f[i][j])%=mod;\n\t\t\t\t(f[i+1][0]+=f[i][j])%=mod;\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<=k/2;j++){\n\t\t\t(s1+=f[n/2][j])%=mod;\n\t\t\t(s2+=f[n-n/2][j])%=mod;\n\t\t}\n\t\tcout<<1ll*s1*s2%mod<<endl; \n\t}\n\telse{\n\t\tg[0][0][0]=1;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tint r=i*2,l=r-k;\n\t\t\tbool fl=(1<=l&&l<=n),fr=(1<=r&&r<=n);\n\t\t\tfor(j=0;j<=n;j++){\n\t\t\t\tfor(p=0;p<=k+1;p++){\n\t\t\t\t\t(g[i][0][0]+=g[i-1][j][p])%=mod;\n\t\t\t\t\tif(fr){\n\t\t\t\t\t\t(g[i][j+1][0]+=g[i-1][j][p])%=mod;\n\t\t\t\t\t}\n\t\t\t\t\tif(fl&&p+1<k+2){\n\t\t\t\t\t\t(g[i][0][p?p+1:p]+=g[i-1][j][p])%=mod;\n\t\t\t\t\t}\n\t\t\t\t\tif(fl&&fr&&max(j+2,p+1)<k+2){\n\t\t\t\t\t\t(g[i][j+1][max(j+2,p+1)]+=g[i-1][j][p])%=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<g[n+1][0][0]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint n,k,Mod;\nint f[2][110][110][160];\nint g[151][151];\nvoid add(int& x,int y)\n{\n\tx+=y;\n\tif(x>=Mod)x-=Mod;\n\treturn ;\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&k,&Mod);\n\tif(k%2==0){\n\t\tk/=2;\n\t\tg[0][0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=k;j++)\n\t\t\t{\n\t\t\t\tadd(g[i][j+1],g[i-1][j]);\n\t\t\t\tadd(g[i][0],g[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tint ans1=0,ans2=0;\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tadd(ans1,g[n/2][i]);\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tadd(ans2,g[(n+1)/2][i]);\n\t\tprintf(\"%d\\n\",(long long)ans1*ans2%Mod);\n\t\treturn 0;\n\t}\n\tf[0][0][0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint now=i&1;\n\t\tfor(int x=0;x*2<=i+1;x++)\n\t\t\tfor(int y=0;y*2<=i;y++)\n\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t\tf[now][x][y][k]=0;\n\t\tfor(int x=0;x*2<=i;x++)\n\t\t\tfor(int y=0;y*2<i;y++)\n\t\t\t{\n\t\t\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(now){\n\t\t\t\t\t\tadd(f[now][0][y][(j&1)?0:j],f[now^1][x][y][j]);\n\t\t\t\t\t\tadd(f[now][x+1][y][j],f[now^1][x][y][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tadd(f[now][x][0][(j&1)?j:0],f[now^1][x][y][j]);\n\t\t\t\t\t\tadd(f[now][x][y+1][j],f[now^1][x][y][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//0&i->0\n\t\t\t\tif(now){\n\t\t\t\t\tadd(f[now][0][y][0],f[now^1][x][y][i]);\n\t\t\t\t\tadd(f[now][0][y][0],f[now^1][x][y][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tadd(f[now][x][0][0],f[now^1][x][y][i]);\n\t\t\t\t\tadd(f[now][x][0][0],f[now^1][x][y][0]);\n\t\t\t\t}\n\t\t\t\t//0->?\n\t\t\t\tif(now){\n\t\t\t\t\tif(y*2-1>=k&&i-x*2+k<=n)\n\t\t\t\t\t\tadd(f[now][x+1][y][i-x*2+k],f[now^1][x][y][0]);\n\t\t\t\t\telse add(f[now][x+1][y][0],f[now^1][x][y][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(x*2-1>=k&&i-y*2+k<=n)\n\t\t\t\t\t\tadd(f[now][x][y+1][i-y*2+k],f[now^1][x][y][0]);\n\t\t\t\t\telse add(f[now][x][y+1][0],f[now^1][x][y][0]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int x=0;x*2<=n+1;x++)\n\t\tfor(int y=0;y*2<=n;y++)\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tadd(ans,f[n&1][x][y][j]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 158\nusing namespace std;\nint vi[N*2],d1[N],mo,dp[N][N][2],n,k,ans;\nvoid add(int &x,int y){x+=y;if (x>=mo)x-=mo;}\nvoid get1(int x,int y){\n\td1[0]=1;\n\tfor (int i=1;i<=x+1;i++)\n\t\tfor (int j=max(0,i-y);j<i;j++)add(d1[i],d1[j]);\n\tcout<<1ll*d1[x/2+1]*d1[(x+1)/2+1]%mo<<endl;\n}\nint main(){\n\tcin>>n>>k>>mo;\n\tif (k%2==0)get1(n,k/2+1);\n\telse{\n\t\tfor (int i=1;i<=n+k+1;i++)\n\t\t\tif(i%2==0){if(i<k+2)vi[i]=0;else vi[i]=1;}else{if(i>n)vi[i]=0;else vi[i]=1;}\n\t\tdp[0][0][0]=1;\n\t\tfor (int i=1;i<=(n+k)/2+1;i++){\n\t\t\tfor (int l=0;l<i;l++)\n\t\t\tfor (int p=0;p<=k;p++)\n\t\t\tif (dp[l][p][0]){\n\t\t\t\tint nl,np;\n\t\t\t\tfor (int t1=0;t1<=vi[i*2-1];t1++)\n\t\t\t\tfor (int t2=0;t2<=vi[i*2];t2++){\n\t\t\t\t\tif (t2&&p==1)continue;\n\t\t\t\t\tif (t1==1)nl=l+1;else nl=0;\n\t\t\t\t\tif (t2==0)np=0;\n\t\t\t\t\tif (t1==1&&t2==1){if (l>=k)continue;if (p==0)np=k-l;else np=min(p-1,k-l);}\n\t\t\t\t\tif (t1==0&&t2==1){if (p==0)np=0;else np=p-1;}\n\t\t\t\t\tadd(dp[nl][np][1],dp[l][p][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int l=0;l<=i;l++)\n\t\t\tfor (int p=0;p<=k;p++){\n\t\t\t\tdp[l][p][0]=dp[l][p][1],dp[l][p][1]=0;\n\t\t\t\tif (i==(n+k)/2+1)add(ans,dp[l][p][0]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n//#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,k;\nll mod,dp[2][155][155][155];\n\nll easy(int n,int m){\n\tfor(int i=0;i<155;i++) for(int j=0;j<155;j++) dp[0][i][j][0] = 0;\n\tdp[0][0][0][0] = 1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][i][j][0] == 0) continue;\n\t\t\tdp[0][i+1][0][0] += dp[0][i][j][0];\n\t\t\tif(dp[0][i+1][0][0]>=mod) dp[0][i+1][0][0]-=mod;\n\t\t\tif(j+1 == m) continue;\n\t\t\tdp[0][i+1][j+1][0] += dp[0][i][j][0];\n\t\t\tif(dp[0][i+1][j+1][0]>=mod) dp[0][i+1][j+1][0]-=mod;\n\t\t}\n\t}\n\tll ret = 0;\n\tfor(int j=0;j<m;j++) ret += dp[0][n][j][0];\n\treturn (ret%mod+mod)%mod;\n}\n\nint main(){\n\tcin >> n >> k >> mod;\n\tif(k == 1){\n\t\tcout << easy(n,3) << endl;\n\t}\n\telse if(k%2 == 0){\n\t\tcout << easy(n/2,k/2+1)*easy(n-n/2,k/2+1)%mod << endl;\n\t}\n\telse{\n\t\tdp[0][0][0][0] = 1;\n\t\tint cur = 0,nxt = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\trep(a,155)rep(b,155)rep(c,155) dp[nxt][a][b][c] = 0;\n\t\t\t\n\t\t\tif(i%2 == 1){\n\t\t\t\tfor(int a=0;a<i;a++){\n\t\t\t\t\tfor(int b=0;b<i;b++){\n\t\t\t\t\t\tfor(int c=0;c<155;c++){\n\t\t\t\t\t\t\tif(dp[cur][a][b][c] == 0) continue;\n\t\t\t\t\t\t\t//use\n\t\t\t\t\t\t\tbool bad = 0;\n\t\t\t\t\t\t\tif(c && c%2 == 1 && c <= i) bad = 1;\n\t\t\t\t\t\t\tif(!bad){\n\t\t\t\t\t\t\t\tint nwc = c;\n\t\t\t\t\t\t\t\tif(nwc == 0 && b && b+k <= i){\n\t\t\t\t\t\t\t\t\tif(a == 0) nwc = i+k;\n\t\t\t\t\t\t\t\t\telse nwc = a+k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nwc > n) nwc = nwc%2 + (n+2)/2*2;\n\t\t\t\t\t\t\t\tint nwa = a;\n\t\t\t\t\t\t\t\tif(nwa == 0) nwa = i;\n\t\t\t\t\t\t\t\tdp[nxt][nwa][b][nwc] += dp[cur][a][b][c];\n\t\t\t\t\t\t\t\tif(dp[nxt][nwa][b][nwc] >= mod) dp[nxt][nwa][b][nwc] -= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//not use\n\t\t\t\t\t\t\tint nwc = c;\n\t\t\t\t\t\t\tif(nwc%2 == 0);\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnwc = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[nxt][0][b][nwc] += dp[cur][a][b][c];\n\t\t\t\t\t\t\tif(dp[nxt][0][b][nwc] >= mod) dp[nxt][0][b][nwc] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int a=0;a<i;a++){\n\t\t\t\t\tfor(int b=0;b<i;b++){\n\t\t\t\t\t\tfor(int c=0;c<155;c++){\n\t\t\t\t\t\t\tif(dp[cur][a][b][c] == 0) continue;\n\t\t\t\t\t\t\t//use\n\t\t\t\t\t\t\tbool bad = 0;\n\t\t\t\t\t\t\tif(c && c%2 == 0 && c <= i) bad = 1;\n\t\t\t\t\t\t//\tif(b && (i-b) >= 2*k) bad = 1;\n\t\t\t\t\t\t\tif(!bad){\n\t\t\t\t\t\t\t\tint nwc = c;\n\t\t\t\t\t\t\t\tif(nwc == 0 && a && a+k <= i){\n\t\t\t\t\t\t\t\t\tif(b == 0) nwc = i+k;\n\t\t\t\t\t\t\t\t\telse nwc = b+k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nwc > n) nwc = nwc%2 + (n+2)/2*2;\n\t\t\t\t\t\t\t\tint nwb = b;\n\t\t\t\t\t\t\t\tif(nwb == 0) nwb = i;\n\t\t\t\t\t\t\t\tdp[nxt][a][nwb][nwc] += dp[cur][a][b][c];\n\t\t\t\t\t\t\t\tif(dp[nxt][a][nwb][nwc] >= mod) dp[nxt][a][nwb][nwc] -= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//not use\n\t\t\t\t\t\t\tint nwc = c;\n\t\t\t\t\t\t\tif(nwc%2 == 1);\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnwc = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[nxt][a][0][nwc] += dp[cur][a][b][c];\n\t\t\t\t\t\t\tif(dp[nxt][a][0][nwc] >= mod) dp[nxt][a][0][nwc] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i=0;i<155;i++) for(int j=0;j<155;j++) for(int k=0;k<155;k++) ans += dp[cur][i][j][k];\n\t\tcout << (ans%mod+mod)%mod << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nint n;\n\nint main() {\n  cin >> n;\n  n -= 2;\n  long long res;\n  cin >> res;\n  vector<int> a(n);\n  range(i, 0, n) cin >> a[i];\n  int foo;\n  cin >> foo;\n  res += foo;\n  if(n == 0) {\n    cout << res;\n    return 0;\n  }\n  vector<pair<long long, long long>> cur;\n  vector<pair<int, int>> to((1 << (n + 1)) - 1, make_pair(-1, -1));\n  function<void(int, int, int)> dfs = [&](int u, int v, int dep) {\n    cur.emplace_back(u, v);\n    if(dep == n) return;\n    int pos = cur.size() - 1;\n    to[pos].first = cur.size();\n    dfs(u, u + v, dep + 1);\n    to[pos].second = cur.size();\n    dfs(u + v, v, dep + 1);\n  };\n  dfs(1, 1, 0);\n  vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(n, vector<long long>((1 << (n + 1)) - 1, LLONG_MAX / 3)));\n  range(s, 0, n) {\n    range(x, 0, n - s) {\n      int y = x + s;\n      if(x == y) {\n        range(z, 0, (1 << (n + 1)) - 1) dp[x][y][z] = cur[z].first * a[x] + cur[z].second * a[y];\n        continue;\n      }\n      range(z, 0, (1 << (n + 1)) - 1) {\n        int u = to[z].first, v = to[z].second;\n        if(u == -1) continue;\n        range(d, x, y + 1) {\n          long long l = (d == x ? 0 : dp[x][d - 1][u]), r = (d == y ? 0 : dp[d + 1][y][v]);\n          dp[x][y][z] = min(dp[x][y][z], l + r + (cur[z].first + cur[z].second) * a[d]);\n        }\n      }\n    }\n  }\n  res += dp[0][n - 1][0];\n  cout << res;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 153;\nint n, k, mod, f[N][N], g[N][N][N];\ninline void qmo(int &x){x += (x >> 31) & mod;}\nint main(){\n\tscanf(\"%d%d%d\", &n, &k, &mod);\n\tif(k & 1){\n\t\tint lim = n + k >> 1; g[0][0][0] = 1;\n\t\tfor(Rint i = 1;i <= lim;++ i){\n\t\t\tfor(Rint j = 0;j <= n;++ j)\n\t\t\t\tfor(Rint l = 0;l <= k + 1;++ l)\n\t\t\t\t\tqmo(g[i][0][0] += g[i - 1][j][l] - mod);\n\t\t\tif(i <= (n >> 1)){\n\t\t\t\tfor(Rint j = 0;j <= n;++ j)\n\t\t\t\t\tfor(Rint l = 0;l <= k + 1;++ l)\n\t\t\t\t\t\tqmo(g[i][j + 1][0] += g[i - 1][j][l] - mod);\n\t\t\t}\n\t\t\tif((i << 1) >= k + 1){\n\t\t\t\tfor(Rint j = 0;j <= n;++ j){\n\t\t\t\t\tfor(Rint l = 1;l <= k;++ l)\n\t\t\t\t\t\tqmo(g[i][0][l + 1] += g[i - 1][j][l] - mod);\n\t\t\t\t\tqmo(g[i][0][0] += g[i - 1][j][0] - mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i <= (n >> 1) && (i << 1) >= k + 1){\n\t\t\t\tfor(Rint j = 0;j <= n && j < k;++ j)\n\t\t\t\t\tfor(Rint l = 0;l <= k;++ l)\n\t\t\t\t\t\tqmo(g[i][j + 1][max(j + 2, l + 1)] += g[i - 1][j][l] - mod);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(Rint j = 0;j <= n;++ j)\n\t\t\tfor(Rint l = 0;l <= k + 1;++ l)\n\t\t\t\tqmo(ans += g[lim][j][l] - mod);\n\t\tprintf(\"%d\\n\", ans);\n\t} else {\n\t\tk >>= 1; f[0][0] = 1;\n\t\tint n1 = n >> 1, n2 = n - n1;\n\t\tfor(Rint i = 1;i <= n2;++ i){\n\t\t\tfor(Rint j = 0;j <= k;++ j)\n\t\t\t\tqmo(f[i][0] += f[i - 1][j] - mod);\n\t\t\tfor(Rint j = 0;j < k;++ j)\n\t\t\t\tqmo(f[i][j + 1] += f[i - 1][j] - mod);\n\t\t}\n\t\tint ans1 = 0, ans2 = 0;\n\t\tfor(Rint i = 0;i <= k;++ i) qmo(ans1 += f[n1][i] - mod);\n\t\tfor(Rint i = 0;i <= k;++ i) qmo(ans2 += f[n2][i] - mod);\n\t\tprintf(\"%d\\n\", (LL) ans1 * ans2 % mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,k,mod;\nvoid upd(int&x,int y){x=(x+y)%mod;}\nint main(){\n\tcin>>n>>k>>mod;\n\tif(k%2==0){\n\t\tstatic int f[155][155];\n\t\tk=k/2+1;\n\t\tf[0][0]=1;\n\t\tfor(int i=1;i<=n+1;i++){\n\t\t\tf[i][0]=f[i-1][0];\n\t\t\tfor(int j=1;j<k;j++){\n\t\t\t\tf[i][j]=f[i-1][j-1];\n\t\t\t\tupd(f[i][0],f[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<1ll*f[n/2+1][0]*f[n-n/2+1][0]%mod<<\"\\n\";\n\t\treturn 0;\n\t}else{\n\t\tstatic int f[155][155][155][2];\n\t\tf[0][0][0][0]=1;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tauto chk=[&](int x){\n\t\t\t\treturn 1<=x&&x<=n;\n\t\t\t};\n\t\t\tint a=chk(2*i+2-k),b=chk(2*i+2);\n\t\t\tfor(int s=0;s<=n;s++)\n\t\t\t\tfor(int r=0;r<=n;r++){\n\t\t\t\t\tfor(int o=0;o<2;o++){\n\t\t\t\t\t\tif(o&&s>k+1)continue;\n\t\t\t\t\t\tupd(f[i+1][0][0][0],f[i][s][r][o]);\n\t\t\t\t\t\tif(a)upd(f[i+1][s+1][0][o],f[i][s][r][o]);\n\t\t\t\t\t\tif(b)upd(f[i+1][0][r+1][0],f[i][s][r][o]);\n\t\t\t\t\t\tif(a&&b){\n\t\t\t\t\t\t\tif(o)upd(f[i+1][s+1][r+1][o],f[i][s][r][o]);\n\t\t\t\t\t\t\telse upd(f[i+1][r+2][r+1][1],f[i][s][r][o]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tcout<<f[n+1][0][0][0]<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=155;\n\nint n,L,Mo;\nint f[N][N],g[N][N][N];\n\nvoid inc(int &x,int y) {x=x+y>=Mo?x+y-Mo:x+y;}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&L,&Mo);\n\tif (L&1) {\n\t\tg[0][0][0]=1;int m=(L>>1)+((n+1)>>1);\n\t\tfo(i,0,m-1) \n\t\t\tfo(j,0,n>>1) \n\t\t\t\tfo(k,0,L+1) {\n\t\t\t\t\tinc(g[i+1][0][0],g[i][j][k]);\n\t\t\t\t\tif (i<(n>>1)) inc(g[i+1][j+1][0],g[i][j][k]);\n\t\t\t\t\tif (i>=(L>>1)) inc(g[i+1][0][k?k+1:0],g[i][j][k]);\n\t\t\t\t\tif (i>=(L>>1)&&i<(n>>1)) inc(g[i+1][j+1][max(j+2,k+1)],g[i][j][k]);\n\t\t\t\t}\n\t\tint ans=0;\n\t\tfo(i,0,n>>1) fo(j,0,L+1) inc(ans,g[m][i][j]);\n\t\tprintf(\"%d\\n\",ans);\n\t} else {\n\t\tfo(i,0,n) fo(j,0,i) f[i][j]=0;\n\t\tf[0][0]=1;\n\t\tfo(i,0,n-1) {\n\t\t\tfo(j,0,min(i,L>>1)) {\n\t\t\t\tinc(f[i+1][j+1],f[i][j]);\n\t\t\t\tinc(f[i+1][0],f[i][j]);\n\t\t\t}\n\t\t}\n\t\tint an_0=0,an_1=0;\n\t\tfo(j,0,L>>1) {\n\t\t\tinc(an_0,f[n>>1][j]);\n\t\t\tinc(an_1,f[(n+1)>>1][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",(ll)an_0*an_1%Mo);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nunsigned int mod = 1;\n\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt;\n\nint N,K;\nmint dp[2][80][80][80][80];\n\nint main(){\n\tcin >> N >> K >> mod;\n\tif(K%2 == 0){\n\t\tK = K/2 + 1;\t// o*K -> no\n\t\tVV<mint> dp(N+1,V<mint>(K));\n\t\tdp[0][0] = 1;\n\t\trep(i,N) rep(k,K){\n\t\t\tdp[i+1][0] += dp[i][k];\n\t\t\tif(k+1 != K) dp[i+1][k+1] += dp[i][k];\n\t\t}\n\t\tmint res = 1;\n\t\tfor(int n : {N/2,(N+1)/2}){\n\t\t\tmint s = 0;\n\t\t\trep(k,K) s += dp[n][k];\n\t\t\tres *= s;\n\t\t}\n\t\tcout << res << endl;\n\t\treturn 0;\n\t}\n\tK = (K+1)/2;\n\tdp[0][0][0][0][0] = 1;\n\trep(i,N){\n\t\tint t = i&1;\n\t\tint nt = 1-t;\n\t\trep(a,K+1) rep(b,K+1) rep(c,K+1){\n\t\t\tdp[nt][a][b][c][0] = 0;\n\t\t\tdp[nt][a][b][0][c] = 0;\n\t\t}\n\t\trep(a,K+1) rep(b,K+1) rep(v,K+1) rep(_,2){\n\t\t\tif(v == 0 && _ == 0) continue;\n\t\t\tint c = v, d = 0;\n\t\t\tif(_) swap(c,d);\n\t\t\tif(!dp[t][a][b][c][d]) continue;\n//\t\t\tprintf(\"[%d][%d][%d][%d]\\n\",a,b,c,d);\n\n\t\t\t//x\n\t\t\tdp[nt][b][0][d][0] += dp[t][a][b][c][d];\n\t\t\t//o\n\t\t\tif(c == 1) continue;\n\t\t\tif(a == K){\n\t\t\t\tif(b >= K) continue;\n\t\t\t\tint nd = c == 0 ? 0 : c-1;\n\t\t\t\tif(b > 0){\n\t\t\t\t\tif(c == 0) nd = K-b;\n\t\t\t\t\telse nd = min(c-1,K-b);\n\t\t\t\t}\n\t\t\t\tdp[nt][b][K][d][nd] += dp[t][a][b][c][d];\n\t\t\t}else{\n\t\t\t\tdp[nt][b][a+1][d][c == 0 ? 0 : c-1] += dp[t][a][b][c][d];\n\t\t\t}\n\t\t}\n\t}\n\tmint res = 0;\n\trep(a,K+1) rep(b,K+1) rep(c,K+1) rep(d,K+1) res += dp[N&1][a][b][c][d];\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\n\nint mod;\n\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint& v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0) val += mod;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& a) { return os << a.val; }\n\tfriend bool operator==(const mint& a, const mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint& operator+=(const mint& m) { if ((val += m.val) >= mod) val -= mod; return *this; }\n\tmint& operator-=(const mint& m) { if ((val -= m.val) < 0) val += mod; return *this; }\n\tmint& operator*=(const mint& m) { val = (lint)val*m.val%mod; return *this; }\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint& a) { assert(a.val); return ipow(a, mod - 2); }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n\toperator int64_t() const {return val; }\n};\n\nmint ez(int n, int k){\n\tvector<mint> dp(n + 2);\n\tdp[0] = mint(1);\n\tfor(int i=1; i<=n+1; i++){\n\t\tfor(int j=1; j<=k+1 && j<=i; j++){\n\t\t\tdp[i] += dp[i - j];\n\t\t}\n\t}\n\treturn dp[n + 1];\n}\n\nvector<int> v;\nmint dp[155][155][155][2], nxt[155][155][155][2];\n\nmint solve(int n, int thr){\n\tdp[0][0][0][0] = 1;\n\tfor(auto &x : v){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i=0; i<=n; i++){ // short\n\t\t\tfor(int j=0; j<=n; j++){ // long\n\t\t\t\tfor(int k=0; k<=thr; k++){ // long with tail\n\t\t\t\t\tfor(int l=0; l<2; l++){ // 1 if up is long\n\t\t\t\t\t\tif((lint)dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t\tnxt[0][0][0][0] += dp[i][j][k][l];\n\t\t\t\t\t\tint next_k = 0;\n\t\t\t\t\t\tif(k > 0) next_k = k + 1;\n\t\t\t\t\t\telse if(i > 0) next_k = i + 2;\n\t\t\t\t\t\tif(x & 1){\n\t\t\t\t\t\t\tif(l == 0){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x & 2){\n\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x == 3){\n\t\t\t\t\t\t\tnxt[i + 1][j + 1][k ? (k + 1) : 0][l] += dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int k=0; k<thr; k++){\n\t\t\t\t\tif(i > 0 && j >= thr - 1){\n\t\t\t\t\t\tnxt[i][j][k][0] = nxt[i][j][k][1] = mint(0);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k][0] = nxt[i][j][k][0];\n\t\t\t\t\tdp[i][j][k][1] = nxt[i][j][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=thr; k++){\n\t\t\t\tfor(int l=0; l<2; l++) ret += dp[i][j][k][l];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k >> mod;\n\tif(k % 2 == 0){\n\t\tcout << ez((n + 1) / 2, k / 2) * ez(n / 2, k / 2) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n+n; i+=2){\n\t\tif(i - k > n) break;\n\t\tint msk = 0;\n\t\tif(i <= n) msk |= 1;\n\t\tif(i - k >= 1) msk |= 2;\n\t\tv.push_back(msk);\n\t}\n\tmint ret = solve(n, k + 2);\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint MOD;\ntemplate <int& MOD_> struct modnum {\n\tstatic constexpr int& MOD = MOD_;\n\t//static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<MOD>;\n\n// if k mod 2 == 0, then you can't contain any k/2+1 consecutive from the n/2\n// else k mod 2 == 1\n\nconst int MAXN = 160;\nconst int MAXK = MAXN;\n\nnum dp1[MAXN];\nnum solve1K(int n, int k) {\n\tassert(k >= 1);\n\t// can't take k+1 consecutive\n\tdp1[0] = 1;\n\tnum sum = dp1[0];\n\tfor (int i = 1; i <= n+1; i++) {\n\t\tdp1[i] = sum;\n\n\t\tsum += dp1[i];\n\t\tif (i >= k+1) sum -= dp1[i-(k+1)];\n\t}\n\treturn dp1[n+1];\n}\n\nnum go(int N, int K) {\n\tif (K % 2 == 0) {\n\t\tnum a = solve1K(N / 2, K / 2);\n\t\tnum b = solve1K(N - N / 2, K / 2);\n\t\treturn a * b;\n\t} else if (K == 1) {\n\t\treturn solve1K(N, 2);\n\t} else {\n\t\tassert(K >= 3);\n\t\t// store the furthest back even that is/might be linked up\n\t\t// it's (# even <= K/2+1, # odd) or (# even > K/2, 0)\n\t\tusing half_state = pair<int, int>;\n\t\tusing state = pair<half_state, half_state>;\n\t\tmap<state, num> dp;\n\t\tdp[state()] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t//cerr << \"Add \" << i << '\\n';\n\t\t\tmap<state, num> ndp;\n\t\t\tfor (auto it : dp) {\n\t\t\t\tconst num cnt = it.second;\n\t\t\t\t{ // case 1: don't take\n\t\t\t\t\tconst state s = it.first;\n\t\t\t\t\tstate ns(half_state(0, 0), s.first);\n\t\t\t\t\tif (ns.second.first == K/2 + 1) {\n\t\t\t\t\t\tns.second.first = K/2;\n\t\t\t\t\t\tns.second.second = 0;\n\t\t\t\t\t} else if (ns.second.first <= K/2) {\n\t\t\t\t\t\tns.second.second = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//cerr << \"notake\" << '\\n';\n\t\t\t\t\t//cerr << s.first.first << ' ' << s.first.second << ' ' << s.second.first << ' ' << s.second.second << '\\n';\n\t\t\t\t\t//cerr << ns.first.first << ' ' << ns.first.second << ' ' << ns.second.first << ' ' << ns.second.second << '\\n';\n\t\t\t\t\t//cerr << cnt << '\\n';\n\t\t\t\t\tndp[ns] += cnt;\n\t\t\t\t}\n\n\t\t\t\t{ // case 2: take it\n\t\t\t\t\tconst state s = it.first;\n\t\t\t\t\tstate ns(half_state(s.second.first + 1, s.second.second), s.first);\n\t\t\t\t\tif (ns.second.first == K/2 + 1) {\n\t\t\t\t\t\tns.second.first = K/2 + 1 + ns.second.second;\n\t\t\t\t\t\tns.second.second = 0;\n\t\t\t\t\t} else if (ns.second.first <= K/2) {\n\t\t\t\t\t\tns.second.second = min(ns.second.second+1, ns.second.first);\n\t\t\t\t\t\t//ns.second.second = ns.second.second+1;\n\t\t\t\t\t}\n\t\t\t\t\t//cerr << \"take\" << '\\n';\n\t\t\t\t\t//cerr << s.first.first << ' ' << s.first.second << ' ' << s.second.first << ' ' << s.second.second << '\\n';\n\t\t\t\t\t//cerr << ns.first.first << ' ' << ns.first.second << ' ' << ns.second.first << ' ' << ns.second.second << '\\n';\n\t\t\t\t\t//cerr << cnt << '\\n';\n\n\t\t\t\t\tif (ns.first.first <= K) {\n\t\t\t\t\t\tndp[ns] += cnt;\n\t\t\t\t\t} else assert(ns.first.first == K+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = std::move(ndp);\n\t\t}\n\t\tnum ans = 0;\n\t\tfor (auto it : dp) {\n\t\t\tans += it.second;\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N, K;\n\tcin >> N >> K >> MOD;\n\tnum ans = go(N, K);\n\tcout << int(ans) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int N = 155;\nint n, k, mod;\ninline void upd(int &x, const int &y) {\n   (x += y) >= mod ? x -= mod : 0;\n}\nnamespace part1 {\n\nint f[N];\nvoid main() {\n   f[0] = 1; k >>= 1;\n   for(int i = 1; i <= n; i ++) {\n      f[i] = i <= k;\n      for(int j = max(0, i - k - 1); j < i; j ++) { //choose [j + 2, i]\n         upd(f[i], f[j]);\n      }\n   }\n   printf(\"%d\\n\", (int) (1ll * f[n / 2] * f[n - n / 2] % mod));\n}\n\n}\nnamespace part2 {\n\nint ans, f[N][N][N];\nvoid main() {\n   int c = (1 + k) / 2 - 1 + (n + 1) / 2;\n   f[0][0][0] = 1;\n   for(int i = 1; i <= c; i ++) {\n      if(i <= (1 + k) / 2 - 1) {\n         for(int j = 0; j <= i - 1; j ++) upd(f[i][0][0], f[i - 1][0][j]);\n         for(int j = 1; j <= i; j ++) upd(f[i][0][j], f[i - 1][0][j - 1]);\n      } else if(i <= n / 2) {\n         for(int x = 0; x <= k + 1; x ++) // 0 0\n            for(int y = 0; y <= i - 1; y ++)\n               upd(f[i][0][0], f[i - 1][x][y]);\n         for(int x = 0; x <= k + 1; x ++) if(x != 1) // 1 0\n            for(int z = 0; z <= i - 1; z ++)\n               upd(f[i][x][0], f[i - 1][!x ? 0 : x - 1][z]);\n         for(int y = 1; y <= i; y ++)\n            for(int z = 0; z <= k + 1; z ++)\n               upd(f[i][0][y], f[i - 1][z][y - 1]);\n         for(int x = 2; x <= k + 1; x ++) {\n            for(int y = 1; y <= i && 1 + y <= x; y ++) {\n               if(1 + y == x) {\n                  for(int z = 0; z < x; z ++) {\n                     upd(f[i][x][y], f[i - 1][z][y - 1]);\n                  }\n               } else {\n                  f[i][x][y] = f[i - 1][x - 1][y - 1];\n               }\n            }\n         }\n      } else {\n         for(int x = 0; x <= k + 1; x ++) {\n            if(x == 0) {\n               for(int y = 0; y <= k + 1; y ++)\n                  for(int z = 0; z <= i - 1; z ++)\n                     upd(f[i][0][0], f[i - 1][y][z]);\n               for(int z = 0; z <= i - 1; z ++)\n                  upd(f[i][0][0], f[i - 1][0][z]);\n            } else if(x != 1) {\n               for(int z = 0; z <= i - 1; z ++)\n                  upd(f[i][x][0], f[i - 1][x - 1][z]);\n            }\n         }\n      }\n   }\n   for(int y = 0; y <= k + 1; y ++)\n      for(int z = 0; z <= n / 2; z ++)\n         upd(ans, f[c][y][z]);\n   printf(\"%d\\n\", ans);\n}\n\n}\nint main() {\n   scanf(\"%d%d%d\", &n, &k, &mod);\n   if(k % 2 == 0) part1::main();\n   else part2::main();\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define cri const int\n#define ll long long\n#define re register\nusing namespace std;\nint N,K,mod;\nint f[152][152];\ninline int mo(cri x){ return x>=mod?x-mod:x; } \ninline void solve2(){\n\tf[0][0]=f[1][0]=f[1][1]=f[2][0]=f[2][1]=1;\n\tK=(K>>1)+1;\n\tfor(int i=3;i<=N;i++){\n\t\tfor(int j=0;j<K;j++) f[i][j]=mo(f[i][0]+f[i-2][j]);\n\t\tfor(int j=0;j<K-1;j++) f[i][j+1]=f[i-2][j];\n\t}\n\tint tmp1=0,tmp2=0;\n\tfor(int i=0;i<K;i++) tmp1=mo(tmp1+f[N][i]),tmp2=mo(tmp2+f[N-1][i]);\n\tcout<<1ll*tmp1*tmp2%mod<<endl;\n}\nint dp[152][152][152];\ninline void solve1(){\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=N+K>>1;i++){//cout<<\"i=\"<<i<<endl;\n\t\tif(i<=K/2) for(int j=0;j<i;j++) dp[i][0][j+1]=dp[i-1][0][j],dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][0][j]);\n\t\telse if(i<=N/2){\n\t\t\tfor(int j=0;j<=i;j++) \n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t//cout<<j<<\" \"<<k<<endl;\n\t\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\t\telse dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][0][k+1]=mo(dp[i][0][k+1]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][max(j+1,k+2)][k+1]=mo(dp[i][max(j+1,k+2)][k+1]+dp[i-1][j][k]);\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<=i;j++) for(int k=0;k<i;k++) {\n\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\telse dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=K+2;j<=i+1;j++) memset(dp[i][j],0,sizeof dp[i][j]); \n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++) ans=mo(ans+dp[N+K>>1][i][k]);\n\tcout<<ans<<endl;\n}\nint main(){\n\tcin>>N>>K>>mod;\n\tif(K&1) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 80;\nint p;\nvoid inc(int &x, int y) {(x += y) >= p ? x -= p : 0;};\nint work(int n, int k, int p) {\n    int dp[2][N] {};\n    dp[0][0] = 1;\n    int cur = 0, pre = 1;\n    for (int i = 0; i < n; ++i) {\n        swap(cur, pre);\n        memset(dp[cur], 0, sizeof(dp[cur]));\n        for (int j = 0; j <= k; ++j) {\n            inc(dp[cur][0], dp[pre][j]);\n            if (j < k)\n                inc(dp[cur][j + 1], dp[pre][j]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= k; ++i)\n        inc(ans, dp[cur][i]);\n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k >> p;\n    if (k % 2 == 0) {\n        cout << 1LL * work(n / 2, k / 2, p) * work((n + 1) / 2, k / 2, p) % p << endl;\n        return 0;\n    }\n    int dp[2][N][N][N] {};\n    int m = (n + 1) / 2 + 1;\n    dp[0][0][0][m] = 1;\n    int cur = 0, pre = 1;\n    for (int i = 0; i < n; ++i) {\n        swap(cur, pre);\n        memset(dp[cur], 0, sizeof(dp[cur]));\n        for (int x = 0; x <= (i + 1) / 2; ++x) {\n            for (int y = 0; y <= i / 2; ++y) {\n                for (int z = max(x, y) + 1; z <= m; ++z) {\n                    if (dp[pre][x][y][z] == 0)\n                        continue;\n                    inc(dp[cur][0][x][x > y ? z : m], dp[pre][x][y][z]);\n                    if (2 * x >= k + 1)\n                        inc(dp[cur][y + 1][x][min(z, max(0, x + (k - 2 * y + 1) / 2))], dp[pre][x][y][z]);\n                    else\n                        inc(dp[cur][y + 1][x][z], dp[pre][x][y][z]);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int x = 0; x <= m; ++x)\n        for (int y = 0; y <= m; ++y)\n            for (int z = max(x, y) + 1; z <= m; ++z)\n                inc(ans, dp[cur][x][y][z]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 158\nusing namespace std;\nint vi[N*2],d1[N],mo,dp[N][N][2],n,k,ans;\nvoid add(int &x,int y){x+=y;if (x>=mo)x-=mo;}\nvoid get1(int x,int y){\n\td1[0]=1;\n\tfor (int i=1;i<=x+1;i++)\n\t\tfor (int j=max(0,i-y);j<i;j++)add(d1[i],d1[j]);\n\tcout<<1ll*d1[x/2+1]*d1[(x+1)/2+1]%mo<<endl;\n}\nint main(){\n\tcin>>n>>k>>mo;\n\tif (k%2==0)get1(n,k/2+1);\n\telse{\n\t\tfor (int i=1;i<=n+k+1;i++)\n\t\t\tif(i%2==0){if(i<k+2)vi[i]=0;else vi[i]=1;}else{if(i>n)vi[i]=0;else vi[i]=1;}\n\t\tdp[0][0][0]=1;\n\t\tfor (int i=1;i<=(n+k)/2+1;i++){\n\t\t\tfor (int l=0;l<i;l++)\n\t\t\tfor (int p=0;p<=k;p++)\n\t\t\tif (dp[l][p][0]){\n\t\t\t\tint nl,np;\n\t\t\t\tfor (int t1=0;t1<=vi[i*2-1];t1++)\n\t\t\t\tfor (int t2=0;t2<=vi[i*2];t2++){\n\t\t\t\t\tif (t2&&p==1)continue;\n\t\t\t\t\tif (t1)nl=l+1;else nl=0;\n\t\t\t\t\tif (!t2)np=0;\n\t\t\t\t\tif (t1&&t2){if (l>=k)continue;if(!p)np=k-l;else np=p-1;}\n\t\t\t\t\tif (!t1&&t2){if(!p)np=0;else np=p-1;}\n\t\t\t\t\tadd(dp[nl][np][1],dp[l][p][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int l=0;l<=i;l++)\n\t\t\tfor (int p=0;p<=k;p++){\n\t\t\t\tdp[l][p][0]=dp[l][p][1],dp[l][p][1]=0;\n\t\t\t\tif (i==(n+k)/2+1)add(ans,dp[l][p][0]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double db;\n#define fir first\n#define sec second\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nint MOD;\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\n\nconst int N = 160;\nint n, k, dp[N][N][N];\nvoid solve0() {\n  k >>= 1; ++ k;\n  dp[0][0][0] = 1;\n  // continus odd (even) 1s less than k\n  rep (i, 1, n) {\n    if (i&1) {\n      rep (a, 0, k-1) rep (b, 0, k-1) {\n\tAdd(dp[i][0][b], dp[i-1][a][b]);\n\tif (a + 1 < k) Add(dp[i][a+1][b], dp[i-1][a][b]);\n      }\n    } else {\n      rep (a, 0, k-1) rep (b, 0, k-1) {\n\tAdd(dp[i][a][0], dp[i-1][a][b]);\n\tif (b + 1 < k) Add(dp[i][a][b+1], dp[i-1][a][b]);\n      }\n    }\n  }\n  int ans = 0;\n  rep (a, 0, k-1) rep (b, 0, k-1)\n    Add(ans, dp[n][a][b]);\n  cout << ans << endl;\n}\npii arr[N];\nint acnt;\nvoid solve1() {\n  rep (i, 1, (k+1)/2) arr[++acnt] = pii(1, i);\n  rep (i, (k+1)/2 + 1, (n+1)/2) {\n    arr[++acnt] = pii(1, i);\n    arr[++acnt] = pii(0, i - (k+1)/2);\n  }\n  rep (i, (n+1)/2-(k+1)/2+1, n/2)\n    arr[++acnt] = pii(0, i);\n  dp[0][0][0] = 1;\n  rep (i, 1, n) {\n    int tp = arr[i].fir, p = arr[i].sec;\n    if (tp == 0) {\n      rep (a, 0, n) rep (b, 0, n) if (dp[i-1][a][b]) {\n\tAdd(dp[i][0][b], dp[i-1][a][b]);\n\tif (p+(k+1)/2 > (n+1)/2 || b == 0) {\n\t  if (a == 0 || a > p)\n\t    Add(dp[i][a][b], dp[i-1][a][b]);\n\t} else if ((a == 0 || a > p) && p+k-b+1 > p)\n\t  Add(dp[i][a == 0 ? p+k-b+1 : min(a, p+k-b+1)][b], dp[i-1][a][b]);\n      }\n    } else {\n      rep (a, 0, n) rep (b, 0, n) if (dp[i-1][a][b]) {\n\tAdd(dp[i][a][0], dp[i-1][a][b]);\n\tAdd(dp[i][a][b+1], dp[i-1][a][b]);\n      }\n    }\n  }\n  int ans = 0;\n  rep (a, 0, n) rep (b, 0, n)\n    Add(ans, dp[n][a][b]);\n  cout << ans << endl;\n}\nint main() {\n  read(n), read(k), read(MOD);\n  if (k % 2 == 0) solve0();\n  else solve1();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nconst int N=305;\nint n,K,mod;\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x;\n}\nnamespace sub1{\n\tint f[N][N][N];\n\tinline void solve(){\n\t\tri i,j,k,x,y,v,c,ans;\n\t\tf[0][0][0]=1;\n\t\tfor(i=1;;++i){\n\t\t\ty=2*i;\n\t\t\tx=y-K;\n\t\t\tif((x<1||x>n)&&(y<1||y>n)) break;\n\t\t\tfor(j=0;j<=i&&j<=K+1;++j)\n\t\t\t\tfor(k=0;k<i&&k<=n/2;++k)\n\t\t\t\t\tif(v=f[i-1][j][k]){\n\t\t\t\t\t\tadd(f[i][0][0],v); // 00\n\t\t\t\t\t\tif(x>=1&&j+(j>0)<=K+1)\n\t\t\t\t\t\t\tadd(f[i][j+(j>0)][0],v); // 10\n\t\t\t\t\t\tif(y<=n){\n\t\t\t\t\t\t\tadd(f[i][0][k+1],v); // 01\n\t\t\t\t\t\t\tif(x>=1&&(c=max(j+1,k+2))<=K+1)\n\t\t\t\t\t\t\t\tadd(f[i][c][k+1],v); // 11\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\t--i;ans=0;\n\t\tfor(j=0;j<=i+1&&j<=K+1;++j)\n\t\t\tfor(k=0;k<=i&&k<=n/2;++k)\n\t\t\t\tadd(ans,f[i][j][k]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nnamespace sub0{\n\tint f[N]; // dp的是不在环上的人 \n\tinline void solve(){\n\t\tri i,j,res0,res1,ans;\n\t\tf[0]=1;\n\t\tfor(i=1;i<=(n+1)/2;++i)\n\t\t\tfor(j=max(i-K/2-1,0);j<i;++j)\n\t\t\t\tadd(f[i],f[j]);\n\t\tres0=res1=0;\n\t\tfor(i=max(0,n/2-K/2);i<=n/2;++i)\n\t\t\tadd(res0,f[i]);\n\t\tfor(i=max(0,(n+1)/2-K/2);i<=(n+1)/2;++i)\n\t\t\tadd(res1,f[i]);\n\t\tans=(ll)res0*res1%mod;\n\t\tprintf(\"%d\\n\",ans); \n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&K,&mod);\n\tif(K&1)\n\t\tsub1::solve();\n\telse\n\t\tsub0::solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 160;\nint n, k, mod, g[N][N], f[N][N][N];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &mod);\n  if (!(k & 1)) {\n    g[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= i && j <= k >> 1; j++) {\n        g[i + 1][j + 1] = (g[i + 1][j + 1] + g[i][j]) % mod;\n        g[i + 1][0] = (g[i + 1][0] + g[i][j]) % mod;\n      }\n    }\n    int ansx = 0, ansy = 0;\n    for (int j = 0; j <= n + 1 >> 1 && j <= k >> 1; j++) {\n      ansx = (ansx + g[n >> 1][j]) % mod;\n      ansy = (ansy + g[n + 1 >> 1][j]) % mod;\n    }\n    ansx = (ll) ansx * ansy % mod;\n    printf(\"%d\\n\", ansx);\n  } else {\n    f[0][0][0] = 1;\n    for (int i = 0; i <= n; i++) {\n      bool px = 2 * i + 1 <= n, py = 2 * i + 1 - k >= 2 && 2 * i + 1 - k <= n;\n      for (int c = 0; c <= i + 1 && c < k + 2; c++) {\n        for (int d = 0; d <= i; d++) {\n          if (true   ) f[i + 1][0][0] = (f[i + 1][0][0] + f[i][c][d]) % mod;\n          if (px     ) f[i + 1][0][d + 1] = (f[i + 1][0][d + 1] + f[i][c][d]) % mod;\n          if (py     ) f[i + 1][c ? c + 1 : 0][0] = (f[i + 1][c ? c + 1 : 0][0] + f[i][c][d]) % mod;\n          if (px & py) f[i + 1][max(c + 1, d + 2)][d + 1] = (f[i + 1][max(c + 1, d + 2)][d + 1] + f[i][c][d]) % mod;\n        }\n      }\n    }\n    printf(\"%d\\n\", f[n + 1][0][0]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mod;\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint n,m;\nstruct Solve1{\n    int dp[155][155];\n    void run()\n    {\n        dp[0][0]=1;\n        for(int i=1;i+i<=n+1;++i)\n            for(int j=0;j+j<=m;++j)\n            {\n                ade(dp[i][0],dp[i-1][j]);\n                ade(dp[i][j],dp[i-1][j-1]);\n            }\n        for(int i=1;i<=m/2;++i)ade(dp[n/2][i],dp[n/2][i-1]);\n        for(int i=1;i<=m/2;++i)ade(dp[(n+1)/2][i],dp[(n+1)/2][i-1]);\n        printf(\"%lld\\n\",1ll*dp[n/2][m/2]*dp[(n+1)/2][m/2]%mod);\n    }\n}solve1;\nstruct Solve2{\n    int dp[155][155][155];\n    void run()\n    {\n        dp[0][0][0]=1;\n        int l,r;\n        bool inl,inr;\n        for(int i=1;i<=n;++i)\n        {\n            r=i*2;l=r-m;\n            inl=(l>=1&&l<=n);\n            inr=(r>=1&&r<=n);\n            for(int j=0;j<=n;++j)\n                for(int k=0;k<=m+1;++k)\n                {\n                    ade(dp[i][0][0],dp[i-1][j][k]);\n                    if(inr)//选择当前行右边的点\n                        ade(dp[i][j+1][0],dp[i-1][j][k]);\n                    if(inl&&k+1<=m+1)//选择当前行左边的点\n                        ade(dp[i][0][k?k+1:0],dp[i-1][j][k]);\n                    if(inl&&inr&&max(j+2,k+1)<=m+1)//两边一起选\n                        ade(dp[i][j+1][max(j+2,k+1)],dp[i-1][j][k]);\n                }\n        }\n        printf(\"%d\\n\",dp[n][0][0]);\n    }\n}solve2;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&mod);\n    if(m&1)solve2.run();\n    else solve1.run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (233)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,K,P;\nint solve(int n,int K){\n\tint f[N][N],ans=0; memset(f,0,sizeof(f)); f[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<=K;j++)\n\t(f[i+1][0]+=f[i][j])%=P,(f[i+1][j+1]+=f[i][j])%=P;\n\tfor(int i=0;i<=K;i++)(ans+=f[n][i])%=P; return ans;\n}\nint main(){\n\tread(n),read(K),read(P);\n\tif(K&1){\n\t\tint f[N][N][N]; memset(f,0,sizeof(f));\n\t\tf[0][0][0]=1;\n\t\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\tfor(int k=0,tmp;k<=K+1;k++)\n\t\tif(f[i-1][j][k]){\n\t\t\t(f[i][0][0]+=f[i-1][j][k])%=P;\n\t\t\tif(i*2<=n)(f[i][j+1][0]+=f[i-1][j][k])%=P;\n\t\t\tif(i*2-K>0&&i*2-K<=n&&k+1<K+2)(f[i][0][k?k+1:0]+=f[i-1][j][k])%=P;\n            if(i*2-K>0&&i*2<=n&&(tmp=max(j+2,k+1))<K+2)(f[i][j+1][tmp]+=f[i-1][j][k])%=P;\n\t\t}\n\t\tprintf(\"%d\\n\",f[n+1][0][0]);\n\t}\n\telse printf(\"%lld\\n\",1ll*solve(n/2,K/2)*solve((n+1)/2,K/2)%P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nint MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 155;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint N,K;\narray<array<array<mi,MX>,MX>,MX> dp, DP;\n\nint main() {\n    setIO(); re(N,K,MOD);\n    if(K%2 == 0) {\n    \tdp[0][0][0] = 1;\n\t    F0R(a,N) {\n\t    \tF0R(x,K/2+1) F0R(y,K/2+1) if (dp[x][y][0] != 0) {\n\t    \t\tDP[y+1][x][0] += dp[x][y][0];\n\t    \t\tDP[0][x][0] += dp[x][y][0];\n\t    \t\tdp[x][y][0] = 0;\n\t    \t}\n\t    \tswap(dp,DP);\n\t    }\n\t    mi ans = 0;\n\t    F0R(x,K/2+1) F0R(y,K/2+1) ans += dp[x][y][0];\n\t    ps(ans);\n\t    exit(0);\n    }\n    dp[0][0][N] = 1;\n    F0R(a,N) {\n    \tF0R(x,(a+1)/2+1) F0R(y,a/2+1) FOR(t,a,N+1) if (dp[x][y][t] != 0) {\n\t    \tif (y >= x) {\n    \t\t\tint T = t; \n\t    \t\tif (x && 2*y-K > 0) ckmin(T,a-2*x+1+K);\n\t    \t\tDP[y+1][x][T] += dp[x][y][t]; // yes\n\t    \t\tDP[0][x][N] += dp[x][y][t];\n\t    \t} else {\n    \t\t\tint T = t; \n\t    \t\tif (2*x-1-K >= 0) ckmin(T,a-2*y+K);\n\t    \t\tDP[y+1][x][T] += dp[x][y][t]; // yes\n\t    \t\tDP[0][x][t] += dp[x][y][t];\n\t    \t}\n\t    \tdp[x][y][t] = 0;\n\t    }\n\t    swap(dp,DP);\n    }\n    mi ret = 0;\n    F0R(x,(N+1)/2+1) F0R(y,N/2+1) ret += dp[x][y][N];\n    ps (ret);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat M;\n\nstruct state {\n\tint pos, s0, s1, mx0, mx1;\n\n\tbool operator<(const state & s) const {\n\t\tif(pos != s.pos) return pos < s.pos;\n\t\tif(s0 != s.s0) return s0 < s.s0;\n\t\tif(s1 != s.s1) return s1 < s.s1;\n\t\tif(mx0 != s.mx0) return mx0 < s.mx0;\n\t\treturn mx1 < s.mx1;\n\t}\n};\n\nmap<state, cat> St;\n\ncat solve(int N, int K, int pos, int s0, int s1, int mx0, int mx1) {\n\tif(pos == N) return (mx0 == N && mx1 == N);\n\tif(mx0 < pos || mx1 < pos) return 0;\n\tauto it = St.find({pos, s0, s1, mx0, mx1});\n\tif(it != St.end()) return it->ss;\n\t// remove\n\tint mx0_nw = N, mx1_nw = N;\n\tif(pos%2 == 0) {\n\t\tif(2*s1-1 >= K) mx1_nw = pos + K - 2 * min(K/2, s0);\n\t}\n\telse {\n\t\tif(2*s0-1 >= K) mx0_nw = pos + K - 2 * min(K/2, s1);\n\t}\n\tcat ret1 = 0;\n\tret1 = solve(N, K, pos+1, s0+(pos%2==0), s1+(pos%2==1), min(mx0, mx0_nw), min(mx1, mx1_nw));\n\t// don't remove\n\tcat ret2 = solve(N, K, pos+1, (pos%2==0)?0:s0, (pos%2==1)?0:s1, (pos%2==0)?N:mx0, (pos%2==1)?N:mx1);\n\tSt[{pos, s0, s1, mx0, mx1}] = (ret1 + ret2) % M;\n\treturn (ret1 + ret2) % M;\n}\n\ncat solve_1(int N, int K) {\n\tvector< vector<cat> > dp(N+1, vector<cat>(K+1, 0));\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j <= K; j++) dp[i+1][0] += dp[i][j];\n\t\tfor(int j = 0; j < K; j++) dp[i+1][j+1] += dp[i][j];\n\t\tfor(int j = 0; j <= K; j++) dp[i+1][j] %= M;\n\t}\n\tcat ret = 0;\n\tfor(int i = 0; i <= K; i++) ret += dp[N][i];\n\tret %= M;\n\treturn ret;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, K;\n\tcin >> N >> K >> M;\n\tif(K%2 == 0 || K == 1) {\n\t\tif(K == 1) cout << solve_1(N, 2) << \"\\n\";\n\t\telse cout << solve_1(N/2, K/2) * solve_1(N-N/2, K/2) % M << \"\\n\";\n\t\treturn 0;\n\t}\n\tcout << solve(N, K, 0, 0, 0, N, N) << \"\\n\";\n\t// cerr << St.size() << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > pii;\ntypedef long long LL;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nint N,L,M,dp[2][10000000],xs[10000000][4];\nint ptr,ind[80][80][80][80];\nint F(int k){\n\treturn (k<2)?k:(k/2+1);\n}\nint acc(int a,int b,int c,int d){\n\tint na=F(a),nb=F(b),nc=F(c),nd=F(d);\n\tif(ind[na][nb][nc][nd]!=-1) return ind[na][nb][nc][nd];\n\txs[ptr][0]=a;xs[ptr][1]=b;xs[ptr][2]=c;xs[ptr][3]=d;\n\treturn ind[na][nb][nc][nd]=ptr++;\n}\nint trs(int id,int v){\n\tint a=xs[id][0],b=xs[id][1],c=xs[id][2],d=xs[id][3];\n\tbool gb=0,gd=0;\n\tif(v){\n\t\tif(b==L) return -1;\n\t\tif(c>=L){\n\t\t\tgd=1;\n\t\t\tUMAX(d,((a&&c&&(abs(a-c)==1))?max(a,c):min(a,c))/2*2);\n\t\t}\n\t}\n\telse{\n\t\ta=b=0;\n\t}\n\tif(v) ++a;\n\tif(c) ++c;\n\tif(b || gb) ++b;\n\tif(d || gd) ++d;\n\treturn acc(c,d,a,b);\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&N,&L,&M);\n\tif(L==1){\n\t\tdp[0][0]=1;\n\t\tfor(i=0;i<N;++i){\n\t\t\tint c=(i&1),t=1-c;\n\t\t\tfor(j=0;j<3;++j){\n\t\t\t\tif(!dp[c][j]) continue;\n\t\t\t\tdp[t][0]+=dp[c][j];\n\t\t\t\tif(dp[t][0]>=M) dp[t][0]-=M;\n\t\t\t\tdp[t][j+1]+=dp[c][j];\n\t\t\t\tif(dp[t][j+1]>=M) dp[t][j+1]-=M;\n\t\t\t\tdp[c][j]=0;\n\t\t\t}\n\t\t\tdp[c][3]=0;\n\t\t}\n\t\tint res=0;\n\t\tfor(i=0;i<3;++i){\n\t\t\tres+=dp[N&1][i];\n\t\t\tif(res>=M) res-=M;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\treturn 0;\n\t}\n\telse if(!(L&1)){\n\t\tdp[0][0]=1;\n\t\tfor(i=0;i<N;++i){\n\t\t\tint c=(i&1),t=1-c;\n\t\t\tfor(j=0;j<N*N;++j){\n\t\t\t\tint sn=j%N,sf=j/N;\n\t\t\t\tif(!dp[c][j]) continue;\n\t\t\t\t// choose no\n\t\t\t\tdp[t][sf]+=dp[c][j];\n\t\t\t\tif(dp[t][sf]>=M) dp[t][sf]-=M;\n\t\t\t\t// choose yes\n\t\t\t\tif(sn<L/2){\n\t\t\t\t\tdp[t][sf+(sn+1)*N]+=dp[c][j];\n\t\t\t\t\tif(dp[t][sf+(sn+1)*N]>=M) dp[t][sf+(sn+1)*N]-=M;\n\t\t\t\t}\n\t\t\t\tdp[c][j]=0;\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(i=0;i<N*N;++i){\n\t\t\tres+=dp[N&1][i];\n\t\t\tif(res>=M) res-=M;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\treturn 0;\n\t}\n\tptr=0;\n\tmemset(ind,-1,sizeof(ind));\n\tdp[0][acc(0,0,0,0)]=1;\n\tfor(i=0;i<N;++i){\n\t\tint c=(i&1),t=1-c;\n\t\tfor(j=0;j<ptr;++j){\n\t\t\tif(!dp[c][j]) continue;\n\t\t\tfor(k=0;k<2;++k){\n\t\t\t\tint d=trs(j,k);\n//\t\t\t\tprintf(\"trs %d %d = %d\\n\",j,k,d);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tdp[t][d]+=dp[c][j];\n\t\t\t\t\tif(dp[t][d]>=M) dp[t][d]-=M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dp[c],dp[c]+ptr,0);\n\t}\n\tint res=0;\n\tfor(i=0;i<ptr;++i){\n\t\tres+=dp[N&1][i];\n\t\tif(res>=M) res-=M;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n/*\n * 代码框架\n * 0. 对于L=1：\n * \t\t即要求没有三连击，直接DP\n * 1. 对于偶的L：\n * \t\tdp[i][j][k]：已经确定前i个元素，奇数位置的延续长度为j，偶数位置的延续长度为k\n * 2. 对于奇的L：\n * \t\t四维数组f[i][j][k][l]：奇数位置的延续长度为i、上次距离为j；偶数位置的延续长度为k、上次距离为l\n * \t\t\t“上次距离”指奇偶性相反的中间位置\n * \t\t\t记得把坐标都/=2。=0表示不存在。\n * \t\t\ti,j,k,l都为n/2的级别\n * \t\t\t实现函数，支持access位置。维护指针\n * \t\t二维DP：dp[i][j]已经确定前i个元素，四维状态为j\n * \t\t实现函数：给定状态和下一位的取值，返回转移到的状态\n * \t\t\t将所有位置++\n * \t\t\t1. 判断是否可作为中间位置\n * \t\t\t\t若标记为空则更新\n * \t\t\t2. 判断是否可作为末尾位置\n * \t\t\t\t若打开则返回-1\n * \t\t\t\t若未打开则清空标记\n * \t\t转移：\n * \t\t\t直接做\n * \t\t结果取最后的总和\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 150;\nint N, K, M;\nint add(int a, int b) {return (a + b)%M;}\nint mul(int a, int b) {return 1LL*a*b%M;}\nint f[MAXN + 5][MAXN + 5];\nvoid solve1() {\n\tK /= 2, f[0][0] = 1;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=0;j<=K;j++)\n\t\t\tf[i][0] = add(f[i][0], f[i-1][j]);\n\t\tfor(int j=0;j<K;j++)\n\t\t\tf[i][j+1] = add(f[i][j+1], f[i-1][j]);\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tfor(int i=0;i<=K;i++)\n\t\tans1 = add(ans1, f[N/2][i]);\n\tfor(int i=0;i<=K;i++)\n\t\tans2 = add(ans2, f[(N+1)/2][i]);\n\tprintf(\"%d\\n\", mul(ans1, ans2));\n}\nint g[2*MAXN + 5][MAXN + 5][MAXN + 5];\nvoid solve2() {\n\tint p; g[0][0][0] = 1;\n\tfor(int i=2;i-K<=N;i+=2) {\n\t\tfor(int j=0;j<=N;j++)\n\t\t\tfor(int k=0;k<=K+1;k++)\n\t\t\t\tg[i][0][0] = add(g[i][0][0], g[i-2][j][k]);\n\t\tif( i <= N ) {\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;k<=K+1;k++)\n\t\t\t\t\tg[i][j+1][0] = add(g[i][j+1][0], g[i-2][j][k]);\n\t\t}\n\t\tif( i - K >= 1 ) {\n\t\t\tfor(int j=0;j<=N;j++) {\n\t\t\t\tfor(int k=1;k<=K;k++)\n\t\t\t\t\tg[i][0][k+1] = add(g[i][0][k+1], g[i-2][j][k]);\n\t\t\t\tg[i][0][0] = add(g[i][0][0], g[i-2][j][0]);\n\t\t\t}\n\t\t}\n\t\tif( i <= N && i - K >= 1 ) {\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;max(k,j+1)<=K;k++)\n\t\t\t\t\tg[i][j+1][max(k+1,j+2)] = add(g[i][j+1][max(k+1,j+2)], g[i-2][j][k]);\n\t\t}\n\t\tp = i;\n\t}\n\tint ans = 0;\n\tfor(int j=0;j<=N;j++)\n\t\tfor(int k=0;k<=K+1;k++)\n\t\t\tans = add(ans, g[p][j][k]);\n\tprintf(\"%d\\n\", ans);\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &K, &M);\n\tif( K % 2 == 0 ) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "/*Lower_Rating*/\n/*AGC035 number*/\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<map>\nusing namespace std;\n\n#define LL long long\n#define DB double\n#define MAXN 150\n#define Pr pair<LL,LL>\n#define PR pair<pair<int,int>,Pr>\n#define X first\n#define Y second\n#define INF 2000000000000000000\n#define mem(x,p) memset(x,p,sizeof(x))\n\nLL read(){\n  LL x=0,F=1;char c=getchar();\n  while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n  while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n  return x*F;\n}\nLL MOD;\nint add(int x,int y){return (x+y>=MOD)?x+y-MOD:x+y;}\nint dec(int x,int y){return (x-y<0)?x-y+MOD:x-y;}\nint mul(int x,int y){return 1LL*x*y%MOD;}\n\nint n,k;\nstruct subtask1{\n    int f[MAXN+5][MAXN+5];\n    int cal(int n,int k){\n        f[0][0]=1;\n        for(int i=1;i<=n;i++){\n            f[i][0]=f[i-1][0];\n            for(int j=1;j<=k;j++){\n                f[i][0]=add(f[i][0],f[i-1][j]);\n                f[i][j]=f[i-1][j-1];\n            }\n        }int res=0;\n        for(int j=0;j<=k;j++)res=add(res,f[n][j]);\n        return res;\n    }\n    int process(){\n        return mul(cal(n>>1,k>>1),cal((n+1)>>1,k>>1));\n    }\n}T1;\n\nstruct subtask2{\n    int f[MAXN+5][MAXN+5][MAXN+5];\n    int process(){\n        f[0][0][0]=1;\n        for(int i=1;i<=n;i++){\n            int r=(i<<1),l=r-k;\n            int cl=1<=l&&l<=n,cr=1<=r&&r<=n;\n            for(int j=0;j<=n;j++)\n                for(int p=0;p<=k+1;p++){\n                    f[i][0][0]=add(f[i][0][0],f[i-1][j][p]);\n                    if(cr)f[i][j+1][0]=add(f[i][j+1][0],f[i-1][j][p]);\n                    if(cl&&p+1<k+2)f[i][0][p?p+1:p]=add(f[i][0][p?p+1:p],f[i-1][j][p]);\n                    if(cl&&cr&&max(p+1,j+2)<k+2)f[i][j+1][max(p+1,j+2)]=add(f[i][j+1][max(p+1,j+2)],f[i-1][j][p]);\n                }\n        }int res=0;\n        for(int j=0;j<=n;j++)\n            for(int p=0;p<=k+1;p++)\n            res=add(res,f[n][j][p]);\n        return res;\n    }\n}T2;\nint main()\n{\n    n=read(),k=read();MOD=read();\n    if(k%2==0)printf(\"%d\\n\",T1.process());\n    else printf(\"%d\\n\",T2.process());\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<stdint.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define VIS(it,con) for(auto it=con.begin();it!=con.end();++it)\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define MIN(x,y) (x=min(x,(y)))\n#define MAX(x,y) (x=max(x,(y)))\n#define mid (l+r>>1)\n#define lch (idx*2+1)\n#define rch (idx*2+2)\n/*****************************************************************************/\n#include<bits/stdc++.h>\n#define int int_fast64_t\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\n#define REP(i,j,k) for(int i=(j);i<(k);++i)\n#define RREP(i,j,k) for(int i=(j)-1;i>=(k);--i)\n#define ALL(a) a.begin(),a.end()\n#define MST(a,v) memset(a,(v),sizeof a)\n#define pb push_back\n#define F first\n#define S second\n#define endl '\\n'\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#define __debug\n#ifdef __debug\n\t#define IOS (void)0\n\t#define de(...) cerr<<__VA_ARGS__\n\t#define ar(a,s,t) {REP(__i,s,t)de(a[__i]<<' ');de(endl);}\n#else\n\t#define IOS cin.tie(0),cout.tie(0),ios_base::sync_with_stdio(false)\n\t#define de(...) (void)0\n\t#define ar(...) (void)0\n#endif\n/***********************************default***********************************/\nconst int maxn=159;\nint n,kk,m,dp[2][maxn][maxn][maxn],par[2][maxn/2];\n\nmain(){\n\tIOS;\n\tcin>>n>>kk>>m;\n\tconst int mo=m;\n\tif(kk&1){\n\t\tfill(dp[0][0][0],dp[0][0][0]+n,0);\n\t\tdp[0][0][0][n]=1;\n\t\tREP(i,0,n){\n\t\t\tint t=i&1;\n\t\t\tREP(j,0,i+1-(i+1)/2+1)REP(k,0,(i+1)/2+1)REP(l,i+1,n+1)dp[!t][j][k][l]=0;\n\t\t\tREP(j,0,i-i/2+1){\n\t\t\t\tREP(k,0,i/2+1){\n\t\t\t\t\tREP(l,i,n+1){\n\t\t\t\t\t\t(dp[!t][0][j][n]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\tif(i!=l){\n\t\t\t\t\t\t\tint mn=l;\n\t\t\t\t\t\t\tif(i-2*k+kk<i)MIN(mn,i-2*j+1+kk);\n\t\t\t\t\t\t\tif(i-2*j+kk<i)MIN(mn,i-2*k+kk);\n\t\t\t\t\t\t\t(dp[!t][k+1][j][mn]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tREP(i,0,n-n/2+1)REP(j,0,n/2+1)(res+=dp[n&1][i][j][n])%=mo;\n\t\tcout<<res<<endl;\n\t}else{\n\t\tpar[0][0]=1;\n\t\tREP(i,0,n/2+2){\n\t\t\tint t=i&1;\n\t\t\tfill(par[!t],par[!t]+i+2,0);\n\t\t\tREP(j,0,i+1){\n\t\t\t\t(par[!t][0]+=par[t][j])%=mo;\n\t\t\t\tif(j+1<kk/2+1)(par[!t][j+1]+=par[t][j])%=mo;\n\t\t\t}\n\t\t}\n\t\tcout<<par[(n/2+1)&1][0]*par[(n-n/2+1)&1][0]%mo<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=155;\nint n,k,mo;\nnamespace solver1{\n\tint f[N][N];\n\tvoid solve(){\n\t\tint v1=n/2,v2=n-n/2;\n\t\tf[0][0]=1; k/=2;\n\t\tFor(i,1,v2) For(j,0,k){\n\t\t\tf[i][0]=(f[i][0]+f[i-1][j])%mo;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i-1][j])%mo;\n\t\t}\n\t\tint ans1=0,ans2=0;\n\t\tFor(j,0,k){\n\t\t\tans1=(ans1+f[v1][j])%mo;\n\t\t\tans2=(ans2+f[v2][j])%mo;\n\t\t}\n\t\tprintf(\"%lld\\n\",1ll*ans1*ans2%mo);\n\t}\n}\nnamespace solver2{\n\tint f[2][N][N][N];\n\tvoid solve(){\n\t\tint v=(k+3)/2,pre=0,suf=1;\n\t\tf[0][0][0][(n+3)/2]=1;\n\t\tFor(i,1,n){\n\t\t\tmemset(f[1],0,sizeof(f[1]));\n\t\t\tFor(p1,0,v) For(p2,0,v) For(p3,1,(n+3)/2)\n\t\t\t\tif (f[0][p1][p2][p3]){\n\t\t\t\t\tint np1,np2,np3;\n\t\t\t\t\tnp1=min(v,p2+1); np2=p1; np3=p3-(p2>=v);\n\t\t\t\t\tif (np1>=v&&np2) np3=min(np3,k+2-v-np2);\n\t\t\t\t\tif (np3) f[1][np1][np2][np3]=(f[1][np1][np2][np3]+f[0][p1][p2][p3])%mo;\n\t\t\t\t\tnp1=0; np2=p1; np3=(p2>=v?(n+3)/2:p3);\n\t\t\t\t\tf[1][np1][np2][np3]=(f[1][np1][np2][np3]+f[0][p1][p2][p3])%mo;\n\t\t\t\t}\n\t\t\tmemcpy(f[0],f[1],sizeof(f[0]));\n\t\t}\n\t\tint ans=0;\n\t\tFor(p1,0,v) For(p2,0,v) For(p3,1,(n+3)/2)\n\t\t\tans=(ans+f[0][p1][p2][p3])%mo;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&mo);\n\tif (k%2==0) solver1::solve();\n\telse solver2::solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N = 152; \nint P;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\nvoid upd(int &a, int b) { a = add(a, b); } \n\nint n, k;\n\nnamespace Even { \n\tint f[N][N], g[N]; \n\tvoid solve() {\n\t\tf[0][0] = 1; \n\t\tint l = k / 2;\n\t\tlop(i, 0, n) rep(j, 0, l) {\n\t\t\tupd(f[i + 1][0], f[i][j]); \n\t\t\tif (j + 1 <= l) upd(f[i + 1][j + 1], f[i][j]);; \n\t\t}\n\t\trep(i, 1, n) rep(j, 0, l) g[i] += f[i][j]; \n\t\tcout << mul(g[n / 2], g[(n + 1) / 2]) << endl;\n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tcin >> n >> k >> P; \n\tif (k % 1 == 0) {\n\t\tEven::solve(); \n\t\treturn 0; \n\t}\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nint md;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nint n, k;\n\nint main() {\n  cin >> n >> k >> md;\n  if(k % 2 == 0) {\n    k /= 2;\n    vector<int> dp((n + 1) / 2 + 1);\n    dp[0] = 1;\n    range(i, 1, (n + 3) / 2) {\n      husk(j, i - 1, max(i - k - 2, -1)) {\n        add(dp[i], dp[j]);\n      }\n      if(i <= k) add(dp[i], 1);\n    }\n    cout << mul(dp[n / 2], dp[(n + 1) / 2]);\n    return 0;\n  }\n  vector<int> p(n + 1);\n  p[0] = 1;\n  range(i, 1, n + 1) p[i] = mul(p[i - 1], 2);\n  vector<vector<int>> dp((n + 1) / 2 + 1, vector<int>(n / 2 + 1));\n  range(a, 0, (n + 1) / 2 + 1) {\n    range(b, 0, n / 2 + 1) {\n      if(2 * a - 2 < k + 1 || 2 * b - 1 < k) {\n        dp[a][b] = p[a + b];\n        continue;\n      }\n      dp[a][b] = dp[a - 1][b];\n      int sb = 2 * b - 1;\n      int sl = k, sr = 2 * a - 2 - k;\n      if(sl <= sr) {\n        sr = min(sr, sb);\n        add(dp[a][b], p[b - (sr - sl) / 2 - 1]);\n      } else {\n        add(dp[a][b], mul(p[(sl - sr) / 2 + 1] - 1, p[b - 1 - (sl - sr) / 2]));\n      }\n      range(x, 0, a - 1) {\n        int l = 2 * x + 2 + k, r = 2 * a - 2 - k;\n        if(l <= r) {\n          if(a == 4 && b == 1) debug(x);\n          r = min(r, sb);\n          l = min(l, sb + 2);\n          int cnt;\n          if(l > sb) {\n            cnt = 0;\n          } else {\n            cnt = (sb - r) / 2;\n          }\n          add(dp[a][b], mul(dp[x][l / 2], p[cnt]));\n        } else {\n          if(l > sb) {\n            add(dp[a][b], dp[x][b]);\n            continue;\n          }\n          int cur = 0;\n          for(int y = r; y <= l; y += 2) {\n            int res = dp[x][y / 2];\n            sub(res, cur);\n            cur = mul(cur, 2);\n            add(cur, res);\n            add(dp[a][b], mul(res, p[(sb - y) / 2]));\n          }\n        }\n      }\n    }\n  }\n  cout << dp[(n + 1) / 2][n / 2] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\n\nint mod;\n\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint& v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0) val += mod;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& a) { return os << a.val; }\n\tfriend bool operator==(const mint& a, const mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint& operator+=(const mint& m) { if ((val += m.val) >= mod) val -= mod; return *this; }\n\tmint& operator-=(const mint& m) { if ((val -= m.val) < 0) val += mod; return *this; }\n\tmint& operator*=(const mint& m) { val = (lint)val*m.val%mod; return *this; }\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint& a) { assert(a.val); return ipow(a, mod - 2); }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n\toperator int64_t() const {return val; }\n};\n\nmint ez(int n, int k){\n\tvector<mint> dp(n + 2);\n\tdp[0] = mint(1);\n\tfor(int i=1; i<=n+1; i++){\n\t\tfor(int j=1; j<=k+1 && j<=i; j++){\n\t\t\tdp[i] += dp[i - j];\n\t\t}\n\t}\n\treturn dp[n + 1];\n}\n\nvector<int> v;\nmint dp[155][155][155][2], nxt[155][155][155][2];\nmint sex[155][155][155];\nint kk;\n\nint adj[20][20];\nbool in(int msk, int val){\n\tif(val > 20 || val < 0) return 0;\n\treturn (msk >> val) & 1;\n}\n\nint g(int n, int k){\n\tint ret = 0;\n\tfor(int i=0; i<(1<<n); i++){\n\t\tmemset(adj, 0, sizeof(adj));\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(in(i, j - 2)) adj[j][j - 2] = 1;\n\t\t\tif(in(i, j + k)) adj[j][j + k] = 1;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tadj[j][k] |= (adj[j][i] & adj[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool good = 1;\n\t\tfor(int i=0; i<n; i++) if(adj[i][i]) good = 0;\n\t\tret += good;\n\t}\n\treturn ret;\n}\n\nmint f(int pos, int l, int dp){\n\tif(dp >= kk) return mint(0);\n\tif(pos == sz(v)) return mint(1);\n\tif(sex[pos][l][dp]) return sex[pos][l][dp];\n\tmint ret = f(pos + 1, 0, 0);\n\tif(v[pos] & 1){\n\t\tret += f(pos + 1, l + 1, 0);\n\t}\n\tif(v[pos] & 2){\n\t\tret += f(pos + 1, 0, dp ? (dp + 1) : 0);\n\t}\n\tif(v[pos] == 3){\n\t\tret += f(pos + 1, l + 1, max(l + 2, dp + 1));\n\t}\n\treturn sex[pos][l][dp] = ret;\n}\n\nmint solve(int n, int thr){\n\tkk = thr;\n\treturn f(0, 0, 0);\n\tdp[0][0][0][0] = 1;\n\tfor(auto &x : v){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i=0; i<=n; i++){ // short\n\t\t\tfor(int j=0; j<=n; j++){ // long\n\t\t\t\tfor(int k=0; k<=thr; k++){ // long with tail\n\t\t\t\t\tfor(int l=0; l<2; l++){ // 1 if up is long\n\t\t\t\t\t\tif((lint)dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t\tnxt[0][0][0][0] += dp[i][j][k][l];\n\t\t\t\t\t\tint next_k = 0;\n\t\t\t\t\t\tif(k > 0) next_k = k + 1;\n\t\t\t\t\t\telse if(i > 0) next_k = i + 2;\n\t\t\t\t\t\tif(x & 1){\n\t\t\t\t\t\t\tif(l == 0){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x & 2){\n\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x == 3){\n\t\t\t\t\t\t\tnxt[i + 1][j + 1][k ? (k + 1) : 0][l] += dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int k=0; k<thr; k++){\n\t\t\t\t\tif(i > 0 && j >= thr - 1){\n\t\t\t\t\t\tnxt[i][j][k][0] = nxt[i][j][k][1] = mint(0);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k][0] = nxt[i][j][k][0];\n\t\t\t\t\tdp[i][j][k][1] = nxt[i][j][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=thr; k++){\n\t\t\t\tfor(int l=0; l<2; l++) ret += dp[i][j][k][l];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k >> mod;\n\tif(k % 2 == 0){\n\t\tcout << ez((n + 1) / 2, k / 2) * ez(n / 2, k / 2) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n+n; i+=2){\n\t\tif(i - k > n) break;\n\t\tint msk = 0;\n\t\tif(i <= n) msk |= 1;\n\t\tif(i - k >= 1) msk |= 2;\n\t\tv.push_back(msk);\n\t}\n\tmint ret = solve(n, k + 2);\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define cri const int\n#define ll long long\n#define re register\nusing namespace std;\nint N,K,mod;\nint f[152][152];\ninline int mo(cri x){ return x>=mod?x-mod:x; } \ninline void solve2(){\n\tf[0][0]=f[1][0]=f[1][1]=f[2][0]=f[2][1]=1;\n\tK=(K>>1)+1;\n\tfor(int i=3;i<=N;i++){\n\t\tfor(int j=0;j<K;j++) f[i][0]=mo(f[i][0]+f[i-2][j]);\n\t\tfor(int j=0;j<K-1;j++) f[i][j+1]=f[i-2][j];\n\t}\n\tint tmp1=0,tmp2=0;\n\tfor(int i=0;i<K;i++) tmp1=mo(tmp1+f[N][i]),tmp2=mo(tmp2+f[N-1][i]);\n\tcout<<1ll*tmp1*tmp2%mod<<endl;\n}\nint dp[152][152][152];\ninline void solve1(){\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=N+K>>1;i++){//cout<<\"i=\"<<i<<endl;\n\t\tif(i<=K/2) for(int j=0;j<i;j++) dp[i][0][j+1]=dp[i-1][0][j],dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][0][j]);\n\t\telse if(i<=N/2){\n\t\t\tfor(int j=0;j<=i;j++) \n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t//cout<<j<<\" \"<<k<<endl;\n\t\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\t\telse dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][0][k+1]=mo(dp[i][0][k+1]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][max(j+1,k+2)][k+1]=mo(dp[i][max(j+1,k+2)][k+1]+dp[i-1][j][k]);\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<=i;j++) for(int k=0;k<i;k++) {\n\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\telse dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=K+2;j<=i+1;j++) memset(dp[i][j],0,sizeof dp[i][j]); \n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++) ans=mo(ans+dp[N+K>>1][i][k]);\n\tcout<<ans<<endl;\n}\nint main(){\n\tcin>>N>>K>>mod;\n\tif(K&1) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 155;\n\nll work_odd(int n, int k, ll mod)\n{\n\tauto add = [=](ll &x, const ll &y){x = (x+y) % mod;};\n\tstatic ll f[2][MX][MX];\n\tint now = 0;\n\tmemset(f[now], 0, sizeof(f[now]));\n\tf[now][0][0] = 1;\n\tfor(int i=2-k; i<=n+2; i+=2)\n\t{\n\t\tint l = i, r = i+k;\n\t\tmemset(f[now^1], 0, sizeof(f[now^1]));\n\t\t//l=0, r=0:\n\t\tfor(int a=0; a<=k+1; a++)\n\t\t\tfor(int b=0; b<=n; b++)\n\t\t\t\tadd(f[now^1][0][0], f[now][a][b]);\n\n\t\t//l=1, r=0:\n\t\tif(1<=l && l<=n)\n\t\t\tfor(int a=0; a<k+1; a++)\n\t\t\t\tfor(int b=0; b<=n; b++)\n\t\t\t\t\tadd(f[now^1][a+(a>0)][0], f[now][a][b]);\n\t\t\n\t\t//l=0, r=1:\n\t\tif(r <= n)\n\t\t\tfor(int a=0; a<=k+1; a++)\n\t\t\t\tfor(int b=0; b<=n; b++)\n\t\t\t\t\tadd(f[now^1][0][b+1], f[now][a][b]);\n\t\t\n\t\t//l=1, r=1:\n\t\tif(1<=l && l<=n && r<=n)\n\t\t\tfor(int a=0; a+1<=k+1; a++)\n\t\t\t\tfor(int b=0; b+2<=k+1; b++)\n\t\t\t\t\tadd(f[now^1][max(a+1, b+2)][b+1], f[now][a][b]);\n\t\t\n\t\tnow ^= 1;\n\t}\n\treturn f[now][0][0];\n}\n\nll work_even(int n, int k, ll mod)\n{\n\tauto add = [=](ll &x, const ll &y){x = (x+y) % mod;};\n\tstatic ll f[MX][MX];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0] = 1;\n\tfor(int i=1; i<=n+1; i++)\n\t{\n\t\tfor(int j=0; j<=k; j++) add(f[i][0], f[i-1][j]);\n\t\tfor(int j=1; j<=k; j++) add(f[i][j], f[i-1][j-1]);\n\t}\n\treturn f[n+1][0];\n}\n\nint main()\n{\n\tint n, k;\n\tll mod;\n\tscanf(\"%d%d%lld\", &n, &k, &mod);\n\tif(k&1) printf(\"%lld\\n\", work_odd(n, k, mod));\n\telse printf(\"%lld\\n\", work_even(n/2, k/2, mod) * work_even(n-n/2, k/2, mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\nusing namespace std;\nconst int N=155;\nint n,k,m,_n,_k,v,f[N][N],g[N][N][N];\nint main(){\n\tcin>>n>>k>>m;\n\tif(~k&1){\n\t\tint a=n+1>>1;\n\t\tf[0][0]=1;k=k/2+1;\n\t\tfo(i,1,a){\n\t\t\tf[i][0]=f[i-1][k-1];\n\t\t\tfo(j,0,k-2)f[i][j+1]=f[i-1][j],f[i][0]=(f[i][0]+f[i-1][j])%m;\n\t\t}\n\t\tint su1=0,su2=0;\n\t\tfo(i,0,k-1)su1=(su1+f[a][i])%m,su2=(su2+f[n-a][i])%m;\n\t\tprintf(\"%d\",(ll)su1*su2%m);\n\t\treturn 0;\n\t}\n\tf[0][0]=1;_k=(k+1)/2-1;\n\tfo(i,1,_k)\n\t\tfo(j,0,i)f[i][j+1]=f[i-1][j],f[i][0]=(f[i][0]+f[i-1][j])%m;\n\t_n=(n+1)/2+1;\n\tfo(j,0,_k)g[0][j][_n]=f[_k][j];\n\tfo(o,1,(n-k+1)/2)\n\t\tfo(i,0,o+_k)\n\t\t\tfo(j,o,_n)\n\t\t\t\tif(v=g[o-1][i][j]){\n\t\t\t\t\t//0 0\n\t\t\t\t\tg[o][0][_n]=(g[o][0][_n]+v)%m;\n\t\t\t\t\t//0 1\n\t\t\t\t\tg[o][i+1][_n]=(g[o][i+1][_n]+v)%m;\n\t\t\t\t\t//1 \n\t\t\t\t\tif(o<j){\n\t\t\t\t\t\t//1 0\n\t\t\t\t\t\tg[o][0][j]=(g[o][0][j]+v)%m;\n\t\t\t\t\t\t//1 1\n\t\t\t\t\t\tint lim=min(o-i+k,_n);\n\t\t\t\t\t\tif(o<lim)\n\t\t\t\t\t\t\tg[o][i+1][min(lim,j)]=(g[o][i+1][min(lim,j)]+v)%m;\n\t\t\t\t\t}\n\t\t\t\t}\n\tmemset(f,0,sizeof f);\n\tfo(j,0,_n)fo(i,0,n/2)f[(n-k+1)/2][j]=(f[(n-k+1)/2][j]+g[(n-k+1)/2][i][j])%m;\n\tfo(o,(n-k+1)/2+1,(n+1)/2)\n\t\tfo(j,0,_n)if(v=f[o-1][j]){\n\t\t\tf[o][_n]=(f[o][_n]+v)%m;\n\t\t\tif(o<j)f[o][j]=(f[o][j]+v)%m;\n\t\t}\n\tcout<<f[(n+1)/2][_n];\n}"
  },
  {
    "language": "C++",
    "code": "//quming\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nint P;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=155;\nint n,p;\ninline int max(R int x,R int y){return x>y?x:y;}\nint solve(int n,int p){\n    static int f[N][N];memset(f,0,sizeof(f));\n    f[0][0]=1;\n    fp(i,0,n-1)fp(j,0,p)if(f[i][j])upd(f[i+1][0],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n    R int res=0;fp(i,0,p)upd(res,f[n][i]);\n    return res;\n}\nint f[N][N][N];\nint main(){\n//  freopen(\"testdata.in\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&p,&P);\n    if(p&1^1)return printf(\"%d\\n\",mul(solve(n>>1,p>>1),solve((n+1)>>1,p>>1))),0;\n    f[0][0][0]=1;\n    fp(i,1,n+1){\n        R int r=(i<<1),l=r-p;\n        R bool fr=(r>=1&&r<=n),fl=(l>=1&&l<=n);\n        fp(j,0,n)fp(k,0,p+1)if(f[i-1][j][k]){\n            upd(f[i][0][0],f[i-1][j][k]);\n            if(fr)upd(f[i][j+1][0],f[i-1][j][k]);\n            if(fl&&k+1<p+2)upd(f[i][0][k?k+1:k],f[i-1][j][k]);\n            if(fl&&fr&&max(j+2,k+1)<p+2)upd(f[i][j+1][max(k+1,j+2)],f[i-1][j][k]);\n        }\n    }\n    printf(\"%d\\n\",f[n+1][0][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=200;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint k,n;\nLL dp[2][NN][NN]={};\nint mod;\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\nvoid upd(LL &x,LL y){\n\tx=(x+y)%mod;\n}\nvoid solve1(){\n\tdp[0][0][0]=1;\n\tint lim=k/2;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int a=0;a<=lim;++a){\n\t\t\tfor(int b=0;b<=lim;++b){\n\t\t\t\tif(i&1){\n\t\t\t\t\tupd(dp[i][a][0],dp[i-1][a][b]);\n\t\t\t\t\tupd(dp[i][a][b+1],dp[i-1][a][b]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tupd(dp[i][0][b],dp[i-1][a][b]);\n\t\t\t\t\tupd(dp[i][a+1][b],dp[i-1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int a=0;a<=lim;++a){\n\t\tfor(int b=0;b<=lim;++b){\n\t\t\tupd(ans,dp[n][a][b]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nvoid empty(int now){\n\tfor(int j=0;j<=k+2;++j){\n\t\tfor(int l=0;l<=k+2;++l){\n\t\t\tdp[now][j][l]=0;\n\t\t}\n\t}\n}\nvoid cut(int now){\n\tfor(int j=0;j<=k+2;++j){\n\t\tfor(int l=k-j+2;l<=k+2;++l){\n\t\t\tdp[now][j][l]=0;\n\t\t}\n\t}\n}\nvoid pushodd(int now){\n\tfor(int j=0;j<=k+1;++j){\n\t\tfor(int l=0;l<=k+1;++l){\n\t\t\tupd(dp[now][j][0],dp[now^1][j][l]);\n\t\t\tupd(dp[now][j][l+1],dp[now^1][j][l]);\n\t\t}\n\t}\n\tupd(dp[now][0][k+1],dp[now^1][0][k+1]);\n}\nvoid pusheven(int now){\n\tfor(int j=1;j<=k+2;++j){\n\t\tfor(int l=0;l<=k+2;++l){\n\t\t\tupd(dp[now][j-1][l],dp[now^1][j][l]);\n\t\t}\n\t}\n\tupd(dp[now][k+1][0],dp[now^1][k+1][0]);\n\tfor(int j=0;j<=k+1;++j){\n\t\tfor(int l=0;l<=k+1;++l){\n\t\t\tupd(dp[now][j][l],dp[now^1][0][l]);\n\t\t}\n\t}\n}\nvoid solve2(){\n\tint t=(k+1)/2;\n\tint now=0;\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=k;i+=2){//2 4 6 | 1 3 5\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpushodd(now);\n\t\tcut(now);\n\t}\n\tfor(int i=k+2;i<=n;i+=2){\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpushodd(now);\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpusheven(now);\n\t\tcut(now);\n\t}\n\tint cur=(n+1)/2*2-1-k;\n\tint cnt=(n-cur)/2;\n\tLL ans=0;\n\tfor(int j=0;j<=cnt;++j){\n\t\tfor(int l=0;l<=k+1-j;++l){\n\t\t\tint rem=cnt-j;\n\t\t\tupd(ans,dp[now][j][l]*ksm(2,rem));\n\t\t}\n\t}\n\tfor(int l=0;l<=k+1-cnt-1;++l){\n\t\tupd(ans,dp[now][cnt+1][l]);\n\t}\n\t/*for(int i=cur+2;i<=n;i+=2){\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpusheven(now);\n\t\tcut(now);\n\t}\n\tfor(int i=0;i<=k+1;++i){\n\t\tupd(ans,dp[now][0][i]);\n\t\tif(i<=k)upd(ans,dp[now][1][i]);\n\t}*/\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//open();\n\tn=read();\n\tk=read();\n\tmod=read();\n\tif(k%2==0){\n\t\tsolve1();\n\t}\n\telse solve2();\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll MOD;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll solve1(int N, int K) {\n\tvector<vector<ll>> dp(N + 1, vector<ll>(N + 1));\n\n\tdp[0][0] = 1;\n\n\trep(i, N) {\n\t\tfor (int j = 0; j <= min(i, K); ++j) {\n\t\t\tadd(dp[i + 1][0], dp[i][j]);\n\t\t\tif (j + 1 <= K) add(dp[i + 1][j + 1], dp[i][j]);\n\t\t}\n\t}\n\n\tll res = 0;\n\n\tfor (int j = 0; j <= K; ++j) add(res, dp[N][j]);\n\n\t\treturn res;\n}\n\nconst int maxn = 160;\n\nll dp[2][maxn][maxn][maxn]; //j < k : rightmost excluded elements, l : limitation (0 means none)\n\nll solve(int N, int K) { // K : odd\n\tmemset(dp, 0, sizeof(dp));\n\n\t//handle as 0 and 1 already skipped and start from 2 to N + 1\n\tint c = 0, f = 1;\n\tdp[c][0][1][0] = 1;\n\n\t++N;\n\n\tfor (int i = 2; i <= N; ++i) {\n\t\t//init\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = j; k <= i; ++k) {\n\t\t\t\tfor (int l = 0; l <= N; ++l) {\n\t\t\t\t\tdp[f][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = i % 2; j < i; j += 2) {\n\t\t\tfor (int k = j - 1; k >= 0; k -= 2) { //parity : i = j != k, k < j < i\n\t\t\t\tbool can = (j + K + 2 <= N && i - K - 2 >= k); //a cycle can be formed or not\n\t\t\t\t//include i and a new constraint (note that constraint is determinied by j), on k side\n\t\t\t\tadd(dp[f][k][j][can ? j + K + 2 : 0], dp[c][k][j][0]);\n\n\t\t\t\t//include i\n\t\t\t\tfor (int l = i + 1; l <= N; ++l) {\n\t\t\t\t\tadd(dp[f][k][j][l], dp[c][k][j][l]);\n\t\t\t\t}\n\n\t\t\t\t//exclude i\n\t\t\t\tfor (int l = 0; l <= N; ++l) {\n\t\t\t\t\tadd(dp[f][k][i][l], dp[c][k][j][l]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = j + 1; k < i; ++k) { //parity : i = j != k, j < k < i\n\t\t\t\t//include i\n\t\t\t\tadd(dp[f][j][k][0], dp[c][j][k][0]);\n\n\t\t\t\tfor (int l = i + 1; l <= N; ++l) {\n\t\t\t\t\tadd(dp[f][j][k][l], dp[c][j][k][l]);\n\t\t\t\t}\n\n\t\t\t\t//exclude i\n\t\t\t\tfor (int l = 0; l <= N; ++l) {\n\t\t\t\t\tadd(dp[f][k][i][0], dp[c][j][k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(c, f);\n\t}\n\tll ans = 0;\n\tfor (int j = 0; j <= N; ++j) {\n\t\tfor (int k = 0; k <= N; ++k) {\n\t\t\tfor (int l = 0; l <= N; ++l) {\n\t\t\t\tadd(ans, dp[c][j][k][l]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N, K, M; cin >> N >> K >> M;\n\tMOD = M;\n\n\tif (K % 2 == 0) {\n\t\tll ans = solve1(N / 2, K / 2) * solve1((N + 1) / 2, K / 2) % MOD;\n\t\tcout << ans << endl;\n\t} else if (K == 1) {\n\t\tll ans = solve1(N, 2);\n\t\tcout << ans << endl;\n\t} else {\n\t\tll ans = solve(N, K);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define ll long long\nusing namespace std;\nconst int N=360;\nint mod;\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod;  }\nint solve0(int n,int k) { // you can't choose k consecutive integers\n\tstatic int f[N];\n\tf[0]=1;\n\tfor(int i=1;i<=n+1;++i) {\n\t\tf[i]=0;\n\t\tfor(int j=i-1;i-j-1<k&&j>=0;--j)\n\t\t\tf[i]=(f[i]+f[j])%mod;\n\t}\n\treturn f[n+1];\n}\nint solve1(int n,int k) { // k is odd, k!=1\n\tstatic int f[N][N][N];\n\tf[1][0][0]=1;\n\tf[1][1][0]=1;\n\tfor(int i=2;i*2-k<=n;++i) {\n\t\tint a=2*i,b=2*i-k;\n\t\tfor(int j=0;j<=i-1;++j) // go down\n\t\t\tfor(int l=0;l<=i-1;++l) if(f[i-1][j][l]) { // go down - left - down\n\t\t\t//\tcout<<i-1<<' '<<j<<' '<<l<<':'<<f[i-1][j][l]<<endl;\n\t\t\t\tif(b<0) {\n\t\t\t\t\tAdd(f[i][0][0],f[i-1][j][l]);\n\t\t\t\t\tAdd(f[i][j+1][0],f[i-1][j][l]);\n\t\t\t\t}\n\t\t\t\telse if(a>n) {\n\t\t\t\t\tAdd(f[i][0][0],f[i-1][j][l]);\n\t\t\t\t\tif(l) { if(l<k) Add(f[i][0][l+1],f[i-1][j][l]); }\n\t\t\t\t\telse Add(f[i][0][0],f[i-1][j][l]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int s=0;s<4;++s) {\n\t\t\t\t\t\tint x=s&1,y=s&2;\n\t\t\t\t\t\tint j1=x?j+1:0;\n\t\t\t\t\t\tint l1=(y&&l)?l+1:0;\n\t\t\t\t\t\tif(x&&y) l1=max(l1,j+1);\n\t\t\t\t\t\tif(l1>=k+1) continue; \n\t\t\t\t\t\tAdd(f[i][j1][l1],f[i-1][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=(n+k)/2;++j)\n\t\tfor(int l=0;l<=k;++l) if(f[(n+k)/2][j][l])\n\t\t\tans=(ans+f[(n+k)/2][j][l])%mod;//,cout<<(n+k)/2<<' '<<j<<' '<<l<<':'<<f[(n+k)/2][j][l]<<endl;\n\treturn ans;\n}\nint main() { \n\tint n,k;\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tif(k==1) { printf(\"%d\\n\",solve0(n,3)); return 0; }\n\tif(k%2==0) {\n\t\tk/=2;\n\t\tprintf(\"%d\\n\",(int)(solve0(n/2,k+1)*1ll*solve0((n+1)/2,k+1)%mod));\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",solve1(n,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n,k,p;\nnamespace work1{\n\tint f[155],g[155];\n\tint dp(int n,int k){\n\t\tf[0]=1;\n\t\tg[0]=1;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tf[i]=0;\n\t\t\tfor(int j=1;j<=k && j<=i;++j){\n\t\t\t\t(f[i]+=g[i==j?0:i-j-1])>=p?f[i]-=p:0;\n\t\t}\n\t\t\t(g[i]=f[i]+g[i-1])>=p?g[i]-=p:0;\n\t\t}\n\t\treturn g[n];\n\t}\n}\nnamespace work2{\n\tint f[79],g[79][79],l[79],r[79];\n\tint &add(int &a,int b){return (a+=b)>=p?a-=p:a;}\n\tvoid main(){\n\t\tint m1=n>>1,m2=(n+1)>>1;\n\t\tint w=1;\n\t\tg[0][0]=1;\n\t\tfor(int i=1;i<=m1;++i){\n\t\t\tint x=((i<<1)-k+1);\n\t\t\tif(x<=0)l[i]=0;\n\t\t\telse l[i]=x>>1;\n\t\t\tx=((i<<1)+k+1);\n\t\t\tr[i]=x>>1;\n\t\t\tchkmin(r[i],m2+1);\n\t\t}\n\t\tfor(int i=1;i<=m2;++i){\n\t\t\tg[0][i]=w;\n\t\t\t(w<<=1)>=p?w-=p:0;\n\t\t}\n\t\tfor(int i=1;i<=m1;++i){\n\t\t\tfor(int j=1;j<=i;++j){\n\t\t\t\tfor(int k=0;k<=m2;++k)f[k]=g[j==1?0:j-2][k];\n\t\t\t\tif(l[i]>=r[j]){\n\t\t\t\t\tf[l[i]]=f[r[j]];\n\t\t\t\t\tfor(int k=0;k<l[i];++k)f[k]=0;\n\t\t\t\t\tint w=f[l[i]];\n\t\t\t\t\tfor(int k=l[i]+1;k<=m2;++k){\n\t\t\t\t\t\tf[k]=w;\n\t\t\t\t\t\tadd(w,f[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(r[j]<=m2){\n\t\t\t\t\t\tfor(int k=0;k<l[i];++k)f[k]=0;\n\t\t\t\t\t\tint s=0;\n\t\t\t\t\t\tfor(int k=0;k<=r[j];++k)add(s,f[k]);\n\t\t\t\t\t\tfor(int k=r[j]+1;k<=m2;++k){\n\t\t\t\t\t\t\tf[k]=s;add(s,f[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<=m2;++k)add(g[i][k],f[k]);\n\t\t\t}\n\t\t\tfor(int j=0;j<=m2;++j){\n\t\t\t\tadd(g[i][j],g[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tint s=0;\n\t\tfor(int i=0;i<=m2;++i)(s+=g[m1][i])>=p?s-=p:0;\n\t\twrite(s,'\\n');\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tread(n,k,p);\n\tif(!(k&1)){\n\t\tk>>=1;\t\t\n\t\twrite((ll)work1::dp(n>>1,k)*work1::dp(n-(n>>1),k)%p,'\\n');\n\t}\n\telse{\n\t\twork2::main();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint MOD;\n// modnum {{{\nstruct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nconst int MAXN = 155;\nmn dp[MAXN][MAXN][MAXN],\n   DP[MAXN][MAXN][MAXN];\n\nint N, K;\n\nint cache[MAXN][MAXN];\nint calc(int end, int cont) {\n    int& res = cache[end][cont];\n    if (cache[end][cont] != 0x7f7f7f7f) return res;\n\n    F0R (cent, min(end, cont - 1)) { // center around a top node\n        int topw = 2 * min(cent, end - 1 - cent);\n        int botmax = (K - topw - 1) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 2 - cent;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax + 1); // not inclusive, number of edges it can grow to\n    }\n\n    F0R (cent, min(end - 1, cont - 1)) { // center between top nodes\n        int topw = 1 + 2 * min(cent, end - 1 - cent - 1);\n        int botmax = (K - topw) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 1 - cent - 1;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax); // not inclusive, number of edges it can grow to\n    }\n\n    return min(N, res);\n}\n\nint main() {\n    setIO();\n    memset(cache, 0x7f, sizeof(cache));\n\n    re(N, K, MOD);\n\n    if (K&1) {\n        dp[0][0][N] = 1;\n\n        F0R (i, N) {\n            memset(DP, 0, sizeof(DP));\n\n            F0R (even, (i+1)/2 + 1) {\n                F0R (odd, i/2 + 1) {\n                    F0R (limit, N + 1) {\n                        const mn& ctr = dp[even][odd][limit];\n                        if (!ctr.v) continue;\n\n                        if (i&1) {\n                            DP[even][0][min(odd > even ? INT_MAX : limit, calc(odd, even))] += ctr;\n                            if (odd + 1 <= calc(even, odd + 1) && (odd < even || odd + 1 <= limit))\n                                DP[even][odd+1][limit] += ctr;\n                        } else {\n                            DP[0][odd][min(even > odd ? INT_MAX : limit, calc(even, odd))] += ctr;\n                            if (even + 1 <= calc(odd, even + 1) && (even < odd || even + 1 <= limit))\n                                DP[even+1][odd][limit] += ctr;\n                        }\n                    }\n                }\n            }\n\n            swap(DP, dp);\n        }\n\n        mn ans = 0;\n        F0R (even, N + 1) F0R (odd, N + 1) F0R (limit, N + 1) ans += dp[even][odd][limit];\n        ps(ans);\n    } else {\n        vmn ways((N+1)/2 + 1);\n        ways[0] = 1;\n        FOR (v, 1, sz(ways)) {\n            FOR (i, 0, min(v, K/2) + 1)\n                ways[v] += ways[max(0, v-i-1)];\n        }\n        ps(ways[N/2] * ways[(N+1)/2]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nint const MAXN = 505;\nint n, k, mod;\nint f[MAXN][MAXN], g[MAXN][MAXN][MAXN];\n\nvoid Solve2() {\n  k >>= 1;\n  f[0][0] = 1;\n  for (RI i = 1; i <= n; ++i) {\n    f[i][0] = f[i - 1][0];\n    for (RI j = k; j; --j) {\n      f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod;\n      f[i][0] = (f[i][0] + f[i - 1][j]) % mod;\n    }\n  }\n  int L = 0, R = 0;\n  for (RI i = 0; i <= k; ++i) {\n    L = (L + f[n / 2][i]) % mod;\n    R = (R + f[(n + 1) / 2][i]) % mod;\n  }\n  cout << 1ll * L * R % mod << endl;\n}\n\nvoid Solve1() {\n  g[0][0][0] = 1;\n  for (RI i = 2; i <= k + n; i += 2) {\n    for (RI j = 0; j <= n; ++j)\n      for (RI l = 0; l <= k + 1; ++l)\n        g[i][0][0] = (g[i][0][0] + g[i - 2][j][l]) % mod;\n    if (i <= n) { // only L\n      for (RI j = 1; j <= n; ++j)\n        for (RI l = 0; l <= k + 1; ++l)\n          g[i][j][0] = (g[i][j][0] + g[i - 2][j - 1][l]) % mod;\n    }\n    if (i - k > 0) { // only R\n      for (RI j = 0; j <= n; ++j) {\n        for (RI l = 0; l <= k + 1; ++l)\n          g[i][0][l] = (g[i][0][l] + g[i - 2][j][l - (l > 0)]);\n        g[i][0][1] = 0;\n      }\n    }\n    if (i <= n && i - k > 0) { // L and R\n      for (RI j = 0; j <= k - 1; ++j)\n        for (RI l = 0; l <= k; ++l)\n          (g[i][j + 1][max(j + 2, l + 1)] += g[i - 2][j][l]) %= mod;\n    }\n  }\n  int last = (n + k) - ((n + k) & 1), ans = 0;\n  for (RI i = 0; i <= n; ++i)\n    for (RI j = 0; j <= k + 1; ++j)\n      ans = (ans + g[last][i][j]) % mod;\n  cout << ans << endl;\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  cin >> n >> k >> mod;\n  if (k & 1) Solve1();\n  else Solve2();\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 155;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n\nint f[2][N];\nint g[2][N][N][N];\nint n,K,m;\n\ninline void add(int &x,int y){\n   x += y; if(x >= m)x -= m;\n}\n\nint main(){\n   scanf(\"%d%d%d\",&n,&K,&m);\n   if(K%2 == 0){\n      int ans = 1;\n      fr(t,0,1){\n         int len = (n+t)/2;\n         int cur = 0;\n         memset(f,0,sizeof f);\n         f[0][0] = 1;\n         fr(z,1,len){\n            cur ^= 1;\n            memset(f[cur],0,sizeof f[cur]);\n            fr(j,0,K/2){\n               if(j < K/2)add(f[cur][j+1],f[cur^1][j]);\n               add(f[cur][0],f[cur^1][j]);\n            }\n         }\n         int res = 0;\n         fr(z,0,len)add(res,f[cur][z]);\n         ans = 1LL*ans*res%m;\n      }\n      printf(\"%d\\n\",ans);\n   } else {\n      int cur = 0;\n      g[0][0][0][n] = 1;\n      \n      int ans = 0;\n      fr(i,1,n){\n         cur ^= 1; memset(g[cur],0,sizeof g[cur]);\n         int odd = i/2,even = (i+1)/2;\n         fr(j,0,even){\n            fr(k,0,odd){\n               fr(t,i-1,n){\n                  int to = (t%2 != i%2) ? n : t;\n                  add(g[cur][0][j][to],g[cur^1][j][k][t]);\n                  if(t != i-1){\n                     to = t;\n                     if(j*2 > K)to = min(to,i-k*2+K-1);\n                     add(g[cur][k+1][j][to],g[cur^1][j][k][t]);\n                  }\n               }\n            }\n         }\n      }\n\n      fr(j,0,n){\n         fr(k,0,n){\n            add(ans,g[cur][j][k][n]);\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I need some holiday\n// But I don't wish that everyday is holiday\n// Because I didn't bear the pain\n// Because it wasn't a true freedom\n//         ——『イヤホンと蝉時雨』·Orangestar\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return cur == ed && (ed = (cur = buffer) + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur == ed) ? EOF : *cur++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\nconst int MAXN = 150;\n\nint n, K, MOD;\n\ninline void input()\n{\n\tn = read<int>(), K = read<int>(), MOD = read<int>();\n}\n\n\nnamespace sub0\n{\n\tinline int calc(int N)\n\t{\n\t\tstatic int f[MAXN + 5][MAXN + 5];\n\t\tmemset(f, 0, sizeof f);\n\n\t\tf[0][0] = 1;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tfor(int j = 0; j <= K / 2; ++j) if(f[i][j])\n\t\t\t{\n\t\t\t\t(f[i + 1][j + 1] += f[i][j]) %= MOD;\n\t\t\t\t(f[i + 1][0] += f[i][j]) %= MOD;\n\t\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i <= K / 2; ++i) (ans += f[N][i]) %= MOD;\n\t\treturn ans;\n\t}\n\n\tinline void solve()\n\t{\n\t\tint ans = (LL) calc(n / 2) * calc(n - n / 2) % MOD;\n\t\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n\t}\n}\n\nnamespace sub1\n{\n\tinline void solve()\n\t{\n\t\tstatic int f[MAXN + 5][MAXN + 5][MAXN + 5];\n\n\t\tf[0][0][0] = 1;\n\t\tfor(int i = 0; i < K / 2 + (n + 1) / 2; ++i)\n\t\t\tfor(int j = 0; j <= K + 1; ++j) for(int k = 0; k <= n; ++k) if(f[i][j][k])\n\t\t\t{\n\t\t\t\tint p = (i + 1 - K / 2) * 2 - 1, q = (i + 1) * 2;\n\n\t\t\t\t// 0 0\n\t\t\t\t(f[i + 1][0][0] += f[i][j][k]) %= MOD;\n\n\t\t\t\t// 1 0\n\t\t\t\tif(1 <= p && p <= n)\n\t\t\t\t{\n\t\t\t\t\tif(j > 0) (f[i + 1][j + 1][0] += f[i][j][k]) %= MOD;\n\t\t\t\t\telse (f[i + 1][0][0] += f[i][j][k]) %= MOD;\n\t\t\t\t}\n\n\t\t\t\t// 0 1\n\t\t\t\tif(1 <= q && q <= n) (f[i + 1][0][k + 1] += f[i][j][k]) %= MOD;\n\n\t\t\t\t// 1 1\n\t\t\t\tif(1 <= p && p <= n && 1 <= q && q <= n) (f[i + 1][max(j + 1, k + 2)][k + 1] += f[i][j][k]) %= MOD;\n\t\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i <= K + 1; ++i) for(int j = 0; j <= n; ++j) (ans += f[K / 2 + (n + 1) / 2][i][j]) %= MOD;\n\t\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n\t}\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tif(K % 2 == 0) sub0::solve();\n\telse sub1::solve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 160;\nint mo, n, k;\nint f[N * 2][N][N], o;\n#define add(x, y) ((x) = ((x) + (y)) % mo)\nll solve2() {\n\tf[0][0][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int x = 0; x < i; x++) {\n\t\t\tfor(int y = 0; y < i; y++) if(f[i-1][x][y]) {\n\t\t\t\tfor(int o = 0; o < 2; o++) {\n\t\t\t\t\tint _x = x, _y = y;\n\t\t\t\t\tif (i & 1) {\n\t\t\t\t\t\t_x = o ? x + 1 : 0;\n\t\t\t\t\t\tif (_x * 2 > k) continue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_y = o ? y + 1 : 0;\n\t\t\t\t\t\tif (_y * 2 > k) continue;\n\t\t\t\t\t}\n\t\t\t\t\tadd(f[i][_x][_y], f[i - 1][x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) add(ans, f[n][i][j]);\n\t}\n\treturn ans;\n}\n\nll solve1() {\n\tf[o][0][0] = 1;\n\tint h = (k - 1) / 2, mid = n / 2 - h, t = (n + 1) / 2 - mid;\n\tfor(int i = 1; i <= h; i++) { //only even\n\t\tmemset(f[1 - o], 0, sizeof f[1 - o]);\n\t\tfor(int j = 0; j < i; j++) if (f[o][0][j])\n\t\t\tfor(int oo = 0; oo < 2; oo++) {\n\t\t\t\tadd(f[1 - o][0][oo ? j + 1 : 0], f[o][0][j]);\n\t\t\t}\n\t\to = 1 - o;\t\n\t}\n\tfor(int i = 1; i <= mid + t; i++) { //both\n\t\tmemset(f[1 - o], 0, sizeof f[1 - o]);\n\t\tfor(int j = 0; j <= k + 1; j++) {\n\t\t\tfor(int w = 0; w * 2 <= n; w++) if (f[o][j][w]) {\n\t\t\t\tfor(int o1 = 0; o1 < 2; o1++) {\n\t\t\t\t\tfor(int o2 = 0; o2 < (i > mid ? 1 : 2); o2++) {\n\t\t\t\t\t\tint _w = o2 ? w + 1 : 0;\n\t\t\t\t\t\tint _j = 0;\n\t\t\t\t\t\tif (o1 == 0) _j = 0;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (j) _j = j + 1;\n\t\t\t\t\t\t\tif (o2) _j = max(_j, _w + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_j <= k + 1) {\n\t\t\t\t\t\t\tadd(f[1 - o][_j][_w], f[o][j][w]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = 1 - o;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i <= k + 1; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tadd(ans, f[o][i][j]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n >> k >> mo;\n\tif (k & 1) {\n\t\tcout << solve1() << endl;\n\t} else {\n\t\tcout << solve2() << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 80;\nint p;\nvoid inc(int &x, int y) {(x += y) >= p ? x -= p : 0;};\nint work(int n, int k, int p) {\n    int dp[2][N] {};\n    dp[0][0] = 1;\n    int cur = 0, pre = 1;\n    for (int i = 0; i < n; ++i) {\n        swap(cur, pre);\n        memset(dp[cur], 0, sizeof(dp[cur]));\n        for (int j = 0; j <= k; ++j) {\n            inc(dp[cur][0], dp[pre][j]);\n            if (j < k)\n                inc(dp[cur][j + 1], dp[pre][j]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= k; ++i)\n        inc(ans, dp[cur][i]);\n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k >> p;\n    if (k % 2 == 0) {\n        cout << 1LL * work(n / 2, k / 2, p) * work((n + 1) / 2, k / 2, p) % p << endl;\n        return 0;\n    }\n    int dp[2][N][N][N] {};\n    int m = (n + 1) / 2 + 1;\n    dp[0][0][0][m] = 1;\n    int cur = 0, pre = 1;\n    for (int i = 0; i < n; ++i) {\n        swap(cur, pre);\n        memset(dp[cur], 0, sizeof(dp[cur]));\n        for (int x = 0; x <= (i + 1) / 2; ++x) {\n            for (int y = 0; y <= i / 2; ++y) {\n                for (int z = max(x, y) + 1; z <= m; ++z) {\n                    if (dp[pre][x][y][z] == 0)\n                        continue;\n                    inc(dp[cur][0][x][x > y ? z : m], dp[pre][x][y][z]);\n                    if (2 * x >= k + 1)\n                        inc(dp[cur][y + 1][x][min(z, max(0, x + (k - 2 * y + 1) / 2))], dp[pre][x][y][z]);\n                    else\n                        inc(dp[cur][y + 1][x][z], dp[pre][x][y][z]);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int x = 0; x <= m; ++x)\n        for (int y = 0; y <= m; ++y)\n            for (int z = max(x, y) + 1; z <= m; ++z)\n                inc(ans, dp[cur][x][y][z]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll from[155][155][155];\nll to[155][155][155];\n\nll hoge(int N) {\n\tll from[151]={};\n\tll to[151];\n\t\n\tfrom[0]=1;\n\tint i,j;\n\tFOR(i,N) {\n\t\tZERO(to);\n\t\tFOR(j,K+1) {\n\t\t\t(to[0]+=from[j])%=mo;\n\t\t\tif(j+1<=K) (to[j+1]+=from[j])%=mo;\n\t\t}\n\t\t\n\t\tswap(from,to);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,N+1) ret+=from[i];\n\treturn ret%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tif(K%2==0) {\n\t\tK/=2;\n\t\tcout<<hoge(N/2)*hoge((N+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tfrom[0][1][154]=1;\n\t\tfor(i=2;i<=N+1;i++) {\n\t\t\tZERO(to);\n\t\t\t\n\t\t\tint a,b;\n\t\t\tfor(a=0;a<i;a+=2) for(b=1;b<i;b+=2) for(j=max(a,b);j<=154;j++) if(from[a][b][j]) {\n\t\t\t\tll v=from[a][b][j];\n\t\t\t\t//cout<<i<<\" \"<<a<<\" \"<<b<<\" \"<<j<<\" \"<<v<<endl;\n\t\t\t\tint nex;\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\t// keep\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(b+2+K>=i) nex=154;\n\t\t\t\t\t(to[i][b][nex]+=v)%=mo;\n\t\t\t\t\t\n\t\t\t\t\t// remove\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(b!=i-1 && a==i-2) nex=min({154,j,i+K});\n\t\t\t\t\t(to[a][b][nex]+=v)%=mo;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// keep\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(a+2+K>=i) nex=154;\n\t\t\t\t\t(to[a][i][nex]+=v)%=mo;\n\t\t\t\t\t\n\t\t\t\t\t// remove\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(a!=i-1 && b==i-2) nex=min({154,j,i+K});\n\t\t\t\t\t(to[a][b][nex]+=v)%=mo;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tswap(from,to);\n\t\t}\n\t\t\n\t\tll ret=0;\n\t\tFOR(x,155) FOR(y,155) FOR(j,155) ret+=from[x][y][j];\n\t\tcout<<ret%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct ModInt{\n\tuint a;\n    ModInt(ll x=0):a((x+mod)%mod){}\n\n\tModInt& operator+=(const ModInt &x){\n\t\ta+=x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt &x){\n\t\ta+=mod-x.a;\n\t\tif(a>=mod)a-=mod;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=ull(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\n\nusing mint=ModInt;\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n#define USE_FMT\n//998244353\nconst mint prim_root=3;\n\n/*\n//in-place fft\n//size of input must be a power of 2\nvoid inplace_fmt(vector<mint>&f,const bool inv){\n\tconst int n=f.size();\n\tconst mint root=inv?prim_root.inv():prim_root;\n\tvc<mint> g(n);\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tmint w=root.pow((mint::base-1)/(n/b)),p=1;\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=p;\n\t\t\t\tg[i/2+j]=f[i+j]+f[i+b+j];\n\t\t\t\tg[n/2+i/2+j]=f[i+j]-f[i+b+j];\n\t\t\t}\n\t\t\tp*=w;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tif(inv)rep(i,n)\n\t\tf[i]*=inv[n];\n}*/\n\nstatic const int LG=21;\nmint roots[1<<(LG+1)],iroots[1<<(LG+1)];\nstruct PrepareRoots{\n\tPrepareRoots(){\n\t\trep(w,LG+1){\n\t\t\tconst int s=(1<<w)-1;\n\t\t\tconst mint g=prim_root.pow((mod-1)/(1<<w)),ig=g.inv();\n\t\t\tmint p=1,ip=1;\n\t\t\trep(i,1<<w){\n\t\t\t\troots[s+i]=p;p*=g;\n\t\t\t\tiroots[s+i]=ip;ip*=ig;\n\t\t\t}\n\t\t}\n\t}\n} PrepareRootsDummy;\n\nvoid broken_fmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=n/2;b>=1;b/=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp*roots[b*2-1+j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid broken_ifmt(vc<mint>&f){\n\tconst int n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\trep(j,b){\n\t\t\t\tf[i+j+b]*=iroots[b*2-1+j];\n\t\t\t\tmint tmp=f[i+j]-f[i+j+b];\n\t\t\t\tf[i+j]+=f[i+j+b];\n\t\t\t\tf[i+j+b]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n)\n\t\tf[i]*=invs[n];\n}\n\nvoid inplace_fmt(vector<mint>&f,const bool i){\n\tif(!i)broken_fmt(f);\n\telse broken_ifmt(f);\n}\n\nvc<mint> multiply(vc<mint> x,vc<mint> y,bool same=false){\n\tint n=x.size()+y.size()-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\ty.resize(s);inplace_fmt(y,false);\n\t}else\n\t\ty=x;\n\trep(i,s)\n\t\tx[i]*=y[i];\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\ntemplate<class D>\nstruct Poly:public vc<D>{\n\ttemplate<class...Args>\n\tPoly(Args...args):vc<D>(args...){}\n\tPoly(initializer_list<D>init):vc<D>(all(init)){}\n\tint size()const{\n\t\treturn vc<D>::size();\n\t}\n\tvoid ups(int s){\n\t\tif(size()<s)this->resize(s,0);\n\t}\n\tPoly low(int s)const{\n\t\treturn Poly(this->bg,this->bg+min(max(s,int(1)),size()));\n\t}\n\tPoly rev()const{\n\t\tauto r=*this;\n\t\treverse(all(r));\n\t\treturn r;\n\t}\n\tPoly& operator+=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]+=r[i];\n\t\treturn *this;\n\t}\n\tPoly& operator-=(const Poly&r){\n\t\tups(r.size());\n\t\trep(i,r.size())\n\t\t\t(*this)[i]-=r[i];\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\tPoly& operator*=(T t){\n\t\tfor(auto&v:*this)\n\t\t\tv*=t;\n\t\treturn *this;\n\t}\n\tPoly& operator*=(const Poly&r){\n\t\treturn *this=multiply(*this,r);\n\t}\n\tPoly square()const{\n\t\treturn multiply(*this,*this,true);\n\t}\n\t#ifndef USE_FMT\n\tPoly inv(int s)const{\n\t\tPoly r{1/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=r*2-(r.square()*low(2*n)).low(2*n);\n\t\treturn r.low(s);\n\t}\n\t#else\n\tPoly inv(int s)const{\n\t\tPoly r{D(1)/(*this)[0]};\n\t\tfor(int n=1;n<s;n*=2){\n\t\t\tr.resize(n*4);\n\t\t\tinplace_fmt(r,false);\n\t\t\tvc<D> f=low(2*n);\n\t\t\tf.resize(n*4);\n\t\t\tinplace_fmt(f,false);\n\t\t\trep(i,n*4)\n\t\t\t\tr[i]=r[i]*2-r[i]*r[i]*f[i];\n\t\t\tinplace_fmt(r,true);\n\t\t\tr.resize(2*n);\n\t\t}\n\t\treturn r.low(s);\n\t}\n\t#endif\n\ttemplate<class T>\n\tPoly& operator/=(T t){\n\t\treturn *this*=D(1)/D(t);\n\t}\n\tPoly quotient(const Poly&r,const Poly&rri)const{\n\t\tint m=r.size();\n\t\tassert(r[m-1]);\n\t\tint n=size();\n\t\tint s=n-m+1;\n\t\tif(s<=0) return {0};\n\t\treturn (rev().low(s)*rri.low(s)).low(s).rev();\n\t}\n\tPoly& operator/=(const Poly&r){\n\t\treturn *this=quotient(r,r.rev().inv(max(size()-r.size(),int(0))+1));\n\t}\n\tPoly& operator%=(const Poly&r){\n\t\t*this-=*this/r*r;\n\t\treturn *this=low(r.size()-1);\n\t}\n\tPoly operator+(const Poly&r)const{return Poly(*this)+=r;}\n\tPoly operator-(const Poly&r)const{return Poly(*this)-=r;}\n\ttemplate<class T>\n\tPoly operator*(T t)const{return Poly(*this)*=t;}\n\tPoly operator*(const Poly&r)const{return Poly(*this)*=r;}\n\ttemplate<class T>\n\tPoly operator/(T t)const{return Poly(*this)/=t;}\n\tPoly operator/(const Poly&r)const{return Poly(*this)/=r;}\n\tPoly operator%(const Poly&r)const{return Poly(*this)%=r;}\n\tPoly dif()const{\n\t\tPoly r(max(int(0),size()-1));\n\t\trep(i,r.size())\n\t\t\tr[i]=(*this)[i+1]*(i+1);\n\t\treturn r;\n\t}\n\tPoly inte()const{\n\t\tPoly r(size()+1,0);\n\t\trep(i,size())\n\t\t\tr[i+1]=(*this)[i]*invs[i+1];\n\t\treturn r;\n\t}\n\t//opencupXvcIII GP of Peterhof H\n\tPoly log(int s)const{\n\t\treturn (low(s).dif()*inv(s-1)).low(s-1).inte();\n\t}\n\t//Petrozavodsk 2019w Day1 G\n\tPoly exp(int s)const{\n\t\treturn exp2(s).a;\n\t}\n\tpair<Poly,Poly> exp2(int s)const{\n\t\tassert((*this)[0]==mint(0));\n\t\tPoly f{1},g{1};\n\t\tfor(int n=1;;n*=2){\n\t\t\tif(n>=s)break;\n\t\t\tg=g*2-(g*g*f).low(n);\n\t\t\t//if(n>=s)break;\n\t\t\tPoly q=low(n).dif();\n\t\t\tq=q+g*(f.dif()-f*q).low(2*n-1);\n\t\t\tf=f+(f*(low(2*n)-q.inte())).low(2*n);\n\t\t}\n\t\treturn mp(f.low(s),g.low(s));\n\t}\n\t//CF250 E\n\tPoly sqrt(int s)const{\n\t\tassert((*this)[0]==1);\n\t\tPoly r{1};\n\t\tfor(int n=1;n<s;n*=2)\n\t\t\tr=(r+(r.inv(n*2)*low(n*2)).low(n*2))*inv[2];\n\t\treturn r.low(s);\n\t}\n\tpair<Poly,Poly> divide(const Poly&r,const Poly&rri)const{\n\t\tPoly a=quotient(r,rri);\n\t\tPoly b=*this-a*r;\n\t\treturn mp(a,b.low(r.size()-1));\n\t}\n\t//Yukicoder No.215\n\tPoly pow_mod(int n,const Poly&r)const{\n\t\tPoly rri=r.rev().inv(r.size());\n\t\tPoly cur{1},x=*this%r;\n\t\twhile(n){\n\t\t\tif(n%2)\n\t\t\t\tcur=(cur*x).divide(r,rri).b;\n\t\t\tx=(x*x).divide(r,rri).b;\n\t\t\tn/=2;\n\t\t}\n\t\treturn cur;\n\t}\n\tD eval(D x)const{\n\t\tD r=0,w=1;\n\t\tfor(auto v:*this){\n\t\t\tr+=w*v;\n\t\t\tw*=x;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tPoly<mint> f(n+1);\n\trep(i,n+1)f[i]=mint(n+1-i)*finv[i];\n\t\n\tmint w=f[0];\n\tdmp(f);\n\tf/=w;\n\tauto g=f.log(n+1)*m;\n\tauto h=g.exp(n+1)*w.pow(m);\n\tdmp(h);\n\t\n\tmint ans=0;\n\trep(i,n+1)ans+=h[i]*finv[n-i];\n\t\n\tcout<<(ans*fact[n]).a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=155;\nint n,k,mod;\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\nnamespace Case1 //Even number solver\n{\n\tint f[N][N];\n\tinline int calc(CI n,CI k)\n\t{\n\t\tRI i,j; for (f[0][0]=i=1;i<=n;++i) for (f[i][0]=f[i-1][0],j=1;j<=k;++j)\n\t\tinc(f[i][0],f[i-1][j]),f[i][j]=f[i-1][j-1];\n\t\tint ret=0; for (i=0;i<=k;++i) inc(ret,f[n][i]); return ret;\n\t}\n\tinline void solve(void)\n\t{\n\t\tprintf(\"%d\",1LL*calc(n>>1,k>>1)*calc(n-(n>>1),k>>1)%mod);\n\t}\n};\nnamespace Case2 //Odd number solver\n{\n\tint f[N][N][N],ans;\n\tinline void solve(void)\n\t{\n\t\tRI i,j,p; for (f[0][0][0]=i=1;i<=n;++i)\n\t\t{\n\t\t\tint r=i<<1,l=r-k,fl=1<=l&&l<=n,fr=1<=r&&r<=n;\n\t\t\tfor (j=0;j<=n;++j) for (p=0;p<=k+1;++p)\n\t\t\t{\n\t\t\t\tinc(f[i][0][0],f[i-1][j][p]); if (fr) inc(f[i][j+1][0],f[i-1][j][p]);\n\t\t\t\tif (fl&&p+1<k+2) inc(f[i][0][p?p+1:p],f[i-1][j][p]);\n\t\t\t\tif (fl&&fr&&max(j+2,p+1)<k+2) inc(f[i][j+1][max(j+2,p+1)],f[i-1][j][p]);\n\t\t\t}\n\t\t}\n\t\tfor (i=0;i<=n;++i) for (j=0;j<=k+1;++j)\n\t\tinc(ans,f[n][i][j]); printf(\"%d\",ans);\n\t}\n};\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&mod); if (k&1) Case2::solve();\n\telse Case1::solve(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nint md;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nint n, k;\n\nint main() {\n  cin >> n >> k >> md;\n  if(k % 2 == 0) {\n    k /= 2;\n    vector<int> dp((n + 1) / 2 + 1);\n    dp[0] = 1;\n    range(i, 1, (n + 3) / 2) {\n      husk(j, i - 1, max(i - k - 2, -1)) {\n        add(dp[i], dp[j]);\n      }\n      if(i <= k) add(dp[i], 1);\n    }\n    cout << mul(dp[n / 2], dp[(n + 1) / 2]);\n    return 0;\n  }\n  vector<int> p(n + 1);\n  p[0] = 1;\n  range(i, 1, n + 1) p[i] = mul(p[i - 1], 2);\n  vector<vector<int>> dp((n + 1) / 2 + 1, vector<int>(n / 2 + 1));\n  range(a, 0, (n + 1) / 2 + 1) {\n    range(b, 0, n / 2 + 1) {\n      if(2 * a - 2 < k + 1 || 2 * b - 1 < k) {\n        dp[a][b] = p[a + b];\n        continue;\n      }\n      dp[a][b] = dp[a - 1][b];\n      int sb = 2 * b - 1;\n      int sl = k, sr = 2 * a - 2 - k;\n      if(sl <= sr) {\n        sr = min(sr, sb);\n        add(dp[a][b], p[b - (sr - sl) / 2 - 1]);\n      } else {\n        add(dp[a][b], mul(p[(sl - sr) / 2 + 1] - 1, p[b - 1 - (sl - sr) / 2]));\n      }\n      range(x, 0, a - 1) {\n        int l = 2 * x + 2 + k, r = 2 * a - 2 - k;\n        if(l <= r) {\n          r = min(r, sb);\n          l = min(l, sb + 2);\n          int cnt;\n          if(l > sb) {\n            cnt = 0;\n          } else {\n            cnt = (sb - r) / 2;\n          }\n          add(dp[a][b], mul(dp[x][l / 2], p[cnt]));\n        } else {\n          if(l > sb) {\n            add(dp[a][b], dp[x][b]);\n            continue;\n          }\n          int cur = 0;\n          for(int y = r; y <= l; y += 2) {\n            int res = dp[x][y / 2];\n            sub(res, cur);\n            cur = mul(cur, 2);\n            add(cur, res);\n            add(dp[a][b], mul(res, p[(sb - y) / 2]));\n          }\n        }\n      }\n    }\n  }\n  cout << dp[(n + 1) / 2][n / 2] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 155;\n\nint dp[2][N][N][N];\nint dp2[N][N][N];\n\nint main() {\n\tfast_cin();\n\tint n, k, mod;\n\tcin >> n >> k >> mod;\n\tll ans = 0;\n\tif (k % 2 == 1) {\n\t\tdp[0][n + 1][n + 1][n + 1] = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tmemset(dp[i & 1], 0, sizeof(dp[i & 1]));\n\t\t\tfor (int l_cur = 1; l_cur <= n + 1; ++l_cur) {\n\t\t\t\tfor (int l_other = 1; l_other <= n + 1; ++l_other) {\n\t\t\t\t\tfor (int mx = i; mx <= n + 1; ++mx) {\n\t\t\t\t\t\tint &cur = dp[(i - 1) & 1][l_cur][l_other][mx];\n\t\t\t\t\t\tif (!cur) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mx == n + 1 or mx % 2 != i % 2) {\n\t\t\t\t\t\t\tdp[i & 1][l_other][n + 1][mx] += cur;\n\t\t\t\t\t\t\tdp[i & 1][l_other][n + 1][mx] %= mod;\n\t\t\t\t\t\t\tint new_mx = mx, new_cur = min(l_cur, i);\n\t\t\t\t\t\t\tif (l_other <= i - k) {\n\t\t\t\t\t\t\t\tnew_mx = min(new_mx, new_cur + k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i & 1][l_other][new_cur][new_mx] += cur;\n\t\t\t\t\t\t\tdp[i & 1][l_other][new_cur][new_mx] %= mod;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdp[i & 1][l_other][n + 1][n + 1] += cur;\n\t\t\t\t\t\t\tdp[i & 1][l_other][n + 1][n + 1] %= mod;\n\t\t\t\t\t\t\tif (i < mx) {\n\t\t\t\t\t\t\t\tdp[i & 1][l_other][l_cur][mx] += cur;\n\t\t\t\t\t\t\t\tdp[i & 1][l_other][l_cur][mx] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int l_cur = 1; l_cur <= n + 1; ++l_cur) {\n\t\t\tfor (int l_other = 1; l_other <= n + 1; ++l_other) {\n\t\t\t\tfor (int mx = n; mx <= n + 1; ++mx) {\n\t\t\t\t\tans += dp[n & 1][l_cur][l_other][mx];\n\t\t\t\t\tans %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdp2[0][n + 1][n + 1] = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int l_cur = 1; l_cur <= n + 1; ++l_cur) {\n\t\t\t\tfor (int l_other = 1; l_other <= n + 1; ++l_other) {\n\t\t\t\t\tint &cur = dp2[i - 1][l_cur][l_other];\n\t\t\t\t\tdp2[i][l_other][n + 1] += cur;\n\t\t\t\t\tdp2[i][l_other][n + 1] %= mod;\n\t\t\t\t\tif (i < l_cur + k) {\n\t\t\t\t\t\tdp2[i][l_other][min(l_cur, i)] += cur;\n\t\t\t\t\t\tdp2[i][l_other][min(l_cur, i)] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int l_cur = 1; l_cur <= n + 1; ++l_cur) {\n\t\t\tfor (int l_other = 1; l_other <= n + 1; ++l_other) {\n\t\t\t\tans += dp2[n][l_cur][l_other];\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,K,mod;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\nvoid solve1()\n{\n\tint dp[151][151];\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=1;i<=(n+1)/2;++i)\n\t{\n\t\tfor(int j=0;j<=K/2;++j)add(dp[i][0],dp[i-1][j]);\n\t\tfor(int j=0;j<K/2;++j)add(dp[i][j+1],dp[i-1][j]);\n\t}\n\tint res1=0,res2=0;\n\tfor(int i=0;i<=K/2;++i)add(res1,dp[n/2][i]);\n\tfor(int i=0;i<=K/2;++i)add(res2,dp[(n+1)/2][i]);\n\tprintf(\"%d\",1ll*res1*res2%mod);\n}\nvoid solve2()\n{\n\tint dp[310][80][160];\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0][0]=1;\n\tint lim=(K+1+n)/2;\n\tfor(int i=0;i<lim;++i)\n\t{\n\t\tif(i+1<=(K+1)/2)\n\t\t{\n\t\t\tfor(int j=0;j<=(n+1)/2;++j)\n\t\t\t\tif(dp[i][j][0])\n\t\t\t\t{\n\t\t\t\t\tadd(dp[i+1][j+1][0],dp[i][j][0]);\n\t\t\t\t\tadd(dp[i+1][0][0],dp[i][j][0]);\n\t\t\t\t}\n\t\t}\n\t\telse if(i+1<=(n+1)/2)\n\t\t{\n\t\t\tfor(int j=0;j<=(n+1)/2;++j)\n\t\t\t\tfor(int k=0;k<=K+1;++k)\n\t\t\t\t\tif(dp[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(dp[i+1][0][0],dp[i][j][k]);\n\t\t\t\t\t\tadd(dp[i+1][0][k?k+1:0],dp[i][j][k]);\n\t\t\t\t\t\tadd(dp[i+1][j+1][0],dp[i][j][k]);\n\t\t\t\t\t\tadd(dp[i+1][j+1][max(k?k+1:0,j+2)],dp[i][j][k]);\n\t\t\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint nowlim=i==(n+1)/2?(n+1)/2:0;\n\t\t\tfor(int j=0;j<=nowlim;++j)\n\t\t\t\tfor(int k=0;k<=K+1;++k)\n\t\t\t\t\tif(dp[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(dp[i+1][0][0],dp[i][j][k]);\n\t\t\t\t\t\tadd(dp[i+1][0][k?k+1:0],dp[i][j][k]);\n\t\t\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=(n+1)/2;++j)\n\t\tfor(int k=0;k<=K+1;++k)\n\t\t\tadd(ans,dp[lim][j][k]);\n\tprintf(\"%d\",ans);\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&K,&mod);\n\tif(!(K&1))solve1();\n\telse solve2();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n  int N,K,M;\n  cin>>N>>K>>M;\n  int MMMM;\n  int MMM;\n  int MM;\n  int M;\n   coutjerjlikekj\n     herherw\n     ewhhew\n     oherigihgero\n     ihogerwoihg\n     pijhgrigr\n     cout<<N*K*M;"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint Mod;\ninline int add(int a,int b,const int mod=Mod){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b,const int mod=Mod){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b,const int mod=Mod){return (ll)a*b%mod;}\ninline int qpow(int a,int b,const int mod=Mod)\n{int ret=1;for(;b;b>>=1,a=mul(a,a,mod))if(b&1)ret=mul(ret,a,mod);return ret;}\n/* math */\nvoid upd(int &a,int b){a=add(a,b);}\nconst int N = 210;\nint n,k;\nnamespace solve0{\n\tint f[210][210];\n\tinline void doit(){\n\t\tf[0][0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<=k/2;j++){\n\t\t\t\tf[i][0]=add(f[i][0],f[i-1][j]);\n\t\t\t\tif(j+1<=k/2)f[i][j+1]=add(f[i][j+1],f[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tint a=n/2,b=n-a;\n\t\tint ans1=0,ans2=0;\n\t\tfor(int sz=0;sz<=k/2;sz++){\n\t\t\tans1=add(ans1,f[a][sz]);\n\t\t\tans2=add(ans2,f[b][sz]);\n\t\t}\n\t\tcout << mul(ans1,ans2) << endl;\n\t}\n}\nnamespace solve1{\n\tint f[N*2][N*2][N*2];\n\tvoid doit(){\n\t\tf[0][0][0]=1;\n\t\tfor(int i=1;i<=n+1;i++){\n\t\t\tint r=(i<<1),l=r-k;\n\t\t\tbool fr=(r>=1&&r<=n),fl=(l>=1&&l<=n);\n\t\t\tfor(int j=0;j<=n;j++)for(int p=0;p<=k+1;p++)if(f[i-1][j][p]){\n\t\t\t\tf[i][0][0]=add(f[i][0][0], f[i-1][j][p]);\n\t\t\t\tif(fr)f[i][j+1][0]=add(f[i-1][j][p],f[i][j+1][0]);\n\t\t\t\tif(fl&&p+1<k+2)upd(f[i][0][p?p+1:p],f[i-1][j][p]);\n\t\t\t\tif(fl&&fr&&max(j+2,p+1)<k+2)upd(f[i][j+1][max(p+1,j+2)],f[i-1][j][p]);\n\t\t\t}\n\t\t}\n\t\tcout << f[n+1][0][0] << endl;\n\t}\n}\n\nint main()\n{\n\tcin >> n >> k >> Mod;\n\tif(k%2) {\n\t\tsolve1::doit();\n\t} else {\n\t\tsolve0::doit();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\n\nint n, k;\nu32 P;\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\nu32 sol(int n) {\n\tu32 ans=0, f[80]={};\n\tf[0]=1;\n\tfor(int i=0; i<=n; ++i) {\n\t\tu64 sum=0;\n\t\tfor(int j=0; j<=k; ++j) sum+=f[j];\n\t\tfor(int j=k; j>=1; --j) f[j]=f[j-1];\n\t\tf[0]=sum%P;\n\t}\n\treturn f[0];\n}\nint main() {\n\tstd::cin>>n>>k>>P;\n\tif(k%2==0) {\n\t\tk/=2;\n\t\tstd::cout<<(u64)sol((n+1)/2)*sol(n/2)%P<<\"\\n\";\n\t} else {\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define SZ(x) (int((x).size()))\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\n#define repe(it, x) for (auto it = (x).begin(); it != (x).end(); ++it)\nconst int MAXN = 155;\nlint MOD;\ninline void chkMOD(int & x) {\n\tif (x >= MOD) x -= MOD;\n}\ninline lint calc(int n, int k) {\n\tstatic int dp[MAXN];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0] = 1;\n\trep (i, 0, n - 1) if (dp[i]) {\n\t\trep (j, 1, k) if (i + j <= n) {\n\t\t\tchkMOD(dp[i + j] += dp[i]);\n\t\t}\n\t}\n\tint res = 0;\n\trep (i, 0, n) {\n\t\tif (n - i < k) chkMOD(res += dp[i]);\n\t}\n\treturn res;\n}\ninline void solveEven(int n, int k) {\n\tcout << calc(n / 2, k / 2 + 1) * calc((n + 1) / 2, k / 2 + 1) % MOD << endl;\n}\ninline void solveOdd(int n, int m) {\n\tstatic int dp[MAXN][MAXN][MAXN];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0][0] = 1;\n\trep (i, 0, m / 2 + (n + 1) / 2 - 1) {\n\t\trep (j, 0, n / 2) rep (k, 0, m + 1) {\n\t\t\tchkMOD(dp[i + 1][0][0] += dp[i][j][k]);\n\t\t\tif (i < n / 2) chkMOD(dp[i + 1][j + 1][0] += dp[i][j][k]);\n\t\t\tif (i >= m / 2) chkMOD(dp[i + 1][0][k ? k + 1 : 0] += dp[i][j][k]);\n\t\t\tif (i < n / 2 && i >= m / 2) chkMOD(dp[i + 1][j + 1][max(j + 2, k + 1)] += dp[i][j][k]);\n\t\t}\n\t}\n\tint res = 0;\n\trep (j, 0, n / 2) rep (k, 0, m + 1) {\n\t\tchkMOD(res += dp[m / 2 + (n + 1) / 2][j][k]);\n\t}\n\tcout << res << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n, k;\n\tcin >> n >> k >> MOD;\n\tif (k & 1) {\n\t\tsolveOdd(n, k);\n\t} else {\n\t\tsolveEven(n, k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N = 153; \nint P;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a, int b) { a = add(a, b); } \n\nint n, k;\n\nnamespace Even { \n\tint f[N][N], g[N]; \n\tvoid solve() {\n\t\tf[0][0] = 1; \n\t\tint l = k / 2;\n\t\tlop(i, 0, n) rep(j, 0, l) {\n\t\t\tupd(f[i + 1][0], f[i][j]); \n\t\t\tif (j + 1 <= l) upd(f[i + 1][j + 1], f[i][j]);; \n\t\t}\n\t\trep(i, 1, n) rep(j, 0, l) upd(g[i], f[i][j]); \n\t\tcout << mul(g[n / 2], g[(n + 1) / 2]) << endl;\n\t}\n}\n\nnamespace Odd {\n\tint f[2][N][N][N], ans; \n\tvoid solve() {\n\t\tf[1][1][0][n] = 1;\n\t\trep(i, 1, n) {\n\t\t\tint ii = i & 1, ni = ii ^ 1;\n\t\t\tmem(f[ni], 0);\n\t\t\trep(x, 1, n) rep(y, 0, n) rep(t, 0, n) if (f[ii][x][y][t]) {\n\t\t\t \tif (2 * x - 3 >= k) { //loop start with the same parity as i\n\t\t\t \t\tif (t) {\n\t\t\t \t\t\tint nt = min(t - 1, y ? (k - 2 * y - 1) / 2 : n);\n\t\t\t \t\t\tupd(f[ni][y + 1][x][nt], f[ii][x][y][t]);\n\t\t\t \t\t}\n\t\t\t \t\tupd(f[ni][y + 1][0][n], f[ii][x][y][t]);\n\t\t\t \t} else {\n\t\t\t \t\tint nx = y + 1, nt = t, ny = x;\n\t\t\t \t\tif (nx * 2 - 3 >= k) nt = min(nt, (k - 2 * ny + 1) / 2); \n\t\t\t \t\tupd(f[ni][y + 1][x][nt], f[ii][x][y][t]); \n\t\t\t \t\tupd(f[ni][y + 1][0][t], f[ii][x][y][t]); \n\t\t\t \t}\n\t\t\t }\n\t\t}\n\t\trep(x, 1, n) rep(y, 0, n) rep(t, 0, n) upd(ans, f[(n + 1) & 1][x][y][t]); \n\t\tcout << ans << endl;\n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tcin >> n >> k >> P;\n\tif (k % 2 == 0) {\n\t\tEven::solve(); \n\t\treturn 0; \n\t}\n\tOdd::solve(); \n\treturn 0; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,k,m;\n\nint s1(int n,int k)\n{\n\tstatic int f[155];\n\tf[0] = 1;\n\tfor(int i = 1;i <= n + 1; ++ i)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tif(i - j - 1 >= 0)\n\t\t\t\tf[i] = (f[i] + f[i - j - 1]) % m;\n\t}\n\treturn f[n + 1];\n}\n\nint s2(int n,int k)\n{\n\tstatic int f[155][155][155];\n\tstatic int typ[155];\n\tint tot = 0;\n\tfor(int i = 1;i * 2 - k <= n; ++ i)\n\t{\n\t\ttot ++;\n\t\tif(i * 2 <= n) typ[tot] |= 2;\n\t\tif(i * 2 - k > 0) typ[tot] |= 1;\n\t}\n\tf[0][0][0] = 1;\n\tfor(int i = 1;i <= tot; ++ i)\n\t\tfor(int j = 0;j <= k + 1; ++ j)\n\t\t\tfor(int l = 0;l <= i; ++ l)\n\t\t\t\tif(f[i - 1][j][l])\n\t\t\t\t{\n\t\t\t\t\t//×óÓÒ¾ù²»Ñ¡\n\t\t\t\t\tf[i][0][0] = (f[i][0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡×ó²»Ñ¡ÓÒ\n\t\t\t\t\tif(typ[i] & 1)\n\t\t\t\t\t\tf[i][j ? j + 1 : 0][0] = (f[i][j ? j + 1 : 0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡ÓÒ²»Ñ¡×ó\n\t\t\t\t\tif(typ[i] & 2)\n\t\t\t\t\t\tf[i][0][l + 1] = (f[i][0][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t\tif(typ[i] == 3)\n\t\t\t\t\t\tf[i][j ? j + 1 : l + 2][l + 1] = (f[i][j ? j + 1 : l + 2][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t}\n\tint as = 0;\n\tfor(int i = 0;i <= k + 1; ++ i)\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tas = (as + f[tot][i][j]) % m;\n\treturn as;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&m);\n\tif(k % 2 == 0)\n\t{\n\t\tprintf(\"%lld\\n\",(s1(n / 2,k / 2) * 1ll * s1((n + 1) / 2,k / 2)) % m);\n\t}\n\telse printf(\"%d\\n\",s2(n,k));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (233)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,K,P;\nint solve(int n,int K){\n\tint f[N][N],ans=0; memset(f,0,sizeof(f)); f[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<=K;j++)\n\t(f[i+1][0]+=f[i][j])%=P,(f[i+1][j+1]+=f[i][j])%=P;\n\tfor(int i=0;i<=K;i++)(ans+=f[n][i])%=P; return ans;\n}\nint main(){\n\tread(n),read(K),read(P);\n\tif(K&1){\n\t\tint f[N][N][N]; memset(f,0,sizeof(f));\n\t\tf[0][0][0]=1;\n\t\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\tfor(int k=0,tmp;k<=K+1;k++)\n\t\tif(f[i-1][j][k]){\n\t\t\t(f[i][0][0]+=f[i-1][j][k])%=P;\n\t\t\tif(i*2<=n)(f[i][j+1][0]+=f[i-1][j][k])%=P;\n\t\t\tif(i*2-K>0&&i*2-K<=n&&k+1<K+2)(f[i][0][k?k+1:0]+=f[i-1][j][k])%=P;\n            if(i*2-K>0&&i*2<=n&&(tmp=max(j+2,k+1))<K+2)(f[i][j+1][tmp]+=f[i-1][j][k])%=P;\n\t\t}\n\t\tprintf(\"%d\\n\",f[n+1][0][0]);\n\t}\n\telse printf(\"%lld\\n\",1ll*solve(n/2,K/2)*solve((n+1)/2,K/2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\nint n, K, Mod;\nint D[88][88][200], T[88][88][200];\nvoid Do(int cur) {\n\tint i, j, k;\n\tfor (i = 0; i < 80; i++)for (j = 0; j < 80; j++)for (k = 0; k < 160; k++)T[i][j][k] = 0;\n\tfor (i = 0; i < 80; i++) {\n\t\tfor (j = 0; j < 80; j++) {\n\t\t\tfor (k = 0; k < 160; k++) {\n\t\t\t\tif (!D[i][j][k])continue;\n\t\t\t\tif (!(cur & 1)) {\n\t\t\t\t\tif (k != 157 && cur % 2 != k % 2) {\n\t\t\t\t\t\tT[0][j][k] = (T[0][j][k] + D[i][j][k]) % Mod;\n\t\t\t\t\t}\n\t\t\t\t\telse T[0][j][157] = (T[0][j][157] + D[i][j][k]) % Mod;\n\n\t\t\t\t\tint nk = k;\n\t\t\t\t\tint ni = min(i + 1, K + 1);\n\t\t\t\t\tif (j >= ni) {\n\t\t\t\t\t\tint needed = ((K + 2) - (ni + ni + 1)) / 2;\n\t\t\t\t\t\tif (j >= needed + ni) {\n\t\t\t\t\t\t\tnk = min(nk, needed * 2 + cur + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (nk <= cur) {\n\t\t\t\t\t\tint z = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tT[ni][j][nk] = (T[ni][j][nk] + D[i][j][k]) % Mod;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tif (k != 157 && cur % 2 != k % 2) {\n\t\t\t\t\t\tT[i][0][k] = (T[i][0][k] + D[i][j][k]) % Mod;\n\t\t\t\t\t}\n\t\t\t\t\telse T[i][0][157] = (T[i][0][157] + D[i][j][k]) % Mod;\n\n\t\t\t\t\tint nk = k;\n\t\t\t\t\tint nj = min(j + 1, K + 1);\n\t\t\t\t\tif (i >= nj) {\n\t\t\t\t\t\tint needed = ((K + 2) - (nj + nj + 1)) / 2;\n\t\t\t\t\t\tif (i >= needed + nj) {\n\t\t\t\t\t\t\tnk = min(nk, needed * 2 + cur + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (nk <= cur) {\n\t\t\t\t\t\tint z = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tT[i][nj][nk] = (T[i][nj][nk] + D[i][j][k]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < 80; i++)for (j = 0; j < 80; j++)for (k = 0; k < 160; k++)D[i][j][k] = T[i][j][k];\n}\nint DP[160][90][90];\nint main() {\n\tint i, j, k;\n\tscanf(\"%d%d%d\", &n, &K, &Mod);\n\tif (K % 2 == 1) {\n\t\tD[0][0][157] = 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tDo(i);\n\t\t}\n\t\tint res = 0;\n\t\tfor (i = 0; i < 80; i++)for (j = 0; j < 80; j++)for (k = 0; k < 160; k++)res = (res + D[i][j][k]) % Mod;\n\t\tprintf(\"%d\\n\", res);\n\t\treturn 0;\n\t}\n\tDP[0][0][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j <= n / 2; j++) {\n\t\t\tfor (k = 0; k <= n / 2; k++) {\n\t\t\t\tif (!DP[i - 1][j][k])continue;\n\t\t\t\tif (i % 2) {\n\t\t\t\t\tDP[i][0][k] = (DP[i][0][k] + DP[i - 1][j][k]) % Mod;\n\t\t\t\t\tif (j + 1 <= K/2)DP[i][j + 1][k] = (DP[i][j + 1][k] + DP[i - 1][j][k]) % Mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tDP[i][j][0] = (DP[i][j][0] + DP[i - 1][j][k]) % Mod;\n\t\t\t\t\tif (k + 1 <= K/2)DP[i][j][k + 1] = (DP[i][j][k + 1] + DP[i - 1][j][k]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i <= n / 2 + 1; i++)for (j = 0; j <= n / 2 + 1; j++)res = (res + DP[n][i][j]) % Mod;\n\tprintf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 160;\nint f[N][N], n, k, m, g[N<<1][N][N];\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\nvoid mo(int & x) { if(x > m) x -= m; }\nvoid solve1() {\n    k /= 2; f[0][0] = 1;\n    FOR(i, 1, n) {\n        FOR(j, 0, k) mo(f[i][0] += f[i - 1][j]);\n        FOR(j, 0, k - 1) mo(f[i][j + 1] += f[i - 1][j]);\n    }\n    int ans1 = 0, ans2 = 0;\n    FOR(i, 0, k) mo(ans1 += f[n / 2][i]);\n    FOR(i, 0, k) mo(ans2 += f[(n + 1) / 2][i]);\n    int ans = 1ll * ans1 * ans2 % m;\n    printf(\"%d\\n\", ans);\n}\nvoid solve2() {\n    g[0][0][0] = 1; int p = 0;\n    for(int i = 2; i - k <= n; i += 2) {\n        FOR(j, 0, n) \n            FOR(d, 0, k + 1) mo(g[i][0][0] += g[i - 2][j][d]);\n        if(i <= n) FOR(j, 0, n) \n            FOR(d, 0, k + 1) mo(g[i][j + 1][0] += g[i - 2][j][d]);\n        if(i - k >= 1) FOR(j, 0, n) {\n            FOR(d, 1, k) mo(g[i][0][d + 1] += g[i - 2][j][d]);\n            mo(g[i][0][0] += g[i - 2][j][0]);\n        }\n        if(i <= n && i - k >= 1) FOR(j, 0, n)\n            for(int d = 0; max(d, j + 1) <= k; ++d)\n                mo(g[i][j + 1][max(d + 1, j + 2)] += g[i - 2][j][d]);\n        p = i;\n    }\n    int ans = 0;\n    FOR(j, 0, n)\n        FOR(d, 0, k + 1) mo(ans += g[p][j][d]);\n    printf(\"%d\\n\", ans);\n}\nint main() {\n    scanf(\"%d %d %d\", &n, &k, &m);\n    if(k & 1) solve2();\n    else solve1();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 80\n#define ll long long\nint p;\ninline void add(int&x,int y){if((x+=y)>=p)x-=p;}\ninline int min(int x,int y){return x<y?x:y;}\nint f[2][N][N][N],i,j,k,l;\ninline int _a(int n,int m)\n{\n    for(f[0][0][0][n+3>>1]=i=1;i<=n;i++)for(j=0;j<=i>>1;j++)\n    {\n        for(k=0;k<j;k++)for(l=i>>1;l<=n+2>>1;f[i&1^1][j][k][l++]=0)\n        if(i&1)add(f[1][i+1>>1][k][l],f[0][j][k][l]),add(f[1][j][k][k<i-m>>1?min((j<<1|1)+m>>1,l):l],f[0][j][k][l]);\n        else\n        {\n            add(f[0][j][i>>1][n+3>>1],f[1][j][k][l]);\n            if(i>>1<l)add(f[0][j][k][l],f[1][j][k][l]);\n        }\n        for(k=j;k<i+1>>1;k++)for(l=i>>1;l<=n+3>>1;f[i&1^1][j][k][l++]=0)\n        if(i&1)\n        {\n            add(f[1][i+1>>1][k][n+2>>1],f[0][j][k][l]);\n            if(i+1>>1<l)add(f[1][j][k][l],f[0][j][k][l]);\n        }\n        else add(f[0][j][i>>1][l],f[1][j][k][l]),add(f[0][j][k][j<i-m+1>>1?min(l,(k+1<<1)+m+1>>1):l],f[1][j][k][l]);\n    }\n    for(i=k=0;i<=n+1>>1;i++)for(j=0;j<i;j++)add(k,f[n&1][i][j][n+2>>1]);\n    for(i=0;i<=n+1>>1;i++)for(j=i;j<=n>>1;j++)add(k,f[n&1][i][j][n+3>>1]);\n    return k;\n}\nint g[N];\ninline int _b(int n,int m)\n{\n    for(*g=i=1;i<=m;i++)g[i]=0;\n    for(i=0;i<=n;i++)\n    {\n        for(j=m+1;j--;)g[j+1]=g[j];\n        for(*g=j=0;j++<=m;)add(*g,g[j]);\n    }\n    return *g;\n}\nint m,n;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&p),printf(\"%d\\n\",m&1?_a(n,m):(ll)_b(n>>1,m>>1)*_b(n+1>>1,m>>1)%p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=155;\nint read(){\n    int f=1,g=0;char ch=getchar();\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n    for (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n    return f*g;\n}\nint K,n,p;\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\nvoid solve1(){\n\tstatic int f[N][N];\n\tf[0][0]=1;K/=2;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<=K;j++){\n\t\tcheck(f[i][0],f[i-1][j]);\n\t\tif (j!=K) check(f[i][j+1],f[i-1][j]);\n\t}\n\tint x=0,y=0;\n\tfor (int i=0;i<=K;i++)\n\tcheck(x,f[n/2][i]),check(y,f[n-n/2][i]);\n\tprintf(\"%lld\\n\",(ll)x*y%p);\n}\nvoid solve2(){\n\tstatic int f[N][N][N];\n\tint i;f[0][0][0]=1;\n\tfor (i=1;i*2-K<=n;i++){\n\t\tfor (int j=0;j<=K+1;j++)\n\t\tfor (int k=0;k<=i;k++)\n\t\tcheck(f[i][0][0],f[i-1][j][k]);\n\t\tif (i*2<=n)\n\t\t\tfor (int j=0;j<=K+1;j++)\n\t\t\tfor (int k=0;k<=i;k++)\n\t\t\tcheck(f[i][0][k+1],f[i-1][j][k]);\n\t\tif (i*2-K>0){\n\t\t\tfor (int j=1;j<=K;j++)\n\t\t\tfor (int k=0;k<=i;k++)\n\t\t\tcheck(f[i][j+1][0],f[i-1][j][k]);\n\t\t\tfor (int k=0;k<=i;k++) check(f[i][0][0],f[i-1][0][k]);\n\t\t}\n\t\tif ((i*2<=n)&&(i*2-K>0)){\n\t\t\tfor (int j=0;j<=K;j++)\n\t\t\tfor (int k=0;k+1<=K;k++)\n\t\t\tcheck(f[i][max(j+1,k+2)][k+1],f[i-1][j][k]);\n\t\t}\n\t}\n\ti--;\n\tint ans=0;\n\tfor (int j=0;j<=K+1;j++)\n\tfor (int k=0;k<=i;k++)\n\tcheck(ans,f[i][j][k]);\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tn=read();K=read();p=read();\n\tif (K&1) solve2();\n\telse solve1();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=155;\nint n,K,mod;\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nint dp[N][N][N];\npair <int,int> p[N];\nnamespace so1{\n\tint dp[N];\n\tvoid Solve(){\n\t\tdp[0]=1;\n\t\tFor(i,1,n+1){\n\t\t\tFor(j,max(i-K/2-1,0),i-1)\n\t\t\t\tAdd(dp[i],dp[j]);\n\t\t}\n\t\tcout<<(LL)dp[n/2+1]*dp[(n+1)/2+1]%mod<<endl;\n\t}\n}\nint main(){\n\tn=read(),K=read(),mod=read();\n\tif (K%2==0)\n\t\treturn so1::Solve(),0;\n\tFor(i,1,n/2)\n\t\tp[i].se=i*2;\n\tFor(i,1,(n+1)/2)\n\t\tp[i+(K-1)/2].fi=i*2-1;\n\tint m=(n+1)/2+(K-1)/2;\n\tdp[0][0][0]=1;\n\tFor(i,1,m)\n\t\tFor(j,0,n)\n\t\t\tFor(k,0,n){\n\t\t\t\tint v=dp[i-1][j][k];\n\t\t\t\tif (!v||j>=K+2)\n\t\t\t\t\tcontinue;\n\t\t\t\tAdd(dp[i][0][0],v);\n\t\t\t\tif (p[i].fi){\n\t\t\t\t\tif (j>0)\n\t\t\t\t\t\tAdd(dp[i][j+1][0],v);\n\t\t\t\t\telse\n\t\t\t\t\t\tAdd(dp[i][0][0],v);\n\t\t\t\t}\n\t\t\t\tif (p[i].se)\n\t\t\t\t\tAdd(dp[i][0][k+1],v);\n\t\t\t\tif (p[i].fi&&p[i].se)\n\t\t\t\t\tAdd(dp[i][max(j+1,k+2)][k+1],v);\n\t\t\t}\n\tint ans=0;\n\tFor(i,0,n)\n\t\tFor(j,0,n)\n\t\t\tif (i<K+2)\n\t\t\t\tAdd(ans,dp[m][i][j]);\n\tcout<<ans<<endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nint P;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 157;\nint n, K;\nmodint f[N][N], g[N][N][N], ans, ans0, ans1;\n\nint main() {\n\trd(n, K, P);\n\tif (K & 1) {\n\t\tg[0][0][0] = 1;\n\t\tint m = (K >> 1) + ((n + 1) >> 1);\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = 0; j <= n >> 1; j++)\n\t\t\t\tfor (int k = 0; k <= K + 1; k++) {\n\t\t\t\t\tg[i+1][0][0] += g[i][j][k];\n\t\t\t\t\tif (i < n >> 1) g[i+1][j+1][0] += g[i][j][k];\n\t\t\t\t\tif (i >= K >> 1) g[i+1][0][k?k+1:0] += g[i][j][k];\n\t\t\t\t\tif (i >= (K >> 1) && i < (n >> 1)) g[i+1][j+1][max(j+2,k+1)] += g[i][j][k];\n\t\t\t\t}\n\t\tfor (int j = 0; j <= n >> 1; j++)\n\t\t\tfor (int k = 0; k <= K + 1; k++)\n\t\t\t\tans += g[m][j][k];\n\t\tprint(ans);\n\t} else {\n\t\tf[0][0] = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j <= min(i, K >> 1); j++)\n\t\t\t\tf[i+1][j+1] += f[i][j], f[i+1][0] += f[i][j];\n\t\tfor (int j = 0; j <= K >> 1; j++)\n\t\t\tans0 += f[n>>1][j], ans1 += f[(n+1)>>1][j];\n\t\tprint(ans0 * ans1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint n, k, m;\n\nInt dp[165][165][165];\n\nbool between(int a, int b, int c){\n    return a < b && b < c;\n}\n\nint main(){\n    cin >> n >> k >> m;\n    if(k % 2 == 0){\n        vector<Int> dp(n+1, 0);\n        dp[0] = 1;\n        for(int i = 1;i <= n;i++){\n            for(int j = max(0, i - k/2-1);j < i;j++){\n                dp[i] += dp[j];\n                dp[i] %= m;\n            }\n        }\n        cout << dp[n/2 + 1] * dp[n-n/2 + 1] % m << endl;\n    }\n    else{\n        int goal = n+3;\n        n+=10;\n        dp[0][2][1] = 1;\n        for(int a = 0;a <= n;a++){\n            for(int b = a+2;b <= n;b+=2){\n                for(int c = !(a%2);c < b;c+=2){\n                    for(int d = c+2;d <= n;d+=2){\n                        if(d-2 > c && between(a, d-2-k, b) && between(a, d-2+k, b))break;\n                        if(d-2 > c && b-2 > a&& between(a, d-2-k, b) && between(c, b-2-k ,d))break;\n                        \n                        if(b > d)(dp[a][b][d] += dp[a][b][c]) %= m;\n                        else (dp[c][d][b] += dp[a][b][c])%= m;\n                    }\n                }\n            }\n        }\n        cout << dp[goal][goal+2][goal+1] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=150;\nconst int MAXH=MAXN/2;\n\nint n,k,mod;\nvoid inc(int &a,int b) { if((a+=b)>=mod) a-=mod; }\n\nint dp[MAXH+1][MAXN+1][2][MAXH+1]; // dp[a][b][par][c] = ways to get to state with last b removed, length of alternating removed sequence before that is a and needing at least one of the next c with given parity to stay (c==0 -> no constraint)\nint ndp[MAXH+1][MAXN+1][2][MAXH+1];\n\nbool havecycle(int a,int b) {\n\tif(k%2==0) {\n\t\tint have=(b+1)/2+(b%2==1?a:0);\n\t\treturn have>=k/2+1;\n\t} else {\n\t\treturn b>=k+2;\n\t}\n}\n\nint solve() {\n\tmemset(dp,0,sizeof(dp));\n\tinc(dp[0][0][0][0],1);\n\tREP(i,n) {\n\t\tmemset(ndp,0,sizeof(ndp));\n\t\tfor(int a=0;2*a<=i;++a) for(int b=0;2*a+b<=i;++b) REP(par,2) for(int c=0;c<=(par==0?(n-i+1)/2:(n-i)/2);++c) if(dp[a][b][par][c]!=0) {\n\t\t\tassert(par==0||c>=1);\n\t\t\t// remove it\n\t\t\tif(!(par==0&&c==1)) {\n\t\t\t\tif(!havecycle(a,b+1)) inc(ndp[a][b+1][c==0?0:1-par][c==0?0:par==0?c-1:c],dp[a][b][par][c]); //else printf(\"x %d(%d,%d,%d,%d)=%d\\n\",i,a,b,par,c,dp[a][b][par][c]);\n\t\t\t} else {\n\t\t\t\t//printf(\"y %d(%d,%d,%d,%d)=%d\\n\",i,a,b,par,c,dp[a][b][par][c]);\n\t\t\t}\n\t\t\t// keep it\n\t\t\t{\n\t\t\t\tif(b==0) { inc(ndp[0][0][0][0],dp[a][b][par][c]); continue; }\n\t\t\t\tint na=(b+1)/2+(b%2==1?a:0);\n\t\t\t\tif(k%2==0) {\n\t\t\t\t\tif(!havecycle(na,0)) inc(ndp[na][0][0][par==0?0:c],dp[a][b][par][c]);\n\t\t\t\t}\n\t\t\t\tif(k%2==1) {\n\t\t\t\t\tif(b%2==0||b==1) inc(ndp[na][0][0][par==0?0:c],dp[a][b][par][c]);\n\t\t\t\t\tif(b%2==1&&b!=1) {\n\t\t\t\t\t\tint need=(k+2-b)/2; assert(need>0); if(i+2*need-1>=n) need=0;\n\t\t\t\t\t\t//if(a==1&&b==3&&i==5) printf(\"need=%d (%d)\\n\",need,(k+2-b)/2);\n\t\t\t\t\t\tif(a<need) inc(ndp[na][0][0][par==0?0:c],dp[a][b][par][c]);\n\t\t\t\t\t\tif(a>=need) inc(ndp[na][0][0][par==0?need:need==0?c:min(need,c)],dp[a][b][par][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int a=0;2*a<=i+1;++a) for(int b=0;2*a+b<=i+1;++b) REP(par,2) for(int c=0;c<=(par==0?(n-(i+1)+1)/2:(n-(i+1))/2);++c) dp[a][b][par][c]=ndp[a][b][par][c];\n\t\t//for(int a=0;2*a<=i+1;++a) for(int b=0;2*a+b<=i+1;++b) REP(par,2) for(int c=0;c<=(par==0?(n-(i+1)+1)/2:(n-(i+1))/2);++c) if(dp[a][b][par][c]!=0) printf(\"after %d: (%d,%d,%d,%d)=%d\\n\",i+1,a,b,par,c,dp[a][b][par][c]);\n\t}\n\tint ret=0;\n\tfor(int a=0;2*a<=n;++a) for(int b=0;2*a+b<=n;++b) REP(par,2) for(int c=0;c<=(par==0?(n-n+1)/2:(n-n)/2);++c) inc(ret,dp[a][b][par][c]);\n\n\t//REP(a,10) REP(b,10) if(havecycle(a,b)) { printf(\"(%d,%d)\\n\",a,b); break; }\n\treturn ret;\n}\n\nbool isset(int mask,int bit) { return (mask&(1<<bit))!=0; }\nint solvestupid() {\n\tint ret=0;\n\tREP(mask,1<<n) {\n\t\tbool ok=true;\n\t\tif(k%2==0) {\n\t\t}\n\t\tif(k%2==1) {\n\t\t\tfor(int b=3;b<=k+2;b+=2) {\n\t\t\t\tint a=(k+2-b)/2;\n\t\t\t\tint len=4*a+b;\n\t\t\t\tREPE(off,n-len) {\n\t\t\t\t\tbool match=true;\n\t\t\t\t\tREP(i,a) if(!isset(mask,off+2*i)) match=false;\n\t\t\t\t\tREP(i,b) if(!isset(mask,off+2*a+i)) match=false;\n\t\t\t\t\tREP(i,a) if(!isset(mask,off+2*a+b+1+2*i)) match=false;\n\t\t\t\t\tif(match) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) ++ret;\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tprintf(\"%d\\n\",solve());\n\t//if(n<=20) printf(\"%d\\n\",solvestupid());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint n,K,mod;\nvoid upd(int&a,int b){\n\ta=(a+b)%mod;\n}\nint main(){\n\tread(n);read(K);read(mod);\n\tif(~K&1){\n\t\tint f[210][210]={};\n\t\tf[1][0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tupd(f[i+1][0],f[i][j]);\n\t\t\t\tif(j+1<=K/2) upd(f[i+1][j+1],f[i][j]);\n\t\t\t}\n\t\tint now1=0,now2=0;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tupd(now1,f[n/2+1][i]),upd(now2,f[n-n/2+1][i]);\n\t\tcout<<(1ll*now1*now2)%mod<<'\\n';\n\t}\n\telse{\n\t\tmap<pair<int,int>,int> f[160][160][160];\n\t\tf[1][0][0][make_pair(n+1,n+1)]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t\tfor(int k=0;k<=i;k++)\n\t\t\t\t\tif(f[i][j][k].size()){\n\t\t\t\t\t\tfor(auto&pr:f[i][j][k]){\n\t\t\t\t\t\t\tint p=pr.first.first,q=pr.first.second;\n\t\t\t\t\t\t\tint tmp=pr.second;\n\t\t\t\t\t\t\tif(i&1){\n\t\t\t\t\t\t\t\tupd(f[i+1][0][k][make_pair(n+1,q)],tmp);\n\t\t\t\t\t\t\t\tif(i<p){\n\t\t\t\t\t\t\t\t\tint lim=q;\n\t\t\t\t\t\t\t\t\tif(i-2*k+1<=i-K) lim=min(lim,i-2*j+K);\n\t\t\t\t\t\t\t\t\tupd(f[i+1][j+1][k][make_pair(p,lim)],tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tupd(f[i+1][j][0][make_pair(p,n+1)],tmp);\n\t\t\t\t\t\t\t\tif(i<q){\n\t\t\t\t\t\t\t\t\tint lim=p;\n\t\t\t\t\t\t\t\t\tif(i-2*j+1<=i-K) lim=min(lim,i-2*k+K);\n\t\t\t\t\t\t\t\t\tupd(f[i+1][j][k+1][make_pair(lim,q)],tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tll ans=0;\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\tfor(auto pr:f[n+1][j][k]) ans=(ans+pr.second)%mod;\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nint P;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=155;\nint n,p;\ninline int max(R int x,R int y){return x>y?x:y;}\nint solve(int n,int p){\n\tstatic int f[N][N];memset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tfp(i,0,n-1)fp(j,0,p)if(f[i][j])upd(f[i+1][0],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n\tR int res=0;fp(i,0,p)upd(res,f[n][i]);\n\treturn res;\n}\nint f[N][N][N];\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&p,&P);\n\tif(p&1^1)return printf(\"%d\\n\",mul(solve(n>>1,p>>1),solve((n+1)>>1,p>>1))),0;\n\tf[0][0][0]=1;\n\tfp(i,1,n+1){\n\t\tR int r=(i<<1),l=r-p;\n\t\tR bool fr=(r>=1&&r<=n),fl=(l>=1&&l<=n);\n\t\tfp(j,0,n)fp(k,0,p)if(f[i-1][j][k]){\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,k);\n\t\t\tupd(f[i][0][0],f[i-1][j][k]);\n\t\t\tif(fr)upd(f[i][j+1][0],f[i-1][j][k]);\n\t\t\tif(fl)upd(f[i][0][k?k+1:k],f[i-1][j][k]);\n\t\t\tif(fl&&fr)upd(f[i][j+1][max(k+1,j+1)],f[i-1][j][k]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n+1][0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\nconst int maxn=155;\nint n,m,mod;\nnamespace subtask1\n{\n\tmap<pii,int> f[maxn][maxn][maxn];\n\tinline void solve()\n\t{\n\t\tf[0][0][0][pii(n+1,n+1)]=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t\tfor(auto it:f[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tint p=it.fi.fi,q=it.fi.se,val=it.se;\n\t\t\t\t\t\tif(!(i&1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(f[i+1][0][k][pii(n+1,q)]+=val)%=mod;\n\t\t\t\t\t\t\tif(p>i+1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(i+2-2*k+m<=i+1 && i+1-2*j+m>i)\n\t\t\t\t\t\t\t\t\t(f[i+1][j+1][k][pii(p,min(q,i+1-2*j+m))]+=val)%=mod;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t(f[i+1][j+1][k][pii(p,q)]+=val)%=mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(f[i+1][j][0][pii(p,n+1)]+=val)%=mod;\n\t\t\t\t\t\t\tif(q>i+1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(i+2-2*j+m<=i+1 && i+1-2*k+m>i)\n\t\t\t\t\t\t\t\t\t(f[i+1][j][k+1][pii(min(p,i+1-2*k+m),q)]+=val)%=mod;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t(f[i+1][j][k+1][pii(p,q)]+=val)%=mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tint res=0;\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\tfor(auto it:f[n][j][k])\n\t\t\t\t\t(res+=it.se)%=mod;\n\t\tprintf(\"%d\\n\",res);\n\t}\n}\nnamespace subtask2\n{\n\tint f[maxn];\n\tinline void solve()\n\t{\n\t\tf[0]=1;\n\t\tint len=m/2+1;\n\t\tfor(int i=1;i<=n/2+1;i++)\n\t\t\tf[i]=(2ll*f[i-1]-((i>=len)?f[i-len-(i!=len)]:0)+mod)%mod;\n\t\tprintf(\"%lld\\n\",(ll)f[n>>1]*f[(n+1)>>1]%mod);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&mod);\n\tif(m&1) subtask1::solve();\n\telse subtask2::solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (233)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,K,P;\nint solve(int n,int K){\n\tint f[N][N],ans=0; memset(f,0,sizeof(f)); f[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<=K;j++)\n\t(f[i+1][0]+=f[i][j])%=P,(f[i+1][j+1]+=f[i][j])%=P;\n\tfor(int i=0;i<=K;i++)(ans+=f[n][i])%=P; return ans;\n}\nint main(){\n\tread(n),read(K),read(P);\n\tif(K&1){\n\t\tint f[N][N][N]; memset(f,0,sizeof(f));\n\t\tf[0][0][0]=1;\n\t\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\tfor(int k=0,tmp;k<=K+1;k++)\n\t\tif(f[i-1][j][k]){\n\t\t\t(f[i][0][0]+=f[i-1][j][k])%=P;\n\t\t\tif(i*2<=n)(f[i][j+1][0]+=f[i-1][j][k])%=P;\n\t\t\tif(i*2-K>0&&i*2-K<=n&&k+1<K+2)(f[i][0][k?k+1:0]+=f[i-1][j][k])%=P;\n            if(i*2-K>0&&i*2<=n&&(tmp=max(j+2,k+1))<K+2)(f[i][j+1][tmp]+=f[i-1][j][k])%=P;\n\t\t}\n\t\tprintf(\"%d\\n\",f[n+1][0][0]);\n\t}\n\telse printf(\"%lld\\n\",1ll*solve(n/2,K/2)*solve((n+1)/2,K/2)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n \n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n \nunsigned int mod = 1;\n \nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n \n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt;\n \nint N,K;\nmint dp[2][80][80][80][80];\n \nint main(){\n\tcin >> N >> K >> mod;\n\tif(K%2 == 0){\n\t\tK = K/2 + 1;\t// o*K -> no\n\t\tVV<mint> dp(N+1,V<mint>(K));\n\t\tdp[0][0] = 1;\n\t\trep(i,N) rep(k,K){\n\t\t\tdp[i+1][0] += dp[i][k];\n\t\t\tif(k+1 != K) dp[i+1][k+1] += dp[i][k];\n\t\t}\n\t\tmint res = 1;\n\t\tfor(int n : {N/2,(N+1)/2}){\n\t\t\tmint s = 0;\n\t\t\trep(k,K) s += dp[n][k];\n\t\t\tres *= s;\n\t\t}\n\t\tcout << res << endl;\n\t\treturn 0;\n\t}\n\tK = (K+1)/2;\n\tdp[0][0][0][0][0] = 1;\n\trep(i,N){\n\t\tint t = i&1;\n\t\tint nt = 1-t;\n\t\trep(a,K+1) rep(b,K+1) rep(c,K+1){\n\t\t\tdp[nt][a][b][c][0] = 0;\n\t\t}\n\t\trep(a,K+1) rep(b,K+1) rep(c,K+1){\n\t\t\tdp[nt][a][b][0][c] = 0;\n\t\t}\n\t\trep(a,K+1) rep(b,K+1) rep(v,K+1) rep(_,2){\n\t\t\tif(v == 0 && _ == 0) continue;\n\t\t\tint c = v, d = 0;\n\t\t\tif(_) swap(c,d);\n\t\t\tif(!dp[t][a][b][c][d]) continue;\n//\t\t\tprintf(\"[%d][%d][%d][%d]\\n\",a,b,c,d);\n \n\t\t\t//x\n\t\t\tdp[nt][b][0][d][0] += dp[t][a][b][c][d];\n\t\t\t//o\n\t\t\tif(c == 1) continue;\n\t\t\tif(a == K){\n\t\t\t\tif(b >= K) continue;\n\t\t\t\tint nd = c == 0 ? 0 : c-1;\n\t\t\t\tif(b > 0){\n\t\t\t\t\tif(c == 0) nd = K-b;\n\t\t\t\t\telse nd = min(c-1,K-b);\n\t\t\t\t}\n\t\t\t\tdp[nt][b][K][d][nd] += dp[t][a][b][c][d];\n\t\t\t}else{\n\t\t\t\tdp[nt][b][a+1][d][c == 0 ? 0 : c-1] += dp[t][a][b][c][d];\n\t\t\t}\n\t\t}\n\t}\n\tmint res = 0;\n\trep(a,K+1) rep(b,K+1) rep(c,K+1) rep(d,K+1) res += dp[N&1][a][b][c][d];\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint MOD;\n// modnum {{{\nstruct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nconst int MAXN = 155;\nmn dp[2][MAXN][MAXN][MAXN];\n\nint N, K;\n\nint cache[MAXN][MAXN];\nint calc(int end, int cont) {\n    int& res = cache[end][cont];\n    if (cache[end][cont] != 0x7f7f7f7f) return res;\n\n    F0R (cent, min(end, cont - 1)) { // center around a top node\n        int topw = 2 * min(cent, end - 1 - cent);\n        int botmax = (K - topw - 1) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 2 - cent;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax + 1); // not inclusive, number of edges it can grow to\n    }\n\n    F0R (cent, min(end - 1, cont - 1)) { // center between top nodes\n        int topw = 1 + 2 * min(cent, end - 1 - cent - 1);\n        int botmax = (K - topw) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 1 - cent - 1;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax); // not inclusive, number of edges it can grow to\n    }\n\n    return min(N, res);\n}\n\nint main() {\n    setIO();\n    memset(cache, 0x7f, sizeof(cache));\n\n    re(N, K, MOD);\n\n    bool x = 0;\n    if (K&1) {\n        dp[x][0][0][N] = 1;\n\n        F0R (i, N) {\n            memset(dp[!x], 0, sizeof(dp[!x]));\n\n            F0R (even, (i+1)/2 + 1) {\n                F0R (odd, i/2 + 1) {\n                    F0R (limit, N + 1) {\n                        const mn& ctr = dp[x][even][odd][limit];\n                        if (!ctr.v) continue;\n\n                        if (i&1) {\n                            dp[!x][even][0][min(odd > even ? INT_MAX : limit, calc(odd, even))] += ctr;\n                            if (odd + 1 <= calc(even, odd + 1) && (odd < even || odd + 1 <= limit))\n                                dp[!x][even][odd+1][limit] += ctr;\n                        } else {\n                            dp[!x][0][odd][min(even > odd ? INT_MAX : limit, calc(even, odd))] += ctr;\n                            if (even + 1 <= calc(odd, even + 1) && (even < odd || even + 1 <= limit))\n                                dp[!x][even+1][odd][limit] += ctr;\n                        }\n                    }\n                }\n            }\n\n            x = !x;\n        }\n\n        mn ans = 0;\n        F0R (even, N + 1) F0R (odd, N + 1) F0R (limit, N + 1) ans += dp[x][even][odd][limit];\n        ps(ans);\n    } else {\n        vmn ways((N+1)/2 + 1);\n        ways[0] = 1;\n        FOR (v, 1, sz(ways)) {\n            FOR (i, 0, min(v, K/2) + 1)\n                ways[v] += ways[max(0, v-i-1)];\n        }\n        ps(ways[N/2] * ways[(N+1)/2]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\n\nint mod;\n\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint& v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0) val += mod;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& a) { return os << a.val; }\n\tfriend bool operator==(const mint& a, const mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint& operator+=(const mint& m) { if ((val += m.val) >= mod) val -= mod; return *this; }\n\tmint& operator-=(const mint& m) { if ((val -= m.val) < 0) val += mod; return *this; }\n\tmint& operator*=(const mint& m) { val = (lint)val*m.val%mod; return *this; }\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint& a) { assert(a.val); return ipow(a, mod - 2); }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n\toperator int64_t() const {return val; }\n};\n\nmint ez(int n, int k){\n\tvector<mint> dp(n + 2);\n\tdp[0] = mint(1);\n\tfor(int i=1; i<=n+1; i++){\n\t\tfor(int j=1; j<=k+1 && j<=i; j++){\n\t\t\tdp[i] += dp[i - j];\n\t\t}\n\t}\n\treturn dp[n + 1];\n}\n\nvector<int> v;\nint dp[155][155][155], n, k;\n\nmint f(int pos, int l, int r){\n\tif(r >= k + 2) return mint(0);\n\tif(pos == sz(v)) return mint(1);\n\tif(~dp[pos][l][r]) return dp[pos][l][r];\n\tmint ret = f(pos + 1, 0, 0);\n\tif(v[pos] & 1){\n\t\tret += f(pos + 1, l + 1, 0);\n\t}\n\tif(v[pos] & 2){\n\t\tret += f(pos + 1, 0, r ? (r + 1) : 0);\n\t}\n\tif(v[pos] == 3){\n\t\tret += f(pos + 1, l + 1, max(l + 2, r + 1));\n\t}\n\treturn dp[pos][l][r] = (lint)ret;\n}\n\nint main(){\n\tcin >> n >> k >> mod;\n\tif(k % 2 == 0){\n\t\tcout << ez((n + 1) / 2, k / 2) * ez(n / 2, k / 2) << endl;\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tfor(int i=1; i<=n+n; i+=2){\n\t\tif(i - k > n) break;\n\t\tint msk = 0;\n\t\tif(i <= n) msk |= 1;\n\t\tif(i - k >= 1) msk |= 2;\n\t\tv.push_back(msk);\n\t}\n\tcout << f(0, 0, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 160\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint f[2][N][N],n,K,mdn;\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nvoid solve1()\n{\n\tf[0][0][0]=1; int cur=0,lst=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcur^=1,lst^=1; memset(f[cur],0,sizeof(f[cur]));\n\t\tfor(int j=0;j<K/2+1;j++)\tfor(int k=0;k<K/2+1;k++)\n\t\t{\n\t\t\tif((i&1))\n\t\t\t{\n\t\t\t\tupd(f[cur][0][k],f[lst][j][k]);\n\t\t\t\tif(j<K/2)\tupd(f[cur][j+1][k],f[lst][j][k]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tupd(f[cur][j][0],f[lst][j][k]);\n\t\t\t\tif(k<K/2)\tupd(f[cur][j][k+1],f[lst][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<K/2+1;i++)\tfor(int j=0;j<K/2+1;j++)\n\t\tupd(ans,f[cur][i][j]);\n\tprintf(\"%d\\n\",ans);\n}\nint g[N*2][N][N];\nvoid solve2()\n{\n\tg[0][0][0]=1; int cur=0,ans=0;\n\tfor(int i=2;i-K<=n;i+=2)\n\t{\n\t\tfor(int j=0;j<=n;j++)\tfor(int k=0;k<=K+1;k++)\n\t\t\tupd(g[i][0][0],g[i-2][j][k]);\n\t\tif(i<=n)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\tfor(int k=0;k<=K+1;k++)\n\t\t\t\tupd(g[i][j+1][0],g[i-2][j][k]);\n\t\t}\n\t\tif(i-K>=1)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=K;k++)\n\t\t\t\t\tupd(g[i][0][k+1],g[i-2][j][k]);\n\t\t\t\tupd(g[i][0][0],g[i-2][j][0]);\n\t\t\t}\n\t\t}\n\t\tif(i<=n && i-K>=1)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\tfor(int k=0;max(j+2,k+1)<=K+1;k++)\n\t\t\t\tupd(g[i][j+1][max(j+2,k+1)],g[i-2][j][k]);\n\t\t}\n\t\tcur=i;\n\t}\n\tfor(int i=0;i<=n;i++)\tfor(int j=0;j<=K+1;j++)\n\t\tupd(ans,g[cur][i][j]);\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tn=read(),K=read(),mdn=read();\n\tif(K&1)\tsolve2();\n\telse\tsolve1();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define ll long long\n#define mul(a, b) (((ll)(a) * (ll)(b)) % MOD)\n\nint N, K, MOD;\n\nint f1[155][155];\nint f[155][80][80][80];\n\nint work_easy(int siz, int consec)\n{\n    for (int i = 0; i < 155; i++) {\n        for (int j = 0; j < 155; j++) {\n            f1[i][j] = 0;\n        }\n    }\n    f1[0][0] = 1;\n    for (int i = 0; i < siz; i++) {\n        for (int j = 0; j <= consec; j++) {\n            f1[i+1][j+1] += f1[i][j];\n            if (f1[i+1][j+1] >= MOD) f1[i+1][j+1] -= MOD;\n            f1[i+1][0] += f1[i][j];\n            if (f1[i+1][0] >= MOD) f1[i+1][0] -= MOD;\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= consec; i++) {\n        ans += f1[siz][i];\n        if (ans >= MOD) ans -= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &N, &K, &MOD);\n    if (K % 2 == 0) {\n        printf(\"%d\", (int)mul(work_easy(N / 2, K / 2),\n            work_easy(N / 2 + (N % 2), K / 2)));\n        return 0;\n    }\n    f[0][0][0][N / 2 + 2] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N / 2 + 1; j++) {\n            for (int k = 0; k <= N / 2 + 1; k++) {\n                for (int l = max(j, k) + 1; l <= N / 2 + 2; l++) {\n                    int& add0 = f[i+1][0][j][j <= k ? N / 2 + 2 : l];\n                    int& add1 = f[i+1][k+1][j][\n                        (k+1 <= j || j == 0 || 2 * k < K + 1) ? l\n                        : min(max(k + 1 + (K + 1 - 2 * j) / 2, 0), l)];\n                    add0 += f[i][j][k][l];\n                    if (add0 >= MOD) add0 -= MOD;\n                    add1 += f[i][j][k][l];\n                    if (add1 >= MOD) add1 -= MOD;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int j = 0; j <= N / 2 + 1; j++) {\n        for (int k = 0; k <= N / 2 + 1; k++) {\n            for (int l = max(j, k) + 1; l <= N / 2 + 2; l++) {\n                ans += f[N][j][k][l];\n                if (ans >= MOD) ans -= MOD;\n            }\n        }\n    }\n    printf(\"%d\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 205;\n\nint mod;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\n\nint f[N][N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int k;  cin >> k >> mod;\n\n    if (k % 2 == 0) {\n        k /= 2;\n        vector<int> f(n + 1,0);\n        vector<int> g(n + 1,0);\n\n        g[0] = 1;\n\n        for(int i = 1 ; i <= n ; ++i)   {\n            add(g[i],f[i - 1]);\n            add(g[i],g[i - 1]);\n\n            for(int j = 1 ; j <= k ; ++j)   if (j <= i)\n                add(f[i],g[i - j]);\n        }\n        for(int i = 0 ; i <= n ; ++i)\n            add(f[i],g[i]);\n\n        cout << mul(f[n / 2],f[n - n / 2]) << endl;\n        return  0;\n    }\n    f[0][0][0] = 1;\n\n    for(int i = 2 ; i <= n + k ; i += 2)    {\n        for(int j = 0 ; j <= n ; ++j)\n        for(int t = 0 ; t <= k + 1 ; ++t)\n            add(f[i][0][0],f[i - 2][j][t]);\n\n        if (i <= n) {\n            for(int j = 0 ; j <= n ; ++j)\n            for(int t = 0 ; t <= k + 1 ; ++t)\n                add(f[i][j + 1][0],f[i - 2][j][t]);\n        }\n        if (i >  k) {\n            for(int j = 0 ; j <= n ; add(f[i][0][0],f[i - 2][j++][0]))\n            for(int t = 1 ; t <= k ; ++t)\n                add(f[i][0][t + 1],f[i - 2][j][t]);\n        }\n        if (i <= n && i > k)    {\n            for(int j = 0 ; j <= n ; ++j)   if (j < k)\n            for(int t = 0 ; t <= k ; ++t)\n                add(f[i][j + 1][max(j + 2,t + 1)],f[i - 2][j][t]);\n        }\n    }\n    int ans = 0;\n\n    for(int i = 0 ; i <= n ; ++i)\n    for(int j = 0 ; j <= k + 1 ; ++j)\n        add(ans,f[(n + k) / 2 * 2][i][j]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nll M;\nint n, k;\n\nconst int N = 160;\nset<string> all;\n\nstring target = \"000101000\";\nset<string> used;\n\nint zip(int x, int y, int xup, int yup) {\n\treturn min(N - 1, (x < y) ? xup : yup);\n}\n\nint mem[2][N][N][N];\n\nint &get(int p, int x, int y, int xup, int yup) {\n\treturn mem[p][x][y][zip(x, y, xup, yup)];\n}\n\nvoid dp(int i, int x, int y, int xup, int yup, int p=0) {\n\t// if (i == n)\n\t\t// return 1;\n\t// if (mem[p][x][y][zip(x, y, xup, yup)] != -1) return mem[i][x][y][zip(x, y, xup, yup)];\n\tint rez = 0;\n\t// take\n\t{\n\t\tint nxup = xup;\n\t\tif (nxup > i) {\n\t\t\tmem[1][y][x][zip(y, x, yup, nxup)] += mem[0][x][y][zip(x, y, xup, yup)];\n\t\t\tmem[1][y][x][zip(y, x, yup, nxup)] %= M;\n\t\t\t// rez += dp(i + 1, y, x, yup, nxup, p + 1);\n\t\t}\n\t}\n\t// don't\n\t{\n\t\tint nyup = yup;\n\t\tif (nyup - k <= i && i <= y + k)\n\t\t\tnyup = i + k + 2;\n\t\t// rez += dp(i + 1, max(y, nyup - k - k), i + 2, nyup, i + 3 + k, p + 1);\n\t\tget(1, max(y, nyup - k - k), i + 2, nyup, i + 3 + k) += get(0, x, y, xup, yup);\n\t\tget(1, max(y, nyup - k - k), i + 2, nyup, i + 3 + k) %= M;\n\t}\n\trez -= (rez >= M) * M;\n\t// return mem[p][x][y][zip(x, y, xup, yup)] = rez;\n}\n\n\nvoid go(string s) {\n\tused.insert(s);\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] == '1') {\n\t\t\tstring t = s;\n\t\t\tif (i - 2 >= 0)\n\t\t\t\tt[i - 2] = '1';\n\t\t\tif (i + k < n)\n\t\t\t\tt[i + k] = '1';\n\t\t\tt[i] = '0';\n\t\t\tif (!used.count(t))\n\t\t\t\tgo(t);\n\t\t}\n}\n\nint hard[N][N];\n\nint easy(int n, int combo) {\n\tif (n == 0) return 1;\n\tif (hard[n][combo] != -1) return hard[n][combo];\n\tint rez = 0;\n\tif (combo != k - 1) \n\t\trez += easy(n - 1, combo + 1);\n\trez += easy(n - 1, 0);\n\trez -= (rez >= M) * M;\n\treturn hard[n][combo] = rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, 0, sizeof mem);\n\tmemset(hard, -1, sizeof hard);\n\tscan n, k, M;\n\tif (k & 1) {\n\t\tmem[0][0][1][1 + k] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int x = 0; x < N; x++)\n\t\t\t\tfor (int y = 0; y < N; y++)\n\t\t\t\t\tfor (int z = 0; z < N; z++)\n\t\t\t\t\t\tif (mem[0][x][y][z]) {\n\t\t\t\t\t\t\tint xup = z;\n\t\t\t\t\t\t\tint yup = z;\n\t\t\t\t\t\t\tif (x < y) yup = y + 1 + k;\n\t\t\t\t\t\t\telse xup = x + 1 + k;\n\t\t\t\t\t\t\tdp(i, x, y, xup, yup);\n\t\t\t\t\t\t}\n\t\t\tswap(mem[0], mem[1]);\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t\tmem[1][i][j][k] = 0;\n\t\t}\n\t\tll final = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\tfinal += mem[0][i][j][k];\n\t\tprint final % M;\n\t} else {\n\t\tk /= 2;\n\t\tk++;\n\t\tprint (easy(n / 2, 0) * easy((n + 1) / 2, 0)) % M;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nint Solve1(int n, int k, int m) { // nie ma k + 1 kolejnych\n  VVI dp(n + 2, VI(n + 2));\n  dp[0][0] = 1;\n  RE (i, n) {\n    REP (prv, k + 1) {\n      dp[i][0] = (dp[i][0] + dp[i - 1][prv]) % m;\n      if (prv < k) {\n        dp[i][prv + 1] = (dp[i][prv + 1] + dp[i - 1][prv]) % m;\n      }\n    }\n  }\n  int res = 0;\n  REP (prv, k + 1) {\n    res = (res + dp[n][prv]) % m;\n  }\n  return res;\n}\n\nconst int N = 80;\nint dp[2 * N][N][N][N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, k, m;\n  cin>>n>>k>>m;\n  if (k % 2 == 0) {\n    cout<<Solve1(n / 2, k / 2, m) * Solve1(n - n / 2, k / 2, m) % m<<endl;\n    return 0;\n  }\n  if (k == 1) {\n    cout<<Solve1(n, 2, m)<<endl;\n    return 0;\n  }\n  dp[0][0][0][N - 1] = 1;\n  // dp[a][b][c][d] \n  // pozycja a\n  // na parzystosci a dlugosc b\n  // na parzystosci a-1 dlugosc c\n  // dluzszy z nich nie moze dojsc do dlugosci d\n  RE (i, n) {\n    REP (prv_b, N - 2) {\n      REP (prv_c, N - 2) {\n        REP (prv_d, N) {\n          // dodajemy x\n          int nb = prv_c + 1;\n          int nc = prv_b;\n          int nd = prv_d;\n          if (nb > nc && nc >= 1 && nb * 2 >= k + 3) {\n            mini(nd, nb + (k - 2 * nc + 1) / 2);\n            maxi(nd, 0ll);\n          }\n          if (i >= 5 && prv_b == 2 && prv_c == 2 && prv_d == N - 1) {\n            debug(nb, nc, nd);\n          }\n          dp[i][nb][nc][nd] = (dp[i][nb][nc][nd] + dp[i - 1][prv_b][prv_c][prv_d]) % m;\n          if (i >= 5 && prv_b == 2 && prv_c == 2 && prv_d == N - 1) {\n            debug(dp[i][nb][nc][nd]);\n          }\n          if (nb >= nd || nc >= nd) {\n            if (dp[i - 1][prv_b][prv_c][prv_d]) {\n              debug(i, nb, nc, nd, prv_b, prv_c, prv_d, dp[i][nb][nc][nd], dp[i - 1][prv_b][prv_c][prv_d]);\n            }\n            dp[i][nb][nc][nd] = 0;\n          }\n          if (i >= 5 && prv_b == 2 && prv_c == 2 && prv_d == N - 1) {\n            debug(dp[i][nb][nc][nd]);\n          }\n          // dodajemy o\n          nb = 0;\n          nc = prv_b;\n          if (prv_c >= prv_b) {\n            nd = N - 1;\n          }\n          dp[i][nb][nc][nd] = (dp[i][nb][nc][nd] + dp[i - 1][prv_b][prv_c][prv_d]) % m;\n          if (nb >= nd || nc >= nd) {\n            dp[i][nb][nc][nd] = 0;\n          }\n        }\n      }\n    }\n  }\n  int res = 0;\n  REP (prv_b, N - 1) {\n    REP (prv_c, N - 1) {\n      REP (prv_d, N) {\n        res = (res + dp[n][prv_b][prv_c][prv_d]) % m;\n      }\n    }\n  }\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define fp(i, a, b) for (R int i = (a), I = (b) + 1; i < I; ++i)\n#define fd(i, a, b) for (R int i = (a), I = (b)-1; i > I; --i)\n#define go(u) for (int i = head[u], v = e[i].v; i; i = e[i].nx, v = e[i].v)\ntemplate <class T>\ninline bool cmin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline bool cmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nusing namespace std;\nint P;\ninline void upd(R int &x, R int y) { (x += y) >= P ? x -= P : 0; }\ninline int add(R int x, R int y) { return x + y >= P ? x + y - P : x + y; }\ninline int dec(R int x, R int y) { return x - y < 0 ? x - y + P : x - y; }\ninline int mul(R int x, R int y) { return 1ll * x * y - 1ll * x * y / P * P; }\nint ksm(R int x, R int y) {\n  R int res = 1;\n  for (; y; y >>= 1, x = mul(x, x)) (y & 1) ? res = mul(res, x) : 0;\n  return res;\n}\nconst int N = 155;\nint n, p;\ninline int max(R int x, R int y) { return x > y ? x : y; }\nint solve(int n, int p) {\n  static int f[N][N];\n  memset(f, 0, sizeof(f));\n  f[0][0] = 1;\n  fp(i, 0, n - 1) fp(j, 0, p) if (f[i][j]) upd(f[i + 1][0], f[i][j]),\n      upd(f[i + 1][j + 1], f[i][j]);\n  R int res = 0;\n  fp(i, 0, p) upd(res, f[n][i]);\n  return res;\n}\nint f[N][N][N];\nint main() {\n  //  freopen(\"testdata.in\",\"r\",stdin);\n  scanf(\"%d%d%d\", &n, &p, &P);\n  if (p & 1 ^ 1)\n    return printf(\"%d\\n\",\n                  mul(solve(n >> 1, p >> 1), solve((n + 1) >> 1, p >> 1))),\n           0;\n  f[0][0][0] = 1;\n  fp(i, 1, n + 1) {\n    R int r = (i << 1), l = r - p;\n    R bool fr = (r >= 1 && r <= n), fl = (l >= 1 && l <= n);\n    fp(j, 0, n) fp(k, 0, p + 1) if (f[i - 1][j][k]) {\n      upd(f[i][0][0], f[i - 1][j][k]);\n      if (fr) upd(f[i][j + 1][0], f[i - 1][j][k]);\n      if (fl && k + 1 < p + 2) upd(f[i][0][k ? k + 1 : k], f[i - 1][j][k]);\n      if (fl && fr && max(j + 2, k + 1) < p + 2)\n        upd(f[i][j + 1][max(k + 1, j + 2)], f[i - 1][j][k]);\n    }\n  }\n  printf(\"%d\\n\", f[n + 1][0][0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long hxtype;\ntypedef pair<int,int>pii;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=155;\nmap<pii,int>dp[N][N][N];int p;\ninline void add(int &a){if(a>=p)a-=p;}\nint main(){\n\tint m,n,k,i,j,t,J,T,d;\n\tmap<pii,int>::iterator it1,it2;\n\tscanf(\"%d%d%d\",&n,&k,&p);\n\tif(k&1){\n\t\tm=n+1;\n\t\tdp[0][0][0][mp(m,m)]=1;\n\t\trep(i,1,n)rep(j,0,n)rep(t,0,n){\n\t\t\tit1=dp[i-1][j][t].begin();\n\t\t\tit2=dp[i-1][j][t].end  ();\n\t\t\tfor(;it1!=it2;++it1){\n\t\t\t\tJ=(*it1).fi.fi;\n\t\t\t\tT=(*it1).fi.se;\n\t\t\t\td=(*it1)   .se;\n//\t\t\t\tprintf(\"sol (%d,%d,%d,%d,%d) %d\\n\",i-1,j,t,J,T,d);\n\t\t\t\tif(i&1){\n//\t\t\t\t\tprintf(\"add (%d,%d,%d,%d,%d)\\n\",i,0,t,m,T);\n\t\t\t\t\tadd(dp[i][0][t][mp(m,T)]+=d);\n\t\t\t\t\tif((t<<1)>k)cmin(T,i-(j<<1)+k);\n//\t\t\t\t\tif(i!=J)printf(\"add (%d,%d,%d,%d,%d)\\n\",i,j+1,t,J,T);\n\t\t\t\t\tif(i!=J)add(dp[i][j+1][t  ][mp(J,T)]+=d);\n\t\t\t\t}else{\n//\t\t\t\t\tprintf(\"add (%d,%d,%d,%d,%d)\\n\",i,j,0,J,m);\n\t\t\t\t\tadd(dp[i][j][0][mp(J,m)]+=d);\n\t\t\t\t\tif((j<<1)>k)cmin(J,i-(t<<1)+k);\n//\t\t\t\t\tif(i!=T)printf(\"add (%d,%d,%d,%d,%d)\\n\",i,j,t+1,J,T);\n\t\t\t\t\tif(i!=T)add(dp[i][j  ][t+1][mp(J,T)]+=d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tT=0;\n\t\trep(j,0,n)rep(t,0,n){\n\t\t\tit1=dp[n][j][t].begin();\n\t\t\tit2=dp[n][j][t].end  ();\n\t\t\tfor(;it1!=it2;++it1)add(T+=(*it1).se);\n\t\t}\n\t\tprintf(\"%d\",T);\n\t}else{\n\t\tk>>=1;\n\t\tstatic int dp[N][N];\n\t\tdp[0][0]=1;\n\t\tREP(i,0,n)rep(j,0,k){\n\t\t\tadd(dp[i+1][  0]+=dp[i][j]);\n\t\t\tif(j!=k)\n\t\t\tadd(dp[i+1][j+1]+=dp[i][j]);\n\t\t}\n\t\tt=n-(j=n>>1);\n\t\tJ=T=0;\n\t\trep(i,0,k)add(J+=dp[j][i]);\n\t\trep(i,0,k)add(T+=dp[t][i]);\n\t\tprintf(\"%lld\",((ll)J)*T%p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, mod;\nint f[200][200], g[200][200];\nmap<int, int> mp1, mp2;\n\ninline void addto(int &x, int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nvoid trans(int x, int y) {\n\tif (!x && !y) return;\n\tmemset(g, 0, sizeof g);\n\tfor (int i = 0; i <= k; ++i)\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\taddto(g[0][0], f[i][j]);\n\t\t\tif (x == 1) addto(g[i ? i + 1 : 0][0], f[i][j]);\n\t\t\tif (y == 1) addto(g[0][j + 1], f[i][j]);\n\t\t\tif (x == 1 && y == 1) addto(g[max(i, j) + 1][j + 1], f[i][j]);\n\t\t}\n\tmemcpy(f, g, sizeof g);\n}\n\nvoid solve1() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (i & 1) ++mp1[i];\n\t\telse ++mp2[i - k];\n\tfor (int i = -1000; i <= 1000; ++i)\n\t\ttrans(mp1[i], mp2[i]);\n\tint ans = 0;\n\tfor (int i = 0; i <= k; ++i)\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\taddto(ans, f[i][j]);\n\tprintf(\"%d\", ans);\n}\n\nvoid solve2() {\n\tf[0][0] = 1;\n\tk /= 2;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j <= k; ++j) {\n\t\t\taddto(f[i + 1][j + 1], f[i][j]);\n\t\t\taddto(f[i + 1][0], f[i][j]);\n\t\t}\n\tint a1 = 0, a2 = 0;\n\tfor (int i = 0; i <= k; ++i) {\n\t\taddto(a1, f[n / 2][i]);\n\t\taddto(a2, f[(n + 1) / 2][i]);\n\t}\n\tprintf(\"%lld\", 1ll * a1 * a2 % mod);\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &k, &mod);\n\tif (k & 1) solve1();\n\telse solve2();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,k,m;\n\nint s1(int n,int k)\n{\n\tstatic int f[155];\n\tf[0] = 1;\n\tfor(int i = 1;i <= n + 1; ++ i)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tif(i - j - 1 >= 0)\n\t\t\t\tf[i] = (f[i] + f[i - j - 1]) % m;\n\t}\n\treturn f[n + 1];\n}\n\nint s2(int n,int k)\n{\n\tstatic int f[155][155][155];\n\tstatic int typ[155];\n\tint tot = 0;\n\tfor(int i = 1;i * 2 - k <= n; ++ i)\n\t{\n\t\ttot ++;\n\t\tif(i * 2 <= n) typ[tot] |= 2;\n\t\tif(i * 2 - k > 0) typ[tot] |= 1;\n\t}\n\tf[0][0][0] = 1;\n\tfor(int i = 1;i <= tot; ++ i)\n\t\tfor(int j = 0;j <= k + 1; ++ j)\n\t\t\tfor(int l = 0;l <= i; ++ l)\n\t\t\t\tif(f[i - 1][j][l])\n\t\t\t\t{\n\t\t\t\t\t//×óÓÒ¾ù²»Ñ¡\n\t\t\t\t\tf[i][0][0] = (f[i][0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡×ó²»Ñ¡ÓÒ\n\t\t\t\t\tif(typ[i] & 1)\n\t\t\t\t\t\tf[i][j ? j + 1 : 0][0] = (f[i][j ? j + 1 : 0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡ÓÒ²»Ñ¡×ó\n\t\t\t\t\tif(typ[i] & 2)\n\t\t\t\t\t\tf[i][0][l + 1] = (f[i][0][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t\tif(typ[i] == 3)\n\t\t\t\t\t\tf[i][j ? j + 1 : l + 2][l + 1] = (f[i][j ? j + 1 : l + 2][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t}\n\tint as = 0;\n\tfor(int i = 0;i <= k + 1; ++ i)\n\t\tfor(int j = 0;j <= tot; ++ j)\n\t\t\tas = (as + f[tot][i][j]) % m;\n\treturn as;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&m);\n\tif(k % 2 == 0)\n\t{\n\t\tprintf(\"%lld\\n\",(s1(n / 2,k / 2) * 1ll * s1((n + 1) / 2,k / 2)) % m);\n\t}\n\telse printf(\"%d\\n\",s2(n,k));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 155;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m, P;\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nmap <pair <int, int>, int> dp[MAXN][MAXN][MAXN];\nint main() {\n\tread(n), read(m), read(P);\n\tif (m % 2 == 0) {\n\t\tstatic int dp[MAXN][MAXN];\n\t\tm /= 2, dp[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tupdate(dp[i][0], dp[i - 1][j]);\n\t\t\tif (j != m) update(dp[i][j + 1], dp[i - 1][j]);\n\t\t}\n\t\tint ans = 0, bns = 0;\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tupdate(ans, dp[n / 2][i]);\n\t\t\tupdate(bns, dp[(n + 1) / 2][i]);\n\t\t}\n\t\twriteln(1ll * ans * bns % P);\n\t} else {\n\t\tdp[0][0][0][make_pair(n + 1, n + 1)] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\tfor (int k = 0; k <= n; k++) {\n\t\t\tif (i & 1) {\n\t\t\t\tfor (auto x : dp[i - 1][j][k]) {\n\t\t\t\t\tpair <int, int> tmp = x.first; tmp.first = n + 1;\n\t\t\t\t\tupdate(dp[i][0][k][tmp], x.second);\n\t\t\t\t\tif (i != x.first.first) {\n\t\t\t\t\t\ttmp = x.first;\n\t\t\t\t\t\tif (i - m >= i - 2 * k + 1) chkmin(tmp.second, i - 2 * j + m);\n\t\t\t\t\t\tif (tmp.second >= i) update(dp[i][j + 1][k][tmp], x.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (auto x : dp[i - 1][j][k]) {\n\t\t\t\t\tpair <int, int> tmp = x.first; tmp.second = n + 1;\n\t\t\t\t\tupdate(dp[i][j][0][tmp], x.second);\n\t\t\t\t\tif (i != x.first.second) {\n\t\t\t\t\t\ttmp = x.first;\n\t\t\t\t\t\tif (i - m >= i - 2 * j + 1) chkmin(tmp.first, i - 2 * k + m);\n\t\t\t\t\t\tif (tmp.first >= i) update(dp[i][j][k + 1][tmp], x.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (auto x : dp[n][i][j])\n\t\t\t\tupdate(ans, x.second);\n\t\t}\n\t\twriteln(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair <int, int>\n#define iiii pair <int, pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n  int x = 0, p = 1; char c = getchar();\t\n  while (c <= 32) c = getchar();\n  if (c == 45) p = -p, c = getchar();\n  while (c > 32) x = x * 10 + c - 48, c = getchar();\n  return x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 158;\nint n, k, mod;\nint g[N][N], f[N][N][N];\n//\ninline void reduce(int &x) {\n  x += x >> 31 & mod;\n}\ninline void add(int &x, int y) {\n  x += y - mod;\n  reduce(x);\n}\ninline int mul(int x, int y) {\n  return 1ll * x * y % mod;\n}\nvoid solve0() {\n  g[0][0] = g[1][0] = 1;\n  k /= 2;\n  for (int i = 1; i <= n; i++) {\n    add(g[i + 1][0], g[i][0]);\n    for (int j = 1; j <= min(i, k); j++) {\n      add(g[i][j], g[i - 1][j - 1]);\n      add(g[i + 1][0], g[i][j]);\n    }\n  }\n  int sum = 0, res = 0;\n  rep(i, k + 1) add(sum, g[n / 2][i]);\n  if (n & 1) ++n;\n  rep(i, k + 1) add(res, g[n / 2][i]);\n  cout << mul(res, sum) << endl;\n}\nvoid solve1() {\n  assert(false);\n  int c0 = 0, c1 = 0, c;\n  for (int i = 2; i <= n; i += 2) {\n    if (i - k <= 0) ++c0;\n  }\n  for (int i = 1; i <= n; i += 2) {\n    if (i + k > n) ++c1;\n  }\n  c = (n - c0 - c1) / 2;\n  f[0][0][0] = 1;\n  for (int i = 1; i <= c0; i++) {\n    rep(j, i) add(f[i][0][0], f[i - 1][0][j]);\n    for (int j = 1; j <= i; j++) {\n      add(f[i][0][j], f[i - 1][0][j - 1]);\n    }\n  }\n  for (int i = c0 + 1; i <= c0 + c + c1; i++) {\n    if (i <= c0 + c) for (int j = 1; j <= k; j++) {\n      for (int x = 0; x < N; x++) {\n        add(f[i][0][j], f[i - 1][x][j - 1]);\n      }\n    }\n    rep(x, N) add(f[i][0][0], f[i - 1][0][x]);\n    rep(j, k + 1) rep(k, N) {\n      add(f[i][0][0], f[i - 1][j][k]);\n    }\n    for (int j = 2; j <= k; j++) {\n      for (int x = 0; x < N; x++) {\n        add(f[i][j][0], f[i - 1][j - 1][x]);\n      }\n    }\n    if (i <= c0 + c) rep(j, k) for (int x = 0; x < N - 1; x++) {\n      add(f[i][max(j, x) + 1][x + 1], f[i - 1][j][x]);\n    }\n  }\n  int res = 0;\n  rep(i, k + 1) rep(j, N) add(res, f[c + c0 + c1][i][j]);\n  cout << res << endl;\n}\nint main() {\n  n = getint(); k = getint(); mod = getint();\n  if (!(k & 1)) {\n    solve0();\n  }\n  else {\n    solve1();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 160;\nint n, k, mod, g[N][N], f[N][N][N];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &mod);\n  if (!(k & 1)) {\n    g[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= i && j <= k >> 1; j++) {\n        g[i + 1][j + 1] = (g[i + 1][j + 1] + g[i][j]) % mod;\n        g[i + 1][0] = (g[i + 1][0] + g[i][j]) % mod;\n      }\n    }\n    int ansx = 0, ansy = 0;\n    for (int j = 0; j <= n + 1 >> 1 && j <= k >> 1; j++) {\n      ansx = (ansx + g[n >> 1][j]) % mod;\n      ansy = (ansy + g[n + 1 >> 1][j]) % mod;\n    }\n    ansx = (ll) ansx * ansy % mod;\n    printf(\"%d\\n\", ansx);\n  } else {\n    f[0][0][0] = 1;\n    for (int i = 0; i <= n; i++) {\n      bool px = 2 * i + 1 <= n, py = 2 * i + 1 - k >= 2 && 2 * i + 1 - k <= n;\n      for (int c = 0; c <= i + 1 && c < k + 2; c++) {\n        for (int d = 0; d <= i; d++) {\n          if (true   ) f[i + 1][0][0] = (f[i + 1][0][0] + f[i][c][d]) % mod;\n          if (px     ) f[i + 1][0][d + 1] = (f[i + 1][0][d + 1] + f[i][c][d]) % mod;\n          if (py     ) f[i + 1][c ? c + 1 : 0][0] = (f[i + 1][c ? c + 1 : 0][0] + f[i][c][d]) % mod;\n          if (px & py) f[i + 1][max(c + 1, d + 2)][d + 1] = (f[i + 1][max(c + 1, d + 2)][d + 1] + f[i][c][d]) % mod;\n        }\n      }\n    }\n    printf(\"%d\\n\", f[n + 1][0][0]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \n//const ll mod=1000000007;\nint mod;\nint rnd(int x) { return mrand() % x;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=160;\nint n,k;\n\nll dp[N][N];\nll solvee(int n,int k) {\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\trep(i,0,n) rep(j,0,k+1) {\n\t\tdp[i+1][0]=(dp[i+1][0]+dp[i][j])%mod;\n\t\tif (j+1<=k) dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t}\n\tll ans=0;\n\trep(j,0,k+1) ans=(ans+dp[n][j])%mod;\n\treturn ans;\n}\n\nll dp2[N][N][N];\n\nvoid upd(ll &a,ll b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\n\nbool valid(int a,int b) {\n\tif (a==0||b==0) return 1;\n\treturn a-1+b-1<k;\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tif (k%2==0) {\n\t\tprintf(\"%lld\\n\",solvee(n/2,k/2)*solvee(n-n/2,k/2)%mod);\n\t} else {\n\t\tif (n==1) {\n\t\t\tputs(\"2\");\n\t\t\treturn 0;\n\t\t}\n\t\tll ans=0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;\n\t\tfor (int i=1;i<=k;i+=2) rep(j,0,k+1) {\n\t\t\tdp[i/2+1][0]=(dp[i/2+1][0]+dp[i/2][j])%mod;\n\t\t\tdp[i/2+1][j+1]=(dp[i/2+1][j+1]+dp[i/2][j])%mod;\n\t\t}\n\t\trep(p1,0,n+1) rep(p2,0,n+1) if (valid(p1,p2)) {\n\t\t\tdp2[0][p1][p2]=dp[k/2+1][p2];\n\t\t}\n\t\tfor (int i=0;i+2<n;i+=2) rep(p1,0,n+1) rep(p2,0,n+1) if (valid(p1,p2)) {\n\t\t\t// fix i+2, i+k+2\n\t\t\t//printf(\"gg %d %d %d %lld\\n\",i,p1,p2,dp2[i][p1][p2]);\n\t\t\tif (p1>0) {\n\t\t\t\tif (i+k+2<n) {\n\t\t\t\t\tupd(dp2[i+2][p1-1][0],dp2[i][p1][p2]);\n\t\t\t\t\tif (valid(p1-1,p2+1)) upd(dp2[i+2][p1-1][p2+1],dp2[i][p1][p2]);\n\t\t\t\t} else {\n\t\t\t\t\tupd(dp2[i+2][p1-1][0],dp2[i][p1][p2]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int l=0;l<=n;l++) {\n\t\t\t\t\tif (i+k+2<n) {\n\t\t\t\t\t\tupd(dp2[i+2][l][0],dp2[i][p1][p2]);\n\t\t\t\t\t\tif (valid(l,p2+1)) upd(dp2[i+2][l][p2+1],dp2[i][p1][p2]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupd(dp2[i+2][l][0],dp2[i][p1][p2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int p1=0;p1<=1;p1++) for (int p2=0;p2<=n;p2++) if (valid(p1,p2)) {\n//\t\t\tprintf(\"%d %d %lld\\n\",p1,p2,dp2[4][p1][p2]);\n\t\t\tupd(ans,dp2[n-((n%2)?1:2)][p1][p2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 155;\n\nint n, m, mod;\nint f[maxN + 1][maxN + 1][maxN + 1], g[maxN + 1][maxN + 1];\nint ans;\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int solve1()\n{\n\tf[0][0][0] = 1;\n\tfor(int i = 1; i <= m / 2; i++)\n\t{\n\t\tfor(int j = 0; j <= i - 1; j++) f[i][0][0] = ADD(f[i][0][0], f[i - 1][0][j]);\n\n\t\tfor(int j = 1; j <= i; j++) \n\t\t\tf[i][0][j] = f[i - 1][0][j - 1];\t\n\t}\n\tfor(int i = m / 2 + 1; i <= n / 2; i++)\n\t{\n\t\t//none\n\t\tfor(int j = 0; j <= m + 1; j++) \n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][0][0] = ADD(f[i][0][0], f[i - 1][j][k]);\n\t\tfor(int j = 1; j <= i - m / 2; j++) f[i][0][0] = ADD(f[i][0][0], g[i - 1][j]);\n\t\t//left\n\t\tg[i][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - 1; j++) g[i][1] = ADD(g[i][1], f[i - 1][0][j]);\n\t\tfor(int j = 2; j <= i - m / 2; j++) g[i][j] = g[i - 1][j - 1];\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][j][0] = ADD(f[i][j][0], f[i - 1][j - 1][k]);\n\t\t//right\n\t\tfor(int j = 0; j <= m + 1; j++) f[i][0][1] = ADD(f[i][0][1], f[i - 1][j][0]);\n\t\tfor(int j = 1; j <= i - m / 2 - 1; j++) f[i][0][1] = ADD(f[i][0][1], g[i - 1][j]);\n\t\tfor(int j = 2; j <= i; j++) \n\t\t{\n\t\t\tf[i][0][j] = f[i - 1][0][j - 1];\n\t\t\tfor(int k = 2; k <= m + 1; k++) f[i][0][j] = ADD(f[i][0][j], f[i - 1][k][j - 1]);\n\t\t}\n\t\t//both\n\t\tf[i][2][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - m / 2 - 1; j++) f[i][2][1] = ADD(f[i][2][1], g[i - 1][j]);\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t{\n\t\t\tf[i][j][j - 1] = f[i - 1][0][j - 2];\n\t\t\tfor(int k = 1; k <= i; k++) f[i][j][k] = ADD(f[i][j][k], f[i - 1][j - 1][k - 1]);\n\t\t}\n\t}\n\tint last = n - n / 2 + m / 2;\n\tfor(int i = n / 2 + 1; i <= last; i++)\n\t{\n\t\tfor(int j = 0; j <= m + 1; j++) \n\t\t\tfor(int k = 0; k <= n / 2; k++)\n\t\t\t\tf[i][0][0] = ADD(f[i][0][0], f[i - 1][j][k]);\n\t\tfor(int j = 1; j <= i - m / 2; j++) f[i][0][0] = ADD(f[i][0][0], g[i - 1][j]);\n\n\t\tg[i][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - 1; j++) g[i][1] = ADD(g[i][1], f[i - 1][0][j]);\n\t\tfor(int j = 2; j <= i - m / 2; j++) g[i][j] = g[i - 1][j - 1];\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][j][0] = ADD(f[i][j][0], f[i - 1][j - 1][k]);\n\t}\n\tint ans = f[last][0][0];\n\tfor(int j = 1; j <= n / 2; j++) ans = ADD(ans, f[last][0][j]);\n\tfor(int i = 2; i <= m + 1; i++) \n\t\tfor(int j = 0; j <= n / 2; j++) ans = ADD(ans, f[last][i][j]);\n\tfor(int i = 1; i <= n - n / 2; i++) ans = ADD(ans, g[last][i]);\n\treturn ans;\n}\n\ninline int solve2(int n)\n{\n\tmemset(g, 0, sizeof(g));\n\tint ans = 1;\n\tg[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j <= min(i - 1, m / 2); j++) g[i][0] = ADD(g[i][0], g[i - 1][j]);\n\t\tfor(int j = 1; j <= min(i, m / 2); j++)\n\t\t\tg[i][j] = g[i - 1][j - 1], ans = ADD(ans, g[i][j]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &mod);\n\tif(m & 1) printf(\"%d\", solve1());\n\telse printf(\"%d\", 1ll * solve2(n / 2) * solve2(n - n / 2) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint MOD;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline void Add(int &a,int b)\n{a+=b;a>=MOD?a-=MOD:1;}\nusing namespace std;\nconst int Q=156;\nint pp[Q];\nint f[2][Q][Q];\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d%d\",&n,&k,&MOD);\n\tif((k&1)^1){\n\t\tpp[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=0;j<=(k>>1)&&j<i;j++)\n\t\t\t\tpp[i]=add(pp[i],pp[i-j-1]);\n\t\treturn 0&printf(\"%lld\\n\",1LL*pp[(n>>1)+1]*pp[n-(n>>1)+1]%MOD);\n\t}\n\tint now=0,nxt=1;\n\tfor(int pi=1,i=(k>>1)+1;i>=0;--i){\n\t\tf[now][0][i]=pi;\n\t\tif(i!=(k>>1)+1)pi=add(pi,pi);\n\t}\n\tfor(int owo=2;owo<=n;owo+=2){\n\t\tfor(int i=0;i<=k+1;i++)\n\t\t\tfill(f[nxt][i],f[nxt][i]+k+2,0);\n\t\tfor(int i=0;i<=k+1;i++)\n\t\t\tfor(int j=0;j<=k+1;j++){\n\t\t\t\tif(owo+k<=n)Add(f[nxt][max(i+1,j+2)][min(j+1,k+1)],f[now][i][j]);\n\t\t\t\tAdd(f[nxt][i?i+1:0][0],f[now][i][j]);\n\t\t\t\tif(owo+k<=n)Add(f[nxt][0][min(j+1,k+1)],f[now][i][j]);\n\t\t\t\tAdd(f[nxt][0][0],f[now][i][j]);\n\t\t\t}\n\t\tnow^=1,nxt^=1;\n\t}\n\tint als=0;\n\tfor(int i=0;i<=k+1;i++)\n\t\tfor(int j=0;j<=k+1;j++)\n\t\t\tAdd(als,f[now][i][j]);\n\tprintf(\"%d\\n\",als);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=155;\nint n,K,P,f[N][N],g[2*N][N][N];\ninline void sol1()\n{\n\tK/=2;f[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=K;j++)f[i][0]=(f[i][0]+f[i-1][j])%P;\n\t\tfor(int j=0;j<K;j++)f[i][j+1]=(f[i][j+1]+f[i-1][j])%P;\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<=K;i++)ans1=(ans1+f[n/2][i])%P;\n\tfor(int i=0;i<=K;i++)ans2=(ans2+f[(n+1)/2][i])%P;\n\tprintf(\"%lld\\n\",1ll*ans1*ans2%P);\n}\ninline void sol2()\n{\n\tint p;g[0][0][0]=1;\n\tfor(int i=2;i-K<=n;p=i,i+=2)\n\t{\n\t\tfor(int j=0;j<=n;j++)for(int k=0;k<=K+1;k++)g[i][0][0]=(g[i][0][0]+g[i-2][j][k])%P;\n\t\tif(i<=n)for(int j=0;j<=n;j++)for(int k=0;k<=K+1;k++)g[i][j+1][0]=(g[i][j+1][0]+g[i-2][j][k])%P;\n\t\tif(i>K)for(int j=0;j<=n;j++)g[i][0][0]=(g[i][0][0]+g[i-2][j][0])%P;\n\t\tif(i>K)for(int j=0;j<=n;j++)for(int k=1;k<=K+1;k++)g[i][0][k+1]=(g[i][0][k+1]+g[i-2][j][k])%P;\n\t\tif(i<=n&&i>K)for(int j=0;j<=n;j++)for(int k=0;max(k,j+1)<=K;k++)g[i][j+1][max(k,j+1)+1]=(g[i][j+1][max(k,j+1)+1]+g[i-2][j][k])%P;\n\t}\n\tint ans=0;for(int i=0;i<=n;i++)for(int j=0;j<=K+1;j++)ans=(ans+g[p][i][j])%P;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&K,&P);\n\tif(K&1)sol2();else sol1();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 160;\n\nint N, M;\nll P;\n\nll solve_trival(int n, int m) {\n    ll F[MAX_N][MAX_N]; memset(F, 0, sizeof(F));\n    F[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= m; j++) {\n            (F[i + 1][0] += F[i][j]) %= P;\n            (F[i + 1][j + 1] += F[i][j]) %= P;\n        }\n    }\n    ll res = 0;\n    for (int i = 0; i <= m; i++) (res += F[n][i]) %= P;\n    return res;\n}\n\nvoid solve() {\n    static ll curr[MAX_N][MAX_N][MAX_N], old[MAX_N][MAX_N][MAX_N];\n    curr[0][0][N + 1] = 1;\n    for (int i = 1; i <= N; i++) {\n        memcpy(old, curr, sizeof(curr));\n        memset(curr, 0, sizeof(curr));\n        for (int j = 0; j < i; j++) {\n            for (int k = 0; k < i; k++) {\n                for (int l = 1; l <= N + 1; l++) {\n                    {\n                        int nj = k + 1, nk = j;\n                        if (j <= k) {\n                            (curr[nj][nk][l - 1] += old[j][k][l]) %= P;\n                        } else {\n                            int t = (M + 1) / 2, nl = l;\n                            if (j >= t) {\n                                nl = min(nl, t - nj + 1);\n                            }\n                            (curr[nj][nk][nl] += old[j][k][l]) %= P;\n                        }\n                    }\n                    {\n                        int nj = 0, nk = j;\n                        if (j <= k) {\n                            (curr[nj][nk][N + 1] += old[j][k][l]) %= P;\n                        } else {\n                            (curr[nj][nk][l] += old[j][k][l]) %= P;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i <= N; i++)\n        for (int j = 0; j <= N; j++)\n            for (int k = 1; k <= N + 1; k++)\n                (ans += curr[i][j][k]) %= P;\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    scanf(\"%d%d%lld\", &N, &M, &P);\n    if (!(M & 1)) {\n        ll ans = solve_trival((N + 1) / 2, M / 2) * solve_trival(N / 2, M / 2) % P;\n        printf(\"%lld\\n\", ans);\n    } else {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=159;\nint MOD;\ninline int add(int a,int b) {return a+=b,a>=MOD?a-MOD:a;}\ninline int del(int a,int b) {return a-=b,a<0?a+MOD:a;}\ninline int mul(int a,int b) {return 1LL*a*b%MOD;}\ninline int quicKpower(int a,int b)\n{\n\tint i,s;\n\tfor(i=a,s=1;b;b>>=1,i=mul(i,i))\n\t\tif(b&1) s=mul(s,i);\n\treturn s;\n}\nint N,K;\nint dp_[MAXN][MAXN],dp__[MAXN<<1][MAXN][MAXN];\ninline void solve_even()\n{\n\tint ans_=0,ans__=0;\n\tK>>=1,dp_[0][0]=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=0;j<=K;j++) dp_[i][0]=add(dp_[i][0],dp_[i-1][j]);\n\t\tfor(int j=0;j<K;j++) dp_[i][j+1]=add(dp_[i][j+1],dp_[i-1][j]);\n\t}\n\tfor(int i=0;i<=K;i++) ans_=add(ans_,dp_[N>>1][i]),ans__=add(ans__,dp_[(N+1)>>1][i]);\n\tcout<<mul(ans_,ans__)<<endl;\n\treturn;\n}\ninline void solve_odd()\n{\n\tint p,ans=0;\n\tdp__[0][0][0]=1;\n\tfor(int i=2;i<=N+K;i+=2)\n\t{\n\t\tfor(int j=0;j<=N;j++)\n\t\t\tfor(int k=0;k<=K+1;k++) dp__[i][0][0]=add(dp__[i][0][0],dp__[i-2][j][k]);\n\t\tif(i<=N)\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;k<=K+1;k++) dp__[i][j+1][0]=add(dp__[i][j+1][0],dp__[i-2][j][k]);\n\t\tif(i>=K+1)\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=K;k++) dp__[i][0][k+1]=add(dp__[i][0][k+1],dp__[i-2][j][k]);\n\t\t\t\tdp__[i][0][0]=add(dp__[i][0][0],dp__[i-2][j][0]);\n\t\t\t}\n\t\tif(i<=N&&i>=K+1)\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;max(k,j+1)<=K;k++) dp__[i][j+1][max(k,j+1)+1]=add(dp__[i][j+1][max(k,j+1)+1],dp__[i-2][j][k]);\n\t\tp=i;\n\t}\n\tfor(int i=0;i<=N;i++)\n\t\tfor(int j=0;j<=K+1;j++) ans=add(ans,dp__[p][i][j]);\n\tcout<<ans<<endl;\n\treturn;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>N>>K>>MOD;\n\tif(!(K&1)) solve_even();\n\telse solve_odd();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define ll long long\nusing namespace std;\nconst int N=360;\nint mod;\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod;  }\nint solve0(int n,int k) { // you can't choose k consecutive integers\n\tstatic int f[N];\n\tf[0]=1;\n\tfor(int i=1;i<=n+1;++i) {\n\t\tf[i]=0;\n\t\tfor(int j=i-1;i-j-1<k&&j>=0;--j)\n\t\t\tf[i]=(f[i]+f[j])%mod;\n\t}\n\treturn f[n+1];\n}\nint solve1(int n,int k) { // k is odd, k!=1\n\tstatic int f[N][N][N];\n\tf[1][0][0]=1;\n\tf[1][1][0]=1;\n\tfor(int i=2;i*2-k<=n;++i) {\n\t\tint a=2*i,b=2*i-k;\n\t\tfor(int j=0;j<=i-1;++j) // go down\n\t\t\tfor(int l=0;l<=i-1;++l) if(f[i-1][j][l]) { // go down - left - down\n\t\t\t//\tcout<<i-1<<' '<<j<<' '<<l<<':'<<f[i-1][j][l]<<endl;\n\t\t\t\tif(b<0) {\n\t\t\t\t\tAdd(f[i][0][0],f[i-1][j][l]);\n\t\t\t\t\tAdd(f[i][j+1][0],f[i-1][j][l]);\n\t\t\t\t}\n\t\t\t\telse if(a>n) {\n\t\t\t\t\tAdd(f[i][0][0],f[i-1][j][l]);\n\t\t\t\t\tif(l) { if(l<k) Add(f[i][0][l+1],f[i-1][j][l]); }\n\t\t\t\t\telse Add(f[i][0][0],f[i-1][j][l]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int s=0;s<4;++s) {\n\t\t\t\t\t\tint x=s&1,y=s&2;\n\t\t\t\t\t\tint j1=x?j+1:0;\n\t\t\t\t\t\tint l1=(y&&l)?l+1:0;\n\t\t\t\t\t\tif(x&&y) l1=max(l1,j+1);\n\t\t\t\t\t\tif(l1>=k+1) continue; \n\t\t\t\t\t\tAdd(f[i][j1][l1],f[i-1][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=(n+k)/2;++j)\n\t\tfor(int l=0;l<=k;++l) if(f[(n+k)/2][j][l])\n\t\t\tans=(ans+f[(n+k)/2][j][l])%mod;//,cout<<(n+k)/2<<' '<<j<<' '<<l<<':'<<f[(n+k)/2][j][l]<<endl;\n\treturn ans;\n}\nint main() { \n\tint n,k;\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tif(k==1) { printf(\"%d\\n\",solve0(n,3)); return 0; }\n\tif(k%2==0) {\n\t\tk/=2;\n\t\tprintf(\"%d\\n\",(int)(solve0(n/2,k+1)*1ll*solve0((n+1)/2,k+1)));\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",solve1(n,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=155;\nint n,k,M,f[N][N],g[N];\nmap<ll,int> Map;\nll calc(int a,int b,int c,int d,int e){\n\treturn (ll)a*(n+2)*(n+2)*(n+2)*(n+2)+(ll)b*(n+2)*(n+2)*(n+2)+(ll)c*(n+2)*(n+2)+d*(n+2)+e;\n}\nint dfs(int x,int p,int q,int fp,int fq){\n\tif (x>n)return 1;\n\tll VV=calc(x,p,q,fp,fq);\n\tif (Map.count(VV))return Map[VV];\n\tif (x&1){\n\t\tMap[VV]=dfs(x+1,0,q,n+1,fq);\n\t\tif (fp>x){\n\t\t\tif (x+1-2*q+k<=x)(Map[VV]+=dfs(x+1,p+1,q,fp,min(fq,x-2*p-k)))%=M;\n\t\t\telse (Map[VV]+=dfs(x+1,p+1,q,fp,fq))%=M;\n\t\t}\n\t}\n\telse {\n\t\tMap[VV]=dfs(x+1,p,0,fp,n+1);\n\t\tif (fp>x){\n\t\t\tif (x+1-2*p+k<=x)(Map[VV]+=dfs(x+1,p,q+1,min(fp,x-2*p-k),fq))%=M;\n\t\t\telse (Map[VV]+=dfs(x+1,p,q+1,fp,fq))%=M;\n\t\t}\n\t}\n\treturn Map[VV];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&M);\n\tif (k%2==0){\n\t\tk/=2;\n\t\tf[0][0]=1;\n\t\tg[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tfor (int j=0;j<=k;j++)\n\t\t\t\tf[i][j]=j==0?g[i-1]:f[i-1][j-1];\n\t\t\tfor (int j=0;j<=k;j++)(g[i]+=f[i][j])%=M;\n\t\t}\n\t\tprintf(\"%d\\n\",(ll)g[n/2]*g[n/2+n%2]%M);\n\t}\n\tprintf(\"%d\\n\",dfs(1,0,0,N+1,N+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 14.07.2019 16:42:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nMint Easy(int n, int k) {\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(k + 1));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= k; j++) {\n      dp[i + 1][0] += dp[i][j];\n      if (j < k) {\n        dp[i + 1][j + 1] += dp[i][j];\n      }\n    }\n  }\n  return accumulate(dp.back().begin(), dp.back().end(), Mint(0));\n}\n\nMint dp[2][77][77][77][77];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k >> md;\n  if (k % 2 == 0) {\n    cout << Easy(n / 2, k / 2) * Easy(n - n / 2, k / 2) << '\\n';\n    return 0;\n  }\n  auto maxMyL = [&](int i) {\n    return i / 2;\n  };\n  auto maxHisL = [&](int i) {\n    return i - i / 2;\n  };\n  auto maxMyR = [&](int i) {\n    return (n - i) - (n - i) / 2;\n  };\n  auto maxHisR = [&](int i) {\n    return (n - i) / 2;\n  };\n  for (int i = 0; i <= n; i++) {\n//    debug(i, maxMyL(i), maxHisL(i), maxMyR(i), maxHisR(i));\n  }\n  dp[0][0][0][maxMyR(0)][maxHisR(0)] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int myL = 0; myL <= maxMyL(i + 1); myL++) {\n      for (int hisL = 0; hisL <= maxHisL(i + 1); hisL++) {\n        for (int myR = 0; myR <= maxMyR(i + 1); myR++) {\n          for (int hisR = 0; hisR <= maxHisR(i + 1); hisR++) {\n            dp[(i & 1) ^ 1][myL][hisL][myR][hisR] = 0;\n          }\n        }\n      }\n    }\n    for (int myL = 0; myL <= maxMyL(i); myL++) {\n      for (int hisL = 0; hisL <= maxHisL(i); hisL++) {\n        for (int myR = 0; myR <= maxMyR(i); myR++) {\n          for (int hisR = 0; hisR <= maxHisR(i); hisR++) {\n            auto ft = dp[i & 1][myL][hisL][myR][hisR];\n            if (ft == 0) {\n              continue;\n            }\n            { // place good\n              int newMyL = hisL;\n              int newHisL = 0;\n              int newMyR = hisR;\n              int newHisR = maxHisR(i + 1);\n              dp[(i & 1) ^ 1][newMyL][newHisL][newMyR][newHisR] += ft;\n//              debug(i + 1, \"g\", myL, hisL, myR, hisR, newMyL, newHisL, newMyR, newHisR);\n            }\n            if (myR > 0) {\n              int newMyL = hisL;\n              int newHisL = myL + 1;\n              int newMyR = hisR;\n              int newHisR = myR - 1;\n              if (newHisL >= 1) {\n                int mid = min(k + 2, min(2 * newHisL + 1, 2 * newMyL + 1));\n                int need = (k + 2 - mid) / 2;\n                int extra = newMyL - mid / 2;\n                if (extra >= need) {\n                  newMyR = min(newMyR, need);\n                }\n              }\n              dp[(i & 1) ^ 1][newMyL][newHisL][newMyR][newHisR] += ft;\n//              debug(i + 1, \"b\", myL, hisL, myR, hisR, newMyL, newHisL, newMyR, newHisR);\n            }\n          }\n        }\n      }\n    }\n  }\n  Mint ans = 0;\n  for (int myL = 0; myL <= maxMyL(n); myL++) {\n    for (int hisL = 0; hisL <= maxHisL(n); hisL++) {\n      ans += dp[n & 1][myL][hisL][0][0];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 153;\n\nint mo;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\n\nint n,tran;\n\nnamespace whentraniseven\n{\n\tlint f[_][_];\n\t\n\tint main()\n\t{\n\t\tmemset(f,0,sizeof(f)),f[0][0]=1;\n\t\tint lim=tran/2,len=(n+1)/2;\n\t\tfor(int i=1;i<=len;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=lim;j++)ad(f[i][0],f[i-1][j]);\n\t\t\tfor(int j=1;j<=lim;j++)ad(f[i][j],f[i-1][j-1]);\n\t\t}\n\n\t\tlint anse=0,anso=0;\n\t\tfor(int i=0;i<=lim;i++)ad(anse,f[n/2][i]);\n\t\tfor(int i=0;i<=lim;i++)ad(anso,f[(n+1)/2][i]);\n\t\tprintf(\"%lld\\n\",anse*anso%mo);\n\n\t\treturn 0;\n\t}\n}\n\nnamespace whentranisodd\n{\n\tlint f[_][_][_];\n\n\tint main()\n\t{\n\t\tmemset(f,0,sizeof(f)),f[0][0][0]=1;\n\t\tint lim=tran+1;\n\t\t\n\t\tfor(int i=1;i+i-tran<=n;i++)\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tfor(int k=0;k<=lim;k++)\n\t\t\t\t{\n\t\t\t\t\tif(!f[i-1][j][k])continue;\n\t\t\t\t\tlint x=f[i-1][j][k];\n\t\t\t\t\tad(f[i][0][0],x);\n\t\t\t\t\tif(i+i<=n)ad(f[i][j+1][0],x);\n\t\t\t\t\tif(i+i-tran>=1)ad(f[i][0][k==0?0:k+1],x);\n\t\t\t\t\tif(i+i<=n && i+i-tran>=1)ad(f[i][j+1][max(j+2,k+1)],x);\n\t\t\t\t}\n\t\t\n\t\tlint ans=0;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\tad(ans,f[(n+tran)/2][i][j]);\n\t\tprintf(\"%lld\\n\",ans);\n\n\t\treturn 0;\n\t}\n}\n\nint main()\n{\n\tn=ty(),tran=ty(),mo=ty();\n\n\tif(tran%2==0)return whentraniseven::main();\n\treturn whentranisodd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define MN 155\n\nint mod, n, l;\nint inc(int a, int b) {return (a += b) >= mod ? a - mod : a;}\n\nint qpow(int x, int p)\n{\n\tif(p < 0) return 1;\n\tint ans = 1;\n\tfor(; p; p >>= 1, x = 1ll * x * x % mod) if(p & 1) ans = 1ll * ans * x % mod;\n\treturn ans;\n}\n\nnamespace solve1{\n\tint f[MN];\n\tint calc(int n)\n\t{\n\t\tf[0] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tf[i] = ((2 * f[i - 1] - (i - l / 2 - 2 < -1 ? -1 : (i - l / 2 - 2 < 0 ? 0 : f[i - l / 2 - 2]))) % mod + mod) % mod;\n\t\treturn f[n] - f[n - 1] + mod;\n\t}\n}\n\nnamespace solve2{\n\t\n\tint f[MN][MN][MN];\n\tint calc()\t\n\t{\n\t\tf[0][0][0] = 1;\n\t\tfor(int i = 0; i < (n + 1 >> 1); i++)\n\t\t\tfor(int j = 0; j <= l + 1; j++)\n\t\t\t\tfor(int k = 0; k <= l + 1; k++)\n\t\t\t\t{\n\t\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\t\tif(j && k && j + k >= l + 2) continue;\n\t\t\t\t\tif(j)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i + 1][j - 1][std::min(k + 1, l + 1)] = inc(f[i + 1][j - 1][std::min(k + 1, l + 1)], f[i][j][k]);\n\t\t\t\t\t\tf[i + 1][j - 1][0] = inc(f[i + 1][j - 1][0], f[i][j][k]);\n\t\t\t\t\t\tif(j == l + 1 && 2 * (i + 1) - 1 - l + 2 * (j - 1) <= n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf[i + 1][j][std::min(k + 1, l + 1)] = inc(f[i + 1][j][std::min(k + 1, l + 1)], f[i][j][k]);\n\t\t\t\t\t\t\tf[i + 1][j][0] = inc(f[i + 1][j][0], f[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(2 * (i + 1) - 1 - l >= 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int o = 1; o <= l + 1; o++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(2 * (i + 1) - 1 - l + 2 * (o - 1) > n) continue;\n\t\t\t\t\t\t\t\tf[i + 1][o][std::min(k + 1, l + 1)] = inc(f[i + 1][o][std::min(k + 1, l + 1)], f[i][j][k]);\n\t\t\t\t\t\t\t\tf[i + 1][o][0] = inc(f[i + 1][o][0], f[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf[i + 1][0][std::min(k + 1, l + 1)] = inc(f[i + 1][0][std::min(k + 1, l + 1)], f[i][j][k]);\n\t\t\t\t\t\tf[i + 1][0][0] = inc(f[i + 1][0][0], f[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tint ans = 0;\n\t\tfor(int j = 0; j <= l + 1; j++)\n\t\t\tfor(int k = 0; k <= l + 1; k++)\n\t\t\t{\n\t\t\t\tif(j && k && j + k >= l + 2) continue;\n\t\t\t\tans = inc(ans, 1ll * f[(n + 1) >> 1][j][k] * qpow(2, (n - ((n + 1) / 2 * 2 - 1 - l + 2 * j)) / 2) % mod);\n\t\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &l, &mod);\n\tif(l & 1) printf(\"%d\\n\", solve2::calc());\n\telse printf(\"%lld\\n\", 1ll * solve1::calc(n / 2) * solve1::calc(n - n / 2) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 153;\nint N , K , M;\nvoid inc(int &a , int b){a = a + b >= M ? a + b - M : a + b;}\n\nnamespace solve1{\n#define PII pair < int , int >\n\tmap < PII , int > dp[_][_][_];\n\n\tvoid ins(int i , int j , int k , int pj , int pk , int val){\n\t}\n\t\n\tvoid main(){\n\t\tdp[0][0][0][PII(N + 1 , N + 1)] = 1;\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tfor(int j = 0 ; j <= N ; ++j)\n\t\t\t\tfor(int k = 0 ; k <= N ; ++k)\n\t\t\t\t\tfor(auto t : dp[i][j][k]){\n\t\t\t\t\t\tint pj = t.first.first , pk = t.first.second , val = t.second;\n\t\t\t\t\t\tif(!(i & 1)){\n\t\t\t\t\t\t\tinc(dp[i + 1][0][k][PII(N + 1 , pk)] , val);\n\t\t\t\t\t\t\tif(i + 1 != pj)\n\t\t\t\t\t\t\t\tif(i + 2 - 2 * k + K <= i + 1 && i + 1 - 2 * j + K > i)\n\t\t\t\t\t\t\t\t\tinc(dp[i + 1][j + 1][k][PII(pj , min(pk , i + 1 - 2 * j + K))] , val);\n\t\t\t\t\t\t\t\telse inc(dp[i + 1][j + 1][k][PII(pj , pk)] , val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tinc(dp[i + 1][j][0][PII(pj , N + 1)] , val);\n\t\t\t\t\t\t\tif(i + 1 != pk)\n\t\t\t\t\t\t\t\tif(i + 2 - 2 * j + K <= i + 1 && i + 1 - 2 * k + K > i)\n\t\t\t\t\t\t\t\t\tinc(dp[i + 1][j][k + 1][PII(min(pj , i + 1 - 2 * k + K) , pk)] , val);\n\t\t\t\t\t\t\t\telse inc(dp[i + 1][j][k + 1][PII(pj , pk)] , val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int j = 0 ; j <= N ; ++j) for(int k = 0 ; k <= N ; ++k) for(auto t : dp[N][j][k]) inc(cnt , t.second);\n\t\tcout << cnt;\n\t}\n}\n\nnamespace solve2{\n\tint dp[153];\n\tvoid main(){\n\t\tdp[0] = 1; int len = K / 2 + 1;\n\t\tfor(int i = 1 ; i <= N / 2 + 1 ; ++i) dp[i] = (dp[i - 1] * 2ll - (i >= len ? dp[i - len - (i != len)] : 0) + M) % M;\n\t\tcout << 1ll * dp[N / 2] * dp[N / 2 + (N & 1)] % M;\n\t}\n}\n\nint main(){\n\tcin >> N >> K >> M;\n\tif(K & 1) solve1::main(); else solve2::main();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <string>\n#include <cmath>\n#include <cassert>\n#define SIZE 155\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll dp1[2][SIZE];\nll dp[2][SIZE][SIZE][SIZE];\n\nint main()\n{\n\tint n,K,MOD;\n\tscanf(\"%d %d %d\",&n,&K,&MOD);\n\tif(K%2==0)\n\t{\n\t\tll ret=1;\n\t\tfor(int t=0;t<2;t++)\n\t\t{\n\t\t\tint len=(n-t+1)/2;\n\t\t\tint pos=0;\n\t\t\tmemset(dp1,0,sizeof(dp1));\n\t\t\tdp1[pos][0]=1;\n\t\t\tfor(int i=0;i<len;i++)\n\t\t\t{\n\t\t\t\tpos=1-pos;\n\t\t\t\tmemset(dp1[pos],0,sizeof(dp1[pos]));\n\t\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t\t{\n\t\t\t\t\tdp1[pos][j+1]+=dp1[1-pos][j];\n\t\t\t\t\tif(dp1[pos][j+1]>=MOD) dp1[pos][j+1]-=MOD;\n\t\t\t\t\tdp1[pos][0]+=dp1[1-pos][j];\n\t\t\t\t\tif(dp1[pos][0]>=MOD) dp1[pos][0]-=MOD;\n\t\t\t\t}\n\t\t\t\tfor(int j=K/2+1;j<=i+1;j++) dp1[pos][j]=0;\n\t\t\t}\n\t\t\tll sum=0;\n\t\t\tfor(int j=0;j<=len;j++)\n\t\t\t{\n\t\t\t\tsum+=dp1[pos][j];\n\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t}\n\t\t\tret=ret*sum%MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n\telse\n\t{\n\t\tint pos=0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[pos][0][0][n]=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpos=1-pos;\n\t\t\tint even=i/2+1,odd=(i+1)/2;\n\t\t\tfor(int j=0;j<=even;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=odd;k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int t=i;t<=n;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[pos][j][k][t]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=even;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=odd;k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int t=i;t<=n;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(dp[1-pos][j][k][t]==0) continue;\n\t\t\t\t\t\t//unset i\n\t\t\t\t\t\t//int to=((t==n||t%2==i%2)?n:t);\n\t\t\t\t\t\tint to=(t%2==i%2?n:t);\n\t\t\t\t\t\tdp[pos][0][j][to]+=dp[1-pos][j][k][t];\n\t\t\t\t\t\tif(dp[pos][0][j][to]>=MOD) dp[pos][0][j][to]-=MOD;\n\t\t\t\t\t\t//set i\n\t\t\t\t\t\tif(t!=i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(j>=K/2+1) to=min(t,i-2*k+K);\n\t\t\t\t\t\t\telse to=t;\n\t\t\t\t\t\t\tdp[pos][k+1][j][to]+=dp[1-pos][j][k][t];\n\t\t\t\t\t\t\tif(dp[pos][k+1][j][to]>=MOD) dp[pos][k+1][j][to]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}/*\n\t\t\tprintf(\"+ %d\\n\",i);\n\t\t\tfor(int j=0;j<=even;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=odd;k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int t=i;t<=n;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(dp[pos][j][k][t]!=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"[%d %d %d] %lld\\n\",j,k,t,dp[pos][j][k][t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}puts(\"\");*/\n\t\t}\n\t\tll ret=0;\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tret+=dp[pos][j][k][n];\n\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 155 \nusing namespace std;\ntypedef long long ll;\nint n,k;\nll mod;\n\nnamespace s1\n{\t\n\tll f[N][N][N],ans;\n\tvoid solve()\n\t{\n\t\tf[0][0][0] = f[1][0][0] = f[1][1][0] = 1;\n\t\tfor(int i=2;i<=n;++i)\n\t\t{\n\t\t\tif(i & 1) for(int j=0;j<=k / 2;++j) \n\t\t\t{\n\t\t\t\tfor(int t=0;t<=k / 2;++t)\n\t\t\t\t{\n\t\t\t\t\tif(t + 1 <= k / 2) f[i][t + 1][j] = (f[i][t + 1][j] + f[i - 1][t][j]) % mod;\n\t\t\t\t\tf[i][0][j] = (f[i][0][j] + f[i - 1][t][j]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse for(int j=0;j<=k / 2;++j)\n\t\t\t{\n\t\t\t\tfor(int t=0;t<=k / 2;++t)\n\t\t\t\t{\n\t\t\t\t\tif(t + 1 <= k / 2) f[i][j][t + 1] = (f[i][j][t + 1] + f[i - 1][j][t]) % mod;\n\t\t\t\t\tf[i][j][0] = (f[i][j][0] + f[i - 1][j][t]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=k / 2;++i)\n\t\t  for(int j=0;j<=k / 2;++j)\n\t\t    ans = (ans + f[n][i][j]) % mod;\n\t\tcout<<ans<<endl;\n\t}\n}\nnamespace s2\n{\n\tll f[N][N][N],ans;\n\tvoid solve()\n\t{\n\t\tf[0][0][0] = 1;\n\t\tfor(int i=2;i - k < 0;i+=2)//先处理只有右边的一段 \n\t\t{\n\t\t\tint now = i / 2;\n\t\t\tfor(int j=0;j<now;++j) f[now][0][0] = (f[now][0][0] + f[now - 1][0][j]) % mod;\n\t\t\tfor(int j=0;j<now;++j) f[now][0][j + 1] = (f[now][0][j + 1] + f[now - 1][0][j]) % mod;\n\t\t} \n\t\tint las = 0;\n\t\tfor(int i=1;i<=n;i+=2)\n\t\t{\n\t\t\tint now = (i + k) / 2;\n\t\t\tlas = now;\n\t\t\t//都不选\n\t\t\tfor(int j=0;j<=k + 1;++j) \n\t\t\t  for(int t=0;t<now;++t)\n\t\t\t    f[now][0][0] = (f[now][0][0] + f[now - 1][j][t]) % mod;\n\t\t\t//只选左边\n\t\t\tfor(int j=0;j<=k;++j) \n\t\t\t  for(int t=0;t<now;++t)\n\t\t\t    f[now][j + (j!=0)][0] = (f[now][j + (j!=0)][0] + f[now - 1][j][t]) % mod;\n\t\t\tif(i + k > n) continue;\n\t\t\t//只选右边\t\n\t\t\tfor(int j=0;j<=k + 1;++j) \n\t\t\t  for(int t=0;t<now;++t)\n\t\t\t    f[now][0][t + 1] = (f[now][0][t + 1] + f[now - 1][j][t]) % mod;\n\t\t\t//两边都选\n\t\t\tfor(int j=0;j<=k;++j) \n\t\t\t  for(int t=0;t<now;++t)\n\t\t\t    if(t + 2 <= k + 1) f[now][max(j + (j!=0),t + 2)][t + 1] = (f[now][max(j + (j!=0),t + 2)][t + 1] + f[now - 1][j][t]) % mod;\n\t\t}\n\t\tfor(int i=0;i<=k + 1;++i)\n\t\t  for(int t=0;t<=las;++t)\n\t\t    ans = (ans + f[las][i][t]) % mod;\n\t\tcout<<ans<<endl;\n\t}\n}\n\nint main()\n{\n\tcin>>n>>k>>mod;\n\tif(!(k & 1)) s1::solve();\n\telse s2::solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint MOD;\n\ninline void add(int &x,int y) {\n  ((x+=y)>=MOD)?x-=MOD:0;\n}\n\nint f[2][155][155],g[155][155];\n\nint dp1(int n,int m) {\n  if (m>n-2) {\n  \tint s=1;\n  \tfor(int i=1;i<=n;i++) s=s*2LL%MOD;\n  \treturn s;\n  }\n  m>>=1;\n  int u=((n+1)>>1),v=n-u,cur=0;\n  for(int i=0;i<=u;i++) f[0][i][0]=1;\n  for(int i=1;i<=m;i++) {\n  \tcur^=1;\n  \tmemset(f[cur],0,sizeof(f[cur]));\n  \tfor(int j=0;j<=u;j++)\n  \tfor(int k=0;k<i;k++)\n  \t  if (f[cur^1][j][k]) {\n  \t  \t  add(f[cur][j][0],f[cur^1][j][k]);\n  \t  \t  add(f[cur][j][k+1],f[cur^1][j][k]);\n\t\t}\n  }\n  for(int i=m+1;i<=v;i++) {\n  \tcur^=1;\n  \tmemset(f[cur],0,sizeof(f[cur]));\n  \tint r=u-i+m+1;\n  \tfor(int j=1;j<=r;j++)\n  \tfor(int k=0;k<i;k++)\n  \t  if (f[cur^1][j][k]) {\n  \t  \t  add(f[cur][j-1][0],f[cur^1][j][k]);\n  \t  \t  if (2*m-k+2>j) add(f[cur][j-1][k+1],f[cur^1][j][k]);\n\t\t}\n\tfor(int j=0;j<r;j++)\n\tfor(int k=0;k<i;k++)\n\t  if (f[cur^1][0][k]) {\n\t  \t  add(f[cur][j][0],f[cur^1][0][k]);\n\t  \t  add(f[cur][j][k+1],f[cur^1][0][k]);\n\t  }\n  }\n  for(int i=v-m+1;i<=u;i++) {\n  \tcur^=1;\n  \tmemset(f[cur],0,sizeof(f[cur]));\n  \tint r=u-i+1;\n  \tfor(int j=1;j<=r;j++)\n  \tfor(int k=0;k<=v;k++)\n  \t  if (f[cur^1][j][k]) add(f[cur][j-1][k],f[cur^1][j][k]);\n  \tfor(int j=0;j<r;j++)\n  \tfor(int k=0;k<=v;k++)\n  \t  if (f[cur^1][0][k]) add(f[cur][j][k],f[cur^1][0][k]);\n  }\n  int ans=0;\n  for(int i=0;i<=v;i++) add(ans,f[cur][0][i]);\n  return ans;\n}\n\nint dp2(int n,int m) {\n  memset(g,0,sizeof(g));\n  g[0][0]=1;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<=i;j++)\n      if (g[i][j]) {\n      \tadd(g[i+1][0],g[i][j]);\n      \tif (j<m) add(g[i+1][j+1],g[i][j]);\n\t  }\n  int ans=0;\n  for(int i=0;i<=n;i++) add(ans,g[n][i]);\n  return ans;\n}\n\nint main() {\n  int n,m;\n  scanf(\"%d%d%d\",&n,&m,&MOD);\n  if (m&1) printf(\"%d\\n\",dp1(n,m));\n  else printf(\"%lld\\n\",(ll)dp2((n+1)>>1,m>>1)*dp2(n>>1,m>>1)%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 150\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,K,mod,KK,F[MN+5],f[MN+5],g[MN+5][MN+5],pw[MN+5],ans;\ninline void Re(int&x,int y){(x+=y)>=mod?x-=mod:0;}\nint Solve1(int n)\n{\n    f[0]=1;\n    for(int i=1;i<=n;++i)\n    {\n        F[i]=i<=K;\n        for(int j=max(1,i-K);j<i;++j) Re(F[i],f[j-1]);\n        f[i]=(f[i-1]+F[i])%mod;\n    }\n    return f[n];\n}\ninline int Odd(int x){return (x&1)?x:x-1;}\ninline int Even(int x){return (x&1)?x-1:x;}\nint main()\n{\n    n=read();K=read();mod=read();KK=K+1>>1;\n    if(~K&1) return K>>=1,printf(\"%d\\n\",1LL*Solve1(n/2)*Solve1(n+1>>1)%mod),0;//number of ways that only contain intervals no longer than K/2\n\tpw[0]=1;for(int i=1;i<=n;++i) pw[i]=2*pw[i-1]%mod;\n    if(K>=n) return 0*printf(\"%d\\n\",pw[n]);\n    for(int i=1;i<=KK;++i) g[0][i*2-1]=pw[max(0,i-2)];\n    g[0][0]=pw[KK-1];\n    for(int i=2;i+K<=n;i+=2)\n    {\n        for(int j=1;j<i+K;j+=2) Re(g[i][j],g[i-2][j]),Re(g[i][0],g[i-2][j]);\n        Re(g[i][i+K],g[i-2][0]);Re(g[i][0],g[i-2][0]);\n        for(int j=i;j<=n;j+=2) //new interval for even numbers: i->j\n        {\n            for(int k=0;k<i+K;k+=2-(k==0)) if(g[i-2][k])\n            {\n                int L=max(i+K,j-K+2),R=min(Odd(n),j+K+2);\n                if(k>0&&k+K<=j) L=max(L,i+K+2);\n                for(int l=L;l<=R;l+=2) \n                {\n                    if(l==i+K&&k) continue;\n                    int num=1LL*g[i-2][k]*pw[max(0,(l-L)/2-1)]%mod;\n                    Re(g[j+2][l],num);\n                }\n                if(L==i+K&&k) Re(g[j+2][k],g[i-2][k]);\n                int num0=1LL*g[i-2][k]*pw[max(0,(R-L)/2)]%mod;\n                Re(g[j+2][0],num0);\n            }\n        }\n    }\n    for(int i=0;i<=n+2;i+=2) if(i+K+2>n) \n        for(int j=0;j<=n;++j) Re(ans,1LL*g[i][j]*pw[max(0,Even(n)-i)/2]%mod);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int N = 155;\n\n#define ll long long\n\nint n, K, K2, Mod;\n\ntemplate <typename T>\nvoid fix(T& x) {\n\t(x >= Mod) && (x -= Mod);\n}\n\nnamespace subtask1 {\n\t\n\tint f[N][N];\n\tvoid solve() {\n\t\tint lim = (n + 1) >> 1;\n\t\tf[0][0] = 1;\n\t\tfor (int i = 1; i <= lim; i++) {\n\t\t\tfor (int j = 0; j < i && j <= K2; j++) {\n\t\t\t\tfix(f[i][j + 1] += f[i - 1][j]);\n\t\t\t\tfix(f[i][0] += f[i - 1][j]);\n\t\t\t}\n\t\t}\n\t\tint ans0 = 0, ans1 = 0;\n\t\tfor (int i = 0; i <= K2; i++)\n\t\t\tfix(ans0 += f[n >> 1][i]);\n\t\tfor (int i = 0; i <= K2; i++)\n\t\t\tfix(ans1 += f[lim][i]);\n\t\tans0 = 1ll * ans0 * ans1 % Mod;\n\t\tprintf(\"%d\\n\", ans0);\n\t}\n\n}\n\nnamespace subtask2 {\n\t\n\tint f[N][N][N];\n\tvoid solve() {\n\t\tf[0][0][0] = 1;\n\t\tfor (int i = 1; i <= n + 1; i++) {\n\t\t\tint r = i << 1, l = r - K;\n\t\t\tboolean have_r = (r >= 1 && r <= n), have_l = (l >= 1 && l <= n);\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tfor (int k = 0; k <= K + 1; k++) {\n\t\t\t\t\tint v = f[i - 1][j][k];\n\t\t\t\t\tif (!v)\n\t\t\t\t\t\tcontinue;\n#define F(nj, nk) ((nk) <= K + 1) && (fix(f[i][nj][(nk)] += v), 0)\n\t\t\t\t\tfix(f[i][0][0] += v);\n\t\t\t\t\tif (have_r)\n\t\t\t\t\t\tfix(f[i][j + 1][0] += v);\n\t\t\t\t\tif (have_l)\n\t\t\t\t\t\tF(0, (k ? k + 1 : 0));\n\t\t\t\t\tif (have_l && have_r)\n\t\t\t\t\t\tF(j + 1, max(j + 2, k + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", f[n + 1][0][0]);\n\t}\n\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &K, &Mod);\n\tK2 = K >> 1;\n\tif (K & 1) {\n\t\tsubtask2::solve();\n\t} else {\n\t\tsubtask1::solve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define pii pair<int,int>\n#define riterator reverse_iterator\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 150;\nllong P;\nint n,m;\n\nvoid updsum(llong &x,llong y) {x = x+y>=P?x+y-P:x+y;}\n\nnamespace Solve1\n{\n\tllong f[N+3];\n\tvoid solve()\n\t{\n\t\tm>>=1; f[0] = 1ll;\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor(int j=max(0,i-m-1); j<i; j++)\n\t\t\t{\n\t\t\t\tupdsum(f[i],f[j]);\n\t\t\t}\n\t\t}\n\t\tllong ans1 = 0ll,ans2 = 0ll;\n\t\tfor(int i=max(0,(n>>1)-m); i<=(n>>1); i++) updsum(ans1,f[i]);\n\t\tfor(int i=max(0,(n+1>>1)-m); i<=(n+1>>1); i++) updsum(ans2,f[i]);\n//\t\tprintf(\"ans1=%lld ans2=%lld\\n\",ans1,ans2);\n\t\tprintf(\"%lld\\n\",ans1*ans2%P);\n\t}\n}\n\nnamespace Solve2\n{\n\tllong f[N+3][N+3][N+3];\n\tvoid solve()\n\t{\n\t\tf[0][0][0] = 1ll;\n\t\tfor(int i=1; i+i-m<=n; i++)\n\t\t{\n\t\t\tfor(int j=0; j<=m+1; j++) for(int k=0; k<=n; k++)\n\t\t\t{\n\t\t\t\tupdsum(f[i][0][0],f[i-1][j][k]);\n\t\t\t}\n\t\t\tif(i+i<=n)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<=m+1; j++) for(int k=0; k<=n; k++)\n\t\t\t\t{\n\t\t\t\t\tupdsum(f[i][0][k+1],f[i-1][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i+i-m>=1)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<=m; j++) for(int k=0; k<=n; k++)\n\t\t\t\t{\n\t\t\t\t\tupdsum(f[i][j+(j>0)][0],f[i-1][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i+i<=n&&i+i-m>=1)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<=m; j++) for(int k=0; k<=n; k++)\n\t\t\t\t{\n\t\t\t\t\tint jj = max(j+1,k+2);\n\t\t\t\t\tif(jj<=m+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdsum(f[i][jj][k+1],f[i-1][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllong ans = 0ll;\n\t\tfor(int j=0; j<=m+1; j++) for(int k=0; k<=n; k++)\n\t\t{\n\t\t\tupdsum(ans,f[(n+m)>>1][j][k]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&m,&P);\n\tif(!(m&1)) {Solve1::solve();}\n\telse {Solve2::solve();}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 12/14/2019, 10:43:31 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\nll MOD{0};\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nistream &operator>>(istream &stream, Mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const Mint &a) { return stream << a.x; }\n\n// ----- main() -----\n\n// I wrote this code referring to yataka1999-san's solution\n// https://atcoder.jp/contests/agc035/submissions/6380939\n\nMint solve_even(ll N, ll K);\nMint solve_odd(ll N, ll K);\n\nMint solve_even(ll N, ll K)\n{\n  Mint ans{1};\n  for (auto t = 0LL; t < 2; t++)\n  {\n    auto L{(N - t + 1) / 2};\n    vector<Mint> to(L + 1), from(L + 1);\n    to[0] = 1;\n    for (auto i = 0LL; i < L; i++)\n    {\n      swap(to, from);\n      to = vector<Mint>(L + 1);\n      for (auto j = 0LL; j <= i; j++)\n      {\n        to[j + 1] += from[j];\n        to[0] += from[j];\n      }\n      for (auto j = K / 2 + 1; j <= i + 1; j++)\n      {\n        to[j] = 0;\n      }\n    }\n    Mint sum{0};\n    for (auto j = 0LL; j <= L; j++)\n    {\n      sum += to[j];\n    }\n    ans *= sum;\n  }\n  return ans;\n}\n\nMint solve_odd(ll N, ll K)\n{\n  vector<vector<vector<Mint>>> from(N + 1, vector<vector<Mint>>(N + 1, vector<Mint>(N + 1)));\n  vector<vector<vector<Mint>>> to(N + 1, vector<vector<Mint>>(N + 1, vector<Mint>(N + 1)));\n  to[0][0][N] = 1;\n  for (auto i = 0LL; i < N; i++)\n  {\n    swap(to, from);\n    to = vector<vector<vector<Mint>>>(N + 1, vector<vector<Mint>>(N + 1, vector<Mint>(N + 1)));\n    auto even{i / 2 + 1};\n    auto odd{(i + 1) / 2};\n    for (auto j = 0LL; j <= even; j++)\n    {\n      for (auto k = 0LL; k <= odd; k++)\n      {\n        for (auto t = i; t <= N; t++)\n        {\n          if (from[j][k][t] == 0)\n          {\n            continue;\n          }\n          auto dst{(t % 2 == i % 2) ? N : t};\n          to[0][j][dst] += from[j][k][t];\n          if (t != i)\n          {\n            dst = j >= K / 2 + 1 ? min(t, i - 2 * k + K) : t;\n            to[k + 1][j][dst] += from[j][k][t];\n          }\n        }\n      }\n    }\n  }\n  Mint ans{0};\n  for (auto j = 0LL; j <= N; j++)\n  {\n    for (auto k = 0LL; k <= N; k++)\n    {\n      ans += to[j][k][N];\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K;\n  cin >> N >> K >> MOD;\n  if (K % 2 == 0)\n  {\n    cout << solve_even(N, K) << endl;\n  }\n  else\n  {\n    cout << solve_odd(N, K) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=330;\nint n,P,L,T,ans,s1,s2,f[N][N],g[N][N][N];\nvoid chk(int&x){x-=P;x+=(x>>31)&P;}\nvoid work0(){\n\tf[0][0]=1;L>>=1;\n\tFOR(i,1,n)FOR(j,0,L){\n\t\tchk(f[i][0]+=f[i-1][j]);\n\t\tchk(f[i][j+1]+=f[i-1][j]);\n\t}\n\tFOR(j,0,L) chk(s1+=f[n>>1][j]),chk(s2+=f[n+1>>1][j]);\n\tcout<<1ll*s1*s2%P<<'\\n';\n}\nvoid work1(){\n\tT=n+(++L)>>1;g[0][0][0]=1;\n\tFOR(i,1,T)FOR(j,0,L)FOR(k,0,i){\n\t\tint w=g[i-1][j][k],x=2*i-1;\n\t\tchk(g[i][0][0]+=w);\n\t\tif(x>=L) chk(g[i][j?j+1:0][0]+=w);\n\t\tif(x<=n) chk(g[i][0][k+1]+=w);\n\t\tif(L<=x && x<=n) chk(g[i][max(j+1,k+2)][k+1]+=w);\n\t}\n\tFOR(j,0,L)FOR(k,0,n) chk(ans+=g[T][j][k]);\n\tcout<<ans<<'\\n';\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&L,&P);\n\tL%2==0?work0():work1();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int maxn = 155;\n\nclass State{\npublic:\n\tint s0, s1, mx0, mx1;\n\tState(int _s0, int _s1, int _mx0, int _mx1): s0(_s0), s1(_s1), mx0(_mx0), mx1(_mx1){}\n\tbool operator < (const State &o)const{return MP(MP(s0, s1), MP(mx0, mx1)) < MP(MP(o.s0, o.s1), MP(o.mx0, o.mx1));}\n};\n\nint n, k, INF;\nint f[maxn][maxn];\nmap<State, int> g[maxn];\n\ninline void uadd(int &x, int y){\n\t(x += y) %= INF;\n\treturn;\n}\n\ninline int mul(int x, int y){\n\treturn 1ll * x * y % INF;\n}\n\ninline int solve(int _n, int _k){\n\tmemset(f, 0, sizeof(f));\n\tf[0][0] = 1;\n\tFOR(i, 0, _n) REP(j, 0, _k){\n\t\tif(j != _k)\n\t\t\tuadd(f[i + 1][j + 1], f[i][j]);\n\t\tuadd(f[i + 1][0], f[i][j]);\n\t}\n\tint ret = 0;\n\t//printf(\"_n = %d _k = %d %d\\n\", _n, _k, f[_n][_k]);\n\tREP(i, 0, _k)\n\t\tuadd(ret, f[_n][i]);\n\treturn ret;\n}\n\ninline int dfs(int pos, int s0, int s1, int mx0, int mx1){\n\tif(pos == n)\n\t\treturn (mx0 == n && mx1 == n);\n\tif(mx0 < pos || mx1 < pos)\n\t\treturn 0;\n\ts0 = min(s0, (k >> 1) + 1);\n\ts1 = min(s1, (k >> 1) + 1);\n\tState cur = State(s0, s1, mx0, mx1);\n\tif(g[pos].find(cur) != g[pos].end())\n\t\treturn g[pos][cur];\n\tint mx0_ = n, mx1_ = n;\n\tif(pos % 2 == 0 && s1 * 2 - 1 >= k)\n\t\tmx1_ = pos + k - min(k / 2, s0) * 2;\n\tif(pos % 2 == 1 && s0 * 2 - 1 >= k)\n\t\tmx0_ = pos + k - min(k / 2, s1) * 2;\n\tint s0_ = s0 + (!(pos % 2)), s1_ = s1 + (pos % 2);\n\tint &ret = g[pos][cur];\n\tret = 0;\n\tuadd(ret, dfs(pos + 1, s0_, s1_, min(mx0, mx0_), min(mx1, mx1_)));\n\ts0_ = (pos % 2) ? s0 : 0;\n\ts1_ = (pos % 2) ? 0 : s1;\n\tuadd(ret, dfs(pos + 1, s0_, s1_, (pos % 2 ? mx0 : n), (pos % 2 ? n : mx1)));\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &k, &INF);\n\tif(!(k % 2)){\n\t\tprintf(\"%d\\n\", mul(solve(n / 2, k / 2), solve(n - n / 2, k / 2)));\n\t\treturn 0;\n\t}\n\tif(k == 1){\n\t\tprintf(\"%d\\n\", solve(n, 2));\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\", dfs(0, 0, 0, n, n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.7.22 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 1e18+1e9\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=150+10;\nnamespace MAIN{\n    int n,k,kcz;\n    int dp[N][N][N];\n    int f[N][N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline int solve(const res &n,const res &k){\n        for(res i=0;i<=n;i++)\n            for(res j=0;j<=k;j++)\n                f[i][j]=0;\n        f[0][0]=1;\n        for(res i=0;i<n;i++)\n            for(res j=0;j<=k;j++)\n                if(f[i][j])add(f[i+1][0],f[i][j]),add(f[i+1][j+1],f[i][j]);\n        res ret=0;\n        for(res i=0;i<=k;i++)add(ret,f[n][i]);\n        return ret;\n    }\n    inline void MAIN(){\n        n=read(),k=read(),kcz=read();\n        if(k%2==0){printf(\"%d\\n\",mul(solve(n>>1,k>>1),solve(n-(n>>1),k>>1)));return;}\n        dp[0][0][0]=1;\n        for(res i=0;i<=n;i++){\n            res r=i<<1,l=r-k;\n            for(res j=0;j<=n;j++)\n                for(res p=0;p<=k;p++)\n                    if(dp[i][j][p]){\n                        add(dp[i+1][0][0],dp[i][j][p]);\n                        if((1<=r&&r<=n)&&(1<=l&&l<=n))add(dp[i+1][j+1][max(p+1,j+1)],dp[i][j][p]);\n                        if((1<=r&&r<=n))add(dp[i+1][j+1][0],dp[i][j][p]);\n                        if((1<=l&&l<=n))add(dp[i+1][0][p?p+1:p],dp[i][j][p]);\n                    }\n        }\n        printf(\"%d\\n\",dp[n+1][0][0]);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n//const ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll mod;\n\nll f(int n,int m){\n\tvl dp(m+1);\n\tdp[0]++;\n\tfor(int i=0;i<n;i++){\n\t\tvl DP(m+1);\n\t\tfor(int j=0;j<m;j++){\n\t\t\t(DP[0]+=dp[j])%=mod;\n\t\t\t(DP[j+1]+=dp[j])%=mod;\n\t\t}\n\t\tDP[m]=0;\n\t\tdp=DP;\n\t}\n\tll t=0;\n\tfor(auto i:dp) (t+=i)%=mod;\n\treturn t;\n}\n\nconst int M=200;\n\nint n,m;\nll two[M];\n\nint main(){\n\tcin>>n>>m>>mod;\n\ttwo[0]=1;\n\tfor(int i=1;i<M;i++) two[i]=two[i-1]*2%mod;\n\tif(m%2==0){\n\t\tm=(m+2)/2;\n\t\tcout<<f((n+1)/2,m)*f(n/2,m)%mod<<endl;\n\t\treturn 0;\n\t}\n\tif(m==1){\n\t\tcout<<f(n,3)<<endl;\n\t\treturn 0;\n\t}\n\tif(n==m){\n\t\tcout<<two[n]<<endl;\n\t\treturn 0;\n\t}\n\tvvl dp(m+2,vl(m+2));\n\tfor(int i=0;i<=m/2;i++) dp[i][0]=two[max(0,m/2-i-1)];\n\tfor(int i=m/2+1;i<=n/2;i++){\n\t\tvvl DP(m+2,vl(m+2));\n\t\tfor(int j=0;j<m+2;j++) for(int k=0;k<m+2;k++) if(dp[j][k]){\n\t\t\tint t=min(m+1,j+1);\n\t\t\t(DP[0][0]+=dp[j][k])%=mod;\n\t\t\t(DP[t][0]+=dp[j][k])%=mod;\n\t\t\tif(k>1) (DP[0][k-1]+=dp[j][k])%=mod;\n\t\t\tif(!k) (DP[0][0]+=dp[j][k])%=mod;\n\t\t\tif(k>1) (DP[t][k-1]+=dp[j][k])%=mod;\n\t\t\tif(!k&&m+1-t>0) (DP[t][m+1-t]+=dp[j][k])%=mod;\n\t\t}\n\t\tdp=DP;\n\t}\n\tll res=0;\n\tfor(int i=0;i<m+2;i++) for(int j=0;j<m+2;j++) if(dp[i][j]){\n\t\tint len=m/2+n%2;\n\t\tint t=(j>len?0:j);\n\t\t(res+=dp[i][j]*(t?two[t]-1:1)%mod*two[len-t])%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int MAXN=150+5;\nint N,k,mod;\ninline int add(int x) {return x>=mod?x-mod:x;}\ninline void upd(int &x,int y) {x+=y; if(x>=mod) x-=mod;}\nnamespace sub0 {\n\tint dp[MAXN][MAXN];\n\tint sol(int n) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<=k;++i) dp[0][i]=1;\n\t\tfor(int i=1;i<=n;++i) {\n\t\t\tint R=n-i+1;\n\t\t\tfor(int j=1;j<=R;++j) upd(dp[i][j-1],dp[i-1][j]);\n\t\t\tfor(int j=0;j<R&&j<=k;++j) upd(dp[i][j],dp[i-1][0]);\n\t\t}\n\t\treturn dp[n][0];\n\t}\n\tint sol() {\n\t\tk>>=1;\n\t\treturn (ll)sol(N>>1)*sol((N+1)>>1)%mod;\n\t}\n}\nnamespace sub1 {\n\tint dp[MAXN][MAXN][MAXN];\n\tint sol() {\n\t\tint n=(N+1)>>1,m=N-n;\n\t\tk>>=1;\n\t\tfor(int i=0;i<=n;++i) {\n\t\t\tdp[0][i][k]=1;\n\t\t\tfor(int j=k-1,r=1;j>=0;--j) {\n\t\t\t\tdp[0][i][j]=r;\n\t\t\t\tr=add(r<<1);\n\t\t\t}\t\n\t\t}\n\t\tfor(int i=1;i+k<=m;++i) {\n\t\t\tint R=n-i+1;\n\t\t\tfor(int j=1;j<=R;++j) for(int h=0;h<i+k;++h) if(dp[i-1][j][h]) {\n\t\t\t\tupd(dp[i][j-1][0],dp[i-1][j][h]);\n\t\t\t\tif(j+h<2*k+2) upd(dp[i][j-1][h+1],dp[i-1][j][h]);\n\t\t\t}\n\t\t\tfor(int j=0;j<R;++j) for(int h=0;h<i+k;++h) if(dp[i-1][0][h]) {\n\t\t\t\tupd(dp[i][j][0],dp[i-1][0][h]);\n\t\t\t\tupd(dp[i][j][h+1],dp[i-1][0][h]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=m-k+1;i<=n;++i) {\n\t\t\tint R=n-i+1;\n\t\t\tfor(int j=1;j<=R;++j) for(int h=0;h<=m;++h) if(dp[i-1][j][h]) {\n\t\t\t\tupd(dp[i][j-1][h],dp[i-1][j][h]);\n\t\t\t}\n\t\t\tfor(int j=0;j<R;++j) for(int h=0;h<=m;++h) if(dp[i-1][0][h]) {\n\t\t\t\tupd(dp[i][j][h],dp[i-1][0][h]);\n\t\t\t}\n\t\t}\n\t\tint an=0;\n\t\tfor(int h=0;h<=m;++h) upd(an,dp[n][0][h]);\n\t\treturn an;\n\t}\n}\nint main() {\n\trd(N),rd(k),rd(mod);\n\tif(~k&1) printf(\"%d\\n\",sub0::sol());\n\telse printf(\"%d\\n\",sub1::sol());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//quming\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nint P;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=155;\nint n,p;\ninline int max(R int x,R int y){return x>y?x:y;}\nint solve(int n,int p){\n    static int f[N][N];memset(f,0,sizeof(f));\n    f[0][0]=1;\n    fp(i,0,n-1)fp(j,0,p)if(f[i][j])upd(f[i+1][0],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n    R int res=0;fp(i,0,p)upd(res,f[n][i]);\n    return res;\n}\nint f[N][N][N];\nint main(){\n//  freopen(\"testdata.in\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&p,&P);\n    if(p&1^1)return printf(\"%d\\n\",mul(solve(n>>1,p>>1),solve((n+1)>>1,p>>1))),0;\n    f[0][0][0]=1;\n    fp(i,1,n+1){\n        R int r=(i<<1),l=r-p;\n        R bool fr=(r>=1&&r<=n),fl=(l>=1&&l<=n);\n        fp(j,0,n)fp(k,0,p)if(f[i-1][j][k]){\n            upd(f[i][0][0],f[i-1][j][k]);\n            if(fr)upd(f[i][j+1][0],f[i-1][j][k]);\n            if(fl)upd(f[i][0][k?k+1:k],f[i-1][j][k]);\n            if(fl&&fr)upd(f[i][j+1][max(k+1,j+1)],f[i-1][j][k]);\n        }\n    }\n    printf(\"%d\\n\",f[n+1][0][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,p,K,f[155][155],g[305][155][155];\nvoid solve1()\n{\n\tK/=2;\n\tf[0][0]=1;\n\tfor(int i=1;i<=(n+1)/2;i++)\n\t{\n\t\tfor(int j=0;j<=K;j++) f[i][0]=(f[i][0]+f[i-1][j])%p;\n\t\tfor(int j=0;j<K;j++) f[i][j+1]=(f[i][j+1]+f[i-1][j])%p;\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<=K;i++) ans1=(ans1+f[n/2][i])%p;\n\tfor(int i=0;i<=K;i++) ans2=(ans2+f[(n+1)/2][i])%p;\n\tprintf(\"%lld\\n\",1ll*ans1*ans2%p);\n}\nvoid solve2()\n{\n\tint last=0;g[0][0][0]=1;\n\tfor(int i=2;i-K<=n;i+=2)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\tfor(int k=0;k<=K+1;k++) g[i][0][0]=(g[i][0][0]+g[i-2][j][k])%p;\n\t\tif(i<=n)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=0;k<=K+1;k++) g[i][j+1][0]=(g[i][j+1][0]+g[i-2][j][k])%p;\n\t\t}\n\t\tif(i-K>=1)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=K;k++) g[i][0][k+1]=(g[i][0][k+1]+g[i-2][j][k])%p;\n\t\t\t\tg[i][0][0]=(g[i][0][0]+g[i-2][j][0])%p;\n\t\t\t}\n\t\t}\n\t\tif(i<=n&&i-K>=1)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=0;max(k,j+1)<=K;k++)\n\t\t\t{\n\t\t\t\tg[i][j+1][max(k+1,j+2)]=(g[i][j+1][max(k+1,j+2)]+g[i-2][j][k])%p;\n\t\t\t}\n\t\t}\n\t\tlast=i;\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=n;j++)\n\tfor(int k=0;k<=K+1;k++) ans=(ans+g[last][j][k])%p;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tn=read(),K=read(),p=read();\n\tif(!(K&1)) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,k,m;\n\nint s1(int n,int k)\n{\n\tstatic int f[155];\n\tf[0] = 1;\n\tfor(int i = 1;i <= n + 1; ++ i)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tif(i - j - 1 >= 0)\n\t\t\t\tf[i] = (f[i] + f[i - j - 1]) % m;\n\t}\n\treturn f[n + 1];\n}\n\nint s2(int n,int k)\n{\n\tstatic int f[155][155][155];\n\tstatic int typ[155];\n\tint tot = 0;\n\tfor(int i = 1;i * 2 - k <= n; ++ i)\n\t{\n\t\ttot ++;\n\t\tif(i * 2 <= n) typ[tot] |= 2;\n\t\tif(i * 2 - k > 0) typ[tot] |= 1;\n\t}\n\tf[0][0][0] = 1;\n\tfor(int i = 1;i <= tot; ++ i)\n\t\tfor(int j = 0;j <= k + 1; ++ j)\n\t\t\tfor(int l = 0;l <= i; ++ l)\n\t\t\t\tif(f[i - 1][j][l])\n\t\t\t\t{\n\t\t\t\t\t//×óÓÒ¾ù²»Ñ¡\n\t\t\t\t\tf[i][0][0] = (f[i][0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡×ó²»Ñ¡ÓÒ\n\t\t\t\t\tif(typ[i] & 1)\n\t\t\t\t\t\tf[i][j ? j + 1 : 0][0] = (f[i][j ? j + 1 : 0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡ÓÒ²»Ñ¡×ó\n\t\t\t\t\tif(typ[i] & 2)\n\t\t\t\t\t\tf[i][0][l + 1] = (f[i][0][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t\tif(typ[i] == 3)\n\t\t\t\t\t\tf[i][j ? j + 1 : l + 2][l + 1] = (f[i][j ? j + 1 : l + 2][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t}\n\tint as = 0;\n\tfor(int i = 0;i <= k + 1; ++ i)\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tas = (as + f[tot][i][j]) % m;\n\treturn as;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&m);\n\tif(k % 2 == 0)\n\t{\n\t\tprintf(\"%d\\n\",(s1(n / 2,k / 2) * 1ll * s1((n + 1) / 2,k / 2)) % m);\n\t}\n\telse printf(\"%d\\n\",s2(n,k));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,k,mod;\nvoid upd(int&x,int y){x=(x+y)%mod;}\nint main(){\n\tcin>>n>>k>>mod;\n\tif(k%2==0){\n\t\tstatic int f[155][155];\n\t\tk=k/2+1;\n\t\tf[0][0]=1;\n\t\tfor(int i=1;i<=n+1;i++){\n\t\t\tf[i][0]=f[i-1][0];\n\t\t\tfor(int j=1;j<k;j++){\n\t\t\t\tf[i][j]=f[i-1][j-1];\n\t\t\t\tupd(f[i][0],f[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<1ll*f[n/2+1][0]*f[n-n/2+1][0]%mod<<\"\\n\";\n\t\treturn 0;\n\t}else{\n\t\tstatic int f[155][155][155][2];\n\t\tf[0][0][0][0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tauto chk=[&](int x){\n\t\t\t\treturn 1<=x&&x<=n;\n\t\t\t};\n\t\t\tint a=chk(2*i+2-k),b=chk(2*i+2);\n\t\t\tfor(int s=0;s<=n;s++)\n\t\t\t\tfor(int r=0;r<=n;r++){\n\t\t\t\t\tfor(int o=0;o<2;o++){\n\t\t\t\t\t\tif(o&&s>k+1)continue;\n\t\t\t\t\t\tupd(f[i+1][0][0][0],f[i][s][r][o]);\n\t\t\t\t\t\tif(a)upd(f[i+1][s+1][0][o],f[i][s][r][o]);\n\t\t\t\t\t\tif(b)upd(f[i+1][0][r+1][0],f[i][s][r][o]);\n\t\t\t\t\t\tif(a&&b){\n\t\t\t\t\t\t\tif(o)upd(f[i+1][s+1][r+1][o],f[i][s][r][o]);\n\t\t\t\t\t\t\telse upd(f[i+1][r+2][r+1][1],f[i][s][r][o]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tcout<<f[n][0][0][0]<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,K,M;\n\ninline void add(int &a,int b){\n\ta+=b;\n\tif(a>=M)a-=M;\n}\n\nint solve(int n,int k){\n\tvint dp(k+1);\n\tdp[0]=1;\n\trep(i,n){\n\t\tint s=accumulate(all(dp),0ll)%M;\n\t\trotate(dp.begin(),dp.begin()+k,dp.end());\n\t\tdp[0]=s;\n\t}\n\treturn accumulate(all(dp),0ll)%M;\n}\n\nint dp[222][222][2];\n\nsigned main(){\n\tcin>>N>>K>>M;\n\tif(K%2==0){\n\t\tcout<<solve(N/2,K/2)*solve(N-N/2,K/2)%M<<endl;\n\t\treturn 0;\n\t}\n\n\tN++;\n\tdp[0][0][0]=1;\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tfor(int k=0;i+k+1<=N;k++){\n\t\t\t\tif(k&1){\n\t\t\t\t\tif(k==1||1+K>=k+j){\n\t\t\t\t\t\tadd(dp[i+k+1][j+k+1][0],dp[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tadd(dp[i+k+1][k+1][1],dp[i][j][0]);\n\t\t\t\t\t}\n\n\t\t\t\t\tadd(dp[i+k+1][j+k+1][1],dp[i][j][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(1+K>=k){\n\t\t\t\t\t\tadd(dp[i+k+1][k][0],dp[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t\tif(1+K>=k+j){\n\t\t\t\t\t\tadd(dp[i+k+1][k][0],dp[i][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,N+1)add(ans,dp[N][i][0]);\n\trep(i,1+K+1)add(ans,dp[N][i][1]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst int MX = 80;\nll dp[MX][MX][MX];\nll ndp[MX][MX][MX];\nint MOD;\nvoid add(ll& x, ll y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\nll solve(int n, int k) {\n\t// max k white things\n\tvector<ll> dp(n + 1);\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= k; ++j) {\n\t\t\tif (i - j - 1 >= 0) add(dp[i], dp[i - j - 1]);\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i)\n\t\tif (n - i <= k) add(ans, dp[i]);\n\treturn ans;\n}\nint main() {\n\tint n, k;\n\tscanf(\"%d%d%d\", &n, &k, &MOD);\n\tif (k % 2 == 0) {\n\t\tll ans = solve(n / 2, k / 2) * solve(n - n / 2, k / 2) % MOD;\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tdp[0][0][MX - 1] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tmemset(ndp, 0, sizeof(ndp));\n\t\tfor (int x = 0; x < MX; ++x)\n\t\t\tfor (int y = 0; y < MX; ++y)\n\t\t\t\tfor (int z = 0; z < MX; ++z) {\n\t\t\t\t\tif (z <= max(x, y)) continue;\n\t\t\t\t\tif (!dp[x][y][z]) continue;\n\t\t\t\t\tint xx = y, yy = x, zz = MX - 1;\n\t\t\t\t\tif (x > y) zz = z;\n\t\t\t\t\tadd(ndp[0][x][zz], dp[x][y][z]);\n\t\t\t\t\t++xx;\n\t\t\t\t\tassert(xx < MX);\n\t\t\t\t\tzz = z;\n\t\t\t\t\tif (yy >= (k + 1) / 2 && xx <= (k + 1) / 2) {\n\t\t\t\t\t\tzz = min(zz, yy + (k + 1) / 2 - xx + 1);\n\t\t\t\t\t}\n\t\t\t\t\tadd(ndp[xx][yy][zz], dp[x][y][z]);\n\t\t\t\t}\n\t\tswap(dp, ndp);\n\t}\n\tll ans = 0;\n\tfor (int x = 0; x < MX; ++x)\n\t\tfor (int y = 0; y < MX; ++y)\n\t\t\tfor (int z = 0; z < MX; ++z) {\n\t\t\t\tif (z <= max(x, y)) continue;\n\t\t\t\tadd(ans, dp[x][y][z]);\n\t\t\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define cri const int\n#define ll long long\n#define re register\nusing namespace std;\nint N,K,mod;\nint f[152][152];\ninline int mo(cri x){ return x>=mod?x-mod:x; } \ninline void solve2(){\n\tf[0][0]=f[1][0]=f[1][1]=f[2][0]=f[2][1]=1;\n\tK=(K>>1)+1;\n\tfor(int i=3;i<=N;i++){\n\t\tfor(int j=0;j<K;j++) f[i][0]=mo(f[i][0]+f[i-2][j]);\n\t\tfor(int j=0;j<K-1;j++) f[i][j+1]=f[i-2][j];\n\t}\n\tint tmp1=0,tmp2=0;\n\tfor(int i=0;i<K;i++) tmp1=mo(tmp1+f[N][i]),tmp2=mo(tmp2+f[N-1][i]);\n\tcout<<1ll*tmp1*tmp2%mod<<endl;\n}\nint dp[152][152][152];\ninline void solve1(){\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=N+K>>1;i++){//cout<<\"i=\"<<i<<endl;\n\t\tif(i<=K/2) for(int j=0;j<i;j++) dp[i][0][j+1]=dp[i-1][0][j],dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][0][j]);\n\t\telse if(i<=N/2){\n\t\t\tfor(int j=0;j<=i;j++) \n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t//cout<<j<<\" \"<<k<<endl;\n\t\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\t\telse dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][0][k+1]=mo(dp[i][0][k+1]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][max(j+1,k+2)][k+1]=mo(dp[i][max(j+1,k+2)][k+1]+dp[i-1][j][k]);\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<=i;j++) for(int k=0;k<i;k++) {\n\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\telse dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=K+2;j<=i+1;j++) memset(dp[i][j],0,sizeof dp[i][j]); \n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++) ans=mo(ans+dp[N+K>>1][i][k]);\n\tcout<<ans<<endl;\n}\nint main(){\n\tcin>>N>>K>>mod;\n\tif(K&1) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 150, M = N >> 1;\nint dp[N + 1][N + 1][N + 1], md, dp0[M + 1][M + 1];\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void up(int i, int a, int b, int y) { ad(dp[i][a + M][b + M], y); }\n\nint pw(int x, int p){\n\tif (p < 0)return 0;\n\tint an = 1;\n\twhile (p){\n\t\tif (p & 1)an = (ll)an * x % md;\n\t\tx = (ll)x * x % md;\n\t\tp >>= 1;\n\t}\n\treturn an;\n}\n\nint easy(int n, int k){\n\tdp0[0][0] = 1;\n\tf(i, 1, n + 1){\n\t\tdp0[i][0] = 0;\n\t\tf(j, 0, k + 1)ad(dp0[i][0], dp0[i - 1][j]);\n\t\tf(j, 1, k + 1)dp0[i][j] = dp0[i - 1][j - 1];\n\t}\n\tint an = 0;\n\tf(i, 0, k + 1)ad(an, dp0[n][i]);\n\treturn an;\n}\n\nint main(){\n\tint n, k;\n\tscanf(\"%d%d%d\", &n, &k, &md);\n\tif (k & 1){\n\t\tdp[0][M][M] = 1;\n\t\tint m = n - n / 2;\n\t\tf(i, 0, n + 1)f(f1, -M, m + 1)f(f2, -M, m + 1){\n\t\t\tint &d = dp[i][f1 + M][f2 + M];\n\t\t\tif (i & 1){\n\t\t\t\tif (-f1 >= k + 3 >> 1 && -f1 + abs(f2) >= k + 2)d = 0;\n\t\t\t\tif (f1 < 0 && i - (-f1 - 1) * 2 <= 0)d = 0;\n\t\t\t\telse if (f1 > 0 && i - k / 2 * 2 <= 0)d = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (-f2 >= k + 3 >> 1 && -f2 + abs(f1) >= k + 2)d = 0;\n\t\t\t\tif (f2 < 0 && i - (-f2 - 1) * 2 <= 0)d = 0;\n\t\t\t\telse if (f2 > 0 && i - k / 2 * 2 <= 0)d = 0;\n\t\t\t}\n\t\t\tif (d == 0 || i == n)continue;\n\t\t\tif (i & 1){\n\t\t\t\tif (f2 < 0){\n\t\t\t\t\tup(i + 1, f1, k / 2, d);\n\t\t\t\t\tup(i + 1, f1, max(f2 - 1, -(k + 1)), d);\n\t\t\t\t}\n\t\t\t\telse if (f2)up(i + 1, f1, f2 - 1, d);\n\t\t\t\telse {\n\t\t\t\t\tup(i + 1, f1, 0, d);\n\t\t\t\t\tf(j, 1, min(k / 2, m) + 1)up(i + 1, f1, j, d);\n\t\t\t\t\tup(i + 1, f1, -(k / 2 + 1), d);\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tif (f1 < 0){\n\t\t\t\t\tup(i + 1, k / 2, f2, d);\n\t\t\t\t\tup(i + 1, max(f1 - 1, -(k + 1)), f2, d);\n\t\t\t\t}\n\t\t\t\telse if (f1)up(i + 1, f1 - 1, f2, d);\n\t\t\t\telse {\n\t\t\t\t\tup(i + 1, 0, f2, d);\n\t\t\t\t\tf(j, 1, min(k / 2, m) + 1)up(i + 1, j, f2, d);\n\t\t\t\t\tup(i + 1, -(k / 2 + 1), f2, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint an = 0;\n\t\tf(i, -M, M + 1)f(j, -M, M + 1){\n\t\t\tint z = dp[n][i + M][j + M];\n\t\t\tif (z == 0)continue;\n\t\t\tif (i >= 0)z = (ll)z * pw(2, k / 2 - i) % md;\n\t\t\tif (j >= 0)z = (ll)z * pw(2, k / 2 - j) % md;\n\t\t\tad(an, z);\n\t\t}\n\t\tprintf(\"%d\\n\", an);\n\t}else printf(\"%d\\n\", (int)((ll)easy(n >> 1, k >> 1) * easy(n - n / 2, k >> 1) % md));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair <int, int>\n#define iiii pair <int, pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n  int x = 0, p = 1; char c = getchar();\t\n  while (c <= 32) c = getchar();\n  if (c == 45) p = -p, c = getchar();\n  while (c > 32) x = x * 10 + c - 48, c = getchar();\n  return x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 158;\nint n, k, mod;\nint g[N][N], f[N][N][N];\n//\ninline void reduce(int &x) {\n  x += x >> 31 & mod;\n}\ninline void add(int &x, int y) {\n  x += y - mod;\n  reduce(x);\n}\ninline int mul(int x, int y) {\n  return 1ll * x * y % mod;\n}\nvoid solve0() {\n  g[0][0] = g[1][0] = 1;\n  k /= 2;\n  for (int i = 1; i <= n; i++) {\n    add(g[i + 1][0], g[i][0]);\n    for (int j = 1; j <= min(i, k); j++) {\n      add(g[i][j], g[i - 1][j - 1]);\n      add(g[i + 1][0], g[i][j]);\n    }\n  }\n  int sum = 0, res = 0;\n  rep(i, k + 1) add(sum, g[n / 2][i]);\n  if (n & 1) ++n;\n  rep(i, k + 1) add(res, g[n / 2][i]);\n  cout << mul(res, sum) << endl;\n}\nvoid solve1() {\n  int c0 = 0, c1 = 0, c;\n  for (int i = 2; i <= n; i += 2) {\n    if (i - k <= 0) ++c0;\n  }\n  for (int i = 1; i <= n; i += 2) {\n    if (i + k > n) ++c1;\n  }\n  c = (n - c0 - c1) / 2;\n  f[0][0][0] = 1;\n  for (int i = 1; i <= c0; i++) {\n    rep(j, i) add(f[i][0][0], f[i - 1][0][j]);\n    for (int j = 1; j <= i; j++) {\n      add(f[i][0][j], f[i - 1][0][j - 1]);\n    }\n  }\n  for (int i = c0 + 1; i <= c0 + c + c1; i++) {\n    if (i <= c0 + c) for (int j = 1; j <= k; j++) {\n      for (int x = 0; x < N; x++) {\n        add(f[i][0][j], f[i - 1][x][j - 1]);\n      }\n    }\n    rep(x, N) add(f[i][0][0], f[i - 1][0][x]);\n    rep(j, k + 1) rep(k, N) {\n      add(f[i][0][0], f[i - 1][j][k]);\n    }\n    for (int j = 2; j <= k; j++) {\n      for (int x = 0; x < N; x++) {\n        add(f[i][j][0], f[i - 1][j - 1][x]);\n      }\n    }\n    if (i <= c0 + c) rep(j, k) for (int x = 0; x < N - 1; x++) {\n      add(f[i][max(j, x) + 1][x + 1], f[i - 1][j][x]);\n    }\n  }\n  int res = 0;\n  rep(i, k + 1) rep(j, N) add(res, f[c + c0 + c1][i][j]);\n  cout << res << endl;\n}\nint main() {\n  n = getint(); k = getint(); mod = getint();\n  if (!(k & 1)) {\n    solve0();\n  }\n  else {\n    solve1();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 155;\n\nint n, m, mod;\nint f[maxN + 1][maxN + 1][maxN + 1], g[maxN + 1][maxN + 1];\nint ans;\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int solve1()\n{\n\tf[0][0][0] = 1;\n\tfor(int i = 1; i <= m / 2; i++)\n\t{\n\t\tfor(int j = 0; j <= i - 1; j++) f[i][0][0] = ADD(f[i][0][0], f[i - 1][0][j]);\n\n\t\tfor(int j = 1; j <= i; j++) \n\t\t\tf[i][0][j] = f[i - 1][0][j - 1];\t\n\t}\n\tfor(int i = m / 2 + 1; i <= n / 2; i++)\n\t{\n\t\t//none\n\t\tfor(int j = 0; j <= m + 1; j++) \n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][0][0] = ADD(f[i][0][0], f[i - 1][j][k]);\n\t\tfor(int j = 1; j <= i - m / 2; j++) f[i][0][0] = ADD(f[i][0][0], g[i - 1][j]);\n\t\t//left\n\t\tg[i][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - 1; j++) g[i][1] = ADD(g[i][1], f[i - 1][0][j]);\n\t\tfor(int j = 2; j <= i - m / 2; j++) g[i][j] = g[i - 1][j - 1];\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][j][0] = ADD(f[i][j][0], f[i - 1][j - 1][k]);\n\t\t//right\n\t\tfor(int j = 0; j <= m + 1; j++) f[i][0][1] = ADD(f[i][0][1], f[i - 1][j][0]);\n\t\tfor(int j = 1; j <= i - m / 2 - 1; j++) f[i][0][1] = ADD(f[i][0][1], g[i - 1][j]);\n\t\tfor(int j = 2; j <= i; j++) \n\t\t{\n\t\t\tf[i][0][j] = f[i - 1][0][j - 1];\n\t\t\tfor(int k = 2; k <= m + 1; k++) f[i][0][j] = ADD(f[i][0][j], f[i - 1][k][j - 1]);\n\t\t}\n\t\t//both\n\t\tf[i][2][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - m / 2 - 1; j++) f[i][2][1] = ADD(f[i][2][1], g[i - 1][j]);\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t{\n\t\t\tf[i][j][j - 1] = f[i - 1][0][j - 2];\n\t\t\tfor(int k = 1; k <= i; k++) f[i][j][k] = ADD(f[i][j][k], f[i - 1][j - 1][k - 1]);\n\t\t}\n\t}\n\tint last = n - n / 2 + m / 2;\n\tfor(int i = n / 2 + 1; i <= last; i++)\n\t{\n\t\tfor(int j = 0; j <= m + 1; j++) \n\t\t\tfor(int k = 0; k <= n / 2; k++)\n\t\t\t\tf[i][0][0] = ADD(f[i][0][0], f[i - 1][j][k]);\n\t\tfor(int j = 1; j <= i - m / 2; j++) f[i][0][0] = ADD(f[i][0][0], g[i - 1][j]);\n\n\t\tg[i][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - 1; j++) g[i][1] = ADD(g[i][1], f[i - 1][0][j]);\n\t\tfor(int j = 2; j <= i - m / 2; j++) g[i][j] = g[i - 1][j - 1];\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][j][0] = ADD(f[i][j][0], f[i - 1][j - 1][k]);\n\t}\n\tint ans = f[last][0][0];\n\tfor(int i = 2; i <= m + 1; i++) \n\t\tfor(int j = 0; j <= n / 2; j++) ans = ADD(ans, f[last][i][j]);\n\tfor(int i = 1; i <= n - n / 2; i++) ans = ADD(ans, g[last][i]);\n\treturn ans;\n}\n\ninline int solve2(int n)\n{\n\tmemset(g, 0, sizeof(g));\n\tint ans = 1;\n\tg[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j <= min(i - 1, m / 2); j++) g[i][0] = ADD(g[i][0], g[i - 1][j]);\n\t\tfor(int j = 1; j <= min(i, m / 2); j++)\n\t\t\tg[i][j] = g[i - 1][j - 1], ans = ADD(ans, g[i][j]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &mod);\n\tif(m & 1) printf(\"0\");\n\telse printf(\"%d\", 1ll * solve2(n / 2) * solve2(n - n / 2) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,p,K,f[155][155],g[155][155][155];\nvoid solve1()\n{\n\tK/=2;\n\tf[0][0]=1;\n\tfor(int i=1;i<=(n+1)/2;i++)\n\t{\n\t\tfor(int j=0;j<=K;j++) f[i][0]=(f[i][0]+f[i-1][j])%p;\n\t\tfor(int j=0;j<K;j++) f[i][j+1]=(f[i][j+1]+f[i-1][j])%p;\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<=K;i++) ans1=(ans1+f[n/2][i])%p;\n\tfor(int i=0;i<=K;i++) ans2=(ans2+f[(n+1)/2][i])%p;\n\tprintf(\"%lld\\n\",1ll*ans1*ans2%p);\n}\nvoid solve2()\n{\n\tint last=0;g[0][0][0]=1;\n\tfor(int i=2;i-K<=n;i+=2)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\tfor(int k=0;k<=K+1;k++) g[i][0][0]=(g[i][0][0]+g[i-2][j][k])%p;\n\t\tif(i<=n)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=0;k<=K+1;k++) g[i][j+1][0]=(g[i][j+1][0]+g[i-2][j][k])%p;\n\t\t}\n\t\tif(i-K>=1)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tfor(int k=1;k<=K;k++) g[i][0][k+1]=(g[i][0][k+1]+g[i-2][j][k])%p;\n\t\t\t\tg[i][0][0]=(g[i][0][0]+g[i-2][j][0])%p;\n\t\t\t}\n\t\t}\n\t\tif(i<=n&&i-K>=1)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=0;max(k,j+1)<=K;k++)\n\t\t\t{\n\t\t\t\tg[i][j+1][max(k+1,j+2)]=(g[i][j+1][max(k+1,j+2)]+g[i-2][j][k])%p;\n\t\t\t}\n\t\t}\n\t\tlast=i;\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=n;j++)\n\tfor(int k=0;k<=K+1;k++) ans=(ans+g[last][j][k])%p;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tn=read(),K=read(),p=read();\n\tif(!(K&1)) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=155;\nint n,k,M,f[N][N],g[N];\nmap<ll,int> Map;\nll calc(int a,int b,int c,int d,int e){\n\treturn (ll)a*(n+2)*(n+2)*(n+2)*(n+2)+(ll)b*(n+2)*(n+2)*(n+2)+(ll)c*(n+2)*(n+2)+d*(n+2)+e;\n}\nint dfs(int x,int p,int q,int fp,int fq){\n\tif (x>=n)return 1;\n\tll VV=calc(x,p,q,fp,fq);\n\tif (Map.count(VV))return Map[VV];\n\tif (x&1){\n\t\tMap[VV]=dfs(x+1,0,q,n+1,fq);\n\t\tif (fp>x+1){\n\t\t\tif (x+2-2*q+k<=x+1)(Map[VV]+=dfs(x+1,p+1,q,fp,min(fq,x+1-2*p+k)))%=M;\n\t\t\telse (Map[VV]+=dfs(x+1,p+1,q,fp,fq))%=M;\n\t\t}\n\t}\n\telse {\n\t\tMap[VV]=dfs(x+1,p,0,fp,n+1);\n\t\tif (fq>x+1){\n\t\t\tif (x+2-2*p+k<=x+1)(Map[VV]+=dfs(x+1,p,q+1,min(fp,x+1-2*q+k),fq))%=M;\n\t\t\telse (Map[VV]+=dfs(x+1,p,q+1,fp,fq))%=M;\n\t\t}\n\t}\n\treturn Map[VV];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&M);\n\tif (k%2==0){\n\t\tk/=2;\n\t\tf[0][0]=1;\n\t\tg[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tfor (int j=0;j<=k;j++)\n\t\t\t\tf[i][j]=j==0?g[i-1]:f[i-1][j-1];\n\t\t\tfor (int j=0;j<=k;j++)(g[i]+=f[i][j])%=M;\n\t\t}\n\t\tprintf(\"%d\\n\",(ll)g[n/2]*g[n/2+n%2]%M);\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,0,n+1,n+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\nconst int N = 151;\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\nvoid put(int x) {\n\tif(x < 0) x = -x, putchar('-');\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint mod;\nint f[N][N][N], g[N][N];\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\n\nint dec(int x, int y) {\n\tx -= y;\n\treturn x < 0 ? x + mod : x;\n}\n\nint solve(int n, int k) {\n\tmemset(g, 0, sizeof(g));\n\tint ans = 0; g[0][0] = 1;\n\tfor(int i = 1; i <= n; i++) for(int j = 0; j <= k; j++) if(g[i - 1][j]){\n\t\tg[i][0] = add(g[i][0], g[i - 1][j]);\n\t\tif(j < k) g[i][j + 1] = add(g[i][j + 1], g[i - 1][j]);\n\t} for(int i = 0; i <= k; i++) ans = add(ans, g[n][i]);\n\treturn ans;\n}\n\nint main() {\n\tint n = read(), k = read(); mod = read();\n\tif(!(k & 1)) return put((LL)solve(n >> 1, k >> 1) * solve((n + 1) >> 1, k >> 1) % mod), 0;\n\tf[0][0][0] = 1;\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tint u = i << 1, v = u - k;\n\t\tfor(int j = 0; j <= n; j++) for(int h = 0; h <= k; h++) if(f[i - 1][j][h]){\n\t\t\tf[i][0][0] = add(f[i][0][0], f[i - 1][j][h]);\n\t\t\tif(1 <= u && u <= n) f[i][j + 1][0] = add(f[i][j + 1][0], f[i - 1][j][h]);\n\t\t\tif(1 <= v && v <= n) f[i][0][h ? h + 1 : 0] = add(f[i][0][h ? h + 1 : 0], f[i - 1][j][h]);\n\t\t\tif(1 <= u && u <= n && 1 <= v && v <= n) f[i][j + 1][_max(j + 1, h + 1)] = add(f[i][j + 1][_max(j + 1, h + 1)], f[i - 1][j][h]);\n\t\t}\n\t} put(f[n + 1][0][0]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=155;\nint n,K,mo,f[N][N][N],i,j,k,ans,x,y;\ninline void add(int&x,const int&y){x+=y-mo;x+=x>>31&mo;}\ninline int calc(int n,int K){\n\tstatic int g[N][N];memset(g,0,sizeof g);g[0][0]=1;\n\tfor(i=1;i<=n;++i)for(j=0;j<=K;++j){\n\t\tg[i][0]=(g[i][0]+g[i-1][j])%mo;\n\t\tif(j<K)g[i][j+1]=g[i-1][j];\n\t}\n\tint ans=0;for(j=0;j<=K;++j)ans=(ans+g[n][j])%mo;return ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&K,&mo);\n\tif(n==K){ans=1;for(i=1;i<=n;++i)ans=2ll*ans%mo;printf(\"%d\\n\",ans);return 0;}\n\tif(!(K&1)){K>>=1;printf(\"%lld\\n\",1ll*calc(n>>1,K)*calc(n+1>>1,K)%mo);return 0;}\n\tif(K==1){printf(\"%d\\n\",calc(n,2));return 0;}\n\tint lb1,rb1,lb2,rb2;\n\tlb1=(K>>1)+1;rb1=lb1+(n+1>>1)-1;\n\tlb2=1;rb2=lb2+(n>>1)-1;\n\tfor(i=rb1+1,f[i][0][0]=1;i>1;--i)for(j=0;j<=n;++j)for(k=0;k<=n;++k)if(x=f[i][j][k]){\n\t\tbool b1=lb1<=i-1 && i-1<=rb1,b2=lb2<=i-1 && i-1<=rb2;\n\t\tadd(f[i-1][0][0],x);\n\t\tif(b1)add(f[i-1][j+1][0],x);\n\t\tif(k+1<=K+1 && b2)add(f[i-1][0][k?k+1:0],x);\n\t\ty=std::max(j+2,k+1);\n\t\tif(y<=K+1 && b1 && b2)add(f[i-1][j+1][y],x);\n\t}\n\tfor(j=0;j<=n;++j)for(k=0;k<=n;++k)add(ans,f[1][j][k]);printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int Maxn = 150;\n\nint N, K, Mod;\n\ninline void add(int &n, int m) {\n\tn += m;\n\tif(n >= Mod) n -= Mod;\n}\n\nnamespace Subtask1 {\n\tint f[Maxn + 5][Maxn + 5];\n\tint calc(int n, int k) {\n\t\tmemset(f, 0, sizeof f);\n\t\tf[0][0] = 1;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tf[i][0] = f[i - 1][0];\n\t\t\tfor(int j = 1; j <= k; j++)\n\t\t\t\tadd(f[i][0], f[i - 1][j]), add(f[i][j], f[i - 1][j - 1]);\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = 0; i <= k; i++)\n\t\t\tadd(ret, f[n][i]);\n\t\treturn ret;\n\t}\n\tvoid Solve() {\n\t\tprintf(\"%lld\\n\", 1LL * calc(N >> 1, K >> 1) * calc(N - (N >> 1), K >> 1) % Mod);\n\t}\n}\n\nnamespace Subtask2 {\n\tint f[Maxn + 5][Maxn + 5][Maxn + 5];\n\tvoid Solve() {\n\t\tf[0][0][0] = 1;\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tint r = (i << 1), l = r - K;\n\t\t\tbool fl = (1 <= l && l <= N), fr = (1 <= r && r <= N);\n\t\t\tfor(int j = 0; j <= N; j++)\n\t\t\t\tfor(int k = 0; k <= K + 1; k++) {\n\t\t\t\t\tadd(f[i][0][0], f[i - 1][j][k]);\n\t\t\t\t\tif(fr) add(f[i][j + 1][0], f[i - 1][j][k]);\n\t\t\t\t\tif(fl && k + 1 < K + 2) add(f[i][0][k ? k + 1 : k], f[i - 1][j][k]);\n\t\t\t\t\tif(fl && fr && max(j + 2, k + 1) < K + 2)\n\t\t\t\t\t\tadd(f[i][j + 1][max(j + 2, k + 1)], f[i - 1][j][k]);\n\t\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i <= N; i++)\n\t\t\tfor(int j = 0; j <= K + 1; j++)\n\t\t\t\tadd(ans, f[N][i][j]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef LOACL\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d %d %d\", &N, &K, &Mod);\n\tif(K % 2 == 0) Subtask1::Solve();\n\telse Subtask2::Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 150\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\nusing namespace std;\nint n,m,X;\nclass EvenSolver\n{\n\tprivate:\n\t\tint f[N+5][N+5];\n\t\tI int DP(CI n,CI m)\n\t\t{\n\t\t\tRI i,j,ans=0;memset(f,0,sizeof(f));\n\t\t\tfor(f[0][0]=1,i=0;i^n;++i) for(j=0;j<=m;++j) Inc(f[i+1][0],f[i][j]),Inc(f[i+1][j+1],f[i][j]);\n\t\t\tfor(i=0;i<=m;++i) Inc(ans,f[n][i]);return ans;\n\t\t}\n\tpublic:\n\t\tI void Solve() {printf(\"%d\",1LL*DP(n+1>>1,m>>1)*DP(n>>1,m>>1)%X);}\n}E;\nclass OddSolver\n{\n\tprivate:\n\t\tint f[N+5][N+5][N+5];\n\tpublic:\n\t\tI void Solve()\n\t\t{\n\t\t\tRI i,j,k,ans=0;f[0][0][0]=1;\n\t\t\tfor(i=0;i<(m>>1)+(n+1>>1);++i) for(j=0;j<=(n>>1);++j) for(k=0;k<=m+1;++k)\n\t\t\t\tInc(f[i+1][0][0],f[i][j][k]),i<(n>>1)&&Inc(f[i+1][j+1][0],f[i][j][k]),\n\t\t\t\ti>=(m>>1)&&Inc(f[i+1][0][k?k+1:0],f[i][j][k]),\n\t\t\t\ti>=(m>>1)&&i<(n>>1)&&Inc(f[i+1][j+1][max(j+2,k+1)],f[i][j][k]);\n\t\t\tfor(j=0;j<=(n>>1);++j) for(k=0;k<=m+1;++k) Inc(ans,f[(m>>1)+(n+1>>1)][j][k]);\n\t\t\tprintf(\"%d\",ans);\n\t\t}\n}O;\nint main()\n{\n\treturn scanf(\"%d%d%d\",&n,&m,&X),m&1?O.Solve():E.Solve(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 150;\nint N, K, M;\nint add(int a, int b) {return (a + b)%M;}\nint mul(int a, int b) {return 1LL*a*b%M;}\nint f[MAXN + 5][MAXN + 5];\nvoid solve1() {\n\tK /= 2, f[0][0] = 1;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=0;j<=K;j++)\n\t\t\tf[i][0] = add(f[i][0], f[i-1][j]);\n\t\tfor(int j=0;j<K;j++)\n\t\t\tf[i][j+1] = add(f[i][j+1], f[i-1][j]);\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tfor(int i=0;i<=K;i++)\n\t\tans1 = add(ans1, f[N/2][i]);\n\tfor(int i=0;i<=K;i++)\n\t\tans2 = add(ans2, f[(N+1)/2][i]);\n\tprintf(\"%d\\n\", mul(ans1, ans2));\n}\nint g[2*MAXN + 5][MAXN + 5][MAXN + 5];\nvoid solve2() {\n\tint p; g[0][0][0] = 1;\n\tfor(int i=2;i-K<=N;i+=2) {\n\t\tfor(int j=0;j<=N;j++)\n\t\t\tfor(int k=0;k<=K+1;k++)\n\t\t\t\tg[i][0][0] = add(g[i][0][0], g[i-2][j][k]);\n\t\tif( i <= N ) {\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;k<=K+1;k++)\n\t\t\t\t\tg[i][j+1][0] = add(g[i][j+1][0], g[i-2][j][k]);\n\t\t}\n\t\tif( i - K >= 1 ) {\n\t\t\tfor(int j=0;j<=N;j++) {\n\t\t\t\tfor(int k=1;k<=K;k++)\n\t\t\t\t\tg[i][0][k+1] = add(g[i][0][k+1], g[i-2][j][k]);\n\t\t\t\tg[i][0][0] = add(g[i][0][0], g[i-2][j][0]);\n\t\t\t}\n\t\t}\n\t\tif( i <= N && i - K >= 1 ) {\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;max(k,j+1)<=K;k++)\n\t\t\t\t\tg[i][j+1][max(k+1,j+2)] = add(g[i][j+1][max(k+1,j+2)], g[i-2][j][k]);\n\t\t}\n\t\tp = i;\n\t}\n\tint ans = 0;\n\tfor(int j=0;j<=N;j++)\n\t\tfor(int k=0;k<=K+1;k++)\n\t\t\tans = add(ans, g[p][j][k]);\n\tprintf(\"%d\\n\", ans);\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &K, &M);\n\tif( K % 2 == 0 ) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint MOD;\n// modnum {{{\nstruct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nconst int MAXN = 155;\nmn dp[2][MAXN][MAXN][MAXN];\n\nint N, K;\n\nint cache[MAXN][MAXN];\nint calc(int end, int cont) {\n    int& res = cache[end][cont];\n    if (cache[end][cont] != 0x7f7f7f7f) return res;\n\n    F0R (cent, min(end, cont - 1)) { // center around a top node\n        int topw = 2 * min(cent, end - 1 - cent);\n        int botmax = (K - topw - 1) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 2 - cent;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax + 1); // not inclusive, number of edges it can grow to\n    }\n\n    F0R (cent, min(end - 1, cont - 1)) { // center between top nodes\n        int topw = 1 + 2 * min(cent, end - 1 - cent - 1);\n        int botmax = (K - topw) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 1 - cent - 1;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax); // not inclusive, number of edges it can grow to\n    }\n\n    return min(N, res);\n}\n\nint main() {\n    setIO();\n    memset(cache, 0x7f, sizeof(cache));\n\n    re(N, K, MOD);\n\n    bool x = 0;\n    if (K&1) {\n        dp[x][0][0][N] = 1;\n\n        F0R (i, N) {\n            memset(dp[!x], 0, sizeof(dp[!x]));\n\n            F0R (even, (i+1)/2 + 1) {\n                F0R (odd, i/2 + 1) {\n                    F0R (limit, N + 1) {\n                        const mn& ctr = dp[x][even][odd][limit];\n                        if (!ctr.v) continue;\n\n                        if (i&1) {\n                            dp[!x][even][0][min(odd > even ? INT_MAX : limit, calc(odd, even))] += ctr;\n                            if ((odd < even || odd + 1 <= limit) && odd + 1 <= calc(even, odd + 1))\n                                dp[!x][even][odd+1][limit] += ctr;\n                        } else {\n                            dp[!x][0][odd][min(even > odd ? INT_MAX : limit, calc(even, odd))] += ctr;\n                            if ((even < odd || even + 1 <= limit) && even + 1 <= calc(odd, even + 1))\n                                dp[!x][even+1][odd][limit] += ctr;\n                        }\n                    }\n                }\n            }\n\n            x = !x;\n        }\n\n        mn ans = 0;\n        F0R (even, N + 1) F0R (odd, N + 1) F0R (limit, N + 1) ans += dp[x][even][odd][limit];\n        ps(ans);\n    } else {\n        vmn ways((N+1)/2 + 1);\n        ways[0] = 1;\n        FOR (v, 1, sz(ways)) {\n            FOR (i, 0, min(v, K/2) + 1)\n                ways[v] += ways[max(0, v-i-1)];\n        }\n        ps(ways[N/2] * ways[(N+1)/2]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=120;\n\nint dp[maxn][maxn][maxn];\nint NB[maxn][maxn][maxn];\n\nint n,m,k,mod;\nint p2[maxn];\n\ninline void init()\n{\n\tn=read();  k=read();mod=read();\n\tm=n+1>>1; n>>=1;\n\tp2[0]=1;\n\tREP(i,1,100)p2[i]=p2[i-1]*2%mod;\n}\n\ninline void pls(int &a,int b){ a+=b; a-=a>=mod?mod:0;}\n\ninline void doing()\n{\n\tif(~k&1)\n\t{\n\t\tstatic int f[maxn];\n\t\tk>>=1; \n\t\tint ans=1;\n\t\tf[0]=1;\n\t\tREP(i,1,n+1)REP(j,1,k+1)if(i>=j)f[i]=(f[i]+f[i-j])%mod;\n\t\tans=(ll)ans*f[n+1]%mod;\n\t\tmemset(f,0,sizeof(f));\n\t\tf[0]=1;\n\t\tREP(i,1,m+1)REP(j,1,k+1)if(i>=j)f[i]=(f[i]+f[i-j])%mod;\n\t\tans=(ll)ans*f[m+1]%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t}else\n\t{\n\t\tint ans=0;\n\t\tpls(ans,p2[m]);\n\t\tk>>=1;\n\t\tREP(i,1,n)REP(j,1,i)\n\t\t{\n\t\t\tint l=j+k+1,r=i-k;\n\t\t\tif(l<=r)\n\t\t\t{\n\t\t\t\tpls(dp[i][j][0],p2[l-1]);\n\t\t\t\tREP(a,i+2,n)REP(b,a,n)\n\t\t\t\t{\n\t\t\t\t\tint nl=a+k+1,nr=b-k;\n\t\t\t\t\tassert(nr>0);\n\t\t\t\t\tif(nl<=nr)pls(dp[b][a][0],(ll)dp[i][j][0]*p2[nl-r-1]%mod);\n\t\t\t\t\telse if(nl>m)pls(dp[b][a][0],(ll)dp[i][j][0]*p2[m-r]%mod);\n\t\t\t\t\telse pls(dp[b][a][nr-1],(ll)dp[i][j][0]*p2[nr-r-1]%mod);\n\t\t\t\t}\n\t\t\t\tpls(ans,(ll)dp[i][j][0]*p2[m-r]%mod);\n\t\t\t}\n\t\t\telse if(r<=0)\n\t\t\t{\n\t\t\t\tpls(dp[i][j][0],1);\n\t\t\t\tREP(a,i+2,n)REP(b,a,n)\n\t\t\t\t{\n\t\t\t\t\tint nl=a+k+1,nr=b-k;\n\t\t\t\t\t//assert(nr>0);\n\t\t\t\t\tif(nl<=nr)pls(dp[b][a][0],(ll)dp[i][j][0]*p2[nl-1]%mod);\n\t\t\t\t\telse if(nr<=0)pls(dp[b][a][0],dp[i][j][0]);\n\t\t\t\t\telse if(nl>m)pls(dp[b][a][0],(ll)dp[i][j][0]*p2[m]%mod);\n\t\t\t\t\telse pls(dp[b][a][nr-1],(ll)dp[i][j][0]*p2[nr-1]%mod);\n\t\t\t\t}\n\t\t\t\tpls(ans,(ll)dp[i][j][0]*p2[m]%mod);\n\t\t\t}\n\t\t\telse if(l>m)\n\t\t\t{\n\t\t\t\tpls(dp[i][j][0],p2[m]);\n\t\t\t\tREP(a,i+2,n)REP(b,a,n)\n\t\t\t\t{\n\t\t\t\t\t//int nl=a+k,nr=b-k-1;\n\t\t\t\t\t//if(nl<=nr)pls(dp[a][b][0],(ll)dp[i][j][0]*p2[nl-1]%mod);\n\t\t\t\t\t//else if(nr<=0)pls(dp[a][b][0],dp[i][j][0]);\n\t\t\t\t\tpls(dp[b][a][0],dp[i][j][0]);\n\t\t\t\t\t//else pls(dp[a][b][nr-1],(ll)dp[i][j][0]*p2[nr-1]%mod);\n\t\t\t\t}\n\t\t\t\tpls(ans,dp[i][j][0]);\n\t\t\t}else {\n\t\t\t\tpls(dp[i][j][r-1],p2[r-1]);\n\t\t\t\tint s=dp[i][j][r-1],ns=0;\n\t\t\t\tREP(x,r,l)\n\t\t\t\t{\n\t\t\t\t\tint t=dp[i][j][x]; dp[i][j][x]=s;\n\t\t\t\t\tpls(s,dp[i][j][x]); pls(s,t);\n\t\t\t\t}\n\t\t\t\tREP(x,r,l)pls(dp[i][j][x],NB[i][j][x]);\n\t\t\t\tREP(x,r,l)pls(ns,dp[i][j][x]);\n\t\t\t\tREP(a,i+2,n)REP(b,a,n)\n\t\t\t\t{\n\t\t\t\t\tint nl=a+k+1,nr=b-k;\n\t\t\t\t\t//assert(nr>0);\n\t\t\t\t\tif(nl<=nr)pls(dp[b][a][0],(ll)ns*p2[nl-l-1]%mod);\n\t\t\t\t\telse if(nl>m)pls(dp[b][a][0],(ll)ns*p2[m-l]%mod);\n\t\t\t\t\telse if(l<nr)pls(dp[b][a][nr-1],(ll)ns*p2[nr-l-1]%mod);\n\t\t\t\t\telse{\n\t\t\t\t\t\tREP(x,r,l)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x<nr)pls(dp[b][a][l],dp[i][j][x]);\n\t\t\t\t\t\t\telse if(x>=nr)pls(dp[b][a][l],dp[i][j][x]),pls(NB[b][a][x],dp[i][j][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(x,r,l)pls(ans,(ll)dp[i][j][x]*p2[m-l]%mod);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 160;\nint mo, n, k;\nint f[N * 2][N][N], o;\n#define add(x, y) ((x) = ((x) + (y)) % mo)\nll solve2() {\n\tf[0][0][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int x = 0; x < i; x++) {\n\t\t\tfor(int y = 0; y < i; y++) if(f[i-1][x][y]) {\n\t\t\t\tfor(int o = 0; o < 2; o++) {\n\t\t\t\t\tint _x = x, _y = y;\n\t\t\t\t\tif (i & 1) {\n\t\t\t\t\t\t_x = o ? x + 1 : 0;\n\t\t\t\t\t\tif (_x * 2 > k) continue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_y = o ? y + 1 : 0;\n\t\t\t\t\t\tif (_y * 2 > k) continue;\n\t\t\t\t\t}\n\t\t\t\t\tadd(f[i][_x][_y], f[i - 1][x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) add(ans, f[n][i][j]);\n\t}\n\treturn ans;\n}\n\nll solve1() {\n\tf[o][0][0] = 1;\n\tint h = (k - 1) / 2, mid = n / 2 - h, t = (n + 1) / 2 - mid;\n\tfor(int i = 1; i <= h; i++) { //only even\n\t\tmemset(f[1 - o], 0, sizeof f[1 - o]);\n\t\tfor(int j = 0; j < i; j++) if (f[o][0][j])\n\t\t\tfor(int oo = 0; oo < 2; oo++) {\n\t\t\t\tadd(f[1 - o][0][oo ? j + 1 : 0], f[o][0][j]);\n\t\t\t}\n\t\to = 1 - o;\t\n\t}\n\tfor(int i = 1; i <= mid + t; i++) { //both\n\t\tmemset(f[1 - o], 0, sizeof f[1 - o]);\n\t\tfor(int j = 0; j <= k + 1; j++) {\n\t\t\tfor(int w = 0; w * 2 <= n; w++) if (f[o][j][w]) {\n\t\t\t\tfor(int o1 = 0; o1 < 2; o1++) {\n\t\t\t\t\tfor(int o2 = 0; o2 < (i > mid ? 1 : 2); o2++) {\n\t\t\t\t\t\tint _w = o2 ? w + 1 : 0;\n\t\t\t\t\t\tint _j = 0;\n\t\t\t\t\t\tif (o1 == 0) _j = 0;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (j) _j = j + 1;\n\t\t\t\t\t\t\tif (o2) _j = max(_j, _w + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_j <= k + 1) {\n\t\t\t\t\t\t\tadd(f[1 - o][_j][_w], f[o][j][w]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\to = 1 - o;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i <= k + 1; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tadd(ans, f[o][i][j]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n >> k >> mo;\n\tif (k & 1) {\n\t\tcout << solve1() << endl;\n\t} else {\n\t\tcout << solve2() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<map>\n#include<bitset>\n#include<fstream>\n#include<tr1/unordered_map>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define x first\n#define y second\n\nvoid proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\nint read()\n{\n\tint x = 0, f = 1; int c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 310;\nint n, K, mod;\nint f[maxn][maxn], g[maxn][maxn][maxn];\n\nvoid sol1()\n{\n\tK >>= 1; f[0][0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfor(int j = 0; j <= K; ++j)\n\t\t\t(f[i][0] += f[i - 1][j]) %= mod;\n\t\tfor(int j = 0; j < K; ++j)\n\t\t\t(f[i][j + 1] += f[i - 1][j]) %= mod;\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tfor(int i = 0; i <= K; ++i) (ans1 += f[n / 2][i]) %= mod;\n\tfor(int i = 0; i <= K; ++i) (ans2 += f[(n + 1) / 2][i]) %= mod;\n\tprintf(\"%d\\n\", (LL)ans1 * ans2 % mod);\n}\n\nvoid sol2()\n{\n\tg[0][0][0] = 1;\n\tfor(int i = 2; i - K <= n; i += 2)\n\t{\n\t\tfor(int j = 0; j <= n; ++j)\n\t\t\tfor(int k = 0; k <= K + 1; ++k)\n\t\t\t\t(g[i][0][0] += g[i - 2][j][k]) %= mod;\n\t\tif(i <= n)\n\t\t\tfor(int j = 0; j <= n; ++j)\n\t\t\t\tfor(int k = 0; k <= K + 1; ++k)\n\t\t\t\t\t(g[i][j + 1][0] += g[i - 2][j][k]) %= mod;\n\t\tif(i - K >= 1)\n\t\t\tfor(int j = 0; j <= n; ++j)\n\t\t\t{\n\t\t\t\tfor(int k = 1; k <= K; ++k)\n\t\t\t\t\t(g[i][0][k + 1] += g[i - 2][j][k]) %= mod;\n\t\t\t\t(g[i][0][0] += g[i - 2][j][0]) %= mod;\n\t\t\t}\n\t\tif(i <= n && i - K >= 1)\n\t\t\tfor(int j = 0; j <= n; ++j)\n\t\t\t\tfor(int k = 0; max(k, j + 1) <= K; ++k)\n\t\t\t\t\t(g[i][j + 1][max(k + 1, j + 2)] += g[i - 2][j][k]) %= mod;\n\t}\n\tint p = n + K - ((n + K) & 1), ans = 0;\n\tfor(int j = 0; j <= n; ++j)\n\t\tfor(int k = 0; k <= K + 1; ++k)\n\t\t\t(ans += g[p][j][k]) %= mod;\n\tcout << ans << endl;\n}\n\nint main()\n{\n\n\tn = read(), K = read(); mod = read();\n\tif(!(K & 1)) sol1();\n\telse sol2();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 155;\n\ntemplate <typename T> inline void read(T &AKSHOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKSHOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nnamespace ModCalculator {\n\tint MOD;\n\tinline void Inc(int &x, int y) {\n\t\tx += y; if (x >= MOD) x -= MOD;\n\t}\n\tinline void Dec(int &x, int y) {\n\t\tx -= y; if (x < 0) x += MOD;\n\t}\n\tinline int Add(int x, int y) {\n\t\tInc(x, y); return x;\n\t}\n\tinline int Sub(int x, int y) {\n\t\tDec(x, y); return x;\n\t}\n\tinline int Mul(int x, int y) {\n\t\treturn 1LL * x * y % MOD;\n\t}\n\tinline int Ksm(int x, int k) {\n\t\tint ret = 1;\n\t\tfor (; k; k >>= 1) {\n\t\t\tif (k & 1) ret = Mul(ret, x);\n\t\t\tx = Mul(x, x);\n\t\t}\n\t\treturn ret;\n\t}\n\tinline int Inv(int x) {\n\t\treturn Ksm(x, MOD - 2);\n\t}\n}\nusing namespace ModCalculator;\n\nint n, k;\n\nint f[N][N];\n\nvoid solve1() {\n    k >>= 1;\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= k; ++j) {\n            Inc(f[i][0], f[i - 1][j]);\n            Inc(f[i][j + 1], f[i - 1][j]);\n        }\n    }\n    int ans1 = 0, ans2 = 0;\n    for (int j = 0; j <= k; ++j) {\n        Inc(ans1, f[n / 2][j]);\n        Inc(ans2, f[(n + 1) / 2][j]);\n    }\n    printf(\"%d\\n\", Mul(ans1, ans2));\n}\n\nint dp[2][N][N];\n\nvoid solve2() {\n    dp[0][0][0] = 1;\n    int pre = 0, cur = 1;\n    for (int i = 1; i * 2 <= n + k; ++i) {\n        mset(dp[cur], 0);\n        for (int j = 0; j <= k + 1; ++j) {\n            for (int t = 0; t <= n; ++t) {\n                int x = dp[pre][j][t];\n                if (!x) continue;\n                Inc(dp[cur][0][0], x);\n                if (i * 2 <= n) {\n                    Inc(dp[cur][0][t + 1], x);\n                }\n                if (i * 2 >= k + 1) {\n                    Inc(dp[cur][j + (j > 0)][0], x);\n                }\n                if (i * 2 <= n && i * 2 >= k + 1) {\n                    Inc(dp[cur][max(j + 1, t + 2)][t + 1], x);\n                }\n            }\n        }\n        swap(pre, cur);\n    }\n    int ans = 0;\n    for (int j = 0; j <= k + 1; ++j) {\n        for (int t = 0; t <= n; ++t) {\n            Inc(ans, dp[pre][j][t]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main(){\n    read(n); read(k); read(MOD);\n    if (k & 1) solve2();\n    else solve1();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 160;\n\nint N, K;\nll M;\n\nll dp[MAXN][MAXN][MAXN]; // cloc\nll ndp[MAXN][MAXN];\n\nll dans (int X, int Y)\n{\n    // whatevs\n    for (int i = 0; i < MAXN; i++)\n        for (int j = 0; j < MAXN; j++)\n            ndp[i][j] = 0;\n    ndp[0][0] = 1;\n    for (int i = 0; i < X; i++)\n    {\n        for (int j = 0; j <= Y; j++)\n        {\n            ndp[i+1][j+1] += ndp[i][j];\n            ndp[i+1][j+1] %= M;\n            ndp[i+1][0] += ndp[i][j];\n            ndp[i+1][0] %= M;\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 0; i <= Y; i++)\n        ans = (ans + ndp[X][i]) % M;\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> N >> K >> M;\n\n    if (K % 2 == 0)\n    {\n        ll a1 = dans (N / 2, K / 2);\n        ll a2 = dans ((N + 1) / 2, K / 2);\n        cout << (a1 * a2) % M << \"\\n\";\n        return 0;\n    }\n\n    for (int i = 0; i < MAXN; i++)\n        for (int j = 0; j < MAXN; j++)\n            for (int k = 0; k < MAXN; k++)\n                dp[i][j][k] = 0;\n    dp[0][0][0] = 1;\n    for (int i = 1; i <= N + 1; i++)\n    {\n        int cloc = 2 * i;\n        int dloc = cloc - K;\n        bool cgood = false;\n        bool dgood = false;\n        if (cloc >= 1 && cloc <= N) cgood = true;\n        if (dloc >= 1 && dloc <= N) dgood = true;\n\n        for (int j = 0; j <= N; j++)\n            for (int k = 0; k <= K; k++)\n            {\n                if (!dp[i-1][j][k]) continue;\n\n                dp[i][0][0] += dp[i-1][j][k];\n                dp[i][0][0] %= M;\n                if (cgood)\n                {\n                    dp[i][j+1][0] += dp[i-1][j][k];\n                    dp[i][j+1][0] %= M;\n                }\n                if (dgood)\n                {\n                    if (k == 0)\n                    {\n                        dp[i][0][k] += dp[i-1][j][k];\n                        dp[i][0][k] %= M;\n                    }\n                    else\n                    {\n                        dp[i][0][k+1] += dp[i-1][j][k];\n                        dp[i][0][k+1] %= M;\n                    }\n                }\n                if (cgood && dgood)\n                {\n                    dp[i][j+1][max(k+1, j+1)] += dp[i-1][j][k];\n                    dp[i][j+1][max(k+1, j+1)] %= M;\n                }\n            }\n    }\n    cout << dp[N+1][0][0] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\n\nll from[151];\nll to[151];\n\nll hoge(int N) {\n\tZERO(from);\n\tfrom[0]=1;\n\tint i,j;\n\tFOR(i,N) {\n\t\tZERO(to);\n\t\tFOR(j,K+1) {\n\t\t\t(to[0]+=from[j])%=mo;\n\t\t\tif(j+1<=K) (to[j+1]+=from[j])%=mo;\n\t\t}\n\t\t\n\t\tswap(from,to);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,N+1) ret+=from[i];\n\treturn ret%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tif(K%2==0) {\n\t\tK/=2;\n\t\tcout<<hoge(N/2)*hoge((N+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tassert(0);\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\n\nint mod;\n\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint& v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0) val += mod;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& a) { return os << a.val; }\n\tfriend bool operator==(const mint& a, const mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint& operator+=(const mint& m) { if ((val += m.val) >= mod) val -= mod; return *this; }\n\tmint& operator-=(const mint& m) { if ((val -= m.val) < 0) val += mod; return *this; }\n\tmint& operator*=(const mint& m) { val = (lint)val*m.val%mod; return *this; }\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint& a) { assert(a.val); return ipow(a, mod - 2); }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n\toperator int64_t() const {return val; }\n};\n\nmint ez(int n, int k){\n\tvector<mint> dp(n + 2);\n\tdp[0] = mint(1);\n\tfor(int i=1; i<=n+1; i++){\n\t\tfor(int j=1; j<=k+1 && j<=i; j++){\n\t\t\tdp[i] += dp[i - j];\n\t\t}\n\t}\n\treturn dp[n + 1];\n}\n\nvector<int> v;\nmint dp[155][155][155][2], nxt[155][155][155][2];\nmint sex[155][155][155];\nint kk;\n\nint adj[20][20];\nbool in(int msk, int val){\n\tif(val > 20 || val < 0) return 0;\n\treturn (msk >> val) & 1;\n}\n\nint g(int n, int k){\n\tint ret = 0;\n\tfor(int i=0; i<(1<<n); i++){\n\t\tmemset(adj, 0, sizeof(adj));\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(in(i, j - 2)) adj[j][j - 2] = 1;\n\t\t\tif(in(i, j + k)) adj[j][j + k] = 1;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tadj[j][k] |= (adj[j][i] & adj[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool good = 1;\n\t\tfor(int i=0; i<n; i++) if(adj[i][i]) good = 0;\n\t\tret += good;\n\t}\n\treturn ret;\n}\n\nmint f(int pos, int l, int dp){\n\tif(dp >= kk) return mint(0);\n\tif(pos == sz(v)) return mint(1);\n\tif(sex[pos][l][dp]) return sex[pos][l][dp];\n\tmint ret = f(pos + 1, 0, 0);\n\tif(v[pos] & 1){\n\t\tret += f(pos + 1, l + 1, 0);\n\t}\n\tif(v[pos] & 2){\n\t\tret += f(pos + 1, 0, dp ? (dp + 1) : 0);\n\t}\n\tif(v[pos] == 3){\n\t\tret += f(pos + 1, l + 1, max(l + 2, dp + 1));\n\t}\n\treturn sex[pos][l][dp] = ret;\n}\n\nmint solve(int n, int thr){\n\tkk = thr;\n\treturn f(0, 0, 0);\n\tdp[0][0][0][0] = 1;\n\tfor(auto &x : v){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i=0; i<=n; i++){ // short\n\t\t\tfor(int j=0; j<=n; j++){ // long\n\t\t\t\tfor(int k=0; k<=thr; k++){ // long with tail\n\t\t\t\t\tfor(int l=0; l<2; l++){ // 1 if up is long\n\t\t\t\t\t\tif((lint)dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t\tnxt[0][0][0][0] += dp[i][j][k][l];\n\t\t\t\t\t\tint next_k = 0;\n\t\t\t\t\t\tif(k > 0) next_k = k + 1;\n\t\t\t\t\t\telse if(i > 0) next_k = i + 2;\n\t\t\t\t\t\tif(x & 1){\n\t\t\t\t\t\t\tif(l == 0){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x & 2){\n\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x == 3){\n\t\t\t\t\t\t\tnxt[i + 1][j + 1][k ? (k + 1) : 0][l] += dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int k=0; k<thr; k++){\n\t\t\t\t\tif(i > 0 && j >= thr - 1){\n\t\t\t\t\t\tnxt[i][j][k][0] = nxt[i][j][k][1] = mint(0);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k][0] = nxt[i][j][k][0];\n\t\t\t\t\tdp[i][j][k][1] = nxt[i][j][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=thr; k++){\n\t\t\t\tfor(int l=0; l<2; l++) ret += dp[i][j][k][l];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k >> mod;\n\tif(k % 2 == 0){\n\t\tcout << ez((n + 1) / 2, k / 2) * ez(n / 2, k / 2) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n+n; i+=2){\n\t\tif(i - k > n) break;\n\t\tint msk = 0;\n\t\tif(i <= n) msk |= 1;\n\t\tif(i - k >= 1) msk |= 2;\n\t\tv.push_back(msk);\n\t}\n\tmint ret = solve(n, k + 2);\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//2019.7.22 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 1e18+1e9\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=150+10;\nnamespace MAIN{\n    int n,k,kcz;\n    int dp[N][N][N];\n    int f[N][N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline int solve(const res &n,const res &k){\n        for(res i=0;i<=n;i++)\n            for(res j=0;j<=k;j++)\n                f[i][j]=0;\n        f[0][0]=1;\n        for(res i=0;i<n;i++)\n            for(res j=0;j<=k;j++)\n                if(f[i][j])add(f[i+1][0],f[i][j]),add(f[i+1][j+1],f[i][j]);\n        res ret=0;\n        for(res i=0;i<=k;i++)add(ret,f[n][i]);\n        return ret;\n    }\n    inline void MAIN(){\n        n=read(),k=read(),kcz=read();\n        if(k%2==0){printf(\"%d\\n\",mul(solve(n>>1,k>>1),solve(n-(n>>1),k>>1)));return;}\n        dp[0][0][0]=1;\n        for(res i=0;i<=n;i++){\n            res r=i<<1,l=r-k;\n            for(res j=0;j<=n;j++)\n                for(res p=0;p<=k;p++)\n                    if(dp[i][j][p]){\n                        add(dp[i+1][0][0],dp[i][j][p]);\n                        if((1<=r&&r<=n)&&(1<=l&&l<=n))add(dp[i+1][j+1][max(p+1,j+1)],dp[i][j][p]);\n                        if((1<=r&&r<=n))add(dp[i+1][j+1][0],dp[i][j][p]);\n                        if((1<=l&&l<=n))add(dp[i+1][0][p?p+1:p],dp[i][j][p]);\n                    }\n        }\n        printf(\"%d\\n\",dp[n+1][0][0]);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint n, k, m;\n\nInt dp[165][165][165];\n\nbool between(int a, int b, int c){\n    return a < b && b < c;\n}\n\nint main(){\n    cin >> n >> k >> m;\n    if(k % 2 == 0){\n        vector<Int> dp(n+1, 0);\n        dp[0] = 1;\n        for(int i = 1;i <= n;i++){\n            for(int j = max(0, i - k/2-1);j < i;j++){\n                dp[i] += dp[j];\n                dp[i] %= m;\n            }\n            cout << i << \" \" << dp[i] << endl;\n        }\n        cout << dp[n/2 + 1] * dp[n-n/2 + 1] % m << endl;\n    }\n    else{\n        int goal = n+3;\n        n+=10;\n        dp[0][2][1] = 1;\n        for(int a = 0;a <= n;a++){\n            for(int b = a+2;b <= n;b+=2){\n                for(int c = !(a%2);c < b;c+=2){\n                    for(int d = c+2;d <= n;d+=2){\n                        if(d-2 > c && between(a, d-2-k, b) && between(a, d-2+k, b))break;\n                        if(d-2 > c && b-2 > a&& between(a, d-2-k, b) && between(c, b-2-k ,d))break;\n                        \n                        if(b > d)(dp[a][b][d] += dp[a][b][c]) %= m;\n                        else (dp[c][d][b] += dp[a][b][c])%= m;\n                    }\n                }\n            }\n        }\n        cout << dp[goal][goal+2][goal+1] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,k,m;\n\nint s1(int n,int k)\n{\n\tstatic int f[155];\n\tf[0] = 1;\n\tfor(int i = 1;i <= n + 1; ++ i)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tif(i - j - 1 >= 0)\n\t\t\t\tf[i] = (f[i] + f[i - j - 1]) % m;\n\t}\n\treturn f[n + 1];\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&m);\n\tif(k % 2 == 0)\n\t{\n\t\tprintf(\"%d\\n\",(s1(n / 2,k / 2) * 1ll * s1((n + 1) / 2,k / 2)) % m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, k, M;\n  cin >> n >> k >> M;\n  function<int(int)> norm = [&](int x) { return x >= M ? x - M : x; };\n  function<void(int&, int)> add = [&](int& x, int y) {\n    (x += y) >= M ? x -= M : 0;\n  };\n  function<void(int&, int)> sub = [&](int& x, int y) {\n    (x -= y) < 0 ? x += M : 0;\n  };\n  if (k % 2 == 0) {\n    function<vi(int, int)> easy = [&](int n, int k) {\n      vi dp(n + 2);\n      dp[0] = 1;\n      for (int i = 1; i <= n + 1; ++i)\n        for (int j = 1; j <= k + 1 && j <= i; ++j)\n          add(dp[i], dp[i - j]);\n      dp.erase(dp.begin());\n      return dp;\n    };\n    vi need = easy((n + 1) / 2, k / 2);\n    cout << need[n / 2] * (ll)need[(n + 1) / 2] % M;\n  } else {\n    int nn = n / 2 + 1;\n    static int dp[80][80][160], newdp[80][80][160];\n    dp[0][0][0] = 1;\n    const int INF = 1 << 30;\n    static int glt[80][80];\n    function<int(int, int)> gl = [&](int a, int b) {\n      a = min(a, k / 2 + 2);\n      if ((b - a + 1) * 2 < k - a * 2 + 3 || a <= 0)\n        return INF;\n//      cerr << a << ' ' << b << \": \" << (k - a * 2 + 3) << '\\n';\n      return (k - a * 2 + 3) / 2 - 1;\n    };\n    for (int i = 0; i <= nn; ++i)\n      for (int j = 0; j <= nn; ++j) {\n        if (i >= k / 2 + 2 && j >= k / 2 + 1) continue;\n        glt[j + 1][i] = gl(j + 1, i);\n      }\n    for (int rep = 0; rep < n; ++rep) {\n      memset(newdp, 0, sizeof(newdp));\n      for (int i = 0; i <= nn; ++i)\n        for (int j = 0; j <= nn; ++j) {\n          if (i >= k / 2 + 2 && j >= k / 2 + 1) continue;\n          // no limit\n          add(newdp[0][i][0], dp[i][j][0]);\n          int v = glt[j + 1][i];\n          //cerr << v << ' ';\n          if (j < k / 2 + 1 || i < k / 2 + 1)\n            add(newdp[j + 1][i][v == INF ? 0 : ((v + 1) << 1)], dp[i][j][0]);\n          // this\n          add(newdp[0][i][0], dp[i][j][2]);\n          for (int l = 1; l <= nn; ++l) {\n            add(newdp[0][i][0], dp[i][j][(l + 1) << 1]);\n            if (j < k / 2 + 1 || i < k / 2 + 1)\n              add(newdp[j + 1][i][(l - 1) << 1 | 1], dp[i][j][(l + 1) << 1]);\n          }\n          // those\n          for (int l = 0; l <= nn; ++l) {\n            add(newdp[0][i][(l + 1) << 1], dp[i][j][l << 1 | 1]);\n            if (j < k / 2 + 1 || i < k / 2 + 1) {\n              add(newdp[j + 1][i][(min(glt[j + 1][i], l) + 1) << 1], dp[i][j][l << 1 | 1]);\n              //cerr << glt[j + 1][i] << ' ';\n            }\n          }\n        }\n      memcpy(dp, newdp, sizeof(dp));\n    }\n    int ans = 0;\n    for (int i = 0; i <= nn; ++i)\n      for (int j = 0; j <= nn; ++j)\n        for (int l = 0; l <= n + 5; ++l)\n          add(ans, dp[i][j][l]);\n    cout << ans;\n  }\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%mod\n#define ll long long\n//#define file\nusing namespace std;\n\nll f[151][151][151][2][2],g[151][151],ans;\nint n,m,mod,i,j,k,l,p1,p2,I,J,K,L,P1,P2,s;\n\nll qpower(ll a,int b) {ll ans=1;while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc035E.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d%d\",&n,&m,&mod);\n\tif (m==n) {printf(\"%lld\\n\",qpower(2,n));return 0;}\n\t\n\tif (!(m&1))\n\t{\n\t\tg[0][0]=1;\n\t\tfo(i,1,n)\n\t\t{\n\t\t\tfo(j,0,m/2)\n\t\t\t{\n\t\t\t\tif (j<m/2) add(g[i][j+1],g[i-1][j]);\n\t\t\t\tadd(g[i][0],g[i-1][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tj=k=0;\n\t\tfo(i,0,m/2) add(j,g[(n+1)/2][i]),add(k,g[n/2][i]);\n\t\tprintf(\"%lld\\n\",1ll*j*k%mod);\n\t}\n\telse\n\t{\n\t\tf[0][0][0][0][0]=1;\n\t\tfo(i,1,n)\n\t\t{\n\t\t\tfo(j,0,i-1)\n\t\t\t{\n\t\t\t\tfo(k,0,i-1)\n\t\t\t\t{\n\t\t\t\t\tfo(p1,0,1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfo(p2,0,1)\n\t\t\t\t\t\tif (f[i-1][j][k][p1][p2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfo(s,0,1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (s) //yes\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (i&1)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tK=k,P2=p2;\n\t\t\t\t\t\t\t\t\t\tif (!p1) J=j+1;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{if (j==1) continue; else J=j-1,P1=1;};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tJ=j,P1=p1;\n\t\t\t\t\t\t\t\t\t\tif (!p2) K=k+1;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{if (k==1) continue; else K=k-1,P2=1;};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse //no\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (i&1)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (p1 || p2 || k<m/2+2 || !j)\n\t\t\t\t\t\t\t\t\t\tJ=0,P1=0,K=k,P2=p2;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (j>=m/2+1) continue;\n\t\t\t\t\t\t\t\t\t\t\tJ=0,P1=0,K=m/2+1-j,P2=1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (p2 || p1 || j<m/2+2 || !k)\n\t\t\t\t\t\t\t\t\t\tK=0,P2=0,J=j,P1=p1;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (k>=m/2+1) continue;\n\t\t\t\t\t\t\t\t\t\t\tK=0,P2=0,J=m/2+1-k,P1=1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(f[i][J][K][P1][P2],f[i-1][j][k][p1][p2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfo(j,0,n)\n\t\t{\n\t\t\tfo(k,0,n)\n\t\t\t{\n\t\t\t\tfo(p1,0,1)\n\t\t\t\t{\n\t\t\t\t\tfo(p2,0,1)\n\t\t\t\t\tif (f[n][j][k][p1][p2] && !((!p1 && !p2 && ((n&1) && j>m/2+1 || !(n&1) && j>m/2)) && (!(n&1) && k>m/2+1 || (n&1) && k>m/2)))\n\t\t\t\t\tadd(ans,f[n][j][k][p1][p2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 150\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\nusing namespace std;\nint n,k,X,f[N+5][N+5];\nI int DP(CI n,CI k)\n{\n\tRI i,j,ans=0;for(f[0][0]=i=1;i<=n;++i)\n\t\tfor(f[i][0]=f[i-1][0],j=1;j<=k;++j) f[i][j]=f[i-1][j-1],Inc(f[i][0],f[i-1][j]);\n\tfor(i=0;i<=k;++i) Inc(ans,f[n][i]);return ans;\n}\nint main()\n{\n\treturn scanf(\"%d%d%d\",&n,&k,&X),printf(\"%d\",1LL*DP(n+1>>1,k>>1)*DP(n>>1,k>>1)%X),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <chrono>\n#include <random>\n#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstatic const int Maxn = 155;\n\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\n\nint n, k, mod;\ninline int add(int x, int y) { return (x += y) >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { (x += y) >= mod && (x -= mod); }\ninline int mul(int x, int y) { return 1LL * x * y - 1LL * x * y / mod * mod; }\n\nnamespace solve1 {\n/* N个数中选一些数使得连续段的长度不超过K */\n  int dp[Maxn][Maxn];\n  int solve(int n, int k) {\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= k; ++j) {\n      inc(dp[i + 1][0], dp[i][j]);\n    }\n    for (int j = 0; j < k; ++j) {\n      inc(dp[i + 1][j + 1], dp[i][j]);\n    }\n  }\n  int res = 0;\n  for (int j = 0; j <= k; ++j) {\n    inc(res, dp[n][j]);\n  }\n  return res;\n  }\n}\n\nnamespace solve2 {\n  int n, k;\n  unordered_map<long long, int, custom_hash> dp[Maxn];\n  inline long long encode(int p, int q, int mxp, int mxq) {\n    return (p * 1LL << 40) | (q * 1LL << 30) | (mxp * 1LL << 20) | (mxq * 1LL << 10);\n  }\n  int dfs(int pos, int p, int q, int mxp, int mxq) {\n    if (mxp < pos || mxq < pos) return 0;\n    if (pos == n) return 1;\n    p = min(p, k / 2 + 1);\n    q = min(q, k / 2 + 1);\n    long long enc = encode(p, q, mxp, mxq);\n    if (dp[pos].find(enc) != dp[pos].end()) return dp[pos][enc];\n    int &ans = dp[pos][enc]; ans = 0;\n    int res1, res2;\n\n// 填入数pos\n    int newmxp = n, newmxq = n;\n    if (pos % 2 == 0 && 2 * q - 1 >= k) newmxq = pos + k - 2 * min(k / 2, p);\n    if (pos % 2 == 1 && 2 * p - 1 >= k) newmxp = pos + k - 2 * min(k / 2, q);\n    int newp = p + (pos % 2 == 0), newq = q + (pos % 2 == 1);\n    res1 = dfs(pos + 1, newp, newq, min(mxp, newmxp), min(mxq, newmxq));\n\n// 不填数pos\n    if (pos % 2 == 0) res2 = dfs(pos + 1, 0, q, n, mxq);\n    else res2 = dfs(pos + 1, p, 0, mxp, n);\n\n    return ans = add(res1, res2);\n  }\n  int solve(int n, int k) {\n    solve2::n = n, solve2::k = k;\n    for (int i = 0; i <= n; ++i) {\n      unordered_map<long long, int, custom_hash> empty_tmp;\n      dp[i].swap(empty_tmp);\n    }\n    return dfs(0, 0, 0, n, n);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &mod);\n  if (k == 1) {\n    printf(\"%d\\n\", solve1::solve(n, 2));\n    return 0;\n  }\n  if (k % 2 == 0) {\n    int odd = solve1::solve(n + 1 >> 1, k >> 1);\n    int even = solve1::solve(n >> 1, k >> 1);\n    printf(\"%d\\n\", mul(odd, even));\n    return 0;\n  }\n  printf(\"%d\\n\", solve2::solve(n, k));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,k,mod,fff[161][161],m,ans1,ans2,f[81][81][81],mi[81],Sum[81][81],s[81][81],nwS[81],nws[81];\n\nint add(int x,int y) {return (x+y>=mod?x+y-mod:x+y);}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tif (!(k&1))\n\t{\n\t\tfff[0][0]=1,k>>=1,m=(n+1>>1),k++;\n\t\tfor (int i=0; i<m; i++)\n\t\t\tfor (int j=0; j<k; j++) if (fff[i][j])\n\t\t\t{\n\t\t\t\tfff[i+1][j+1]=(fff[i+1][j+1]+fff[i][j])%mod;\n\t\t\t\tfff[i+1][0]=(fff[i+1][0]+fff[i][j])%mod;\n\t\t\t}\n\t\tans1=ans2=0;\n\t\tfor (int i=0; i<k; i++) ans1=(ans1+fff[n>>1][i])%mod;\n\t\tfor (int i=0; i<k; i++) ans2=(ans2+fff[n+1>>1][i])%mod;\n\t\treturn printf(\"%d\\n\",1ll*ans1*ans2%mod),0;\n\t} \n\tmi[0]=1;\n\tfor (int i=1; i<=80; i++) mi[i]=2ll*mi[i-1]%mod;\n\tm=(n>>1),n=(n+1>>1);\n\tfor (int k=0; k<=m; k++) Sum[0][k]=mi[k];\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=i; j++)\n\t\t{\n\t\t\tint l=max(j-2,0);\n\t\t\tif (i-j+1>=k+1) f[i][i-(k+1>>1)+1][i-(k+1>>1)]=add(f[i][i-(k+1>>1)+1][i-(k+1>>1)],Sum[l][j+(k>>1)-1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int o=(j+(k>>1)>m)?1:max(1,i-(k+1>>1)+1); o<=j+(k>>1)+1&&o<=m+1; o++)\n\t\t\t\t\tf[i][o][min(j+(k>>1),m)]=add(f[i][o][min(j+(k>>1),m)],Sum[l][max(o-2,0)]),\n\t\t\t\t\tf[i][o][min(j+(k>>1),m)]=add(f[i][o][min(j+(k>>1),m)],s[l][o]);\n\t\t\t}\n\t\t}\n\t\tnwS[0]=0;\n\t\tfor (int j=0; j<=m+1; j++) nwS[0]=add(nwS[0],f[i][j][0]);\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tnwS[j]=0;\n\t\t\tfor (int k=0; k<=m+1; k++) nwS[j]=add(nwS[j],f[i][k][j]);\n\t\t\tnwS[j]=add(add(nwS[j-1],nwS[j-1]),nwS[j]);\n\t\t}\n\t\tfor (int j=0; j<=m; j++) Sum[i][j]=add(Sum[i-1][j],nwS[j]);\n\t\tfor (int j=1; j<=m+1; j++)\n\t\t{\n\t\t\tnws[j]=0;\n\t\t\tfor (int k=0; k<=m; k++) nws[j]=add(nws[j],f[i][j][k]);\n\t\t}\n\t\tfor (int j=1; j<=m+1; j++) s[i][j]=add(s[i-1][j],nws[j]);\n\t}\n\treturn printf(\"%d\\n\",Sum[n][m]),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 155;\nint n, k, mod;\n\nvoid up(int &x, int y) { x += y - mod, x += x >> 31 & mod; }\n\nvoid solve0() {\n\tstatic int dp[N][N]; k >>= 1, dp[0][0] = 1;\n\tfor (int i = 0; i < n + 1 >> 1; ++i) {\n\t\tfor (int j = 1; j <= k; ++j)\n\t\t\tdp[i + 1][j] = dp[i][j - 1];\n\t\tfor (int j = 0; j <= k; ++j)\n\t\t\tup(dp[i + 1][0], dp[i][j]);\n\t}\n\tint a = 0, b = 0;\n\tfor (int i = 0; i <= k; ++i)\n\t\tup(a, dp[n >> 1][i]), up(b, dp[n + 1 >> 1][i]);\n\tstd::cout << (LL) a * b % mod << '\\n';\n}\n\nvoid solve1() {\n\tstatic int dp[N][N][N];\n\tdp[0][0][0] = 1;\n\tconst int L = k >> 1, R = n >> 1;\n\tfor (int i = 0; i < n + k >> 1; ++i)\n\t\tfor (int j = 0; j <= k + 1; ++j)\n\t\t\tfor (int l = 0; l <= n >> 1; ++l)\n\t\t\t\tif (int v = dp[i][j][l]) {\n\t\t\t\t\tup(dp[i + 1][0][0], v);\n\t\t\t\t\tif (i >= L)\n\t\t\t\t\t\tup(dp[i + 1][j + !!j][0], v);\n\t\t\t\t\tif (i < R)\n\t\t\t\t\t\tup(dp[i + 1][0][l + 1], v);\n\t\t\t\t\tif (i >= L && i < R)\n\t\t\t\t\t\tup(dp[i + 1][std::max(j + 1, l + 2)][l + 1], v);\n\t\t\t\t}\n\tint ans = 0;\n\tfor (int j = 0; j <= k + 1; ++j)\n\t\tfor (int l = 0; l <= n >> 1; ++l)\n\t\t\tup(ans, dp[n + k >> 1][j][l]);\n\tstd::cout << ans << '\\n';\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> k >> mod;\n\tif (k & 1) solve1(); else solve0();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\n\nint mod;\n\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint& v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0) val += mod;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& a) { return os << a.val; }\n\tfriend bool operator==(const mint& a, const mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint& operator+=(const mint& m) { if ((val += m.val) >= mod) val -= mod; return *this; }\n\tmint& operator-=(const mint& m) { if ((val -= m.val) < 0) val += mod; return *this; }\n\tmint& operator*=(const mint& m) { val = (lint)val*m.val%mod; return *this; }\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint& a) { assert(a.val); return ipow(a, mod - 2); }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n\toperator int64_t() const {return val; }\n};\n\nmint ez(int n, int k){\n\tvector<mint> dp(n + 2);\n\tdp[0] = mint(1);\n\tfor(int i=1; i<=n+1; i++){\n\t\tfor(int j=1; j<=k+1 && j<=i; j++){\n\t\t\tdp[i] += dp[i - j];\n\t\t}\n\t}\n\treturn dp[n + 1];\n}\n\nvector<int> v;\nmint dp[155][155][155][2], nxt[155][155][155][2];\n\nmint solve(int n, int thr){\n\tdp[0][0][0][0] = 1;\n\tfor(auto &x : v){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i=0; i<=n; i++){ // short\n\t\t\tfor(int j=0; j<=n; j++){ // long\n\t\t\t\tfor(int k=0; k<=thr; k++){ // long with tail\n\t\t\t\t\tfor(int l=0; l<2; l++){ // 1 if up is long\n\t\t\t\t\t\tif((lint)dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t\tnxt[0][0][0][0] += dp[i][j][k][l];\n\t\t\t\t\t\tint next_k = 0;\n\t\t\t\t\t\tif(k > 0) next_k = k + 1;\n\t\t\t\t\t\telse if(i > 0) next_k = i + 2;\n\t\t\t\t\t\tif(x & 1){\n\t\t\t\t\t\t\tif(l == 0){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x & 2){\n\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x == 3){\n\t\t\t\t\t\t\tnxt[i + 1][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int k=0; k<thr; k++){\n\t\t\t\t\tif(i >= thr - 1 || (i > 0 && j >= thr - 1)){\n\t\t\t\t\t\tnxt[i][j][k][0] = nxt[i][j][k][1] = mint(0);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k][0] = nxt[i][j][k][0];\n\t\t\t\t\tdp[i][j][k][1] = nxt[i][j][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=thr; k++){\n\t\t\t\tfor(int l=0; l<2; l++) ret += dp[i][j][k][l];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k >> mod;\n\tif(k % 2 == 0){\n\t\tcout << ez((n + 1) / 2, k / 2) * ez(n / 2, k / 2) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n+n; i+=2){\n\t\tif(i - k > n) break;\n\t\tint msk = 0;\n\t\tif(i <= n) msk |= 1;\n\t\tif(i - k >= 1) msk |= 2;\n\t\tv.push_back(msk);\n\t}\n\tmint ret = solve(n, k + 2);\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nll M;\nint n, k;\n\nconst int N = 160;\nset<string> all;\n\nstring target = \"000101000\";\nset<string> used;\n\nint zip(int x, int y, int xup, int yup) {\n\treturn min(N - 1, (x < y) ? xup : yup);\n}\n\nint mem[N][N][N][N];\n\nint dp(int i, int x, int y, int xup, int yup) {\n\tif (i == n)\n\t\treturn 1;\n\tif (mem[i][x][y][zip(x, y, xup, yup)] != -1) return mem[i][x][y][zip(x, y, xup, yup)];\n\tint rez = 0;\n\t// take\n\t{\n\t\tint nxup = xup;\n\t\tif (nxup > i) {\n\t\t\trez += dp(i + 1, y, x, yup, nxup);\n\t\t}\n\t}\n\t// don't\n\t{\n\t\tint nyup = yup;\n\t\tif (nyup - k <= i && i <= y + k)\n\t\t\tnyup = i + k + 2;\n\t\trez += dp(i + 1, max(y, nyup - k - k), i + 2, nyup, i + 3 + k);\n\t}\n\trez -= (rez >= M) * M;\n\treturn mem[i][x][y][zip(x, y, xup, yup)] = rez;\n}\n\n\nvoid go(string s) {\n\tused.insert(s);\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] == '1') {\n\t\t\tstring t = s;\n\t\t\tif (i - 2 >= 0)\n\t\t\t\tt[i - 2] = '1';\n\t\t\tif (i + k < n)\n\t\t\t\tt[i + k] = '1';\n\t\t\tt[i] = '0';\n\t\t\tif (!used.count(t))\n\t\t\t\tgo(t);\n\t\t}\n}\n\nint hard[N][N];\n\nint easy(int n, int combo) {\n\tif (n == 0) return 1;\n\tif (hard[n][combo] != -1) return hard[n][combo];\n\tint rez = 0;\n\tif (combo != k - 1) \n\t\trez += easy(n - 1, combo + 1);\n\trez += easy(n - 1, 0);\n\trez -= (rez >= M) * M;\n\treturn hard[n][combo] = rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tmemset(hard, -1, sizeof hard);\n\tscan n, k, M;\n\tif (k & 1) {\n\t\tprint dp(0, 0, 1, 1 + k, 2 + k);\n\t} else {\n\t\tk /= 2;\n\t\tk++;\n\t\tprint (easy(n / 2, 0) * easy((n + 1) / 2, 0)) % M;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n,k,p;\nnamespace work1{\n\tint f[155],g[155];\n\tint dp(int n,int k){\n\t\tf[0]=1;\n\t\tg[0]=1;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tf[i]=0;\n\t\t\tfor(int j=1;j<=k && j<=i;++j){\n\t\t\t\t(f[i]+=g[i==j?0:i-j-1])>=p?f[i]-=p:0;\n\t\t}\n\t\t\t(g[i]=f[i]+g[i-1])>=p?g[i]-=p:0;\n\t\t}\n\t\treturn g[n];\n\t}\n}\nnamespace work2{\n\tint f[79],g[79][79],l[79],r[79];\n\tint &add(int &a,int b){return (a+=b)>=p?a-=p:a;}\n\tvoid main(){\n\t\tint m1=n>>1,m2=(n+1)>>1;\n\t\tint w=1;\n\t\tg[0][0]=1;\n\t\tfor(int i=1;i<=m1;++i){\n\t\t\tint x=((i<<1)-k+1);\n\t\t\tif(x<=0)l[i]=0;\n\t\t\telse l[i]=x>>1;\n\t\t\tx=((i<<1)+k+1);\n\t\t\tr[i]=x>>1;\n\t\t\tchkmin(r[i],m2+1);\n\t\t}\n\t\tfor(int i=1;i<=m2;++i){\n\t\t\tg[0][i]=w;\n\t\t\t(w<<=1)>=p?w-=p:0;\n\t\t}\n\t\tfor(int i=1;i<=m1;++i){\n\t\t\tfor(int j=1;j<=i;++j){\n\t\t\t\tfor(int k=0;k<=m2;++k)f[k]=g[j==1?0:j-2][k];\n\t\t\t\tif(l[i]>=r[j]){\n\t\t\t\t\tf[l[i]]=f[r[j]];\n\t\t\t\t\tfor(int k=0;k<l[i];++k)f[k]=0;\n\t\t\t\t\tint w=f[l[i]];\n\t\t\t\t\tfor(int k=l[i]+1;k<=m2;++k){\n\t\t\t\t\t\tf[k]=w;\n\t\t\t\t\t\tadd(w,f[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(r[j]<=m2){\n\t\t\t\t\t\tfor(int k=0;k<l[i];++k)f[k]=0;\n\t\t\t\t\t\tint s=0;\n\t\t\t\t\t\tfor(int k=0;k<=r[j];++k)add(s,f[k]);\n\t\t\t\t\t\tfor(int k=r[j]+1;k<=m2;++k){\n\t\t\t\t\t\t\tf[k]=s;add(s,f[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<=m2;++k)add(g[i][k],f[k]);\n\t\t\t}\n\t\t\tfor(int j=0;j<=m2;++j){\n\t\t\t\tadd(g[i][j],g[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tint s=0;\n\t\tfor(int i=0;i<=m2;++i)(s+=g[m1][i])>=p?s-=p:0;\n\t\twrite(s,'\\n');\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tread(n,k,p);\n\tif(!(k&1)){\n\t\tk>>=1;\t\t\n\t\twrite(work1::dp(n>>1,k)*work1::dp(n-(n>>1),k)%p,'\\n');\n\t}\n\telse{\n\t\twork2::main();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint n,k;\nll MOD,f[2][155][155][155],g[155][155];\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&k,&MOD);\n\tif(k%2==0)\n\t{\n\t\tk/=2;\n\t\tg[0][0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=k;j++)\n\t\t\t{\n\t\t\t\tg[i-1][j]%=MOD;\n\t\t\t\tg[i][j+1]+=g[i-1][j];\n\t\t\t\tg[i][0]+=g[i-1][j];\n\t\t\t}\n\t\t}\n\t\tll ans1=0,ans2=0;\n\t\tfor(int i=0;i<=k;i++)ans1+=g[n/2][i];\n\t\tfor(int i=0;i<=k;i++)ans2+=g[(n+1)/2][i];\n\t\tans1%=MOD;\n\t\tans2%=MOD;\n\t\tprintf(\"%lld\\n\",ans1*ans2%MOD);\n\t\treturn 0;\n\t}\n\tf[0][0][0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=i&1;\n\t\tfor(int x=0;2*x-1<=i;x++)\n\t\t  for(int y=0;2*y<=i;y++)\n\t\t    for(int k=0;k<=n;k++)\n\t\t      f[flag][x][y][k]=0;\n\t\tfor(int x=0;2*x-1<i;x++)\n\t\tfor(int y=0;2*y<i;y++)\n\t\t{\n\t\t\tf[!flag][x][y][0]%=MOD;\n\t\t\tf[!flag][x][y][i]%=MOD;\n\t\t\tfor(int k=i+1;k<=n;k++)\n\t\t\t{\n\t\t\t\tf[!flag][x][y][k]%=MOD;\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\tf[flag][x+1][y][k]+=f[!flag][x][y][k];\n\t\t\t\t\tf[flag][0][y][k&1?0:k]+=f[!flag][x][y][k];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tf[flag][x][y+1][k]+=f[!flag][x][y][k];\n\t\t\t\t\tf[flag][x][0][k&1?k:0]+=f[!flag][x][y][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)f[flag][0][y][0]+=f[!flag][x][y][i]+f[!flag][x][y][0];\n\t\t\telse f[flag][x][0][0]+=f[!flag][x][y][i]+f[!flag][x][y][0];\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tif(y>=k/2+1&&i-2*x+k<=n)f[flag][x+1][y][i-2*x+k]+=f[!flag][x][y][0];\n\t\t\t\telse if(x>=k/2+1&&y&&i-1-2*y+2+k<=n)f[flag][x+1][y][i-1-2*y+2+k]+=f[!flag][x][y][0];\n\t\t\t\telse f[flag][x+1][y][0]+=f[!flag][x][y][0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(x>=k/2+1&&i-2*y+k<=n)f[flag][x][y+1][i-2*y+k]+=f[!flag][x][y][0];\n\t\t\t\telse if(y>=k/2+1&&x&&i-1-2*x+2+k<=n)f[flag][x][y+1][i-1-2*x+2+k]+=f[!flag][x][y][0];\n\t\t\t\telse f[flag][x][y+1][0]+=f[!flag][x][y][0];\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d:\\n\",i);\n//\t\tfor(int x=0;2*x-1<=i;x++)\n//\t\t{\n//\t\t\tfor(int y=0;2*y<=i;y++)\n//\t\t\t{\n//\t\t\t\tprintf(\"(\");\n//\t\t\t\tfor(int k=0;k<n;k++)\n//\t\t\t\t  printf(\"%lld \",f[flag][x][y][k]);\n//\t\t\t\tprintf(\"%lld) \",f[flag][x][y][n]);\n//\t\t\t}\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n\t}\n\tbool flag=n&1;\n\tll ans=0;\n\tfor(int x=0;2*x-1<=n;x++)\n\t  for(int y=0;2*y<=n;y++)\n\t    for(int k=0;k<=n;k++)\n\t      ans+=f[flag][x][y][k];\n\tprintf(\"%lld\\n\",ans%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint MOD;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nconst int N = 77;\nint dp[2][N][N][N];\nint n, k;\n\nll solveEven(int m) {\n\tint a[N + 5];\n\tfor (int i = 0; i <= m + 1; i++)\n\t\ta[i] = 0;\n\ta[0] = 1;\n\tfor (int i = 1; i <= m + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (i - j > k + 1) continue;\n\t\t\ta[i] = add(a[i], a[j]);\n\t\t}\n\t}\n//\tcerr << m << \" \" << a[m + 1] << endl;\n\treturn a[m + 1];\n}\nvoid solveEven() {\n\tk /= 2;\n\tprintf(\"%lld\\n\", ((ll)solveEven(n / 2) * solveEven(n - n / 2)) % MOD);\n}\n\nbool goodPos(int x, int y, int z) {\n\tif (max(x, y) >= z) return false;\n\tif (2 * y - 1 - k >= 2 && 2 * x - k >= 1) return false;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &n, &k, &MOD);\n\tif (k % 2 == 0) {\n\t\tsolveEven();\n\t\treturn 0;\n\t}\n\tdp[0][0][0][N - 1] = 1;\n\tfor (int pos = 0; pos < n; pos++) {\n\t\tfor (int x = 0; x < N; x++)\n\t\t\tfor (int y = 0; y < N; y++)\n\t\t\t\tfor (int z = 0; z < N; z++)\n\t\t\t\t\tdp[1][x][y][z] = 0;\n\t\tfor (int x = 0; x < N; x++)\n\t\t\tfor (int y = 0; y < N; y++)\n\t\t\t\tfor (int z = 0; z < N; z++) {\n\t\t\t\t\tif (!goodPos(x, y, z)) continue;\n\t\t\t\t\tif (dp[0][x][y][z] == 0) continue;\n\t\t\t\t\tdp[1][x + 1][y][z] = add(dp[1][x + 1][y][z], dp[0][x][y][z]);\n\t\t\t\t\tint zz = N - 1;\n\t\t\t\t\tif (2 * y - 1 - k >= 2 && x > 0)\n\t\t\t\t\t\tzz = min(zz, 1 + (2 * y - 1 - 2 * x + k) / 2);\n\t\t\t\t\tif (zz <= y) throw;\n\t\t\t\t\tif (x < y) zz = min(zz, z);\n\t\t\t\t\tdp[1][0][y][zz] = add(dp[1][0][y][zz], dp[0][x][y][z]);\n\t\t\t\t}\n\t\tfor (int x = 0; x < N; x++)\n\t\t\tfor (int y = 0; y < N; y++)\n\t\t\t\tfor (int z = 0; z < N; z++)\n\t\t\t\t\tdp[0][y][x][z] = dp[1][x][y][z];\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x < N; x++)\n\t\tfor (int y = 0; y < N; y++)\n\t\t\tfor (int z = 0; z < N; z++)\n\t\t\t\tif (goodPos(x, y, z))\n\t\t\t\t\tans = add(ans, dp[0][x][y][z]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll mo;\nll from[155][155][155];\nll to[155][155][155];\n\nll hoge(int N) {\n\tll from[151]={};\n\tll to[151];\n\t\n\tfrom[0]=1;\n\tint i,j;\n\tFOR(i,N) {\n\t\tZERO(to);\n\t\tFOR(j,K+1) {\n\t\t\t(to[0]+=from[j])%=mo;\n\t\t\tif(j+1<=K) (to[j+1]+=from[j])%=mo;\n\t\t}\n\t\t\n\t\tswap(from,to);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,N+1) ret+=from[i];\n\treturn ret%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>mo;\n\t\n\tif(K%2==0) {\n\t\tK/=2;\n\t\tcout<<hoge(N/2)*hoge((N+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tfrom[0][1][154]=1;\n\t\tfor(i=2;i<=N+1;i++) {\n\t\t\tZERO(to);\n\t\t\t\n\t\t\tint a,b;\n\t\t\tfor(a=0;a<i;a+=2) for(b=1;b<i;b+=2) for(j=max(a,b);j<=154;j++) if(from[a][b][j]) {\n\t\t\t\tll v=from[a][b][j];\n\t\t\t\t//cout<<i<<\" \"<<a<<\" \"<<b<<\" \"<<j<<\" \"<<v<<endl;\n\t\t\t\tint nex;\n\t\t\t\tif(i%2==0) {\n\t\t\t\t\t// keep\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(b+2+K>=i) nex=154;\n\t\t\t\t\t(to[i][b][nex]+=v)%=mo;\n\t\t\t\t\t\n\t\t\t\t\t// remove\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tif(b+2<=i-K&&a+2+K<i) continue;\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(b==i-1) nex=j;\n\t\t\t\t\telse if(a==i-2) nex=min({154,j,i+K});\n\t\t\t\t\t(to[a][b][nex]+=v)%=mo;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// keep\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(a+2+K>=i) nex=154;\n\t\t\t\t\t(to[a][i][nex]+=v)%=mo;\n\t\t\t\t\t\n\t\t\t\t\t// remove\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tif(a+2<=i-K&&b+2+K<i) continue;\n\t\t\t\t\tnex=j;\n\t\t\t\t\tif(a==i-1) nex=j;\n\t\t\t\t\telse if(b==i-2) nex=min({154,j,i+K});\n\t\t\t\t\t(to[a][b][nex]+=v)%=mo;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tswap(from,to);\n\t\t}\n\t\t\n\t\tll ret=0;\n\t\tFOR(x,155) FOR(y,155) FOR(j,155) ret+=from[x][y][j];\n\t\tcout<<ret%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=200;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint k,n;\nLL dp[NN][NN][NN]={};\nint mod;\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\nvoid upd(LL &x,LL y){\n\tx=(x+y)%mod;\n}\nvoid solve1(){\n\tdp[0][0][0]=1;\n\tint lim=k/2;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int a=0;a<=lim;++a){\n\t\t\tfor(int b=0;b<=lim;++b){\n\t\t\t\tif(i&1){\n\t\t\t\t\tupd(dp[i][a][0],dp[i-1][a][b]);\n\t\t\t\t\tupd(dp[i][a][b+1],dp[i-1][a][b]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tupd(dp[i][0][b],dp[i-1][a][b]);\n\t\t\t\t\tupd(dp[i][a+1][b],dp[i-1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int a=0;a<=lim;++a){\n\t\tfor(int b=0;b<=lim;++b){\n\t\t\tupd(ans,dp[n][a][b]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nvoid empty(int now){\n\tfor(int j=0;j<=k+2;++j){\n\t\tfor(int l=0;l<=k+2;++l){\n\t\t\tdp[now][j][l]=0;\n\t\t}\n\t}\n}\nvoid cut(int now){\n\tfor(int j=0;j<=k+2;++j){\n\t\tfor(int l=k-j+2;l<=k+2;++l){\n\t\t\tdp[now][j][l]=0;\n\t\t}\n\t}\n}\nvoid pushodd(int now){\n\tfor(int j=0;j<=k+1;++j){\n\t\tfor(int l=0;l<=k+1;++l){\n\t\t\tupd(dp[now][j][0],dp[now^1][j][l]);\n\t\t\tupd(dp[now][j][l+1],dp[now^1][j][l]);\n\t\t}\n\t}\n\tupd(dp[now][0][k+1],dp[now^1][0][k+1]);\n}\nvoid pusheven(int now){\n\tfor(int j=1;j<=k+2;++j){\n\t\tfor(int l=0;l<=k+2;++l){\n\t\t\tupd(dp[now][j-1][l],dp[now^1][j][l]);\n\t\t}\n\t}\n\tupd(dp[now][k+1][0],dp[now^1][k+1][0]);\n\tfor(int j=0;j<=k+1;++j){\n\t\tfor(int l=0;l<=k+1;++l){\n\t\t\tupd(dp[now][j][l],dp[now^1][0][l]);\n\t\t}\n\t}\n}\nvoid solve2(){\n\tint t=(k+1)/2;\n\tint now=0;\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=k;i+=2){//2 4 6 | 1 3 5\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpushodd(now);\n\t\tcut(now);\n\t}\n\tfor(int i=k+2;i<=n;i+=2){\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpushodd(now);\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpusheven(now);\n\t\tcut(now);\n\t}\n\tint cur=(n+1)/2*2-1-k;\n\tint cnt=(n-cur)/2;\n\tLL ans=0;\n\tfor(int j=0;j<=cnt;++j){\n\t\tfor(int l=0;l<=k+1-j;++l){\n\t\t\tint rem=cnt-j;\n\t\t\tupd(ans,dp[now][j][l]*ksm(2,rem));\n\t\t}\n\t}\n\tfor(int l=0;l<=k+1-cnt-1;++l){\n\t\tupd(ans,dp[now][cnt+1][l]);\n\t}\n\t/*for(int i=cur+2;i<=n;i+=2){\n\t\tnow^=1;\n\t\tempty(now);\n\t\tpusheven(now);\n\t\tcut(now);\n\t}\n\tfor(int i=0;i<=k+1;++i){\n\t\tupd(ans,dp[now][0][i]);\n\t\tif(i<=k)upd(ans,dp[now][1][i]);\n\t}*/\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//open();\n\tn=read();\n\tk=read();\n\tmod=read();\n\tif(k%2==0){\n\t\tsolve1();\n\t}\n\telse solve2();\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, K, mod;\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\nint f[202][202];\nvoid solve1() {\n    K /= 2, f[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= K; ++j) Add(f[i][0], f[i - 1][j]);\n        for (int j = 0; j < K; ++j) Add(f[i][j + 1], f[i - 1][j]);\n    }\n    int res1 = 0, res2 = 0;\n    for (int i = 0; i <= K; ++i) Add(res1, f[n / 2][i]);\n    for (int i = 0; i <= K; ++i) Add(res2, f[(n + 1) / 2][i]);\n    printf(\"%d\\n\", 1ll * res1 * res2 % mod);\n}\nint g[502][202][202];\nvoid solve2() {\n    int t;\n    g[0][0][0] = 1;\n    for (int i = 2; i - K <= n; i += 2) {\n        for (int j = 0; j <= n; ++j)\n            for (int k = 0; k < K + 2; ++k) Add(g[i][0][0], g[i - 2][j][k]);\n        if (i <= n)\n            for (int j = 0; j <= n; ++j)\n                for (int k = 0; k < K + 2; ++k)\n                    Add(g[i][j + 1][0], g[i - 2][j][k]);\n\n        if (i - K >= 1)\n            for (int j = 0; j <= n; ++j) {\n                for (int k = 1; k <= K; ++k)\n                    Add(g[i][0][k + 1], g[i - 2][j][k]);\n                Add(g[i][0][0], g[i - 2][j][0]);\n            }\n\n        if (i <= n && i - K >= 1)\n            for (int j = 0; j <= n; ++j)\n                for (int k = 0; max(k, j + 1) <= K; ++k)\n                    Add(g[i][j + 1][max(k + 1, j + 2)], g[i - 2][j][k]);\n\n        t = i;\n    }\n    int res = 0;\n    for (int j = 0; j <= n; ++j)\n        for (int k = 0; k < K + 2; ++k) Add(res, g[t][j][k]);\n    printf(\"%d\\n\", res);\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &K, &mod);\n    (K & 1) ? solve2() : solve1();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\n// ここから編集しろ\nlong long M;\nlong long dp[160][80][80][80];\nlong long DP[160][160][160];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d%lld\",&a,&b,&M);\n\tif(b%2==0){\n\t\tDP[0][0][1]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<=i+1;j++){\n\t\t\t\tfor(int k=0;k<=i+1;k++){\n\t\t\t\t\tif(!DP[i][j][k])continue;\n\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\tDP[i+1][i+2][k]=(DP[i+1][i+2][k]+DP[i][j][k])%M;\n\t\t\t\t\t\tif(i-j<b)DP[i+1][j][k]=(DP[i+1][j][k]+DP[i][j][k])%M;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tDP[i+1][j][i+2]=(DP[i+1][j][i+2]+DP[i][j][k])%M;\n\t\t\t\t\t\tif(i-k<b)DP[i+1][j][k]=(DP[i+1][j][k]+DP[i][j][k])%M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<=a+1;i++){\n\t\t\tfor(int j=0;j<=a+1;j++){\n\t\t\t\tret+=DP[a][i][j];\n\t\t\t}\n\t\t}\n\t\tret%=M;\n\t\tprintf(\"%lld\\n\",ret);\n\t\treturn 0;\n\t}else{\n\t\tdp[0][0][0][79]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<80;j++){\n\t\t\t\tfor(int k=0;k<80;k++){\n\t\t\t\t\tfor(int l=0;l<80;l++){\n\t\t\t\t\t\tif(!dp[i][j][k][l])continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint x=j*2-2;\n\t\t\t\t\t\tint y=k*2-1;\n\t\t\t\t\t//\tprintf(\"%d %d %d %d: %lld\\n\",i,x,y,l,dp[i][j][k][l]);\n\t\t\t\t\t\tif(x<y){\n\t\t\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\t\t\tif(i<l*2)dp[i+1][j][k][l]=(dp[i+1][j][k][l]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t\tdp[i+1][(i+2)/2][k][79]=(dp[i+1][(i+2)/2][k][79]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(x+2+b<=i)dp[i+1][j][k][min(l,(y+2+b)/2)]=(dp[i+1][j][k][min(l,(y+b+2)/2)]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t\telse dp[i+1][j][k][l]=(dp[i+1][j][k][l]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t\tdp[i+1][j][(i+1)/2][l]=(dp[i+1][j][(i+1)/2][l]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(i%2==1){\n\t\t\t\t\t\t\t\tif(i<l*2-1)dp[i+1][j][k][l]=(dp[i+1][j][k][l]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t\tdp[i+1][j][(i+1)/2][79]=(dp[i+1][j][(i+1)/2][79]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(y+2+b<=i)dp[i+1][j][k][min(l,(x+b+3)/2)]=(dp[i+1][j][k][min(l,(x+b+3)/2)]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t\telse dp[i+1][j][k][l]=(dp[i+1][j][k][l]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t\tdp[i+1][(i+2)/2][k][l]=(dp[i+1][(i+2)/2][k][l]+dp[i][j][k][l])%M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<80;i++){\n\t\t\tfor(int j=0;j<80;j++){\n\t\t\t\tfor(int k=0;k<80;k++){\n\t\t\t\t\tret+=dp[a][i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret%=M;\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\n#define ll long long\n//#define file\nusing namespace std;\n\nint p[18],d[233],n,K,i,j,k,l,mod,ans;\nbool f[131072];\n\nvoid dg(int t)\n{\n\tint i,j,k,l,s;\n\tif (t>n)\n\t{\n\t\tif (!(K&1))\n\t\t{\n\t\t\tfo(i,1,n-K+1)\n\t\t\tif (d[i])\n\t\t\t{\n\t\t\t\tfo(j,1,K/2)\n\t\t\t\tif (!d[i+j*2])\n\t\t\t\tbreak;\n\t\t\t\tif (j>K/2) return;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfo(i,1,n)\n\t\t\tif (d[i])\n\t\t\t{\n\t\t\t\tfo(j,1,K/2+1)\n\t\t\t\tif (i+j<=n && i-j>=1 && d[i+j] && d[i-j])\n\t\t\t\t{\n\t\t\t\t\tfo(k,1,K/2+1-j)\n\t\t\t\t\tif (!(i+j+k*2<=n && i-j-k*2>=1 && d[i+j+k*2] && d[i-j-k*2]))\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tif (k>K/2+1-j) return;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t++ans;\n\t\treturn;\n\t}\n\t\n\td[t]=0;dg(t+1);\n\td[t]=1;dg(t+1);\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc035E.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d%d\",&n,&K,&mod);\n\tp[1]=1;\n\tfo(i,2,n) p[i]=p[i-1]*2;\n\tdg(1);\n\tcout<<ans<<endl;\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 160;\nint n, k, mod, g[N][N], f[N][N][N];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &mod);\n  if (!(k & 1)) {\n    g[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= i && j <= k >> 1; j++) {\n        g[i + 1][j + 1] = (g[i + 1][j + 1] + g[i][j]) % mod;\n        g[i + 1][0] = (g[i + 1][0] + g[i][j]) % mod;\n      }\n    }\n    int ansx = 0, ansy = 0;\n    for (int j = 0; j <= n + 1 >> 1 && j <= k >> 1; j++) {\n      ansx = (ansx + g[n >> 1][j]) % mod;\n      ansy = (ansy + g[n >> 1 | 1][j]) % mod;\n    }\n    ansx = (ll) ansx * ansy % mod;\n    printf(\"%d\\n\", ansx);\n  } else {\n    f[0][0][0] = 1;\n    for (int i = 0; i <= n; i++) {\n      bool px = 2 * i + 1 <= n, py = 2 * i + 1 - k >= 2 && 2 * i + 1 - k <= n;\n      for (int c = 0; c <= i + 1 && c < k + 2; c++) {\n        for (int d = 0; d <= i; d++) {\n          if (true   ) f[i + 1][0][0] = (f[i + 1][0][0] + f[i][c][d]) % mod;\n          if (px     ) f[i + 1][0][d + 1] = (f[i + 1][0][d + 1] + f[i][c][d]) % mod;\n          if (py     ) f[i + 1][c ? c + 1 : 0][0] = (f[i + 1][c ? c + 1 : 0][0] + f[i][c][d]) % mod;\n          if (px & py) f[i + 1][max(c + 1, d + 2)][d + 1] = (f[i + 1][max(c + 1, d + 2)][d + 1] + f[i][c][d]) % mod;\n        }\n      }\n    }\n    printf(\"%d\\n\", f[n + 1][0][0]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\n\nint n, k;\nu32 P;\nu32 f[80], g[2][155][80];\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\nvoid once(int m) {\n\tu64 sum=0;\n\tfor(int j=0; j<=m; ++j) sum+=f[j];\n\tfor(int j=m; j>=1; --j) f[j]=f[j-1];\n\tf[0]=sum%P;\n}\nint main() {\n\tstd::cin>>n>>k>>P;\n\tif(k%2==0) {\n\t\tu64 ans0;\n\t\tf[0]=1;\n\t\tfor(int i=0; i<=(n+1)/2; ++i) {\n\t\t\tonce(k/2);\n\t\t\tif(i==n/2) ans0=f[0];\n\t\t}\n\t\tstd::cout<<ans0*f[0]%P<<\"\\n\";\n\t} else {\n\t\tint t;\n\t\tauto G=g[0], H=g[1];\n\t\tf[0]=1;\n\t\tfor(t=1; t<k; t+=2) once(k/2);\n\t\tmemcpy(G[0], f, (k/2+1)*sizeof(int));\n\t\tfor(t=1; t+k<=n; t+=2) {\n\t\t\tstd::swap(G, H);\n\t\t\tfor(int i=0; i<=k; ++i) memset(G[i], 0, (n/2+1)*sizeof(int));\n\t\t\tfor(int i=0; i<=k; ++i)\n\t\t\t\tfor(int j=0; j<=n/2; ++j)\n\t\t\t\t\tif(H[i][j]) {\n\t\t\t\t\t\tinc(G[i?i+1:j+1][j+1], H[i][j]);\n\t\t\t\t\t\tinc(G[0][j+1], H[i][j]);\n\t\t\t\t\t\tinc(G[i?i+1:0][0], H[i][j]);\n\t\t\t\t\t\tinc(G[0][0], H[i][j]);\n\t\t\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=k; ++i) {\n\t\t\tu64 sum=0;\n\t\t\tfor(int j=0; j<=n/2; ++j) sum+=G[i][j];\n\t\t\tf[i]=sum%P;\n\t\t}\n\t\tfor(; t<=n; t+=2) {\n\t\t\tonce(k);\n\t\t\tinc(f[0], f[1]);\n\t\t\tf[1]=0;\n\t\t}\n\t\tonce(k);\n\t\tprintf(\"%u\\n\", f[0]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//const uint mod=998244353;\n//const uint mod=1000000007;\nuint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nmint sub(int n,int k){\n\tn+=2;\n\tvc<mint> dp(n);\n\tdp[0]=1;\n\trng(i,1,n)\n\t\trng(j,max(i-k,int(0)),i)\n\t\t\tdp[i]+=dp[j];\n\treturn dp[n-1];\n}\n\nconst int Nmax=160;\nmint dp[Nmax][Nmax][Nmax];\n\nbool chk(int a,int b,int c,int d,int len){\n\tif(b-a<len)return true;\n\tint p=a+len,q=b-len;\n\tif(q<=p){\n\t\tif(c<=q&&p<=d)return false;\n\t}else{\n\t\tif(p<=d&&c<=q)return false;\n\t}\n\treturn true;\n}\n\nbool ok(int a,int b,int c,int d,int len){\n\tif(b<a||d<c)return true;\n\treturn chk(a,b,c,d,len)&&chk(c,d,a,b,len);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,len;cin>>n>>len;\n\tcin>>mod;\n\t\n\tif(len%2==0){\n\t\tcout<<sub(n/2,len/2+1)*sub(n-n/2,len/2+1)<<endl;\n\t}else{\n\t\tn+=6;\n\t\tdp[2][1][0]=1;\n\t\trng(i,1,n)for(int j=(i+1)%2;j<i;j+=2)for(int k=i%2;k<j;k+=2)if(dp[i][j][k].v){\n\t\t\tfor(int l=(j+2);l<n;l+=2){\n\t\t\t\tif(ok(k+2,i-2,j+2,l-2,len)){\n\t\t\t\t\tif(l<i)\n\t\t\t\t\t\tdp[i][l][k]+=dp[i][j][k];\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[l][i][j]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n-1][n-2][n-3]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat M;\n\nint encode(int s0, int s1, int mx0, int mx1) {\n\treturn (s0 << 24) + (s1 << 16) + (mx0 << 8) + mx1;\n}\n\nmap<int, cat> states[200];\n\ncat solve_2(int N, int K, int pos, int s0, int s1, int mx0, int mx1) {\n\tif(pos == N) return (mx0 == N && mx1 == N);\n\tif(mx0 < pos || mx1 < pos) return 0;\n\ts0 = min(s0, K/2+1);\n\ts1 = min(s1, K/2+1);\n\n\tauto it = states[pos].find(encode(s0, s1, mx0, mx1));\n\tif(it != states[pos].end()) return it->ss;\n\n\t// remove\n\tint mx0_nw = N, mx1_nw = N;\n\tif(pos%2 == 0 && 2*s1-1 >= K) mx1_nw = pos + K - 2 * min(K/2, s0);\n\tif(pos%2 == 1 && 2*s0-1 >= K) mx0_nw = pos + K - 2 * min(K/2, s1);\n\tint s0_nw = s0 + (pos%2 == 0), s1_nw = s1 + (pos%2 == 1);\n\tcat ret1 = solve_2(N, K, pos+1, s0_nw, s1_nw, min(mx0, mx0_nw), min(mx1, mx1_nw));\n\n\t// don't remove\n\ts0_nw = (pos%2 == 0) ? 0 : s0, s1_nw = (pos%2 == 1) ? 0 : s1;\n\tcat ret2 = solve_2(N, K, pos+1, s0_nw, s1_nw, (pos%2==0)?N:mx0, (pos%2==1)?N:mx1);\n\n\tstates[pos][encode(s0, s1, mx0, mx1)] = (ret1 + ret2) % M;\n\treturn (ret1 + ret2) % M;\n}\n\ncat solve_1(int N, int K) {\n\tvector< vector<cat> > dp(N+1, vector<cat>(K+1, 0));\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j <= K; j++) dp[i+1][0] += dp[i][j];\n\t\tfor(int j = 0; j < K; j++) dp[i+1][j+1] += dp[i][j];\n\t\tfor(int j = 0; j <= K; j++) dp[i+1][j] %= M;\n\t}\n\tcat ret = 0;\n\tfor(int i = 0; i <= K; i++) ret += dp[N][i];\n\tret %= M;\n\treturn ret;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, K;\n\tcin >> N >> K >> M;\n\tif(K%2 == 0 || K == 1) {\n\t\tif(K == 1) cout << solve_1(N, 2) << \"\\n\";\n\t\telse cout << solve_1(N/2, K/2) * solve_1(N-N/2, K/2) % M << \"\\n\";\n\t}\n\telse cout << solve_2(N, K, 0, 0, 0, N, N) << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair <int, int>\n#define iiii pair <int, pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n  int x = 0, p = 1; char c = getchar();\t\n  while (c <= 32) c = getchar();\n  if (c == 45) p = -p, c = getchar();\n  while (c > 32) x = x * 10 + c - 48, c = getchar();\n  return x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 158;\nint n, k, mod;\nint g[N][N], f[N][N][N];\n//\ninline void reduce(int &x) {\n  x += x >> 31 & mod;\n}\ninline void add(int &x, int y) {\n  x += y - mod;\n  reduce(x);\n}\ninline int mul(int x, int y) {\n  return 1ll * x * y % mod;\n}\nvoid solve0() {\n  g[0][0] = g[1][0] = 1;\n  k /= 2;\n  for (int i = 1; i <= n; i++) {\n    add(g[i + 1][0], g[i][0]);\n    for (int j = 1; j <= min(i, k); j++) {\n      add(g[i][j], g[i - 1][j - 1]);\n      add(g[i + 1][0], g[i][j]);\n    }\n  }\n  int sum = 0, res = 0;\n  rep(i, k + 1) add(sum, g[n / 2][i]);\n  if (n & 1) ++n;\n  rep(i, k + 1) add(res, g[n / 2][i]);\n  cout << mul(res, sum) << endl;\n}\nvoid solve1() {\n  int c0 = 0, c1 = 0, c;\n  for (int i = 2; i <= n; i += 2) {\n    if (i - k <= 0) ++c0;\n  }\n  for (int i = 1; i <= n; i += 2) {\n    if (i + k > n) ++c1;\n  }\n  c = (n - c0 - c1) / 2;\n  //cout <<c0 << \" \" << c << \" \" << c1 << endl;\n  f[0][0][0] = 1;\n  for (int i = 1; i <= c0; i++) {\n    rep(j, i) add(f[i][0][0], f[i - 1][0][j]);\n    for (int j = 1; j <= i; j++) {\n      add(f[i][0][j], f[i - 1][0][j - 1]);\n    }\n  }\n  for (int i = c0 + 1; i <= c0 + c + c1; i++) {\n    if (i <= c0 + c) rep(j, N) {\n      for (int x = 0; x <= k; x++) {\n        add(f[i][0][j], f[i - 1][x][j - 1]);\n      }\n    }\n    rep(x, N) add(f[i][0][0], f[i - 1][0][x]);\n    rep(j, k + 1) rep(k, N) {\n      add(f[i][0][0], f[i - 1][j][k]);\n    }\n    for (int j = 2; j <= k; j++) {\n      for (int x = 0; x < N; x++) {\n        add(f[i][j][0], f[i - 1][j - 1][x]);\n      }\n    }\n    if (i <= c0 + c) rep(j, k) for (int x = 0; x < N - 1; x++) {\n      add(f[i][max(j, x) + 1][x + 1], f[i - 1][j][x]);\n    }\n    rep(j, N) rep(x, N) if (f[i][j][x]) {\n      //cout << i << \" \" << j << \" \" << x << \" \" << f[i][j][x] << endl;\n    }\n  }\n  int res = 0;\n  rep(i, k + 1) rep(j, N) add(res, f[c + c0 + c1][i][j]);\n  cout << res << endl;\n}\nint main() {\n  n = getint(); k = getint(); mod = getint();\n  if (!(k & 1)) {\n    solve0();\n  }\n  else {\n    solve1();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nunsigned int mod = 1;\n\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt;\n\nint N,K;\nmint dp[2][50][50][50][50];\n\nint main(){\n\tcin >> N >> K >> mod;\n\tif(K%2 == 0){\n\t\tK = K/2 + 1;\t// o*K -> no\n\t\tVV<mint> dp(N+1,V<mint>(K));\n\t\tdp[0][0] = 1;\n\t\trep(i,N) rep(k,K){\n\t\t\tdp[i+1][0] += dp[i][k];\n\t\t\tif(k+1 != K) dp[i+1][k+1] += dp[i][k];\n\t\t}\n\t\tmint res = 1;\n\t\tfor(int n : {N/2,(N+1)/2}){\n\t\t\tmint s = 0;\n\t\t\trep(k,K) s += dp[n][k];\n\t\t\tres *= s;\n\t\t}\n\t\tcout << res << endl;\n\t\treturn 0;\n\t}\n\tK = (K+1)/2;\n\tdp[0][0][0][0][0] = 1;\n\trep(i,N){\n\t\tint t = i&1;\n\t\tint nt = 1-t;\n\t\trep(a,K+1) rep(b,K+1) rep(c,K+1){\n\t\t\tdp[nt][a][b][c][0] = 0;\n\t\t\tdp[nt][a][b][0][c] = 0;\n\t\t}\n\t\trep(a,K+1) rep(b,K+1) rep(v,K+1) rep(_,2){\n\t\t\tif(v == 0 && _ == 0) continue;\n\t\t\tint c = v, d = 0;\n\t\t\tif(_) swap(c,d);\n\t\t\tif(!dp[t][a][b][c][d]) continue;\n//\t\t\tprintf(\"[%d][%d][%d][%d]\\n\",a,b,c,d);\n\n\t\t\t//x\n\t\t\tdp[nt][b][0][d][0] += dp[t][a][b][c][d];\n\t\t\t//o\n\t\t\tif(c == 1) continue;\n\t\t\tif(a == K){\n\t\t\t\tif(b >= K) continue;\n\t\t\t\tint nd = c == 0 ? 0 : c-1;\n\t\t\t\tif(b > 0){\n\t\t\t\t\tif(c == 0) nd = K-b;\n\t\t\t\t\telse nd = min(c-1,K-b);\n\t\t\t\t}\n\t\t\t\tdp[nt][b][K][d][nd] += dp[t][a][b][c][d];\n\t\t\t}else{\n\t\t\t\tdp[nt][b][a+1][d][c == 0 ? 0 : c-1] += dp[t][a][b][c][d];\n\t\t\t}\n\t\t}\n\t}\n\tmint res = 0;\n\trep(a,K+1) rep(b,K+1) rep(c,K+1) rep(d,K+1) res += dp[N&1][a][b][c][d];\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=205;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,m,Mod;\nnamespace Task1{\n\tint F[MAXN];\n\tinline void Solve(){\n\t\tm>>=1,F[0]=1;\n\t\tRep(i,1,n)Rep(j,max(0,i-m-1),i-1)F[i]=(F[i]+F[j])%Mod;\n\t\tint ans1=0,ans2=0;\n\t\tRep(i,max(0,(n>>1)-m),(n>>1))ans1=(ans1+F[i])%Mod;\n\t\tRep(i,max(0,(n+1>>1)-m),(n+1>>1))ans2=(ans2+F[i])%Mod;\n\t\tcout<<1ll*ans1*ans2%Mod;\n\t}\n}\nnamespace Task2{\n\tint F[MAXN][MAXN][MAXN];\n\tinline void Solve(){\n\t\tF[0][0][0]=1;\n\t\tfor(int i=1;i+i-m<=n;i++){\n\t\t\tRep(j,0,m+1)Rep(k,0,n)F[i][0][0]=(F[i][0][0]+F[i-1][j][k])%Mod;\n\t\t\tif(i+i<=n)Rep(j,0,m+1)Rep(k,0,n)F[i][0][k+1]=(F[i][0][k+1]+F[i-1][j][k])%Mod;\n\t\t\tif(i+i-m>=1)Rep(j,0,m+1)Rep(k,0,n)F[i][j+(j>0)][0]=(F[i][j+(j>0)][0]+F[i-1][j][k])%Mod;\n\t\t\tif(i+i<=n&&i+i-m>=1)Rep(j,0,m+1)Rep(k,0,n){int jj=max(j+1,k+2);if(j<=m+1)F[i][jj][k+1]=(F[i][jj][k+1]+F[i-1][j][k])%Mod;}\n\t\t}int ans=0;Rep(j,0,m+1)Rep(k,0,n)ans=(ans+F[n+m>>1][j][k])%Mod;cout<<ans<<'\\n';\n\t}\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),m=read(),Mod=read();\n\tif(!(m&1))Task1::Solve();else Task2::Solve();\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 160;\n\ntypedef long long LL;\n\nint mod;\n\ninline void Inc(int &x, int y) {\n    x += y, x -= x >= mod ? mod : 0;\n}\n\ninline int solve1(int n, int k) {\n    static int f[N]; memset(f, 0, sizeof(f)), f[0] = 1;\n    for (int i = 1; i <= n + 1; i++)\n        for (int j = 0; j <= k && i - 1 - j >= 0; j++) \n            Inc(f[i], f[i - 1 - j]);\n    return f[n + 1];\n}\n\nint dp[N][N][N], type[N];\n\ninline int solve2(int n, int k) {\n    int tot = 0;\n    for (int i = 1; i * 2 - k <= n; i++) {\n        int a = i * 2, b = i * 2 - k; tot++;\n        if (a <= n) type[tot] |= 2;\n        if (b > 0) type[tot] |= 1; \n    }\n    dp[0][0][0] = 1;\n    for (int i = 1; i <= tot; i++) \n        for (int j = 0; j <= i * 2 && j <= k + 1; j++)\n            for (int k = 0; k <= i; k++) if (dp[i - 1][j][k]) {\n                Inc(dp[i][0][0], dp[i - 1][j][k]);\n                if (type[i] & 1) Inc(dp[i][j ? j + 1 : 0][0], dp[i - 1][j][k]);\n                if (type[i] & 2) Inc(dp[i][0][k + 1], dp[i - 1][j][k]);\n                if (type[i] == 3) Inc(dp[i][j ? j + 1 : k + 2][k + 1], dp[i - 1][j][k]);\n            }\n    int res = 0;\n    for (int j = 0; j <= k + 1; j++)\n        for (int k = 0; k <= tot; k++) Inc(res, dp[tot][j][k]);\n    return res;\n}\n\nint main() {\n    int n, k; scanf(\"%d%d%d\", &n, &k, &mod);\n    if (k % 2 == 0) printf(\"%d\\n\", ((LL)solve1(n / 2, k / 2) * solve1((n + 1) / 2, k / 2)) % mod);\n    else if (k == 1) printf(\"%d\\n\", solve1(n, 2));\n    else printf(\"%d\\n\", solve2(n, k));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int N = 550;\n\nint n, K, P;\n\ntemplate <typename T1, typename T2>\ninline void add(T1 &x, T2 y) {\n  x += y;\n  if (x >= P)\n    x -= P;\n}\n\nnamespace Sub1 {\n\n  ll f[N][N], ans1, ans2;\n\n  inline ll solve() {\n    K /= 2;\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j <= K; ++j)\n        add(f[i][j], f[i - 1][j]);\n      for (int j = 1; j <= K; ++j)\n        add(f[i][j], f[i - 1][j - 1]);\n    }\n    for (int i = 0; i <= K; ++i)\n      add(ans1, f[n / 2][i]);\n    for (int i = 1; i <= K; ++i)\n      add(ans2, f[(n + 1) / 2][i]);\n    return ans1 * ans2 % P;\n  }\n}\n\nnamespace Sub2 {\n\n  ll f[N][N][N], ans;\n\n  inline ll solve() {\n    if (K > n - 2) {\n      ll ret = 1;\n      for (int i = 1; i <= n; ++i)\n        ret = ret * 2 % P;\n      return ret;\n    }\n    f[0][0][0] = 1;\n    for (int i = 2; i <= n + K; i += 2) {\n      for (int j = 0; j <= n; ++j)\n        for (int k = 0; k <= K + 1; ++k)\n          add(f[i][0][0], f[i - 2][j][k]);\n      if (i <= n) {\n        for (int j = 0; j <= n; ++j)\n          for (int k = 0; k <= K + 1; ++k)\n            add(f[i][j + 1][0], f[i - 2][j][k]);\n      }\n      if (i >= K + 1) {\n        for (int j = 0; j <= n; ++j) {\n          for (int k = 1; k <= K; ++k)\n            add(f[i][0][k + 1], f[i - 2][j][k]);\n          add(f[i][0][0], f[i - 2][j][0]);\n        }\n      }\n      if (i <= n && i >= K + 1) {\n        for (int j = 0; j <= n; ++j)\n          for (int k = 0; std::max(j + 1, k) <= K; ++k)\n            add(f[i][j + 1][std::max(j + 2, k + 1)], f[i - 2][j][k]);\n      }\n    }\n    for (int j = 0, qwq = ((n + K) & 1 ? n + K - 1 : n + K); j <= n; ++j)\n      for (int k = 0; k <= K + 1; ++k)\n        add(ans, f[qwq][j][k]);\n    return ans;\n  }\n}\n\nint main() {\n  // freopen(\"data\", \"r\", stdin);\n  std::cin >> n >> K >> P;\n  if (!(K & 1)) std::cout << Sub1::solve() << std::endl;\n  else std::cout << Sub2::solve() << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 150;\nint N, K, M;\nint add(int a, int b) {return (a + b)%M;}\nint mul(int a, int b) {return 1LL*a*b%M;}\nint f[MAXN + 5][MAXN + 5];\nvoid solve1() {\n\tK /= 2, f[0][0] = 1;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=0;j<=K;j++)\n\t\t\tf[i][0] = add(f[i][0], f[i-1][j]);\n\t\tfor(int j=0;j<K;j++)\n\t\t\tf[i][j+1] = add(f[i][j+1], f[i-1][j]);\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tfor(int i=0;i<=K;i++)\n\t\tans1 = add(ans1, f[N/2][i]);\n\tfor(int i=0;i<=K;i++)\n\t\tans2 = add(ans2, f[(N+1)/2][i]);\n\tprintf(\"%d\\n\", mul(ans1, ans2));\n}\nint g[2*MAXN + 5][MAXN + 5][MAXN + 5];\nvoid solve2() {\n\tint p; g[0][0][0] = 1;\n\tfor(int i=2;i-K<=N;i+=2) {\n\t\tfor(int j=0;j<=N;j++)\n\t\t\tfor(int k=0;k<=K+1;k++)\n\t\t\t\tg[i][0][0] = add(g[i][0][0], g[i-2][j][k]);\n\t\tif( i <= N ) {\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;k<=K+1;k++)\n\t\t\t\t\tg[i][j+1][0] = add(g[i][j+1][0], g[i-2][j][k]);\n\t\t}\n\t\tif( i - K >= 1 ) {\n\t\t\tfor(int j=0;j<=N;j++) {\n\t\t\t\tfor(int k=1;k<=K;k++)\n\t\t\t\t\tg[i][0][k+1] = add(g[i][0][k+1], g[i-2][j][k]);\n\t\t\t\tg[i][0][0] = add(g[i][0][0], g[i-2][j][0]);\n\t\t\t}\n\t\t}\n\t\tif( i <= N && i - K >= 1 ) {\n\t\t\tfor(int j=0;j<=N;j++)\n\t\t\t\tfor(int k=0;max(k,j+1)<=K;k++)\n\t\t\t\t\tg[i][j+1][max(k+1,j+2)] = add(g[i][j+1][max(k+1,j+2)], g[i-2][j][k]);\n\t\t}\n\t\tp = i;\n\t}\n\tint ans = 0;\n\tfor(int j=0;j<=N;j++)\n\t\tfor(int k=0;k<=K+1;k++)\n\t\t\tans = add(ans, g[p][j][k]);\n\tprintf(\"%d\\n\", ans);\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &K, &M);\n\tif( K % 2 == 0 ) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\n\nint mod;\n\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint& v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0) val += mod;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& a) { return os << a.val; }\n\tfriend bool operator==(const mint& a, const mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint& operator+=(const mint& m) { if ((val += m.val) >= mod) val -= mod; return *this; }\n\tmint& operator-=(const mint& m) { if ((val -= m.val) < 0) val += mod; return *this; }\n\tmint& operator*=(const mint& m) { val = (lint)val*m.val%mod; return *this; }\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint& a) { assert(a.val); return ipow(a, mod - 2); }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n\toperator int64_t() const {return val; }\n};\n\nmint ez(int n, int k){\n\tvector<mint> dp(n + 2);\n\tdp[0] = mint(1);\n\tfor(int i=1; i<=n+1; i++){\n\t\tfor(int j=1; j<=k+1 && j<=i; j++){\n\t\t\tdp[i] += dp[i - j];\n\t\t}\n\t}\n\treturn dp[n + 1];\n}\n\nvector<int> v;\nmint dp[155][155][155][2], nxt[155][155][155][2];\n\nmint solve(int n, int thr){\n\tdp[0][0][0][0] = 1;\n\tfor(auto &x : v){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i=0; i<=n; i++){ // short\n\t\t\tfor(int j=0; j<=n; j++){ // long\n\t\t\t\tfor(int k=0; k<=thr; k++){ // long with tail\n\t\t\t\t\tfor(int l=0; l<2; l++){ // 1 if up is long\n\t\t\t\t\t\tif((lint)dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t\tnxt[0][0][0][0] += dp[i][j][k][l];\n\t\t\t\t\t\tint next_k = 0;\n\t\t\t\t\t\tif(k > 0) next_k = k + 1;\n\t\t\t\t\t\telse if(i > 0) next_k = i + 2;\n\t\t\t\t\t\tif(x & 1){\n\t\t\t\t\t\t\tif(l == 0){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x & 2){\n\t\t\t\t\t\t\tif(l == 1){\n\t\t\t\t\t\t\t\tif(i > 0) nxt[0][i + 1][j + 2][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\telse nxt[0][1][0][l ^ 1] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnxt[0][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x == 3){\n\t\t\t\t\t\t\tnxt[i + 1][j + 1][next_k][l] += dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int k=0; k<thr; k++){\n\t\t\t\t\tif(j >= thr - 1 && i > 0){\n\t\t\t\t\t\tnxt[i][j][k][0] = nxt[i][j][k][1] = mint(0);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k][0] = nxt[i][j][k][0];\n\t\t\t\t\tdp[i][j][k][1] = nxt[i][j][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret = 0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=thr; k++){\n\t\t\t\tfor(int l=0; l<2; l++) ret += dp[i][j][k][l];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k >> mod;\n\tif(k % 2 == 0){\n\t\tcout << ez((n + 1) / 2, k / 2) * ez(n / 2, k / 2) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n+n; i+=2){\n\t\tif(i - k > n) break;\n\t\tint msk = 0;\n\t\tif(i <= n) msk |= 1;\n\t\tif(i - k >= 1) msk |= 2;\n\t\tv.push_back(msk);\n\t}\n\tmint ret = solve(n, k + 2);\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=155;\nint n,k,M,f[N][N],g[N];\nmap<ll,int> Map;\nll calc(int a,int b,int c,int d,int e){\n\treturn (ll)a*(n+2)*(n+2)*(n+2)*(n+2)+(ll)b*(n+2)*(n+2)*(n+2)+(ll)c*(n+2)*(n+2)+d*(n+2)+e;\n}\nint dfs(int x,int p,int q,int fp,int fq){\n\tif (x>=n)return 1;\n\tll VV=calc(x,p,q,fp,fq);\n\tif (Map.count(VV))return Map[VV];\n\tif (x&1){\n\t\tMap[VV]=dfs(x+1,0,q,n+1,fq);\n\t\tif (fp>x+1){\n\t\t\tif (x+2-2*q+k<=x+1)(Map[VV]+=dfs(x+1,p+1,q,fp,min(fq,x+1-2*p+k)))%=M;\n\t\t\telse (Map[VV]+=dfs(x+1,p+1,q,fp,fq))%=M;\n\t\t}\n\t}\n\telse {\n\t\tMap[VV]=dfs(x+1,p,0,fp,n+1);\n\t\tif (fq>x+1){\n\t\t\tif (x+2-2*p+k<=x+1)(Map[VV]+=dfs(x+1,p,q+1,min(fp,x+1-2*q+k),fq))%=M;\n\t\t\telse (Map[VV]+=dfs(x+1,p,q+1,fp,fq))%=M;\n\t\t}\n\t}\n\treturn Map[VV];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&M);\n\tif (k%2==0){\n\t\tk/=2;\n\t\tf[0][0]=1;\n\t\tg[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tfor (int j=0;j<=k;j++)\n\t\t\t\tf[i][j]=j==0?g[i-1]:f[i-1][j-1];\n\t\t\tfor (int j=0;j<=k;j++)(g[i]+=f[i][j])%=M;\n\t\t}\n\t\tprintf(\"%d\\n\",(ll)g[n/2]*g[n/2+n%2]%M);\n\t}\n\tprintf(\"%d\\n\",dfs(0,0,0,n+1,n+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=155;\nint n,K,mo,f[N][N][N],i,j,k,ans,x,y;\ninline void add(int&x,const int&y){x+=y-mo;x+=x>>31&mo;}\ninline int calc(int n,int K){\n\tstatic int g[N][N];memset(g,0,sizeof g);g[0][0]=1;\n\tfor(i=1;i<=n;++i)for(j=0;j<=K;++j){\n\t\tg[i][0]=(g[i][0]+g[i-1][j])%mo;\n\t\tif(j<K)g[i][j+1]=g[i-1][j];\n\t}\n\tint ans=0;for(j=0;j<=K;++j)ans=(ans+g[n][j])%mo;return ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&K,&mo);\n\tif(n==K){ans=1;for(i=1;i<=n;++i)ans=2ll*ans*i%mo;printf(\"%d\\n\",ans);return 0;}\n\tif(!(K&1)){K>>=1;printf(\"%lld\\n\",1ll*calc(n>>1,K)*calc(n+1>>1,K)%mo);return 0;}\n\tif(K==1){printf(\"%d\\n\",calc(n,2));return 0;}\n\tint lb1,rb1,lb2,rb2;\n\tlb1=(K>>1)+1;rb1=lb1+(n+1>>1)-1;\n\tlb2=1;rb2=lb2+(n>>1)-1;\n\tfor(i=rb1+1,f[i][0][0]=1;i>1;--i)for(j=0;j<=n;++j)for(k=0;k<=n;++k)if(x=f[i][j][k]){\n\t\tbool b1=lb1<=i-1 && i-1<=rb1,b2=lb2<=i-1 && i-1<=rb2;\n\t\tadd(f[i-1][0][0],x);\n\t\tif(b1)add(f[i-1][j+1][0],x);\n\t\tif(k+1<=K+1 && b2)add(f[i-1][0][k?k+1:0],x);\n\t\ty=std::max(j+2,k+1);\n\t\tif(y<=K+1 && b1 && b2)add(f[i-1][j+1][y],x);\n\t}\n\tfor(j=0;j<=n;++j)for(k=0;k<=n;++k)add(ans,f[1][j][k]);printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=160;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define fi first\n#define se second\n\nint n,m,mod;\nmap<pii,int> f[N][N][N];\n\nvoid inc(int &a,int b) {\n\ta=a+b>=mod?a+b-mod:a+b;\n}\n\nint main() {\n\tcin>>n>>m>>mod;\n\tif(m&1) {\n\t\tf[0][0][0][mp(n+1,n+1)]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t\tfor(auto x:f[i-1][j][k]) {\n\t\t\t\t\t\tif(i&1) {\n\t\t\t\t\t\t\tinc(f[i][0][k][mp(n+1,x.fi.se)],x.se);\n\t\t\t\t\t\t\tif(i!=x.fi.fi) {\n\t\t\t\t\t\t\t\tif(i-m>=i-2*k+1) inc(f[i][j+1][k][mp(x.fi.fi,min(x.fi.se,max(i+1,i-2*j+m)))],x.se);\n\t\t\t\t\t\t\t\telse inc(f[i][j+1][k][x.fi],x.se);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinc(f[i][j][0][mp(x.fi.fi,n+1)],x.se);\n\t\t\t\t\t\t\tif(i!=x.fi.se) {\n\t\t\t\t\t\t\t\tif(i-m>=i-2*j+1) inc(f[i][j][k+1][mp(min(x.fi.fi,max(i+1,i-2*k+m)),x.fi.se)],x.se);\n\t\t\t\t\t\t\t\telse inc(f[i][j][k+1][x.fi],x.se);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tfor(auto x:f[n][i][j]) inc(ans,x.se);\n\t\tcout<<ans;\n\t}\n\telse {\n\t\tm>>=1;\n\t\tstatic int f[N][N];f[0][0]=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=m;j++) {\n\t\t\t\tinc(f[i+1][0],f[i][j]);\n\t\t\t\tif(j<m) inc(f[i+1][j+1],f[i][j]);\n\t\t\t}\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<=m;i++)\n\t\t\tinc(x,f[n>>1][i]),inc(y,f[(n+1)>>1][i]);\n\t\tcout<<1ll*x*y%mod;\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair <int, int>\n#define iiii pair <int, pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n  int x = 0, p = 1; char c = getchar();\t\n  while (c <= 32) c = getchar();\n  if (c == 45) p = -p, c = getchar();\n  while (c > 32) x = x * 10 + c - 48, c = getchar();\n  return x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 80;\nint n, k, mod;\nint g[N][N];\n//\ninline void reduce(int &x) {\n  x += x >> 31 & mod;\n}\ninline void add(int &x, int y) {\n  x += y - mod;\n  reduce(x);\n}\ninline int mul(int x, int y) {\n  return 1ll * x * y % mod;\n}\nvoid solve0() {\n  g[0][0] = g[1][0] = 1;\n  k /= 2;\n  for (int i = 1; i <= n; i++) {\n    add(g[i + 1][0], g[i][0]);\n    for (int j = 1; j <= min(i, k); j++) {\n      add(g[i][j], g[i - 1][j - 1]);\n      add(g[i + 1][0], g[i][j]);\n    }\n  }\n  int sum = 0, res = 0;\n  rep(i, k + 1) add(sum, g[n / 2][i]);\n  if (n & 1) ++n;\n  rep(i, k + 1) add(res, g[n / 2][i]);\n  cout << mul(res, sum) << endl;\n}\nvoid solve1() {\n  assert(false);\n}\nint main() {\n  n = getint(); k = getint(); mod = getint();\n  if (!(k & 1)) {\n    solve0();\n  }\n  else {\n    solve1();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<stdint.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define VIS(it,con) for(auto it=con.begin();it!=con.end();++it)\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define MIN(x,y) (x=min(x,(y)))\n#define MAX(x,y) (x=max(x,(y)))\n#define mid (l+r>>1)\n#define lch (idx*2+1)\n#define rch (idx*2+2)\n/*****************************************************************************/\n#include<bits/stdc++.h>\n#define int int_fast64_t\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\n#define REP(i,j,k) for(int i=(j);i<(k);++i)\n#define RREP(i,j,k) for(int i=(j)-1;i>=(k);--i)\n#define ALL(a) a.begin(),a.end()\n#define MST(a,v) memset(a,(v),sizeof a)\n#define pb push_back\n#define F first\n#define S second\n#define endl '\\n'\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#define __debug\n#ifdef __debug\n\t#define IOS (void)0\n\t#define de(...) cerr<<__VA_ARGS__\n\t#define ar(a,s,t) {REP(__i,s,t)de(a[__i]<<' ');de(endl);}\n#else\n\t#define IOS cin.tie(0),cout.tie(0),ios_base::sync_with_stdio(false)\n\t#define de(...) (void)0\n\t#define ar(...) (void)0\n#endif\n/***********************************default***********************************/\nconst int maxn=159;\nint n,kk,m,dp[2][maxn][maxn][maxn],par[2][maxn/2];\n\nmain(){\n\tIOS;\n\tcin>>n>>kk>>m;\n\tconst int mo=m;\n\tif(kk&1){\n\t\tfill(dp[0][0][0],dp[0][0][0]+n,0);\n\t\tdp[0][0][0][n]=1;\n\t\tREP(i,0,n){\n\t\t\tint t=i&1;\n//\t\t\tREP(j,0,i+1-(i+1)/2+1)REP(k,0,(i+1)/2+1)REP(l,i+1,n+1)dp[!t][j][k][l]=0;\n\t\t\tMST(dp[!t],0);\n\t\t\tREP(j,0,i-i/2+1){\n\t\t\t\tREP(k,0,i/2+1){\n\t\t\t\t\tREP(l,i,n+1){\n\t\t\t\t\t\tif(l!=n&&l%2!=i%2)(dp[!t][0][j][l]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\telse(dp[!t][0][j][n]+=dp[t][j][k][l])%=mo;\n//\t\t\t\t\t\tif(i+1==6&&j==3&&n==7&&dp[t][j][k][l])cout<<j<<k<<l<<dp[t][j][k][l]<<endl;\n\t\t\t\t\t\tif(i!=l){\n\t\t\t\t\t\t\tint mn=l;\n\t\t\t\t\t\t\tif(j&&k&&i-2*k+kk<=i-1)MIN(mn,i-2*j+1+kk);\n\t\t\t\t\t\t\tif(j&&k&&i-2*j+1+kk<=i)MIN(mn,i-2*k+kk);\n\t\t\t\t\t\t\tif(mn<0)break;\n//\t\t\t\t\t\t\tif(i+1==6&&k+1==0&&j==3&&mn==7)cout<<j<<k<<l<<dp[t][j][k][l]<<endl;\n//\t\t\t\t\t\t\tif(i==5&&j==0&&k==3&&l==7)cout<<k+1<<j<<mn<<dp[t][j][k][l]<<endl;\n\t\t\t\t\t\t\t(dp[!t][k+1][j][mn]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tREP(i,0,n-n/2+1)REP(j,0,n/2+1)(res+=dp[n&1][i][j][n])%=mo;\n\t\tcout<<res%mo<<endl;\n\t}else{\n\t\tpar[0][0]=1;\n\t\tREP(i,0,n/2+2){\n\t\t\tint t=i&1;\n\t\t\tfill(par[!t],par[!t]+i+2,0);\n\t\t\tREP(j,0,i+1){\n\t\t\t\t(par[!t][0]+=par[t][j])%=mo;\n\t\t\t\tif(j+1<kk/2+1)(par[!t][j+1]+=par[t][j])%=mo;\n\t\t\t}\n\t\t}\n\t\tcout<<par[(n/2+1)&1][0]*par[(n-n/2+1)&1][0]%mo<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \n//const ll mod=1000000007;\nint mod;\nint rnd(int x) { return mrand() % x;}\n//ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=160;\nint n,k;\n\nll dp[N][N];\nll solvee(int n,int k) {\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\trep(i,0,n) rep(j,0,k+1) {\n\t\tdp[i+1][0]=(dp[i+1][0]+dp[i][j])%mod;\n\t\tif (j+1<=k) dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t}\n\tll ans=0;\n\trep(j,0,k+1) ans=(ans+dp[n][j])%mod;\n\treturn ans;\n}\n\nll dp2[N][N][N];\n\nvoid upd(ll &a,ll b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\n\nbool valid(int a,int b) {\n\tif (a==0||b==0) return 1;\n\treturn a-1+b-1<k;\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&k,&mod);\n\tif (k%2==0) {\n\t\tprintf(\"%lld\\n\",solvee(n/2,k/2)*solvee(n-n/2,k/2)%mod);\n\t} else {\n\t\tll ans=0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;\n\t\tfor (int i=1;i<=k;i+=2) rep(j,0,k+1) {\n\t\t\tdp[i/2+1][0]=(dp[i/2+1][0]+dp[i/2][j])%mod;\n\t\t\tdp[i/2+1][j+1]=(dp[i/2+1][j+1]+dp[i/2][j])%mod;\n\t\t}\n\t\trep(p1,0,n+1) rep(p2,0,n+1) if (valid(p1,p2)) {\n\t\t\tdp2[0][p1][p2]=dp[k/2+1][p2];\n\t\t}\n\t\tfor (int i=0;i+2<n;i+=2) rep(p1,0,n+1) rep(p2,0,n+1) if (valid(p1,p2)) {\n\t\t\t// fix i+2, i+k+2\n\t\t\t//printf(\"gg %d %d %d %lld\\n\",i,p1,p2,dp2[i][p1][p2]);\n\t\t\tif (p1>0) {\n\t\t\t\tif (i+k+2<n) {\n\t\t\t\t\tupd(dp2[i+2][p1-1][0],dp2[i][p1][p2]);\n\t\t\t\t\tif (valid(p1-1,p2+1)) upd(dp2[i+2][p1-1][p2+1],dp2[i][p1][p2]);\n\t\t\t\t} else {\n\t\t\t\t\tupd(dp2[i+2][p1-1][0],dp2[i][p1][p2]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int l=0;l<=n;l++) {\n\t\t\t\t\tif (i+k+2<n) {\n\t\t\t\t\t\tupd(dp2[i+2][l][0],dp2[i][p1][p2]);\n\t\t\t\t\t\tif (valid(l,p2+1)) upd(dp2[i+2][l][p2+1],dp2[i][p1][p2]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupd(dp2[i+2][l][0],dp2[i][p1][p2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int p1=0;p1<=1;p1++) for (int p2=0;p2<=n;p2++) if (valid(p1,p2)) {\n//\t\t\tprintf(\"%d %d %lld\\n\",p1,p2,dp2[4][p1][p2]);\n\t\t\tupd(ans,dp2[n-((n%2)?1:2)][p1][p2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 158\nusing namespace std;\nint vi[N*2],d1[N],mo,dp[N][N][2],n,k,ans;\nvoid get1(int x,int y){\n\td1[0]=1;\n\tfor (int i=1;i<=x+1;i++)\n\t\tfor (int j=max(0,i-y);j<i;j++)d1[i]=(d1[i]+d1[j])%mo;\n\tcout<<d1[x/2+1]*d1[(x+1)/2+1]%mo<<endl;\n}\nvoid add(int &x,int y){x+=y;if (x>=mo)x-=mo;}\nint main(){\n\tcin>>n>>k>>mo;\n\tif (k%2==0)get1(n,k/2+1);\n\telse{\n\t\tfor (int i=1;i<=n+k+1;i++)\n\t\t\tif(i%2==0){if(i<k+2)vi[i]=0;else vi[i]=1;}else{if(i>n)vi[i]=0;else vi[i]=1;}\n\t\tdp[0][0][0]=1;\n\t\tfor (int i=1;i<=(n+k)/2+1;i++){\n\t\t\tfor (int l=0;l<i;l++)\n\t\t\tfor (int p=0;p<=k;p++)\n\t\t\tif (dp[l][p][0]){\n\t\t\t\tint nl,np;\n\t\t\t\tfor (int t1=0;t1<=vi[i*2-1];t1++)\n\t\t\t\tfor (int t2=0;t2<=vi[i*2];t2++){\n\t\t\t\t\tif (t2&&p==1)continue;\n\t\t\t\t\tif (t1==1)nl=l+1;else nl=0;\n\t\t\t\t\tif (t2==0)np=0;\n\t\t\t\t\tif (t1==1&&t2==1){if (l>=k)continue;if (p==0)np=k-l;else np=min(p-1,k-l);}\n\t\t\t\t\tif (t1==0&&t2==1){if (p==0)np=0;else np=p-1;}\n\t\t\t\t\tadd(dp[nl][np][1],dp[l][p][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int l=0;l<=i;l++)\n\t\t\tfor (int p=0;p<=k;p++){\n\t\t\t\tdp[l][p][0]=dp[l][p][1],dp[l][p][1]=0;\n\t\t\t\tif (i==(n+k)/2+1)add(ans,dp[l][p][0]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 12/14/2019, 10:43:31 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing namespace std;\nusing ll = long long;\nll MOD{0};\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{x % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nistream &operator>>(istream &stream, Mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const Mint &a) { return stream << a.x; }\n\n// ----- main() -----\n\n// I wrote this code referring to yataka1999-san's solution\n// https://atcoder.jp/contests/agc035/submissions/6380939\n\nconstexpr int MAX_SIZE{160};\n\nMint dp[MAX_SIZE][MAX_SIZE];\nMint solve_even(ll N, ll K);\n\nMint DP[MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE];\nMint solve_odd(ll N, ll K);\n\nMint solve_even(ll N, ll K)\n{\n  Mint ans{1};\n  for (auto t = 0LL; t < 2; t++)\n  {\n    auto L{(N - t + 1) / 2};\n    fill(&dp[0][0], &dp[0][0] + MAX_SIZE * MAX_SIZE, Mint{0});\n    dp[0][0] = 1;\n    for (auto i = 0LL; i < L; i++)\n    {\n      for (auto j = 0LL; j <= i; j++)\n      {\n        dp[i + 1][j + 1] += dp[i][j];\n        dp[i + 1][0] += dp[i][j];\n      }\n      for (auto j = K / 2 + 1; j <= i + 1; j++)\n      {\n        dp[i + 1][j] = 0;\n      }\n    }\n    Mint sum{0};\n    for (auto j = 0LL; j <= L; j++)\n    {\n      sum += dp[L][j];\n    }\n    ans *= sum;\n  }\n  return ans;\n}\n\nMint solve_odd(ll N, ll K)\n{\n  DP[0][0][0][N] = 1;\n  for (auto i = 0LL; i < N; i++)\n  {\n    auto even{i / 2 + 1};\n    auto odd{(i + 1) / 2};\n    for (auto j = 0LL; j <= even; j++)\n    {\n      for (auto k = 0LL; k <= odd; k++)\n      {\n        for (auto t = i; t <= N; t++)\n        {\n          if (DP[i][j][k][t] == 0)\n          {\n            continue;\n          }\n          auto dst{(t % 2 == i % 2) ? N : t};\n          DP[i + 1][0][j][dst] += DP[i][j][k][t];\n          if (t != i)\n          {\n            dst = j >= K / 2 + 1 ? min(t, i - 2 * k + K) : t;\n            DP[i + 1][k + 1][j][dst] += DP[i][j][k][t];\n          }\n        }\n      }\n    }\n  }\n  Mint ans{0};\n  for (auto j = 0LL; j <= N; j++)\n  {\n    for (auto k = 0LL; k <= N; k++)\n    {\n      ans += DP[N][j][k][N];\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  ll N, K;\n  cin >> N >> K >> MOD;\n  if (K % 2 == 0)\n  {\n    cout << solve_even(N, K) << endl;\n  }\n  else\n  {\n    cout << solve_odd(N, K) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mod;\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint n,m;\nstruct Solve1{\n    int dp[155][155];\n    void run()\n    {\n        dp[0][0]=1;\n        for(int i=1;i+i<=n+1;++i)\n            for(int j=0;j+j<=m;++j)\n            {\n                ade(dp[i][0],dp[i-1][j]);\n                if(j) ade(dp[i][j],dp[i-1][j-1]);\n            }\n        for(int i=1;i<=m/2;++i)ade(dp[n/2][i],dp[n/2][i-1]);\n        if(n&1)\n            for(int i=1;i<=m/2;++i)ade(dp[(n+1)/2][i],dp[(n+1)/2][i-1]);\n        printf(\"%lld\\n\",1ll*dp[n/2][m/2]*dp[(n+1)/2][m/2]%mod);\n    }\n}solve1;\nstruct Solve2{\n    int dp[155][155][155];\n    void run()\n    {\n        dp[0][0][0]=1;\n        int l,r;\n        bool inl,inr;\n        for(int i=1;i<=n;++i)\n        {\n            r=i*2;l=r-m;\n            inl=(l>=1&&l<=n);\n            inr=(r>=1&&r<=n);\n            for(int j=0;j<=n;++j)\n                for(int k=0;k<=m+1;++k)\n                {\n                    ade(dp[i][0][0],dp[i-1][j][k]);\n                    if(inr)//选择当前行右边的点\n                        ade(dp[i][j+1][0],dp[i-1][j][k]);\n                    if(inl&&k+1<=m+1)//选择当前行左边的点\n                        ade(dp[i][0][k?k+1:0],dp[i-1][j][k]);\n                    if(inl&&inr&&max(j+2,k+1)<=m+1)//两边一起选\n                        ade(dp[i][j+1][max(j+2,k+1)],dp[i-1][j][k]);\n                }\n        }\n        printf(\"%d\\n\",dp[n][0][0]);\n    }\n}solve2;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&mod);\n    if(m&1)solve2.run();\n    else solve1.run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=155;\nint n,k,mo;\nnamespace solver1{\n\tint f[N][N];\n\tvoid solve(){\n\t\tint v1=n/2,v2=n-n/2;\n\t\tf[0][0]=1; k/=2;\n\t\tFor(i,1,v2) For(j,0,k){\n\t\t\tf[i][0]=(f[i][0]+f[i-1][j])%mo;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i-1][j])%mo;\n\t\t}\n\t\tint ans1=0,ans2=0;\n\t\tFor(j,0,k){\n\t\t\tans1=(ans1+f[v1][j])%mo;\n\t\t\tans2=(ans2+f[v2][j])%mo;\n\t\t}\n\t\tprintf(\"%lld\\n\",1ll*ans1*ans2%mo);\n\t}\n}\nnamespace solver2{\n\tint f[2][N][N][N];\n\tvoid solve(){\n\t\tint v=(k+3)/2,pre=0,suf=1;\n\t\tf[0][0][0][(n+3)/2]=1;\n\t\tFor(i,1,n){\n\t\t\tint mx=min(v,i/2),val;\n\t\t\tFor(p1,0,mx) For(p2,0,mx) For(p3,1,(n+3)/2)\n\t\t\t\tif (val=f[pre][p1][p2][p3]){\n\t\t\t\t\tint np1,np2,np3;\n\t\t\t\t\tnp1=min(v,p2+1); np2=p1; np3=p3-(p2>=v);\n\t\t\t\t\tif (np1>=v&&np2) np3=min(np3,k+2-v-np2);\n\t\t\t\t\tif (np3) f[suf][np1][np2][np3]=(f[suf][np1][np2][np3]+val)%mo;\n\t\t\t\t\tnp1=0; np2=p1; np3=(p2>=v?(n+3)/2:p3);\n\t\t\t\t\tif (np3) f[suf][np1][np2][np3]=(f[suf][np1][np2][np3]+val)%mo;\n\t\t\t\t\tf[pre][p1][p2][p3]=0;\n\t\t\t\t}\n\t\t\tswap(pre,suf);\n\t\t}\n\t\tint ans=0;\n\t\tFor(p1,0,v) For(p2,0,v) For(p3,1,(n+3)/2)\n\t\t\tans=(ans+f[pre][p1][p2][p3])%mo;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&mo);\n\tif (k%2==0) solver1::solve();\n\telse solver2::solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nint const MAXN = 250;\nint n, k, mod;\nint f[MAXN][MAXN], g[MAXN][MAXN][MAXN];\n\nvoid Solve2() {\n  k >>= 1;\n  f[0][0] = 1;\n  for (RI i = 1; i <= n; ++i) {\n    f[i][0] = f[i - 1][0];\n    for (RI j = k; j; --j) {\n      f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod;\n      f[i][0] = (f[i][0] + f[i - 1][j]) % mod;\n    }\n  }\n  int L = 0, R = 0;\n  for (RI i = 0; i <= k; ++i) {\n    L = (L + f[n / 2][i]) % mod;\n    R = (R + f[(n + 1) / 2][i]) % mod;\n  }\n  cout << 1ll * L * R % mod << endl;\n}\n\nvoid Solve1() {\n  g[0][0][0] = 1;\n  for (RI i = 2; i <= k + n; i += 2) {\n    for (RI j = 0; j <= n; ++j)\n      for (RI l = 0; l <= k + 1; ++l)\n        g[i][0][0] = (g[i][0][0] + g[i - 2][j][l]) % mod;\n    if (i <= n) { // only L\n      for (RI j = 1; j <= n; ++j)\n        for (RI l = 0; l <= k + 1; ++l)\n          g[i][j][0] = (g[i][j][0] + g[i - 2][j - 1][l]) % mod;\n    }\n    if (i - k > 0) { // only R\n      for (RI j = 0; j <= n; ++j) {\n        for (RI l = 0; l <= k + 1; ++l)\n          g[i][0][l] = (g[i][0][l] + g[i - 2][j][l - (l > 0)]);\n        g[i][0][1] = 0;\n      }\n    }\n    if (i <= n && i - k > 0) { // L and R\n      for (RI j = 0; j <= k - 1; ++j)\n        for (RI l = 0; l <= k; ++l)\n          (g[i][j + 1][max(j + 2, l + 1)] += g[i - 2][j][l]) %= mod;\n    }\n  }\n  int last = (n + k) - ((n + k) & 1), ans = 0;\n  for (RI i = 0; i <= n; ++i)\n    for (RI j = 0; j <= k + 1; ++j)\n      ans = (ans + g[last][i][j]) % mod;\n  cout << ans << endl;\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  cin >> n >> k >> mod;\n  if (k & 1) Solve1();\n  else Solve2();\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define cri const int\n#define ll long long\n#define re register\nusing namespace std;\nint N,K,mod;\nint f[152][152];\ninline int mo(cri x){ return x>=mod?x-mod:x; } \ninline void solve2(){\n\tf[0][0]=f[1][0]=f[1][1]=f[2][0]=f[2][1]=1;\n\tK=(K>>1)+1;\n\tfor(int i=3;i<=N;i++){\n\t\tfor(int j=0;j<K;j++) f[i][j]=mo(f[i][0]+f[i-2][j]);\n\t\tfor(int j=0;j<K-1;j++) f[i][j+1]=f[i-2][j];\n\t}\n\tint tmp1=0,tmp2=0;\n\tfor(int i=0;i<K;i++) tmp1=mo(tmp1+f[N][i]),tmp2=mo(tmp2+f[N-1][i]);\n\tcout<<(1ll*tmp1*tmp2%mod+1)%mod<<endl;\n}\nint dp[152][152][152];\ninline void solve1(){\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=N+K>>1;i++){//cout<<\"i=\"<<i<<endl;\n\t\tif(i<=K/2) for(int j=0;j<i;j++) dp[i][0][j+1]=dp[i-1][0][j],dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][0][j]);\n\t\telse if(i<=N/2){\n\t\t\tfor(int j=0;j<=i;j++) \n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t//cout<<j<<\" \"<<k<<endl;\n\t\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\t\telse dp[i][1][0]=mo(dp[i][1][0]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][0][k+1]=mo(dp[i][0][k+1]+dp[i-1][j][k]);\n\t\t\t\t\tif(max(j,k+1)<K+1) dp[i][max(j+1,k+2)][k+1]=mo(dp[i][max(j+1,k+2)][k+1]+dp[i-1][j][k]);\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<=i;j++) for(int k=0;k<i;k++) {\n\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\telse dp[i][1][0]=mo(dp[i][1][0]+dp[i-1][j][k]);\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=i;j++,puts(\"\")) for(int k=0;k<i;k++) cout<<dp[i][j][k]<<\" \";puts(\"\"); \n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++) ans=mo(ans+dp[N+K>>1][i][k]);\n\tcout<<mo(ans+mod-1)<<endl;\n}\nint main(){\n\tcin>>N>>K>>mod;\n\tif(K&1) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define PB push_back\n#define ll long long\nusing namespace std;\nint n,k,mo;\nnamespace solve1{\n\tint f[155][155];\n\tvoid solve(){\n\t\tint ans1=0,ans2=0;\n\t\tf[0][0]=1; k/=2;\n\t\tFor(i,1,n/2+1) For(j,0,min(i-1,k)){\n\t\t\tf[i][0]=(f[i][0]+f[i-1][j])%mo;\n\t\t\tf[i][j+1]=(f[i][j+1]+f[i-1][j])%mo;\n\t\t}\n\t\tFor(i,0,k){\n\t\t\tans1=(ans1+f[n/2][i])%mo;\n\t\t\tans2=(ans2+f[n-n/2][i])%mo;\n\t\t}\n\t\tprintf(\"%d\\n\",1ll*ans1*ans2)%mo;\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&mo);\n\tif (k%2==0) solve1::solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,k,m;\n\nint s1(int n,int k)\n{\n\tstatic int f[155];\n\tf[0] = 1;\n\tfor(int i = 1;i <= n + 1; ++ i)\n\t{\n\t\tf[i] = 0;\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tif(i - j - 1 >= 0)\n\t\t\t\tf[i] = (f[i] + f[i - j - 1]) % m;\n\t}\n\treturn f[n + 1];\n}\n\nint s2(int n,int k)\n{\n\tstatic int f[155][155][155];\n\tstatic int typ[155];\n\tint tot = 0;\n\tfor(int i = 1;i * 2 - k <= n; ++ i)\n\t{\n\t\ttot ++;\n\t\tif(i * 2 <= n) typ[tot] |= 2;\n\t\tif(i * 2 - k > 0) typ[tot] |= 1;\n\t}\n\tf[0][0][0] = 1;\n\tfor(int i = 1;i <= tot; ++ i)\n\t\tfor(int j = 0;j <= k + 1; ++ j)\n\t\t\tfor(int l = 0;l <= k; ++ l)\n\t\t\t\tif(f[i - 1][j][l])\n\t\t\t\t{\n\t\t\t\t\t//×óÓÒ¾ù²»Ñ¡\n\t\t\t\t\tf[i][0][0] = (f[i][0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡×ó²»Ñ¡ÓÒ\n\t\t\t\t\tif(typ[i] & 1)\n\t\t\t\t\t\tf[i][j ? j + 1 : 0][0] = (f[i][j ? j + 1 : 0][0] + f[i - 1][j][l]) % m;\n\t\t\t\t\t//Ñ¡ÓÒ²»Ñ¡×ó\n\t\t\t\t\tif(typ[i] & 2)\n\t\t\t\t\t\tf[i][0][l + 1] = (f[i][0][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t\tif(typ[i] == 3)\n\t\t\t\t\t\tf[i][j ? j + 1 : l + 2][l + 1] = (f[i][j ? j + 1 : l + 2][l + 1] + f[i - 1][j][l]) % m;\n\t\t\t\t}\n\tint as = 0;\n\tfor(int i = 0;i <= k + 1; ++ i)\n\t\tfor(int j = 0;j <= k; ++ j)\n\t\t\tas = (as + f[tot][i][j]) % m;\n\treturn as;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&m);\n\tif(k % 2 == 0)\n\t{\n\t\tprintf(\"%d\\n\",(s1(n / 2,k / 2) * 1ll * s1((n + 1) / 2,k / 2)) % m);\n\t}\n\telse printf(\"%d\\n\",s2(n,k));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 158\nint n,s,p,dp1[N],dp2[N][N][N],pw[N];\nint solve(int m)\n{\n\tdp1[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(i>s/2+1)dp1[i]=(2ll*dp1[i-1]-dp1[i-s/2-2]+p)%p;\n\t\telse if(i==s/2+1)dp1[i]=(2ll*dp1[i-1]-1+p)%p;\n\t\telse dp1[i]=2ll*dp1[i-1]%p;\n\t}\n\treturn dp1[m];\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&s,&p);\n\tpw[0]=1;for(int i=1;i<=150;i++)pw[i]=pw[i-1]*2%p;\n\tif(~s&1)printf(\"%lld\\n\",1ll*solve(n/2)*solve(n-n/2)%p);\n\telse \n\tif(s==1) s=4,printf(\"%d\\n\",solve(n));\n\telse \n\t{\n\t\tint l2=n/2,l1=n-n/2;\n\t\tif(n<=s){int as=1;for(int i=1;i<=n;i++)as=as*2%p;printf(\"%d\\n\",as);return 0;}\n\t\tfor(int i=0;i<=(s+1)/2;i++)dp2[0][0][i]=(s+1)/2==i?1:pw[(s+1)/2-i-1];\n\t\tfor(int i=0;i<l1-(s+1)/2;i++)\n\t\tfor(int j=0;j<=s+1;j++)\n\t\tfor(int k=0;k<=n;k++)\n\t\tif(dp2[i][j][k])\n\t\t{\n\t\t\tdp2[i+1][0][0]=(dp2[i+1][0][0]+dp2[i][j][k])%p;\n\t\t\tdp2[i+1][0][k+1]=(dp2[i+1][0][k+1]+dp2[i][j][k])%p;\n\t\t\tif(j<s+1)\n\t\t\t{\n\t\t\t\tdp2[i+1][j==0?0:j+1][0]=(dp2[i+1][j==0?j:j+1][0]+dp2[i][j][k])%p;\n\t\t\t\tint st=j<k+1?k+2:j+1;\n\t\t\t\tif(st<=s+1)dp2[i+1][st][k+1]=(dp2[i+1][st][k+1]+dp2[i][j][k])%p;\n\t\t\t}\n\t\t}\n\t\tint as=0,ls=l2-(l1-(s+1)/2);\n\t\tfor(int i=0;i<=s+1;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tint tp=dp2[l1-(s+1)/2][i][j],s1=pw[ls];\n\t\t\tif(ls-(s+2-i)>=0)\n\t\t\ts1=(s1-pw[ls-(s+2-i)]+p)%p;\n\t\t\tas=(as+1ll*tp*s1)%p;\n\t\t}\n\t\tprintf(\"%d\\n\",as);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 101;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n\nint f[2][N];\nint g[2][N][N][N];\nint n,K,m;\n\ninline void add(int &x,int y){\n   x += y; if(x >= m)x -= m;\n}\n\nint main(){\n   scanf(\"%d%d%d\",&n,&K,&m);\n   if(K%2 == 0){\n      int ans = 1;\n      fr(t,0,1){\n         int len = (n+t)/2;\n         int cur = 0;\n         f[0][0] = 1;\n         fr(z,1,len){\n            cur ^= 1;\n            memset(f[cur],0,sizeof f[cur]);\n            fr(j,0,K/2-1){\n               add(f[cur][j+1],f[cur^1][j]);\n               add(f[cur][0],f[cur^1][j]);\n            }\n         }\n         int res = 0;\n         fr(z,0,len)res = 1LL*res*f[cur][z]%m;\n         ans = 1LL*ans*res%m;\n      }\n      printf(\"%d\\n\",ans);\n   } else {\n      int cur = 0;\n      g[0][0][0][n] = 1;\n      \n      int ans = 0;\n      fr(i,1,n){\n         cur ^= 1; memset(g[cur],0,sizeof g[cur]);\n         int odd = i/2,even = (i+1)/2;\n         fr(j,0,even){\n            fr(k,0,odd){\n               fr(t,i-1,n){\n                  int to = (t%2 != i%2) ? n : t;\n                  add(g[cur][0][j][to],g[cur^1][j][k][t]);\n                  if(t != i-1){\n                     to = t;\n                     if(j*2 > K)to = min(to,i-k*2+K-1);\n                     add(g[cur][k+1][j][to],g[cur^1][j][k][t]);\n                  }\n               }\n            }\n         }\n      }\n\n      fr(j,0,n){\n         fr(k,0,n){\n            add(ans,g[cur][j][k][n]);\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 158\nint n,s,p,dp1[N],dp2[N][N][N],pw[N];\nint solve(int m)\n{\n\tdp1[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(i>s/2+1)dp1[i]=(2ll*dp1[i-1]-dp1[i-s/2-2]+p)%p;\n\t\telse if(i==s/2+1)dp1[i]=(2ll*dp1[i-1]-1+p)%p;\n\t\telse dp1[i]=2ll*dp1[i-1]%p;\n\t}\n\treturn dp1[m];\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&s,&p);\n\tpw[0]=1;for(int i=1;i<=150;i++)pw[i]=pw[i-1]*2%p;\n\tif(~s&1)printf(\"%lld\\n\",1ll*solve(n/2)*solve(n-n/2)%p);\n\telse \n\tif(s==1) s=4,printf(\"%d\\n\",solve(n));\n\telse \n\t{\n\t\tint l2=n/2,l1=n-n/2;\n\t\tif(n<=s){int as=1;for(int i=1;i<=n;i++)as=as*2%p;printf(\"%d\\n\",as);return 0;}\n\t\tfor(int i=0;i<=(s+1)/2;i++)dp2[0][0][i]=(s+1)/2==i?1:pw[(s+1)/2-i-1];\n\t\tfor(int i=0;i<l1-(s+1)/2;i++)\n\t\tfor(int j=0;j<=s+1;j++)\n\t\tfor(int k=0;k<=n;k++)\n\t\tif(dp2[i][j][k])\n\t\t{\n\t\t\tdp2[i+1][0][0]=(dp2[i+1][0][0]+dp2[i][j][k])%p;\n\t\t\tdp2[i+1][0][k+1]=(dp2[i+1][0][k+1]+dp2[i][j][k])%p;\n\t\t\tif(j<s+1)\n\t\t\t{\n\t\t\t\tdp2[i+1][j==0?0:j+1][0]=(dp2[i+1][j==0?j:j+1][0]+dp2[i][j][k])%p;\n\t\t\t\tint st=j<k+1?k+2:j+1;\n\t\t\t\tif(st<=s+1)dp2[i+1][st][k+1]=(dp2[i+1][st][k+1]+dp2[i][j][k])%p;\n\t\t\t}\n\t\t}\n\t\tint as=0,ls=l2-(l1-(s+1)/2);\n\t\tfor(int i=0;i<=s+1;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tint tp=dp2[l1-(s+1)/2][i][j],s1=pw[ls];\n\t\t\tif(ls-(s+2-i)>=0)\n\t\t\ts1=(s1-pw[ls-(s+2-i)]+p)%p;\n\t\t\tas=(as+1ll*tp*s1)%p;\n\t\t}\n\t\tprintf(\"%d\\n\",as);\n\t}\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint MOD;\n// modnum {{{\nstruct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nconst int MAXN = 155;\nmn dp[MAXN][MAXN][MAXN],\n   DP[MAXN][MAXN][MAXN];\n\nint N, K;\nint calc(int end, int cont) {\n    int res = INT_MAX;\n\n    F0R (cent, min(end, cont - 1)) { // center around a top node\n        int topw = 2 * min(cent, end - 1 - cent);\n        int botmax = (K - topw - 1) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 2 - cent;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax + 1); // not inclusive, number of edges it can grow to\n    }\n\n    F0R (cent, min(end - 1, cont - 1)) { // center between top nodes\n        int topw = 1 + 2 * min(cent, end - 1 - cent - 1);\n        int botmax = (K - topw) / 2; // not inclusive, number of edges in each direction\n\n        int bothave = cont - 1 - cent - 1;\n        if (bothave < botmax) continue;\n\n        ckmin(res, bothave + botmax); // not inclusive, number of edges it can grow to\n    }\n\n    return min(N, res);\n}\n\nint main() {\n    setIO();\n\n    re(N, K, MOD);\n\n    if (K&1) {\n        dp[0][0][N] = 1;\n\n        F0R (i, N) {\n            memset(DP, 0, sizeof(DP));\n\n            F0R (even, N + 1) {\n                F0R (odd, N + 1) {\n                    F0R (limit, N + 1) {\n                        const mn& ctr = dp[even][odd][limit];\n                        if (!ctr.v) continue;\n\n                        if (i&1) {\n                            DP[even][0][min(odd > even ? INT_MAX : limit, calc(odd, even))] += ctr;\n                            if (odd + 1 <= calc(even, odd + 1) && (odd < even || odd + 1 <= limit))\n                                DP[even][odd+1][limit] += ctr;\n                        } else {\n                            DP[0][odd][min(even > odd ? INT_MAX : limit, calc(even, odd))] += ctr;\n                            if (even + 1 <= calc(odd, even + 1) && (even < odd || even + 1 <= limit))\n                                DP[even+1][odd][limit] += ctr;\n                        }\n                    }\n                }\n            }\n\n            swap(DP, dp);\n        }\n\n        mn ans = 0;\n        F0R (even, N + 1) F0R (odd, N + 1) F0R (limit, N + 1) ans += dp[even][odd][limit];\n        ps(ans);\n    } else {\n        vmn ways((N+1)/2 + 1);\n        ways[0] = 1;\n        FOR (v, 1, sz(ways)) {\n            FOR (i, 0, min(v, K/2) + 1)\n                ways[v] += ways[max(0, v-i-1)];\n        }\n        ps(ways[N/2] * ways[(N+1)/2]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<stdint.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define VIS(it,con) for(auto it=con.begin();it!=con.end();++it)\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define MIN(x,y) (x=min(x,(y)))\n#define MAX(x,y) (x=max(x,(y)))\n#define mid (l+r>>1)\n#define lch (idx*2+1)\n#define rch (idx*2+2)\n/*****************************************************************************/\n#include<bits/stdc++.h>\n#define int int_fast64_t\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\n#define REP(i,j,k) for(int i=(j);i<(k);++i)\n#define RREP(i,j,k) for(int i=(j)-1;i>=(k);--i)\n#define ALL(a) a.begin(),a.end()\n#define MST(a,v) memset(a,(v),sizeof a)\n#define pb push_back\n#define F first\n#define S second\n#define endl '\\n'\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#define __debug\n#ifdef __debug\n\t#define IOS (void)0\n\t#define de(...) cerr<<__VA_ARGS__\n\t#define ar(a,s,t) {REP(__i,s,t)de(a[__i]<<' ');de(endl);}\n#else\n\t#define IOS cin.tie(0),cout.tie(0),ios_base::sync_with_stdio(false)\n\t#define de(...) (void)0\n\t#define ar(...) (void)0\n#endif\n/***********************************default***********************************/\nconst int maxn=159;\nint n,kk,m,dp[2][maxn][maxn][maxn],par[2][maxn/2];\n\nmain(){\n\tIOS;\n\tcin>>n>>kk>>m;\n\tconst int mo=m;\n\tif(kk&1){\n\t\tfill(dp[0][0][0],dp[0][0][0]+n,0);\n\t\tdp[0][0][0][n]=1;\n\t\tREP(i,0,n){\n\t\t\tint t=i&1;\n\t\t\tREP(j,0,i+1-(i+1)/2+1)REP(k,0,(i+1)/2+1)REP(l,i+1,n+1)dp[!t][j][k][l]=0;\n\t\t\tREP(j,0,i-i/2+1){\n\t\t\t\tREP(k,0,i/2+1){\n\t\t\t\t\tREP(l,i,n+1){\n\t\t\t\t\t\tif(l!=n&&l%2!=i%2)(dp[!t][0][j][l]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\telse(dp[!t][0][j][n]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\tif(i!=l){\n\t\t\t\t\t\t\tint mn=l;\n\t\t\t\t\t\t\tif(i-2*k+kk<i)MIN(mn,i-2*j+1+kk);\n\t\t\t\t\t\t\tif(i-2*j+kk<i)MIN(mn,i-2*k+kk);\n\t\t\t\t\t\t\t(dp[!t][k+1][j][mn]+=dp[t][j][k][l])%=mo;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tREP(i,0,n-n/2+1)REP(j,0,n/2+1)(res+=dp[n&1][i][j][n])%=mo;\n\t\tcout<<res<<endl;\n\t}else{\n\t\tpar[0][0]=1;\n\t\tREP(i,0,n/2+2){\n\t\t\tint t=i&1;\n\t\t\tfill(par[!t],par[!t]+i+2,0);\n\t\t\tREP(j,0,i+1){\n\t\t\t\t(par[!t][0]+=par[t][j])%=mo;\n\t\t\t\tif(j+1<kk/2+1)(par[!t][j+1]+=par[t][j])%=mo;\n\t\t\t}\n\t\t}\n\t\tcout<<par[(n/2+1)&1][0]*par[(n-n/2+1)&1][0]%mo<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 101;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n\nint f[2][N];\nint g[2][N][N][N];\nint n,K,m;\n\ninline void add(int &x,int y){\n   x += y; if(x >= m)x -= m;\n}\n\nint main(){\n   scanf(\"%d%d%d\",&n,&K,&m);\n   if(K%2 == 0){\n      int ans = 1;\n      fr(t,0,1){\n         int len = (n+t)/2;\n         int cur = 0;\n         memset(f,0,sizeof f);\n         f[0][0] = 1;\n         fr(z,1,len){\n            cur ^= 1;\n            memset(f[cur],0,sizeof f[cur]);\n            fr(j,0,K/2){\n               if(j < K/2)add(f[cur][j+1],f[cur^1][j]);\n               add(f[cur][0],f[cur^1][j]);\n            }\n         }\n         int res = 0;\n         fr(z,0,len)add(res,f[cur][z]);\n         ans = 1LL*ans*res%m;\n      }\n      printf(\"%d\\n\",ans);\n   } else {\n      int cur = 0;\n      g[0][0][0][n] = 1;\n      \n      int ans = 0;\n      fr(i,1,n){\n         cur ^= 1; memset(g[cur],0,sizeof g[cur]);\n         int odd = i/2,even = (i+1)/2;\n         fr(j,0,even){\n            fr(k,0,odd){\n               fr(t,i-1,n){\n                  int to = (t%2 != i%2) ? n : t;\n                  add(g[cur][0][j][to],g[cur^1][j][k][t]);\n                  if(t != i-1){\n                     to = t;\n                     if(j*2 > K)to = min(to,i-k*2+K-1);\n                     add(g[cur][k+1][j][to],g[cur^1][j][k][t]);\n                  }\n               }\n            }\n         }\n      }\n\n      fr(j,0,n){\n         fr(k,0,n){\n            add(ans,g[cur][j][k][n]);\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define SZ(x) (int((x).size()))\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\n#define repe(it, x) for (auto it = (x).begin(); it != (x).end(); ++it)\nconst int MAXN = 155;\nlint MOD;\ninline void chkMOD(int & x) {\n\tif (x >= MOD) x -= MOD;\n}\ninline lint calc(int n, int k) {\n\tstatic int dp[MAXN];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0] = 1;\n\trep (i, 0, n - 1) if (dp[i]) {\n\t\trep (j, 1, k) if (i + j <= n) {\n\t\t\tchkMOD(dp[i + j] += dp[i]);\n\t\t}\n\t}\n\tint res = 0;\n\trep (i, 0, n) {\n\t\tif (n - i < k) chkMOD(res += dp[i]);\n\t}\n\treturn res;\n}\ninline void solveEven(int n, int k) {\n\tcout << calc(n / 2, k / 2 + 1) * calc((n + 1) / 2, k / 2 + 1) % MOD << endl;\n}\ninline void solveOdd(int n, int m) {\n\tstatic int dp[MAXN][MAXN][MAXN];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0][0] = 1;\n\trep (i, 0, m / 2 + (n + 1) / 2 - 1) {\n\t\trep (j, 0, n / 2) rep (k, 0, m + 1) {\n\t\t\tchkMOD(dp[i + 1][0][0] += dp[i][j][k]);\n\t\t\tif (i < n / 2) chkMOD(dp[i + 1][j + 1][0] += dp[i][j][k]);\n\t\t\tif (i >= m / 2) chkMOD(dp[i + 1][0][k ? k + 1 : 0] += dp[i][j][k]);\n\t\t\tif (i < n / 2 && i >= m / 2) chkMOD(dp[i + 1][j + 1][max(j + 2, k + 1)] += dp[i][j][k]);\n\t\t}\n\t}\n\tint res = 0;\n\trep (j, 0, n / 2) rep (k, 0, m + 1) {\n\t\tchkMOD(res += dp[m / 2 + (n + 1) / 2][j][k]);\n\t}\n\tcout << res << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n, k;\n\tcin >> n >> k >> MOD;\n\tif (k & 1) {\n\t\tsolveOdd(n, k);\n\t} else {\n\t\tsolveEven(n, k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, l, mod, dp1[157][157], dp2[307][157][157];\nint main()\n{\n\tcin >> n >> l >> mod;\n\tif (l % 2 == 0)\n\t{\n\t\tl /= 2;\n\t\tdp1[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j <= l; j++)\n\t\t\t\tdp1[i][0] = (dp1[i][0] + dp1[i - 1][j]) % mod;\n\t\t\tfor (int j = 1; j <= l; j++)\n\t\t\t\tdp1[i][j] = (dp1[i][j] + dp1[i - 1][j - 1]) % mod;\n\t\t}\n\t\tint a = 0, b = 0;\n\t\tfor (int i = 0; i <= l; i++)\n\t\t\ta = (a + dp1[n / 2][i]) % mod;\n\t\tfor (int i = 0; i <= l; i++)\n\t\t\tb = (b + dp1[(n + 1) / 2][i]) % mod;\n\t\tcout << 1LL * a * b % mod << endl;\n\t}\n\telse\n\t{\n\t\tint lst = 0;\n\t\tdp2[0][0][0] = 1;\n\t\tfor (int i = 2; i - l <= n; i += 2)\n\t\t{\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tfor (int k = 0; k <= l + 1; k++)\n\t\t\t\t\tdp2[i][0][0] = (dp2[i][0][0] + dp2[i - 2][j][k]) % mod;\n\t\t\tif (i <= n)\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tfor (int k = 0; k <= l + 1; k++)\n\t\t\t\t\t\tdp2[i][j + 1][0] = (dp2[i][j + 1][0] + dp2[i - 2][j][k]) % mod;\n\t\t\tif (i - l >= 1)\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 1; k <= l; k++)\n\t\t\t\t\t\tdp2[i][0][k + 1] = (dp2[i][0][k + 1] + dp2[i - 2][j][k]) % mod;\n\t\t\t\t\tdp2[i][0][0] = (dp2[i][0][0] + dp2[i - 2][j][0]) % mod;\n\t\t\t\t}\n\t\t\tif (i <= n && i - l >= 1)\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tfor (int k = 0; max(k, j + 1) <= l; k++)\n\t\t\t\t\t\tdp2[i][j + 1][max(k + 1, j + 2)] = (dp2[i][j + 1][max(k + 1, j + 2)] + dp2[i - 2][j][k]) % mod;\n\t\t\tlst = i;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tfor (int k = 0; k <= l + 1; k++)\n\t\t\t\tres = (res + dp2[lst][j][k]) % mod;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=155;\nint n,m,mod;\nvoid Inc(int &x,int y){\n\tx+=y;x>=mod?x-=mod:x;\n}\nvoid solve1(){\n\tstatic int f[N][N][N];\n\tf[0][0][0]=1;\n\tfor(int i=1;i<=(n+m)/2;++i){\n\t\tint x=i+i-m,y=i+i;\n\t\tfor(int j=0;j<=m+1;++j)\n\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\tInc(f[i][0][0],f[i-1][j][k]);\n\t\tif(x>=1){\n\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\tInc(f[i][0][0],f[i-1][0][k]);\n\t\t\tfor(int j=1;j<=m+1;++j)\n\t\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\t\tInc(f[i][j+1][0],f[i-1][j][k]);\n\t\t}\n\t\tif(y<=n)\n\t\t\tfor(int j=0;j<=m+1;++j)\n\t\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\t\tInc(f[i][0][k+1],f[i-1][j][k]);\n\t\tif(x>=1&&y<=n)\n\t\t\tfor(int j=0;j<=m+1;++j)\n\t\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\t\tInc(f[i][max(j+1,k+2)][k+1],f[i-1][j][k]);\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=m+1;++j)\n\t\tfor(int k=0;k<=n;++k)\n\t\t\tInc(ans,f[(n+m)/2][j][k]);\n\tprintf(\"%d\\n\",ans);\n}\nvoid solve2(){\n\tstatic int f[N];\n\tf[0]=1;\n\tfor(int i=1;i<=(n+1)/2;++i)\n\t\tfor(int j=max(i-m/2-1,0);j<i;++j)\n\t\t\tInc(f[i],f[j]);\n\tint s1=0,s2=0;\n\tfor(int i=max((n+1)/2-m/2,0);i<=(n+1)/2;++i)\n\t\tInc(s1,f[i]);\n\tfor(int i=max(n/2-m/2,0);i<=n/2;++i)\n\t\tInc(s2,f[i]);\n\tprintf(\"%lld\\n\",1ll*s1*s2%mod);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&mod);\n\tif(m&1)solve1();\n\telse solve2();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=155;\nint n,K,P;\nnamespace sub1{\n\tint f[N][N];\n\tvoid sol(){\n\t\tf[0][0]=1;\n\t\tK/=2;\n\t\trep(i,1,(n+1)/2){\n\t\t\trep(j,0,K)(f[i][0]+=f[i-1][j])%=P;\n\t\t\trep(j,1,K)(f[i][j]+=f[i-1][j-1])%=P;\n\t\t}\n\t\tint ans1=0,ans2=0;\n\t\trep(i,0,K)(ans1+=f[n/2][i])%=P,(ans2+=f[(n+1)/2][i])%=P;\n\t\tprintf(\"%lld\\n\",1LL*ans1*ans2%P);\n\t}\n}\nnamespace sub2{\n\tint f[N][N][N];\n\tvoid sol(){\n\t\tf[0][0][0]=1;\n\t\tint T=(n+(++K))/2;\n\t\trep(i,1,T)rep(j,0,K)rep(k,0,i){\n\t\t\tint w=f[i-1][j][k],x=2*i-1;\n\t\t\t(f[i][0][0]+=w)%=P;\n\t\t\tif(x>=K){\n\t\t\t\t(f[i][j?j+1:0][0]+=w)%=P;\n\t\t\t}\n\t\t\tif(x<=n){\n\t\t\t\t(f[i][0][k+1]+=w)%=P;\n\t\t\t}\n\t\t\tif(K<=x&&x<=n){\n\t\t\t\t(f[i][max(j+1,k+2)][k+1]+=w)%=P;\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(j,0,K)rep(k,0,n)(ans+=f[T][j][k])%=P;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&K,&P);\n\tif(K%2==0){\n\t\tsub1::sol();\n\t}else{\n\t\tsub2::sol();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 155;\nint n,k,mo,f[2][N][N][N];\ninline void add(int &x, int y){\n\tx+=y;x=x<mo?x:x-mo;\n}\nint solve(int n, int k){//no consequent k\n\tstatic int dp[N][N];memset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\trep(i,0,n-1)rep(j,0,k-1)if(dp[i][j]){\n\t\tadd(dp[i+1][0],dp[i][j]);if(j+1<k)add(dp[i+1][j+1],dp[i][j]);\n\t}\n\tint res=0;rep(i,0,k-1)add(res,dp[n][i]);\n\treturn res;\n}\ninline bool ck(int a, int b, int c, int d){\n\tif(b-k>=c&&b-k<=d&&d-k>=a&&d-k<=b)return 0;\n\treturn 1;\n}\nint main() {\n\tread(n);read(k);read(mo);\n\tif(n==1){puts(\"2\");return 0;}\n\tif(k%2==0){\n\t\tprintf(\"%lld\\n\",1LL*solve(n/2,k/2+1)*solve(n-n/2,k/2+1)%mo);\n\t\treturn 0;\n\t}\n\tif(k==1){\n\t\tprintf(\"%lld\\n\",1LL*solve(n,3));\n\t\treturn 0;\n\t}\n\t#define f(p,i,j,k) f[p][i+2][j+2][k]\n\tf(0,0,-1,n+1)=1;\n\trep(i,0,n-1){\n\t\tint p=i&1,q=p^1;//p-->q\n\t\trep(x,0,i+1)rep(y,-1,i+1)rep(t,i,n+1)f(q,x,y,t)=0;\n\t\trep(x,0,i)rep(y,-1,i){\n\t\t\tint T=n+1;\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int c=x+2;c<=n;c+=2)if(!ck(x+2,c,y+2,i-1)){\n\t\t\t\t\tT=c;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int c=y+2;c<=n;c+=2)if(!ck(y+2,c,x+2,i-1)){\n\t\t\t\t\tT=c;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(t,i,n+1)if(f(p,x,y,t)){\n\t\t\t\tif(!(i&1)){\n\t\t\t\t\tif(i+1!=t&&ck(y+2,i+1,x+2,i))add(f(q,x,y,t),f(p,x,y,t));\n\t\t\t\t\tint t_=t-i-1&1?t:n+1;umin(t_,T);\n\t\t\t\t\tadd(f(q,x,i+1,t_),f(p,x,y,t));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i+1!=t&&ck(x+2,i+1,y+2,i))add(f(q,x,y,t),f(p,x,y,t));\n\t\t\t\t\tint t_=t-i-1&1?t:n+1;umin(t_,T);\n\t\t\t\t\tadd(f(q,i+1,y,t_),f(p,x,y,t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;rep(x,0,n)rep(y,-1,n)rep(t,0,n+1)add(res,f(n&1,x,y,t));\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int N = 550;\n\nint n, K, P;\n\ntemplate <typename T1, typename T2>\ninline void add(T1 &x, T2 y) {\n  x += y;\n  if (x >= P)\n    x -= P;\n}\n\nnamespace Sub1 {\n\n  ll f[N][N], ans1, ans2;\n\n  inline ll solve() {\n    K /= 2; f[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j <= K; ++j)\n        add(f[i][0], f[i - 1][j]);\n      for (int j = 1; j <= K; ++j)\n        add(f[i][j], f[i - 1][j - 1]);\n    }\n    for (int i = 0; i <= K; ++i)\n      add(ans1, f[n / 2][i]);\n    for (int i = 0; i <= K; ++i)\n      add(ans2, f[(n + 1) / 2][i]);\n    return ans1 * ans2 % P;\n  }\n}\n\nnamespace Sub2 {\n\n  ll f[N][N][N], ans;\n\n  inline ll solve() {\n    if (K > n - 2) {\n      ll ret = 1;\n      for (int i = 1; i <= n; ++i)\n        ret = ret * 2 % P;\n      return ret;\n    }\n    f[0][0][0] = 1;\n    for (int i = 2; i <= n + K; i += 2) {\n      for (int j = 0; j <= n; ++j)\n        for (int k = 0; k <= K + 1; ++k)\n          add(f[i][0][0], f[i - 2][j][k]);\n      if (i <= n) {\n        for (int j = 0; j <= n; ++j)\n          for (int k = 0; k <= K + 1; ++k)\n            add(f[i][j + 1][0], f[i - 2][j][k]);\n      }\n      if (i >= K + 1) {\n        for (int j = 0; j <= n; ++j) {\n          for (int k = 1; k <= K; ++k)\n            add(f[i][0][k + 1], f[i - 2][j][k]);\n          add(f[i][0][0], f[i - 2][j][0]);\n        }\n      }\n      if (i <= n && i >= K + 1) {\n        for (int j = 0; j <= n; ++j)\n          for (int k = 0; std::max(j + 1, k) <= K; ++k)\n            add(f[i][j + 1][std::max(j + 2, k + 1)], f[i - 2][j][k]);\n      }\n    }\n    for (int j = 0, qwq = ((n + K) & 1 ? n + K - 1 : n + K); j <= n; ++j)\n      for (int k = 0; k <= K + 1; ++k)\n        add(ans, f[qwq][j][k]);\n    return ans;\n  }\n}\n\nint main() {\n  // freopen(\"data\", \"r\", stdin);\n  std::cin >> n >> K >> P;\n  if (!(K & 1)) std::cout << Sub1::solve() << std::endl;\n  else std::cout << Sub2::solve() << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*&@@@@@@@@&&&&&&&&&&&@@@@@@@@&%$$!'''..                                   .!&&&&&&&$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%|\n@@@@@@@@@@@@@@@@&&&&&@@@@&&&&&%%|:`.                                          `|$$$$$$$%%%%%%%%%%||||||||||||||||||||||\n@@@@@@@@@@@@@@@@@@&@@@&&$&&$!;:.                                                .;%%%%%%%%||||||||||!!!!|||||||||||||||\n@@@@@@@@@@@@@@@@@@@&&&$%$&$%;.                                                    .:|||||||||!!!!!!!!!!!!!!!|||||||||||\n@@@@@@@@@@@@@@&&&&&$$$$$$|'                                                          '||||||!!!!!!!!!!!!!!!!!!|||||||||\n@@@@@@@@&&&&&&&&&&&$%|%!`        ....                                                 .'||||!!!!!!!!!!!!!!!!!!|||||||||\n&&&&&&&&&&&&&$$$$$$$%!'         ...                                                     .;|||!!!!!!!!!!!!!!!!!!!|||||||\n&&&&&&$$$$$$$$$$$$%|:.         ...                                                      ..'!|||||||||||||||||||||||||||\n$$$$$$$$$$$$%%%%%|;`          ....            ......                                     ..`;||||||||||||||||||||||||||\n%%%%%%%%%%%%%%%|!:..         ..`..    ..........   .                               ....     `;|||||||||||||||||||||||||\n%%||%||%|%%%%||!:`.          .``..        ..........                          .        ....  `;||||||||||||||||||||||||\n||||||||||||%|!;'.          ..``...      .....  ........                      ......    ..... .:|||||||||||||||||||||||\n|||||||||||||!;:`        ....```..    ..............                          .  ...............:||||||||||||||||||||||\n||||||||||%||!:'.      .   ..`'`.......................  .    .....              ......... ......:|%|||||||||||||||||||\n|||||||||%||!;'.          ..````..........................               ....       ..............:|%%%||||||||||||||||\n||||||||%||!;:`. ..      ...`'''``...............................                       ........  `;%||||||||||||||||||\n||||||%%%||!;:..... .......``''''```..........................................  `:;;;'.   ........ `;%|||||||||||||||||\n|||||||||%|!:`.............`''''''''`````````````.................................````...  ........ `;|||||||||||||||||\n||||||||||!:`............``'::::::::'''``'''``````````.............    ........`....```...   ........'!||||||||||||||||\n||||||||||;`............``':;;;;!;;;::::'''::'''``....................     ...`'````````....   .......:||||||||||||||||\n|||||||||;`....     ...``':;;!!!!!!!!;;;:::::::::''`````.....................':::'``````'``..   ..  ...:|||||||||||||||\n|||||||!'..         ..``':;;!!!!!!!!!!!;;;;;;;:::::'''```````````....```````'::::''''''''''``..   .  ...:||||||||||||||\n|||||!:'`.          .`'':;;!!!!!!||!!!!!!!!!;;;;;;::::::'''''''''''''''`''''''':::'''''''::`....       ..:|||||||||||||\n|||!;;'..          .`''::;;!!!!!|||||||!!!!!!!!!!!!;;;;;;;;;;;;;;;;;;;;;;;:::;:::::'''';;;:'.   .    .   .:||||||||||||\n||;!;:'`            `'::;;;!!!!!||||||||!!!!!!!!!!!!!!!!!!!!!!!!!||||||!;;;::::;;;::'':;:::'.             .:||||||||||!\n|!!!:'`.            .'::;;;!!!!!!|||||||||!!!!!!!!|!!!!!!!!!!!|||||%%%%||!;;;::::::::::::;:`..             .:|||||||||!\n!!!;''`.            .'::;;;!!!!!!!!||||!!!!||||!!!!!!;;;!!!!!!||||%%%|||||!!;;:;;;;:'':::'.                  :||||||||!\n!|!:''`.             `'::;;;!!!!!!!!!!!!!!!!!!!;::'':;;!!!!!!!|||||||||||||!!;;;;;;;:::''`.                   '!||||||!\n!!!:''`.             .`':;;;!!!!!!!!!!!!!!;:''''':;;;;;;;;!!!!||||||||||||!!!;;;;;;;:::''`..                   `;|!!!|!\n!!!:'`.               .'::;;;;!!!!!!!!;:''``':;;;;;;;;;;;;;!!|||||||||||||!!!!!;;;;;;:::''`..                   .:|||!!\n||!:'`..               `'::;;;;;;!;;;;:''':;;;;;;;;;::'`';!!||||||||||||||!!!!!!!!!;;;:::'`..                     '!|||\n|!!:'`..                `:::::;;;;;;;;;;::;;;::::::''``';!!|||||||||||||||!!!!!!!!!!;;;;::'`.                      `;||\n||!;'.                   ....``'::;;;!!;;;;;::'''`...`:;!!!|||||||||||||||!!!!!!!!!!!;;;;::'`..                 .   .'!\n%||;'..  ..               .`''::::::;!!!!!!;;;::''`::;;!!!||||||||||||||||||||||||!!!!!;;;;::'`.                      '\n|%|!:`.                     `'':::'::;!||||!!!!!!;;;;!!!!!||||||||||||||||||||||||||!!!!!;;;;;:'`.                    .\n||%|;`                        `````..`;|||||||||||!!!!!!!!|||||||||||||||||||||%||||||!!!!!!!!;::'`..                 .\n%|%%|'.  ..                    .....`':!||||||||||||!!||||||||||!!!|||||||%%%%%%%||||||!!|||||!!;:''`.                .\n|||%|;.                         .`''::;;|||||||||||!!!!|||||!!!!!!!|||||||%%%%%%|%%%||||||||||||!!;;:'`..             .\n|||%|!'.  ..                     `':::;;!|%|||||||!!!!!!!!!!!!!!!!!||||||%%%%%%%%%%%%|||||%%%|||||!!!;;:'`.           .\n||||||;`   ..                     `::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||%%%%%%%$$%%%|||||%%%%%||||||||!!;:'`.        .\n||||||!:`  ...                     .::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||||%%%%$$%%%||||%%%%%%%%||||%%%||!;;:'.      .\n|||||||;`     ..                    .':;;!|||||||||!!!;!!!!!!!!!!!!!!!!||||||%%%%%%%%||||%%%%%%%%%%%%%%%%%%%||!;:''`. .\n!!!!!!||;`.    ..              .      `:;;;!!!!!!;::;;!!!!!!!!!!!!!!!!!!|||||||||%%%||||%%%%%%%%||||%%%%%%%%%%%||!;;;::\n!!!!!!!!!:.  .......                    `::;;;;;;:;;;!!!||!!!;;;;:;;;!!!!!|||!!!|||||||%%%%%%%|||!||||%%%$$$%%%|||!!!!!\n!!!!!!!!!!:.  .......          .          `:::;;;;;;!!!!!!;;;:::;;;;;;!!!!!!!!!!!||||||%%%%%%%%|||!!!||||||||||||||!!!!\n;;;;;;!!!!!:`..........       ...           .`:::::;;;;;:'``':;!!!!!!!!!!|!!!!!!!||||||||%%%%%%%%%|||!!!!!!!!!!!!!!!!!!\n;;;;;;;!!!!!:`..........        .              .`::::''''':;;!!!!!!!!!|||||!!!!!!!!!!!||||||%%%$$$$%%|||!!!!!!!!!!!!!!!\n;;;;;!!!!!!!!;`............. ..                   .`::::;;;;;;;;;;!!!||%%||!!!!!!!;;;!!!!||||%%$$&&&$$%%%|||||||||||||!\n!!!!!!!!!!!!!!!:`............        ..               .':::::::;;!!|||%%%||!!!!;;;;;;;;;!!!!||%%$&&&&&$$$$$%%%%||||||||\n!!!!!!!!!!|!!!!!:`...............     .      ....        `::;;;!!||||||%||!!!:''::::;;;;;!!!!!|%$&&&&&&&$$$$%%%||||||||\n!!!!!!|||||||||!;`............         ...........         .';;!!!!!!!!!!!!;::::::::;;;;;!!!!!!|%$&&&&&&&$$$$%%%|||||||\n||||||||||||||||;`........... ...      .......`...           .';;;;;;;!!:``'':::;;;;;;!!!!|||||||$&@@@&&&&$$$$%%%%|||||\n||||||||||||||||:``.............       .............            .`':'`.....`':::;;;!!!!||%%%%%%||$@@@@@@&&&$$$%%%%%%%%|\n|||||||||||||%|!:'`.............      . ............                   ....`':::;;!|%$$$$$$$$$%%|%&@##@@@&&$$$$$$$$%%$%\n||||||||||%%%%|;;;`......  ....      ... ....     ...        ..       .....`':::;;!%$&&&&&&&&&&$%$&@@@@@@&&$$$$$$$$$$$$\n||||||%%%%%%%%%!;:'`.....   ...             ..     .......    ..   .....```''::;;!|%$&&@@@@@@@&&$$&&@@@@@&$$%%%%%%%$$$$\n%%%%%%%%%%%%%%%!!;'`...........               ...... ..........   ..``````'':;!%%$$$&&@@@###@@@@&&&&&&&$$%%%|||||%$$$&$\n%%%%%%%%%%%%%%%|!;'.....`''`..      .          ...............    .``````':!%%||||%$&@@######@@@&&&$$%%%||||||||%$&&&&&\n%%%%%%%%%%%%%%%|!:`.......`...     ...````''``````````````.......``''':;|%%|!!!!!!|%$@########@@@&$%%||||||||%%%$&&&@@@\n|%%%%%%%%%%%%%%%|;'`.`'`. .....`''''''::::::::::::::::;;:::'::::::;;;;!%%||!!!!!!!||$&########@&$%%|||||||%%$$$&@@@@@#@\nCoded by Shinmurn Shar, a 20-yr-old beautiful girl.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k,jt;\nint dp[155][155];\nmap<int,int> dps[205];\n\nint getcode(int so,int si,int mo,int mi){\n\treturn (so<<24)+(si<<16)+(mo<<8)+mi;\n}\n\nint dfs(int n,int k,int pos,int so,int si,int mo,int mi){\n\tif(pos==n){\n\t\treturn mo==n&&mi==n;\n\t}\n\tif(mo<pos||mi<pos){\n\t\treturn 0;\n\t}\n\tso=min(so,k/2+1);\n\tsi=min(si,k/2+1);\n\tauto it=dps[pos].find(getcode(so,si,mo,mi));\n\tif(it!=dps[pos].end()){\n\t\treturn it->second;\n\t}\n\tint m0n=n,m1n=n;\n\tif(pos%2==0&&2*si-1>=k){\n\t\tm1n=pos+k-2*min(k/2,so);\n\t}\n\tif(pos%2==1&&2*so-1>=k){\n\t\tm0n=pos+k-2*min(k/2,si);\n\t}\n\tint s0n=so+(pos%2==0),s1n=si+(pos%2==1);\n\tlong long res=dfs(n,k,pos+1,s0n,s1n,min(mo,m0n),min(mi,m1n));\n\tres=(res+dfs(n,k,pos+1,(pos%2==0?0:so),(pos%2==1?0:si),(pos%2==0?n:mo),(pos%2==1?n:mi)))%jt;\n\tdps[pos][getcode(so,si,mo,mi)]=res;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&jt);\n\tif(k%2==0){\n\t\tdp[0][0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=min(i,(k>>1));j++){\n\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%jt;\n\t\t\t\tdp[i+1][0]=(dp[i+1][0]+dp[i][j])%jt;\n\t\t\t}\n\t\t}\n\t\tint ans0=0,ans1=0;\n\t\tfor(int i=0;i<=(k>>1);i++){\n\t\t\tans0=(ans0+dp[n>>1][i])%jt;\n\t\t\tans1=(ans1+dp[(n+1)>>1][i])%jt;\n\t\t}\n\t\tprintf(\"%lld\\n\",1ll*ans0*ans1%jt);\n\t}else if(k==1){\n\t\tdp[0][0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=2;j++){\n\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%jt;\n\t\t\t\tdp[i+1][0]=(dp[i+1][0]+dp[i][j])%jt;\n\t\t\t}\n\t\t}\n\t\tint ans0=0;\n\t\tfor(int i=0;i<=2;i++){\n\t\t\tans0=(ans0+dp[n][i])%jt;\n\t\t}\n\t\tprintf(\"%d\\n\",ans0%jt);\n\t}else{\n\t\tprintf(\"%d\\n\",dfs(n,k,0,0,0,n,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, k, MOD;\nint dp[85][85][85], cur[85][85];\nint pw2[85];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &k, &MOD);\n\t\n\tint ans = 0;\n\tif(k % 2 == 0) {\n\t\tcur[0][0] = 1;\n\t\trep1(i, (n + 3) / 2) rep1(j, min(i, k / 2 + 1))\n\t\tcur[i][i] = (cur[i][i] + cur[i - j][i - j]) % MOD;\n\t\tans = 1LL * cur[n / 2 + 1][n / 2 + 1] * cur[(n + 3) / 2][(n + 3) / 2] % MOD;\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\t\n\tint n0 = (n + 1) / 2, n1 = n / 2;\n\tk = (k + 1) / 2;\n\t\n\tpw2[0] = 1;\n\trep(i, n0) pw2[i + 1] = 2 * pw2[i] % MOD;\n\t\n\tn0 += 2;\n\tn1 += 2;\n\t\n\tfor(int i = 0; i <= k; i ++) dp[0][1][i] = pw2[max(i - 1, 0)];\n\t\n\trep(i, n0) for(int j = 0; j <= i + 1; j ++)\n\trep(lj, n1) {\n\t\tif(lj >= j + k || j <= i && lj != j + k - 1 && lj < i - k) {\n\t\t\tdp[i][j][lj] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdp[i + 1][j][lj] = (dp[i + 1][j][lj] + dp[i][j][lj]) % MOD;\n\t\tif(i - j >= 2 * k) {\n\t\t\tfor(int nj = i - k; nj < n1; nj ++)\n\t\t\tdp[i + 1][i + 2][nj] = (dp[i + 1][i + 2][nj] + 1LL * pw2[max(nj - i + k - 1, 0)] * dp[i][j][lj]) % MOD;\n\t\t} else {\n\t\t\tdp[i + 1][i + 2][lj] = (dp[i + 1][i + 2][lj] + dp[i][j][lj]) % MOD;\n\t\t\tfor(int nj = j + k; nj < n1; nj ++)\n\t\t\tdp[i + 1][i + 2][nj] = (dp[i + 1][i + 2][nj] + 1LL * pw2[nj - j - k] * dp[i][j][lj]) % MOD;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[n0 - 1][n0][n1 - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\nconst int MAX = 161;\nint n,k,m;\n\nvoid add(int& a,int b){\n  a += b;\n  if(a >= m)\n    a -= m;\n}\nint licz(int x){\n  vector<int> dp(k);\n  dp[0] = 1;\n  R(_,x){\n    vector<int> ak(k);\n    R(i,k){\n      add(ak[0],dp[i]);\n      if(i != k-1)\n        add(ak[i+1],dp[i]);\n    }\n    swap(ak,dp);\n  }\n  int res = 0;\n  R(i,k){\n    add(res,dp[i]);\n  }\n  return res;\n}\nint dp[MAX][MAX][MAX];\nint ak[MAX][MAX][MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k >> m;\n  if(k & 1){\n    dp[0][0][0] = 1;\n    R(i,n){\n      debug(\"--------------\",i);\n      R(sk1,n/2+2)R(sk2,n/2+2)R(lim, k+1){\n        ak[sk1][sk2][lim] = 0;\n      }\n      R(sk1,n/2+2)R(sk2,n/2+2)R(lim, k+1){\n        if(lim == 0 || (lim&1))\n          add(ak[sk2][0][0],dp[sk1][sk2][lim]);\n        else\n          add(ak[sk2][0][lim-1],dp[sk1][sk2][lim]);\n        if(lim == 0){\n          if(sk2*2 > k)\n            add(ak[sk2][sk1+1][k-2*sk1], dp[sk1][sk2][lim]);\n          else\n            add(ak[sk2][sk1+1][0], dp[sk1][sk2][lim]);\n        }else{\n          if(lim > 1)\n            add(ak[sk2][sk1+1][lim-1], dp[sk1][sk2][lim]);\n        }\n      }\n      R(sk1,n/2+2)R(sk2,n/2+2)R(lim, k+1){\n        dp[sk1][sk2][lim] = ak[sk1][sk2][lim];\n        if(dp[sk1][sk2][lim]){\n          debug(sk1,sk2,lim, dp[sk1][sk2][lim]);\n        }\n      }\n    }\n    int res = 0;\n    R(sk1,n/2+2)R(sk2,n/2+2)R(lim, k+1){\n      add(res, dp[sk1][sk2][lim]);\n    }\n    cout << res << \"\\n\";\n  }else{\n    k/=2;k++;\n    cout << licz(n/2) * licz((n+1)/2) % m << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define cri const int\n#define ll long long\n#define re register\nusing namespace std;\nint N,K,mod;\nint f[152][152];\ninline int mo(cri x){ return x>=mod?x-mod:x; } \ninline void solve2(){\n\tf[0][0]=f[1][0]=f[1][1]=f[2][0]=f[2][1]=1;\n\tK=(K>>1)+1;\n\tfor(int i=3;i<=N;i++){\n\t\tfor(int j=0;j<K;j++) f[i][j]=mo(f[i][0]+f[i-2][j]);\n\t\tfor(int j=0;j<K-1;j++) f[i][j+1]=f[i-2][j];\n\t}\n\tint tmp1=0,tmp2=0;\n\tfor(int i=0;i<K;i++) tmp1=mo(tmp1+f[N][i]),tmp2=mo(tmp2+f[N-1][i]);\n\tcout<<(1ll*tmp1*tmp2%mod-1+mod)%mod<<endl;\n}\nint dp[152][152][152];\ninline void solve1(){\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=N+K>>1;i++){//cout<<\"i=\"<<i<<endl;\n\t\tif(i<=K/2) for(int j=0;j<i;j++) dp[i][0][j+1]=dp[i-1][0][j],dp[i][0][0]=mo(dp[i][0][0]+dp[i-1][0][j]);\n\t\telse if(i<=N/2){\n\t\t\tfor(int j=0;j<=i;j++) \n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t//cout<<j<<\" \"<<k<<endl;\n\t\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\t\telse dp[i][1][0]=mo(dp[i][1][0]+dp[i-1][j][k]);\n\t\t\t\t\tdp[i][0][k+1]=mo(dp[i][0][k+1]+dp[i-1][j][k]);\n\t\t\t\t\tif(max(j,k+1)<K+1) dp[i][max(j+1,k+2)][k+1]=mo(dp[i][max(j+1,k+2)][k+1]+dp[i-1][j][k]);\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<=i;j++) for(int k=0;k<i;k++) {\n\t\t\t\tdp[i][0][0]=mo(dp[i][0][0]+dp[i-1][j][k]);\n\t\t\t\tif(j>=2) dp[i][j+1][0]=mo(dp[i][j+1][0]+dp[i-1][j][k]);\n\t\t\t\telse dp[i][1][0]=mo(dp[i][1][0]+dp[i-1][j][k]);\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=i;j++,puts(\"\")) for(int k=0;k<i;k++) cout<<dp[i][j][k]<<\" \";puts(\"\"); \n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++) ans=mo(ans+dp[N+K>>1][i][k]);\n\tcout<<mo(ans+mod-1)<<endl;\n}\nint main(){\n\tcin>>N>>K>>mod;\n\tif(K&1) solve1();\n\telse solve2();\n}"
  },
  {
    "language": "C++",
    "code": "//quming\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nint P;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n    R int res=1;\n    for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n    return res;\n}\nconst int N=155;\nint n,p;\ninline int max(R int x,R int y){return x>y?x:y;}\nint solve(int n,int p){\n    static int f[N][N];memset(f,0,sizeof(f));\n    f[0][0]=1;\n    fp(i,0,n-1)fp(j,0,p)if(f[i][j])upd(f[i+1][0],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n    R int res=0;fp(i,0,p)upd(res,f[n][i]);\n    return res;\n}\nint f[N][N][N];\nint main(){\n//  freopen(\"testdata.in\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&p,&P);\n    if(p&1^1)return printf(\"%d\\n\",mul(solve(n>>1,p>>1),solve((n+1)>>1,p>>1))),0;\n    f[0][0][0]=1;\n    fp(i,1,n+1){\n        R int r=(i<<1),l=r-p;\n        R bool fr=(r>=1&&r<=n),fl=(l>=1&&l<=n);\n        fp(j,0,n)fp(k,0,p+1)if(f[i-1][j][k]){\n            upd(f[i][0][0],f[i-1][j][k]);\n            if(fr)upd(f[i][j+1][0],f[i-1][j][k]);\n            if(fl&&k+1<p+2)upd(f[i][0][k?k+1:k],f[i-1][j][k]);\n            if(fl&&fr&&max(k+1,j+1)<p+2)upd(f[i][j+1][max(k+1,j+1)],f[i-1][j][k]);\n        }\n    }\n    printf(\"%d\\n\",f[n+1][0][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 155;\n\nint n, m, mod;\nint f[maxN + 1][maxN + 1][maxN + 1], g[maxN + 1][maxN + 1];\nint ans;\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int solve1()\n{\n\tf[0][0][0] = 1;\n\tfor(int i = 1; i <= m / 2; i++)\n\t{\n\t\tfor(int j = 0; j <= i - 1; j++) f[i][0][0] = ADD(f[i][0][0], f[i - 1][0][j]);\n\n\t\tfor(int j = 1; j <= i; j++) \n\t\t\tf[i][0][j] = f[i - 1][0][j - 1];\t\n\t}\n\tfor(int i = m / 2 + 1; i <= n / 2; i++)\n\t{\n\t\t//none\n\t\tfor(int j = 0; j <= m + 1; j++) \n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][0][0] = ADD(f[i][0][0], f[i - 1][j][k]);\n\t\tfor(int j = 1; j <= i - m / 2; j++) f[i][0][0] = ADD(f[i][0][0], g[i - 1][j]);\n\t\t//left\n\t\tg[i][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - 1; j++) g[i][1] = ADD(g[i][1], f[i - 1][0][j]);\n\t\tfor(int j = 2; j <= i - m / 2; j++) g[i][j] = g[i - 1][j - 1];\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][j][0] = ADD(f[i][j][0], f[i - 1][j - 1][k]);\n\t\t//right\n\t\tfor(int j = 0; j <= m + 1; j++) f[i][0][1] = ADD(f[i][0][1], f[i - 1][j][0]);\n\t\tfor(int j = 1; j <= i - m / 2 - 1; j++) f[i][0][1] = ADD(f[i][0][1], g[i - 1][j]);\n\t\tfor(int j = 2; j <= i; j++) \n\t\t{\n\t\t\tf[i][0][j] = f[i - 1][0][j - 1];\n\t\t\tfor(int k = 2; k <= m + 1; k++) f[i][0][j] = ADD(f[i][0][j], f[i - 1][k][j - 1]);\n\t\t}\n\t\t//both\n\t\tf[i][2][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - m / 2 - 1; j++) f[i][2][1] = ADD(f[i][2][1], g[i - 1][j]);\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t{\n\t\t\tf[i][j][j - 1] = f[i - 1][0][j - 2];\n\t\t\tfor(int k = 1; k <= i; k++) f[i][j][k] = ADD(f[i][j][k], f[i - 1][j - 1][k - 1]);\n\t\t}\n\t}\n\tint last = n - n / 2 + m / 2;\n\tfor(int i = n / 2 + 1; i <= last; i++)\n\t{\n\t\tfor(int j = 0; j <= m + 1; j++) \n\t\t\tfor(int k = 0; k <= n / 2; k++)\n\t\t\t\tf[i][0][0] = ADD(f[i][0][0], f[i - 1][j][k]);\n\t\tfor(int j = 1; j <= i - m / 2; j++) f[i][0][0] = ADD(f[i][0][0], g[i - 1][j]);\n\n\t\tg[i][1] = f[i - 1][0][0];\n\t\tfor(int j = 1; j <= i - 1; j++) g[i][1] = ADD(g[i][1], f[i - 1][0][j]);\n\t\tfor(int j = 2; j <= i - m / 2; j++) g[i][j] = g[i - 1][j - 1];\n\t\tfor(int j = 3; j <= m + 1; j++)\n\t\t\tfor(int k = 0; k <= i - 1; k++)\n\t\t\t\tf[i][j][0] = ADD(f[i][j][0], f[i - 1][j - 1][k]);\n\t}\n\tint ans = f[last][0][0];\n\tfor(int i = 2; i <= m + 1; i++) \n\t\tfor(int j = 0; j <= n / 2; j++) ans = ADD(ans, f[last][i][j]);\n\tfor(int i = 1; i <= n - n / 2; i++) ans = ADD(ans, g[last][i]);\n\treturn ans;\n}\n\ninline int solve2(int n)\n{\n\tmemset(g, 0, sizeof(g));\n\tint ans = 1;\n\tg[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j <= min(i - 1, m / 2); j++) g[i][0] = ADD(g[i][0], g[i - 1][j]);\n\t\tfor(int j = 1; j <= min(i, m / 2); j++)\n\t\t\tg[i][j] = g[i - 1][j - 1], ans = ADD(ans, g[i][j]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &mod);\n\tif(m & 1) printf(\"%d\", solve1());\n\telse printf(\"%d\", 1ll * solve2(n / 2) * solve2(n - n / 2) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 153;\n\nint mo;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\n\nint n,tran;\n\nnamespace whentraniseven\n{\n\tlint f[_][_];\n\t\n\tint main()\n\t{\n\t\tmemset(f,0,sizeof(f)),f[0][0]=1;\n\t\tint lim=tran/2,len=(n+1)/2;\n\t\tfor(int i=1;i<=len;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=lim;j++)ad(f[i][0],f[i-1][j]);\n\t\t\tfor(int j=1;j<=lim;j++)ad(f[i][j],f[i-1][j-1]);\n\t\t}\n\n\t\tlint anse=0,anso=0;\n\t\tfor(int i=0;i<=lim;i++)ad(anse,f[n/2][i]);\n\t\tfor(int i=0;i<=lim;i++)ad(anso,f[n/2+1][i]);\n\t\tprintf(\"%lld\\n\",anse*anso%mo);\n\n\t\treturn 0;\n\t}\n}\n\nnamespace whentranisodd\n{\n\tlint f[_][_][_];\n\n\tint main()\n\t{\n\t\tmemset(f,0,sizeof(f)),f[0][0][0]=1;\n\t\tint lim=tran+1;\n\t\t\n\t\tfor(int i=1;i+i-tran<=n;i++)\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tfor(int k=0;k<=lim;k++)\n\t\t\t\t{\n\t\t\t\t\tif(!f[i-1][j][k])continue;\n\t\t\t\t\tlint x=f[i-1][j][k];\n\t\t\t\t\tad(f[i][0][0],x);\n\t\t\t\t\tif(i+i<=n)ad(f[i][j+1][0],x);\n\t\t\t\t\tif(i+i-tran>=1)ad(f[i][0][k==0?0:k+1],x);\n\t\t\t\t\tif(i+i<=n && i+i-tran>=1)ad(f[i][j+1][max(j+2,k+1)],x);\n\t\t\t\t}\n\t\t\n\t\tlint ans=0;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\tad(ans,f[(n+tran)/2][i][j]);\n\t\tprintf(\"%lld\\n\",ans);\n\n\t\treturn 0;\n\t}\n}\n\nint main()\n{\n\tn=ty(),tran=ty(),mo=ty();\n\n\tif(tran%2==0)return whentraniseven::main();\n\treturn whentranisodd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 305;\n\nint mod;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\n\nint f[N][N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int k;  cin >> k >> mod;\n\n    if (k % 2 == 0) {\n        k /= 2;\n        vector<int> f(n + 1,0);\n        vector<int> g(n + 1,0);\n\n        g[0] = 1;\n\n        for(int i = 1 ; i <= n ; ++i)   {\n            add(g[i],f[i - 1]);\n            add(g[i],g[i - 1]);\n\n            for(int j = 1 ; j <= k ; ++j)   if (j <= i)\n                add(f[i],g[i - j]);\n        }\n        for(int i = 0 ; i <= n ; ++i)\n            add(f[i],g[i]);\n\n        cout << mul(f[n / 2],f[n - n / 2]) << endl;\n        return  0;\n    }\n    f[0][0][0] = 1;\n\n    for(int i = 2 ; i <= n + k ; i += 2)    {\n        for(int j = 0 ; j <= n ; ++j)\n        for(int t = 0 ; t <= k + 1 ; ++t)\n            add(f[i][0][0],f[i - 2][j][t]);\n\n        if (i <= n) {\n            for(int j = 0 ; j <= n ; ++j)\n            for(int t = 0 ; t <= k + 1 ; ++t)\n                add(f[i][j + 1][0],f[i - 2][j][t]);\n        }\n        if (i >  k) {\n            for(int j = 0 ; j <= n ; add(f[i][0][0],f[i - 2][j++][0]))\n            for(int t = 1 ; t <= k ; ++t)\n                add(f[i][0][t + 1],f[i - 2][j][t]);\n        }\n        if (i <= n && i > k)    {\n            for(int j = 0 ; j <= n ; ++j)   if (j < k)\n            for(int t = 0 ; t <= k ; ++t)\n                add(f[i][j + 1][max(j + 2,t + 1)],f[i - 2][j][t]);\n        }\n    }\n    int ans = 0;\n\n    for(int i = 0 ; i <= n ; ++i)\n    for(int j = 0 ; j <= k + 1 ; ++j)\n        add(ans,f[(n + k) / 2 * 2][i][j]);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-28 17:46:12\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200;\nint n,m,mod;\ni64 &Add(i64 &a,i64 b){ return a=(a+b)%mod; }\nnamespace m2\n{\n\ti64 f[N],F[N];\n\tint main(int n)\n\t{\n\t\ti64 ans=0; memset(f,0,sizeof(f)); f[0]=1;\n\t\tfr(i,1,n)\n\t\t{\n\t\t\tfr(j,0,m/2){ F[j]=f[j]; f[j]=0; }\n\t\t\tfr(j,0,m/2){ Add(f[0],F[j]); Add(f[j+1],F[j]); }\n\t\t}\n\t\tfr(i,0,m/2) Add(ans,f[i]);\n\t\treturn ans;\n\t}\n}\nnamespace m1\n{\n\ti64 f[N][N],F[N][N];\n\tint a[N],b[N],n;\n\tint main(int _n)\n\t{\n\t\ti64 ans=0; memset(f,0,sizeof(f)); f[0][0]=1;\n\t\tfd(i,_n,1) if(i&1){ n++; a[n]=1; b[n]=(i+m<=_n); }\n\t\tfr(i,1,m) if(!(i&1)) b[++n]=1;\n\t\tfr(i,1,n)\n\t\t{\n//\t\t\tputchar(10);\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",f[j][k],k==m?'\\n':' ');\n\t\t\tfr(j,0,m+1) fr(k,0,m) F[j][k]=0;\n\t\t\tfr(j,0,m+1) fr(k,0,m){ Add(F[std::min(j,m)][k],f[j][k]); f[j][k]=0; }\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",F[j][k],k==m?'\\n':' ');\n\t\t\tfr(j,0,m) fr(k,0,m) fr(A,0,a[i]) fr(B,0,b[i])\n\t\t\t{\n\t\t\t\tif(A&&B) Add(f[j+1][std::max(j,k)+1],F[j][k]);\n\t\t\t\tif(A&&!B) Add(f[j+1][0],F[j][k]);\n\t\t\t\tif(!A&&B) Add(f[0][k?k+1:0],F[j][k]);\n\t\t\t\tif(!A&&!B) Add(f[0][0],F[j][k]);\n\t\t\t}\n//\t\t\tprintf(\"%d  %d %d\\n\",i,a[i],b[i]);\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",f[j][k],k==m?'\\n':' ');\n\t\t}\n\t\tfr(i,0,m+1) fr(j,0,m) Add(ans,f[i][j]);\n\t\treturn ans;\n\t}\n}\nint main()\n{\n\tn=read(); m=read(); mod=read();\n\tif(m%2==0) printf(\"%d\\n\",int(1ll*m2::main(n/2)*m2::main((n+1)/2)%mod));\n\telse printf(\"%d\\n\",int(m1::main(n)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nint const MAXN = 505;\nint n, k, mod;\nint f[MAXN][MAXN], g[MAXN][MAXN][MAXN];\n\nvoid Solve2() {\n  k >>= 1;\n  f[0][0] = 1;\n  for (RI i = 1; i <= n; ++i) {\n    f[i][0] = f[i - 1][0];\n    for (RI j = k; j; --j) {\n      f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod;\n      f[i][0] = (f[i][0] + f[i - 1][j]) % mod;\n    }\n  }\n  int L = 0, R = 0;\n  for (RI i = 0; i <= k; ++i) {\n    L = (L + f[n / 2][i]) % mod;\n    R = (R + f[(n + 1) / 2][i]) % mod;\n  }\n  cout << 1ll * L * R % mod << endl;\n}\n\nvoid Solve1() {\n  g[0][0][0] = 1;\n  for (RI i = 2; i <= k + n; i += 2) {\n    for (RI j = 0; j <= n; ++j)\n      for (RI l = 0; l <= k + 1; ++l)\n        g[i][0][0] = (g[i][0][0] + g[i - 2][j][l]) % mod;\n    if (i <= n) { // only L\n      for (RI j = 1; j <= n; ++j)\n        for (RI l = 0; l <= k + 1; ++l)\n          g[i][j][0] = (g[i][j][0] + g[i - 2][j - 1][l]) % mod;\n    }\n    if (i - k > 0) { // only R\n      for (RI j = 0; j <= n; ++j) {\n        for (RI l = 0; l <= k + 1; ++l)\n          if (l != 1)\n            g[i][0][l] = (g[i][0][l] + g[i - 2][j][l - (l > 0)]) % mod;\n      }\n    }\n    if (i <= n && i - k > 0) { // L and R\n      for (RI j = 0; j <= k - 1; ++j)\n        for (RI l = 0; l <= k; ++l)\n          (g[i][j + 1][max(j + 2, l + 1)] += g[i - 2][j][l]) %= mod;\n    }\n  }\n  int last = (n + k) - ((n + k) & 1), ans = 0;\n  for (RI i = 0; i <= n; ++i)\n    for (RI j = 0; j <= k + 1; ++j)\n      ans = (ans + g[last][i][j]) % mod;\n  cout << ans << endl;\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  cin >> n >> k >> mod;\n  if (k & 1) Solve1();\n  else Solve2();\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=155;\nint n,K,MD;\nvoid add(int &x,int y) {\n\tx+=y;\n\tif(x>=MD) x-=MD;\n}\nint f[N][N];\nvoid solve1() {\n\tK>>=1,f[0][0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<=K;j++) add(f[i][0],f[i-1][j]);\n\t\tfor(int j=0;j<K;j++) add(f[i][j+1],f[i-1][j]);\n\t}\n\tint s1=0,s2=0;\n\tfor(int i=0;i<=K;i++) add(s1,f[n/2][i]);\n\tfor(int i=0;i<=K;i++) add(s2,f[(n+1)/2][i]);\n\tprintf(\"%d\\n\",1LL*s1*s2%MD);\n}\nint g[N*2][N][N];\nvoid solve2() {\n\tint p;\n\tg[0][0][0]=1;\n\tfor(int i=2;i-K<=n;i+=2) {\n\t\tfor(int j=0;j<=n;j++) {//不选\n\t\t\tfor(int k=0;k<=K+1;k++) {\n\t\t\t\tadd(g[i][0][0],g[i-2][j][k]);\n\t\t\t}\n\t\t}\n\t\tif(i<=n) {//右\n\t\t\tfor(int j=0;j<=n;j++) {\n\t\t\t\tfor(int k=0;k<=K+1;k++) {\n\t\t\t\t\tadd(g[i][j+1][0],g[i-2][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i-K>=1) {//左\n\t\t\tfor(int j=0;j<=n;j++) {\n\t\t\t\tfor(int k=1;k<=K;k++) {\n\t\t\t\t\tadd(g[i][0][k+1],g[i-2][j][k]);\n\t\t\t\t}\n\t\t\t\tadd(g[i][0][0],g[i-2][j][0]);\n\t\t\t}\n\t\t}\n\t\tif(i<=n&&i-K>=1) {\n\t\t\tfor(int j=0;j<=n;j++) {\n\t\t\t\tfor(int k=0;max(k,j+1)<=K;k++) {\n\t\t\t\t\tadd(g[i][j+1][max(k,j+1)+1],g[i-2][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp=i;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n;i++) {\n\t\tfor(int j=0;j<=K+1;j++) {\n\t\t\tadd(ans,g[p][i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\nint main() {\n\tscanf(\"%d%d%d\",&n,&K,&MD);\n\tif(K%2==0) solve1();\n\telse solve2();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint read() {\n\tchar c = getchar();\n\tint res = 0;\n\twhile (c < '0' || c > '9') c = getchar();\n\twhile (c >= '0' && c <= '9') res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();\n\treturn res;\n}\nint n, p, K, f[155][155], g[305][155][155];\nvoid Solve1()\n{\n\tK /= 2;\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= (n + 1) / 2; i++)\n\t{\n\t\tfor (int j = 0; j <= K; j++)\n\t\t\tf[i][0] = (f[i][0] + f[i - 1][j]) % p;\n\t\tfor (int j = 0; j < K; j++)\n\t\t\tf[i][j + 1] = (f[i][j + 1] + f[i - 1][j]) % p;\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tfor (int i = 0; i <= K; i++)\n\t\tans1 = (ans1 + f[n / 2][i]) % p;\n\tfor (int i = 0; i <= K; i++)\n\t\tans2 = (ans2 + f[(n + 1) / 2][i]) % p;\n\tprintf(\"%lld\\n\", 1ll * ans1 * ans2 % p);\n}\nvoid Solve2()\n{\n\tint last = 0;\n\tg[0][0][0] = 1;\n\tfor (int i = 2; i - K <= n; i += 2)\n\t{\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tfor (int k = 0; k <= K + 1; k++)\n\t\t\t\tg[i][0][0] = (g[i][0][0] + g[i - 2][j][k]) % p;\n\t\tif (i <= n)\n\t\t{\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tfor (int k = 0; k <= K + 1; k++)\n\t\t\t\t\tg[i][j + 1][0] = (g[i][j + 1][0] + g[i - 2][j][k]) % p;\n\t\t}\n\t\tif (i - K >= 1)\n\t\t{\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 1; k <= K; k++)\n\t\t\t\t\tg[i][0][k + 1] = (g[i][0][k + 1] + g[i - 2][j][k]) % p;\n\t\t\t\tg[i][0][0] = (g[i][0][0] + g[i - 2][j][0]) % p;\n\t\t\t}\n\t\t}\n\t\tif (i <= n && i - K >= 1)\n\t\t{\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tfor (int k = 0; max(k, j + 1) <= K; k++)\n\t\t\t\t\tg[i][j + 1][max(k + 1, j + 2)] = (g[i][j + 1][max(k + 1, j + 2)] + g[i - 2][j][k]) % p;\n\t\t}\n\t\tlast = i;\n\t}\n\tint ans = 0;\n\tfor (int j = 0; j <= n; j++)\n\t\tfor (int k = 0; k <= K + 1; k++) ans = (ans + g[last][j][k]) % p;\n\tprintf(\"%d\\n\", ans);\n}\nint main()\n{\n\tn = read(), K = read(), p = read();\n\tif (!(K & 1))\n\t\tSolve1();\n\telse\n\t\tSolve2();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=150;\nint n,k,mod;\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\nnamespace Case1 //Even number solver\n{\n\tint f[N][N];\n\tinline int calc(CI n,CI k)\n\t{\n\t\tRI i,j; for (f[0][0]=i=1;i<=n;++i) for (f[i][0]=f[i-1][0],j=1;j<=k;++j)\n\t\tinc(f[i][0],f[i-1][j]),f[i][j]=f[i-1][j-1];\n\t\tint ret=0; for (i=0;i<=k;++i) inc(ret,f[n][i]); return ret;\n\t}\n\tinline void solve(void)\n\t{\n\t\tprintf(\"%d\",1LL*calc(n>>1,k>>1)*calc(n-(n>>1),k>>1)%mod);\n\t}\n};\nnamespace Case2 //Odd number solver\n{\n\tint f[N][N][N],ans;\n\tinline void solve(void)\n\t{\n\t\tRI i,j,p; for (f[0][0][0]=i=1;i<=n;++i)\n\t\t{\n\t\t\tint r=i<<1,l=r-k,fl=1<=l&&l<=n,fr=1<=r&&r<=n;\n\t\t\tfor (j=0;j<=n;++j) for (p=0;p<=k+1;++p)\n\t\t\t{\n\t\t\t\tinc(f[i][0][0],f[i-1][j][p]); if (fr) inc(f[i][j+1][0],f[i-1][j][p]);\n\t\t\t\tif (fl&&p+1<k+2) inc(f[i][0][p?p+1:p],f[i-1][j][p]);\n\t\t\t\tif (fl&&fr&&max(j+2,p+1)<k+2) inc(f[i][j+1][max(j+2,p+1)],f[i-1][j][p]);\n\t\t\t}\n\t\t}\n\t\tfor (i=0;i<=n;++i) for (j=0;j<=k+1;++j)\n\t\tinc(ans,f[n][i][j]); printf(\"%d\",ans);\n\t}\n};\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&mod); if (k&1) Case2::solve();\n\telse Case1::solve(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\n#define int long long\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nll M;\nint n, k;\n\nconst int N = 160;\nset<string> all;\n\nstring target = \"000101000\";\nset<string> used;\n\nint zip(int x, int y, int xup, int yup) {\n\treturn min(N - 1, (x < y) ? xup : yup);\n}\n\n// int mem[N][N][N][N];\nint ****mem;\n\nint dp(int i, int x, int y, int xup, int yup) {\n\tif (i == n)\n\t\treturn 1;\n\tif (mem[i][x][y][zip(x, y, xup, yup)] != -1) return mem[i][x][y][zip(x, y, xup, yup)];\n\tint rez = 0;\n\t// take\n\t{\n\t\tint nxup = xup;\n\t\tif (nxup > i) {\n\t\t\trez += dp(i + 1, y, x, yup, nxup);\n\t\t}\n\t}\n\t// don't\n\t{\n\t\tint nyup = yup;\n\t\tif (nyup - k <= i && i <= y + k)\n\t\t\tnyup = i + k + 2;\n\t\trez += dp(i + 1, max(y, nyup - k - k), i + 2, nyup, i + 3 + k);\n\t}\n\trez -= (rez >= M) * M;\n\treturn mem[i][x][y][zip(x, y, xup, yup)] = rez;\n}\n\n\nvoid go(string s) {\n\tused.insert(s);\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] == '1') {\n\t\t\tstring t = s;\n\t\t\tif (i - 2 >= 0)\n\t\t\t\tt[i - 2] = '1';\n\t\t\tif (i + k < n)\n\t\t\t\tt[i + k] = '1';\n\t\t\tt[i] = '0';\n\t\t\tif (!used.count(t))\n\t\t\t\tgo(t);\n\t\t}\n}\n\nint hard[N][N];\n\nint easy(int n, int combo) {\n\tif (n == 0) return 1;\n\tif (hard[n][combo] != -1) return hard[n][combo];\n\tint rez = 0;\n\tif (combo != k - 1) \n\t\trez += easy(n - 1, combo + 1);\n\trez += easy(n - 1, 0);\n\trez -= (rez >= M) * M;\n\treturn hard[n][combo] = rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\t// memset(mem, -1, sizeof mem);\n\tint *a = new int[N * N * N * N];\n\tprint a[0];\n\treturn 0;\n\tmemset(hard, -1, sizeof hard);\n\tscan n, k, M;\n\tif (k & 1) {\n\t\tprint dp(0, 0, 1, 1 + k, 2 + k);\n\t} else {\n\t\tk /= 2;\n\t\tk++;\n\t\tprint (easy(n / 2, 0) * easy((n + 1) / 2, 0)) % M;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-28 17:46:12\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200;\nint n,m,mod;\ni64 &Add(i64 &a,i64 b){ return a=(a+b)%mod; }\nnamespace m2\n{\n\ti64 f[N],F[N];\n\tint main(int n)\n\t{\n\t\ti64 ans=0; memset(f,0,sizeof(f)); f[0]=1;\n\t\tfr(i,1,n)\n\t\t{\n\t\t\tfr(j,0,m/2){ F[j]=f[j]; f[j]=0; }\n\t\t\tfr(j,0,m/2){ Add(f[0],F[j]); Add(f[j+1],F[j]); }\n\t\t}\n\t\tfr(i,0,m/2) Add(ans,f[i]);\n\t\treturn ans;\n\t}\n}\nnamespace m1\n{\n\ti64 f[N][N],F[N][N];\n\tint a[N],b[N],n;\n\tint main(int _n)\n\t{\n\t\ti64 ans=0; memset(f,0,sizeof(f)); f[0][0]=1;\n\t\tfd(i,_n,1) if(i&1){ n++; a[n]=1; b[n]=(i+m<=_n); }\n\t\tfr(i,1,m) if(!(i&1)) b[++n]=1;\n\t\tfr(i,1,n)\n\t\t{\n//\t\t\tputchar(10);\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",f[j][k],k==m?'\\n':' ');\n\t\t\tfr(j,0,m+1) fr(k,0,m) F[j][k]=0;\n\t\t\tfr(j,0,m+1) fr(k,0,m){ Add(F[std::min(j,m)][k],f[j][k]); f[j][k]=0; }\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",F[j][k],k==m?'\\n':' ');\n\t\t\tfr(j,0,m) fr(k,0,m) fr(A,0,a[i]) fr(B,0,b[i])\n\t\t\t{\n\t\t\t\tif(A&&B) Add(f[j+1][std::max(j,k)+1],F[j][k]);\n\t\t\t\tif(A&&!B) Add(f[j+1][0],F[j][k]);\n\t\t\t\tif(!A&&B) Add(f[0][k?k+1:0],F[j][k]);\n\t\t\t\tif(!A&&!B) Add(f[0][0],F[j][k]);\n\t\t\t}\n//\t\t\tprintf(\"%d  %d %d\\n\",i,a[i],b[i]);\n//\t\t\tfr(j,0,m+1) fr(k,0,m) printf(\"%I64d%c\",f[j][k],k==m?'\\n':' ');\n\t\t}\n\t\tfr(i,0,m+1) fr(j,0,m) Add(ans,f[i][j]);\n\t\treturn ans;\n\t}\n}\nint main()\n{\n\tn=read(); m=read(); mod=read();\n\tif(m%2==0) printf(\"%d\\n\",int(m2::main(n/2)*m2::main((n+1)/2)%mod));\n\telse printf(\"%d\\n\",int(m1::main(n)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for (int i = l; i <= r; i++)\n#define ford(i, r, l) for (int i = r; i >= l; i--)\n\nint mod = 1;\nvoid Inc(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\nvoid Dec(int &x, int y) { x -= y, x += x < 0 ? mod : 0; }\nint inc(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\nint dec(int x, int y) { return x < y ? x - y + mod : x - y; }\nint mul(int x, int y) { return 1LL * x * y % mod; }\nint fastpow(int base, int x) {\n  int res = 1;\n  while (x) {\n    if (x & 1) res = mul(res, base);\n    base = mul(base, base), x >>= 1;\n  }\n  return res;\n}\n\nconst int maxn = 155;\nint N, M;\n\nnamespace work_1 {\nint f[maxn];\nvoid solve() {\n  M >>= 1, f[0] = 1;\n  foru(i, 1, N) foru(j, max(0, i - M - 1), i - 1) Inc(f[i], f[j]);\n  int Ans_1 = 0, Ans_2 = 0;\n  foru(i, max(0, (N >> 1) - M), (N >> 1)) Inc(Ans_1, f[i]);\n  foru(i, max(0, ((N + 1) >> 1) - M), ((N + 1) >> 1)) Inc(Ans_2, f[i]);\n  printf(\"%d\\n\", mul(Ans_1, Ans_2));\n}\n}  // namespace work_1\n\nnamespace work_2 {\nint f[maxn][maxn][maxn];\nvoid solve() {\n  f[0][0][0] = 1;\n  foru(i, 1, ((N + M) >> 1)) {\n    foru(j, 0, M + 1) foru(k, 0, N) Inc(f[i][0][0], f[i - 1][j][k]);\n    if (i + i <= N)\n      foru(j, 0, M + 1) foru(k, 0, N) Inc(f[i][0][k + 1], f[i - 1][j][k]);\n    if (i + i - M >= 1)\n      foru(j, 0, M) foru(k, 0, N) Inc(f[i][j + (j > 0)][0], f[i - 1][j][k]);\n    int tmp = 0;\n    if (i + i <= N && i + i - M >= 1)\n      foru(j, 0, M) foru(k, 0, N) if ((tmp = max(j + 1, k + 2)) <= M + 1)\n          Inc(f[i][tmp][k + 1], f[i - 1][j][k]);\n  }\n  int Ans = 0;\n  foru(j, 0, M + 1) foru(k, 0, N) Inc(Ans, f[(N + M) >> 1][j][k]);\n  printf(\"%d\\n\", Ans);\n}\n}  // namespace work_2\n\nint main() {\n  scanf(\"%d%d%d\", &N, &M, &mod);\n  if(M & 1) work_2::solve();\n  else work_1::solve();\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.fill;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= mod ? res - mod : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % mod);\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic int mod;\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt(), k = scanInt();\n\t\tmod = scanInt();\n\t\tif (k % 2 == 0) {\n\t\t\tout.print(mul(solve2(n / 2, k / 2 + 1), solve2((n + 1) / 2, k / 2 + 1)));\n\t\t} else {\n\t\t\tint dyn[][] = new int[k + 2][k + 2];\n\t\t\tdyn[0][0] = 1;\n\t\t\tint ndyn[][] = new int[k + 2][k + 2];\n\t\t\tfor (int i = 0; i < (n | 1) / 2 + k / 2 + 2; i++) {\n\t\t\t\tfor (int a[]: ndyn) {\n\t\t\t\t\tfill(a, 0);\n\t\t\t\t}\n\t\t\t\tint mask = (i < (n + 1) / 2 ? 1 : 0) + (i >= k / 2 + 2 ? 2 : 0);\n\t\t\t\tfor (int m = mask;; m = (m - 1) & mask) {\n\t\t\t\t\tfor (int j = 0; j < k + 2; j++) {\n\t\t\t\t\t\tfor (int jj = 0; jj < k + 2; jj++) {\n\t\t\t\t\t\t\tint nj = (m & 1) != 0 ? min(j + 1, k + 1) : 0;\n\t\t\t\t\t\t\tint njj = (m & 2) != 0 && (j != 0 || jj != 0) ? max(j, jj) + 1 : 0;\n\t\t\t\t\t\t\tif (nj < k + 2 && njj < k + 2) {\n\t\t\t\t\t\t\t\tndyn[nj][njj] = add(ndyn[nj][njj], dyn[j][jj]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (m == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint t[][] = dyn;\n\t\t\t\tdyn = ndyn;\n\t\t\t\tndyn = t;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < k + 2; i++) {\n\t\t\t\tfor (int j = 0; j < k + 2; j++) {\n\t\t\t\t\tans = add(ans, dyn[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.print(ans);\n\t\t}\n\t}\n\n\tstatic int solve2(int n, int k) {\n\t\tint dyn[] = new int[k];\n\t\tfill(dyn, 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint v = dyn[k - 1];\n\t\t\tfor (int j = k - 2; j >= 0; j--) {\n\t\t\t\tdyn[j + 1] = add(dyn[j], v);\n\t\t\t}\n\t\t\tdyn[0] = v;\n\t\t}\n\t\treturn dyn[k - 1];\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dunkelheit\" version=\"1.0.1\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner, dkh.modint;\n\n/*\nint l;\nlong mod;\n\nlong calc(int n, int a, int b, int c, int d) {\n    assert(c >= 0 && d >= 0);\n    assert(c == 0 || d == 0);\n    if (n == 0) return 1;\n    long ans = 0;\n    // off\n    {\n        int nc = d;\n        if (a && b >= l + 1) {            \n            assert(a >= 1 && l - a >= 1);\n            nc = (nc == 0) ? l - a : min(nc, l - a);\n        }\n        ans = (ans + calc(n - 1, b, 0, nc, 0)) % mod;\n    }\n\n    // on\n    if (c != 1 && (a < l || b < l)) {\n        ans = (ans + calc(n - 1, b, a + 1, d, max(0, c - 1))) % mod;\n    }\n\n    return ans;\n}*/\n\nalias Mint = DModInt!\"dummy\";\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) assert(!sc.hasNext);\n\n    int n, k;\n    sc.read(n, k, Mint.MD);\n    int l = k / 2 + 1;\n\n    if (k % 2 == 0) {\n        Mint[] dp = new Mint[n / 2 + 5];\n        dp[0] = Mint(1);\n        foreach (i; 1 .. n / 2 + 5) {\n            foreach (j; max(0, i - l) .. i) {\n                dp[i] += dp[j];\n            }\n        }\n        writeln(dp[n / 2 + 1] * dp[(n + 1) / 2 + 1]);\n        return 0;\n    }\n\n    //writeln(calc(n, 0, 0, 0, 0));\n\n\n    //long[][][][] dp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);    \n    //dp[0][0][0][0] = 1;\n\n    int to_i(int a, int b, int c, int d) {\n        if (d == 0) return a * 80 * 80 + b * 80 + c;\n        else return (a * 80 * 80 + b * 80 + d) + 80 * 80 * 80;\n        assert(false);\n//        return a * 80 * 80 * 80 + b * 80 * 80 + c * 80 + d;\n    }\n\n    Mint[] dp = new Mint[2 * 80 * 80 * 80];\n    dp[0] = Mint(1);\n    Mint[] ndp = new Mint[2 * 80 * 80 * 80];\n    foreach (_n; 0..n) {\n        //long[][][][] ndp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);        \n        ndp[] = Mint(0);\n/*        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    ndp[to_i(a, b, c, 0)].v = 0;\n                }\n                foreach (d; 1..l + 1) {\n                    ndp[to_i(a, b, 0, d)].v = 0;\n                }\n            }\n        }*/\n        void calc(int a, int b, int c, int d) {\n            int idx = to_i(a, b, c, d);\n            if (dp[idx].v == 0) return;\n            // off\n            {\n                int nc = d;\n                if (a && b >= l + 1) {            \n                    assert(a >= 1 && l - a >= 1);\n                    nc = (nc == 0) ? l - a : min(nc, l - a);\n                }\n                int nidx = to_i(b, 0, nc, 0);\n                ndp[nidx] += dp[idx];\n            }\n\n            // on\n            if (c != 1 && (a < l || b < l)) {\n                int nidx = to_i(b, a+1, d, max(0, c-1));\n                ndp[nidx] += dp[idx];\n            }\n        }\n        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    calc(a, b, c, 0);\n                }\n                foreach (d; 1..l + 1) {\n                    calc(a, b, 0, d);\n                }\n            }\n        }\n        swap(dp, ndp);\n        //dp = ndp;\n    }\n\n    writeln(dp.sum);\n//    writeln(dp.map!(v => v.map!(v => v.map!(v => v.sum % mod).sum % mod).sum % mod).sum % mod);\n    return 0;\n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/modint.d */\n// module dkh.modint;\n\n// import dkh.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n     \n    auto opBinary(string op:\"^^\", T)(T r) const {return pow(this, r, ModInt(1));}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return x^^(MD-2);};\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(T : DModInt!S, string S);\n}\n\n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/numeric/primitive.d */\n// module dkh.numeric.primitive;\n\nimport std.traits, std.bigint;\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        m >>= 1;\n    }\n    return r % md;\n}\n\n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n\n \nT invMod(T)(T x, T md) {\n    auto r = extGcd!T(x, md);\n    assert(r[2] == 1);\n    auto z = r[0];\n    return (z % md + md) % md;\n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    private File f;\n     \n    this(File f) {\n        this.f = f;\n    }\n    private char[512] lineBuf;\n    private char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    assert(succW());\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n     \n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n     \n    void read(Args...)(auto ref Args args) {\n        import std.exception : enforce;\n        static if (args.length != 0) {\n            enforce(readSingle(args[0]));\n            read(args[1..$]);\n        }\n    }\n     \n    bool hasNext() {\n        return succ();\n    }\n}\n\n\n \n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dunkelheit\" version=\"1.0.1\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n/*\nint l;\nlong mod;\n\nlong calc(int n, int a, int b, int c, int d) {\n    assert(c >= 0 && d >= 0);\n    assert(c == 0 || d == 0);\n    if (n == 0) return 1;\n    long ans = 0;\n    // off\n    {\n        int nc = d;\n        if (a && b >= l + 1) {            \n            assert(a >= 1 && l - a >= 1);\n            nc = (nc == 0) ? l - a : min(nc, l - a);\n        }\n        ans = (ans + calc(n - 1, b, 0, nc, 0)) % mod;\n    }\n\n    // on\n    if (c != 1 && (a < l || b < l)) {\n        ans = (ans + calc(n - 1, b, a + 1, d, max(0, c - 1))) % mod;\n    }\n\n    return ans;\n}*/\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) assert(!sc.hasNext);\n\n    int n, k;\n    long mod;\n    sc.read(n, k, mod);\n    int l = k / 2 + 1;\n\n    if (k % 2 == 0) {\n        long[] dp = new long[n / 2 + 5];\n        dp[0] = 1;\n        foreach (i; 1 .. n / 2 + 5) {\n            foreach (j; max(0, i - l) .. i) {\n                dp[i] += dp[j];\n                dp[i] %= mod;\n            }\n        }\n        writeln(dp[n / 2 + 1] * dp[(n + 1) / 2 + 1] % mod);\n        return 0;\n    }\n\n    //writeln(calc(n, 0, 0, 0, 0));\n\n    long[][][][] dp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);\n    dp[0][0][0][0] = 1;\n\n    foreach (_n; 0..n) {\n        long[][][][] ndp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);        \n        void calc(int a, int b, int c, int d) {\n            if (dp[a][b][c][d] == 0) return;\n            // off\n            {\n                int nc = d;\n                if (a && b >= l + 1) {            \n                    assert(a >= 1 && l - a >= 1);\n                    nc = (nc == 0) ? l - a : min(nc, l - a);\n                }\n                ndp[b][0][nc][0] += dp[a][b][c][d];\n                ndp[b][0][nc][0] %= mod;\n            }\n\n            // on\n            if (c != 1 && (a < l || b < l)) {\n                ndp[b][a+1][d][max(0, c - 1)] += dp[a][b][c][d];\n                ndp[b][a+1][d][max(0, c - 1)] %= mod;\n            }\n        }\n        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    calc(a, b, c, 0);\n                }\n                foreach (d; 1..l + 1) {\n                    calc(a, b, 0, d);\n                }\n            }\n        }\n        dp = ndp;\n    }\n\n    writeln(dp.map!(v => v.map!(v => v.map!(v => v.sum % mod).sum % mod).sum % mod).sum % mod);\n    return 0;\n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    private File f;\n     \n    this(File f) {\n        this.f = f;\n    }\n    private char[512] lineBuf;\n    private char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    assert(succW());\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n     \n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n     \n    void read(Args...)(auto ref Args args) {\n        import std.exception : enforce;\n        static if (args.length != 0) {\n            enforce(readSingle(args[0]));\n            read(args[1..$]);\n        }\n    }\n     \n    bool hasNext() {\n        return succ();\n    }\n}\n\n\n \n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dunkelheit\" version=\"1.0.1\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n/*\nint l;\nlong mod;\n\nlong calc(int n, int a, int b, int c, int d) {\n    assert(c >= 0 && d >= 0);\n    assert(c == 0 || d == 0);\n    if (n == 0) return 1;\n    long ans = 0;\n    // off\n    {\n        int nc = d;\n        if (a && b >= l + 1) {            \n            assert(a >= 1 && l - a >= 1);\n            nc = (nc == 0) ? l - a : min(nc, l - a);\n        }\n        ans = (ans + calc(n - 1, b, 0, nc, 0)) % mod;\n    }\n\n    // on\n    if (c != 1 && (a < l || b < l)) {\n        ans = (ans + calc(n - 1, b, a + 1, d, max(0, c - 1))) % mod;\n    }\n\n    return ans;\n}*/\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) assert(!sc.hasNext);\n\n    int n, k;\n    long mod;\n    sc.read(n, k, mod);\n    int l = k / 2 + 1;\n\n    if (k % 2 == 0) {\n        long[] dp = new long[n / 2 + 5];\n        dp[0] = 1;\n        foreach (i; 1 .. n / 2 + 5) {\n            foreach (j; max(0, i - l) .. i) {\n                dp[i] += dp[j];\n                dp[i] %= mod;\n            }\n        }\n        writeln(dp[n / 2 + 1] * dp[(n + 1) / 2 + 1] % mod);\n        return 0;\n    }\n\n    //writeln(calc(n, 0, 0, 0, 0));\n\n\n    //long[][][][] dp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);    \n    //dp[0][0][0][0] = 1;\n\n    int to_i(int a, int b, int c, int d) {\n        return a * 80 * 80 * 80 + b * 80 * 80 + c * 80 + d;\n    }\n\n    long[] dp = new long[80 * 80 * 80 * 80];\n    dp[0] = 1;\n    long[] ndp = new long[80 * 80 * 80 * 80];\n    foreach (_n; 0..n) {\n        //long[][][][] ndp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);        \n        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    ndp[to_i(a, b, c, 0)] = 0;\n                }\n                foreach (d; 1..l + 1) {\n                    ndp[to_i(a, b, 0, d)] = 0;\n                }\n            }\n        }\n        void calc(int a, int b, int c, int d) {\n            if (dp[to_i(a, b, c, d)] == 0) return;\n            // off\n            {\n                int nc = d;\n                if (a && b >= l + 1) {            \n                    assert(a >= 1 && l - a >= 1);\n                    nc = (nc == 0) ? l - a : min(nc, l - a);\n                }\n                ndp[to_i(b, 0, nc, 0)] += dp[to_i(a, b, c, d)];\n                ndp[to_i(b, 0, nc, 0)] %= mod;\n            }\n\n            // on\n            if (c != 1 && (a < l || b < l)) {\n                ndp[to_i(b, a+1, d, max(0, c - 1))] += dp[to_i(a, b, c, d)];\n                ndp[to_i(b, a+1, d, max(0, c - 1))] %= mod;\n            }\n        }\n        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    calc(a, b, c, 0);\n                }\n                foreach (d; 1..l + 1) {\n                    calc(a, b, 0, d);\n                }\n            }\n        }\n        swap(dp, ndp);\n        //dp = ndp;\n    }\n\n    writeln(dp.sum % mod);\n//    writeln(dp.map!(v => v.map!(v => v.map!(v => v.sum % mod).sum % mod).sum % mod).sum % mod);\n    return 0;\n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    private File f;\n     \n    this(File f) {\n        this.f = f;\n    }\n    private char[512] lineBuf;\n    private char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    assert(succW());\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n     \n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n     \n    void read(Args...)(auto ref Args args) {\n        import std.exception : enforce;\n        static if (args.length != 0) {\n            enforce(readSingle(args[0]));\n            read(args[1..$]);\n        }\n    }\n     \n    bool hasNext() {\n        return succ();\n    }\n}\n\n\n \n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dunkelheit\" version=\"1.0.1\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner, dkh.modint;\n\n/*\nint l;\nlong mod;\n\nlong calc(int n, int a, int b, int c, int d) {\n    assert(c >= 0 && d >= 0);\n    assert(c == 0 || d == 0);\n    if (n == 0) return 1;\n    long ans = 0;\n    // off\n    {\n        int nc = d;\n        if (a && b >= l + 1) {            \n            assert(a >= 1 && l - a >= 1);\n            nc = (nc == 0) ? l - a : min(nc, l - a);\n        }\n        ans = (ans + calc(n - 1, b, 0, nc, 0)) % mod;\n    }\n\n    // on\n    if (c != 1 && (a < l || b < l)) {\n        ans = (ans + calc(n - 1, b, a + 1, d, max(0, c - 1))) % mod;\n    }\n\n    return ans;\n}*/\n\nalias Mint = DModInt!\"dummy\";\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) assert(!sc.hasNext);\n\n    int n, k;\n    sc.read(n, k, Mint.MD);\n    int l = k / 2 + 1;\n\n    if (k % 2 == 0) {\n        Mint[] dp = new Mint[n / 2 + 5];\n        dp[0] = Mint(1);\n        foreach (i; 1 .. n / 2 + 5) {\n            foreach (j; max(0, i - l) .. i) {\n                dp[i] += dp[j];\n            }\n        }\n        writeln(dp[n / 2 + 1] * dp[(n + 1) / 2 + 1]);\n        return 0;\n    }\n\n    //writeln(calc(n, 0, 0, 0, 0));\n\n\n    //long[][][][] dp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);    \n    //dp[0][0][0][0] = 1;\n\n    int to_i(int a, int b, int c, int d) {\n        return a * 80 * 80 * 80 + b * 80 * 80 + c * 80 + d;\n    }\n\n    Mint[] dp = new Mint[80 * 80 * 80 * 80];\n    dp[0] = Mint(1);\n    Mint[] ndp = new Mint[80 * 80 * 80 * 80];\n    foreach (_n; 0..n) {\n        //long[][][][] ndp = new long[][][][](n / 2 + 2, n / 2 + 2, l + 1, l + 1);        \n        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    ndp[to_i(a, b, c, 0)].v = 0;\n                }\n                foreach (d; 1..l + 1) {\n                    ndp[to_i(a, b, 0, d)].v = 0;\n                }\n            }\n        }\n        void calc(int a, int b, int c, int d) {\n            int idx = to_i(a, b, c, d);\n            if (dp[idx].v == 0) return;\n            // off\n            {\n                int nc = d;\n                if (a && b >= l + 1) {            \n                    assert(a >= 1 && l - a >= 1);\n                    nc = (nc == 0) ? l - a : min(nc, l - a);\n                }\n                int nidx = to_i(b, 0, nc, 0);\n                ndp[nidx] += dp[idx];\n            }\n\n            // on\n            if (c != 1 && (a < l || b < l)) {\n                int nidx = to_i(b, a+1, d, max(0, c-1));\n                ndp[nidx] += dp[idx];\n            }\n        }\n        foreach (a; 0..n/2 + 2) {\n            foreach (b; 0..n/2 + 2) {\n                foreach (c; 0..l + 1) {\n                    calc(a, b, c, 0);\n                }\n                foreach (d; 1..l + 1) {\n                    calc(a, b, 0, d);\n                }\n            }\n        }\n        swap(dp, ndp);\n        //dp = ndp;\n    }\n\n    writeln(dp.sum);\n//    writeln(dp.map!(v => v.map!(v => v.map!(v => v.sum % mod).sum % mod).sum % mod).sum % mod);\n    return 0;\n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/modint.d */\n// module dkh.modint;\n\n// import dkh.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n     \n    auto opBinary(string op:\"^^\", T)(T r) const {return pow(this, r, ModInt(1));}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return x^^(MD-2);};\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(T : DModInt!S, string S);\n}\n\n \nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\n \nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/numeric/primitive.d */\n// module dkh.numeric.primitive;\n\nimport std.traits, std.bigint;\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        m >>= 1;\n    }\n    return r % md;\n}\n\n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n\n \nT invMod(T)(T x, T md) {\n    auto r = extGcd!T(x, md);\n    assert(r[2] == 1);\n    auto z = r[0];\n    return (z % md + md) % md;\n}\n\n \n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Programs/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    private File f;\n     \n    this(File f) {\n        this.f = f;\n    }\n    private char[512] lineBuf;\n    private char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    assert(succW());\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n     \n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n     \n    void read(Args...)(auto ref Args args) {\n        import std.exception : enforce;\n        static if (args.length != 0) {\n            enforce(readSingle(args[0]));\n            read(args[1..$]);\n        }\n    }\n     \n    bool hasNext() {\n        return succ();\n    }\n}\n\n\n \n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nN, K, M = map(int, input().split(\" \"))\nall_set = set()\nseq = [i for i in range(1, N+1)]\nall_set.add(tuple(seq))\nfor i in range(1, N+1):\n  l_ls = list(itertools.permutations(seq,i))\n  for l_tp in l_ls:\n    t = set([i for i in range(-1, N+K+1)])\n    for l in l_tp:\n      t.remove(l)\n      t.add(l-2)\n      t.add(l+K)\n\n    all_set.add(tuple(sorted(list(t))))\n\nprint(len(all_set) % M)"
  },
  {
    "language": "Python",
    "code": "N, K, M = map(int, input().split())\n# limitの最大値（limitなし）\nL = (N+1)//2+1\n\ndef even(n, k) :\n    # dp[iまでみた][前のj個が連続]\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(n) :\n        for j in range(k + 1) :\n            dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % M\n            # 直前にK個連続しているときは追加できない\n            if j != k :\n                dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % M\n    \n    return sum(dp[n]) % M\n\ndef loop(x, y) :\n    return (2*x >= K+1 and 2*y >= K+3)\n  \nif K % 2 == 0 :\n    print(even(N//2, K//2) * even((N+1)//2, K//2) % M)\n    \nelse :\n    # dp[x][y][z]\n    # iとパリティが異なる列がx個連続、iとパリティが同じ列がy個連続でかつxとyのどちらかをzまで伸ばせる組み合わせ\n    dp0 = [[[0]*(L+1) for _ in range(L+1)] for _ in range(L+1)]\n    dp0[0][0][L] = 1\n    \n    for i in range(N) :\n        dp1 = [[[0]*(L+1) for _ in range(L+1)] for _ in range(L+1)]\n        for x in range(L+1) :\n            for y in range(L+1) :\n                if loop(x, y) : continue\n                for z in range(max(x, y)+1, L+1) :\n                    if dp0[x][y][z] == 0 :\n                        continue\n                    dp1[y][x+1][z] += dp0[x][y][z]\n                    dp1[y][x+1][z] %= M\n                    # zの更新\n                    # (1) y > x のときはzを引き継ぎ y <= x のときはLにリセット\n                    # (2) ↖ みたいな矢印が引ける時 つまり 2*y >= K+3 and x > 0の時 \n                    # y - x + K//2 + 1 と (1)との最小値に更新\n                    if y > x :\n                        zz = z\n                    else :\n                        zz = L\n                    if 2*y >= K+3 and x > 0 :\n                        zz = min(zz, 1+y-x+K//2)\n                    dp1[y][0][zz] += dp0[x][y][z]\n                    dp1[y][0][zz] %= M\n        dp0 = dp1\n    \n    ret = 0\n    for x in range(L+1) :\n        for y in range(L+1) :\n            if loop(x, y) : continue\n            for z in range(max(x, y)+1, L+1) :\n                ret += dp0[x][y][z]\n                ret %= M\n                    \n    print(ret)"
  }
]