[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\ndouble max(double x, double y){\n\tif(x > y)\n\t\treturn x;\n\telse\n\t\treturn y;\n}\ndouble min(double x, double y){\n\tif(x < y)\n\t\treturn x;\n\telse\n\t\treturn y;\n}\n\nstruct sphere{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\n\ndouble dist(double x,double y,double z){\n\treturn sqrt(x * x + y * y + z * z);\n}\n\nint main(void){\n\tint n, i, j, f[100], v;\n\tstruct sphere s[100];\n\tdouble mincost[100], ans;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n) break;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%lf%lf%lf%lf\",&s[i].x,&s[i].y,&s[i].z,&s[i].r);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tmincost[i] = 0x3FFFFFFF;\n\t\tmincost[0] = 0;\n\t\tans = 0;\n\t\tmemset(f,0,sizeof(f));\n\t\twhile(1){\n\t\t\tv = -1;\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t\tif(!f[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n\t\t\tif(v == -1) break;\n\t\t\tans += mincost[v];\n\t\t\tf[v] = 1;\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t\tmincost[i] = min(mincost[i],(max(dist(s[v].x - s[i].x,s[v].y - s[i].y,s[v].z - s[i].z) - (s[v].r + s[i].r),0)));\n\t\t}\n\t\tprintf(\"%.3f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define all(x) (x).begin(),(x).end()\nusing ll = long long;\nusing P = pair<int, int>;\nstring char_to_string(char val) {\n  return string(1, val);\n}\nint char_to_int(char val) {\n  return val - '0';\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nint vector_finder(std::vector<ll> vec, int number) {\n  auto itr = std::find(vec.begin(), vec.end(), number);\n  size_t index = std::distance( vec.begin(), itr );\n  if (index != vec.size()) { // 発見できたとき\n    return 1;\n  }\n  else { // 発見できなかったとき\n    return 0;\n  }\n}\ntemplate<typename T>\nstruct edge {\n    int from, to; // クラスカル法に限って、fromもedgeに含めるといい\n    T cost;\n};\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) { }\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\ntemplate<typename T>\nT kruskal(vector<edge<T>> &edges, int V) {\n    sort(edges.begin(), edges.end(), [](const edge<T> &a, const edge<T> &b) {\n        return a.cost < b.cost;\n    });\n    UnionFind unionFind(V);\n    T res = 0;\n    for (edge<T> &e: edges) {\n        if (unionFind.merge(e.to, e.from)) {\n            res += e.cost;\n        }\n    }\n    return res;\n}\nint n;\nvector<double> x, y, z, r;\nint main() {\n  vector<double> ans;\n  while(true) {\n    cin >> n;\n    if(n == 0) break;\n    x.resize(n); y.resize(n); z.resize(n); r.resize(n);\n    REP(i, n) {\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    vector<vector<double>> cost(n, vector<double>(n, 0.0));\n    for(int i = 0; i < n; ++i) {\n      for(int k = i; k < n; ++k) {\n        if(i == k) continue;\n        double line = sqrt(pow(x[i] - x[k], 2) + pow(y[i] - y[k], 2) + pow(z[i] - z[k], 2)) - r[i] - r[k];\n        if(0 <= line) cost[i][k] = line;\n        else cost[i][k] = 0;\n      }\n    }\n    vector<edge<double>> tree;\n    for(int i = 0; i < n; ++i) {\n      for(int k = i; k < n; ++k) {\n        edge<double> tmp; tmp.from = i; tmp.to = k; tmp.cost = cost[i][k];\n        tree.push_back(tmp);\n      }\n    }\n    ans.push_back(kruskal(tree, n));\n  }\n  REP(i, ans.size()) {\n    cout << fixed << setprecision(3) << ans[i] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <assert.h>\n#include <iomanip>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define IS_BIT_ON(bit, i) (bit & (1 << i))\n#define BIT_ON(bit, i) (bit | (1 << i))\n#define BIT_OFF(bit, i) (bit & ~(1 << i))\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\nvoid print() { std::cout << std::endl; }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << \" \";} }std::cout << std::endl;}\ntemplate <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nstruct Edge {\n    int no;\n    int from;\n    int to;\n    double cost;\n    Edge() {}\n    Edge(int from, int to, double cost) : from(from), to(to), cost(cost) {}\n    Edge(int no, int from, int to, double cost) : no(no), from(from), to(to), cost(cost) {}\n    bool operator<(const Edge& edge) const {\n        return this->cost < edge.cost;\n    }\n    bool operator>(const Edge& edge) const {\n        return this->cost > edge.cost;\n    }\n};\n\nclass UnionFind {\npublic:\n    vector<int> parent;\n    vector<int> setSize;\n\n    UnionFind(unsigned int size) {\n        parent.resize(size + 1);\n        iota(parent.begin(), parent.end(), 0);\n        setSize.resize(size + 1, 1);\n    }\n\n    // xとyが同じ集合に属するか\n    bool isSameSet(int x, int y) {\n        return findRoot(x) == findRoot(y);\n    }\n\n    // xとyの属する集合を併合\n    void unionSet(int x, int y) {\n        x = findRoot(x);\n        y = findRoot(y);\n        if (x == y) { return; }\n\n        parent[x] = y;\n        setSize[y] += setSize[x];\n    }\n\nprivate:\n    // 木の根を求める\n    int findRoot(int x) {\n        if (parent[x] == x) {\n            return x;\n        }\n        else {\n            return parent[x] = findRoot(parent[x]);\n        }\n    }\n};\n\n/**\n * グラフの最小全域木を求める。O(|E| log|V|)\n * @param num_of_node ノード数\n * @param edges　エッジ　無向グラフならu -> vとv -> uの両方向入れる\n * @return\n */\ndouble kruskal(int num_of_node, vector<Edge> &edges) {\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(num_of_node);\n    double ans = 0;\n    for (const auto e : edges) {\n        if (!uf.isSameSet(e.from, e.to)) {\n            uf.unionSet(e.from, e.to);\n            ans += e.cost;\n        }\n    }\n\n    return ans;\n}\n\n\ntemplate<class T> class Distance {\npublic:\n    static T euclidean_distance_2d(T x1, T y1, T x2, T y2) {\n        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    static T euclidean_distance_3d(T x1, T y1, T z1, T x2, T y2, T z2) {\n        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        LL N;\n        cin >> N;\n\n        if (N == 0) {\n            return 0;\n        }\n\n        auto c = make_v<tuple<double, double, double, double>>(N);\n        FOR(i, 0, N) {\n            double X, Y, Z, R;\n            cin >> X >> Y >> Z >> R;\n            c[i] = make_tuple(X, Y, Z, R);\n        }\n\n        auto edges = make_v<Edge>(0);\n        FOR(i, 0, N) {\n            FOR(j, 0, N) {\n                if (i == j) {\n                    continue;\n                }\n                double X1, Y1, Z1, R1, X2, Y2, Z2, R2;\n                tie(X1, Y1, Z1, R1) = c[i];\n                tie(X2, Y2, Z2, R2) = c[j];\n\n                double cost = Distance<double>::euclidean_distance_3d(X1, Y1, Z1, X2, Y2, Z2);\n                cost -= (R1 + R2);\n                edges.emplace_back(Edge(i, j, max(0.0, cost)));\n            }\n        }\n\n        cout << fixed << setprecision(3) << kruskal(N, edges) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[300][300];\nchar field[200][200];\n\n#define MAX 10000\ntemplate<class TYPE>\nclass Prim{\nprivate:\n  struct Edge{int to;TYPE cost;};\n  static const int INF = 1e+9+7;\n  vector<Edge> G[MAX];\n  TYPE mincost[MAX];\n  bool used[MAX];\n  int N;\n  int m;\n\npublic:\n  // Prim(){\n  //   cin >> N >> m;\n  //   for(int i = 0;i < m;i++){\n  //     int p,q;\n  //     TYPE r;\n  //     cin >> p >> q >> r;\n  //     G[p].pb(Edge{q,r});\n  //     G[q].pb(Edge{p,r});\n  //   }\n  // }\n\n  Prim(int n,int l){\n    N = n;\n    m = l;\n  }\n\n  void in(int p,int q,TYPE r){\n    // cin >> p >> q >> r;\n    G[p].pb(Edge{q,r});\n    G[q].pb(Edge{p,r});\n  }\n\n  TYPE prim(){\n    TYPE res = 0;\n    for(int i = 0;i < N;i++){\n      mincost[i] = INF;\n      used[i] = false;\n    }\n    mincost[0] = (TYPE)0;\n    while(1){\n      int v = -1;\n      for(int i = 0;i < N;i++){\n        if(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n      }\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n      for(int i = 0;i < G[v].size();i++){\n        mincost[G[v][i].to] = min(mincost[G[v][i].to],G[v][i].cost);\n      }\n    }\n    return res;\n  }\n};\n\nnamespace Geometry{\n  #define equals(a,b) (fabs((a) - (b)) < EPS)\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n  #define gprint(X) cout << fixed << setprecision(8) << (X) << endl\n  #define gprints(X,Y) cout << fixed << setprecision(8) << (X) << \" \" << (Y) << endl\n  const double EPS = 1e-10;\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n  \n  class Point{\n  public:\n    double x,y;\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator += (Point p){ return Point(x += p.x,y += p.y); }\n    Point operator -= (Point p){ return Point(x -= p.x,y -= p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n    bool operator < (const Point &p) const{ return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (const Point &p) const{ return equals(x,p.x) && equals(y,p.y); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n    friend ostream& operator << (ostream &os,Point &p){ return os << p.x << \" \" << p.y; }\n    friend istream& operator >> (istream &is,Point &p){ return is >> p.x >> p.y; }\n  };\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &seg){ return os << seg.p1 << \" \" << seg.p2; }\n    friend istream& operator >> (istream &is,Segment &seg){ return is >> seg.p1 >> seg.p2; }\n  };\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){ return os << c.c << \" \" << c.r; }\n    friend istream& operator >> (istream &is,Circle &c){ return is >> c.c >> c.r; }\n  };\n\n  typedef Point Vector;\n  typedef Segment Line;\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){ return  a.x * a.x + a.y * a.y; }\n  double abs(Vector a){ return sqrt(norm(a)); }\n  double dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\n  double cross(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\n  bool Orthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\n  bool Orthogonal(Point a1,Point a2,Point b1,Point b2){ return Orthogonal(a1 - a2,b1 - b2); }\n  bool Orthogonal(Segment s1,Segment s2){ return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0); }\n  bool Parallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\n  bool Parallel(Point a1,Point a2,Point b1,Point b2){ return Parallel(a1 - a2 , b1 - b2); }\n  bool Parallel(Segment s1,Segment s2){ return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0); }\n  bool less(const Point &a,const Point &b){ return (a.x != b.x) ? a.x < b.x : a.y < b.y; }\n  bool greater(const Point &a,const Point b){ return !less(a,b); }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  int ccw(Point &p0,Point p1,Point p2){\n    p1 -= p0;\n    p2 -= p0;\n    if(cross(p1,p2) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(p1,p2) < -EPS)return CLOCKWISE;\n    if(dot(p1,p2) < -EPS)return ONLINE_BACK;\n    if(p1.norm() < p2.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n  bool intersect(Segment s1,Segment s2){ return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2); }\n\n  double getDistance(Vector a,Vector b){ return abs(a - b); }\n  double getDistanceLP(Line l,Point p){ return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1)); }\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){ return atan2(p.y,p.x); }\n  Vector polar(double a,double r){ return Point(cos(r) * a, sin(r) * a); }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n  \n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  //=====================================================//\n  //==================== Andrew Scan ====================//\n  //=====================================================//\n \n  int Accw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return 1;\n    return -1;\n  }\n \n  Polygon andrewScan(Polygon s){\n    Polygon ans;\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && Accw(u[n-2],u[n-1],s[i]) != -1;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n \n    for(int i = s.size() - 3;i >= 0;i--){\n      for(int n = l.size();n >= 2 && Accw(l[n-2],l[n-1],s[i]) != -1;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--){\n      l.push_back(u[i]);\n    }\n    int f = 0;\n    for(int i = 1;i < l.size();i++){\n      if(l[f].y > l[i].y || (l[f].y == l[i].y && l[f].x > l[i].x)){\n        f = i;\n      }\n    }\n    for(int i = 0;i < l.size();i++){\n      ans.push_back(Point((int)l[(i + f)%l.size()].x,(int)l[(i + f)%l.size()].y));\n    }\n    return ans;\n  }\n\n  //=====================================================//\n  //======================== END ========================//\n  //=====================================================//\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nclass Circle2{\npublic:\n  double x,y,z;\n  double r;\n  Circle2(double x = 0.0,double y = 0.0,double z = 0.0,double r = 0.0): x(z),y(y),z(z),r(r){}\n  friend istream& operator >> (istream &is,Circle2 &c){ return is >> c.x >> c.y >> c.z >> c.r; }\n};\n\nint main(){\n  while(cin >> n,n){\n    vector<Circle2> vec;\n    Prim<double> ans(n,n-1);\n    rep(i,0,n){\n      Circle2 a;\n      cin >> a;\n      vec.pb(a);\n    }\n    rep(i,0,n){\n      rep(j,i+1,n){\n        double distin = 0;\n        double dist1 = sqrt((vec[i].x - vec[j].x)*(vec[i].x - vec[j].x) + (vec[i].y - vec[j].y)*(vec[i].y - vec[j].y) + (vec[i].z - vec[j].z)*(vec[i].z - vec[j].z));\n        double dist2 = vec[i].r + vec[j].r;\n        if(dist1 > dist2)distin = dist1 - dist2;\n        // printf(\"%f , %f : %f\\n\",dist1,dist2,distin);\n        ans.in(i,j,distin);\n      }\n    }\n    cout << fixed << setprecision(8) << ans.prim() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct edge{int u,v;double cost;};\n\nint par[100000],rank[100000],V,E;\nedge es[100000];\n\nvoid init(int n){for(int i=0;i<n;i++){par[i]=i;rank[i]=0;}}\nint find(int x){if(par[x]==x)return x;else return find(par[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank[x]<rank[y])par[x]=y;else{par[y]=x;if(rank[x]==rank[y])rank[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n\nbool comp(const edge e1,const edge e2){return e1.cost<e2.cost;}\n\ndouble kruskal(){\n\tsort(es,es+E,comp);\n\tinit(V);\n\tdouble res=0;\n\trep(i,E){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble x[100],y[100],z[100],r[100];\n\nint main(){\n\twhile(cin>>V&&V){\n\t\tE=V*(V-1)/2;\n\t\trep(i,V)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tint cur=0;\n\t\trep(i,V)rep(j,V)if(i<j){es[cur].u=i;es[cur].v=j;es[cur++].cost=max(0.0,sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])+(z[j]-z[i])*(z[j]-z[i]))-r[i]-r[j]);}\n\t\tprintf(\"%.3f\\n\",kruskal());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<0)x=0;\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m;m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<fixed<<setprecision(3)<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])continue;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(5)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct UF\n{\n\tvector<int>v;\n\tUF():v(100,-1){};\n\tint R(int x){return v[x]<0?x:v[x]=R(v[x]);}\n\tint U(int x,int y)\n\t{\n\t\tx=R(x);\n\t\ty=R(y);\n\t\tif(x-y)\n\t\t{\n\t\t\tif(v[x]<v[y])swap(x,y);\n\t\t\tv[y]+=v[x];\n\t\t\tv[x]=y;\n\t\t}\n\t\treturn x-y;\n\t}\n};\ndouble F(double x){return x*x;}\nstruct S{double d;int a,b;S(double d,int a,int b):d(d),a(a),b(b){}bool operator<(const S&s)const{return d<s.d;}};\nint main()\n{\n\tint n,i,j;\n\tdouble x[100],y[100],z[100],r[100],d,res;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tvector<S>v;\n\t\tUF uf;\n\t\tfor(i=0;i<n;++i)scanf(\"%lf%lf%lf%lf\",x+i,y+i,z+i,r+i);\n\t\tfor(i=0;i<n;++i)for(j=i+1;j<n;++j)\n\t\t{\n\t\t\td=sqrt(F(x[i]-x[j])+F(y[i]-y[j])+F(z[i]-z[j]))-r[i]-r[j];\n\t\t\tif(d<0)uf.U(i,j);\n\t\t\telse v.push_back(S(d,i,j));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tres=0;\n\t\tfor(i=0;i<v.size();++i)\n\t\t{\n\t\t\tS s=v[i];\n\t\t\tif(uf.U(s.a,s.b))res+=s.d;\n\t\t}\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.IOException;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\tint[] par;\n\n\tclass Ball {\n\t\tdouble x, y, z;\n\t\tdouble r;\n\n\t\tBall(double x, double y, double z, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tdouble len;\n\t\tint x, y;\n\n\t\tEdge(double len, int x, int y) {\n\t\t\tthis.len = len;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (this.len - o.len > 0) return 1;\n\t\t\tif (this.len - o.len < 0) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble dist(Ball a, Ball b) {\n\t\tdouble res = 0;\n\t\tres = Math.hypot(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n\t\tres = Math.hypot(res, Math.abs(a.z - b.z));\n\t\treturn res;\n\t}\n\n\tboolean isTouching(Ball a, Ball b) {\n\t\treturn dist(a, b) < a.r + b.r;\n\t}\n\n\tvoid union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tpar[x] = y;\n\t}\n\n\tboolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn root(par[x]);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBall[] b = new Ball[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tb[i] = new Ball(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\n\t\t\tpar = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\n\t\t\tList<Edge> list = new LinkedList<Edge>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!isTouching(b[i], b[j])) {\n\t\t\t\t\t\tlist.add(new Edge(dist(b[i], b[j]) - b[i].r - b[j].r, i, j));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunion(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble sum = 0;\n\t\t\tCollections.sort(list);\n\t\t\tfor (Edge E: list) {\n\t\t\t\tif (!find(E.x, E.y)) {\n\t\t\t\t\tunion(E.x, E.y);\n\t\t\t\t\tsum += E.len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to;\n  double cost;\n  Edge() { }\n  Edge(int from_, int to_, double cost_) : from(from_), to(to_), cost(cost_) { }\n  bool operator <(const Edge &rhs) const {\n    return cost < rhs.cost;\n  }\n};\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int v) : data(v, -1) { };\n  int root(int x){\n  \treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n  }\n  bool same(int x, int y){\n  \treturn root(x) == root(y);\n  }\n  void merge(int x, int y){\n  \tx = root(x), y = root(y);\n  \tif(x != y){\n  \t\tif(size(y) > size(x)) swap(x, y);\n  \t\tdata[x] += data[y]; data[y] = x;\n  \t}\n  }\n  int size(int x){\n  \treturn -data[root(x)];\n  }\n};\n\ndouble kruskal(const int v, vector<Edge> es) {\n\tsort(es.begin(), es.end());\n\tdouble ans = 0;\n\tUnionFind uf(v);\n\tfor(int i = 0; i < es.size(); ++i) {\n\t\tif(uf.same(es[i].from, es[i].to)) continue;\n\t\tuf.merge(es[i].from, es[i].to);\n\t\tans += es[i].cost;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\twhile (cin>>n, n) {\n\t\tvector<double>x(n), y(n), z(n), r(n);\n\t\tvector<Edge> e;\n\t\t\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdouble d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\t\td -= r[i] + r[j];\n\t\t\t\t\td = max(0.0, d);\n\t\t\t\t\te.push_back(Edge(i, j, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout.setf(ios::fixed); cout.precision(10);\n\t\tcout << kruskal(n, e) << endl;\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\nconst double INF = 1e10;\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        vector<vector<double> > dis(n, vector<double>(n, INF));\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double tdis = pow(x[i] - x[j], 2.0) + pow(y[i] - y[j], 2.0) + pow(z[i] - z[j], 2.0);\n                tdis = sqrt(tdis) - r[i] - r[j];\n                if (tdis < 0.0) tdis = 0.0;\n                dis[i][j] = dis[j][i] = tdis;\n            }\n        }\n\n        priority_queue<P, vector<P>, greater<P> > que;\n        vector<bool> used(n, false);\n        double res = 0.0;\n        for (int i = 0; i < n; i++) {\n            que.push(P(dis[0][i], i));\n        }\n        used[0] = true;\n        while (que.size()) {\n            P p = que.top(); que.pop();\n\n            if (used[p.second]) continue;\n            res += p.first;\n            used[p.second] = true;\n            for (int i = 0; i < n; i++) {\n                que.push(P(dis[p.second][i], i));\n            }\n        }\n\n        printf(\"%.3f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nclass GeometryUtil {\n\tpublic:\n\t\tbool eql(double a, double b) { return abs(a - b) < EPS; }\n\t\tbool lt(double a, double b) { return b - a >= EPS; }\n\t\tbool lte(double a, double b) { return lt(a, b) || eql(a, b); }\n\t\tbool gt(double a, double b) { return !lte(a, b); }\n\t\tbool gte(double a, double b) { return !lt(a, b); }\n\t\tbool eql(P a, P b) { return eql(a.Y, b.Y) && eql(a.X, b.X); }\n\t\tGeometryUtil() {\n\t\t}\n};\n\nGeometryUtil geo = GeometryUtil();\n\ntemplate<typename T>\nclass Vector3D {\n\tpublic:\n\t\tT x, y, z;\n\t\tVector3D(T _x, T _y, T _z): x(_x), y(_y), z(_z) {\n\t\t}\n\n\t\tT abs() {\n\t\t\treturn sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n\t\t}\n\n\t\tT dot(Vector3D<T> rhs) {\n\t\t\treturn x * rhs.x + y * rhs.y + z * rhs.z;\n\t\t}\n\n\t\tVector3D<T> cross(Vector3D<T> rhs) {\n\t\t\treturn Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);\n\t\t}\n\n\t\t// check if this Vector3D (as a point) is on a line (a-b)\n\t\tbool is_upon(const Vector3D<T> a, const Vector3D<T> b) const {\n\t\t\tdump((b-a).cross(b-(*this)).abs());\n\t\t\tdump(geo.eql((b-a).cross(b-(*this)).abs(), 0));\n\t\t\tdump((b-a).dot((*this)-a));\n\t\t\tdump(geo.gt( (b-a).dot((*this)-a), 0 ));\n\t\t\tdump((a-b).dot((*this)-b));\n\t\t\tdump(geo.gt( (a-b).dot((*this)-b), 0 ));\n\n\t\t\treturn geo.eql( (b-a).cross(b-(*this)).abs(), 0 ) &&\n\t\t\t\tgeo.gt( (b-a).dot((*this)-a), 0 ) &&\n\t\t\t\tgeo.gt( (a-b).dot((*this)-b), 0 );\n\t\t}\n\n\t\t// Add vector\n\t\tVector3D<T> operator+(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x + rhs.x, y + rhs.y, z + rhs.z);\n\t\t}\n\n\t\t// Subtract vecrtor\n\t\tVector3D<T> operator-(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x - rhs.x, y - rhs.y, z - rhs.z);\n\t\t}\n\n\t\t// Multiply by scala value\n\t\ttemplate<typename Scala>\n\t\tVector3D<T> operator*(const Scala rhs) const {\n\t\t\treturn Vector3D<T>(x * rhs, y * rhs, z * rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Vector3D<T>& v) {\n\treturn out << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\";\n}\n\ntemplate<typename T>\nclass Sphere {\n\tpublic:\n\t\tT x, y, z, r;\n\t\tSphere(T _x, T _y, T _z, T _r) : x(_x), y(_y), z(_z), r(_r) {\n\t\t}\n\n\t\t// distance of the centers of spheres\n\t\tT distance(const Sphere& rhs) const {\n\t\t\t// move two spheres so that the center of (*this) comes to the origin\n\t\t\tSphere _r(rhs.x - x, rhs.y - y, rhs.z - z, rhs.r);\n\t\t\treturn Vector3D<T>(_r.x, _r.y, _r.z).abs();\n\t\t}\n\n\t\t// check if this sphere is completely inside of rhs\n\t\tbool is_inside_of(const Sphere& rhs) const {\n\t\t\treturn geo.lt(distance(rhs) + r, rhs.r);\n\t\t}\n\n\t\t// check if this sphere is completely outside of rhs\n\t\tbool is_outside_of(const Sphere& rhs) const {\n\t\t\treturn geo.gt(distance(rhs) - r, rhs.r);\n\t\t}\n\n\t\t// check if this sphere is touching with rhs\n\t\tbool is_touching_with(const Sphere& rhs) const {\n\t\t\treturn\n\t\t\t\tgeo.eql(distance(rhs), r + rhs.r) ||\n\t\t\t\t((*this).is_inside_of(rhs) && geo.eql(distance(rhs) + r, rhs.r)) ||\n\t\t\t\t(rhs.is_inside_of((*this)) && geo.eql(distance(rhs) + rhs.r, r));\n\t\t}\n\n\t\tbool is_overlapping_with(const Sphere& rhs) const {\n\t\t\treturn !is_inside_of(rhs) && !is_outside_of(rhs) && !is_touching_with(rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Sphere<T>& s) {\n\treturn out << \"(\" << s.x << \", \" << s.y << \", \" << s.z << \", \" << s.r << \")\";\n}\n\nclass UnionFindTree {\n\tint n;\n\tVI parent;\n\tpublic:\n\t\tUnionFindTree(int _n): n(_n) {\n\t\t\tparent = VI(n);\n\t\t\tREP (i, n) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tint group(int x) {\n\t\t\tif (parent[x] == x) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn parent[x] = group(parent[x]);\n\t\t\t}\n\t\t}\n\n\t\tbool united(int x, int y) {\n\t\t\treturn group(x) == group(y);\n\t\t}\n\n\t\tvoid unite(int x, int y) {\n\t\t\tx = group(x);\n\t\t\ty = group(y);\n\t\t\tparent[x] = y;\n\t\t}\n};\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tdump(n);\n\t\tvector< Sphere<double> > cells;\n\t\tREP (i, n) {\n\t\t\tdouble x, y, z, r; cin >> x >> y >> z >> r;\n\t\t\tcells.PB(Sphere<double>(x,y,z,r));\n\t\t}\n\t\tVVD costs(n, VD(n, INF));\n\t\tREP (i, n) {\n\t\t\tREP (j, n) {\n\t\t\t\tif (i == j) { costs[i][j] = costs[j][i] = 0; continue; }\n\t\t\t\tif (cells[i].is_touching_with(cells[j]) || cells[i].is_overlapping_with(cells[j])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = 0;\n\t\t\t\t} else if (cells[i].is_inside_of(cells[j])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = cells[j].r - cells[i].distance(cells[j]) - cells[i].r;\n\t\t\t\t} else if (cells[j].is_inside_of(cells[i])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = cells[i].r - cells[i].distance(cells[j]) - cells[j].r;\n\t\t\t\t} else {\n\t\t\t\t\t// outside of each other\n\t\t\t\t\tcosts[i][j] = costs[j][i] = cells[i].distance(cells[j]) - cells[i].r - cells[j].r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP (i, n) {\n\t\t\tREP (j, n) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tif (cells[i].is_inside_of(cells[j])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdumpl(costs);\n\n\t\tdouble ans = 0;\n\t\tUnionFindTree ut(n);\n\t\ttypedef pair<double, PII> PDPII;\n\t\tvector<PDPII> edges; // (cost, (from, to))\n\t\tREP (i, n) {\n\t\t\tFOR (j, i+1, n) {\n\t\t\t\tedges.PB(MP(costs[i][j], MP(i, j)));\n\t\t\t}\n\t\t}\n\t\tSORT(edges);\n\n\t\tREP (i, edges.size()) {\n\t\t\tdouble cost = edges[i].F;\n\t\t\tint from = edges[i].S.F;\n\t\t\tint to = edges[i].S.S;\n\t\t\tif (ut.united(from, to)) { continue; }\n\t\t\tut.unite(from, to);\n\t\t\tdump(from);\n\t\t\tdump(to);\n\t\t\tdump(cost);\n\t\t\tans += cost;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint n;\n\nstruct Celldata {\n    double x; double y; double z; double r;\n};\n\nstruct pqdata {\n    int from; int to; double corridor;\n    bool operator<(const pqdata &r) const { return corridor > r.corridor; }\n};\n\n// UnionFindの実装\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n\n    // 集合をマージする\n    // すでに同じ集合ならfalseが返る\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) return false;\n        //要素数の少ない方を多い方に繋げる\n        if(data.at(y) < data.at(x)) swap(x, y);\n        data.at(x) += data.at(y);\n        data.at(y) = x;\n        return true;\n    }\n\n    // ある要素がどの集合に属しているかを返す\n    int root(int x) {\n        // 根に直接つなぎ直す\n        return data.at(x) < 0 ? x : (data.at(x) = root(data.at(x)));\n    }\n\n    // ある集合の大きさを答える\n    int size(int x) {\n        return -data.at(root(x));\n    }\n\n    // ある二つの要素が同じ集合か判定\n    bool same(int x, int y) {\n        x = root(x); y = root(y);\n        return x == y;\n    }\n};\n\nint main() {\n    while(1) {\n        cin >> n;\n        if(n == 0) break;\n        vector<Celldata> cells(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> cells.at(i).x >> cells.at(i).y >> cells.at(i).z >> cells.at(i).r;\n        }\n        priority_queue<pqdata> pque;\n        UnionFind tree(n);\n        for(int i = 0; i < n; ++i) {\n            for(int j = i+1; j < n; ++j) {\n                pqdata indata;\n                indata.from = i; indata.to = j;\n                double xx = powl(cells.at(i).x-cells.at(j).x, 2);\n                double yy = powl(cells.at(i).y-cells.at(j).y, 2);\n                double zz = powl(cells.at(i).z-cells.at(j).z, 2);\n                double xyz = xx+yy+zz;\n                double len = sqrtl(xyz) - (cells.at(i).r+cells.at(j).r);\n                if(len <= 0.0) {\n                    tree.merge(i, j);\n                }else {\n                    indata.corridor = len;\n                    pque.push(indata);\n                }\n            }\n        }\n\n        double ans = 0.0;\n        while(!pque.empty()) {\n            pqdata now = pque.top();\n            pque.pop();\n            if(!tree.same(now.from, now.to)) {\n                ans += now.corridor;\n                tree.merge(now.from, now.to);\n            }\n        }\n\n        printf(\"%.3lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;scanf(\"%lf\",&a);return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    printf(\"%.3lf\\n\",prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\n\nstruct UnionFind {\n    vector<int> par; // 親を指すvector,-par[親]は木のサイズ\n    UnionFind(int n):par(n, -1) {} // uniteで親を埋め込んでいく必要あり\n    int root(int x) { // 親をたどる&データの整理\n        if(par[x] < 0) return x;\n        return par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) { // データの結合\n        x = root(x);\n        y = root(y);\n        if(x == y) return false;\n        if(par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    bool same(int x, int y) {return root(x) == root(y);} // 所属判定\n    int size(int x) {return -par[root(x)];} // 木のサイズ\n};\n\nstruct edge {\n    int u, v;\n    double cost;\n    edge(int u=0, int v=0, double cost=0.0):u(u), v(v), cost(cost) {} \n};\n\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\n// 辺の数でresize & 入力\nvector<edge> es;\n//最小全域木, Vは頂点数\ndouble kruskal(int V) {\n    int E = es.size();\n    sort(es.begin(), es.end(), comp);\n    UnionFind uft(V);\n    double res = 0.0;\n    for(int i = 0; i < E; ++i) {\n        edge e = es[i];\n        if(!uft.same(e.u, e.v)) {\n            uft.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\ndouble leng(double x1, double y1, double z1, double x2, double y2, double z2) {return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2));}\n\nint main() {\n    cout << fixed << setprecision(3);\n    while(1) {\n        int n;\n        cin >> n;\n        if(!n) break;\n        vector<double> x(n), y(n), z(n), r(n);\n        rep(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, n) {\n            rep(j, i) {\n                double kyo = leng(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j];\n                if(kyo > 0.0) {\n                    es.push_back(edge(i, j, kyo));\n                } else {\n                    es.push_back(edge(i, j, 0.0));\n                }\n            }\n        }\n\n        cout << kruskal(n) << endl;\n        es.clear();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_E = 100*100;\nconst int MAX_N = 100;\n\nstruct UnionFind\n{\n  int par[MAX_N];\n  int rank[MAX_N];\n\n  void init(int n){\n    for(int i = 0; i < n; ++i){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++; \n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\nstruct Edge {\n  int u, w;\n  double cost;\n};\nbool comp(const Edge &e1, const Edge &e2)\n{\n  return e1.cost < e2.cost;\n}\n\nEdge es[MAX_E]; \nint v, e; \n\nint main()\n{\n  for(;;){\n    int n;\n    scanf(\"%d\",&n);\n    if(n==0)return 0;\n    double data[n][4];\n    e = n*(n-1)/2;\n    v = n;\n    \n    UnionFind uf;\n    uf.init(n*(n-1)/2);\n\n    for(int i=0;i<n;i++){\n      cin >> data[i][0] >> data[i][1] >> data[i][2] >> data[i][3];\n    }\n\n    int count=0;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tEdge et;\n\tet.u=i;\n\tet.w=j;\n\tdouble length = sqrt(((data[i][0]-data[j][0])*(data[i][0]-data[j][0]))+((data[i][1]-data[j][1])*(data[i][1]-data[j][1]))+((data[i][2]-data[j][2])*(data[i][2]-data[j][2])))-data[i][3]-data[j][3];\n\tif(length<0.0){\n\t  uf.unite(i,j);\n\t  length=0.0;\n\t}\n\tet.cost=length;\n\tes[count++]=et;\n      }\n    }\n    \n    //printf(\"A:%d %d\\n\",count,e);\n\n    sort(es,es+e,comp);\n    double ans = 0.0;\n\n    for(int i = 0; i < e; ++i){\n      Edge et = es[i];\n      //printf(\"B:%f\\n\",et.cost);\n      if(!uf.same(et.u, et.w)){\n\tuf.unite(et.u, et.w); \n\tans += et.cost; \n      }\n    }\n    \n    printf(\"%.3f\\n\",ans);\n\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define REP2(i,x,n) for(int i=x; i<(n); i++)\n#define PRINT(x) cout<<(x)<<endl\n#define INF 1000000000000 // 10^12\n#define MOD 1000000007 // 10^9+7\n#define PB push_back\n#define MP make_pair\n\nconst int MAX_N = 100;\n\nint n;\ndouble x[MAX_N], y[MAX_N], z[MAX_N], r[MAX_N];\n\nstruct edge { int u, v; double d; };\n\nstruct UnionFind {\n    vector<int> par;\n\n    UnionFind(int N) : par(N) {\n        REP(i, N) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) {\n        int rx = root(x);\n        int ry = root(y);\n        if (rx == ry) return;\n        par[rx] = ry;\n    }\n\n    bool same(int x, int y) {\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n    double dist = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2));\n    return dist;\n}\n\nbool comp_edge(const edge& e1, const edge& e2) {\n    return e1.d < e2.d;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        UnionFind cell(n);\n        vector<edge> es;\n        REP(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(i, n) {\n            REP(j, n) {\n                if (cell.same(i, j)) continue;\n                double l = dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j];\n                if (l <= 0) cell.unite(i, j);\n                else es.PB(edge{ .u = i, .v = j, .d = l});\n            }\n        }\n        sort(es.begin(), es.end(), comp_edge);\n        double sum_len = 0;\n        REP(i, es.size()) {\n            if (cell.same(es[i].u, es[i].v)) continue;\n            cell.unite(es[i].u, es[i].v);\n            sum_len += es[i].d;\n        }\n        printf(\"%.3f\\n\", sum_len);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UnionFind{\n    vector<int> par;\n    int cnt;\n    UnionFind(int N):par(N,-1),cnt(N){}\n    void init(int N){par.assign(N,-1);}\n    int root(int x){\n        if(par[x]<0)return x;\n        return par[x]=root(par[x]);\n    }\n    bool issame(int x,int y){\n        return root(x)==root(y);\n    }\n    bool merge(int x,int y){\n        x=root(x),y=root(y);\n        if(x==y)return false;\n        if(par[x]>par[y])swap(x,y);\n        par[x]+=par[y];\n        par[y]=x;\n        cnt--;\n        return true;\n    }\n    int size(int x){\n        return -par[root(x)];\n    }\n};\nstruct Edge{\n    double a,b,cost;\n    bool operator<(const Edge &o){\n        return cost<o.cost;\n    }\n};\nvector<double> x,y,z,r;\ndouble dist(int i,int j){\n    double X=(x[i]-x[j])*(x[i]-x[j]),\n            Y=(y[i]-y[j])*(y[i]-y[j]),\n            Z=(z[i]-z[j])*(z[i]-z[j]);\n    return sqrt(X+Y+Z);\n}\nbool touch(int i,int j){\n    return dist(i,j)<=r[i]+r[j];\n}\nvoid solve(int n){\n    x.assign(n,(double)0),y.assign(n,0),z.assign(n,0),r.assign(n,0);\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    //scanf(\"%llf %llf %llf %llf\",&x[i],&y[i],&z[i],&r[i]);\n    UnionFind Tree(n);\n    vector<Edge> a;\n    for(int i=0;i<n-1;i++){\n        for(int j=i+1;j<n;j++){\n            if(touch(i,j))Tree.merge(i,j);\n            else{\n                Edge ne;\n                ne.a=i,ne.b=j,ne.cost=dist(i,j)-r[i]-r[j];\n                a.push_back(ne);\n            }\n        }\n    }\n    sort(a.begin(),a.end());\n    double ans=0;\n    for(int i=0;i<a.size();i++){\n        if(Tree.issame(a[i].a,a[i].b))continue;\n        ans+=a[i].cost;\n        Tree.merge(a[i].a,a[i].b);\n    }\n    cout<<fixed<<setprecision(3)<<ans<<endl;\n    //printf(\"%.3llf\\n\",ans);\n}\nint main(){\n    while(true){\n        int n;scanf(\"%d\",&n);\n        if(n)solve(n);\n        else break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\nstruct C{ double x,y,z,r; };\n\ndouble abs(C a,C b){\n    double d = sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));\n    return max(d-(a.r+b.r),0.0);\n}\n\nstruct UnionFind{\n    vector<int> par;\n    vector<int> sizes;\n    UnionFind(int n):par(n),sizes(n,1){ rep(i,n)par[i]=i; }\n\n    //find root of x\n    int find(int x){\n        if(x!=par[x]) par[x] = find(par[x]);\n        return par[x];\n    }\n\n    void unite(int x,int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sizes[x] < sizes[y]) swap(x, y);\n        par[y] = x;\n        sizes[x] += sizes[y];\n    }\n\n    bool same(int x,int y){ return find(x) == find(y); }\n    int size(int x){ return sizes[find(x)]; }\n};\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<C> cs(n);\n        rep(i,n){\n            double x,y,z,r;\n            cin>>x>>y>>z>>r;\n            cs[i] = {x,y,z,r};\n        }\n\n        using P = pair<double,pair<int,int>>;\n        priority_queue<P,vector<P>,greater<P>> pq;\n        rep(i,n)rep(j,i) {\n            pq.push({abs(cs[i],cs[j]), {i,j}});\n        }\n        UnionFind uf(n);\n        double cost = 0;\n        while(pq.size()){\n            P p = pq.top(); pq.pop();\n            double d = p.first;\n            int a = p.second.first;\n            int b = p.second.second;\n            if(!uf.same(a,b)){\n                uf.unite(a,b);\n                cost += d;\n            }\n        }\n        printf(\"%.3f\\n\",cost);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nint UF[100];\npair<double,pair<int,int> > e[10000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);\n\tb=FIND(b);\n\tif(a==b)return;\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n}\ndouble x[100],y[100],z[100],r[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tUF[i]=-1;\n\t\t\tscanf(\"%lf%lf%lf%lf\",x+i,y+i,z+i,r+i);\n\t\t}\n\t\tint now=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\te[now++]=make_pair(max(0.0,-r[i]-r[j]+sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))),make_pair(i,j));\n\t\t\t}\n\t\t}\n\t\tstd::sort(e,e+now);\n\t\tdouble ret=0;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tif(FIND(e[i].second.first)!=FIND(e[i].second.second)){\n\t\t\t\tUNION(e[i].second.first,e[i].second.second);\n\t\t\t\tret+=e[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",ret);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\nusing namespace std;\n#define repeat(i,n) for (int i = 0; i < n; ++i)\n\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\n\nclass union_find {\n    vector<int> tree;\npublic:\n    union_find() {}\n    union_find(int n) : tree(n, -1) {}\n    bool is_root(int a) { return tree[a] < 0; }\n    int find_root(int a) { return is_root(a) ? a : (tree[a] = find_root(tree[a])); }\n    int tree_size(int a) { return - tree[find_root(a)]; }\n    void union_tree(int a, int b) {\n        a = find_root(a); b = find_root(b);\n        if (a != b) {\n            if (not (tree_size(a) < tree_size(b))) swap(a,b);\n            tree[b] += tree[a];\n            tree[a] = b;\n        }\n    }\n    bool is_connected(int a, int b) { return find_root(a) == find_root(b); }\n    friend ostream & operator<<(ostream & output, const union_find & uf) { repeat (i, uf.tree.size()-1) output << uf.tree[i] << ' '; return output << uf.tree[uf.tree.size()-1]; }\n};\n\nstruct pos3 { double x, y, z; };\npos3 operator+(const pos3 & p, const pos3 & q) { return (pos3){p.x + q.x, p.y + q.y, p.z + q.z}; }\npos3 operator-(const pos3 & p) { return (pos3){-p.x, -p.y, -p.z}; }\npos3 operator-(const pos3 & p, const pos3 & q) { return p + (- q); }\nistream & operator>>(istream & input, pos3 & p) { return input >> p.x >> p.y >> p.z; }\ndouble sq(double a) { return a * a; }\ndouble length_squared(const pos3 & p) { return sq(p.x) + sq(p.y) + sq(p.z); }\ndouble length(const pos3 & p) { return sqrt(length_squared(p)); }\n\nstruct circle { pos3 p; double r; };\n\n#define MAX_N 100\n#define MIN_X 0.0\n#define MAX_X 100.0\nint N;\nunion_find tree;\ncircle C[MAX_N];\n\nint main() {\n    while (true) {\n        cin >> N; if (not N) break;\n        tree = union_find(N);\n        repeat (i,N) {\n            cin >> C[i].p >> C[i].r;\n            repeat (j,i) if (length_squared(C[j].p - C[i].p) < sq(C[i].r + C[j].r)) {\n                tree.union_tree(i,j);\n            }\n        }\n        double sum = 0.0;\n        repeat (i,N) if (tree.is_root(i)) {\n            double inf = numeric_limits<double>::infinity();\n            int ix = -1;\n            repeat (j,N) if (tree.is_connected(i,j)) {\n                repeat (k,N) if (not tree.is_connected(i,k)) {\n                    double dist = length(C[j].p - C[k].p) - (C[j].r + C[k].r);\n                    if (dist < inf) {\n                        inf = dist; ix = k;\n                    }\n                }\n            }\n            if (ix == -1) break;\n            tree.union_tree(i, ix);\n            sum += inf;\n        }\n#ifdef DEBUG\n        int cnt = 0;\n        repeat (i,N) if (tree.is_root(i)) ++ cnt;\n        assert(cnt == 1);\n#endif\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_E = 200*100;\nconst int MAX_N = 200*100;\ndouble data[200][4];\n\nstruct UnionFind\n{\n  int par[MAX_N];\n  int rank[MAX_N];\n\n  void init(int n){\n    for(int i = 0; i < n; ++i){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++; \n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\nstruct Edge {\n  int u, w;\n  double cost;\n};\nbool comp(const Edge &e1, const Edge &e2)\n{\n  return e1.cost < e2.cost;\n}\n\nEdge es[MAX_E]; \nint v, e; \n    UnionFind uf;\n\n\nint main()\n{\n  for(;;){\n    int n;\n    scanf(\"%d\",&n);\n    if(n==0)return 0;\n    //double data[n][4];\n    e = n*(n-1)/2;\n    v = n;\n    \n    uf.init(n*(n-1)/2);\n\n    for(int i=0;i<n;i++){\n      cin >> data[i][0] >> data[i][1] >> data[i][2] >> data[i][3];\n    }\n\n    int count=0;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tEdge et;\n\tet.u=i;\n\tet.w=j;\n\tdouble length = sqrt(((data[i][0]-data[j][0])*(data[i][0]-data[j][0]))+((data[i][1]-data[j][1])*(data[i][1]-data[j][1]))+((data[i][2]-data[j][2])*(data[i][2]-data[j][2])))-data[i][3]-data[j][3];\n\tif(length<0.0){\n\t  uf.unite(i,j);\n\t  length=0.0;\n\t}\n\tet.cost=length;\n\tes[count++]=et;\n      }\n    }\n    \n    //printf(\"A:%d %d\\n\",count,e);\n\n    sort(es,es+e,comp);\n    double ans = 0.0;\n\n    for(int i = 0; i < e; ++i){\n      Edge et = es[i];\n      //printf(\"B:%f\\n\",et.cost);\n      if(!uf.same(et.u, et.w)){\n\tuf.unite(et.u, et.w); \n\tans += et.cost; \n      }\n    }\n    \n    printf(\"%.3f\\n\",ans);\n\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<double, int>P;\n\ndouble x[100], y[100], z[100], r[100], d[100][100];\nbool used[100];\ndouble distance(double x1, double y1, double z1, double r1, double x2, double y2, double z2, double r2) {\n\treturn max(0., sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)) - r1 - r2);\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n\t\trep(i, n)for (int j = i + 1; j < n; j++)d[i][j] = d[j][i] = distance(x[i], y[i], z[i], r[i], x[j], y[j], z[j], r[j]);\n\t\tdouble sum = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\tpriority_queue<P, vector<P>, greater<P>>que; que.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (used[p.second])continue;\n\t\t\tused[p.second] = true;\n\t\t\tsum += p.first;\n\t\t\trep(i, n)que.push(P(d[p.second][i], i));\n\t\t}\n\t\tprintf(\"%.3lf\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ld cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\nld kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tld res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { ld x, y, z, r; };\nld dis(point a,point b) {\n\tld res;\n\tres = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n\tres -= (a.r + b.r);\n\tif (res < 0) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[101];\n\t\tld x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(5) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct hasi{\n  int s,t;\n  double nagasa;\n  bool operator < ( const hasi &H ) const {\n    return nagasa < H.nagasa;\n  }\n};\n\nint n;\ndouble x[1000],y[1000],z[1000],r[1000];\n\nint uni_tabetai[1000];\nint mituketa(int x){\n  if( x == uni_tabetai[x] ) return x;\n  return uni_tabetai[x] = mituketa(uni_tabetai[x]);\n}\n\nvoid nakayosi(int x,int y){\n  x = mituketa(x);\n  y = mituketa(y);\n  if( x == y ) \n    {\n    }\n  else \n    {\n      uni_tabetai[x] = y;\n    }\n}\n\ndouble kannsuu(double a,double b,double c){\n  return sqrt(a*a+b*b+c*c);\n}\n\nint\nmain() {\n  while( cin >> n ) {\n    if( n == 0 ) break;\n    for(int rupu=0;rupu<n;rupu++) \n      {\n\tuni_tabetai[rupu] = rupu;\n\tint i = rupu;\n\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n      }\n\n    vector<hasi> hairetu;\n    for(int _1=0;_1<n;_1++) {\n      for(int _2=_1+1;_2<n;_2++) {\n\tdouble nagasa = kannsuu(x[_1]-x[_2],y[_1]-y[_2],z[_1]-z[_2]);\n\tif( nagasa > r[_1]+r[_2] ) \n\t  hairetu.push_back((hasi){_1,_2,nagasa-r[_1]-r[_2]});\n\telse \n\t  nakayosi(_1,_2);\n      }\n    }\n    sort(hairetu.begin(),hairetu.end());\n    double ko_ko_ = 0;\n    for(int i=0;i<hairetu.size();i++){\n      int iti = hairetu[i].s;\n      int ni  = hairetu[i].t;\n      if( mituketa(iti) != mituketa(ni) ) {\n\tnakayosi(iti,ni);\n\tko_ko_ += hairetu[i].nagasa;\n      }\n    }\n    printf(\"%.3f\\n\",ko_ko_);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, SIZE(vv)) {\n        REP(j, SIZE(vv[i])) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    if(a > b) swap(a, b);\n    if(a == 0) return b;\n    else return gcd(b%a, a);\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\n#define INF 1e8\n\nstruct edge{int u, v; double cost;};\n\nbool cmp(edge x, edge y) {\n    return x.cost < y.cost;\n};\n\nVI par;\n\nint root(int x) {\n    if(par[x] == x) return x;\n    else return root(par[x]);\n}\n\nvoid unite(int x, int y) {\n    int rx = root(x), ry = root(y);\n    if(rx == ry) return;\n    par[rx] = ry;\n}\n\nbool same(int x, int y) {\n    int rx = root(x), ry = root(y);\n    return rx == ry;\n}\n\nstruct node {double x, y, z, r;};\n\ndouble dist(node a, node b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));\n}\n\nint main(void) {\n    while(1) {\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n        vector<node> v(n);\n        REP(i, n) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            v[i].x = x;\n            v[i].y = y;\n            v[i].z = z;\n            v[i].r = r;\n        }\n        vector<edge> e;\n        REP(i, n) {\n            REP(j, n) {\n                if(i >= j) continue;\n                edge tmp;\n                tmp.u = i;\n                tmp.v = j;\n                tmp.cost = max(0.0, dist(v[i], v[j]) - v[i].r - v[j].r);\n                e.push_back(tmp);\n            }\n        }\n        sort(ALL(e), cmp);\n        double ans = 0.0;\n        int i = 0;\n        par = VI(n);\n        iota(ALL(par), 0);\n        while(i < e.size()) {\n            // cerr << e[i].u << \", \" << e[i].v << \", \" << e[i].cost << endl;\n            if(!same(e[i].u, e[i].v)) {\n                unite(e[i].u, e[i].v);\n                ans += e[i].cost;\n            }\n            // vprint(par);\n            i++;\n        }\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ndouble prim(int n, vector< vector<double> > &G){\n  double ans = 0;\n  priority_queue< pair<double,int> > wait;\n  bool connected[n];\n  fill(connected,connected+n,false);\n  wait.push(make_pair(0.0,0));\n  while(!wait.empty()){\n    double cost = -wait.top().first;\n    int v = wait.top().second;\n    wait.pop();\n    if(connected[v]) continue;\n    ans += cost;\n    connected[v] = true;\n    for(int i = 0; i < n; ++i){\n      if(!connected[i]){\n        wait.push(make_pair(-G[v][i],i));\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x[n], y[n], z[n], r[n];\n    for(int i = 0; i < n; ++i){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    vector< vector<double> > dist(n,vector<double>(n,0));\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        dist[i][j] = max(0.0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j]);\n      }\n    }\n    printf(\"%.12f\\n\",prim(n,dist));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\n\n#define dis(x,y,z,x2,y2,z2) sqrt((x2-x)*(x2-x)+(y2-y)*(y2-y)+(z2-z)*(z2-z)) \n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    Graph g(n);\n    double x[n], y[n], z[n], r[n];\n    REP(i,n) {\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n      REP(j,i) {\n        double d;\n        if ((d = dis(x[i],y[i],z[i],x[j],y[j],z[j])-r[i]-r[j]) >= 0) {\n          g[j].push_back(Edge(j,i,d));\n          g[i].push_back(Edge(i,j,d));\n        } else {\n          g[j].push_back(Edge(j,i,0));\n          g[i].push_back(Edge(i,j,0));\n        }\n      }\n    }\n    \n    printf(\"%.3lf\\n\", minimumSpanningTree(g).first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst double INF = 1000000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\t//if(i==j)\n\t\t\t\t//\tcontinue;\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\t\t//if(cost[i][j]<0)\n\t\t\t\t\t//\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n  vector<int> sz;\n \n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    sz.resize(size,0);\n    for(int i=0;i<size;i++) makeSet(i);\n  }\n \n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n    sz[x]=1;\n  }\n \n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n \n  void unite(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n \n  void link(int x,int y){\n    if(rank[x]>rank[y]){\n      p[y]=x;\n      sz[x]+=sz[y];\n    }else{\n      p[x]=y;\n      sz[y]+=sz[x];\n      if(rank[x]==rank[y]){\n        rank[y]++;\n      }\n    }\n  }\n \n  int findSet(int x){\n    if(x!=p[x]){\n      p[x]=findSet(p[x]);\n    }\n    return p[x];\n  }\n \n  int findSize(int x){\n    return sz[findSet(x)];\n  }\n};\n\n\nvoid solve(){\n    vector<double> x(N),y(N),z(N),r(N);\n    for(int i=0;i<N;i++) cin>>x[i]>>y[i]>>z[i]>>r[i];\n\n    vector<tuple<double,int,int>> edges;\n    for(int i=0;i<N;i++){\n        for(int j=1;j<N;j++){\n            double dis;\n            double s=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n            double t=(r[i]+r[j])*(r[i]+r[j]);\n            if(s<=t) dis=0.0;\n            else{\n                double z=sqrt(s)-(r[i]+r[j]);\n                if(z>0) dis=z;\n                else dis=0.0;\n            }\n            edges.push_back(make_tuple(dis,i,j));\n        }\n    }\n\n    sort(edges.begin(),edges.end());\n    DisjointSet ds(N);\n    double ans=0.0;\n    for(int i=0;i<edges.size();i++){\n        int x=get<1>(edges[i]);\n        int y=get<2>(edges[i]);\n        if(ds.same(x,y)) continue;\n        ds.unite(x,y);\n        ans+=get<0>(edges[i]);\n    }\n    \n    cout<<fixed<<setprecision(3)<<ans<<endl;\n}\n\n\nint main(){\n  while(1){\n      cin>>N;\n      if(N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100\n#define MAX_E 10000\n\nint V,E,par[MAX_V],rank[MAX_V];\n\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\n\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\n\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n\nEdge es[MAX_E];\n\nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n\ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n\nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[MAX_V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n    \n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.3f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind\n{\n    vector<int> par;\n    UnionFind(int n) : par(n, -1){ }\n    int root(int x){\n        if(par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    bool issame(int x, int y){\n        return root(x) == root(y);\n    }\n    bool merge(int x, int y){\n        x = root(x); y = root(y);\n        if(x == y) return false;\n        if(par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    int size(int x){\n        return -par[root(x)];\n    }\n};\n\nstruct Edge\n{\n    int a, b;\n    double dist;\n    bool operator<(const Edge& o) const{\n        return dist < o.dist;\n    }\n};\n\nstruct Graph\n{\n    int n;\n    vector<Edge> es;\n\n    double kruskal(){\n        sort(es.begin(), es.end());\n\n        UnionFind uf(n);\n        double min_dist = 0;\n        for (int ei = 0; ei < es.size(); ei++)\n        {\n            Edge& e = es[ei];\n            if(!uf.issame(e.a, e.b)){\n                min_dist += e.dist;\n                uf.merge(e.a, e.b);\n            }\n        }\n        return min_dist;\n    }\n};\n\ndouble d(double x, double y, double z, double u, double v, double w){\n    double dx = x - u, dy = y - v, dz = z - w;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nint N;\nint main() {\n    while (true)\n    {\n        cin >> N;\n        double in[N][4];\n        if(N == 0) break;\n        for (int i = 0; i < N; i++)\n        {\n            cin >> in[i][0] >> in[i][1] >> in[i][2] >> in[i][3];\n        }\n\n        Graph g;\n        g.n = N;\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i+1; j < N; j++)\n            {\n                Edge e;\n                e.a = i, e.b = j;\n                e.dist = max((double)0, d(in[i][0], in[i][1], in[i][2], in[j][0], in[j][1], in[j][2]) - in[i][3] - in[j][3]);\n                g.es.push_back(e);\n            }\n        }\n        cout << fixed << setprecision(3) << g.kruskal() << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, start, end) for (long long i = start; i < end; ++i)\n#define repreverse(i, start, end) for (long long i = start; i >= end; --i)\n#define all(x) (x).begin(), (x).end()\n#define len(x) ((long long)(x).size())\n#define lcm(a, b) ((a) / __gcd((a), (b)) * (b))\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vllvll = vector<vll>;\nusing pll = pair<ll, ll>;\ntemplate<class T>void print1d(T x,ll n=-1){if(n==-1)n=x.size();rep(i,0,n){cout<<x[i]<<' ';}cout<<'\\n';}\ntemplate<class T>void print2d(T x,ll r=-1,ll c=-1){if(r==-1)r=x.size();if(c==-1)c=x[0].size();rep(i,0,r)print1d(x[i],c);}\ntemplate<class T, class U>bool haskey(T mp, U key) { return mp.find(key) != mp.end(); }\ntemplate<class T, class U>bool isin(T el, U container) { return find(all(container), el) != container.end(); }\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<class T>ld deg2rad(T deg) { return M_PI * deg / 180.0; }\ntemplate<class T>ld rad2deg(T rad) { return 180.0 * rad / M_PI; }\nll intpow(ll a,ll n){ll p=1;while(n){if(n&1)p*=a;a*=a;n>>=1;}return p;}\nconst long double pi = M_PI;\nconst long long big = 1LL << 50;\nconst long long inf = 1LL << 60;\nconst long long mod = 1e9 + 7;\n\nclass UnionFind\n{   \npublic:\n    static const int N_MAX = 1000000;\n    int par[N_MAX];\n    int n;\n    \n    UnionFind(int n)\n        : n{n}\n    {\n        for (int i = 0; i < n; ++i) {\n            par[i] = i;\n        }\n    }\n    \n    int root(int x)\n    {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = root(par[x]);\n    }\n    \n    bool same(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    \n    void unite(int x, int y)\n    {\n        int rx = root(x);\n        int ry = root(y);\n        if (rx == ry) {\n            return;\n        }\n        par[ry] = root(x);\n        return;\n    }\n    \n    int groups()\n    {\n        int cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            if (root(i) == i)\n            ++cnt;\n        }\n        return cnt;\n    }\n};\n\n\nclass Edge\n{\npublic:\n    ll from;\n    ll to;\n    ld cost;\n    Edge() : to{0}, cost{0} {}\n    Edge(ll to, ld cost) : to{to}, cost{cost} {}\n    Edge(ll from, ll to, ld cost) : from{from}, to{to}, cost{cost} {}\n    bool operator<(const Edge& rhs) const {\n        return cost < rhs.cost;\n    }\n};\n\nld kruskal(vector<Edge>& edges, long long n)\n{\n    sort(edges.begin(), edges.end());\n    UnionFind uf(n);\n    ld min_cost = 0;\n\n    for (Edge e : edges) {\n        if (! uf.same(e.from, e.to)) {\n            uf.unite(e.from, e.to);\n            min_cost += e.cost;\n        }\n    }\n    return min_cost;\n}\n\n\nld calc(ld x1, ld y1, ld z1, ld x2, ld y2, ld z2)\n{\n        ld res = powl(x1-x2, 2) + powl(y1-y2, 2) + powl(z1-z2, 2);\n        return sqrtl(res);\n}\n\nint main()\n{\n        ll n = 1000;\n        do {\n                cin >> n;\n                if (n == 0) break;\n                vector<ld> x(n), y(n), z(n), r(n);\n                vector<Edge> edges;\n                rep(i, 0, n) {\n                        cin >> x[i] >> y[i] >> z[i] >> r[i];\n                }\n\n                rep(i, 0, n) {\n                        rep(j, i+1, n) {\n                                ld dist = calc(x[i], y[i], z[i], x[j], y[j], z[j]);\n                                if (r[i] + r[j] > dist) {\n                                        dist = 0.0;\n                                } else {\n                                        dist -= r[i] + r[j];\n                                }\n                                Edge e(i, j, dist);\n                                edges.push_back(e);\n                        }\n                }\n                ld ans = kruskal(edges, n);\n                cout << fixed << setprecision(3) << ans << endl;\n\n        } while (n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[111], y[111], z[111], r[111];\ndouble d[111][111];\nint visit[111];\n\nint main(){\n\tint n;\n\twhile(cin>>n, n){\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tREP(i,n)FOR(j,i+1,n)d[i][j] = d[j][i] = max(sqrt(pow(x[i]-x[j], 2.0)+pow(y[i]-y[j], 2.0)+pow(z[i]-z[j], 2.0))-r[i]-r[j], 0.0);\n\t\tpriority_queue<pair<double, PII>, vector<pair<double,PII> >, greater<pair<double,PII> > > q;\n\t\tvisit[0]=1;\n\t\tFOR(i,1,n)q.push(MP(d[0][i], MP(0, i)));\n\t\tdouble ret = 0.0;\n\t\twhile(!q.empty()){\n\t\t\tpair<double, PII> tmp;\n\t\t\ttmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(visit[tmp.second.second])continue;\n\t\t\tret += tmp.first;\n\t\t\tvisit[tmp.second.second] = 1;\n\t\t\tREP(i,n)if(i!=tmp.second.second)q.push(MP(d[tmp.second.second][i], MP(tmp.second.second, i)));\n\t\t}\n\t\tprintf(\"%.3f\\n\", ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<stdio.h>\nusing namespace std;\n#define inf 1<<21\nstruct cell{\n  double x,y,z,r;\n};\ndouble dis(cell a,cell b){\n  double o=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z))-(a.r+b.r);\n  if(o<=0) return 0;\n  return o;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int i,j,k;\n    vector<cell> cells;\n    cell c;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.z >> c.r;\n      cells.push_back(c);\n    }\n    \n    double cost[100][100]={{}};\n    for(i=0;i<n;i++){\n      for(j=i;j<n;j++){\n\tif(i==j) cost[i][j]=inf;\n\telse{\n\t  cost[i][j]=dis(cells[i],cells[j]);\n\t  cost[j][i]=cost[i][j];\n\t}\n      }\n    }\n    \n    int color[100]={},p[100]={};\n    double d[100]={};\n    for(i=0;i<n;i++){\n      color[i]=0;\n      d[i]=inf;\n      p[i]=-1;\n    }\n    double sum=0,minv;\n    int u;\n    d[0]=0;\n    while(1){\n      minv=inf;\n      u=-1;\n      for(i=0;i<n;i++){\n\tif(minv>d[i]&&color[i]!=2){\n\t  u=i;\n\t  minv=d[i];\n\t}\n      }\n      if(u==-1) break;\n      color[u]=2;\n      for(i=0;i<n;i++){\n\tif(color[i]!=2&&u!=i){\n\t  if(d[i]>cost[u][i]){\n\t    d[i]=cost[u][i];\n\t    p[i]=u;\n\t    color[i]=1;\n\t  }\n\t}\n      }\n      \n    }\n    for(i=0;i<n;i++){\n      if(p[i]!=-1) sum+=cost[i][p[i]];\n    }\n    \n    printf(\"%.3f\\n\",sum);\n    \n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <queue>\n#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\n\ntypedef long double R;\ntypedef tuple<R,R,R> P;\ntypedef pair<P,R> S;\nR const eps = 1e-10;\n\ntypedef R Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n    int n = g.size();\n    Edges T;\n    Weight total = 0;\n    vector<bool> vis(n);\n    priority_queue<Edge> q;\n    q.push( Edge(-1, r, 0) );\n    while (!q.empty()) {\n        Edge e = q.top(); q.pop();\n        if (vis[e.dst]) continue;\n        T.push_back(e);\n        total += e.weight;\n        vis[e.dst] = true;\n        for(auto& f : g[e.dst]) if (!vis[f.dst]) q.push(f);\n    }\n    return make_pair(total, T);\n}\n\nint n;\nS ss[111];\nR d[111][111];\n\nP operator-(const P& p, const P& q){\n    R x,y,z, a,b,c;\n    tie(x,y,z) = p; tie(a,b,c) = q;\n    return P(x-a, y-b, z-c);\n}\n\nR abs(P p){\n    R x,y,z;\n    tie(x,y,z) = p;\n    return sqrt(x*x+y*y+z*z);\n}\n\nR dist(S const& c1, S const& c2){\n    R d = abs(c1.first-c2.first);\n    return max<R>(0, d-(c1.second+c2.second));\n}\n\nint main(){\n    while(cin >> n && n){\n        Graph g(n);\n        rep(i,n){\n            R x,y,z,r; cin >> x >> y >> z >> r;\n            ss[i] = S(P(x,y,z),r);\n            rep(j,i){\n                R d = dist(ss[i],ss[j]);\n                g[i].eb(i,j,d);\n                g[j].eb(j,i,d);\n            }\n        }\n        printf(\"%.3lf\\n\", (double)minimumSpanningTree(g).first);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct hasi{\n  int s,t;\n  double nagasa;\n  bool operator < ( const hasi &H ) const {\n    return nagasa < H.nagasa;\n  }\n};\n\nint n;\ndouble x[1000],y[1000],z[1000],r[1000];\n\nint uni_tabetai[1000];\nint mituketa(int x){\n  if( x == uni_tabetai[x] ) return x;\n  return uni_tabetai[x] = mituketa(uni_tabetai[x]);\n}\n\nvoid nakayosi(int x,int y){\n  x = mituketa(x);\n  y = mituketa(y);\n  if( x == y ) \n    {\n    }\n  else \n    {\n      uni_tabetai[x] = y;\n    }\n}\n\ndouble kannsuu(double a,double b,double c){\n  return sqrt(a*a+b*b+c*c);\n}\n\nint\nmain() {\n  while( cin >> n ) {\n    if( n == 0 ) break;\n    for(int rupu=0;rupu<n;rupu++) \n      {\n\tuni_tabetai[rupu] = rupu;\n\tint i = rupu;\n\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n      }\n\n    vector<hasi> hairetu;\n    for(int _1=0;_1<n;_1++) {\n      for(int _2=_1+1;_2<n;_2++) {\n\tdouble nagasa = kannsuu(x[_1]-x[_2],y[_1]-y[_2],z[_1]-z[_2]);\n\tif( nagasa > r[_1]+r[_2] ) \n\t  hairetu.push_back((hasi){_1,_2,nagasa-r[_1]-r[_2]});\n\telse \n\t  nakayosi(_1,_2);\n      }\n    }\n    sort(hairetu.begin(),hairetu.end());\n    double ko_ko_ = 0;\n    for(int i=0;i<hairetu.size();i++){\n      int iti = hairetu[i].s;\n      int ni  = hairetu[i].t;\n      if( mituketa(iti) != mituketa(ni) ) {\n\tnakayosi(iti,ni);\n\tko_ko_ += hairetu[i].nagasa;\n      }\n    }\n    printf(\"%.3f\\n\",ko_ko_);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ninline double sq(double x){ return x*x; }\ntypedef pair<double, int> P;\nint main(){\n  int n;\n  while(cin>>n,n){\n    double x[100],y[100],z[100],r[100];\n    REP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    double d[100][100];\n    REP(i,n)REP(j,n){\n      d[i][j] = sqrt(sq(x[i]-x[j]) + sq(y[i]-y[j]) + sq(z[i]-z[j])) - (r[i] + r[j]);\n      d[i][j] = max(0.0, d[i][j]);\n    }\n    priority_queue<P> que;\n    que.push(P(0,0));\n    bool used[100] = {};\n    double ans = 0;\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      p.first *= -1;\n      if(used[p.second]) continue;\n      used[p.second] = true;\n      ans += p.first;\n      REP(i,n)if(!used[i]){\n        que.push(P(-d[p.second][i], i));\n      }\n    }\n    printf(\"%.3lf\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\nconst double eps = 1e-8;\n\nint root(vector<int> & ufa,int i)\n{\n\tif(ufa[i] != i)\n\t\tufa[i] = root(ufa,ufa[i]);\n\treturn ufa[i];\n}\n\nvoid join(vector<int> & ufa,int i,int j)\n{\n\tint ri = root(ufa,i);\n\tint rj = root(ufa,j);\n\tufa[ri] = rj;\n}\n\nstruct e\n{\n\tint s;\n\tint t;\n\tdouble cst;\n};\n\nbool operator<(const e & lhs,const e & rhs)\n{\n\treturn lhs.cst < rhs.cst;\n}\n\nint main(void) {\n\tcout.precision(4);\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tvector<double> z(n);\n\t\tvector<double> r(n);\n\t\tvector<int> ufa(n);\n\t\tREP(i,n)ufa[i]=i;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tvector<vector<double> > dist_big(n,vector<double>(n,INF));\n\t\tREP(i,n)REP(j,n)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tint d = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\tdist_big[i][j]=dist_big[j][i]=sqrt(d)-(r[i]+r[j]);\n\t\t\tif(d <= (r[i]+r[j]+eps)*(r[i]+r[j]+eps))\n\t\t\t{\n\t\t\t\tjoin(ufa,i,j);\n\t\t\t}\n\t\t}\n\t\tset<int> sec;\n\t\tREP(i,n)\n\t\t\tsec.insert(root(ufa,i));\n\t\tint secn = sec.size();\n\t\tif(secn > 1)\n\t\t{\n\t\t\tvector<int> roots;\n\t\t\tFORIT(i,sec)\n\t\t\t\troots.push_back(*i);\n\t\t\tvector<vector<double> > dist(secn,vector<double>(secn,INF));\n\t\t\tREP(i,n)REP(j,n)\n\t\t\t{\n\t\t\t\tif(ufa[i]==ufa[j])continue;\n\t\t\t\tint di,dj;\n\t\t\t\tREP(k,secn)\n\t\t\t\t{\n\t\t\t\t\tif(roots[k]==ufa[i])di=k;\n\t\t\t\t\tif(roots[k]==ufa[j])dj=k;\n\t\t\t\t}\n\t\t\t\tdist[di][dj]=min(dist[di][dj],dist_big[i][j]);\n\t\t\t}\n\t\t\tvector<e> edge;\n\t\t\tREP(i,secn)REP(j,i)\n\t\t\t{\n\t\t\t\te p = {i,j,dist[i][j]};\n\t\t\t\tedge.push_back(p);\n\t\t\t}\n\t\t\tsort(ALL(edge));\n\t\t\tvector<int> ufa2(secn);\n\t\t\tREP(i,secn)ufa2[i]=i;\n\t\t\tdouble cost = 0.0;\n\t\t\tREP(i,edge.size())\n\t\t\t{\n\t\t\t\te p = edge[i];\n\t\t\t\tif(root(ufa2,p.s) != root(ufa2,p.t))\n\t\t\t\t{\n\t\t\t\t\tjoin(ufa2,p.s,p.t);\n\t\t\t\t\tcost += p.cst;\n\t\t\t\t\tsecn--;\n\t\t\t\t\tif(secn == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout  << setiosflags(ios::fixed)<< cost << endl;\n\t\t}\n\t\telse\n\t\t\tcout << 0.0 << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<double, P> PDP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 100\n\nstruct Point {\n  double x, y, z, r;\n};\n\nPoint p[MAX_N];\nint parent[MAX_N];\ndouble ans;\n\ndouble dis(int i, int j) {\n  return sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y)\n           + (p[i].z - p[j].z) * (p[i].z - p[j].z));\n}\n\ndouble  corridor(int i, int j) {\n  double d = dis(i, j);\n  if (d > p[i].r + p[j].r) return d - (p[i].r + p[j].r);\n  else return 0;\n}\n\nint find(int i) {\n  if (i == parent[i]) return i;\n  return parent[i] = find(parent[i]);\n}\n\nvoid unite(PDP v) {\n  int x = find(v.se.fi), y = find(v.se.se);\n  if (x == y) return;\n\n  parent[y] = x;\n  ans += v.fi;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n\n  while(cin >> n, n) {\n    rep(i, n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n    vector<PDP> v;\n    rep(i, n - 1)repl(j, i + 1, n)  v.pb(PDP(corridor(i, j), P(i, j)));\n    rep(i, n) parent[i] = i;\n\n    sort(all(v));\n    ans = 0;\n\n    rep(i, v.size()) unite(v[i]);\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double, pii> pdpii;\n\nconst double EPS = 1e-9;\n\nclass UnionFindTree {\nprivate:\n\tvector<int> parent;\n\tvector<int> rank;\n\npublic:\n\texplicit UnionFindTree(int n = 0) :\n\t\tparent(n), rank(n)\n\t{\n\t\tfor(int i = 0; i < n; ++i){ parent[i] = i; }\n\t}\n\tint find(int x){\n\t\tif(parent[x] == x){ return x; }\n\t\tparent[x] = find(parent[x]);\n\t\treturn parent[x];\n\t}\n\tint unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){ return x; }\n\t\tif(rank[x] < rank[y]){\n\t\t\tparent[x] = y;\n\t\t\treturn y;\n\t\t}else if(rank[x] > rank[y]){\n\t\t\tparent[y] = x;\n\t\t\treturn x;\n\t\t}else{\n\t\t\tparent[y] = x;\n\t\t\t++rank[x];\n\t\t\treturn x;\n\t\t}\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setiosflags(ios::fixed) << setprecision(3);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tvector< vector<double> > mat(n, vector<double>(n));\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = i + 1; j < n; ++j){\n\t\t\t\tdouble dx = x[i] - x[j], dy = y[i] - y[j], dz = z[i] - z[j];\n\t\t\t\tdouble dist = sqrt(dx * dx + dy * dy + dz * dz);\n\t\t\t\tdouble rsum = r[i] + r[j];\n\t\t\t\tif(dist > rsum){\n\t\t\t\t\tmat[i][j] = mat[j][i] = dist - rsum;\n\t\t\t\t}else{\n\t\t\t\t\tmat[i][j] = mat[j][i] = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pdpii> edges(n * (n - 1) / 2);\n\t\tfor(int i = 0, k = 0; i < n; ++i){\n\t\t\tfor(int j = i + 1; j < n; ++j, ++k){\n\t\t\t\tedges[k] = pdpii(mat[i][j], pii(i, j));\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tUnionFindTree uft(n);\n\t\tdouble answer = 0.0;\n\t\tfor(int i = 0; i < edges.size(); ++i){\n\t\t\tdouble c = edges[i].first;\n\t\t\tint a = edges[i].second.first, b = edges[i].second.second;\n\t\t\tif(uft.same(a, b)){ continue; }\n\t\t\tanswer += c;\n\t\t\tuft.unite(a, b);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; double w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble prim(int n, vector<edge> G[]) {\n\tvector<double> w(n, DBL_MAX); w[0] = 0;\n\tpriority_queue< d_i, vector<d_i>, greater<d_i> > q;\n\tq.push(d_i(0, 0));\n\tdouble res = 0;\n\twhile (!q.empty()) {\n\t\td_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > w[u]) continue;\n\t\tres += w[u]; w[u] = -DBL_MAX;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (w[e.v] > e.w) {\n\t\t\t\tw[e.v] = e.w;\n\t\t\t\tq.push(d_i(e.w, e.v));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<edge> G[100];\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tG[i].clear();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble dx = x[i] - x[j], dy = y[i] - y[j], dz = z[i] - z[j];\n\t\t\t\tdouble l = max(0.0, sqrt(dx * dx + dy * dy + dz * dz) - (r[i] + r[j]));\n\t\t\t\tedge e = {i, j, l}, _e = {j, i, l};\n\t\t\t\tG[i].push_back(e); G[j].push_back(_e);\n\t\t\t}\n\t\tprintf(\"%.3f\\n\", prim(n, G));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI 3.14159265358979323846\n\nusing namespace std;\n\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\n#define M_PI 3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\ninline int readInt()\n{\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n//#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\nconst int INF = 2147483647;\nclass UnionFind\n{\npublic:\n    vector<int> par;\n    vector<int> siz;\n\n    UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n    {\n        for (ll i = 0; i < sz_; ++i)\n            par[i] = i;\n    }\n    void init(int sz_)\n    {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i)\n            par[i] = i;\n    }\n\n    int root(int x)\n    {\n        while (par[x] != x)\n        {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n\n    bool merge(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if (x == y)\n            return false;\n        if (siz[x] < siz[y])\n            swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n\n    int size(int x)\n    {\n        return siz[root(x)];\n    }\n};\n\nint N;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(3);\n\n    while (cin >> N)\n    {\n        if (N == 0)\n            break;\n\n        vector<long double> x(N), y(N), z(N), r(N);\n        REP(i, N)\n        {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        vector<pair<long double, pair<int, int>>> vp;\n        REP(i, N)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                long double d1 = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n\n                long double d2 = sqrt(d1 * d1 + (z[i] - z[j]) * (z[i] - z[j]));\n\n                vp.push_back(make_pair(max((long double)0.000, d2 - r[i] - r[j]), make_pair(i, j)));\n            }\n        }\n\n        sort(all(vp));\n\n        UnionFind uf(N + 1);\n        long double ans = 0;\n        for (int i = 0; i < vp.size(); i++)\n        {\n\n            int v = vp[i].second.first, u = vp[i].second.second;\n            if (!uf.issame(u, v))\n            {\n                ans += vp[i].first;\n                uf.merge(v, u);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nstruct edge { int from, to; double dist; };\n\nstruct UnionFind {\n\tvector<int> vec;\n\tUnionFind(int n) { vec.resize(n, -1); };\n\n\tbool unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return false;\n\t\tif (vec[a] > vec[b]) swap(a, b);\n\t\tvec[a] += vec[b];\n\t\tvec[b] = a;\n\t\treturn true;\n\t}\n\tbool same(int a, int b) { return find(a) == find(b); }\n\tint find(int x) { return vec[x] < 0 ? x : vec[x] = find(vec[x]); }\n\tint size(int x) { return -vec[find(x)]; };\n};\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\tvector<edge> graph;\n\t\tusing tup = tuple<double, double, double, double>;\n\t\tvector<tup> v(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y, z, r; cin >> x >> y >> z >> r;\n\t\t\tv[i] = tup(x, y, z, r);\n\t\t}\n\n\t\tUnionFind uf(n);\n\t\trep(i, n) rep(j, i + 1, n) {\n\t\t\tauto a = v[i], b = v[j];\n\t\t\tdouble d = hypot(hypot(get<0>(a) - get<0>(b), get<1>(a) - get<1>(b)), get<2>(a) - get<2>(b)) - get<3>(a) - get<3>(b);\n\t\t\tif (d <= 0) uf.unite(i, j);\n\t\t\telse graph.push_back(edge{ i, j, d });\n\t\t}\n\n\t\tdouble ans = 0;\n\t\tsort(all(graph), [](edge e1, edge e2) {return e1.dist < e2.dist; });\n\t\tfor (auto& e : graph) if (!uf.same(e.from, e.to)) {\n\t\t\tuf.unite(e.from, e.to);\n\t\t\tans += e.dist;\n\t\t}\n\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct cell{\n\tdouble x,y,z,r;\n\tcell(double a, double b, double c, double d):x(a),y(b),z(c),r(d){}\n\tdouble dist(const cell &c2){\n\t\tdouble d = sqrt((x-c2.x)*(x-c2.x)+(y-c2.y)*(y-c2.y)+(z-c2.z)*(z-c2.z));\n\t\treturn max<double>(d-r-c2.r, 0);\n\t}\n};\nstruct Edge{\n\tint s,g;\n\tdouble d;\n\tEdge(int a, int b, double c) : s(a), g(b), d(c) {}\n\t\n\tbool operator<(const Edge &b){\n\t\tif(d!=b.d) return d<b.d;\n\t\tif(s!=b.s) return s<b.s;\n\t\treturn g < b.g;\n\t}\n};\n\nstruct Unionfind {\n\tvector< int > par;\n\tUnionfind(int N) : par(N,-1){\n\t}\n\tbool unite(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif(x == y) return 0;\n\t\tif(par[x] > par[y]) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn 1;\n\t}\n\tint root(int k) {\n\t\tif(par[k] < 0) return (k);\n\t\treturn (par[k] = root(par[k]));\n\t}\n\tbool same(int x, int y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\treturn x==y;\n\t}\n\tint size(int k) {\n\t\treturn (-par[root(k)]);\n\t}\n};\n\nint main() {\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<cell> ce;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tdouble a, b, c,r;\n\t\t\tcin >> a >> b >> c>>r;\n\t\t\tce.push_back({a,b,c,r});\n\t\t}\n\t\tvector<Edge> g;\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tauto d = ce.at(i).dist(ce.at(j));\n\t\t\t\tg.push_back({i,j,d});\n\t\t\t\tg.push_back({j,i,d});\n\t\t\t}\n\t\t}\n\t\tsort(g.begin(),g.end());\n\t\tdouble sum{};\n\t\tUnionfind uf(n);\n\t\tfor(auto i:g){\n\t\t\tif(!uf.same(i.s,i.g)){\n\t\t\t\tuf.unite(i.s,i.g);\n\t\t\t\tsum += i.d;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(3);\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ninline double sq(double x){ return x*x; }\ntypedef pair<double, int> P;\nint main(){\n  int n;\n  while(cin>>n,n){\n    double x[100],y[100],z[100],r[100];\n    REP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    double d[100][100];\n    REP(i,n)REP(j,n){\n      d[i][j] = sqrt(sq(x[i]-x[j]) + sq(y[i]-y[j]) + sq(z[i]-z[j])) - (r[i] + r[j]);\n      d[i][j] = max(0.0, d[i][j]);\n    }\n    priority_queue<P> que;\n    que.push(P(0,0));\n    bool used[100] = {};\n    double ans = 0;\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      p.first *= -1;\n      if(used[p.second]) continue;\n      used[p.second] = true;\n      ans += p.first;\n      REP(i,n)if(!used[i]){\n        que.push(P(-d[p.second][i], i));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\ntemplate<class T> bool chmin(T &a, T b) {if(a>b) {a=b;return 1;}return 0;}\nusing namespace std;\nusing vint = vector<int>;\nusing vvint = vector<vector<int>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing P = pair<int,int>;\nconst ll inf = 1e18;\n\n// union-find\nvint par;\nvint depth;\n\nvoid init (int n) {\n    rep(i,n) {\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (depth[x] < depth[y]) par[x] = y;\n    else {\n        par[y] = x;\n        if (depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y) {return find(x) == find(y);}\n\n// kruscal\nstruct edge {int u, v; double cost;};\n\nbool comp(const edge &e1, const edge &e2) {\n    return e1.cost < e2.cost;\n}\n\nedge es[10005];\nint V, E;\n\ndouble kruskal() {\n    sort(es,es+E,comp);\n    init(V);\n    double res = 0;\n    rep(i,E) {\n        edge e = es[i];\n        if (!same(e.u,e.v)) {\n            unite(e.u,e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (true) {\n        cin >> V;\n        if (V == 0) break;\n        E = V*(V-1)/2;\n        par.resize(V);\n        depth.resize(V);\n        vector<vector<double>> a(V);\n        rep(i,V) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            a[i] = {x,y,z,r};\n        }\n        int ct = 0;\n        for (int i = 0; i < V; i++) {\n            for (int j = i+1; j < V; j++) {\n                es[ct].u = i; es[ct].v = j;\n                double c = 0;\n                rep(k,3) c += (a[i][k]-a[j][k])*(a[i][k]-a[j][k]);\n                c = sqrt(c) - a[i][3] - a[j][3];\n                if (c < 0.001) c = 0;\n                es[ct].cost = c;\n                ct++;\n            }\n        }\n        printf(\"%.3f\\n\",kruskal());\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst int MAX = 100;\n\nint par[MAX];\nint rnk[MAX];\nint nodeNum[MAX];\n\nvoid init(int n) {\n\tfor(int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tnodeNum[i] = 1;\n\t}\n}\n\nint find(int x) {\n\tif(par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rnk[x] < rnk[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n\tnodeNum[x] = nodeNum[y] = nodeNum[x] + nodeNum[y];\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\ntypedef double W;\nstruct edge {\n\tint u, v;\n\tW cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\n\nW kruskal(int V, int E) {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tW res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble x[100], y[100], z[100], r[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tes.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\t\tdouble d = sqrt((x[i] - x[j]) * (x[i] - x[j]) +\n\t\t\t\t\t(y[i] - y[j]) * (y[i] - y[j]) +\n\t\t\t\t\t(z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\td = max(0.0, d - r[i] - r[j]);\n\t\t\t\tes.push_back(edge{ i, j, d });\n\t\t\t}\n\t\t}\n\t\tdouble ans = kruskal(N, es.size());\n\t\tcout << fixed << setprecision(3) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct edge {\n  int p, q;\n  double d;\n  bool operator<(const edge &e) const { return d < e.d; }\n};\n\nint N;\ndouble X[100], Y[100], Z[100], R[100];\n\ndouble dist(int i, int j) {\n  double dx = X[i] - X[j];\n  double dy = Y[i] - Y[j];\n  double dz = Z[i] - Z[j];\n  return max(sqrt(dx * dx + dy * dy + dz * dz) - R[i] - R[j], 0.0);\n}\n\nint find(int *a, int i) { return a[i] == i ? i : (a[i] = find(a, a[i])); }\nvoid unite(int *a, int i, int j) { if(find(a, i) != find(a, j)) a[find(a, i)] = find(a, j); }\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\n    vector<edge> e;\n    REP(i, 0, N) REP(j, i + 1, N) e.push_back((edge) { i, j, dist(i, j) });\n    sort(e.begin(), e.end());\n\n    double ans = 0.0;\n    int g[100];\n    REP(i, 0, N) g[i] = i;\n    REP(i, 0, e.size()) if(find(g, e[i].p) != find(g, e[i].q)) {\n      ans += e[i].d;\n      unite(g, e[i].p, e[i].q);\n    }\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Point{\n    double x, y, z;\n    double r;\n};\n\n\ndouble dist(Point a, Point b){\n    auto pow = [](double a){return a * a; };\n    return sqrt(pow(b.x - a.x) + pow(b.y - a.y) + pow(b.z - a.z)) - (a.r + b.r);\n}\n\nclass Edge {\n    public:\n        int to;\n        double cost;\n        Edge(int to, double cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble prim(const Graph &g, int s = 0) {\n    int n = g.size();\n    double total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n    //priority_queue<pair<double, int> > q;\n\n    q.push(make_pair(0.0,s));\n    while (not q.empty()) {\n        pair<double, int> u = q.top(); q.pop();\n        if (visited[u.second]) continue;\n        total += u.first;\n        visited[u.second] = true;\n        for(auto it : g[u.second]) {\n            if (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n        }\n    }\n    return total;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        Point p[105];\n        rep(i,n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n\n        Graph g(n);\n        rep(i,n){\n            rep(j,n){\n                double tmp = dist(p[i], p[j]);\n//                cout << i << ' ' << j << endl;\n//                show(tmp)\n                g[i].emplace_back(Edge{j,tmp < 0 ? 0 : tmp});\n            }\n        }\n        cout <<fixed << setprecision(8) <<  prim(g,0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])break;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(22)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ndouble prim(int n, vector< vector<double> > &G){\n  double ans = 0.0;\n  priority_queue< pair<double,int> > wait;\n  bool connected[n];\n  fill(connected,connected+n,false);\n  wait.push(make_pair(0.0,0));\n  while(!wait.empty()){\n    double cost = -wait.top().first;\n    int v = wait.top().second;\n    wait.pop();\n    if(connected[v]) continue;\n    ans += cost;\n    connected[v] = true;\n    for(int i = 0; i < n; ++i){\n      if(!connected[i]){\n        wait.push(make_pair(-G[v][i],i));\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x[n], y[n], z[n], r[n];\n    for(int i = 0; i < n; ++i){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    vector< vector<double> > dist(n,vector<double>(n,0));\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        dist[i][j] = max(0.0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j]);\n      }\n    }\n    printf(\"%.3f\\n\",prim(n,dist));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nconst int INF = numeric_limits<int>::max() / 2;\n\nstruct cell {\n\tdouble x, y, z, r;\n};\n\ndouble calc(cell p, cell q) {\n\tdouble tmp = sqrt((p.x - q.x)*(p.x - q.x) + (p.y - q.y)* (p.y - q.y) + (p.z - q.z)*(p.z - q.z));\n\tif (tmp <= p.r + q.r) return 0;\n\telse return (-p.r - q.r + tmp);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<cell> cells;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcell c;\n\t\t\tcin >> c.x >> c.y >> c.z >> c.r;\n\t\t\tcells.push_back(c);\n\t\t}\n\t\tvector<vector<double>> dis(n, vector<double>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) dis[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tdis[i][j] = calc(cells[i], cells[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> used(n, false);\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\tdouble res = 0;\n\t\tque.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (used[p.second]) continue;\n\t\t\tused[p.second] = true;\n\t\t\tres += p.first;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!used[i]) {\n\t\t\t\t\tque.push(P(dis[p.second][i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed<<setprecision(10)<<res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nconst int MAX = 100;\n\nint par[MAX];\nint rnk[MAX];\nint nodeNum[MAX];\n\nvoid init(int n) {\n\tfor(int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tnodeNum[i] = 1;\n\t}\n}\n\nint find(int x) {\n\tif(par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rnk[x] < rnk[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n\tnodeNum[x] = nodeNum[y] = nodeNum[x] + nodeNum[y];\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\ntypedef double W;\nstruct edge {\n\tint u, v;\n\tW cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\n\nW kruskal(int V, int E) {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tW res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble x[100], y[100], z[100], r[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tes.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\t\tdouble d = sqrt((x[i] - x[j]) * (x[i] - x[j]) +\n\t\t\t\t\t(y[i] - y[j]) * (y[i] - y[j]) +\n\t\t\t\t\t(z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\td = max(0.0, d - r[i] - r[j]);\n\t\t\t\tes.push_back(edge{ i, j, d });\n\t\t\t}\n\t\t}\n\t\tdouble ans = kruskal(N, es.size());\n\t\tcout << setprecision(12) << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include<algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nusing T=tuple<double, int>;\n\nclass Solver {\n};\n\nint main() {\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tvector<vector<double>> poses(n, vector<double>(4, 0));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tcin >> poses[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<vector<T>> graph(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble dist = sqrt(\n\t\t\t\t\tpow(poses[j][0] - poses[i][0], 2)\n\t\t\t\t\t+ pow(poses[j][1] - poses[i][1], 2)\n\t\t\t\t\t+ pow(poses[j][2] - poses[i][2], 2))\n\t\t\t\t\t- poses[j][3] - poses[i][3];\n\t\t\t\tif (dist < 0)dist = 0;\n\t\t\t\tgraph[i].emplace_back(make_tuple(dist,j));\n\t\t\t\tgraph[j].emplace_back(make_tuple(dist,i));\n\t\t\t}\n\t\t}\n\n\t\tdouble res = 0;\n\t\tpriority_queue<T, vector<T>, greater<T>> queue;\n\t\tqueue.emplace(make_tuple(0, 0));\n\t\tvector<bool> checked(n, false);\n\t\twhile (queue.size() > 0) {\n\t\t\tint index = get<1>(queue.top());\n\t\t\tdouble dist = get<0>(queue.top());\n\t\t\tqueue.pop();\n\t\t\tif (checked[index])continue;\n\n\t\t\tchecked[index] = true;\n\t\t\tres += dist;\n\n\t\t\tfor (int i = 0; i < graph[index].size(); i++) {\n\t\t\t\tint to = get<1>(graph[index][i]);\n\t\t\t\tdouble d = get<0>(graph[index][i]);\n\t\t\t\tif (checked[to])continue;\n\n\t\t\t\tqueue.emplace(make_tuple(d, to));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.3f\\n\", res);\n\t\t//cout << setprecision(8) << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<typename T> using V = std::vector<T>;\nusing Vi = V<int>;\nusing VVi = V<V<int>>;\nusing Vl = V<ll>;\nusing VVl = V<V<ll>>;\nusing Vs = V<string>;\n\ntemplate<typename T1, typename T2> using P = std::pair<T1, T2>;\nusing Pii = P<int, int>;\nusing Pll = P<ll, ll>;\nusing Pdd = P<double, double>;\n\ntemplate<typename T1, typename T2> using M = std::map<T1, T2>;\nusing Mii = M<int, int>;\nusing Msi = M<string, int>;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP2(i,s,e) for(int i=(int)(s);i<(int)(e);++i)\n#define RREP(i,s,e) for(int i=(int)(s);i>=(int)(e);--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(),ie=(c).end();i!=ie;++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double PI = acos(-1);\nconst ll MOD = 1e9+7;\n\nstruct UFTree {\n    static const int MAX_N = 1e6;\n    int p[MAX_N], r[MAX_N];\n\n    UFTree(int n) : p(), r() {\n        for(int i = 0; i < n; ++i) {\n            p[i] = i;\n            r[i] = 0;\n        }\n    }\n\n    int root(int x) {\n        return p[x] == x ? x : (p[x] = root(p[x]));\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n\n        if(r[x] < r[y]) {\n            p[x] = y;\n        } else {\n            p[y] = x;\n            if(r[x] == r[y]) r[x]++;\n        }\n    }\n};\n\nint n;\nstring s;\n\nstruct X {\n    double x, y, z, r;\n};\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n\n        UFTree t = UFTree(n);\n        V<X> xs(n);\n        REP(i, n) {\n            double x,y,z,r;\n            cin >> x >> y >> z >> r;\n            xs[i] = {x, y, z, r};\n        }\n\n        V<P<double, Pii>> edges(n*n-n);\n        int cnt = 0;\n        REP(i, n) REP(j, n) {\n            if (i == j) continue;\n            edges[cnt] = {\n                max(0.0,\n                    sqrt(\n                        pow(xs[i].x - xs[j].x, 2) +\n                        pow(xs[i].y - xs[j].y, 2) +\n                        pow(xs[i].z - xs[j].z, 2)\n                    ) - xs[i].r - xs[j].r\n                ),\n                {i, j}\n            };\n            cnt++;\n        }\n\n        sort(ALL(edges));\n        double res = 0;\n        FOR(i, edges) {\n            double c = i->first;\n            int x = i->second.first, y = i->second.second;\n            if (t.same(x, y)) continue;\n            t.unite(x, y);\n            res += c;\n        }\n        printf(\"%.3lf\\n\", res);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define invrepr(i,a,b) for(int i=b-1;i>=a;i--)\n#define invrep(i,n) invrepr(i,0,n)\n#define repitr(itr,a) for(auto itr=a.begin();itr!=a.end();++itr)\n#define P pair<int,int>\nconst int MOD=1e9+7;\nconst int INF=2e9;\n\ndouble dis(double x,double y,double z) {\n    return sqrt(x*x+y*y+z*z);\n}\n\nstruct UnionFind {\n    vector<int> par;\n    UnionFind(int N) : par(N) {\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) {\n        int rx = root(x);\n        int ry = root(y);\n        if (rx == ry) return;\n        par[rx] = ry;\n    }\n\n    bool same(int x, int y) {\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    vector<double> a;\n    while (1) {\n        int n;\n        cin >> n; \n        if (n==0) break;\n        vector<double> x(n),y(n),z(n),r(n);\n        rep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        UnionFind tree(n);\n        vector<pair<double,P>> d;\n        rep(i,n) {\n            rep(j,i) {\n                double dd=dis(x[i]-x[j],y[i]-y[j],z[i]-z[j])-(r[i]+r[j]);\n                if (dd<=0) tree.unite(i,j);\n                else d.push_back(make_pair(dd,make_pair(i,j)));\n            }\n        }\n        sort(d.begin(),d.end());\n        double ans=0.0;\n        rep(i,d.size()) {\n            if (!tree.same(d[i].second.first,d[i].second.second)) {\n                ans+=d[i].first;\n                tree.unite(d[i].second.first,d[i].second.second);\n            }\n        }\n        a.push_back(ans);\n    }\n    rep(i,a.size()) cout << fixed << setprecision(3) << a[i] << endl;\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point3D {\n\tdouble x, y, z;\n\n\tPoint3D() : x(0), y(0), z(0) {}\n\n\tPoint3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\tPoint3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }\n\n\tPoint3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }\n\n\tPoint3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }\n\n\tPoint3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }\n\n\tbool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point3D& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\treturn os;\n}\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }\n\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n\tPoint3D a, b;\n\n\tLine() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n\n\tLine(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \", \" << l.a.z <<  \")-(\" << l.b.x << \",\" << l.b.y << \", \" << l.b.z <<  \")\";\n\treturn os;\n}\n\nPoint3D project(Line l, Point3D p) {\n\tPoint3D base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nstruct Sphere {\n\tPoint3D p;\n\tdouble r;\n\n\tSphere() : p(Point3D(0, 0, 0)), r(0.0) {}\n\n\tSphere(Point3D p, double r) : p(p), r(r) {}\n};\n\nostream& operator << (ostream& os, const Sphere& s) {\n\tos << \"(\" << s.p.z << \", \" << s.p.y << \", \" << s.p.z << \" :\" << s.r << \")\";\n\treturn os;\n}\n\ndouble distanceSphSph(Sphere s1, Sphere s2) {\n\tPoint3D p = s2.p - s1.p;\n\tdouble dist = abs(p) - s1.r - s2.r;\n\treturn max(0.0, dist);\n}\n\nstruct UnionFind {\n\tvector<int> par,rank;\n\tint N;\n\n\tUnionFind(int n) {\n\t\tN = n;\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\n\t\trep(i,n) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint size() {\n\t\tint cnt = 0;\n\t\trep(i,N) if(find(i) == i) cnt++;\n\t\treturn cnt;\n\t}\n};\n\nstruct edge {\n\tint from,to;\n\tdouble cost;\n\n\tedge(int t, int c) : to(t),cost(c) {}\n\tedge(int f, int t, double c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\ndouble kruskal(int n, vector<edge> v) {\n\tsort(v.begin(),v.end());\n\tUnionFind uf(n);\n\n\tdouble ret = 0;\n\trep(i, v.size()) {\n\t\tedge e = v[i];\n\t\tif(!uf.same(e.from,e.to)) {\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tret += e.cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n && n) {\n\t\tvector<Sphere> s(n);\n\t\trep(i, n) cin >> s[i].p.x >> s[i].p.y >> s[i].p.z >> s[i].r;\n\n\t\tvector<edge> v;\n\t\trep(i, n) {\n\t\t\tREP(j, i+1, n) {\n\t\t\t\tdouble dist = distanceSphSph(s[i], s[j]);\n\t\t\t\tv.push_back(edge(i, j, dist));\n\t\t\t}\n\t\t}\n\n\t\tcout << fixed;\n\t\tcout.precision(3);\n\t\tcout << kruskal(n, v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nconst double EPS=1e-7;\nint N;\nint par[100];\ndouble x[100],y[100],z[100],r[100];\nvoid init(){\n    rep(i,N)par[i]=i;\n}\nint find(int x){\n    return x==par[x]?x:par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n    par[find(y)]=find(x);\n}\nbool same(int x,int y){\n    return find(x)==find(y);\n}\n\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N)cin>>x[i]>>y[i]>>z[i]>>r[i];\n        init();\n        vector<tuple<double,int,int>>vec;\n        rep(i,N)rep(j,N){\n            double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n            if(r[i]+r[j]+EPS>d)unite(i,j);\n            else vec.pb(make_tuple(d-r[i]-r[j],i,j));\n        }\n        sort(all(vec));\n        double ans=0;\n        rep(i,vec.size()){\n            double d;\n            int u,v;\n            tie(d,u,v)=vec[i];\n            if(same(u,v))continue;\n            ans+=d;\n            unite(u,v);\n        }\n        printf(\"%.3f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Sphere\n{\n  double x, y, z, r;\n  double getDist(const Sphere &other)\n  {\n    double res = sqrt(pow(x - other.x, 2) + pow(y - other.y, 2) + pow(z - other.z, 2)) - r - other.r;\n    if (res <= 0)\n    {\n      return 0;\n    }\n    return res;\n  }\n};\n\nstruct UnionFind\n{\n  vector<int> rank, p;\n  UnionFind(int n)\n  {\n    rank.resize(n, 0);\n    p.resize(n, 0);\n    for (int i = 0; i < n; i++)\n    {\n      p.at(i) = i;\n    }\n  }\n\n  int find(int x)\n  {\n    if (x != p.at(x))\n    {\n      p.at(x) = find(p.at(x));\n    }\n    return p.at(x);\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n\n  void link(int x, int y)\n  {\n    if (rank.at(x) > rank.at(y))\n    {\n      p.at(y) = x;\n    }\n    else\n    {\n      p.at(x) = y;\n      if (rank.at(x) == rank.at(y))\n      {\n        rank.at(y)++;\n      }\n    }\n  }\n\n  void unite(int x, int y)\n  {\n    link(find(x), find(y));\n  }\n};\n\nint main()\n{\n  while (1)\n  {\n    int n;\n    cin >> n;\n    if (!n)\n    {\n      break;\n    }\n    vector<Sphere> sp(n);\n    for (int i = 0; i < n; i++)\n    {\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      sp.at(i) = Sphere{x, y, z, r};\n    }\n    UnionFind uf(n);\n    vector<tuple<double, int, int>> edge;\n    for (int i = 0; i < n; i++)\n    {\n      for (int j = i + 1; j < n; j++)\n      {\n        double d = sp.at(i).getDist(sp.at(j));\n        if (d == 0)\n        {\n          uf.unite(i, j);\n          continue;\n        }\n        edge.push_back(make_tuple(d, i, j));\n      }\n    }\n    sort(edge.begin(), edge.end());\n    double ans = 0;\n    for (int i = 0; i < edge.size(); i++)\n    {\n      double d;\n      int s, t;\n      tie(d, s, t) = edge.at(i);\n      if (uf.same(s, t))\n      {\n        continue;\n      }\n      ans += d;\n      uf.unite(s, t);\n    }\n    printf(\"%.3f\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nusing P = pair<double, int>;\n\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\nvector<P> edge[101];\n\ndouble sq(double x)\n{\n    return x * x;\n}\n\ndouble dis(int i, int j)\n{\n    double d = sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n    return max(0.0, d - r[i] - r[j]);\n}\n\nint main()\n{\n    int n;\n    double res;\n\n    while(cin >> n && n)\n    {\n        res = 0.0;\n        for (int i = 0; i < n; ++i) {\n            edge[i].clear();\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n            for (int j = 0; j < i; ++j) {\n                double d = dis(i, j);\n                edge[i].push_back(P(d, j));\n                edge[j].push_back(P(d, i));\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> h;\n        fill_n(used, n, false);\n        h.push(P(0.0, 0));\n        for (int i = 0; i < n; ++i) {\n            P p = h.top(); h.pop();\n            int v = p.second;\n            res += p.first;\n            used[v] = true;\n            for (size_t j = 0; j < edge[v].size(); ++j)\n                if (! used[edge[v][j].second])\n                    h.push(edge[v][j]);\n        }\n        cout << fixed << setprecision(3) << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\nstruct Edge {\n  int from, to;\n  double cost;\n  Edge() { }\n  Edge(int from_, int to_, double cost_) : from(from_), to(to_), cost(cost_) { }\n  bool operator <(const Edge &rhs) const {\n    return cost < rhs.cost;\n  }\n};\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int v) : data(v, -1) { };\n  int root(int x){\n  \treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n  }\n  bool same(int x, int y){\n  \treturn root(x) == root(y);\n  }\n  void merge(int x, int y){\n  \tx = root(x), y = root(y);\n  \tif(x != y){\n  \t\tif(size(y) > size(x)) swap(x, y);\n  \t\tdata[x] += data[y]; data[y] = x;\n  \t}\n  }\n  int size(int x){\n  \treturn -data[root(x)];\n  }\n};\n\ndouble kruskal(const int v, vector<Edge> es) {\n\tsort(es.begin(), es.end());\n\tdouble ans = 0;\n\tUnionFind uf(v);\n\tfor(int i = 0; i < es.size(); ++i) {\n\t\tif(uf.same(es[i].from, es[i].to)) continue;\n\t\tuf.merge(es[i].from, es[i].to);\n\t\tans += es[i].cost;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\twhile (cin>>n, n) {\n\t\tvector<double>x(n), y(n), z(n), r(n);\n\t\tvector<Edge> e;\n\t\t\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tfor (int j=i+1; j<n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdouble d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\t\td -= r[i] + r[j];\n\t\t\t\t\td = max(0.0, d);\n\t\t\t\t\te.push_back(Edge(i, j, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout.setf(ios::fixed); cout.precision(3);\n\t\tcout << kruskal(n, e) << endl;\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst int INF = 10000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\tif(v == -1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble dist=(vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z);\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r)*(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r)*(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.5f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to;\n\tdouble cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstruct a\n{\n\tdouble x, y, z, r;\n};\nvector<a> v;\nint par[105];\nvector<edge> es;\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x == y) return;\n\tpar[y] = x;\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t}\n}\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tv.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, z, r;\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tv.push_back(a{ x, y, z, r });\n\t\t}\n\t\tes.clear();\n\t\tinit_UFT(n);\n\t\tREP(i, n)FOR(j, i + 1, n)\n\t\t{\n\t\t\tdouble dif = sqrt(pow((v[i].x - v[j].x), 2) + pow((v[i].y - v[j].y), 2) + pow((v[i].z - v[j].z), 2)) - v[i].r - v[j].r;\n\t\t\tif (dif > 0)\n\t\t\t{\n\t\t\t\tes.push_back(edge{ i, j, dif });\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunite(i, j);\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(es));\n\t\tdouble sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(par[es[i].from], par[es[i].to]))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << D10 << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAX_N = 100010;\nint par[MAX_N];\nint rnk[MAX_N];\nint siz[MAX_N];\n\nvoid init(int n) {\n    rep(i,n) {\n        par[i] = i;\n        rnk[i] = 0;\n        siz[i] = 1;\n    }\n}\n\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    int s = siz[x] + siz[y];\n    if (rnk[x] < rnk[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rnk[x] == rnk[y]) rnk[x]++;\n    }\n    siz[find(x)] = s;\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint size(int x) {\n    return siz[find(x)];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n != 0) {\n        vector<double> x(n), y(n), z(n), r(n);\n        rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        priority_queue<tuple<double, int, int>> q;\n        rep(i, n - 1) {\n            for (int j = i + 1; j < n; j++) {\n                double dx = x[i] - x[j], dy = y[i] - y[j], dz = z[i] - z[j];\n                double d = max(0.0, sqrt(dx * dx + dy * dy + dz * dz) - r[i] - r[j]);\n                q.push(make_tuple(-d, i, j));\n            }\n        }\n        double ans = 0;\n        init(n);\n        while (!q.empty()) {\n            auto p = q.top();\n            q.pop();\n            int a = get<1>(p), b = get<2>(p);\n            if (same(a, b)) continue;\n            double d = -get<0>(p);\n            ans += d;\n            unite(a, b);            \n        }\n        cout << fixed;\n        cout << setprecision(3) << ans << \"\\n\";\n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define MAX_V 500\n\ndouble cost[MAX_V][MAX_V]; // cost[u][v] ?????????u??????v???????????????\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;// V???????????°\n\n// ????°???¨?????¨??§?????????O(V^2)\n\n// ???????????????????????????????????????cost????¨?????????????????????¨\n\ndouble prim(){\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\t\n\tmincost[0] = 0;\n\t\n\tdouble total = 0;\n\t\n\twhile(true){\n\t\t\n\t\tint add_v = -1;\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (add_v == -1 || mincost[u] < mincost[add_v])){\n\t\t\t\tadd_v = u;\n\t\t\t}\n\t\t} // ??????????????????????±????\n\t\t\n\t\tif(add_v == -1){\n\t\t\tbreak;\n\t\t} // ??´??°???????????????????????´????????????\n\t\tused[add_v] = true;\n\t\ttotal += mincost[add_v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[add_v][u]);\n\t\t} // ???????????????????????????????°???????????????´??°\n\t}\n\treturn total;\n}\n\nstruct Sphere{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\n\ndouble dist(Sphere p1, Sphere p2){\n\tdouble ans;\n\tans = sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z)) - (p1.r + p2.r);\n\tif(ans <= 0){\n\t\tans = 0;\n\t}\n\treturn ans;\n}\n\nint main(){\n\t\n\tdouble ans;\n\t\n\tSphere ball[500];\n\t\n\twhile(true){\n\t\tcin >> V;\n\t\tif(V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tcin >> ball[i].x >> ball[i].y >> ball[i].z >> ball[i].r;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t}else{\n\t\t\t\t\tcost[i][j] = dist(ball[i], ball[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = prim();\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct UnionFind {\n    int node[110];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return node[x] < 0 ? x : find(node[x]);\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size(x) < size(y)) swap(x, y);\n        node[x] += node[y];\n        node[y] = x;\n    }\n\n    int size(int x) {\n        return -node[x];\n    }\n};\n\nstruct Elem {\n    int from, to;\n    double d;\n    bool operator<(const Elem &e) const {\n        return d < e.d;\n    }\n};\n\nconst double EPS = 1e-8;\n\ndouble coor[110][3], r[110];\ndouble dist(int p, int q) {\n    double val = 0;\n    for(int i=0; i<3; i++) {\n        double diff = coor[p][i] - coor[q][i];\n        val += diff * diff;\n    }\n    return max(0.0, sqrt(val) - r[p] - r[q]);\n}\n\nint main() {\n    int N;\n    while(1) {\n        scanf(\"%d\", &N);\n        if(N == 0) break;\n\n        for(int i=0; i<N; i++) {\n            scanf(\"%lf%lf%lf%lf\", &coor[i][0], &coor[i][1], &coor[i][2], &r[i]);\n        }\n\n        UnionFind uf;\n        vector<Elem> lines;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                double dist_ij = dist(i, j);\n                if(dist_ij < EPS) {\n                    uf.unite(i, j);\n                    continue;\n                }\n                lines.push_back(Elem{i, j, dist_ij});\n            }\n        }\n        sort(lines.begin(), lines.end());\n\n        double ans = 0.0;\n        for(auto e : lines) {\n            int s = e.from, t = e.to;\n            double cost = e.d;\n            if(uf.same(s, t)) continue;\n            uf.unite(s, t);\n            ans += cost;\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<0)x=0;\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<fixed<<setprecision(3)<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i){\n      double a,b,c,d;\n      cin >> a >> b >> c >> d;\n      cell.push_back(P(a,b,c,d));\n    }\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    cout << fixed << setprecision(3) << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS 0.0001\n\ntypedef struct {\n  double x;\n  double y;\n  double z;\n  double r;\n} Cell;\n\nbool eq(double a, double b){\n  return abs(a-b) < EPS;\n}\n\ndouble cellLength( Cell a, Cell b){\n  double l = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)) - (a.r + b.r);\n  if(l <= 0) return 0;\n  else return l;\n}\n\nint main(void){\n  int n;\n  double btw[101][101];\n  Cell cell[101];\n  while(cin >> n, n){\n    for(int i=0; i < n; i++){\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      Cell tmp = {x, y, z, r};\n      cell[i] = tmp;\n    }\n\n    for(int p=0; p < n; p++){\n      for(int q=0; q < n; q++){\n        btw[p][q] = cellLength(cell[p], cell[q]);\n      }\n    }\n\n    //prim\n    double mincost[101];\n    bool used[101];\n    for(int i=0; i < n; i++){\n      mincost[i] = INT_MAX-1;\n      used[i] = false;\n    }\n    mincost[0] = 0;\n    double res = 0;\n\n    while(true){\n      int v = -1;\n      for(int u=0; u < n; u++){\n        if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n      }\n\n      if(v == -1) break;\n      used[v] = true;\n      res += mincost[v];\n\n      for(int u=0; u < n; u++){\n        mincost[u] = min(mincost[u], btw[v][u]);\n      }\n    }\n    printf(\"%.3f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <float.h>\n#include <math.h>\n#include <stdio.h>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntypedef struct {\n  float x,y,z,r;\n} Cell;\n\nint main(void)\n{\n  while (1) {\n    int n,i;\n    Cell v[100];\n    int vlen=0;\n    float G [100][100];\n    for (int i=0;i<100;++i)\n      for(int j=0;j<100;++j)\n\tG[i][j]=FLT_MAX;\n     \n    scanf(\"%d\",&n);\n    if( n==0 )\n      break;\n   \n    for(i=0;i<n;++i){ \n      float x,y,z,r;\n      scanf(\"%f %f %f %f\",&x,&y,&z,&r);\n      for(int j=0; j<vlen; ++j){\n\tfloat dx = x - v[j].x;\n\tfloat dy = y - v[j].y;\n\tfloat dz = z - v[j].z;\n\tfloat d = sqrt(dx*dx + dy*dy + dz*dz) - (v[j].r + r);\n\tif (d<=0){\n\t  G[i][j] = 0.0;\n\t  G[j][i] = 0.0;\n\t} else {\n\t  G[i][j] = d;\n\t  G[j][i] = d;\n\t}\t\n      }\n\n      Cell const c = { x, y, z, r };\n      v[vlen] = c;\n      ++vlen;\n    }\n    float sum = 0.0;\n    float d[100];\n    bool visited[100];\n    std::fill( d, d+100, FLT_MAX );\n    std::fill( visited, visited+100, false );\n\n    puts(\"\");\n\n    //initialize\n    int u = 0;\n    d[0] = 0;\n\n    for( int i=0; i<n; ++i ) {\n      float tmp = FLT_MAX;\n      for( int j=0; j<n; ++j ) {\n\tif ( !visited[j] && d[j] < tmp ) {\n\t  tmp = d[j];\n\t  u = j;\n\t}\n      }\n      sum += d[u];\n      visited[u] = true;\n\n      for(int j=0; j<n; ++j ) {\n\tif ( !visited[j] && G[u][j] < d[j] ) {\n\t  d[j] = G[u][j];\n\t}\n      }\n    }\n    printf( \"%.3lf\\n\", sum );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst double EPS = 1e-10;\n\nint n;\ndouble x[110], y[110], z[110], r[110];\n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       for(int i = 0; i < n; i++) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nstruct edge{\n    int u, v;\n    double cost;\n    bool operator<(const edge &e) const{\n        return cost < e.cost;\n    }\n};\n\nvector<edge> es; \n\ndouble kruskal(){\n    double res = 0;    \n    UF uf(n);\n    sort(es.begin(), es.end());\n    for(int i = 0; i < es.size(); i++){\n        edge e = es[i];\n        if(!uf.same(e.u, e.v)){\n            uf.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\ndouble dist(int i, int j){\n    return sqrt((x[j]-x[i])*(x[j]-x[i]) + (y[j]-y[i])*(y[j]-y[i]) + (z[j]-z[i])*(z[j]-z[i]));\n}\n\nsigned main(){\n    while(cin >> n, n){\n        es.clear();\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                double tmp = dist(i, j) - r[i] - r[j];\n                if(tmp < EPS) tmp = 0.0;\n                es.push_back({i, j, tmp});\n            }\n        }\n        double ans = kruskal();\n        printf(\"%.3f\\n\", ans);\n    }    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate <class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct sphere{\n\tdouble x,y,z,r;\n\t//sphere(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\ndouble dist(const sphere &left, const sphere &right){\n\tdouble p=sqrt(pow(left.x-right.x,2)+pow(left.y-right.y,2)+pow(left.z-right.z,2));\n\tdouble d=p-left.r-right.r;\n\tif(d<EPS){\n\t\treturn 0.000;\n\t}else{\n\t\treturn d;\n\t}\n}\n#define MAX INT_MAX/10\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<sphere> s(n);\n\t\tREP(i,n){\n\t\t\tcin>>s[i].x>>s[i].y>>s[i].z>>s[i].r;\n\t\t}\n\n\t\tvvd d(n,vd(n,MAX));\n\n\t\tREP(i,n)REP(j,n){\n\t\t\td[i][j]=dist(s[i],s[j]);\n\t\t}\n\n\t\tvi dones(n,0);\n\t\tdones[0]=1;\n\n\t\tdouble res=0;\n\t\twhile(find(ALL(dones),0)!=dones.end()){\n\t\t\tdouble mindist=MAX;\n\t\t\tint minindex=-1;\n\t\t\tREP(i,n){\n\t\t\t\tif(dones[i]){\n\t\t\t\t\tREP(j,n){\n\t\t\t\t\t\tif(!dones[j]){\n\t\t\t\t\t\t\tif(mindist>d[i][j]){\n\t\t\t\t\t\t\t\tmindist=d[i][j];\n\t\t\t\t\t\t\t\tminindex=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(minindex!=-1);\n\t\t\tres+=mindist;\n\t\t\tdones[minindex]=1;\n\t\t}\n\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct UnionFind {\n    int* parent;\n    int N;\n    UnionFind(int N) : N(N) {\n        parent = new int[N];\n        fill(parent, parent + N, -1);\n    }\n    ~UnionFind() {\n        delete[] parent;\n    }\n    int root(int x) {\n        if (parent[x] == -1) return x;\n        return parent[x] = root(parent[x]);\n    }\n    bool query(int x, int y) {\n        return root(x) == root(y);\n    }\n    void merge(int x, int y) {\n        x = root(x); \n        y = root(y);\n        if (x != y) {\n            parent[x] = y;\n        }\n    }\n};\n\nint N;\n#define L 100\ndouble x[L], y[L], z[L], r[L];\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    return true;\n}\n\nconst double INF = 1e20;\nstruct Kruskal {\n    struct Edge {\n        int from, to;\n        double cost;\n        Edge(int from, int to, double cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            return cost < e.cost;\n        }\n    };\n    vector<Edge> G;\n    Kruskal() {\n        G.clear();\n    }\n    void addEdge(int from, int to, double cost) {\n        G.push_back(Edge(from, to, cost));\n    }\n    double solve() {\n        UnionFind uf(N);\n        sort(whole(G));\n        double Ret = 0;\n        for (int i = 0; i < G.size(); i++) {\n            if (!uf.query(G[i].from, G[i].to)) {\n                uf.merge(G[i].from, G[i].to);\n                Ret += G[i].cost;\n            }\n        }\n        return Ret;\n    }\n};\n\n#define POW2(x) ((x) * (x))\ndouble Dist(int a, int b) {\n    return sqrt(POW2(x[a] - x[b]) + POW2(y[a] - y[b]) + POW2(z[a] - z[b])) - (r[a] + r[b]);\n}\n\nvoid solve() {\n    Kruskal K;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            K.addEdge(i, j, max(0.0, Dist(i, j)));\n        }\n    }\n    printf(\"%.8lf\\n\", K.solve());\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\n#define uni(x) x.erase(unique(all(x)),x.end())\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<double, P> edge;\n#define INF INT_MAX/3\n#define MAX_N 1000\n#define M_INF 1000000000\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n;\ndouble x[111],y[111],z[111],r[111];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0) break;\n    rep(i,n) cin>>x[i]>>y[i]>>z[i]>>r[i];\n    UnionFind uf(n);\n    std::vector<edge> es;\n    rep(i,n) rep(j,i){\n      double dist=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2));\n      if(dist<=r[i]+r[j]){\n        uf.unite(i,j);\n      }else{\n        es.push_back(edge(dist-r[i]-r[j],P(i,j)));\n      }\n    }\n    double res= 0;\n    sort(all(es));\n    rep(i,es.size()){\n      if(uf.same(es[i].se.fi,es[i].se.se)) continue;\n      else {\n        uf.unite(es[i].se.fi,es[i].se.se);\n        res += es[i].fi;\n      }\n    }\n     printf(\"%.3f\\n\", res);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll INF = 1001001001;\nconst double EPS = 1e-10;\nstruct Edge { ll to, cost; };\nusing Graph = vector<vector<Edge>>;\n\nstruct edge{ll from,to; double cost;};\n\nbool comp(edge& e1, edge& e2){return e1.cost<e2.cost;}\n\nstruct UnionFind {\n    vector<int> d;\n    UnionFind(int n): d(n, -1) {}\n    int root(int x) {\n        if (d[x] < 0) return x;\n        return d[x] = root(d[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (d[x] > d[y]) swap(x, y);\n        d[x] += d[y];\n        d[y] = x;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -d[root(x)]; }\n};\n\ndouble kruskal(int n,vector<edge> g){\n    sort(g.begin(),g.end(),comp);\n    UnionFind uf(n);\n    double res=0;\n    for(auto e:g){\n        ll a=e.from,b=e.to;\n        double c=e.cost;\n        if(!uf.same(a,b)){\n            uf.unite(a,b);\n            res+=c;\n        }\n    }\n    return res;\n}\n\ndouble getDist(double x1,double x2,double y1,double y2,double z1,double z2,double r1, double r2){\n    return sqrt(pow(x1-x2,2)+pow(y1-y2,2)+pow(z1-z2,2))-(r1+r2);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n&&n){\n        vector<edge> g;\n        double x[n],y[n],z[n],r[n];\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>z[i]>>r[i];\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                double t=getDist(x[i],x[j],y[i],y[j],z[i],z[j],r[i],r[j]);\n                if(t<EPS){\n                    g.emplace_back((edge){i,j,0});\n                    g.emplace_back((edge){j,i,0});\n                }else{\n                    g.emplace_back((edge){i,j,t});\n                    g.emplace_back((edge){j,i,t});\n                }\n            }\n        }\n        double ans=kruskal(n,g);\n        cout<<fixed<<setprecision(3)<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\ndouble EPS = 1e-9;\n\nint n;\ndouble x[110], y[110], z[110], r[110];\n\ndouble pow2(double x) { return x * x; }\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n\treturn sqrt( pow2(x1 - x2) + pow2(y1 - y2) + pow2(z1 - z2) );\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) {}\n\t\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\t\n\tbool sameSet(int x, int y) { return root(x) == root(y); }\n\t\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\t\n\tint size(int x) { return -data[root(x)]; }\n};\n\nstruct Edge {\n\tint f, t; double c;\n\tEdge(int _f, int _t, double _c) : f(_f), t(_t), c(_c) {}\n};\nbool operator < (const Edge& a, const Edge& b) { return a.c + EPS < b.c; }\n\nvoid solve() {\n\tvector<Edge> edges;\n\t\n\tfor_(i,0,n) for_(j,i + 1,n) {\n\t\tdouble d = dist(x[i], y[i], z[i], x[j], y[j], z[j]);\n\t\tedges.push_back( Edge(i, j, max(0.0, d - r[i] - r[j])) );\n\t}\n\t\n\tsort(allof(edges));\n\t\n\tUnionFind uf(n);\n\tdouble ans = 0.0;\n\tint e_size = size_of(edges);\n\t\n\tfor_(i,0,e_size) {\n\t\tEdge e = edges[i];\n\t\tif (!uf.sameSet(e.f, e.t)) {\n\t\t\tuf.unionSet(e.f, e.t);\n\t\t\tans += e.c;\n\t\t}\n\t}\n\t\n\tprintf(\"%.3lf\\n\", ans);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor_(i,0,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\nint main() {\n\tint n;\n\twhile (cin >> n,n) {\n\t\tvector<pos3> cic(n);\n\t\tvector<pair<double, pii>> dis;\n\t\tREP(i, n)\n\t\t\tcin >> cic[i].x >> cic[i].y >> cic[i].z >> cic[i].r;\n\t\tREP(i,n-1)\n\t\t\tFOR(j, i + 1, n) {\n\t\t\tdouble d = sqrt((cic[i].x - cic[j].x)*(cic[i].x - cic[j].x) +\n\t\t\t\t(cic[i].y - cic[j].y)*(cic[i].y - cic[j].y) +\n\t\t\t\t(cic[i].z - cic[j].z)*(cic[i].z - cic[j].z))-cic[i].r-cic[j].r;\n\t\t\tdis.push_back({ d,{i,j}});\n\t\t}\n\t\tSORT(dis);\n\t\tUnionFind uf(n);\n\t\tdouble ans = 0.0;\n\t\tREP(i, dis.size()) {\n\t\t\tif (uf.find(dis[i].second.first) == uf.find(dis[i].second.second))\n\t\t\t\tcontinue;\n\t\t\tuf.unite(dis[i].second.first, dis[i].second.second);\n\t\t\tans += max(0.0,dis[i].first);\n\t\t\tint cnt = 0;\n\t\t\tREP(j, n) {\n\t\t\t\tif (uf.find(0) == uf.find(j))\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt == n)break;\n\t\t}\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n  \nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tdouble x[101], y[101], z[101], r[101];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tdouble kyori_pow2[101][101];\n\t\tbool ischecked[101];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tkyori_pow2[i][i] = 0.0;\n\t\t\tischecked[i] = false;\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdouble k = sqrt(pow((x[i] - x[j]), 2) + pow((y[i] - y[j]), 2) + pow((z[i] - z[j]), 2));\n\t\t\t\tkyori_pow2[i][j] = max(0.0, k - r[i] - r[j]);\n\t\t\t\tkyori_pow2[j][i] = max(0.0, k - r[i] - r[j]);\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0.0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble mind = 10000000.0;\n\t\t\tint j = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(ischecked[k]) continue;\n\t\t\t\tif(kyori_pow2[0][k] < mind){\n\t\t\t\t\tmind = kyori_pow2[0][k];\n\t\t\t\t\tj = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j == -1) break;\n\t\t\tans += mind;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tkyori_pow2[0][k] = min(kyori_pow2[0][k], kyori_pow2[j][k]);\n\t\t\t}\n\t\t\tischecked[j] = true;\n\t\t}\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    double x, y, z, r;\n};\n\nstruct Edge {\n    int a, b;\n    double cost;\n\n    bool operator<(const Edge& o) const {\n        return cost < o.cost;\n    }\n};\n\nstruct UnionFind {\n    vector<int> v;\n    UnionFind(int size) : v(size, -1) { }\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (v[y] < v[x]) swap(x, y);\n            v[x] += v[y]; v[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n    int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n    int size(int x) { return -v[find(x)]; }\n};\n\nstruct Graph {\n    int n;\n    vector<Edge> es;\n\n    double kruskal() {\n        UnionFind uf(n);\n        SORT(es);\n\n        double total = 0;\n        REP(ei, es.size()) {\n            Edge& e = es[ei];\n            if (!uf.same(e.a, e.b)) {\n                uf.unite(e.a, e.b);\n                total += e.cost;\n            }\n        }\n        return total;\n    }\n};\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<P> p(N);\n        Graph g;\n        g.n = N;\n        REP(i, N) {\n            cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n        }\n        REP(i, N) {\n            FOR(j, i+1, N) {\n                double d = sqrt(SQ(p[i].x - p[j].x) + SQ(p[i].y - p[j].y) + SQ(p[i].z - p[j].z)) - p[i].r - p[j].r;\n                if (d < 0) d = 0;\n                g.es.push_back({i, j, d});\n            }\n        }\n        printf(\"%.3f\\n\", g.kruskal());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r}),parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=0;j<i;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstruct edge{\n\tint a,b;\n\tdouble d;\n\tedge(int p,int q,double r){a=p,b=q,d=r;}\n};\nbool comp(const edge &l,const edge &r){\n\treturn l.d<r.d;\n}\nint par[100];\nvoid init(int N){rep(i,N) par[i]=i;}\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tpar[y]=x;\n}\ndouble x[100],y[100],z[100],r[100];\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tvector<edge> es;\n\t\trep(i,N) rep(j,i){\n\t\t\tdouble dis=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j];\n\t\t\tes.pb(edge(i,j,max(dis,0.0)));\n\t\t}\n\t\tsort(all(es),comp);\n\t\tinit(N);\n\t\tdouble ans=0;\n\t\tfor(edge e:es){\n\t\t\tif(same(e.a,e.b)) continue;\n\t\t\tunite(e.a,e.b);\n\t\t\tans+=e.d;\n\t\t}\n\t\tprintf(\"%.3f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ndouble dist(double x1, double y1, double z1,\n            double x2, double y2, double z2 ){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2) );\n}\n\nconst double INF = (double)(1<<30);\ndouble G[100][100];\ndouble mindist[100];\nbool used[100];\ndouble x[100], y[100], z[100], r[100];\n\nint main(){\n    int n, i, j;\n    while(cin>>n,n){\n        for(i = 0; i < n; i++) used[i] = false;\n        for(i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        for(i = 0; i < n; i++){\n            for(j = 0; j < n; j++){\n                if( i == j ) G[i][j] = 0.0;\n                double d = dist(x[i],y[i],z[i],x[j],y[j],z[j]);\n                if( d <= r[i] + r[j] ){\n                    G[i][j] = 0.0;\n                    G[j][i] = 0.0;\n                }else{\n                    G[i][j] = d - r[i] - r[j];\n                    G[j][i] = d - r[i] - r[j];\n                }\n            }\n        }\n        used[0] = true;\n        double ans = 0.0;\n        for(i = 0; i < n; i++){\n            mindist[i] = G[0][i];\n        }\n        for(i = 0; i < n; i++){\n            int id = -1;\n            double m = INF;\n            for(j = 0; j < n; j++){\n                if( used[j] ) continue;\n                if( mindist[j] < m ){\n                    m = mindist[j];\n                    id = j;\n                }\n            }\n            if( id == -1 ) break;\n            used[id] = true;\n            ans += m;\n            for(j = 0; j < n; j++){\n                mindist[j] = min( mindist[j], G[id][j] );\n            }\n        }\n        printf(\"%.3lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef double db;\n\ndb dist(db x1,db y1,db z1,db x2,db y2,db z2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n}\n\nconst db INF=(db)(1<<30);\ndb G[100][100];\ndb mindist[100];\nbool used[100];\ndb x[100],y[100],z[100],r[100];\n\nint main(){\n    int n, i, j;\n    while(cin>>n,n){\n        for(i=0;i<n;i++) cin>>x[i]>>y[i]>>z[i]>>r[i];\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n                db d=dist(x[i],y[i],z[i],x[j],y[j],z[j]);\n                G[i][j]=d-r[i]-r[j]>=0?d-r[i]-r[j]:0.0;\n            }\n        }\n        db ans=0.0;\n        for(i=0;i<n;i++){\n            mindist[i]=G[0][i];\n            used[i]=false;\n        }\n        used[0]=true;\n        for(i=0;i<n;i++){\n            int id=-1;\n            db m=INF;\n            for(j=0;j<n;j++){\n                if(used[j]) continue;\n                if(mindist[j]<m){\n                    m=mindist[j];id=j;\n                }\n            }\n            if(id==-1)break;\n            used[id]=true;\n            ans+=m;\n            for(j=0;j<n;j++)\n                mindist[j]=min(mindist[j],G[id][j]);\n        }\n        printf(\"%.3lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef pair<double, int> P;\n\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\nvector<P> edge[101];\n\ndouble sq(double x)\n{\n    return x * x;\n}\n\ndouble dis(int i, int j)\n{\n    double d = sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n    return max(0.0, d - r[i] - r[j]);\n}\n\nint main()\n{\n    int n;\n    double res;\n\n    while(cin >> n && n)\n    {\n        res = 0.0;\n        for (int i = 0; i < n; ++i) {\n            edge[i].clear();\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n            for (int j = 0; j < i; ++j) {\n                double d = dis(i, j);\n                edge[i].push_back(P(d, j));\n                edge[j].push_back(P(d, i));\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> h;\n        fill_n(used, n, false);\n        h.push(P(0.0, 0));\n        while (n) {\n            P p = h.top(); h.pop();\n            int v = p.second;\n            if (used[v]) continue;\n            --n;\n            res += p.first;\n            used[v] = true;\n            for (size_t j = 0; j < edge[v].size(); ++j)\n                if (! used[edge[v][j].second])\n                    h.push(edge[v][j]);\n        }\n        cout << fixed << setprecision(3) << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst int MAX = 100;\n\nint par[MAX];\nint rnk[MAX];\nint nodeNum[MAX];\n\nvoid init(int n) {\n\tfor(int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tnodeNum[i] = 1;\n\t}\n}\n\nint find(int x) {\n\tif(par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rnk[x] < rnk[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n\tnodeNum[x] = nodeNum[y] = nodeNum[x] + nodeNum[y];\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\ntypedef double W;\nstruct edge {\n\tint u, v;\n\tW cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\n\nW kruskal(int V, int E) {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tW res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble x[100], y[100], z[100], r[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tes.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\t\tdouble d = sqrt((x[i] - x[j]) * (x[i] - x[j]) +\n\t\t\t\t\t(y[i] - y[j]) * (y[i] - y[j]) +\n\t\t\t\t\t(z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\td = max(0.0, d - r[i] - r[j]);\n\t\t\t\tes.push_back(edge{ i, j, d });\n\t\t\t}\n\t\t}\n\t\tdouble ans = kruskal(N, es.size());\n\t\tcout << setprecision(12) << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nstruct edge {\n\tint from, to;\n\tld cost;\n\tedge() {}\n\tedge(int from, int to, ld cost) : from(from), to(to), cost(cost) {}\n};\n\nbool operator<(const edge& l, const edge& r){\n\treturn l.cost < r.cost;\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tvector<int> rank;\n\tint root(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = root(data[a]);\n\t}\npublic:\n\tUnionFind(int n) : data(n, -1), rank(n, 1) {}\n\tbool Find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tvoid Union(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] < rank[b]) {\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t}\n\t\telse {\n\t\t\tdata[b] += data[a];\n\t\t\tdata[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint Size(int a) {\n\t\treturn -data[root(a)];\n\t}\n\tint Rank(int a) {\n\t\treturn rank[root(a)];\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(3);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<ld> x(n), y(n), z(n), r(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tld dx = x[j] - x[i], dy = y[j] - y[i], dz = z[j] - z[i];\n\t\t\t\tes.emplace_back(i, j, max((ld)0, sqrtl(dx * dx + dy * dy + dz * dz) - r[i] - r[j]));\n\t\t\t}\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tld res = 0;\n\t\tUnionFind uf(n);\n\t\tfor (auto e : es) {\n\t\t\tif (uf.Find(e.from, e.to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += e.cost;\n\t\t\tuf.Union(e.from, e.to);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;double cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\ndouble kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { double x, y, z, r; };\ndouble dis(point a,point b) {\n\tdouble res;\n\tres = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n\tres -= a.r + b.r;\n\tif (res < 0) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[100];\n\t\tdouble x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(5) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\n\n#define max_n 100\n#define max_e (max_n * max_n)\n\ndouble c[max_n][4];\n\ndouble d(int a, int b){\n    double x = c[a][0] - c[b][0];\n    double y = c[a][1] - c[b][1];\n    double z = c[a][2] - c[b][2];\n    double ret = sqrt(x*x + y*y + z*z);\n    ret = ret - c[a][3] - c[b][3];\n    return ret;\n}\n\n\n\n\n\nclass UnionFind{\n\nprivate:\n    vector<int> rank,p;\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n    }\n\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        for(int i = 0; i < size; i++){\n          makeSet(i);\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n      link(find(x), find(y));\n    }\n\n    int find(int x){\n      if(x != p[x]) p[x] = find(p[x]);\n      return p[x];\n    }\n\nprivate:\n    void link(int x, int y){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n      }else{\n        p[x] = y;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\n\n\n\nstruct edge{\n     int u, v;\n     double cost;\n };\n\nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\nedge es[max_e];\nint v,e;\n\ndouble kruskal(){\n    sort(es, es+e, comp);\n    UnionFind uf = UnionFind(v);\n    double ret = 0;\n    int i;\n    rep(i,e){\n        edge ee = es[i];\n        if(!uf.same(ee.u, ee.v)){\n            uf.unite(ee.u, ee.v);\n            if(ee.cost > EPS)ret += ee.cost;\n        }\n    }\n    return ret;\n}\n\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        v = n;\n        e = 0;\n\n        rep(i,n)rep(j,4) cin >> c[i][j];\n        double ans = 0;\n        rep(i,n)rep(j,i){\n            edge ee;\n            ee.u = i;\n            ee.v = j;\n            ee.cost = d(i,j);\n            es[e] = ee;\n            e++;\n        }\n\n        cout << shosu(3) << kruskal() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nconst double EPS=1e-7;\nint N;\nint par[100];\ndouble x[100],y[100],z[100],r[100];\nvoid init(){\n    rep(i,N)par[i]=i;\n}\nint find(int x){\n    return x==par[x]?x:par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n    par[find(y)]=find(x);\n}\nbool same(int x,int y){\n    return find(x)==find(y);\n}\n\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N)cin>>x[i]>>y[i]>>z[i]>>r[i];\n        init();\n        vector<tuple<double,int,int>>vec;\n        rep(i,N)rep(j,N){\n            double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n            if(r[i]+r[j]+EPS>d)unite(i,j);\n            else vec.pb(make_tuple(d-r[i]-r[j],i,j));\n        }\n        sort(all(vec));\n        double ans=0;\n        rep(i,vec.size()){\n            double d;\n            int u,v;\n            tie(d,u,v)=vec[i];\n            if(same(u,v))continue;\n            ans+=d;\n            unite(u,v);\n        }\n        printf(\"%.20f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef double Weight;\nconst Weight INF = 1e9;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int f, int t, Weight c) :\n        src(f), dst(t), weight(c) {}\n};\nbool operator<(const Edge &a, const Edge &b) {\n    return a.weight != b.weight ? a.weight > b.weight :\n        a.src != b.src ? a.src < b.src : a.dst < b.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nWeight Prim(const Graph &g, int r = 0) {\n    int n = g.size();\n    Edges T;\n    Weight total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<Edge> que;\n    que.push(Edge(-1, r, 0));\n\n    while (!que.empty()) {\n        Edge e = que.top();  que.pop();\n        if (visited[e.dst])\n            continue;\n        T.push_back(e);\n        total += e.weight;\n        visited[e.dst] = true;\n        for (auto f = g[e.dst].begin(); f != g[e.dst].end(); ++f)\n            if (!visited[f->dst])\n                que.push(*f);\n    }\n\n    return total;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(3) << setiosflags(ios::fixed); // printf(\"%.4f\", x);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        Graph g(n);\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                double d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])\n                    + (z[i] - z[j]) * (z[i] - z[j]);\n\n                if (d <= (r[i] + r[j]) * (r[i] + r[j]))\n                    d = 0.0;\n                else\n                    d = sqrt(d) - r[i] - r[j];\n\n                g[i].push_back(Edge(i, j, d));\n                g[j].push_back(Edge(j, i, d));\n            }\n\n        cout << Prim(g) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T>& V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> >& Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T>& mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct UnionFind{\n    vector<int> parent, rank;\n    UnionFind(int n) : parent(n, -1), rank(n, 0) { }\n    int find(int x){\n        if(parent[x] == -1) return x;\n        else return (parent[x] = find(parent[x]));\n    }\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(rank[x] < rank[y])\n            parent[x] = y;\n        else\n            parent[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\nstruct P{\n    double x,y,z,r;\n    P(){}\n    P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n    double operator - (const P& o){\n        return max(0.0,sqrt((x-o.x)*(x-o.x)+(y-o.y)*(y-o.y)+(z-o.z)*(z-o.z)) - r - o.r);\n    }\n};\n\ntemplate<class Type>\nType solve(Type res = Type()){\n    int n;\n    while(cin >> n,n){\n        vector<P> Ps(n);\n        for(int i = 0; i < n;i++){\n            double x,y,z,r;cin >> x >> y >> z >> r;\n            Ps[i] = P(x,y,z,r);\n        }\n        \n        using Item = tuple<double,int,int>;\n        priority_queue<Item,vector<Item>,greater<Item>> pq;\n        for(int i = 0; i < n;i++){\n            for(int j = i+1;j<n;j++){\n                pq.push(Item(Ps[i]-Ps[j],i,j));\n            }\n        }\n        UnionFind UF(n);\n        double ans = 0;\n        while(pq.size()){\n            double cost; int u,v;\n            tie(cost,u,v) = pq.top(); pq.pop();\n            if(UF.same(u, v)) continue;\n            ans += cost;\n            UF.unite(u, v);\n        }\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve(0);\n    //cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n\n#define WHITE 0\n#define EPS 1e-10\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 1000\n#define INF 999999999.99\n\nlong double x[MAX_N][MAX_N];\nlong double MIN[MAX_N], color[MAX_N];\nlong double X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nlong double b, sum, sum_min;\nint n, c, a;\n\nvoid prim() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tMIN[j] = INF;\n\t\t\tcolor[j] = WHITE;\n\t\t}\n\t\tb = INF;\n\t\ta = n;\n\t\tcolor[i] = GRAY;\n\t\tMIN[i] = 0;\n\t\twhile (a != 0) {\n\t\t\tb = INF;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor[c] = BLACK;\n\t\t\ta -= 1;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (color[k] != BLACK && x[c][k] >= -EPS) {\n\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum += MIN[j];\n\t\t}\n\t\tsum_min = min(sum_min, sum);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tsum_min = INF;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tX[i] = 0; Y[i] = 0; Z[i] = 0;\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = -INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tlong double X1 = (X[i] - X[j])*(X[i] - X[j]);\n\t\t\t\tlong double Y1 = (Y[i] - Y[j])*(Y[i] - Y[j]);\n\t\t\t\tlong double Z1 = (Z[i] - Z[j])*(Z[i] - Z[j]);\n\t\t\t\tlong double dist = sqrtl(X1 + Y1 + Z1);\n\t\t\t\tlong double dist2 = dist - R[i] - R[j];\n\t\t\t\tx[i][j] = max(0.0l, dist2);\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tsum_min *= 10000;\n\t\tsum_min += 5;\n\t\tsum_min /= 10;\n\t\tint RES = sum_min;\n\t\tcout << RES / 1000 << '.' << RES % 1000 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\n\ndouble dist(Point3D a, Point3D b) {\n  return sqrt((pow(a.x-b.x, 2)+pow(a.y-b.y, 2)+pow(a.z-b.z, 2)));\n}\n\nstruct UnionFind{\n  int n;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\nint main() {\n  int n;\n  while ( cin >> n, n ) {\n    vector<Point3D> c(n);\n    vector<double> r(n);\n    for ( int i = 0; i < n; i++ ) {\n      cin >> c[i].x >> c[i].y >> c[i].z >> r[i];      \n    }\n\n    typedef pair<int, int> P;\n    typedef pair<double, P> Edge;\n    vector<Edge> edges;\n    for ( int i = 0; i < n; i++ ) {\n      for ( int j = i+1; j < n; j++ ) {\n\tedges.push_back(Edge(max(0.0, dist(c[i], c[j])-r[i]-r[j]), P(i, j)));\t\n      }\n    }\n\n    UnionFind uf(n);\n    sort(edges.begin(), edges.end());\n    int cnt = 0;\n    double ans = 0;\n    for ( int i = 0; i < (int)edges.size(); i++ ) {\n      int a = edges[i].second.first, b = edges[i].second.second;\n      double c = edges[i].first;\n      if ( uf.same(a, b) ) continue;\n      uf.unite(a, b);\n      ans += c;\n      cnt++;\n      if ( cnt >= n-1 ) break;\n    }\n\n    printf(\"%.3lf\\n\", ans);    \n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<double,pi> P;\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nint n;\ndouble x[100],y[100],z[100],r[100];\n\ninline double dist(int i, int j)\n{\n    return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]) );\n}\n\ninline double make_edge(int i, int j)\n{\n    double ret=dist(i,j)-r[i]-r[j];\n    return ret>0?ret:0;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %lf %lf %lf %lf\", &x[i], &y[i], &z[i], &r[i]);\n\n        vector<P> e;\n        rep(i,n)rep(j,i) e.pb(P(make_edge(i,j),pi(i,j)));\n        sort(all(e));\n\n        double ans=0;\n        UF uf(n);\n        rep(i,e.size())\n        {\n            int a=e[i].se.fi, b=e[i].se.se;\n            if(!uf.same(a,b))\n            {\n                uf.unite(a,b);\n                ans+=e[i].fi;\n            }\n\n            if(uf.size(0)==n) break;\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<double, P> PDP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 100\n\nstruct Point {\n  double x, y, z, r;\n};\n\nPoint p[MAX_N];\nint parent[MAX_N];\ndouble ans;\n\ndouble distance(int i, int j) {\n  return sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y)\n           + (p[i].z - p[j].z) * (p[i].z - p[j].z));\n}\n\ndouble  corridor(int i, int j) {\n  double d = distance(i, j);\n  if (d > p[i].r + p[j].r) return d - (p[i].r + p[j].r);\n  else return 0;\n}\n\nint find(int i) {\n  if (i == parent[i]) return i;\n  return parent[i] = find(parent[i]);\n}\n\nvoid unite(PDP v) {\n  int x = find(v.se.fi), y = find(v.se.se);\n  if (x == y) return;\n\n  parent[y] = x;\n  ans += v.fi;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n\n  while(cin >> n, n) {\n    rep(i, n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n    vector<PDP> v;\n    rep(i, n - 1)repl(j, i + 1, n)  v.pb(PDP(corridor(i, j), P(i, j)));\n    rep(i, n) parent[i] = i;\n\n    sort(all(v));\n    ans = 0;\n\n    rep(i, v.size()) unite(v[i]);\n\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\ndouble dd(double a) {return a*a;}\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    vector<double> x,y,z,r;\n    x.resize(n);\n    y.resize(n);\n    z.resize(n);\n    r.resize(n);\n    REP(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    vector<vector<double> > dist;\n    dist.resize(n);\n    REP(i,n) dist[i].resize(n);\n    REP(i,n) REP(j,n) dist[i][j]=max(0.0,sqrt(dd(x[i]-x[j])+dd(y[i]-y[j])+dd(z[i]-z[j]))-r[i]-r[j]);\n    priority_queue<pair<double,int> > prim;\n    // negc,next\n    prim.push(make_pair(0.0,0));\n    set<int> already;\n    double answer=0.0;\n    while(!prim.empty()){\n      double negc=prim.top().first;\n      int tmp=prim.top().second;\n      prim.pop();\n      if(!already.insert(tmp).second) continue;\n      answer-=negc;\n      REP(j,n) prim.push(make_pair(-dist[tmp][j],j));\n    }\n    cout << fixed << setprecision(10) << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n\n  UnionFind(int n) : par(n), rank(n, 1) {\n    for(int i=0; i<n; ++i) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) swap(x, y);\n    par[y] = x;\n    rank[x] += rank[y];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n};\n\nstruct edge{\n    int src, dst;\n    double cost;\n    edge(int s, int t, double c) : src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost > rhs.cost;}\n};\n\nint main(void) {\n    int n;\n    while(cin >> n && n) {\n        UnionFind uf(n);\n        vector<double> x(n), y(n), z(n), r(n);\n        vector<edge> edges;\n        REP(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(i, n)  {\n            REP(j, n) {\n                if(i == j) continue;\n                double c = sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j];\n                edges.push_back(edge(i, j, max(0.0, c)));\n            }\n        }\n        sort(edges.rbegin(), edges.rend());\n\n        double ans = 0;\n        for(auto e : edges) {\n            if(!uf.same(e.src, e.dst)) {\n                uf.unite(e.src, e.dst);\n                ans += e.cost;\n            }\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\nstruct Elem {\n    int to;\n    double cost;\n};\n\nbool operator >(const Elem& x, const Elem& y) {\n    return tie(x.cost, x.to) > tie(y.cost, y.to);\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<double> x(n), y(n), z(n), r(n);\n        loop (n, i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        vector<vector<double>> dist(n, vector<double>(n));\n        loop (n, i) loop (n, j) {\n            double d = pow(\n                    pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2),\n                    0.5\n                    );\n            dist[i][j] = max(0.0, d - r[i] - r[j]);\n        }\n\n        priority_queue<Elem, vector<Elem>, greater<Elem>> Q;\n        vector<int> vis(n);\n        Q.push({ 0, 0 });\n        double ans = 0;\n        while (Q.size()) {\n            Elem e = Q.top(); Q.pop();\n            if (vis[e.to]) continue;\n            vis[e.to] = 1;\n            ans += e.cost;\n            loop (n, i) if (i != e.to && !vis[i]) {\n                Q.push({ i, dist[e.to][i] });\n            }\n        }\n        cout << setprecision(8) << fixed << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j),q++;\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct UnionFind {\n    int* parent;\n    int N;\n    UnionFind(int N) : N(N) {\n        parent = new int[N];\n        fill(parent, parent + N, -1);\n    }\n    ~UnionFind() {\n        delete[] parent;\n    }\n    int root(int x) {\n        if (parent[x] == -1) return x;\n        return parent[x] = root(parent[x]);\n    }\n    bool query(int x, int y) {\n        return root(x) == root(y);\n    }\n    void merge(int x, int y) {\n        x = root(x); \n        y = root(y);\n        if (x != y) {\n            parent[x] = y;\n        }\n    }\n};\n\nint N;\n#define L 100\ndouble x[L], y[L], z[L], r[L];\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    return true;\n}\n\nconst double INF = 1e20;\nstruct Kruskal {\n    struct Edge {\n        int from, to;\n        double cost;\n        Edge(int from, int to, double cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            return cost < e.cost;\n        }\n    };\n    vector<Edge> G;\n    Kruskal() {\n        G.clear();\n    }\n    void addEdge(int from, int to, double cost) {\n        G.push_back(Edge(from, to, cost));\n    }\n    double solve() {\n        UnionFind uf(N);\n        sort(whole(G));\n        double Ret = 0;\n        for (int i = 0; i < G.size(); i++) {\n            if (!uf.query(G[i].from, G[i].to)) {\n                uf.merge(G[i].from, G[i].to);\n                Ret += G[i].cost;\n            }\n        }\n        return Ret;\n    }\n};\n\n#define POW2(x) ((x) * (x))\ndouble Dist(int a, int b) {\n    return sqrt(POW2(x[a] - x[b]) + POW2(y[a] - y[b]) + POW2(z[a] - z[b])) - (r[a] + r[b]);\n}\n\nvoid solve() {\n    Kruskal K;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            K.addEdge(i, j, max(0.0, Dist(i, j)));\n        }\n    }\n    printf(\"%.3lf\\n\", K.solve());\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\n\n#define max_n 100\n#define max_e (max_n * max_n)\n\ndouble c[max_n][4];\n\ndouble d(int a, int b){\n    double x = c[a][0] - c[b][0];\n    double y = c[a][1] - c[b][1];\n    double z = c[a][2] - c[b][2];\n    double ret = sqrt(x*x + y*y + z*z);\n    ret = ret - c[a][3] - c[b][3];\n    return ret;\n}\n\n\n\n\n\nclass UnionFind{\n\nprivate:\n    vector<int> rank,p;\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n    }\n\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        for(int i = 0; i < size; i++){\n          makeSet(i);\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n      link(find(x), find(y));\n    }\n\n    int find(int x){\n      if(x != p[x]) p[x] = find(p[x]);\n      return p[x];\n    }\n\nprivate:\n    void link(int x, int y){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n      }else{\n        p[x] = y;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\n\n\n\nstruct edge{\n     int u, v;\n     double cost;\n };\n\nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\nedge es[max_e];\nint v,e;\n\ndouble kruskal(){\n    sort(es, es+e, comp);\n    UnionFind uf = UnionFind(v);\n    double ret = 0;\n    int i;\n    rep(i,e){\n        edge ee = es[i];\n        if(!uf.same(ee.u, ee.v)){\n            uf.unite(ee.u, ee.v);\n            if(ee.cost > EPS)ret += ee.cost;\n        }\n    }\n    return ret;\n}\n\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        v = n;\n        e = 0;\n\n        rep(i,n)rep(j,4) cin >> c[i][j];\n        double ans = 0;\n        rep(i,n)rep(j,i){\n            edge ee;\n            ee.u = i;\n            ee.v = j;\n            ee.cost = d(i,j);\n            es[e] = ee;\n            e++;\n        }\n\n        cout << shosu(5) << kruskal() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127\n// Only English\n\nvector<int> parents;\nvector<int> ranks;\n\nvoid init(int n) {\n    parents = vector<int>(n, 0);\n    ranks = vector<int>(n, 0);\n    for (int i = 0; i < n; ++i) {\n        parents[i] = i;\n    }\n}\n\nint find(int x) {\n    if (parents[x] == x) {\n        return x;\n    }\n    else {\n        parents[x] = find(parents[x]);\n        return parents[x];\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n        return;\n    }\n\n    if (ranks[x] < ranks[y]) {\n        parents[x] = y;\n    }\n    else if (ranks[x] > ranks[y]) {\n        parents[y] = x;\n    }\n    else {\n        parents[y] = x;\n        ++ranks[x];\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nstruct Corridor {\n    int start;\n    int end;\n    double length;\n};\n\nconst double eps = 1e-12;\n\nbool comp(const Corridor& c1, const Corridor& c2) {\n    return c1.length < c2.length;\n}\n\nvoid solve(int n) {\n    vector<double> x(n, 0.0), y(n, 0.0), z(n, 0.0), r(n, 0.0);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n\n    vector<Corridor> corridors;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double l = sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2));\n            Corridor c;\n            c.start = i;\n            c.end = j;\n            if (l + eps < r[i] + r[j]) {\n                c.length = 0.0;\n            }\n            else {\n                c.length = l - r[i] - r[j];\n            }\n            corridors.push_back(c);\n        }\n    }\n\n    init(n);\n    sort(corridors.begin(), corridors.end(), comp);\n    double ans = 0.0;\n    for (int i = 0; i < corridors.size(); ++i) {\n        const Corridor& c = corridors[i];\n        if (!same(c.start, c.end)) {\n            unite(c.start, c.end);\n            ans += c.length;\n        }\n    }\n    cout << ans << endl;\n}\n\nvoid Main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        solve(n);\n    }\n}\n\nint main() {\n    std::cout << std::fixed << std::setprecision(3);\n    Main();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    \n    printf(\"%lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define P pair<float, pair<int,int> >\n#define sqr(x) ((x) * (x))\n\nusing namespace std;\n\nint parent[100],rank[100];\n\nint findset(int x){\n  if(x!=parent[x]) parent[x] = findset(parent[x]);\n  return parent[x];\n}\n\nvoid link(int x,int y){\n  if(rank[x]>rank[y])\n    parent[y]=x;\n  else{\n    parent[x]=y;\n    if(rank[x]==rank[y]) rank[y]++;\n  }\n}\n\nvoid merge(int x,int y){\n  link(findset(x),findset(y));\n}\n\nbool sameset(int x,int y){\n  return findset(x)==findset(y);\n}\n\nfloat x[100],y[100],z[100],r[100];\nvector<P> tako;\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    tako.clear();\n    for(int i=0; i<n; i++){\n      float xx,yy,zz,rr;\n      scanf(\"%f %f %f %f\",&xx,&yy,&zz,&rr);\n      x[i]=xx; y[i]=yy; z[i]=zz; r[i]=rr;\n\n      parent[i]=i; rank[i]=0;\n    }\n\n    for(int i=0; i<n-1; i++) for(int j=i+1; j<n; j++){\n      float dist = sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j])+sqr(z[i]-z[j]))-r[i]-r[j];\n      //      printf(\"dist: %f, x: %d, y: %d\\n\",dist,i,j);\n      dist = dist>0?dist:0;\n      tako.push_back(make_pair(dist,make_pair(i,j)));\n    }\n    sort(tako.begin(),tako.end());\n\n    float ans=0;\n    for(int i=0; i<tako.size(); i++){\n      float dist = tako[i].first;\n      int x=tako[i].second.first, y=tako[i].second.second;\n      if(sameset(x,y)) continue;\n      ans+=dist;\n      merge(x,y);\n    }\n\n    printf(\"%.3f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind{\n    vector<int> p;\n    vector<int> r;\n\n    UnionFind(int n){\n        p.resize(n, -1);\n        r.resize(n, 1);\n    }\n\n    int find(int x){\n        if(p[x] == -1) return x;\n        else return p[x] = find(p[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return;\n        if(r[x] > r[y]) swap(x, y);\n        if(r[x] == r[y]) ++r[y];\n\n        p[x] = y;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    vector<double> ans;\n    while(1){\n        int n;\n        cin >> n;\n\n        if(n == 0) break;\n\n        vector<double> x(n), y(n), z(n), r(n);\n        rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        vector<vector<double>> dist(n, vector<double>(n));\n        vector<pair<double, pair<int, int>>> dp;\n        rep(i, n) rep(j, n){\n            if(i < j) continue;\n            dist[i][j] = pow(pow(x[i]-x[j], 2) + pow(y[i]-y[j], 2) + pow(z[i]-z[j], 2), 0.5);\n            dist[i][j] = max(0.0, dist[i][j] - r[i] - r[j]);\n            dist[j][i] = dist[i][j];\n\n            dp.push_back(make_pair(dist[i][j], make_pair(i, j)));\n        }\n\n        sort(dp.begin(), dp.end());\n        UnionFind uf(n);\n\n        double res = 0;\n        rep(i, dp.size()){\n            double d = dp[i].first;\n            int from = dp[i].second.first;\n            int to = dp[i].second.second;\n\n            if(uf.find(from) != uf.find(to)){\n                res += d;\n                uf.unite(from, to);\n            }\n        }\n\n\n\n        // rep(i, n){\n        //     rep(j, n) cout << dist[i][j] << \" \";\n        //     cout << endl;\n        // }\n\n        // cout << res << endl;\n        ans.push_back(res);\n\n    }\n\n    rep(i, ans.size()) printf(\"%.3f\\n\", ans[i]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst double INF = 1e10;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tdouble edge[100][100];\n\t\tfor(int i=0;i<n-1;++i){\n\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\tdouble distance = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\tdouble cost = max(distance - r[i] - r[j] , 0.0);\n\t\t\t\tedge[i][j] = cost;\n\t\t\t}\n\t\t}\n\t\tdouble mincost[100];\n\t\tbool used[100];\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0.0; double ans=0;\n\t\twhile(1){\n\t\t\tint v = -1;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v])) v=i;\n\t\t\t}\n\t\t\tif(v == -1) break;\n\t\t\tused[v] = true;\n\t\t\tans += mincost[v];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tmincost[i] = min(mincost[i], edge[v][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.03f\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100],sum,mn,maxd=99999999.9;\nint n,m,mx=(1<<20),a,b,c,t,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt((x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) + (z[i]-z[j]) * (z[i]-z[j]));\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    for(int i=0;i<n;i++) {\n      cin>>x[i]; cin>>y[i]; cin>>z[i]; cin>>r[i];\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tmap[i][j]=maxd;\n      }\n      p[i]=0;\n      d[i]=maxd;\n      visited[i]=0;\n    }\n    \n    for(int i=0; i<n; i++) {\n      for(int j=0; j<n; j++) {\n\tif(i==j) continue;\n\tmap[i][j] = compute(i, j);\n\tmap[i][j]-=(r[i]+r[j]);\n\tif(map[i][j]<0)map[i][j]=0;\n      }\n    }\n\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\t//\tcout<<map[i][j]<<endl;\n      }\n    }\n    \n    sumcor=0.0;\n    d[0]=0.0;\n    while(1){\n      mn=maxd;\n      for(int i=0;i<n;i++){\n\tif(d[i]<mn&&visited[i]==0){\n\t  mn=d[i];\n\t  t=i;\n\t}\n      }\n      if(mn==maxd)break;\n      visited[t]=1;\n      for(int v=0;v<n;v++){\n\tif(map[t][v]<d[v]&&visited[v]==0){\n\t  d[v]=map[t][v];\n\t  p[v]=t;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)if(map[i][p[i]]!=maxd)sumcor+=map[i][p[i]];\n    printf(\"%4.3f\\n\",sumcor);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n;\ndouble x[101],y[101],z[101],r[101];\nstruct data{\n\tdouble dist;\n\tint f,t;\n\tdata(){}\n\tdata(double d,int ff,int tt){\n\t\tdist=d;\n\t\tf=ff;\n\t\tt=tt;\n\t}\n};\n\nbool comp(const data &d1,const data &d2){\n\treturn d1.dist<d2.dist;\n}\n\nint par[101],rank[101];\nvoid init(int x){\n\tfor(int i=0;i<x;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return;\n\tif(rank[x]<rank[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tif(rank[x]==rank[y])rank[x]++;\n\t\tpar[y]=x;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nvector<data> d;\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\td.clear();\n\t\tinit(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf %lf\",&x[i],&y[i],&z[i],&r[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble dist=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2));\n\t\t\t\tif(dist<=r[i]+r[j])unite(i,j);\n\t\t\t\telse if(dist<fabs(r[i]-r[j]))unite(i,j);\n\t\t\t\telse d.push_back(data(dist-r[i]-r[j],i,j));\n\t\t\t}\n\t\t}\n\t\tsort(d.begin(),d.end(),comp);\n\t\tdouble res=0.0;\n\t\tfor(int i=0;i<d.size();i++){\n\t\t\tif(!same(d[i].f,d[i].t)){\n\t\t\t\tunite(d[i].f,d[i].t);\n\t\t\t\tres+=d[i].dist;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000.0\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n\n  UnionFind(int n){\n    data.resize(n+1);\n    fill(data.begin(), data.end(), -1);\n  }\n\n  int root(int x){\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n\n  void unite(int x, int y){\n    int rx=root(x);\n    int ry=root(y);\n\n    if(rx!=ry){\n      if(data[ry] < data[rx])swap(rx, ry);\n\n      data[rx]+=data[ry];\n      data[ry]=rx;\n    }\n  }\n\n  bool same(int x, int y){\n    return root(x)==root(y);\n  }\n\n  int size(int x){\n    return -data[root(x)];\n  }\n};\n\nint n;\n#define MAXN 100\n\ndouble x[MAXN], y[MAXN], z[MAXN], r[MAXN];\nvector<pair<double, pi>> edges;\n\ndouble square(double n){ return n*n; }\n\ndouble solve(){\n  edges.clear();\n\n  rep(i, n)rep(j, n){\n    if(i==j)continue;\n \n    double dist = square(x[i]-x[j])+square(y[i]-y[j])+square(z[i]-z[j]);\n    dist = pow(dist, 0.5);\n    double cost=0.0;\n    \n    // 非接触\n    if( dist > r[i]+r[j] ){\n      cost = dist - (r[i]+r[j]);\n    // }else if(max<double>(r[i], r[j]) > dist+min<double>(r[i], r[j]) ){\n      // 内包\n      // cost = max<double>(r[i], r[j]) - (dist+min<double>(r[i], r[j]) );\n    }\n    edges.push_back({cost, {i, j}});\n  }\n\n  sort(edges.begin(), edges.end());\n\n  double result=0.0;\n  UnionFind uf(n);\n  for(auto p: edges){\n    pi pp = p.second;\n    if(!uf.same(pp.first, pp.second)){\n      result += p.first;\n      uf.unite(pp.first, pp.second);\n    }\n  }\n  return result;\n}\n\nint main(){\n\n  while(cin>>n){\n    if(n==0)break;\n\n    rep(i, n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\n    cout<<fixed<<setprecision(3)<<solve()<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ndouble x[111], y[111], z[111], r[111];\ndouble dis[111][111];\nbool used[111];\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    rep (i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    rep (i, n) used[i] = false;\n    rep (i, n) rep (j, n) dis[i][j] = max(sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2)) - r[i] - r[j], 0.);\n    double res = 0;\n    used[0] = true;\n    rep (i, n - 1) {\n      int next = -1;\n      double mincost = 1e10;\n      rep (j, n) if (used[j]) rep (k, n) if (!used[k]) {\n\t  //cout << j << \" \" << k << \" \" << dis[j][k] << endl;\n\t  if (mincost >= dis[j][k]) {\n\t    mincost = dis[j][k];\n\t    next = k;\n\t  }\n\t}\n      res += mincost;\n      used[next] = true;\n    }\n    printf(\"%.3lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n#define MAX 100\ntypedef pair<int,int> pii;\ntypedef pair<double,pii> pp;\n\nstruct union_find {\n    int rnk[MAX], par[MAX];\n\n    union_find(int n) { for(int i = 0; i < n; i++) rnk[i] = 1, par[i] = i; }\n\n    int find(int x) {\n        if(x == par[x]) return x;\n        else return par[x] = find(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if(rnk[x] > rnk[y]) par[y] = x;\n        else{\n            par[x] = y;\n            if(rnk[x] == rnk[y]) rnk[y]++;\n        }\n        return true;\n    }\n};\n\ninline double cor(vector<double> a, vector<double> b) {\n    double ret = sqrt((a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]));\n    ret -= a[3]+b[3];\n    if (ret <= 0) return 0;\n    else return ret;\n}\n\nint main(void) {\n    int n;\n    while (cin>>n && n) {\n        vector<vector<double> > v(n, vector<double>(4));\n        for (int i = 0; i < n; i++) cin >> v[i][0] >> v[i][1] >> v[i][2] >> v[i][3];\n        \n        vector<vector<double> > l(n, vector<double>(n));\n        priority_queue<pp, vector<pp>, greater<pp> > que;\n        union_find uf(n);\n        for (int i = 0; i < n-1; i++) {\n            for (int j = i+1; j < n; j++) {\n                pp t = make_pair(cor(v[i],v[j]), make_pair(i,j));\n                que.push(t);\n            }\n        }\n        double ans = 0;\n        while (!que.empty()) {\n            pp t = que.top();\n            que.pop();\n            if (uf.unite(t.second.first, t.second.second)) ans += t.first;\n        }\n        printf(\"%.8lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j);\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=std::max(.0,node[i].first);\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\ntypedef tuple<double, int, int> T;\n\nstruct UF {\n\tint par[100];\n\tvoid init() { for (int i = 0; i < 100; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid unit(int x, int y) { x = root(x); y = root(y); par[x] = y; }\n\tbool same(int x, int y) { return root(x) == root(y); }\n};\n\nint n;\ndouble x[100], y[100], z[100], r[100];\nvector<T> edges;\nUF uf;\n\ndouble dist(int a, int b) {\n\tdouble dx = x[a] - x[b];\n\tdouble dy = y[a] - y[b];\n\tdouble dz = z[a] - z[b];\n\treturn sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\t\n\t\t//don't forget to initialize!!!\n\t\tedges.clear();\n\t\tuf.init();\n\t\t\n\t\tint i, j;\n\t\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\tdouble length = dist(i, j) - r[i] - r[j];\n\t\t\t\tif (length < 0) length = 0;\n\t\t\t\tedges.push_back(T(length, i, j));\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\t\n\t\tdouble ans = 0;\n\t\tfor (i = 0; i < edges.size(); i++) {\n\t\t\tdouble l = get<0>(edges[i]);\n\t\t\tint u = get<1>(edges[i]);\n\t\t\tint v = get<2>(edges[i]);\n\t\t\tif (!uf.same(u, v)) {\n\t\t\t\tuf.unit(u, v);\n\t\t\t\tans += l;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\t// ------ Variables ------ //\n\tstatic const long double INF = 1000000000000000000.0L;\n\tint V, E; vector<vector<pair<int, long double> > > G;\n\n\t// ------ Constructors ------ //\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long double> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long double> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long double> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\n\t// ------ Basic Functions ------ //\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long double w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long double w) { add1(v1, v2, w); add1(v2, v1, w); }\n\n\t// ------ Operators ------ //\n\tbool operator==(const Graph2& g) const { return G == g.G; }\n\tbool operator!=(const Graph2& g) const { return G != g.G; }\n\tvector<pair<int, long double> > operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tlong double minspan() {\n\t\tvector<long double> d(V, INF);\n\t\tvector<bool> used(V, false);\n\t\tpriority_queue<pair<long double, int> > que;\n\t\tfor (int i = 0; i < V; i++) d[i] = INF;\n\t\td[0] = 0; que.push(make_pair(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int> pa = que.top(); que.pop();\n\t\t\tint u = pa.second; used[u] = true;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first;\n\t\t\t\tif (d[v] > G[u][i].second && !used[v]) {\n\t\t\t\t\td[v] = G[u][i].second; que.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double sum = 0;\n\t\tfor (int i = 0; i < V; i++) sum += d[i];\n\t\treturn sum;\n\t}\n};\n// ------ Main ------ //\nint n; long double x[111], y[111], z[111], r[111];\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tGraph2 G(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tlong double dist = sqrtl((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\tG.add2(i, j, (dist > r[i] + r[j]) ? (dist - r[i] - r[j]) : 0)\n\t\t\t}\n\t\t}\n\t\tcout << G.minspan() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\nclass UnionFind {\npublic:\n  UnionFind(ll n) : par(n, -1), rnk(n, 0), cnt(n, 1), _size(n) {}\n\n  bool same(ll x, ll y) {\n    return root(x) == root(y);\n  }\n  void unite(ll x, ll y) {\n    x = root(x); y = root(y);\n    if (x == y) return;\n\n    --_size;\n\n    if (rnk[x] < rnk[y]) { swap(x, y); }\n    par[y] = x;\n    cnt[x] += cnt[y];\n    if (rnk[x] == rnk[y]) { ++rnk[x]; }\n  }\n  ll root(ll x) {\n    if (par[x] < 0) {\n      return x;\n    } else {\n      return par[x] = root(par[x]);\n    }\n  }\n  ll count(ll x) {\n    return cnt[root(x)];\n  }\n  ll size() {\n    return _size;\n  }\n\nprivate:\n  vector<ll> par;\n  vector<ll> rnk;\n  vector<ll> cnt; // The number of vertices in each connected components.\n  ll _size; // The number of connected components. Decreases by unite.\n};\n\n// int main(int argc, char** argv) {\n//   ll N, M;\n//   cin >> N >> M;\n//   UnionFind tree(N);\n//   rep(i, M) {\n//     ll p, a, b;\n//     cin >> p >> a >> b;\n//     if (p == 0) { // Connect\n//       tree.unite(a, b);\n//     } else { // Judge\n//       if (tree.same(a, b)) {\n//         cout << \"Yes\" << endl;\n//         cout << \"size: \" << tree.size() << endl;\n//         cout << \"count(\" << a << \"): \" << tree.count(a) << endl;\n//         cout << \"count(\" << b << \"): \" << tree.count(b) << endl;\n//       } else {\n//         cout << \"No\" << endl;\n//         cout << \"size: \" << tree.size() << endl;\n//         cout << \"count(\" << a << \"): \" << tree.count(a) << endl;\n//         cout << \"count(\" << b << \"): \" << tree.count(b) << endl;\n//       }\n//     }\n//   }\n// }\n\nconst double eps = 1e-10;\n\nvoid solve(ll n) {\n  vector<double> x(n),y(n),z(n),r(n);\n  rep(i,n) {\n    cin >> x[i] >> y[i] >> z[i] >> r[i];\n  }\n  vector<vector<double>> d(n,vector<double>(n, INF));\n  rep(i,n)rep(j,n) {\n    double dist = 0;\n    dist += (x[i]-x[j])*(x[i]-x[j]);\n    dist += (y[i]-y[j])*(y[i]-y[j]);\n    dist += (z[i]-z[j])*(z[i]-z[j]);\n    dist = sqrt(dist);\n    dist -= r[i]+r[j];\n    d[i][j] = dist;\n  }\n\n  UnionFind uf(n);\n  rep(i,n)rep(j,i) {\n    if (d[i][j] < eps) { // minus\n      uf.unite(i,j);\n    }\n  }\n\n  // d2 .. distance between connected components\n  vector<vector<double>> d2(n,vector<double>(n, INF));\n  vector<ll> roots;\n  rep(i,n) {\n    ll r = uf.root(i);\n    d2[r][r] = 0; // same\n    roots.push_back(r);\n  }\n  sort(all(roots));\n  roots.erase(unique(all(roots)), roots.end());\n\n  rep(i,n)rep(j,i) {\n    ll r1 = uf.root(i);\n    ll r2 = uf.root(j);\n    if (r1 == r2) { continue; } // already connected\n    chmin(d2[r1][r2], d[i][j]);\n    chmin(d2[r2][r1], d[i][j]);\n  }\n\n  // Here, calculate the minimum spanning tree\n  vector<tuple<double,ll,ll>> edges;\n  rep(i,roots.size())rep(j,i) {\n    ll r1 = roots[i];\n    ll r2 = roots[j];\n    edges.emplace_back(d2[r1][r2],i,j);\n  }\n\n  double ans = 0;\n  UnionFind uf2(roots.size());\n  sort(all(edges));\n  for (auto& edge : edges) {\n    double cost;\n    ll i,j;\n    tie(cost,i,j) = edge;\n    if (!uf2.same(i,j)) {\n      ans += cost;\n      uf2.unite(i,j);\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  cout << setprecision(3) << fixed;\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0) { break; }\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, P> DP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n//// UnionFind\nstruct UnionFind{\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t\treturn true;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint n;\ndouble x[111],y[111],z[111],r[111];\nvector<DP> es;\n\ndouble dist(int i,int j){\n\treturn sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2));\n}\n\nbool judge(int i,int j){\n\tif(dist(i,j)<=r[i]+r[j])return true;\n\telse return false;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tes.clear();\n\t\tUnionFind uf(n);\n\t\trep(i,n)rep(j,i){\n\t\t\tif(judge(i,j))uf.unite(i,j);\n\t\t\telse{\n\t\t\t\tes.pb(DP(dist(i,j)-r[i]-r[j],P(i,j)));\n\t\t\t}\n\t\t}\n\t\tsort(all(es));\n\t\tdouble res=0;\n\t\trep(i,es.size()){\n\t\t\tif(uf.same(es[i].se.fi,es[i].se.se))continue;\n\t\t\tres+=es[i].fi;\n\t\t\tuf.unite(es[i].se.fi,es[i].se.se);\n\t\t}\n\t\tprintf(\"%.3f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<0)x=0;\n\t\t\tcout<<x<<endl;\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m;m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<fixed<<setprecision(3)<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])continue;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(5)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct Sphere {\n    double x, y, z, r;\n};\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Sphere> spheres(n);\n        for (vector<Sphere>::iterator it = spheres.begin(); it != spheres.end(); it++) {\n            cin >> it->x >> it-> y >> it->z >> it->r;\n        }\n        multimap<double, pair<int, int> > costs;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dist2 = pow(spheres[i].x - spheres[j].x, 2) + pow(spheres[i].y - spheres[j].y, 2) + pow(spheres[i].z - spheres[j].z, 2),\n                    cost = sqrt(dist2) - spheres[i].r - spheres[j].r;\n                costs.insert(make_pair(cost, make_pair(i, j)));\n            }\n        }\n        double totalCost = 0;\n        if (n > 1) {\n            set<int> connected;\n            for (multimap<double, pair<int, int> >::iterator it = costs.begin(); it != costs.end(); it++) {\n                connected.insert((*it).second.first);\n                connected.insert((*it).second.second);\n                if ((*it).first > 0) {\n                    totalCost += (*it).first;\n                }\n                break;\n            }\n            while ((int) connected.size() < n) {\n                for (multimap<double, pair<int, int> >::iterator it = costs.begin(); it != costs.end(); it++) {\n                    bool add = false;\n                    int k = (*it).second.first, l = (*it).second.second;\n                    if (connected.find(k) != connected.end() && connected.find(l) == connected.end()) {\n                        connected.insert(l);\n                        add = true;\n                    } else if (connected.find(k) == connected.end() && connected.find(l) != connected.end()) {\n                        connected.insert(k);\n                        add = true;\n                    }\n                    if (add && (*it).first > 0) {\n                        totalCost += (*it).first;\n                        break;\n                    }\n                }\n            }\n        }\n        printf(\"%.3f\\n\", totalCost);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n\tbool check(int n) {\n\t\tint p = root(0);\n\t\tfor(int i=1; i<n; ++i) {\n\t\t\tif(p!=root(i)) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tq.push((Edge){i, j, 0.0});\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && c<n-1) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tcout << e.from << \" \" << e.to << endl;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\tans += e.cost;\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n#define EPS 1e-6\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint par[1000];\n\nvoid init(int n){\n    REP(i,n){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if (par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid merge(int x, int y){\n    x = find(x);\n    y = find(y);\n    if (x==y) return;\n    par[x] = y;\n}\n\nstruct edge{ int u, v; double cost; };\n\nvector<edge> es;\nint n;\n\nbool comp(const edge &e1, const edge &e2){\n    return e1.cost < e2.cost;\n}\n\ndouble kruskal(){\n    sort(es.begin(), es.end(), comp);\n    init(n);\n    double res = 0;\n    REP(i,es.size()){\n        edge e = es[i];\n        if (!same(e.u, e.v)){\n            merge(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n){\n        es.clear();\n        vector<double> x(n), y(n), z(n), r(n);\n        REP(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        REP(i,n) REP(j,n) {\n            edge e;\n            e.u = i;\n            e.v = j;\n            double d = sqrt(pow(x[i]-x[j],2) + pow(y[i]-y[j],2) + pow(z[i]-z[j],2));\n            d -= r[i] + r[j];\n            if (d < 0) d = 0;\n            e.cost = d;\n            es.push_back(e);\n        }\n        printf(\"%.10f\\n\", kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1<<29;\n\ndouble prim(){\n  double ret = 0;\n  bool used[100]={};\n  double dist[100];\n  for(int i=0;i<n;++i) dist[i]=INF;\n  dist[0]=0;\n  while(true){\n    int id = -1;\n    double mindst = INF;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dist[i]){\n\tmindst = dist[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id] = true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dist[i]=min(dist[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;cin>>a;return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n\n    cout << fixed << setprecision(10) << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOTCONNECTED 0 // WHITE\n#define CANDIDATE 1 // GRAY\n#define CONNECTED 2 // BLACK\n#define int long long\nusing namespace std;\ndouble getDistance(vector<double>, vector<double>);\n\nsigned main() {\n  int n;\n  while(cin >> n, n) {\n    vector<vector<double> > cells;\n    for(int i = 0; i < n; ++i) {\n      double y, x, z, r;\n      cin >> x >> y >> z >> r;\n      cells.push_back(vector<double>({x, y, z, r}));\n    }\n    vector<double> minWeights(n, INT_MAX); // d\n    minWeights[0] = 0;\n    vector<int> states(n, NOTCONNECTED); // color\n    vector<int> parents(n, -1); // p\n    while(true) {\n      int minv = INT_MAX;\n      int u = -1;\n      for(int i = 0; i < n; ++i) {\n        if(minWeights[i] != INT_MAX && minv > minWeights[i] && states[i] == NOTCONNECTED) {\n          u = i;\n          minv = minWeights[i];\n        }\n      }\n      if(u == -1) break;\n      states[u] = CONNECTED;\n      for(int v = 0; v < n; ++v) {\n        if(states[v] == NOTCONNECTED && minWeights[v] > getDistance(cells[u], cells[v])) {\n          minWeights[v] = getDistance(cells[u], cells[v]);\n          parents[v] = u;\n          // states[v] = CANDIDATE;\n        }\n      }\n    }\n    double ans = 0;\n    for(int i = 0; i < n; ++i) {\n      if(parents[i] != -1) ans += getDistance(cells[i], cells[parents[i]]);\n    }\n    printf(\"%.3f\", ans);\n    cout << endl;\n  }\n  return 0;\n}\n\ndouble getDistance(vector<double> a, vector<double> b) {\n  double dx = abs(a[0] - b[0]);\n  double dy = abs(a[1] - b[1]);\n  double dz = abs(a[2] - b[2]);\n  double ans = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - a[3] - b[3];\n  return ans < 0 ? 0.0 : ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nusing D=double;\nstruct edge{\n    int u,v;\n    double cost;\n    bool operator<(edge &e){\n        return cost<e.cost;\n    }\n};\n\nclass UnionFind\n{\n public:\n    vector<int> par,sz;\n    UnionFind(int N):par(N),sz(N){\n        for(int i=0;i<N;i++){\n            par[i]=i; sz[i]=1;\n        }\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x); y=find(y);\n        if(x==y) return;\n        if(sz[x]<sz[y]) swap(x,y);\n        par[y]=x;\n        sz[x]+=sz[y];\n    }\n    bool same(int x,int y){ return find(x)==find(y); }\n    int size(int x){ return sz[find(x)]; }\n    bool root(int x){ return par[x]==x; }\n};\n\nvoid solve(int N)\n{\n    vector<D> x(N),y(N),z(N),r(N);\n    for(int i=0;i<N;i++) cin>>x[i]>>y[i]>>z[i]>>r[i];\n    \n    auto dist=[&](int i,int j)\n    {\n        D dx=x[i]-x[j];\n        D dy=y[i]-y[j];\n        D dz=z[i]-z[j];\n        D d=sqrt(dx*dx+dy*dy+dz*dz);\n        return max(0.0,d-(r[i]+r[j]));\n    };\n    vector<edge> es;\n    for(int i=0;i<N-1;i++) for(int j=i+1;j<N;j++){\n        es.push_back({i,j,dist(i,j)});\n        // cout<<i<<' '<<j<<' '<<dist(i,j)<<endl;\n    }\n    sort(es.begin(),es.end());\n\n    UnionFind tree(N);\n    D ans=0;\n    for(edge e:es){\n        if(!tree.same(e.u,e.v)){\n            tree.unite(e.u,e.v);\n            ans+=e.cost;\n        }\n    }\n    printf(\"%.3f\\n\",ans);\n}\nsigned main()\n{\n    while(true){\n        int N; cin>>N;\n        if(N==0) break;\n        solve(N);\n    }    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LOOP(n) for (int _i = 0; _i < (n); _i++)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define RREP(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, r, n) for (int i = (r); i < (n); ++i)\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<int, int>;\nusing Graph = vector<vector<int>>;\n\nconst int INF = 2100100100;\nconst int MOD = 1e9 + 7;\n\n// 多次元 vector 生成\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n/* UnionFind：素集合系管理の構造体(union by rank)\n    isSame(x, y): x と y が同じ集合にいるか。 計算量はならし O(α(n))\n    unite(x, y): x と y を同じ集合にする。計算量はならし O(α(n))\n*/\nstruct UnionFind {  // The range of node number is u 0 v n-1\n    vector<int> rank, parents;\n    UnionFind() {}\n    UnionFind(int n) {  // make n trees.\n        rank.resize(n, 0);\n        parents.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            makeTree(i);\n        }\n    }\n    void makeTree(int x) {\n        parents[x] = x;  // the parent of x is x\n        rank[x] = 0;\n    }\n    bool isSame(int x, int y) { return findRoot(x) == findRoot(y); }\n    void unite(int x, int y) {\n        x = findRoot(x);\n        y = findRoot(y);\n        if (rank[x] > rank[y]) {\n            parents[y] = x;\n        } else {\n            parents[x] = y;\n            if (rank[x] == rank[y]) {\n                rank[y]++;\n            }\n        }\n    }\n    int findRoot(int x) {\n        if (x != parents[x]) parents[x] = findRoot(parents[x]);\n        return parents[x];\n    }\n};\n\n// 辺の定義\nstruct Edge {\n    int u;\n    int v;\n    double cost;\n};\nbool comp_e(const Edge &e1, const Edge &e2) { return e1.cost < e2.cost; }\n\n/* Kruskal :クラスカル法で minimum spanning tree を求める構造体\n    入力: 辺のvector, 頂点数V\n    最小全域木の重みの総和: sum\n    計算量: O(|E|log|V|)\n*/\nstruct Kruskal {\n    UnionFind uft;\n    double sum;  // 最小全域木の重みの総和\n    vector<Edge> edges;\n    int V;\n    Kruskal(const vector<Edge> &edges_, int V_) : edges(edges_), V(V_) { init(); }\n    void init() {\n        sort(edges.begin(), edges.end(), comp_e);\n        uft = UnionFind(V);\n        sum = 0;\n        for (auto e : edges) {\n            if (!uft.isSame(e.u, e.v)) {\n                uft.unite(e.u, e.v);\n                sum += e.cost;\n            }\n        }\n    }\n};\n\nll N, M, K, Q, W, H, R, C;\nstring S;\n\nint main() {\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);\n\n    vector<double> ans;\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        vector<double> x(N), y(N), z(N), r(N);\n        REP(i, N) cin >> x.at(i) >> y.at(i) >> z.at(i) >> r.at(i);\n        vector<Edge> edges;\n        REP(i, N) {\n            REP(j, N) {\n                if (i < j) {\n                    double dis = sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2));\n                    edges.push_back({i, j, max(0.0, dis - (r[i] + r[j]))});\n                }\n            }\n        }\n        Kruskal krs(edges, N);\n        ans.push_back(krs.sum);\n    }\n    for (auto i : ans) {\n        cout << fixed << setprecision(3) << i << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const float EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ndouble path[100][100];\ndouble mincost[100];\nbool used[100];\n\nclass Data{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n\tData(double _x,double _y,double _z,double _r){\n\t\tx = _x;\n\t\ty = _y;\n\t\tz = _z;\n\t\tr = _r;\n\t}\n};\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> nodes;\n\n\t\tfill((bool*)used,(bool*)used + 100,false);\n\t\tfill((double*)mincost,(double*)mincost + 100,numeric_limits<double>::max());\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,z,r;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&x,&y,&z,&r);\n\t\t\tnodes.push_back(Data(x,y,z,r));\n\t\t}\n\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble diff = sqrt((nodes[i].x-nodes[j].x) * (nodes[i].x-nodes[j].x)\n\t\t\t\t\t+ (nodes[i].y-nodes[j].y) * (nodes[i].y-nodes[j].y)\n\t\t\t\t\t+ (nodes[i].z-nodes[j].z) * (nodes[i].z-nodes[j].z));\n\t\t\t\tdouble cost = (diff - (nodes[i].r + nodes[j].r) >= 0 ? diff - (nodes[i].r + nodes[j].r) : 0);\n\t\t\t\tpath[i][j] = path[j][i] = cost;\n\t\t\t}\n\t\t}\n\n\n\t\tmincost[0]=0;\n\n\t\tdouble res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v])){\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\tres+=mincost[v];\n\t\t\t\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = min(mincost[u],path[v][u]);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tprintf(\"%lf\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nusing vd=vector<double>;\nusing data=tuple<double,int,int>;\n\ndouble hypot3(double x,double y,double z){\n\treturn sqrt(x*x+y*y+z*z);\n}\ndouble dist(vd a, vd b){\n\tauto d=hypot3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);\n\treturn max(d-a[3]-b[3],0.0);\n}\n\nstruct UnionFind{\n\tint n; vi par;\n\tUnionFind(int N){n=N; par.resize(n); iota(all(par),0);}\n\tint root(int a){return par[a]=par[a]==a?a:root(par[a]);}\n\tbool same(int a, int b){return root(a)==root(b);}\n\tvoid unite(int a, int b){a=root(a),b=root(b);if(a!=b) par[a]=b;}\n};\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vd> cell(n,vd(4));\n\t\tvector<data> edge;\n\t\trep(i,n) {\n\t\t\trep(j,4) cin>>cell[i][j];\n\t\t\trep(j,i) edge.emplace_back(dist(cell[i],cell[j]),i,j);\n\t\t}\n\t\tsort(all(edge),[](data a,data b){return get<0>(a)<get<0>(b);});\n\n\t\tUnionFind uf(n);\n\t\tdouble ans=0;\n\t\tfor(auto e:edge){\n\t\t\tdouble d; int a,b;\n\t\t\ttie(d,a,b)=e;\n\t\t\tif(!uf.same(a,b)){\n\t\t\t\tans+=d;\n\t\t\t\tuf.unite(a,b);\n\t\t\t}\n\t\t}\n\t\tcout.precision(3);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n\n#define WHITE 0\n#define EPS 1e-10\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 1000\n#define INF 999999999.99\n\nlong double x[MAX_N][MAX_N];\nlong double MIN[MAX_N], color[MAX_N];\nlong double X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nlong double b, sum, sum_min;\nint n, c, a;\n\nvoid prim() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tMIN[j] = INF;\n\t\t\tcolor[j] = WHITE;\n\t\t}\n\t\tb = INF;\n\t\ta = n;\n\t\tcolor[i] = GRAY;\n\t\tMIN[i] = 0;\n\t\twhile (a != 0) {\n\t\t\tb = INF;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor[c] = BLACK;\n\t\t\ta -= 1;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (color[k] != BLACK && x[c][k] >= -EPS) {\n\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum += MIN[j];\n\t\t}\n\t\tsum_min = min(sum_min, sum);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tsum_min = INF;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tX[i] = 0; Y[i] = 0; Z[i] = 0;\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = -INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tlong double X1 = (X[i] - X[j])*(X[i] - X[j]);\n\t\t\t\tlong double Y1 = (Y[i] - Y[j])*(Y[i] - Y[j]);\n\t\t\t\tlong double Z1 = (Z[i] - Z[j])*(Z[i] - Z[j]);\n\t\t\t\tlong double dist = sqrtl(X1 + Y1 + Z1);\n\t\t\t\tlong double dist2 = dist - R[i] - R[j];\n\t\t\t\tx[i][j] = max(0.0l, dist2);\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tcout << fixed << setprecision(114514) << sum_min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n#define MAX 100\ntypedef pair<int,int> pii;\ntypedef pair<double,pii> pp;\n\nstruct union_find {\n    int rnk[MAX], par[MAX];\n\n    union_find(int n) { for(int i = 0; i < n; i++) rnk[i] = 1, par[i] = i; }\n\n    int find(int x) {\n        if(x == par[x]) return x;\n        else return par[x] = find(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if(rnk[x] > rnk[y]) par[y] = x;\n        else{\n            par[x] = y;\n            if(rnk[x] == rnk[y]) rnk[y]++;\n        }\n        return true;\n    }\n};\n\ninline double cor(vector<double> a, vector<double> b) {\n    double ret = sqrt((a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]));\n    ret -= a[3]+b[3];\n    if (ret <= 0) return 0;\n    else return ret;\n}\n\nint main(void) {\n    int n;\n    while (cin>>n && n) {\n        vector<vector<double> > v(n, vector<double>(4));\n        for (int i = 0; i < n; i++) cin >> v[i][0] >> v[i][1] >> v[i][2] >> v[i][3];\n        \n        vector<vector<double> > l(n, vector<double>(n));\n        priority_queue<pp, vector<pp>, greater<pp> > que;\n        union_find uf(n);\n        for (int i = 0; i < n-1; i++) {\n            for (int j = i+1; j < n; j++) {\n                pp t = make_pair(cor(v[i],v[j]), make_pair(i,j));\n                que.push(t);\n            }\n        }\n        double ans = 0;\n        while (!que.empty()) {\n            pp t = que.top();\n            que.pop();\n            if (uf.unite(t.second.first, t.second.second)) ans += t.first;\n        }\n        printf(\"%.8lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <math.h>\n#define N 101\n#define INFTY 200000000\nusing namespace std;\nvoid prim();\nint n,p[N];\ndouble M[N][N],d[N],x[N],y[N],z[N],r[N];\nstring color[N];\nint main(){\n  int i,j;\n  double min,xc,yc,zc;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    for(i=0;i<n;i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tM[i][j]=-1;\n      }\n    }\n    for(i=0;i<n-1;i++){\n      for(j=i+1;j<n;j++){\n\txc=x[i]-x[j];\n\tyc=y[i]-y[j];\n\tzc=z[i]-z[j];\n\tif(xc<0) xc*=-1;\n\tif(yc<0) yc*=-1;\n\tif(zc<0) zc*=-1;\n\tM[i][j]=M[j][i]=sqrt(xc*xc+yc*yc+zc*zc)-r[i]-r[j];\n\tif(M[i][j]<0) M[i][j]=M[j][i]=0;\n      }\n    }\n    prim();\n    min=0.0;\n    for(i=0;i<n;i++){\n      if(d[i]!=INFTY) min+=d[i];\n      else{\n\tmin=0;\n\tbreak;\n      }\n    }\n    printf(\"%.3f\",min);\n    cout << endl;\n  }\n  return 0;\n}\nvoid prim(){\n  int i,j,u;\n  double mincost;\n  for(i=0;i<n;i++) color[i]=\"WHITE\",d[i]=INFTY;\n  d[0]=0;\n  p[0]=-1;\n  while(1){\n    mincost=INFTY;\n    for(i=0;i<n;i++){\n      if(color[i]!=\"BLACK\"&&d[i]<mincost){\n\tmincost=d[i];\n\tu=i;\n      }\n    }\n    if(mincost==INFTY) break;\n    color[u]=\"BLACK\";\n    for(i=0;i<n;i++){\n      if(color[i]!=\"BLACK\"&&M[u][i]!=-1){\n\tif(M[u][i]<d[i]){\n\t  d[i]=M[u][i];\n\t  p[i]=u;\n\t  color[i]=\"GLAY\";\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\nstruct Elem {\n    int to;\n    double cost;\n};\n\nbool operator >(const Elem& x, const Elem& y) {\n    return tie(x.cost, x.to) > tie(y.cost, y.to);\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        vector<double> x(n), y(n), z(n), r(n);\n        loop (n, i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        vector<vector<double>> dist(n, vector<double>(n));\n        loop (n, i) loop (n, j) {\n            double d = pow(\n                    pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2),\n                    0.5\n                    );\n            dist[i][j] = max(0.0, d - r[i] - r[j]);\n        }\n\n        priority_queue<Elem, vector<Elem>, greater<Elem>> Q;\n        vector<int> vis(n);\n        Q.push({ 0, 0 });\n        double ans = 0;\n        while (Q.size()) {\n            Elem e = Q.top(); Q.pop();\n            if (vis[e.to]) continue;\n            vis[e.to] = 1;\n            ans += e.cost;\n            loop (n, i) if (i != e.to && !vis[i]) {\n                Q.push({ i, dist[e.to][i] });\n            }\n        }\n        cout << setprecision(3) << fixed << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\nusing Point = complex<double>;\nconstexpr double EPS = 1e-8;\n\nstruct Circle {\n    double x, y, z, r;\n    Circle(double x, double y, double z, double r) : x(x), y(y), z(z), r(r) {}\n};\n\ndouble dist(const Circle &a, const Circle &b) {\n    double d = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));\n    d -= (a.r + b.r);\n    if (d < EPS)\n        return 0;\n    else\n        return d;\n}\n\nstruct UnionFind {\n    int N;\n    vector<int> siz, par, Rank;\n\n    UnionFind(int n) : siz(n, 1), par(n), Rank(n, 0), N(n) { REP(i, N) par[i] = i; }\n\n    int find(int x) {\n        if (par[x] == x)\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (Rank[x] < Rank[y]) {\n            par[x] = y;\n            siz[x] += siz[y];\n            siz[y] = siz[x];\n        } else {\n            siz[y] += siz[x];\n            siz[x] = siz[y];\n            par[y] = x;\n            if (Rank[x] == Rank[y]) Rank[x]++;\n        }\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    vector<Circle> cs;\n    REP(i, N) {\n        double x, y, z, r;\n        cin >> x >> y >> z >> r;\n        cs.push_back(Circle(x, y, z, r));\n    }\n    UnionFind uf(N);\n    double sum = 0;\n    REP(_, N - 1) {\n        double mn = 1e9;\n        int id1 = 0, id2 = 0;\n        REP(i, N) FOR(j, i + 1, N) {\n            if (uf.same(i, j)) continue;\n            double cost = dist(cs[i], cs[j]);\n            if (cost < mn) {\n                mn = cost;\n                id1 = i, id2 = j;\n            }\n        }\n        sum += mn;\n        uf.unite(id1, id2);\n    }\n    cout << fixed << setprecision(3) << sum << endl;\n\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r}),parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <queue>\n#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\n\ntypedef long double R;\ntypedef tuple<R,R,R> P;\ntypedef pair<P,R> S;\nR const eps = 1e-10;\n\ntypedef R Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n    int n = g.size();\n    Edges T;\n    Weight total = 0;\n    vector<bool> vis(n);\n    priority_queue<Edge> q;\n    q.push( Edge(-1, r, 0) );\n    while (!q.empty()) {\n        Edge e = q.top(); q.pop();\n        if (vis[e.dst]) continue;\n        T.push_back(e);\n        total += e.weight;\n        vis[e.dst] = true;\n        for(auto& f : g[e.dst]) if (!vis[f.dst]) q.push(f);\n    }\n    return make_pair(total, T);\n}\n\nint n;\nS ss[111];\nR d[111][111];\n\nP operator-(const P& p, const P& q){\n    R x,y,z, a,b,c;\n    tie(x,y,z) = p; tie(a,b,c) = q;\n    return P(x-a, y-b, z-c);\n}\n\nR abs(P p){\n    R x,y,z;\n    tie(x,y,z) = p;\n    return sqrt(x*x+y*y+z*z);\n}\n\nR dist(S const& c1, S const& c2){\n    R d = abs(c1.first-c2.first);\n    return max<R>(0, d-(c1.second+c2.second));\n}\n\nint main(){\n    while(cin >> n && n){\n        Graph g(n);\n        rep(i,n){\n            R x,y,z,r; cin >> x >> y >> z >> r;\n            ss[i] = S(P(x,y,z),r);\n            rep(j,i){\n                R d = dist(ss[i],ss[j]);\n                g[i].eb(i,j,d);\n                g[j].eb(j,i,d);\n            }\n        }\n        printf(\"%.20lf\\n\", (double)minimumSpanningTree(g).first);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nrandom_device rnd;\nmt19937 mt(rnd());\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1000000007;\n\ntypedef vector<long double> Cell;\n\nlong double cost(Cell &a, Cell &b)\n{\n    long double dist = sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));\n    return max(dist - a[3] - b[3], (long double)0.0);\n}\nvoid solve(int n)\n{\n    vector<Cell> v(n);\n    rep(i, n)\n    {\n        long double x, y, z, r;\n        cin >> x >> y >> z >> r;\n        v[i] = Cell({x, y, z, r});\n    }\n    vector<bool> used(n, false);\n    long double ans = 0;\n    used[0] = true;\n    bool isupdate = true;\n\n    while (isupdate)\n    {\n        long double bestdist = 1 << 20;\n        int best = -1;\n        rep(i, n)\n        {\n\n            if (used[i] == false)\n            {\n                continue;\n            }\n            rep(j, n)\n            {\n\n                if (used[j] == true)\n                {\n                    continue;\n                }\n                if (cost(v[i], v[j]) < bestdist)\n                {\n                    bestdist = cost(v[i], v[j]);\n                    best = j;\n                }\n            }\n        }\n        if (best == -1)\n            break;\n        ans += bestdist;\n        used[best] = true;\n        isupdate = false;\n        rep(i, n)\n        {\n            isupdate |= !used[i];\n        }\n    }\n    printf(\"%.3Lf\\n\", ans);\n}\n\nint main()\n{\n\n    int n;\n    while (cin >> n, n)\n    {\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\ndouble data[101][5],mst[101];\nbool used[101];\ndouble cur,kyori,sum;\nint cur_pos;\n\nvoid prim(int n){\n  \n  for(int _= 1 ; _ <= n ; _++){\n    used[_]=false;\n    mst[_]=1e9;\n  }\n  \n  mst[1]=0;\n  \n  for(int _=0 ; _ < n ; _++){\n    cur=1e9;\n    for(int i=1 ; i <= n ; i++){\n      if(cur >= mst[i] && used[i] == false){\n\tcur=mst[i];\n\tcur_pos=i;\n      }\n    }\n    \n    used[cur_pos]=true;\n    \n    for(int i=1 ; i <= n ; i++){  \n      if(i == cur_pos || used[i] == true)continue;\n      kyori=sqrt((data[i][1]-data[cur_pos][1])*(data[i][1]-data[cur_pos][1])+(data[i][2]-data[cur_pos][2])*(data[i][2]-data[cur_pos][2])+(data[i][3]-data[cur_pos][3])*(data[i][3]-data[cur_pos][3]))-(data[i][4]+data[cur_pos][4]);\n      if(kyori < 0)kyori=0;\n      //cout <<kyori<<endl;\n      if(mst[i] > kyori){\n\tmst[i]=kyori;\n      }\n    }\n    \n  }\n\n  //for(int i=1 ; i <= n ; i++)cout <<mst[i]<<endl;\n  \n  sum=0;\n  for(int i=1 ; i <= n ; i++)sum+=mst[i];\n\n  printf(\"%.3lf\\n\",sum);\n\n}\nint main(){\n  \n  int n;\n  \n  while(1){\n    \n    cin >> n; \n    if(n == 0)break;\n    \n    for(int i=1 ; i <= n ; i++){\n      for(int j=1 ; j < 5 ; j++){\n\tcin >>data[i][j];\n      }\n    }\n\n    prim(n);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nstruct UnionFind{\n    vector<int> par, siz;\n    void init(int n){\n        par.resize(n);\n        siz.resize(n);\n        for(int i = 0; i < n; i++){\n            par[i] = i;\n            siz[i] = 1;\n        }\n    }\n    \n    int root(int i){\n        if(par[i] == i) return i;\n        else return par[i] = root(par[i]);\n    }\n\n    bool same(int a, int b){\n        return root(a) == root(b);\n    }\n\n    int size(int i){\n        return siz[root(i)];\n    }\n\n    void unite(int a, int b){\n        a = root(a);\n        b = root(b);\n        if(a == b) return;\n        if(size(a) < size(b)) swap(a, b);\n        siz[a] += siz[b];\n        par[b] = a;\n    }\n};\nstruct state{\n    double x, y, z;\n    double r;\n};\nstruct edge{\n    int i, j;\n    double d;\n};\nvector<state> G;\nedge dist(int i, int j){\n    double dis = sqrt((G[i].x - G[j].x)*(G[i].x - G[j].x) + (G[i].y - G[j].y)*(G[i].y - G[j].y) + (G[i].z - G[j].z)*(G[i].z - G[j].z));\n    dis -= G[i].r + G[j].r;\n    if(dis < 0) dis = 0;\n    edge e = {i, j, dis};\n    return e;\n}\nbool comp(const edge &e1, const edge &e2){\n    return e1.d < e2.d;\n}\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n        G.resize(n);\n        for(int i = 0; i < n; i++){\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            state s = {x, y, z, r};\n            G[i] = s;\n        }\n        vector<edge> es(n*(n-1)/2);\n        int u = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                edge e = dist(i, j);\n                es[u] = e;\n                u++;\n            }\n        }\n        sort(es.begin(), es.end(), comp);\n        UnionFind U;\n        U.init(n);\n        double ans = 0;\n        for(int i = 0; i < n*(n-1)/2; i++){\n            edge e = es[i];\n            if(!U.same(e.i, e.j)){\n                U.unite(e.i, e.j);\n                ans += e.d;\n            }\n        }\n        printf(\"%.3lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS (10e-11)\n\nint solve() {\n\t\n\tint n;\n\tcin >> n;\n\tif( n == 0 ) return 1;\n\n\tvector< vector< long double > > src(4, vector< long double >( n ) );\n\tvector< vector< long double > > dist(n, vector< long double >( n, 0.0 ) );\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < 4; j++ ) {\n\t\t\tcin >> src[j][i];\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = i + 1; j < n; j++ ) {\n\t\t\tlong double d = sqrt( \n\t\t\t\t(src[0][i] - src[0][j]) * (src[0][i] - src[0][j]) + \n\t\t\t\t(src[1][i] - src[1][j]) * (src[1][i] - src[1][j]) +\n\t\t\t\t(src[2][i] - src[2][j]) * (src[2][i] - src[2][j]) );\n\t\t\tif( d > src[3][i] + src[3][j] + EPS ) {\n\t\t\t\td -= src[3][i] + src[3][j];\n\t\t\t\tdist[j][i] = d;\n\t\t\t\tdist[i][j] = dist[j][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double distsum = 0.0;\n\tbitset<100> flg(0);\n\tflg.set(0);\n\t\t\n\twhile( flg.count() < n ) {\n\t\tlong double mindist = 10e20;\n\t\tint p, q;\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tif( !flg[j] ) continue;\t\t\t//jは訪問済み頂点\n\t\t\tfor( int k = 0; k < n; k++ ) {\n\t\t\t\tif( flg[k] ) continue;\t\t//kは未訪問頂点\n\t\t\t\tif( j == k ) continue;\n\t\t\t\tif( dist[j][k] + EPS < mindist ) {\n\t\t\t\t\tp = j;\n\t\t\t\t\tq = k;\n\t\t\t\t\tmindist = dist[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdistsum += mindist;\n\t\tflg.set(q);\n\t}\n\n\tprintf(\"%.3llf\\n\",distsum);\n\n\treturn 0;\n}\n     \nint main(void){\n\twhile(1){\n\t\tif( solve() ) break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define DBL(d) ((d)*(d))\n#define DIST(x,y,z,a,b,c) (DBL(x-a)+DBL(y-b)+DBL(z-c))\n\nint main(){\n  int n;\n  double x[110], y[110], z[110], r[110];\n  double d[110][110];\n  while(cin>>n, n){\n    vector<int> f(n);\n    double ans = 0.0;\n    for(int i=0; i<n; i++){\n      cin>>x[i]>>y[i]>>z[i]>>r[i];\n      f[i]=i;\n    }\n\n    for(int i=0; i<n; i++){\n      for(int j=i+1; j<n; j++){\n\tdouble tmp = sqrt(DIST(x[i],y[i],z[i],x[j],y[j],z[j])) - r[j] - r[i];\n\tif(tmp < 0.0) tmp = 0.0;\n\td[i][j]=d[j][i]=tmp;\n      }\n    }\n\n    for(int i=1; i<n; i++){\n      int jj=-1,kk=-1;\n      double dmin = 1e20;\n      for(int j=0; j<n; j++){\n\tfor(int k=j+1; k<n; k++){\n\t  if(f[j]!=f[k] && dmin > d[j][k]){\n\t    jj=j; kk=k;\n\t    dmin = d[j][k];\n\t  }\n\t}\n      }\n      while(jj==-1);\n      int cb = max(f[jj],f[kk]);\n      int ca = min(f[jj],f[kk]);\n      for(int j=0; j<n; j++)\n\tif(f[j] == cb) f[j]=ca;\n      ans += dmin;\n    }\n    printf(\"%.3f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntemplate<typename T>\nclass UnionFind {\n    int size_;\n    std::vector<T> par;\n    std::vector<T> rank;\n    public:\n    UnionFind(int size_) : size_(size_) {\n        par.resize(size_);\n        rank.resize(size_);\n        for(int i=0; i<size_; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    T find(T x) {\n        return par[x] == x ? x : par[x] = find(par[x]);\n    }\n    void unite(T x,T y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]) {\n            par[x] = y;\n        }\n        else {\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(T x,T y) {\n        return find(x) == find(y);\n    }\n};\nint n;\nstruct Sphere {\n    double x,y,z,r;\n};\nstruct Edge {\n    int from;\n    int to;\n    double cost;\n\n    bool operator<(const Edge &rth) const {\n        return cost < rth.cost;\n    }\n};\ndouble pow2(double x) {\n    return x*x;\n}\ndouble dist(Sphere s1, Sphere s2) {\n    double t;\n    t=pow2(s1.x-s2.x);\n    t+=pow2(s1.y-s2.y);\n    t+=pow2(s1.z-s2.z);\n    t=sqrt(t);\n\n    t=t-s1.r-s2.r;\n\n    if(t<0) t=0;\n    return t;\n}\nvoid solve() {\n    UnionFind<int> uf(102);\n    vector<Edge> edges;\n    Sphere sphere[102];\n    rep(i,n) {\n        double x,y,z,r;\n        cin>>x>>y>>z>>r;\n        sphere[i]={x,y,z,r};\n    }\n    rep(i,n) rep(j,n) if(i!=j) {\n        double d=dist(sphere[i],sphere[j]);\n        edges.push_back({i,j,d});\n    }\n\n    sort(all(edges));\n    double ans=0;\n\n    rep(i,edges.size()) {\n        Edge e = edges[i];\n        if(!uf.same(e.from,e.to)) {\n            ans+=e.cost;\n            uf.unite(e.from,e.to);\n        }\n    }\n\n    printf(\"%.3f\\n\",ans);\n}\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = double;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass UnionFind {\n  vector<int> tree, rank, setSize;\n\npublic:\n  UnionFind(const int &n) : tree(n), rank(n), setSize(n, 1) { iota(all(tree), 0); }\n\n  int root(const int &x) { return tree[x] == x ? x : tree[x] = root(tree[x]); }\n\n  bool same(const int &a, const int &b) { return root(a) == root(b); }\n\n  bool unite(int a, int b) {\n    a = root(a), b = root(b);\n    if (a == b) return false;\n    if (rank[a] < rank[b]) swap(a, b);\n    tree[b] = a;\n    setSize[a] += setSize[b];\n    if (rank[a] == rank[b]) rank[a]++;\n    return true;\n  }\n\n  int setSizeOf(const int &x) { return setSize[root(x)]; }\n\n  int size() { return tree.size(); }\n};\n\npair<Weight, Edges> kruskal(const Graph &g) {\n  UnionFind uf(g.size());\n  Edges es;\n  for (auto &adj : g) {\n    for (auto &e : adj) es.emplace_back(e);\n  }\n  sort(es.begin(), es.end(), [](const Edge &e, const Edge &f) { return e.weight < f.weight; });\n  Weight total = 0;\n  Edges tree;\n  for (auto &e : es) {\n    if (uf.unite(e.src, e.dst)) tree.push_back(e), total += e.weight;\n  }\n  return {total, tree};\n}\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<double> x(n), y(n), z(n), r(n);\n    rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    Graph g(n);\n    rep(i, n) loop(j, i + 1, n) {\n      double dx = abs(x[i] - x[j]), dy = abs(y[i] - y[j]), dz = abs(z[i] - z[j]);\n      double d = max(0.0, sqrt(dx * dx + dy * dy + dz * dz) - r[i] - r[j]);\n      g.addEdge(i, j, d);\n    }\n    cout << prec(32) << kruskal(g).first << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tuf.unite(i, j);\n\t\t\t\t\t++c;\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && n-1!=c) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t++c;\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst double EPS = 1e-7;\n\nint n;\ndouble x[110], y[110], z[110], r[110];\n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       for(int i = 0; i < n; i++) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nstruct edge{\n    int u, v;\n    double cost;\n    bool operator<(const edge &e) const{\n        return cost < e.cost;\n    }\n};\n\nvector<edge> es; \n\ndouble kruskal(){\n    double res = 0;    \n    UF uf(n);\n    sort(es.begin(), es.end());\n    for(int i = 0; i < es.size(); i++){\n        edge e = es[i];\n        if(!uf.same(e.u, e.v)){\n            uf.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\ndouble dist(int i, int j){\n    return sqrt(pow(x[j]-x[i], 2) + pow(y[j]-y[i], 2) + pow(z[j]-z[i], 2));\n}\n\nsigned main(){\n    while(cin >> n, n){\n        es.clear();\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                double tmp = dist(i, j) - r[i] - r[j];\n                if(tmp < EPS) tmp = 0.0;\n                es.push_back({i, j, tmp});\n            }\n        }\n        double ans = kruskal();\n        printf(\"%.10f\\n\", ans);\n    }    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=\n*$* WRITER:kakitamasziru/OxOmisosiru *$*\n~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/\n#ifdef LOCAL_JUDGE\n#define _GLIBCXX_DEBUG //FOR THE DEBUG! COMMENT OUT THIS WHEN SUBMITTING!\n#endif\n/* I REALLY HOPE MY WISH REACH YOU , ATCODER'S ONLINE JUDGE */\n#define WOULD\n#define YOU\n#define PLEASE\n#define ACCEPT\n#define MY\n#define SUBMISSION\n/* I REALLY HOPE MY WISH REACH YOU , ATCODER'S ONLINE JUDGE */\n#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <iomanip>\n#include <limits>//setprecision\n//#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <math.h>//pow,,,\n#include <cmath>//abs,,,\n#include <bitset> // bitset\n//It is so troublesome that I include bits/stdc++.h !\nusing namespace std;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\nconst long long INF = 100100100100;\nconst long long MOD = 1000000007;\ntypedef pair<double,int> P;\n//NのM乗を求める(繰り返し二乗法)\nlong long mod_pow(long long N, long long M) {\n    if (M == 0) return 1;\n    long long res = mod_pow((N * N) % MOD, M / 2);\n    //最下位ビット(*N)が1の時は単独でNをかける\n    if (M & 1) res = (res * N) % MOD;\n\n    return res %= MOD;\n}\nlong long nCr(long long n, long long r) {\n    long long A = 1, B = 1;\n    //Aが分子Bが1/r!\n    for (long long i = n - r + 1; i <= n; i++) {\n        A = A * i % MOD;\n    }\n    for (long long i = 1; i <= r; i++) {\n        B = B * i % MOD;\n    }\n    B = mod_pow(B, MOD - 2);\n    B %= MOD;\n    //Bは割るのではなく掛ける\n    return (A * B) % MOD;\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) return a;\n    else return gcd(b, a % b);\n}\n \nlong long lcm(long long a, long long b) {\n    return a * b / gcd(a, b);\n}\n\n//long long A,B;\nbool ok(long long key,long long index){\n    if(index > key) return true;\n    else if(index <= key) return false;\n}\nlong long binary_search(long long key,long long size){\n    //left,right,midはいずれもindex\n    long long left = -1,right = size;\n    while(right - left > 1){\n        long long mid = left + (right-left)/2;\n        long long hantei = ok(key,mid);\n        if(hantei) right = mid;\n        else left = mid;\n    }\n    if(left == -1)return 0;\n    return left;\n}\nconst int MAX_N = 105;\n//firstがcost,secondがto\n\n\ndouble prim(int start,vector<vector<P>> &Edge,vector<bool> &seen){\n    double res = 0.0;\n    seen.at(start) = true;\n    priority_queue<P,vector<P>,greater<P>> Q;\n    for(P U : Edge.at(start)){\n        Q.push(make_pair(U.first,U.second));\n    }\n    while(!Q.empty()){\n        P V = Q.top();Q.pop();\n        double cost = V.first;\n        int to = V.second;\n        if(seen.at(to) == true) continue;\n        seen.at(to) = true;\n        res += cost;\n        for(P next : Edge.at(to)){\n            Q.push(make_pair(next.first,next.second));\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector<double> out;\n    while(true){\n        vector<vector<P>> Edge(MAX_N);\n        vector<bool> seen(MAX_N,false);\n        int N;cin >> N;\n        if(N == 0) break;\n        vector<tuple<double,double,double,double>> retu;\n\n        for(int i = 0;i<N;i++){\n            double x,y,z,r;cin >> x >> y >> z >> r;\n            retu.push_back(make_tuple(x,y,z,r));\n        }\n        for(int i = 0;i<N;i++){\n            for(int j = 0;j<N;j++){\n                if(i == j) continue;\n                double X = get<0>(retu.at(i)) - get<0>(retu.at(j));\n                double Y = get<1>(retu.at(i)) - get<1>(retu.at(j));\n                double Z = get<2>(retu.at(i)) - get<2>(retu.at(j));\n                double R = get<3>(retu.at(i)) + get<3>(retu.at(j));\n                double dist = sqrt(pow(X,2) + pow(Y,2) + pow(Z,2)) - R;\n                if(dist < 0.000) dist = 0.000;\n                Edge.at(i).push_back(make_pair(dist,j));\n            }\n        }\n        double ans = prim(0,Edge,seen);\n        out.push_back(ans);\n    }\n\n    for(int i = 0;i<out.size();i++){\n        cout << fixed << setprecision(3) << out.at(i) << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst double INF = 1e10;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tdouble edge[100][100];\n\t\tfor(int i=0;i<n;++i){\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tdouble distance = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\tdouble cost = max(distance - r[i] - r[j] , 0.0);\n\t\t\t\tedge[i][j] = cost;\n\t\t\t}\n\t\t}\n\t\tdouble mincost[100];\n\t\tbool used[100];\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0.0; double ans=0.0;\n\t\twhile(1){\n\t\t\tint v = -1;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v])) v=i;\n\t\t\t}\n\t\t\tif(v == -1) break;\n\t\t\tused[v] = true;\n\t\t\tans += mincost[v];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tmincost[i] = min(mincost[i], edge[v][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.03f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "3\n10.000 10.000 50.000 10.000\n40.000 10.000 50.000 10.000\n40.000 40.000 50.000 10.000\n2\n30.000 30.000 30.000 20.000\n40.000 40.000 40.000 20.000\n5\n5.729 15.143 3.996 25.837\n6.013 14.372 4.818 10.671\n80.115 63.292 84.477 15.120\n64.095 80.924 70.029 14.881\n39.472 85.116 71.369 5.553\n0"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nusing vd=vector<double>;\nusing data=tuple<double,int,int>;\n\ndouble hypot3(double x,double y,double z){\n\treturn sqrt(x*x+y*y+z*z);\n}\ndouble dist(vd a, vd b){\n\tauto d=hypot3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);\n\treturn max(d-a[3]-b[3],0.0);\n}\n\nstruct UnionFind{\n\tvi p;\n\tUnionFind(int s):p(s,-1){}\n\tvoid union(int a,int b){\n\t\ta=root(a);b=root(b);\n\t\tif(a!=b){\n\t\t\tif(p[b]<p[a])swap(a,b);\n\t\t\tp[a]+=p[b];p[b]=a;\n\t\t}\n\t}\n\tbool same(int a,int b){return root(a)==root(b);}\n\tint root(int a){return p[a]<0?a:p[a]=root(p[a]);}\n};\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vd> cell(n,vd(4));\n\t\tvector<data> edge;\n\t\trep(i,n) {\n\t\t\trep(j,4) cin>>cell[i][j];\n\t\t\trep(j,i) edge.emplace_back(dist(cell[i],cell[j]),i,j);\n\t\t}\n\t\tsort(all(edge),[](data a,data b){return get<0>(a)<get<0>(b);});\n\n\t\tUnionFind uf(n);\n\t\tdouble ans=0;\n\t\tfor(auto e:edge){\n\t\t\tdouble d; int a,b;\n\t\t\ttie(d,a,b)=e;\n\t\t\tif(!uf.same(a,b)){\n\t\t\t\tans+=d;\n\t\t\t\tuf.unite(a,b);\n\t\t\t}\n\t\t}\n\t\tcout.precision(3);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble x[110];\ndouble y[110];\ndouble z[110];\ndouble r[110];\n\nint par[110];\nvoid init(){for(int i=0;i<110;++i)par[i]=i;}\nint find(int x){return (par[x]==x)?x:find(par[x]);}\nvoid unite(int a,int b){a=find(a),b=find(b),par[b]=a;}\nbool same(int a,int b){return find(a)==find(b);}\n\ninline double dist(int a,int b){\n\tdouble d=0;\n\td+=(x[a]-x[b])*(x[a]-x[b]);\n\td+=(y[a]-y[b])*(y[a]-y[b]);\n\td+=(z[a]-z[b])*(z[a]-z[b]);\n\treturn max(0.0,sqrt(d)-r[a]-r[b]);\n}\n\ntypedef tuple<double,int,int> state;\n\nint main(void){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\trep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tinit();\n\t\tdouble ans=0.0;\n\t\tvector<state> edge;\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i>=j)\n\t\t\t\tcontinue;\n\t\t\tdouble d=dist(i,j);\n\t\t\tedge.pb(make_tuple(d,i,j));\n\t\t}\n\t\tsort(edge.begin(),edge.end());\n\t\trep(i,edge.size()){\n\t\t\tdouble d;\n\t\t\tint a,b;\n\t\t\ttie(d,a,b)=edge[i];\n\t\t\tif(same(a,b))\n\t\t\t\tcontinue;\n\t\t\tans+=d;\n\t\t\tunite(a,b);\n\t\t}\n\t\tcout.precision(3);\n\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#define INF 1000000000\nusing namespace std;\ndouble mp[101][101];\nbool flg[101];\ndouble dis[101];\nint n;\n\ndouble prim() {\n  double sum = 0;\n  for(int i=0;i<=n;i++) flg[i] = 0,dis[i] = INF;\n  dis[0] = 0;\n\n  for(int q=0;q<n;q++) {\n    int nx;\n    double dmin = INF;\n    for(int i=0;i<n;i++) \n      if(dmin > dis[i] && flg[i] == 0) dmin = dis[i],nx = i;\n    flg[nx] = 1;\n    sum+=dmin;\n    for(int i=0;i<n;i++) \n      if(mp[nx][i] < dis[i]) dis[i] = mp[nx][i];\n  }\n  return sum;\n\n}\n\nint main() {\n\n\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tmp[i][j] = INF;\n\n    for(int i=0;i<n;i++) {\n      double x[101],y[101],z[101],r[101];\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n      \n      for(int j=0;j<i;j++) {\n\tmp[i][j] = sqrt ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]) )-r[i]-r[j];\n\t//\tcout << mp[i][j] << endl;\n\tif(mp[i][j] < 0) mp[i][j] = 0;\n\tmp[j][i] = mp[i][j];\n      }\n    }\n\n    printf(\"%.8f\\n\",prim());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst double eps = 1e-9;\nconst double inf = 1e9;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\t\n\t\tvector<vector<double> > dist(n, vector<double>(n, inf));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tdouble d = sqrt( (x[i]-x[j])*(x[i]-x[j]) \n\t\t\t\t\t+(y[i]-y[j])*(y[i]-y[j]) +(z[i]-z[j])*(z[i]-z[j]) );\n\t\t\t\tif(d-r[i]-r[j] < eps){\n\t\t\t\t\tdist[i][j] = dist[j][i] = 0.0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = dist[j][i] = d -r[i]-r[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> used(n, false);\n\t\tdouble total=0.0;\n\t\tpriority_queue<pair<double, int> > pq;\n\t\tpq.push(make_pair(0.0, 0));\n\t\twhile(!pq.empty()){\n\t\t\tdouble cost = -pq.top().first;\n\t\t\tint v = pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(used[v]) continue;\n\t\t\tused[v]=true;\n\t\t\ttotal+=cost;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tpq.push(make_pair(-dist[v][i], i));\n\t\t\t}\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(5);\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while ((int)F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\nconst int size = 101;\ndouble X[size];\ndouble Y[size];\ndouble Z[size];\ndouble R[size];\n\ndouble square( double r ) {\n    return r*r;\n}\n\ndouble getDist( int a, int b ) {\n    return sqrt( square( X[a]-X[b] ) + square( Y[a]-Y[b] ) + square( Z[a]-Z[b] ) );\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        for ( int i = 0; i < n; i++ ) {\n            cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n        }\n        Graph g(n);\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                double d = getDist(i,j);\n                if ( d <= R[i] + R[j] ) {\n                    g[i].push_back( Edge( i, j, 0 ) );\n                } else {\n                    g[i].push_back( Edge( i, j, d-R[i]-R[j] ) );\n                }\n            }\n        }\n        printf( \"%.3f\\n\", minimumSpanningForest(g).first );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nstruct Corr\n{\n\tint to;\n\tdouble len;\n\tCorr(int to, double len)\n\t\t: to(to), len(len) { }\n};\nbool operator<(const Corr& a, const Corr& b)\n{\n\treturn a.len > b.len;\n}\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tdouble x[128], y[128], z[128], r[128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\n#define SQ(d, a, b) ((d[a] - d[b])*(d[a] - d[b]))\n#define LEN(a, b) (max(0.0, sqrt(SQ(x, a, b) + SQ(y, a, b) + SQ(z, a, b)) - (r[a] + r[b])))\n\t\tvector<Corr> cor[128];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t\tcor[i].push_back(Corr(j, LEN(i, j))), cor[j].push_back(Corr(i, LEN(i, j)));\n\n\t\tbool used[128];\n\t\tclear(used, 0);\n\t\tpriority_queue<Corr> q;\n\t\tused[0] = true;\n\t\tforeach (it, cor[0])\n\t\t\tq.push(*it);\n\t\tdouble res = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tCorr c = q.top(); q.pop();\n\t\t\tif (used[c.to])\n\t\t\t\tcontinue;\n\n\t\t\tres += c.len;\n\t\t\tused[c.to] = true;\n\t\t\tforeach (it, cor[c.to])\n\t\t\t\tq.push(*it);\n\t\t}\n\t\tprintf(\"%.3f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nconst int INF = numeric_limits<int>::max() / 2;\n\nstruct cell\n{\n\tdouble x, y, z, r;\n};\n\ndouble calc(cell p, cell q)\n{\n\tdouble tmp = sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) + (p.z - q.z) * (p.z - q.z));\n\tif (tmp <= p.r + q.r)\n\t\treturn 0;\n\telse\n\t\treturn (-p.r - q.r + tmp);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tvector<cell> cells;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcell c;\n\t\t\tcin >> c.x >> c.y >> c.z >> c.r;\n\t\t\tcells.push_back(c);\n\t\t}\n\t\tvector<vector<double>> dis(n, vector<double>(n, INF));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t\tdis[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdis[i][j] = calc(cells[i], cells[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> used(n, false);\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tdouble res = 0;\n\t\tque.push(P(0, 0));\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tif (used[p.second])\n\t\t\t\tcontinue;\n\t\t\tused[p.second] = true;\n\t\t\tres += p.first;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (!used[i])\n\t\t\t\t{\n\t\t\t\t\tque.push(P(dis[p.second][i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(3) << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    int cnt;\n    UnionFind(int n) : par(n, -1), cnt(n) {}\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y];\n            par[y] = x;\n            cnt--;\n        }\n    }\n    int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n    bool same(int x, int y) { return find(x) == find(y); }\n    int size(int x) { return -par[find(x)]; }\n    int size() { return cnt; }\n};\n\nstruct Edge {\n    int from, to;\n    double cost;\n    Edge(int s, int t, double c) : from(s), to(t), cost(c) {}\n};\n\nbool operator<(const Edge &a, const Edge &b) { return a.cost < b.cost; }\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        UnionFind uf(n);\n        vector<Edge> g;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dx = x[i] - x[j];\n                double dy = y[i] - y[j];\n                double dz = z[i] - z[j];\n                double dr = -r[i] - r[j];\n                double d1 = dx * dx + dy * dy + dz * dz;\n                double d2 = dr * dr;\n                double d = max(0.0, dr + sqrt(d1));\n                g.push_back(Edge(i, j, d));\n            }\n        }\n        sort(g.begin(), g.end());\n        double res = 0.0;\n        for (int i = 0; i < g.size(); i++) {\n            Edge e = g[i];\n            if(!uf.same(e.from, e.to)){\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n        cout << fixed << setprecision(3);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ld cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\nld kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tld res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { ld x, y, z, r; };\nld dis(point a,point b) {\n\tld res;\n\tres = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n\tres -= a.r + b.r;\n\tif (res < eps) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[101];\n\t\tld x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(5) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Point{\n    double x, y, z;\n    double r;\n};\n\n\ndouble dist(Point a, Point b){\n    auto pow = [](double a){return a * a; };\n    return sqrt(pow(b.x - a.x) + pow(b.y - a.y) + pow(b.z - a.z)) - (a.r + b.r);\n}\n\nclass Edge {\n    public:\n        int to;\n        double cost;\n        Edge(int to, double cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble prim(const Graph &g, int s = 0) {\n    int n = g.size();\n    double total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n    //priority_queue<pair<double, int> > q;\n\n    q.push(make_pair(0.0,s));\n    while (not q.empty()) {\n        pair<double, int> u = q.top(); q.pop();\n        if (visited[u.second]) continue;\n        total += u.first;\n        visited[u.second] = true;\n        for(auto it : g[u.second]) {\n            if (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n        }\n    }\n    return total;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        Point p[105];\n        rep(i,n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n\n        Graph g(n);\n        rep(i,n){\n            rep(j,n){\n                double tmp = dist(p[i], p[j]);\n//                cout << i << ' ' << j << endl;\n//                show(tmp)\n                g[i].emplace_back(Edge{j,tmp < 0 ? 0 : tmp});\n            }\n        }\n        cout <<fixed << setprecision(3) <<  prim(g,0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\nconst double INF = 1e10;\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        vector<vector<double> > dis(n, vector<double>(n, INF));\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double tdis = pow(x[i] - x[j], 2.0) + pow(y[i] - y[j], 2.0) + pow(z[i] - z[j], 2.0);\n                tdis = sqrt(tdis) - r[i] - r[j];\n                if (tdis < 0.0) tdis = 0.0;\n                dis[i][j] = dis[j][i] = tdis;\n            }\n        }\n\n        priority_queue<P, vector<P>, greater<P> > que;\n        vector<bool> used(n, false);\n        double res = 0.0;\n        for (int i = 0; i < n; i++) {\n            que.push(P(dis[0][i], i));\n        }\n        used[0] = true;\n        while (que.size()) {\n            P p = que.top(); que.pop();\n\n            if (used[p.second]) continue;\n            res += p.first;\n            used[p.second] = true;\n            for (int i = 0; i < n; i++) {\n                que.push(P(dis[p.second][i], i));\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define INF 1e9\ntypedef long long ll;\n\nstruct UnionFind{\n    vector<int> data;\n    //data[i] = -x ... iが根であり、サイズがx\n    //data[i] = x ... iの親がx\n\n    //最初は全員根\n    UnionFind(int size): data(size,-1){}\n\n    bool union_set(int x, int y){//サイズがx>yになるようにしてから、xにyをつなげる\n        x=root(x);\n        y=root(y);\n        if(x != y){\n            if(data[y] < data[x]) swap(x,y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool find_set(int x, int y){//ルートが一致するかどうかを返す\n        return root(x) == root(y);\n    }\n    int root(int x){//根を見つける。ついでに深さ2にしちゃう\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\n\nstruct Edge{\n    int s,t;\n    double cost;\n    bool operator<(const Edge &o) const{\n        return cost < o.cost;\n    }\n};\n\nstruct Graph{\n    int n;\n    vector<Edge> es;\n\n    double kruskal(){\n        sort(ALL(es));\n\n        UnionFind uf(n);\n        double min_cost = 0;\n        REP(i,es.size()){\n            Edge& e = es[i];\n            if(!uf.find_set(e.s, e.t)){//辺を追加しても閉路ができなければ採用\n                min_cost += e.cost;\n                uf.union_set(e.s, e.t);\n            }\n        }\n\n        return min_cost;\n    }\n};\n\nint main() {\n    while(1){\n        int n; cin >> n;\n        if (n==0){\n            return 0;\n        }\n\n        vector<vector<double>> inputs(n, vector<double>(4));\n        REP(i,n){\n            double x,y,z,r; cin >> x >> y >> z >> r;\n            inputs[i] = {x,y,z,r};\n        }\n\n        Graph g;\n        g.n = n;\n\n        REP(i,n-1){\n            FOR(j,i+1,n){\n                double l;\n                l = sqrt( pow(inputs[i][0]-inputs[j][0], 2)+pow(inputs[i][1]-inputs[j][1], 2)+pow(inputs[i][2]-inputs[j][2], 2));\n                if (l <= inputs[i][3]+inputs[j][3]){\n                    g.es.push_back({i,j,0.0});\n                }else{\n                    g.es.push_back({i,j,l-inputs[i][3]-inputs[j][3]});\n                }\n            }\n        }\n\n        cout << fixed << setprecision(3) << g.kruskal() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\n\nstruct UnionFind{\n    vector<int> par;\n    vector<int> dep;\n\n    UnionFind(int siz){\n        par.assign(siz,0);\n        dep.assign(siz,0);\n        for(int i = 0; i < siz; i++){\n            par[i] = i;\n        }\n    };\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(dep[x] < dep[y]) par[x] = y;\n        else{\n            par[y] = x;\n            if(dep[x] = dep[y]) dep[x]++;\n        }\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{int from, to; double cost;};\n\nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\nint main(){\n    int n; \n    while(cin >> n && n){\n        vector<vector<double>> v(n, vector<double>(4));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 4; j++) cin >> v[i][j];\n        }\n\n        vector<edge> e;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                double x = v[i][0] - v[j][0];\n                double y = v[i][1] - v[j][1];\n                double z = v[i][2] - v[j][2];\n                double cost = sqrt(x*x + y*y + z*z);\n                cost = max((double)0, cost - v[i][3] - v[j][3]);\n                e.push_back({i, j, cost});\n            }\n        }\n\n        UnionFind uf(n);\n        sort(all(e), comp);\n        double ans = 0;\n        for(int i = 0; i < (n-1)*n/2; i++){\n            if(uf.same(e[i].from, e[i].to)) continue;\n            uf.unite(e[i].from, e[i].to);\n            ans += e[i].cost;\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOTCONNECTED 0 // WHITE\n#define CANDIDATE 1 // GRAY\n#define CONNECTED 2 // BLACK\nusing namespace std;\ndouble getDistance(vector<double>, vector<double>);\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<vector<double> > cells;\n    for(int i = 0; i < n; ++i) {\n      double y, x, z, r;\n      cin >> x >> y >> z >> r;\n      cells.push_back(vector<double>({x, y, z, r}));\n    }\n    vector<int> minWeights(n, INT_MAX); // d\n    minWeights[0] = 0;\n    vector<int> states(n, NOTCONNECTED); // color\n    vector<int> parents(n, -1); // p\n    while(true) {\n      int minv = INT_MAX;\n      int u = -1;\n      for(int i = 0; i < n; ++i) {\n        if(minv > minWeights[i] && states[i] == NOTCONNECTED) {\n          u = i;\n          minv = minWeights[i];\n        }\n      }\n      if(u == -1) break;\n      states[u] = CONNECTED;\n      for(int v = 0; v < n; ++v) {\n        if(states[v] == NOTCONNECTED && minWeights[v] > getDistance(cells[u], cells[v])) {\n          minWeights[v] = getDistance(cells[u], cells[v]);\n          parents[v] = u;\n          // states[v] = CANDIDATE;\n        }\n      }\n    }\n    double ans = 0;\n    for(int i = 0; i < n; ++i) {\n      if(parents[i] != -1) ans += getDistance(cells[i], cells[parents[i]]);\n    }\n    printf(\"%.3f\", ans);\n    cout << endl;\n  }\n  return 0;\n}\n\ndouble getDistance(vector<double> a, vector<double> b) {\n  double dx = abs(a[0] - b[0]);\n  double dy = abs(a[1] - b[1]);\n  double dz = abs(a[2] - b[2]);\n  double ans = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - a[3] - b[3];\n  return ans < 0 ? 0 : ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\ntypedef pair<double ,pair<int, int> > pdii; // distance, point1, point2\n\nint n;\ndouble dis[100][100];\nint unit[100];\nvector<pdii> difdis(100);\n\ndouble x[100], y[100], z[100], r[100];\ndouble cordis;\n\ndouble dis3d(double x1, double y1, double z1, double x2, double y2, double z2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n}\n\nbool allunited(){\n    int u = unit[0];\n    REP(i, n){\n        if(unit[i] != u) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        REP(i, n){\n            cin >> x[i];\n            cin >> y[i];\n            cin >> z[i];\n            cin >> r[i];\n        }\n\n        REP(i, n){\n            REP(j, n){\n                if(i==j){\n                    dis[i][j] = 0;\n                } else {\n                    dis[i][j] = dis3d(x[i], y[i], z[i], x[j], y[j], z[j]) - (r[i]+r[j]);\n                }\n            }\n        }\n\n        REP(i, n) unit[i] = i;\n        REP(i, n){\n            int u = unit[i];\n            vector<int> update;\n            update.push_back(unit[i]);\n            REP(j, n){\n                if(dis[i][j]<=0){\n                    update.push_back(unit[j]);\n                    u = min(u, unit[j]);\n                    unit[j] = unit[i];\n                }\n            }\n            REP(j, n){\n                REP(k, update.size()){\n                    if(unit[j] == update[k]){\n                        unit[j] = u;\n                    }\n                }\n            }\n        }\n\n        cordis = 0;\n        while(1){\n            if(allunited()) break;\n\n            difdis = vector<pdii>();\n            REP(i, n){\n                for(int j=i+1; j<n; j++){\n                    if(unit[i] != unit[j]){\n                        difdis.push_back(pdii(dis[i][j], make_pair(i, j)));\n                    }\n                }\n            }\n\n            sort(difdis.begin(), difdis.end());\n            cordis += difdis[0].first;\n            int ci = difdis[0].second.first;\n            int cj = difdis[0].second.second;\n\n            int ucj = unit[cj];\n            REP(i, n){\n                if(unit[i] == ucj){\n                    unit[i] = unit[ci];\n                }\n            }\n        }\n\n        cout << fixed << setprecision(3) << cordis << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nstruct Cell {\n\tdouble x, y, z, r;\n};\n\nstruct Edge {\n\tint to;\n\tdouble distance;\n\tbool operator <(const Edge &a) const {\n\t\treturn distance > a.distance;\n\t}\n};\n\nCell cells[101];\nbool visited[101];\ndouble distances[101][101];\n\nint main() {\n\tint n;\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cells[i].x >> cells[i].y >> cells[i].z >> cells[i].r;\n\t\t\tvisited[i] = false;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdistances[i][j] = distances[j][i]\n\t\t\t\t\t= max(0.0,\n\t\t\t\t\t\tsqrt(pow(cells[i].x - cells[j].x, 2) + pow(cells[i].y - cells[j].y, 2)\n\t\t\t\t\t\t+ pow(cells[i].z - cells[j].z, 2))\n\t\t\t\t\t\t- cells[i].r - cells[j].r\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<Edge> pq;\n\t\tint current_vertex = 0;\n\t\tdouble length = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tvisited[current_vertex] = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif(!visited[j]) {\n\t\t\t\t\tEdge e;\n\t\t\t\t\te.to = j;\n\t\t\t\t\te.distance = distances[i][j];\n\t\t\t\t\tpq.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()) {\n\t\t\t\tEdge e = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(!visited[e.to]) {\n\t\t\t\t\tcurrent_vertex = e.to;\n\t\t\t\t\tlength += e.distance;\n\t\t\t\t\t//cout << \"goto:\" << e.to << \", dist:\" << e.distance << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << length << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst int INF = 10000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ndouble cost[101][101];\ndouble mincost[101];\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\ndouble INF = numeric_limits<double>::max();\nint main(void){\n    int n;\n    while(cin >> n && n) {\n        rep(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, n) rep(j, n) {\n            cost[i][j] = max(sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j], 0.0);\n        }\n        // prim\n        rep(i, n) {\n            mincost[i] = INF;\n            used[i] = false;\n        }\n        mincost[0] = 0;\n        double res = 0;\n\n        while(true) {\n            int v = -1;\n            rep(u, n) {\n                if(!used[u] && (v==-1 || mincost[u] < mincost[v])) v = u;\n            }\n            if(v == -1) break;\n            used[v] = true;\n            res += mincost[v];\n\n            rep(u, n) {\n                mincost[u] = min(mincost[u], cost[v][u]);\n            }\n        }\n        printf(\"%.3lf\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<cmath>\nusing ll = long long;\nusing namespace std;\n#define rep(i,n) for(int i=0, i##_len=(int)(n); i<i##_len; i++)\n#define reps(i,n) for(int i=1 , i##_len=(int)(n);i<=i##_len;i++)\n#define rrep(i,n) for(int i=((int)(n)-1);i>=0;i--)\n#define rreps(i,n) for(int i=((int)(n));i>0;i--)\n#define all(x) (x).begin(), (x).end()\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define solve(a) ((a)?\"Yes\":\"No\")\ntypedef vector<long long> V;\ntypedef vector<V> VV;\ntypedef pair<long long , long long> P;\ntypedef vector<P> VP;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1;} return 0;}\nconst long long INFLL = 1LL<<62;\nconst int INF = 1<<30;\nconst double PI=acos(-1);\n//include UnionFind\n//union by size + path having\nclass UnionFind{\n\tpublic:\n\tvector<long long> par; // 各元の親を表す配列\n\tvector<long long> siz; // 素集合のサイズを表す配列(1 で初期化)\n\n\n\t// Constructor\n\tUnionFind(long long sz_) : par(sz_), siz(sz_,1LL){\n\t\tfor (long long i = 0; i < sz_; ++i)\n\t\tpar[i] = i; // 初期では親は自分自身\n\t}\n\tvoid init(long long sz_){\n\t\tpar.resize(sz_);\n\t\tsiz.assign(sz_,1LL); // resize だとなぜか初期化されなかった\n\t\tfor (long long i = 0; i < sz_; ++i)\n\t\t\tpar[i] = i; // 初期では親は自分自身\n\t}\n\t// Member Function\n\n\n\t// Find\n\tlong long root(long long x){ // 根の検索\n\t\twhile (par[x] != x){\n\t\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t\t}\n\t\treturn x;\n\t}\n\t// 結合(Unite, Merge)\n\tbool merge(long long x, long long y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y){\n\t\t\treturn false;\n\t\t}\n\t\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\t\tif (siz[x] < siz[y]){\n\t\t\tswap(x, y);\n\t\t}\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\n\t// 連結判定(つながっているときはture,つながっていなければfalse)\n\tbool issame(long long x, long long y){ \n\t\treturn root(x) == root(y);\n\t}\n\n\n\t// 素集合のサイズ\n\tlong long size(long long x){ \n\t\treturn siz[root(x)];\n\t}\n};\n\n//クラスカル法(隣接リストから最小全域木を隣接リストで返す)\n//計算量 (辺)log(頂点)\nvector<vector<pair<int, double>>> Kruskal(vector<vector<pair<int, double>>> pathlist)\n{\n\tvector<pair<double, pair<int, int>>> paths;\n\tint edge=pathlist.size();\n\tUnionFind conect(edge);\n\tvector<vector<pair<int, double>>> res(edge);\n\trep(i, edge){\n\t\tfor (auto itr = pathlist[i].begin(); itr != pathlist[i].end(); itr++){\n\t\t\tpaths.emplace_back(itr->S, mp(i, itr->F));\n\t\t}\n\t}\n\tsort(all(paths));\n\tfor (auto at = paths.begin(); at != paths.end(); at++){\n\t\tif (conect.merge(at->S.F, at->S.S)){\n\t\t\tres[at->S.F].emplace_back(at->S.S, at->F);\n\t\t\tres[at->S.S].emplace_back(at->S.F, at->F);\n\t\t\tif (conect.size(0) == edge){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tvector<vector<pair<int, double>>> res;\n\tint n = 1;\n\tdouble ans=0.0;\n\tvector<vector<pair<int, double>>> path ;\n\tvector<tuple<double,double,double,double>>data;\n\twhile (1)\n\t{\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tpath.clear();\n\t\tpath.resize(n);\n\t\t//data.resize(n);\n\t\tdata.clear();\n\t\tres.clear();\n\t\tans=0.0;\n\t\tdouble x,y,z,r;\n\t\trep(i,n){\n\t\t\tcin>>x>>y>>z>>r;\n\t\t\tdata.push_back(make_tuple(x,y,z,r));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tx = get<0>(data[i]) - get<0>(data[j]);\n\t\t\t\ty = get<1>(data[i]) - get<1>(data[j]);\n\t\t\t\tz = get<2>(data[i]) - get<2>(data[j]);\n\t\t\t\tr = get<3>(data[i]) + get<3>(data[j]);\n\t\t\t\tpath[i].emplace_back(j, max(0.0, sqrt(x*x+y*y+z*z) -r));\n\t\t\t//\tclog<<i<<\" \"<<j<<endl;\n\t\t\t//\tclog<<x<<\" \"<<y<<\" \"<<z<<\" \"<<r<<endl;\n\t\t\t//\tclog<<path[i].back().S<<endl;\n\t\t\t}\n\t\t}\n\t\tres=Kruskal(path);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(auto itr=res[i].begin();itr!=res[i].end();itr++){\n\t\t\t\tans+=itr->S;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\",ans/2.0);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG_OUTPUT\n#define DEBUG_LOG(s) cout << s << endl;\n#else\n#define DEBUG_LOG(s) void();\n#endif\n\nclass UnionFindTree {\nprivate:\n    vector<int> parent;\n    vector<int> count;\npublic:\n    UnionFindTree(int n) : parent(n), count(n, 1) {\n        // 最初は全てを根として初期化\n        for(int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int get_root(const int x) {\n        // データxが属する木の根を取得する\n        if (parent[x] == x) return x;\n        // 取得したものは直接木の根をつなぐ(経路圧縮)\n        return parent[x] = get_root(parent[x]);\n    }\n\n    void unite(const int x, const int y) {\n        // xとyの木を併合する\n        int rx = get_root(x);\n        int ry = get_root(y);\n        // 元から同じ木に属している場合は何もしない\n        if (rx == ry) return;\n        // xの属する木をyの属する木につける\n        parent[rx] = ry;\n        count[ry] += count[rx];\n        count[rx] = 0;\n    }\n\n    bool is_same_root(const int x, const int y) {\n        return get_root(x) == get_root(y);\n    }\n\n    int get_size(const int x) {\n        return count[get_root(x)];\n    }\n\n    void print() {\n        for(auto elm : parent) cout << elm << \" \";\n        cout << endl;\n        for(auto elm : count) cout << elm << \" \";\n        cout << endl;\n    }\n};\n\nstruct cell {\n    double x;\n    double y;\n    double z;\n    double r;\n};\n\nint main() {\n\n    while (true) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<cell> c(n);\n        for (auto i = 0; i < n; i++) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            c[i] = {x, y, z, r};\n        }\n\n        UnionFindTree tree(n);\n        map<double, vector<pair<int, int>>> g;\n        for (auto i = 0; i < n; i++) {\n            for (auto j = i + 1; j < n; j++) {\n                double nx = (c[i].x - c[j].x) * (c[i].x - c[j].x);\n                double ny = (c[i].y - c[j].y) * (c[i].y - c[j].y);\n                double nz = (c[i].z - c[j].z) * (c[i].z - c[j].z);\n                double nr = (c[i].r + c[j].r) * (c[i].r + c[j].r);\n                // cout << i << \" \" << j << endl;\n                // cout << nx << \" \" << ny << \" \" << nz << \" \" << nr << endl;\n                if (nx + ny + nz > nr)\n                    g[sqrt(nx + ny + nz) - sqrt(nr)].emplace_back(i, j);\n                else\n                    g[0].emplace_back(i, j);\n            }\n        }\n\n        double ans = 0;\n        for (auto &a : g) {\n            // cout << \"a:\" << a.first << endl;\n            for (auto &b : a.second) {\n                // cout << \"b:\" << b.first << \" \" << b.second << endl;\n                if (not tree.is_same_root(b.first, b.second)) {\n                    tree.unite(b.first, b.second);\n                    ans += a.first;\n                }\n            }\n        }\n\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tuf.unite(i, j);\n\t\t\t\t\t++c;\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && c<n-1) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t++c;\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct UF\n{\n\tvector<int>v;\n\tUF():v(100,-1){};\n\tint R(int x){return v[x]<0?x:v[x]=R(v[x]);}\n\tint U(int x,int y)\n\t{\n\t\tx=R(x);\n\t\ty=R(y);\n\t\tif(x-y)\n\t\t{\n\t\t\tif(v[x]<v[y])swap(x,y);\n\t\t\tv[y]+=v[x];\n\t\t\tv[x]=y;\n\t\t}\n\t\treturn x-y;\n\t}\n};\ndouble F(double x){return x*x;}\nstruct S{double d;int a,b;S(double d,int a,int b):d(d),a(a),b(b){}bool operator<(const S&s){return d<s.d;}};\nint main()\n{\n\tint n,i,j;\n\tdouble x[100],y[100],z[100],r[100],d,res;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tvector<S>v;\n\t\tUF uf;\n\t\tfor(i=0;i<n;++i)scanf(\"%lf%lf%lf%lf\",x+i,y+i,z+i,r+i);\n\t\tfor(i=0;i<n;++i)for(j=i+1;j<n;++j)\n\t\t{\n\t\t\td=sqrt(F(x[i]-x[j])+F(y[i]-y[j])+F(z[i]-z[j]))-r[i]-r[j];\n\t\t\tif(d<0)uf.U(i,j);\n\t\t\telse v.push_back(S(d,i,j));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tres=0;\n\t\tfor(i=0;i<v.size();++i)\n\t\t{\n\t\t\tS s=v[i];\n\t\t\tif(uf.U(s.a,s.b))res+=s.d;\n\t\t}\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#define INF 1000000000\nusing namespace std;\ndouble mp[101][101];\nbool flg[101];\ndouble dis[101];\nint n;\n\ndouble prim() {\n  double sum = 0;\n  for(int i=0;i<=n;i++) flg[i] = 0,dis[i] = INF;\n  dis[0] = 0;\n\n  for(int q=0;q<n;q++) {\n    int nx;\n    double dmin = INF;\n    for(int i=0;i<n;i++) \n      if(dmin > dis[i] && flg[i] == 0) dmin = dis[i],nx = i;\n    flg[nx] = 1;\n    sum+=dmin;\n    for(int i=0;i<n;i++) \n      if(mp[nx][i] < dis[i]) dis[i] = mp[nx][i];\n  }\n  return sum;\n\n}\n\nint main() {\n\n\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tmp[i][j] = INF;\n\n    for(int i=0;i<n;i++) {\n      double x[101],y[101],z[101],r[101];\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n      \n      for(int j=0;j<i;j++) {\n\tmp[i][j] = sqrt ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]) )-r[i]-r[j];\n\t//\tcout << mp[i][j] << endl;\n\tif(mp[i][j] < 0) mp[i][j] = 0;\n\tmp[j][i] = mp[i][j];\n      }\n    }\n\n    printf(\"%.3f\\n\",prim());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define INF 1e9\n\nstruct sphere {\n  double x,y,z,r;\n};\n\nbool eq(double a,double b) {\n  return fabs(a-b)<EPS;\n}\n\ndouble f(double a) { return a*a; }\n\ndouble dist(sphere a,sphere b) {\n  double d=sqrt(f(a.x-b.x)+f(a.y-b.y)+f(a.z-b.z));\n  if(d<=a.r+b.r) return 0;\n  return d-(a.r+b.r);\n}\n\ntemplate <typename T> \nT prim(vector<vector<pair<int, T> > > G) {\n\tT cost = 0;\n\tconst int N = G.size();\n\tvector<bool> used(G.size());\n\tpriority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > pq;\n\tpq.push(make_pair(0, 0));\n\twhile (!pq.empty()) {\n\t\tpair<T, int> p = pq.top(); pq.pop();\n\t\tint now = p.second;\n\t\tif (used[now]) continue;\n\t\tused[now] = true;\n\t\tcost += p.first;\n\t\tfor (auto e : G[now])\n\t\t\tpq.push(make_pair(e.second, e.first));\n\t}\n\treturn cost;\n}\n\nint main() {\n  int n;\n  while(cin >> n,n) {\n    vector<sphere> s(n);\n    for(auto &a:s) cin >> a.x >> a.y >> a.z >> a.r;\n    vector<vector<pair<int,double> > > G(n);\n    for(int i=0;i<n;++i) {\n      for(int j=i+1;j<n;++j) {\n\tdouble d=dist(s[i],s[j]);\n\tG[i].push_back(make_pair(j,d));\n\tG[j].push_back(make_pair(i,d));\n      }\n    }\n    printf(\"%.3f\\n\",prim(G));\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble INF = 1'000'000'000.0;\ntypedef pair<double, int> P;\n\nint main(){\n    while (1){\n        int n;\n        cin >> n;\n        if (!n) break;\n        vector<vector<double>> sphere(n, vector<double>(4));\n        for (int i = 0; i < n; i++) cin >> sphere[i][0] >> sphere[i][1] >> sphere[i][2] >> sphere[i][3];\n        vector<vector<double>> distance(n, vector<double>(n, 0.0));\n        for (int i = 0; i < n; i++){\n            for (int j = i + 1; j < n; j++){\n                double x = (sphere[i][0] - sphere[j][0]);\n                double y = (sphere[i][1] - sphere[j][1]);\n                double z = (sphere[i][2] - sphere[j][2]);\n                double r = sqrt(x * x + y * y + z * z) - sphere[i][3] - sphere[j][3];\n                if (r < 0) r = 0;\n                distance[i][j] = r;\n                distance[j][i] = r;\n            }\n        }\n\n        double ans = 0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<bool> check(n, false);\n        que.push({0, 0});\n        while (que.size()){\n            double d = que.top().first;\n            int s = que.top().second;\n            que.pop();\n            if (check[s]) continue;\n            check[s] = true;\n            ans += d;\n            for (int i = 0; i < n; i++){\n                if (!check[i]) que.push({distance[s][i], i});\n            }\n        }\n        cout << fixed;\n        cout << setprecision(3) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nbool isprime(int n){\n    double rootn = sqrt(n);\n    if (n < 2){\n        return false;\n    }\n    else if (n == 2){\n        return true;\n    }\n    else if (n % 2 == 0){\n        return false;\n    }\n    else{\n        for(int i = 3; i <= rootn; i += 2){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// 空のベクトルを二つ渡す。N (>=2) 以下の素数を primes に順番に入れる。\nvoid prime_vectors(int N, vector<int>& primes, vector<bool>& is_prime){\n    primes = {};\n    is_prime = {};\n    for(int i=0; i<=N; i++){\n        is_prime.push_back(true);\n    }\n\n    primes.push_back(2);\n    for(int j=4; j<=N; j+=2){\n        is_prime[j] = false;\n    }\n\n    int i;\n    for(i=3; i*i<=N; i+=2){\n        if(!is_prime[i]) continue;\n        primes.push_back(i);\n        for(int j=2*i; j<=N; j+=i){\n            is_prime[j] = false;\n        }\n    }\n\n    for(; i<=N; i+=2){\n        if(is_prime[i]){\n            primes.push_back(i);\n        }\n    }\n}\n\n\nstruct UnionFind{\n    vector<int> par;\n\n    UnionFind(int n): par(n){\n        for(int i=0; i<n; i++){\n            par[i] = i;\n        }\n    }\n\n    int root(int i){\n        if(par[i] == i) return i;\n        else return par[i] = root(par[i]);\n    }\n\n    void unite(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx != ry){\n            par[rx] = ry;\n        }\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\n// 二つの球の最短距離\n// 中心の距離 - 半径の和\n// すなわち、負数も取りうる\ndouble dis_two_sphere(double x1, double y1, double z1, double r1, double x2, double y2, double z2, double r2){\n    double d_sq = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2);\n    return sqrt(d_sq) - (r1+r2);\n}\nsigned main(){\n    cout << fixed << setprecision(3) << flush;\n\n    int n;\n    cin >> n;\n    vector<double> ans;\n    while(n != 0){\n        vector<double> x(n), y(n), z(n), r(n);\n        for(int i=0; i<n; i++){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        UnionFind uf(n);\n        // 距離を求めて小さい順に並べる\n        vector<tuple<double, int, int>> dis; // 距離, i, j (i < j)\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j<n; j++){\n                double d = dis_two_sphere(x[i], y[i], z[i], r[i], x[j], y[j], z[j], r[j]);\n                // くっついてるやつをつなげる\n                if(d < 0.0){\n                    uf.unite(i, j);\n                }\n                else{\n                    dis.push_back(make_tuple(d, i, j));\n                }\n            }\n        }\n        sort(dis.begin(), dis.end());\n\n        // Kruskal\n        double res = 0.0;\n        for(int i=0; i<dis.size(); i++){\n            double d = get<0>(dis[i]);\n            int a = get<1>(dis[i]);\n            int b = get<2>(dis[i]);\n            if(!uf.same(a, b)){\n                uf.unite(a, b);\n                res += d;\n            }\n        }\n\n        ans.push_back(res);\n        cin >> n;\n    }\n\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec secondstruct edge{ int u, v, cost; };\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nstruct edge{ int u, v; double cost; };\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\nint par[100];\nint rank[100];\nedge es[10000];\nint V, E;\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\t\n\tif(rank[x] < rank[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\ndouble kruskal(){\n\tsort(es, es+E, comp);\n\tdouble res = 0.0;\n\tfor(int i = 0; i < E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tdouble x[100], y[100], z[100], r[100];\n\trep(i,V) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\tinit(V);\n\tE = 0;\n\trep(i,V){\n\t\tfor(int j = i+1; j < V; j++){\n\t\t\tif((r[j]+r[i])*(r[j]+r[i]) < (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j])){\n\t\t\t\tedge e;\n\t\t\t\te.u = i;\n\t\t\t\te.v = j;\n\t\t\t\te.cost = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[j]-r[i];\n\t\t\t\tes[E] = e;\n\t\t\t\tE++;\n\t\t\t} else{\n\t\t\t\tunite(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\", kruskal());\n}\n\nint main(){\n\twhile(cin >> V,V) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <tuple>\n#include <iomanip>\n#include <cmath>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef tuple<double,int,int> T;\n\nclass UnionFind {\npublic:\n    vector<int> par;\n    int size;\n    UnionFind(int n) {\n        size = n;\n        par.resize(n);\n        REP (i, 0, n) par[i] = i;\n    }\n    int find(int n) {\n        return (n == par[n] ? n : par[n] = find(par[n]));\n    }\n    bool unite(int a, int b) {\n        a = find(a);\n        b = find(b);\n        if (a == b) return false;\n        par[a] = b;\n        size--;\n    }\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        REP (i, 0, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        UnionFind uf(n);\n        vector<T> v;\n        v.reserve(n * n);\n        REP (i, 0, n) REP (j, i + 1, n) {\n            double dis = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n            v.push_back(make_tuple(max(0.0, dis - r[i] - r[j]), i, j));\n        }\n        sort(begin(v), end(v));\n        double ans = 0;\n        REP (i, 0, v.size()) {\n            T tp = v[i];\n            if (uf.unite(get<1>(tp), get<2>(tp))) {\n                ans += get<0>(tp);\n            }\n        }\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n\n  UnionFind(int n) : par(n), rank(n, 1) {\n    for(int i=0; i<n; ++i) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) swap(x, y);\n    par[y] = x;\n    rank[x] += rank[y];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n};\n\nstruct edge{\n    int src, dst;\n    double cost;\n    edge(int s, int t, double c) : src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost < rhs.cost;}\n};\n\nint main(void) {\n    int n;\n    while(cin >> n && n) {\n        UnionFind uf(n);\n        vector<double> x(n), y(n), z(n), r(n);\n        vector<edge> edges;\n        REP(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(i, n)  {\n            REP(j, n) {\n                if(i == j) continue;\n                double c = sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j];\n                edges.push_back(edge(i, j, max(0.0, c)));\n            }\n        }\n        sort(edges.begin(), edges.end());\n\n        double ans = 0;\n        for(auto e : edges) {\n            if(!uf.same(e.src, e.dst)) {\n                uf.unite(e.src, e.dst);\n                ans += e.cost;\n            }\n        }\n        printf(\"%.6f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdio.h>\n#define INF 1e9\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\nusing namespace std;\nstruct station{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\ndouble a[101][101];\ndouble d[101];\nint p[101];\nint color[101]; \nint n;\n\ndouble solve(){\n\tdouble  res = 0;\n\tfor(int i = 0;i < n;i++){\n\t\td[i] = INF;\n\t\tcolor[i] = WHITE;\n\t}\n\td[0] = 0;\n\tp[0] = -1;\n\tint u;\n\twhile(1){\n\t\tdouble mincost = INF;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(mincost > d[i] && color[i] != BLACK){\n\t\t\t\tmincost = d[i];\n\t\t\t\tu = i;\n\t\t\t}\n\t\t}\n\t\tif(mincost == INF)break;\n\t\tcolor[u] = BLACK;\n\n\t\tfor(int v = 0;v < n;v++){\n\t\t\tif(color[v] != BLACK){\n\t\t\t\tif(a[u][v] < d[v]){\n\t\t\t\t\td[v] = a[u][v];\n\t\t\t\t\tp[v] = u;\n\t\t\t\t\tcolor[v] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++)res += d[i];\n\treturn res;\n}\nint main(){\n\tstation sta[101];\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> sta[i].x >> sta[i].y >> sta[i].z >> sta[i].r;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i == j)a[i][j] = 0;\n\t\t\t\ta[i][j] = pow((sta[i].x - sta[j].x)*(sta[i].x - sta[j].x) + (sta[i].y - sta[j].y)*(sta[i].y - sta[j].y) + (sta[i].z - sta[j].z)*(sta[i].z - sta[j].z),0.5) - sta[i].r - sta[j].r;\n\t\t\t\tif(a[i][j] < 0)a[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",solve());\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v(n);\n\t\tfor(q=m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r);\n\t\t\tv[i].push_back(x),v[i].push_back(y),v[i].push_back(z),v[i].push_back(r),parent[i]=i;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t\t}\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n// >>> union find\nstruct UnionFind {\n    int n, sz; // id : 0...n-1\n    vector<int> par;\n\n    UnionFind(int n = 0) : n(n), sz(n), par(n,-1) { }\n    int root(int x) {\n        assert(0 <= x); assert(x < n);\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return false;\n        sz--;\n        if (par[x] < par[y]) swap(x,y);\n        par[y] += par[x];\n        par[x] = y;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -par[root(x)]; }\n    int size() const { return sz; }\n    struct groups_t {\n        vector<vector<int> > grp;\n        vector<pair<int,int> > id;\n    };\n    groups_t groups() {\n        vector<vector<int> > g(n);\n        rep (i,n) if (par[i] < 0) g[i].reserve(-par[i]);\n        rep (i,n) g[root(i)].push_back(i);\n        vector<vector<int> > grp; grp.reserve(size());\n        rep (i,n) if (g[i].size()) grp.emplace_back(move(g[i]));\n        vector<pair<int,int> > id(n);\n        rep (i,grp.size()) rep (j,grp[i].size()) {\n            id[grp[i][j]] = make_pair(i,j);\n        }\n        return { grp, id };\n    }\n};\n// <<<\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<double> x(n), y(n), z(n), r(n);\n        rep (i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        vector<tuple<double,int,int>> es;\n        rep (i,n) rep (j,n) if (i < j) {\n            double dx = x[i]-x[j];\n            double dy = y[i]-y[j];\n            double dz = z[i]-z[j];\n            double dist = sqrt(dx*dx + dy*dy + dz*dz);\n            double cost = max(dist-(r[i]+r[j]),{});\n            es.eb(cost,i,j);\n        }\n        sort(all(es));\n\n        UnionFind uf(n);\n        double ans = 0;\n        for (auto &t : es) {\n            double cost = get<0>(t);\n            int i = get<1>(t);\n            int j = get<2>(t);\n            if (uf.unite(i,j)) ans += cost, dump(cost);\n        }\n        cout << fixed << setprecision(3) << ans << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n// type {{{\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvll = vector<vector<ll>>;\n// }}}\n\n\n// macro {{{\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define RREP(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i,a,n) for (int i=(a); i<(n); ++i)\n#define RFOR(i,a,n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n// }}}\n\n\n// debug {{{\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    REP (i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n// }}}\n\n\n// chmax, chmin {{{\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// }}}\n\n\n// constants {{{\n#define inf(T) (numeric_limits<T>::max() / 2)\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n// }}}\n\n\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    const int n;\n    UnionFind(int n) : n(n), par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    friend ostream& operator<<(ostream& os, UnionFind& uf) {\n        os << \"[\";\n        for (int i = 0; i < uf.n; ++i) {\n            if (i > 0) os << \" \";\n            os << uf.root(i);\n        }\n        return os << \"]\" << endl;\n    }\n};\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\ntemplate<typename T>\nT kruskal(const vector<edge<T>> &es, int V) {\n\n    UnionFind uf(V);\n    T ret = 0;\n\n    vector<int> ord(es.size());\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int i,int j){\n            return es[i].cost < es[j].cost;\n            });\n\n    for (auto i : ord) {\n        auto &e = es[i];\n        if (!uf.issame(e.src, e.to)) {\n            ret += e.cost;\n            uf.merge(e.src, e.to);\n        }\n    }\n\n    return ret;\n}\n\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nstruct Point3D {\n    double x, y, z;\n    Point3D() {}\n    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}\n    Point3D operator+(const Point3D& b) const {\n        return Point3D(x + b.x, y + b.y, z + b.z);\n    }\n    Point3D operator-(const Point3D& b) const {\n        return Point3D(x - b.x, y - b.y, z - b.z);\n    }\n    friend double norm(const Point3D& p) {\n        return p.x * p.x + p.y * p.y + p.z * p.z;\n    };\n    friend double abs(const Point3D& p) { return sqrt(norm(p)); }\n\n    friend ostream &operator<<(ostream &os, Point3D &p) {\n        return os << \"(\" << p.x << \",\" << p.y << \",\" << p.z << \")\";\n    }\n    friend istream &operator>>(istream &is, Point3D &p) {\n        return is >> p.x >> p.y >> p.z;\n    }\n};\nstruct Segment3D {\n    Point3D a, b;\n    Segment3D() {}\n    Segment3D(const Point3D& a, const Point3D& b) : a(a), b(b) {}\n    friend ostream &operator<<(ostream &os, Segment3D &l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n    friend istream &operator>>(istream &is, Segment3D &l) {\n        return is >> l.a >> l.b;\n    }\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\ndouble dot(const Point3D &a, const Point3D &b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nPoint3D cross(const Point3D &a, const Point3D &b) {\n    double x = a.y * b.z - a.z * b.y,\n           y = a.z * b.x - a.x * b.z,\n           z = a.x * b.y - a.y * b.x;\n    return Point3D(x, y, z);\n}\n\nbool parallel(\n        const Point3D &a1, const Point3D &a2,\n        const Point3D &b1, const Point3D &b2) {\n    return eq(abs(cross(a1-b1, a2-b2)), 0.0);\n}\n\nbool parallel(const Segment3D& l1, const Segment3D& l2) {\n    return parallel(l1.a, l1.b, l2.a, l2.b);\n}\n\ndouble distance(const Segment3D &l, const Point3D &p) {\n    if (dot(l.b - l.a, p - l.a) < EPS) return abs(p - l.a);\n    if (dot(l.a - l.b, p - l.b) < EPS) return abs(p - l.b);\n    return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(3);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vector<edge<double>> edges;\n        vector<Point3D> points(n);\n        vector<double> rs(n);\n        REP(i, n) {\n            cin >> points[i] >> rs[i];\n        }\n        REP(i, n) {\n            FOR(j, i+1, n) {\n                Point3D diff = points[i] - points[j];\n                double dist = sqrt(dot(diff, diff));\n                edges.push_back((edge<double>){ i, j, max(dist - rs[i] - rs[j], 0.0) });\n            }\n        }\n\n        double ans = kruskal(edges, n);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nclass UnionFind {\n  vector<int> a;\npublic:\n  UnionFind(int n) { REP(i, 0, n) a.push_back(i); }\n  int find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\n  bool unite(int i, int j) {\n    if(find(i) == find(j)) return false;\n    a[find(i)] = find(j);\n    return true;\n  }\n};\n\nstruct edge {\n  int a, b;\n  double d;\n  bool operator<(const edge e) const {\n    return d > e.d;\n  }\n};\n\nint N;\ndouble X[100], Y[100], Z[100], R[100];\n\ndouble dist(int i, int j) {\n  double dx = X[i] - X[j];\n  double dy = Y[i] - Y[j];\n  double dz = Z[i] - Z[j];\n  double d = sqrt(dx * dx + dy * dy + dz * dz);\n  if(d < R[i] + R[j]) return 0;\n  return d - R[i] - R[j];\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\n    priority_queue<edge> q;\n    REP(i, 0, N) REP(j, i + 1, N) q.push((edge) { i, j, dist(i, j) });\n\n    UnionFind uf(N);\n    double ans = 0;\n    while(q.size()) {\n      int a = q.top().a, b = q.top().b;\n      double d = q.top().d;\n      q.pop();\n      if(uf.unite(a, b)) ans += d;\n    }\n    printf(\"%.3lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct unionfind{\n  vector<int> p;\n  unionfind(int n){\n    p = vector<int>(n, -1);\n  }\n  int root(int x){\n    if (p[x] == -1){\n      return x;\n    } else {\n      p[x] = root(p[x]);\n      return p[x];\n    }\n  }\n  bool same(int x, int y){\n    return root(x) == root(y);\n  }\n  void unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    p[x] = y;\n  }\n};\nint main(){\n  cout << fixed << setprecision(3);\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<double> x(n), y(n), z(n), r(n);\n    for (int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    vector<tuple<double, int, int>> E;\n    for (int i = 0; i < n; i++){\n      for (int j = i + 1; j < n; j++){\n        double d = sqrt(pow(x[j] - x[i], 2) + pow(y[j] - y[i], 2) + pow(z[j] - z[i], 2));\n        if (d <= r[i] + r[j]){\n          E.push_back(make_tuple(0, i, j));\n        } else {\n          E.push_back(make_tuple(d - r[i] - r[j], i, j));\n        }\n      }\n    }\n    sort(E.begin(), E.end());\n    int m = E.size();\n    double ans = 0;\n    unionfind UF(n);\n    int cnt = 0;\n    for (int i = 0; i < m; i++){\n      double d = get<0>(E[i]);\n      int v = get<1>(E[i]);\n      int w = get<2>(E[i]);\n      if (!UF.same(v, w)){\n        UF.unite(v, w);\n        ans += d;\n        cnt++;\n        if (cnt == n - 1){\n          break; \n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\n\nvector<pair<int,double> > E[100];\nint n;\n\ndouble prim(){\n  bool used[n];\n  memset(used,0,sizeof(used));\n  priority_queue<pair<double,int> > Q;\n  Q.push(mp(0,0));\n  double ret=0;\n  while(!Q.empty()){\n    double cc=-Q.top().F;\n    int from=Q.top().S;\n    Q.pop();\n    if(used[from])continue;\n    used[from]=true;\n    ret+=cc;\n    \n    rep(i,E[from].size()){\n      int to=E[from][i].F;\n      double co=E[from][i].S;\n      if(used[to])continue;\n      Q.push(mp(-co,to));\n    }\n  }\n  return ret;\n}\n\nmain(){\n\n  while(cin>>n,n){\n    double x[n],y[n],z[n],r[n];\n    rep(i,n)E[i].clear();\n\n    rep(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\n    rep(i,n){\n      rep(j,i){\n\tdouble tx=x[j]-x[i],ty=y[j]-y[i],tz=z[j]-z[i];\n\tdouble len=sqrt(tx*tx+ty*ty+tz*tz);\n\tdouble cost=len-r[i]-r[j];\n\tif(cost<0)cost=0;\n\tE[i].pb(mp(j,cost));\n\tE[j].pb(mp(i,cost));\n      }\n    }\n\n    printf(\"%.3f\\n\",prim());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nint n;\nbool used[110];\ndouble x[110], y[110], z[110], r[110];\nconst double inf = 999999999.9;\nvector<pair<int, double> > dist[110];\n\n\ndouble sqr(double x){ return x*x; }\n\nbool isoverlap(int i, int j){\n    return (sqr(x[i]-x[j]) + sqr(y[i]-y[j]) + sqr(z[i]-z[j]) <= sqr(r[i]) + 2.0*r[i]*r[j] + sqr(r[j]));\n}\n\nint main(){\n    int i,j,k;\n\n    while( cin >> n, n){\n        rep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        // init\n        rep(i,n) dist[i].clear();\n        memset(used, false, sizeof(used));\n\n        rep(i,n){\n            REP(j,i+1,n){\n                if( isoverlap(i,j) ){\n                    dist[i].push_back(make_pair(j,0.0));\n                    dist[j].push_back(make_pair(i,0.0));\n                }\n                else{\n                    double cost = sqrt(sqr(x[i]-x[j]) + sqr(y[i]-y[j]) + sqr(z[i]-z[j])) - (r[i] + r[j]);\n                    dist[i].push_back(make_pair(j,cost));\n                    dist[j].push_back(make_pair(i,cost));\n                }\n            }\n        }\n\n        // debug\n        /*\n        rep(i,n){\n            rep(j,dist[i].size()){\n                printf(\"%d -> %d , cost = %lf\\n\",i,dist[i][j].first, dist[i][j].second);\n            }\n        }\n        puts(\"\");\n        */\n\n        double res = 0.0;\n\n        used[0] = true;\n        rep(k,n-1){\n            int id = -1;\n            double cost = inf;\n\n            rep(i,n) if( used[i] ) {\n                rep(j,dist[i].size()){\n                    //printf(\"i:%d --> u:%d\\n\",i,dist[i][j].first);\n                    int u = dist[i][j].first;\n                    double tmp = dist[i][j].second;\n                    if( used[u] ) continue;\n                    if( tmp < cost ){\n                        cost = tmp;\n                        id = u;\n                    } \n                }\n            }\n\n            //printf(\"k = %d, id = %d\\n\",k,id);\n\n            if( id == -1 ){\n                exit(1);\n            }\n            used[id] = true;\n            res += cost;\n        }\n\n        printf(\"%.3lf\\n\", (k == n-1 ? res : 0.0) ); \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double INF = 1000000000;\n\nstruct UnionFind {  // The range of node number is u 0 v n-1\n\tvector<int> rank, parents;\n\tUnionFind() {}\n\tUnionFind(int n) {  // make n trees.\n\t\trank.resize(n, 0);\n\t\tparents.resize(n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmakeTree(i);\n\t\t}\n\t}\n\tvoid makeTree(int x) {\n\t\tparents[x] = x;  // the parent of x is x\n\t\trank[x] = 0;\n\t}\n\tbool isSame(int x, int y) { return findRoot(x) == findRoot(y); }\n\tvoid unite(int x, int y) {\n\t\tx = findRoot(x);\n\t\ty = findRoot(y);\n\t\tif (rank[x] > rank[y]) {\n\t\t\tparents[y] = x;\n\t\t}\n\t\telse {\n\t\t\tparents[x] = y;\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\tint findRoot(int x) {\n\t\tif (x != parents[x]) parents[x] = findRoot(parents[x]);\n\t\treturn parents[x];\n\t}\n};\n\n// 辺の定義\nstruct Edge {\n\tint u;\n\tint v;\n\tdouble cost;\n};\n\n//セル定義\nstruct cell {\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\n\nbool comp_e(const Edge &e1, const Edge &e2) { return e1.cost < e2.cost; } // 辺を直接比較するための関数\n\ndouble Kruskal(vector<Edge> &edges, int v) {\n\n\tdouble sum = 0;  // 最小全域木の重みの総和\n\n\tsort(edges.begin(), edges.end(), comp_e); // 辺の重みでソート\n\n\tUnionFind uft = UnionFind(v);\n\n\tfor (unsigned int i = 0; i < edges.size(); i++) {\n\t\tif (!uft.isSame(edges[i].u, edges[i].v)) { // 閉路にならなければ加える\n\t\t\tuft.unite(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].cost;\n\t\t}\n\t}\n\n\treturn sum;\n};\n\nint main() {\n\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\n\t\tvector<cell> cell(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cell[i].x >> cell[i].y >> cell[i].z >> cell[i].r;\n\t\t}\n\n\t\tvector<Edge> edges;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\n\t\t\t\tif (i == j) { continue; }\n\n\t\t\t\tdouble dist = pow(\n\t\t\t\t\t(cell[i].x - cell[j].x)*(cell[i].x - cell[j].x)\n\t\t\t\t\t+ (cell[i].y - cell[j].y)*(cell[i].y - cell[j].y)\n\t\t\t\t\t+ (cell[i].z - cell[j].z)*(cell[i].z - cell[j].z)\n\t\t\t\t\t, 0.5)\n\t\t\t\t\t- cell[i].r - cell[j].r;\n\t\t\t\tif (dist < 0) { dist = 0; }\n\n\t\t\t\tedges.push_back({ i,j,dist });\n\n\t\t\t}\n\t\t}\n\n\t\tdouble krs = Kruskal(edges, n);\n\n\t\tcout << fixed << setprecision(3) << krs << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ld cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\nld kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tld res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { ld x, y, z, r; };\nld dis(point a,point b) {\n\tld res;\n\tres = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n\tres -= (a.r + b.r);\n\tif (res < 0) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[101];\n\t\tld x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(5) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <typename T>\nstruct Kruskal {\n  struct UnionFind {\n    int n;\n    vector<int> rank, par;\n    UnionFind() {}\n    UnionFind(int n) : n(n), rank(n, 1), par(n) {\n      iota(par.begin(), par.end(), 0);\n    }\n    int root(int x) {\n      return par[x] == x ? x : par[x] = root(par[x]);\n    }\n    bool merge(int x, int y) {\n      if ((x = root(x)) == (y = root(y))) return false;\n      if (rank[x] < rank[y]) swap(x, y);\n      rank[x] += rank[y];\n      par[y] = x;\n      return true;\n    }\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n    int size(int x) {\n      return rank[root(x)];\n    }\n  };\n  struct edge {\n    int from, to; T cost;\n    edge() {}\n    edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend ostream& operator<<(ostream& os, edge &e) {\n      return os << e.from << \" \" << e.to << \" \" << e.cost;\n    }\n  };\n\n  int n;\n  vector<edge> es;\n  Kruskal() {}\n  Kruskal(int n) : n(n) {}\n\n  void add_edge(int from, int to, T cost) {\n    es.emplace_back(from, to, cost);\n  }\n  T mst() {\n    T res = 0;\n    UnionFind uf(n);\n    sort(es.begin(), es.end(), [&](edge a, edge b) {\n      return a.cost < b.cost;\n    });\n    for (auto &e : es) if (uf.merge(e.from, e.to)) {\n      res += e.cost;\n    }\n    return res;\n  }\n};\n\ndouble len(double x, double y, double z) {\n  return sqrt(x * x + y * y + z * z);\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(3);\n  \n  int n;\n  while (cin >> n, n) {\n    vector<double> x(n), y(n), z(n), r(n);\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n\n    Kruskal<double> K(n);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (j != i) {\n        K.add_edge(i, j, max(0., len(x[i] - x[j], y[i] - y[j], z[i] - z[j]) - r[i] - r[j]));\n    }\n    cout << K.mst() << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    \n    printf(\"%0.3lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nclass UnionFindTree{\nprivate:\n\tvll par, rank, size;\npublic:\n\tUnionFindTree(ll num): par(num), rank(num), size(num, 1){\n\t\tREP(i, num) par[i] = i;\n\t}\n\tbool Same(ll x, ll y) { return Root(x) == Root(y); }\n\tll Root(ll x) { return (par[x] == x) ? x : par[x]=Root(par[x]); }\n\tll Size(ll x){ return size[Root(x)]; }\n\tvoid Unite(ll x, ll y){\n\t\tx = Root(x);\n\t\ty = Root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse                   par[y] = x;\n\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\tsize[x] = size[y] = size[x] + size[y];\n\t}\n};\n\nvoid solve()\n{\n\twhile (true){\n\t\tll n;  cin >> n;\n\t\tif (n==0) break;\n\n\t\tvector<tuple<dd, dd, dd, dd>> xyzr = cinv4<dd, dd, dd, dd>(n);\n\t\t\n\t\tvector<tuple<dd,ll,ll>> E;//距離,v,u\n\t\trep(v, 0,n-1)rep(u, v+1, n-1){\n\t\t\tif (v==u) continue;\n\t\t\tdd x;  dd y;  dd z;  dd r;  tie(x, y, z, r) = xyzr[v];\n\t\t\tdd xx; dd yy; dd zz; dd rr;  tie(xx, yy, zz, rr) = xyzr[u];\n\t\t\t\n\t\t\tdd D = sqrt(POW(x-xx, 2)+POW(y-yy, 2)+POW(z-zz, 2));\n\t\t\tdd d = 0.;\n\t\t\tif (r+rr<D) d = D-r-rr;\n\t\t\t//if (D<abs(rr-r)) d = abs(rr-r)-D;\n\t\t\tE.emplace_back(d, v, u);\n\t\t}\n\t\tsort(E.begin(), E.end());\n\n\t\tUnionFindTree uft(n);\n\t\tdd sum=0.;\n\t\tll count = 0;\n\t\tEACH(e, E){\n\t\t\tdd d; ll v; ll u;  tie(d, v, u) = e;\n\t\t\tif (uft.Same(v, u)) continue;\n\t\t\tuft.Unite(v, u);\n\t\t\tsum+=d;\n\t\t\tcount++;\n\t\t\tif (count == n-1) break;\n\t\t}\n\t\tcout << fixed << setprecision(3);\n\t\tcout << sum << '\\n';\n\t}\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\ntypedef double Weight;\nconst int INF = 1e9;\n\n//UnionFind\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x,int y) {\n    x = root(x);\n    y = root(y);\n    if(x != y) {\n      if(data[y] < data[x]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n      return x != y;\n  }\n  bool findSet(int x,int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct Edge {\n  int src,dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n//UnionFindðg¤\n//Å¬SæØ(Kruskal) verifyÏÝ\nWeight minimumSpannnigTree(Graph graph) {\n  int n = graph.size();\n  UnionFind uf(n);\n  Weight total = 0.0;\n  priority_queue<Edge> q;\n  for(Graph::iterator it = graph.begin(); it != graph.end(); ++it)\n    for(Edges::iterator j = (*it).begin(); j != (*it).end(); ++j)\n      q.push(*j);\n\n  while(!q.empty()) {\n    Edge e = q.top();\n    q.pop();\n    if(uf.unionSet(e.src, e.dst))\n      total += e.weight;\n  }\n  return total;\n}\n\nstruct Part{\n  double x,y,z,r;\n  Part(double x,double y,double z,double r) : x(x), y(y), z(z), r(r) { }\n};\n\ndouble dist(Part a,Part b) {\n  double d = sqrt((a.x-b.x)*(a.x-b.x)\n\t\t  + (a.y-b.y)*(a.y-b.y)\n\t\t  + (a.z-b.z)*(a.z-b.z));\n  return max(0.0, d-a.r-b.r);\n}\n\nint main() {\n  int n;\n  double x,y,z,r;\n  while(cin>>n, n) {\n    Graph g(n);\n    vector<Part> p;\n    for(int i=0; i<n; ++i) {\n      cin>>x>>y>>z>>r;\n      p.push_back( Part(x,y,z,r) );\n    }\n    for(int i=0; i<n; ++i) {\n      for(int j=0; j<n; ++j) {\n\tif(i == j) continue;\n\tg[i].push_back(Edge(i,j,dist(p[i],p[j])));\n      }\n    }\n    printf(\"%.3f\\n\", minimumSpannnigTree(g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define MAX_V 100\n#define MAX_E 10000\nint V,E,par[MAX_V],rnk[MAX_V];\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n \nEdge es[MAX_E];\n \nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n \nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n \n  if(x == y) return;\n \n  if(rnk[x] < rnk[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rnk[x] == rnk[y]){\n      rnk[x]++;\n    }\n  }\n}\n \nbool same(int x,int y){\n  return find(x) == find(y);\n}\n \ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n \ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n \nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[MAX_V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n     \n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.3f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<deque>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<limits>\n#include<functional>\n#include<unordered_set>\n#include<iomanip>\n#include<cassert>\n#include<regex>\n#include<bitset>\n#include<complex>\n#include<chrono>\n#include<random>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define rrep(i,a) for(int i=(int)a-1;i>=0;--i)\n#define REP(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RREP(i,a,b) for(int i=(int)a-1;i>=b;--i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\ntypedef std::vector<int> vi;\ntypedef std::vector<std::vector<int>> vvi;\ntypedef std::vector<long long> vl;\ntypedef std::vector<std::vector<long long>> vvl;\n#define out(x) cout<<x<<\"\\n\";\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\nll gcd(ll n, ll m) {\n    ll tmp;\n    while (m!=0) {\n        tmp = n % m;\n        n = m;\n        m = tmp;\n    }\n    return n;\n}\n\nll lcm(ll n, ll m) {\n    return abs(n) / gcd(n, m)*abs(m);//gl=xy\n}\n \ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \nusing namespace std;\n\n//グラフのテンプレート\ntemplate<typename T>\nstruct edge {\n\tint from, to;\n\tT cost;\n\n    edge(int to,T cost):from(0),to(to),cost(cost){}\n\tedge(int from, int to, T cost) :from(from), to(to), cost(cost) {}\n};\n\ntemplate<typename T>\nT prim(vector<vector<edge<T>>> &g){//プリム法(最小全域木)\n    using P=pair<T,int>;//firstがcost,secondが行き先\n\n    T sum=0;\n    vector<bool>used(g.size(),false);\n    priority_queue<P,vector<P>,greater<P>>pq;\n    pq.emplace(0,0);\n    while(!pq.empty()){\n        auto p=pq.top();\n        pq.pop();\n        if(used[p.second])continue;\n        used[p.second]=true;\n        sum+=p.first;\n        for(auto &x: g[p.second]){\n            pq.emplace(x.cost,x.to);\n        }\n    }\n    return sum;\n}\n  \nint n;\nstruct dim{\n    double x,y,z,r;\n    dim(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble func(dim &a,dim &b){\n    return max(sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2))-(a.r+b.r),0.0);\n}\n\nvoid solve(){\n    vector<dim>v;\n    double a,b,c,d;\n    rep(i,n){\n        cin>>a>>b>>c>>d;\n        v.eb(a,b,c,d);\n    }\n    vector<vector<edge<double>>>vv(n);\n    rep(i,n){\n        REP(j,i+1,n){\n            double s=func(v[i],v[j]);\n            vv[i].eb(j,s);\n            vv[j].eb(i,s);\n        }\n    }\n    double ans=prim(vv);\n    cout<<ans<<\"\\n\";\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(3);\n    while(1){\n        cin>>n;\n        if(n==0)return 0;\n        solve();\n    }\n    //solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\n#define fore(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);++i)\n#define rep(i,n) fore(i,0,(n)-1)\n#define rfore(i,a,b) for(ll i=(ll)(b);i>=(ll)(a);--i)\n#define rrep(i,n) rfore(i,0,(n)-1)\n#define all(x) (x).begin(),(x).end()\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\nll par[105];\nll find(ll x){\n    if(par[x]<0)return x;\n    return par[x]=find(par[x]);\n}\nvoid unite(ll x,ll y){\n    x=find(x),y=find(y);\n    if(x==y)return;\n    par[y]=x;\n}\n\nvoid solve(){\n    double eps=1e-8;\n    while(1){\n        ll n;cin>>n;\n        if(n==0)return;\n        memset(par,-1,sizeof(par));\n\n        vector<double> x(n),y(n),z(n),r(n);\n        rep(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n        vector<pair<double,ll> > a;\n        vl src,to;\n        ll idx=0;\n        rep(i,n)fore(j,i+1,n-1){\n            a.push_back(pair<double,ll>(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j],idx++));\n            src.push_back(i);\n            to.push_back(j);\n        }\n        sort(all(a));\n        double ans=0;\n        rep(i,a.size()){\n            if(find(src[a[i].second])!=find(to[a[i].second])){\n                ans+=max(0.0,a[i].first);\n                unite(src[a[i].second],to[a[i].second]);\n            }\n        }\n        printf(\"%.3f\\n\",ans);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\n\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\nstruct UnionFind{\n    vector<ll> par;\n\n    UnionFind(ll N) : par(N){\n        rep(i,N){\n            par[i]=i;\n        }\n    }\n\n    ll root(ll x){\n        if(par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(ll x, ll y){\n        ll rx = root(x);\n        ll ry = root(y);\n        if(rx==ry) return;\n        par[rx] = ry;\n    }\n\n    bool same(ll x, ll y){\n        ll rx = root(x);\n        ll ry = root(y);\n        return rx == ry;\n    }\n};\n\n\nint main() {\n    while(1){\n    ll N;\n    cin >> N;\n    if(N==0) break;\n    vector<tuple<ld,ll,ll>> S;\n    vector<ld>x(N);\n    vector<ld>y(N);\n    vector<ld>z(N);\n    vector<ld>r(N);\n\n\n    rep(i,N){\n        cin >>x[i]>>y[i]>>z[i]>>r[i];\n    }\n\n    rep(i,N){\n        rep3(j,i+1,N){\n            ld d = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j])) - r[i] - r[j];\n            //cout<<d<<endl;\n            if(d<0.0){\n                d=0.0;\n            }\n            S.pb(make_tuple(d,i,j));\n        }\n    }\n\n    sort(all(S));\n    UnionFind tree(N);\n\n    double ans = 0;\n    rep(i,S.size()){\n        ll x = get<1>(S[i]);\n        ll y = get<2>(S[i]);\n        if(!tree.same(x,y)){\n            tree.unite(x,y);\n            ans += get<0>(S[i]);\n\n        }\n        \n    }\n\n\n\n\n\n    cout << std::fixed << std::setprecision(3) << ans << endl;\n    }\n    \n    return 0;\n    \n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point\n{\n        double x, y, z;\n        Point () {}\n        Point (double x, double y, double z) : x(x), y(y), z(z) {}\n        \n        double dist(Point &d)\n        {\n                double vx = x - d.x;\n                double vy = y - d.y;\n                double vz = z - d.z;\n\n                return ( sqrt(vx * vx + vy * vy + vz * vz) );\n        } \n};\n\nstruct Sphere\n{\n        Point center;\n        double r;\n\n        Sphere () {}\n        Sphere (Point center, double r) : center(center), r(r) {}\n\n        double dist(Sphere &d)\n        {\n                if ( isCollied(d) ) return ( 0.0 );\n                return ( center.dist(d.center) - r - d.r );\n        }\n\n        bool isCollied(Sphere &d)\n        {\n                return ( center.dist(d.center) < r + d.r );\n        }\n};\n\nstruct Edge\n{\n        int a, b;\n        double cost;\n\n        Edge () {}\n        Edge (int a, int b, double cost) : a(a), b(b), cost(cost) {}\n\n        bool operator < (const Edge &d) const\n        {\n                return ( cost < d.cost );\n        }\n};\n\nstruct Unionfind\n{\n        vector < int > par;\n\n        Unionfind(int n)\n        {\n                par = vector < int >(n);\n                for ( int i = 0; i < n; i++ ) {\n                        par[i] = i;\n                }\n        }\n\n        void unite(int x, int y)\n        {\n                x = root(x), y = root(y);\n                if ( x == y ) return;\n                par[x] = y;\n        }\n\n        bool same(int x, int y)\n        {\n                return ( root(x) == root(y) );\n        }\n\n        int root(int n)\n        {\n                return par[n] = (par[n] == n ? n : root(par[n]));\n        }\n};\n\nint main()\n{\n        int n;\n        Sphere data[105];\n\n        while ( cin >> n, n ) {\n                vector < Edge > edges;\n                for ( int i = 0; i < n; i++ ) {\n                        double x, y, z, r;\n                        cin >> x >> y >> z >> r;\n                        data[i] = Sphere(Point(x, y, z), r);\n                }\n\n                for ( int i = 0; i < n; i++ ) {\n                        for ( int j = i + 1; j < n; j++ ) {\n                                edges.emplace_back(i, j, data[i].dist(data[j]));\n                        }\n                }\n                \n                sort(begin(edges), end(edges));\n\n                Unionfind tree(n);\n                \n                double cost = 0.0;\n                for ( auto &x : edges ) {\n                        if ( !tree.same(x.a, x.b) ) {\n                                tree.unite(x.a, x.b);\n                                cost += x.cost;\n                        }\n                }\n\n                printf(\"%.3f\\n\", cost);\n        }\n                \n        return ( 0 );\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P2;\ntypedef pair<double,P2> PP;\nstruct P {double x,y,z,r;};\ndouble D3(P a,P b) {\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint p[10001],r[10001];\nvoid init() {rep(i,10001) p[i]=i,r[i]=0;}\nint find(int x) {return (p[x]==x)?x:(p[x]=find(p[x]));}\nvoid unite(int x,int y) {\n  x=find(x),y=find(y);\n  if(x==y) return;\n  if(r[x]<r[y]) p[x]=y;\n  else {p[y]=x;if(r[x]==r[y]) r[x]++;}\n}\nbool same(int x, int y) {return find(x)==find(y);}\n\nvoid Main() {\n  int n;\n  while(R n && n) {\n    init();\n    P a[n];\n    rep(i,n) {\n      double x,y,z,r;\n      cin >> x >> y >> z >> r;\n      a[i]=(P){x,y,z,r};\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    rep(i,n) {\n      REP(j,i+1,n) que.push(PP(max(0.0,D3(a[i],a[j])-a[i].r-a[j].r),P2(i,j)));\n    }\n    double ans=0;\n    while(!que.empty()) {\n      PP q=que.top();que.pop();\n      int i=q.S.F,j=q.S.S;\n      if(same(i,j)) continue;\n      unite(i,j);\n      ans+=q.F;\n    }\n    printf(\"%.3f\\n\",ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <typename T>\nclass Edge\n{\npublic:\n\n\tLL from,to;\n\tT cost;\n\t\n\tEdge(LL _from,LL _to,T _cost){\n\t\tfrom=_from;\n\t\tto=_to;\n\t\tcost=_cost;\n\t}\n\t\n\tbool operator<(const Edge& e) const {\n\t\treturn cost<e.cost;\n\t}\n};\n\ntemplate <typename T>\nclass UF{\npublic:\n\tvector<T> par,rank;\n\n\tUF(T n){\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor(T i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tT find(T x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(T x, T y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(T x, T y){\n\n\t\treturn find(x)==find(y);\n\t}\n};\n\ntemplate <typename T>\nclass Graph\n{\npublic:\n\tlong long n;\n\tvector<Edge<T> > ve;\n\tGraph(vector<Edge<T> > _ve,LL _n){\n\t\tve=_ve;\n\t\tn=_n;\n\n\t}\n\t\n\tvector<Edge<T> > kruskal(){\n\t\t\n\t\tvector<Edge<T> > res;\n\t\tsort(ve.begin(),ve.end());\n\t\t\n\t\tUF<LL> uf(n);\n\t\t\n\t\tfor(LL i=0;i<ve.size();i++){\n\t\t\tEdge<T> e=ve[i];\n\t\t\tif(!uf.same(e.from,e.to)){\n\t\t\t\tres.push_back(e);\n\t\t\t\tcout<<e.from<<\" \"<<e.to<<endl;\n\t\t\t\tuf.unite(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\t\n\t\tvector<Edge<double> > ve;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble d=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\t\tve.push_back(Edge<double>(i,j,max(0.0,sqrt(d)-r[i]-r[j])));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ve.size()<<endl;\n\t\t\n\t\tGraph<double> G(ve,n);\n\n\t\tvector<Edge<double> > MST=G.kruskal();\n\t\t\n\t\tdouble res=0;\n\t\tfor(int i=0;i<MST.size();i++) res+=MST[i].cost;\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n\n#define int long long\n#define dotimes(i, n) for (int i : range(n))\n\nusing namespace std;\n\nclass range {\n  class iterator {\n    int i, s;\n  public:\n    iterator(int i, int s): i(i), s(s) {}\n    int& operator*() {\n      return i;\n    }\n    void operator++() {\n      i += s;\n    }\n    bool operator!=(iterator const& that) {\n      return i < that.i;\n    }\n  };\n  iterator b, e;\npublic:\n  range(int e): b({0, 1}), e({e, 1}) {}\n  range(int b, int e): b({b, 1}), e({e, 1}) {}\n  range(int b, int e, int s): b({b, s}), e({e, s}) {}\n  iterator begin() {\n    return b;\n  }\n  iterator end() {\n    return e;\n  }\n};\n\nint rint() {\n  int n;\n  scanf(\"%lld\", &n);\n  return n;\n}\n\nvoid wint(int n) {\n  printf(\"%lld\\n\", n);\n}\n\ntemplate<typename T>\ninline int size(T container) {\n  return static_cast<int>(container.size());\n}\n\ntemplate<typename T>\ninline bool maxs(T& a, T const& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\ninline bool mins(T& a, T const& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\ninline T sq(T const &x) {\n  return x * x;\n}\n\nstruct union_find {\n  vector<int> p;\n  union_find(int n): p(n) {\n    dotimes(x, n)\n      p[x] = x;\n  }\n  int find(int x) {\n    while (x != p[x]) {\n      int y = p[x];\n      p[x] = p[y];\n      x = y;\n    }\n    return x;\n  }\n  bool eqv(int x, int y) {\n    int a = find(x), b = find(y);\n    return a == b;\n  }\n  bool unite(int x, int y) {\n    int a = find(x), b = find(y);\n    if (a == b)\n      return false;\n    if (!(a < b))\n      swap(a, b);\n    p[b] = a;\n    return true;\n  }\n};\n\nsigned main() {\n  for (;;) {\n    const int n = rint();\n    if (!n)\n      break;\n    struct {\n      double x, y, z, r;\n    } cells[n];\n    dotimes(i, n)\n      scanf(\"%lf%lf%lf%lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n    union_find uf(n);\n    double dists[n][n];\n    dotimes(j, n) dotimes(i, j) {\n      dists[j][i] = sqrt(sq(cells[i].x - cells[j].x) + sq(cells[i].y - cells[j].y) + sq(cells[i].z - cells[j].z));\n      if (dists[j][i] <= cells[i].r + cells[j].r)\n        uf.unite(i, j);\n    }\n    pair<int, int> p[n];\n    dotimes(i, n) {\n      p[i].first = i;\n      p[i].second = uf.find(i);\n    }\n    sort(p, p + n, [](auto const &a, auto const &b) { return a.second < b.second; });\n    int x = p[0].second;\n    int c = 0;\n    p[0].second = 0;\n    dotimes(i, n-1) {\n      int y = p[i+1].second;\n      if (x != y) {\n        c++;\n        x = y;\n      }\n      p[i+1].second = c;\n    }\n    sort(p, p + n);\n    c++;\n    double ds[c][c];\n    dotimes(j, c) dotimes(i, j) ds[j][i] = 200;\n    dotimes(j, n) dotimes(i, j) if (p[i].second != p[j].second) {\n      int a = p[i].second, b = p[j].second;\n      if (a > b)\n        swap(a, b);\n      mins(ds[b][a], dists[j][i] - (cells[i].r + cells[j].r));\n    }\n    vector<tuple<double, int, int>> edges;\n    edges.reserve(n * (n - 1) / 2);\n    dotimes(j, c) dotimes(i, j) edges.emplace_back(ds[j][i], i, j);\n    sort(edges.begin(), edges.end());\n    int k = c;\n    double r = 0;\n    union_find uf2(c);\n    for (auto &&e : edges) {\n      if (k == 1)\n        break;\n      if (uf2.unite(get<1>(e), get<2>(e))) {\n        r += get<0>(e);\n        k--;\n      }\n    }\n    printf(\"%.3lf\\n\", r);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;scanf(\"%lf\",&a);return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    printf(\"%.10lf\\n\",prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Union Find用\nclass DisjointSet {\nprivate:\n  vector<int> p;\n  \npublic:\n  DisjointSet(int size) : p(size, -1) {}\n\n  bool unite_set(int x, int y) {\n    x = root(x);\n    y = root(y);\n    \n    if (x != y) {\n      if (x > y) { swap(x, y); }\n      p[x] += p[y];\n      p[y] = x;\n    }   \n\n    return x != y;\n  }\n\nprivate:\n  int root(int x) {\n    return p[x] < 0 ? x : p[x] = root(p[x]);\n  }\n};\n\n// 通路\nstruct corridor {\n  int a, b;     // 繋がっているcell\n  double len;   // 通路の長さ\n  corridor(int a, int b, double len) : a(a), b(b), len(len) {}\n\n  // ソート用\n  bool operator <(const corridor& rhs) const {\n    if (len != rhs.len) { return len < rhs.len; }\n    if (a != rhs.a) { return a < rhs.a; }\n    return b < rhs.b;\n  }\n};\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n  return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2));\n}\n\nint main(int argc, char const* argv[]) {\n  int n;\n  while (cin >> n && n) {\n    double x[100], y[100], z[100], r[100];\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n\n    // 全ての通路を長さでソートする\n    vector<corridor> cor;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        cor.push_back(corridor(i, j, max(0.0, dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j])));\n      }\n    }\n    sort(cor.begin(), cor.end());\n\n    DisjointSet ds(n);\n    double ans = 0;   // 通路の長さの総和\n    int count = 0;    // 選んだ通路の数\n\n    for (vector<corridor>::iterator itr = cor.begin(); count < n - 1; itr++) {\n      // aとbが別々の集合に属しているならばその通路を採用する\n      if (ds.unite_set(itr->a, itr->b)) {\n        ans += itr->len;\n        count++;\n      }\n    }\n\n    printf(\"%.3f\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <limits>\nusing namespace std;\n#define repeat(i,n) for (int i = 0; i < n; ++i)\n\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\n\nclass union_find {\n    vector<int> tree;\npublic:\n    union_find() {}\n    union_find(int n) : tree(n, -1) {}\n    bool is_root(int a) { return tree[a] < 0; }\n    int find_root(int a) { return is_root(a) ? a : (tree[a] = find_root(tree[a])); }\n    int tree_size(int a) { return - tree[find_root(a)]; }\n    void union_tree(int a, int b) {\n        a = find_root(a); b = find_root(b);\n        if (a != b) {\n            if (not (tree_size(a) < tree_size(b))) swap(a,b);\n            tree[b] += tree[a];\n            tree[a] = b;\n        }\n    }\n    bool is_connected(int a, int b) { return find_root(a) == find_root(b); }\n    friend ostream & operator<<(ostream & output, const union_find & uf) { repeat (i, uf.tree.size()-1) output << uf.tree[i] << ' '; return output << uf.tree[uf.tree.size()-1]; }\n};\n\nstruct pos3 { double x, y, z; };\npos3 operator+(const pos3 & p, const pos3 & q) { return (pos3){p.x + q.x, p.y + q.y, p.z + q.z}; }\npos3 operator-(const pos3 & p) { return (pos3){-p.x, -p.y, -p.z}; }\npos3 operator-(const pos3 & p, const pos3 & q) { return p + (- q); }\nistream & operator>>(istream & input, pos3 & p) { return input >> p.x >> p.y >> p.z; }\ndouble sq(double a) { return a * a; }\ndouble length_squared(const pos3 & p) { return sq(p.x) + sq(p.y) + sq(p.z); }\ndouble length(const pos3 & p) { return sqrt(length_squared(p)); }\n\nstruct circle { pos3 p; double r; };\n\n#define MAX_N 100\n#define MIN_X 0.0\n#define MAX_X 100.0\nint N;\nunion_find tree;\ncircle C[MAX_N];\n\nint main() {\n    while (true) {\n        cin >> N; if (not N) break;\n        tree = union_find(N);\n        repeat (i,N) {\n            cin >> C[i].p >> C[i].r;\n            repeat (j,i) if (length_squared(C[j].p - C[i].p) < sq(C[i].r + C[j].r)) {\n                tree.union_tree(i,j);\n            }\n        }\n        double sum = 0.0;\n        repeat (i,N) if (tree.is_root(i)) {\n            double inf = numeric_limits<double>::infinity();\n            int ix = -1;\n            repeat (j,N) if (tree.is_connected(i,j)) {\n                repeat (k,N) if (not tree.is_connected(i,k)) {\n                    double dist = length(C[j].p - C[k].p) - (C[j].r + C[k].r);\n                    if (dist < inf) {\n                        inf = dist; ix = k;\n                    }\n                }\n            }\n            if (ix == -1) break;\n            tree.union_tree(i, ix);\n            sum += inf;\n        }\n#ifdef DEBUG\n        int cnt = 0;\n        repeat (i,N) if (tree.is_root(i)) ++ cnt;\n        assert(cnt == 1);\n#endif\n        cout << setprecision(3) << fixed << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#define REP(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,a) REP(i,0,a)\nusing namespace std;\n\nconst int INF = 1 << 28;\nint n;\ndouble xyzr[101][4], cost[101][101];\n\ndouble calc(int i,int j) {\n    double d = 0.0;\n    rep(k,3) d += (xyzr[i][k]-xyzr[j][k])*(xyzr[i][k]-xyzr[j][k]);\n    d = sqrt(d);\n    return max(0.0, d-xyzr[i][3]-xyzr[j][3]);\n}\n\nint main(void){\n    while (cin >> n, n) {\n        rep(i,n) rep(j,4) cin >> xyzr[i][j];\n        \n        rep(i,n) REP(j,i+1,n) cost[i][j] = cost[j][i] = calc(i,j);\n        double mincost[n];\n        bool used[n];\n        rep(i,n) {\n            mincost[i] = INF;\n            used[i] = false;\n        }\n        mincost[0] = 0.0;\n        double ans = 0.0;\n        \n        while (1) {\n            int v = -1;\n            rep(u,n) {\n                if (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n            }\n            if (v == -1) break;\n            used[v] = true;\n            ans += mincost[v];\n            rep(u,n) mincost[u] = min(mincost[u], cost[u][v]);\n        }\n        printf(\"%.3f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\t\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\t\n\tinline bool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn false;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\n\t\treturn true;\n\t}\n};\n\nstruct edge {\n\tint u, v;\n\tdouble cost;\n\tedge(int u, int v, double c):u(u), v(v), cost(c){}\n\n\tbool operator< (const edge& o) const {\n\t\treturn cost < o.cost;\n\t}\n};\n\nint n;\nvector<edge> es;\n\ndouble kruskal() {\n\tsort(es.begin(), es.end());\n\tunion_find uf(n);\n\n\tdouble res = 0;\n\tfor(int i = 0; i < es.size(); ++i)\n\t\tif(uf.unite(es[i].u, es[i].v))\n\t\t\tres += es[i].cost;\n\n\treturn res;\n}\n\ninline double dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n\tconst double dx = x1 - x2, dy = y1 - y2, dz = z1 - z2;\n\treturn sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &z[i], &r[i]);\n\n\t\tes.clear();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst double cost = max(0.0, dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j]);\n\t\t\t\tes.push_back(edge(i, j, cost));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", kruskal());\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n\n\n#define x first.first\n#define y first.second\n#define z second.first\n#define r second.second\n\n#define dis first\n#define a second.first\n#define b second.second\n\nvector<int> par, siz;\n\nvoid init(int X){\n  par.resize(X);\n  siz.resize(X);\n  \n  for(int i = 0; i < X; i++){\n    par[i] = i;\n    siz[i] = 1;\n  }\n}\n\nint find(int X){\n  return X==par[X]?X:X = find(par[X]);\n}\n\nvoid unite(int X, int Y){\n  X = find(X);\n  Y = find(Y);\n\n  if(X == Y) return ;\n\n  if(siz[X] > siz[Y]){\n    par[Y] = X;\n    siz[X] += siz[Y];\n  } else {\n    par[X] = Y;\n    siz[Y] += siz[X];\n  }\n}\n\nbool same(int X, int Y){\n  return find(X) == find(Y);\n}\n\nlong double dist(long double c, long double d, long double e, long double f, long double g, long double h){\n  long double i = (c - f), j = (d - g), k = (e - h);\n  long double res;\n\n  res = sqrt(i*i + j*j + k*k);\n\n  return res;\n}\n\nsigned main(){\n  cout<<fixed<<setprecision(3);\n\n  while(true){\n    vector<pair<pair<long double, long double>, pair<long double, long double>>> in;\n    vector<pair<long double,pair<int,int>>> edge;\n    long double ans = 0;\n    int n;\n\n    cin>>n;\n\n    if(!n) break;\n\n    in.resize(n);\n\n    for(int i = 0; i < n; i++){\n      //long double x, y, z, r;\n\n      cin>>in[i].x>>in[i].y>>in[i].z>>in[i].r;\n      \n    }\n    init(n);\n  \n    for(int i = 0; i < n; i++){\n      for(int j = i+1; j < n; j++){\n        long double d = dist(in[i].x,in[i].y,in[i].z,in[j].x,in[j].y,in[j].z);\n        long double o = d - in[i].r - in[j].r;\n\n        if(o < 0.0) {\n          o = 0;\n          unite(i, j);\n        }\n        //edge.push_back({max(0.0, d - in[i].r - in[j].r),{i,j}});\n        //edge.push_back(make_pair(max(0.0, d - in[i].r - in[j].r), make_pair(i, j)));\n        edge.push_back(make_pair(o, make_pair(i, j)));\n      }\n    }\n\n    sort(edge.begin(), edge.end());\n\n  \n    for(int i = 0; i < edge.size(); i++){\n      if(!same(edge[i].a, edge[i].b)){\n        unite(edge[i].a, edge[i].b);\n        ans += edge[i].dis;\n      }\n    }\n\n\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<string>\n#include<map>\n#include<string.h>\n#include<complex>\n#include<math.h>\n#include<queue>\n#include <functional>\n#include<time.h>\n#include<iomanip>\n#include<cassert>\n#include<bitset>\n#include<sstream>\nusing namespace std;\ntypedef long long int llint;\ntypedef pair<int, int> pint;\ntypedef pair<llint, llint> pllint;\ntypedef vector<int> vint;\ntypedef vector<llint> vllint;\ntypedef vector<pint> vpint;\ntypedef vector<string> vstring;\ntypedef vector<pair<llint, llint>> vpllint;\ntypedef vector<vector<int>> vvint;\ntypedef vector<vector<llint>> vvllint;\ntypedef vector<vector<pint>> vvpint;\ntypedef vector<bool> vbool;\ntypedef vector<vbool> vvbool;\ntypedef vector<vpllint> vvpllint;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define drep(i,n) for(int i=n-1;0<=i;i--)\n#define yes(ans) if(ans)cout<<\"yes\"<<endl;else cout<<\"no\"<<endl;\n#define Yes(ans) if(ans)cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;\n#define YES(ans) if(ans)cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;\n#define POSSIBLE(ans) if(ans)cout<<\"POSSIBLE\"<<endl;else cout<<\"IMPOSSIBLE\"<<endl;\n#define Pi 3.1415926535897932384626\n#define mod llint(1e9+7)\n#define Inf 2147483647\n#define llInf 9223372036854775807\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define isin(n,i) 0<=i&&i<n\n\nclass UnionFind {\npublic:\n\t//親の番号を格納する。親だった場合は-(その集合のサイズ)\n\tvector<int> Parent;\n\n\t//作るときはParentの値を全て-1にする\n\t//こうすると全てバラバラになる\n\tUnionFind(int N) {\n\t\tParent = vector<int>(N, -1);\n\t}\n\n\t//Aがどのグループに属しているか調べる\n\tint root(int A) {\n\t\tif (Parent[A] < 0) return A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\t//自分のいるグループの頂点数を調べる\n\tint size(int A) {\n\t\treturn -Parent[root(A)];//親をとってきたい\n\t}\n\n\t//AとBをくっ付ける\n\tbool connect(int A, int B) {\n\t\t//AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\t//すでにくっついてるからくっ付けない\n\t\t\treturn false;\n\t\t}\n\n\t\t//大きい方(A)に小さいほう(B)をくっ付けたい\n\t\t//大小が逆だったらひっくり返しちゃう。\n\t\tif (size(A) < size(B)) swap(A, B);\n\n\t\t//Aのサイズを更新する\n\t\tParent[A] += Parent[B];\n\t\t//Bの親をAに変更する\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n};\n\n//セグ木・0-indexed・非再帰・(大きさ・単位元・関数)で初期化\ntemplate<typename T>\nstruct SegTree {\n\t//比較関数の型\n\tusing F = function<T(T, T)>;\n\t//二分木を配列で表したもの\n\tvector<T>seg;\n\t//木の半分の大きさ\n\tint siz;\n\t//単位元\n\tconst T unit;\n\t//比較する関数\n\tconst F f;\n\n\t//大きさn、unit(単位元)、f(モノイド)でsegtreeを初期化する\n\tSegTree(int n, const T unit, const F f) : unit(unit), f(f) {\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t\tseg.assign(siz * 2 - 1, unit);\n\t\tsiz--;\n\t}\n\n\t//k番目にtを入力\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//fによって木を構築する\n\tvoid build() {\n\t\tfor (int i = siz - 1; 0 <= i; i--) {\n\t\t\tseg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t\t}\n\t}\n\n\tT operator[](const int i) {\n\t\treturn seg[i + siz];\n\t}\n\n\t//k番目をxに更新する\n\tvoid update(int k, T x) {\n\t\tk += siz;\n\t\tseg[k] = x;\n\t\twhile (0 < k) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[a,b)について、fした結果を返す\n\t//半開区域のためa以上b未満の位置を指す\n\tT query(int a, int b) {\n\t\tT l = unit, r = unit;\n\t\tfor (a += siz, b += siz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(seg[a++], l);\n\t\t\tif (!(b & 1))r = f(seg[--b], r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n};\n\n//aとbの最大公約数を求めるよ\nlong long GCD(long long a, long long b) {\n\tif (b == 0) return a;\n\telse return GCD(b, a % b);\n}\n\n// 返り値: a と b の最大公約数\n// ax + by = gcd(a, b) を満たす (x, y) が格納される\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//nCrをmで割った余りを求める\nllint nCr(llint n, llint r, llint m) {\n\tllint ans = 1;\n\tfor (llint i = 0; i < r; i++) {\n\t\tans *= n - i;\n\t\tans %= m;\n\t}\n\tfor (llint i = 1; i <= r; i++) {\n\t\tans *= modinv(i, m);\n\t\tans %= m;\n\t}\n\treturn ans;\n}\n\n//aのb乗をmで割った余りを求める\nllint power(llint a, llint b, llint m) {\n\tif (b == 1)return a;\n\tif (b == 0)return 1;\n\tllint tmp = power(a, (llint)b / 2, m);\n\ttmp *= tmp;\n\ttmp %= m;\n\tif (b % 2 == 1) {\n\t\ttmp *= a;\n\t\ttmp %= m;\n\t}\n\treturn tmp;\n}\n\n//bitを表すsub,要素数を表すlength\nbool next_combination(llint& sub, int length) {\n\tllint x = sub & -sub, y = sub + x;\n\tsub = (((sub & ~y) / x) >> 1) | y;\n\treturn sub < (llint)(1 << (llint)length);\n}\n\nvoid Zalgorithm(string& s, vint& a) {\n\ta[0] = s.size();\n\tint i = 1, j = 0;\n\twhile (i < s.size()) {\n\t\twhile (i + j < s.size() && s[j] == s[i + j])j++;\n\t\ta[i] = j;\n\t\tif (j == 0) { i++; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < s.size() && a[k] + k < j) {\n\t\t\ta[i + k] += a[k]; k++;\n\t\t}\n\t\ti += k; j -= k;\n\t}\n\treturn;\n}\n\nint main() {\n\tvector<double>anses;\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tvector<vector<double>>g(n, vector<double>(n));\n\t\tvector<tuple<double, double, double, double>>cell(n);\n\t\trep(i, n) {\n\t\t\tcin >> get<0>(cell[i]) >> get<1>(cell[i]) >> get<2>(cell[i]) >> get<3>(cell[i]);\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i == j)g[i][j] = 0;\n\t\t\t\tdouble x = get<0>(cell[i]) - get<0>(cell[j]),\n\t\t\t\t\ty = get<1>(cell[i]) - get<1>(cell[j]),\n\t\t\t\t\tz = get<2>(cell[i]) - get<2>(cell[j]),\n\t\t\t\t\tr = get<3>(cell[i]) + get<3>(cell[j]);\n\t\t\t\tif (x * x + y * y + z * z < r * r) {\n\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tg[i][j] = sqrt(x * x + y * y + z * z) - r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvbool visited(n, false);\n\t\tvisited[0] = true;\n\t\tpriority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>>que;\n\t\trep(i, n) {\n\t\t\tif (i == 0)continue;\n\t\t\tque.push({ g[0][i],i });\n\t\t}\n\t\tdouble ans = 0;\n\t\tint cnt = 1;\n\t\twhile (cnt < n) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tif (visited[now.second])continue;\n\t\t\tvisited[now.second] = true;\n\t\t\tans += now.first;\n\t\t\tcnt++;\n\t\t\trep(i, n) {\n\t\t\t\tif (visited[i])continue;\n\t\t\t\tque.push({ g[now.second][i],i });\n\t\t\t}\n\t\t}\n\t\tanses.pb(ans);\n\t}\n\trep(i, anses.size()) {\n\t\tprintf(\"%.3f\\n\", anses[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble matrix[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmatrix[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmatrix[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(matrix[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = matrix[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n\n    printf(\"%0.3lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <float.h>\n#include <math.h>\n#include <stdio.h>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntypedef struct {\n  float x,y,z,r;\n} Cell;\n\nint main(void)\n{\n  while (1) {\n    int n,i;\n    Cell v[100];\n    int vlen=0;\n    float G [100][100];\n    for (int i=0;i<100;++i)\n      for(int j=0;j<100;++j)\n\tG[i][j]=FLT_MAX;\n     \n    scanf(\"%d\",&n);\n    if( n==0 )\n      break;\n   \n    for(i=0;i<n;++i){ \n      float x,y,z,r;\n      scanf(\"%f %f %f %f\",&x,&y,&z,&r);\n      for(int j=0; j<vlen; ++j){\n\tfloat dx = x - v[j].x;\n\tfloat dy = y - v[j].y;\n\tfloat dz = z - v[j].z;\n\tfloat d = sqrt(dx*dx + dy*dy + dz*dz) - (v[j].r + r);\n\tif (d<=0){\n\t  G[i][j] = 0.0;\n\t  G[j][i] = 0.0;\n\t} else {\n\t  G[i][j] = d;\n\t  G[j][i] = d;\n\t}\t\n      }\n\n      Cell const c = { x, y, z, r };\n      v[vlen] = c;\n      ++vlen;\n    }\n    float sum = 0.0;\n    float d[100];\n    bool visited[100];\n    std::fill( d, d+100, FLT_MAX );\n    std::fill( visited, visited+100, false );\n\n    //initialize\n    int u = 0;\n    d[0] = 0;\n\n    for( int i=0; i<n; ++i ) {\n      float tmp = FLT_MAX;\n      for( int j=0; j<n; ++j ) {\n\tif ( !visited[j] && d[j] < tmp ) {\n\t  tmp = d[j];\n\t  u = j;\n\t}\n      }\n      sum += d[u];\n      visited[u] = true;\n\n      for(int j=0; j<n; ++j ) {\n\tif ( !visited[j] && G[u][j] < d[j] ) {\n\t  d[j] = G[u][j];\n\t}\n      }\n    }\n    printf( \"%.3lf\\n\", sum );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define lper(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\nll modfac(ll a){\n    ll ans=1;\n    while(a>1){\n        ans*=a;\n        ans%=1000000007;\n        a--;\n    }\n    return ans;\n}\nll modinv(ll a,ll m) {\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m; \n    if (u < 0) u += m;\n    return u;\n}\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) {}\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint main(){\n    while(true){\n        CST(3);\n        ll n;cin >> n;\n        if(!n)break;\n        vector<double> x(n),y(n),z(n),r(n);\n        rep(i,n)cin >> x[i] >>y[i]>>z[i]>>r[i];\n        vector<tuple<double,ll,ll>> v;\n        rep(i,n){\n            repl(j,i+1,n){\n                double dx=abs(x[i]-x[j]),dy=abs(y[i]-y[j]),dz=abs(z[i]-z[j]);\n                double dl=sqrt(dx*dx+dy*dy+dz*dz);\n                double cost=max((double)0,dl-r[i]-r[j]);\n                v.pb(tie(cost,i,j));\n            }\n        }\n        sort(all(v));\n        double ans=0;\n        UnionFind uf(n);\n        rep(i,v.size()){\n            ll a=get<1>(v[i]),b=get<2>(v[i]);\n            double cost=get<0>(v[i]);\n            if(!uf.same(a,b)){\n                ans+=cost;\n                uf.merge(a,b);\n            }\n        }\n        cout << ans <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nstruct point{\n  double x, y, z, r;\n  point(){}\n  point(double x, double y, double z, double r):x(x), y(y), z(z), r(r){}\n};\nbool used[111];\nint n;\n\npoint pos[111];\n\ndouble dist(point p, point q)\n{\n  double x = p.x - q.x, y = p.y - q.y, z = p.z - q.z;\n  double d = sqrt(x*x + y*y + z*z);\n  return max(d - p.r - q.r, 0.0);\n}\n\ndouble prim()\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  double total = 0.0;\n  fill(used, used + 111, false);\n  que.push(P(0.0, 0));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int now = p.second;\n    double d = p.first;\n    if(used[now]) continue;\n    used[now] = true;\n    total += d;\n    for(int i = 0; i < n; i++){\n      if(i == now) continue;\n      que.push(P(dist(pos[now], pos[i]), i));\n    }\n  }\n  return total;\n}\n\nint main()\n{\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      pos[i] = point(x, y, z, r);\n    }\n    printf(\"%.3f\\n\", prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=103,INF=1<<30;\nconst double eps=1e-12;\n\nint par[MAX],size[MAX];\n\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        size[i]=1;\n    }\n}\n\nint root(int a){\n    if(par[a]==a) return a;\n    else return par[a]=root(par[a]);\n}\n\nvoid unite(int a,int b){\n    if(root(a)!=root(b)){\n        size[root(a)]+=size[root(b)];\n        par[root(b)]=root(a);\n    }\n}\n\nbool check(int a,int b){\n    return root(a)==root(b);\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        \n        init(N);\n        \n        vector<double> x(N),y(N),z(N),r(N);\n        vector<pair<double,pair<int,int>>> S;\n        \n        for(int i=0;i<N;i++) cin>>x[i]>>y[i]>>z[i]>>r[i];\n        \n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                double d=hypot(hypot(x[i]-x[j],y[i]-y[j]),z[i]-z[j]);\n                if(d<=r[i]+r[j]+eps) unite(i,j);\n                else S.push_back({d-(r[i]+r[j]),{i,j}});\n            }\n        }\n        \n        sort(all(S));\n        bool ok=false;\n        \n        for(int i=0;i<N;i++){\n            if(size[root(i)]==N) ok=true;\n        }\n        \n        if(ok){\n            cout<<\"0.000\"<<endl;\n            continue;\n        }\n        \n        double ans=0.0;\n        \n        for(int i=0;i<S.size();i++){\n            int a=S[i].second.first,b=S[i].second.second;\n            if(check(a,b)) continue;\n            unite(a,b);\n            ans+=S[i].first;\n            \n            if(size[root(a)]==N) break;\n        }\n        \n        cout<<fixed<<setprecision(3)<<ans<<endl;\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\nstruct UnionFind{\n    int root[101];\n    \n    UnionFind(){\n        for(int i = 0; i < 101; i++){\n            root[i] = i;\n        }\n    }\n\n    int getRoot(int x){\n        if(root[x] == x) return x;\n        root[x] = getRoot(root[x]);\n        return root[x];\n    }\n\n    bool isSame(int x, int y){\n        int px = getRoot(x);\n        int py = getRoot(y);\n        if(px == py) return true;\n        else return false;\n    }\n\n    void unite(int x, int y){\n        if(isSame(x,y)) return;\n        int px = getRoot(x);\n        int py = getRoot(y);\n        root[py] = px;\n    }\n};\n\nvoid solve(int n){\n    vector<double> x(n),y(n),z(n),r(n);\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    vector<pair<double, pair<int,int> > > edge;\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            double d = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n            d = sqrt(d);\n            d = d - r[i] - r[j];\n            if(d < 0) d = 0;\n            edge.push_back(make_pair(d,make_pair(i,j)));\n        }\n    }\n    sort(edge.begin(), edge.end());\n    \n    UnionFind uf;\n\n    double ans = 0;\n    for(int i = 0; i < edge.size(); i++){\n        auto d = edge[i].first;\n        auto path = edge[i].second;\n        if(uf.isSame(path.first, path.second) == true) continue;\n        uf.unite(path.first, path.second);\n        ans += d;\n    }\n\n    cout << std::fixed << std::setprecision(3) <<  ans << endl;\n    return;\n}\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n,0));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tbool flag = false;\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])continue;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(3)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n\n// Union-Findの実装\nconst int MAX_N = 10000; // 今回の場合、頂点の数の最大値\n\nstruct UnionFind\n{\n  // par[i]:要素iが属する木の親の番号、i==par[i]のときは要素iが木の根となる\n  int par[MAX_N];\n  \n  // rank[i]:根が要素iの木の高さ(ランク)\n  int rank[MAX_N];\n  \n  // コンストラクタ\n  // 各要素iが要素iを根とする高さ0の木に存在するものとして初期化を行う\n  UnionFind(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  // 要素xが属する木の根を得るメソッド\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  // 2つの要素xとyが属する木を併合するメソッド\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属している場合\n    if(x == y) return;\n\n    // 効率化の工夫としてランクが低いものから高いものへ辺を張る\n    if(rank[x] < rank[y]) par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++; // ランクが等しい場合\n    }\n  }\n\n  // 2つの要素xとyが属する木の根が同じならtrueを返すメソッド\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\n\n// 辺の情報を表す構造体\nstruct Edge{\n  int u, w;\n  double cost;\n};\n\n// Edgeをコストの小さい順にソートするための比較関数\nbool comp(const Edge &e1, const Edge &e2)\n{\n  return e1.cost < e2.cost;\n}\n\nconst int MAX_E = 100000; // 辺の数の最大値\nEdge es[MAX_E]; // グラフ上の辺を保存する配列\nint v, e; // 頂点の数と辺の数\n\n\ndouble kruskal()\n{\n  sort(es, es + e, comp); // 辺をコストの小さい順にソート\n  UnionFind uf(v); // Union-Findの準備\n  double ans = 0; // 最小全域木(森)の辺の総コスト\n\n  // 全域木に辺を追加していく\n  for(int i = 0; i < e; i++){\n    // コストの小さい辺から調べる\n    Edge et = es[i];\n\n    // もし辺の両端の頂点が同じ連結成分属していないならば\n    if(!uf.same(et.u, et.w)){\n      uf.unite(et.u, et.w); // 同じ連結成分に属させる\n      ans += et.cost; // その辺を全域木に追加\n    }\n  }\n\n  return ans;\n}\n\ntypedef struct sphere{\n  double x, y, z, r;\n} Sphere;\n\n\nint main()\n{\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    v = n;\n    e = 0;\n    for(int i = n - 1; i > 0; i--)\n      e += i;\n    Sphere s[100];\n    for(int i = 0; i < n; i++)\n      cin >> s[i].x >> s[i].y >> s[i].z >> s[i].r;\n    for(int i = 0, k = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++, k++){\n        Edge et;\n        et.u = i;\n        et.w = j;\n        et.cost = sqrt(pow(s[i].x - s[j].x, 2) + pow(s[i].y - s[j].y, 2) + pow(s[i].z - s[j].z, 2)) - s[i].r - s[j].r;\n        if(et.cost < 0)\n          et.cost = 0;\n        es[k] = et;\n      }\n    }\n    printf(\"%.3lf\\n\", kruskal());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double INF = 10000.0;\nconst int MAX_V = 1000;\n\nint n;\nstruct cell{ double x,y,z,r; };\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v, double cost_){\n\tcost[u][v] = cost[v][u] = cost_;\n}\n\ndouble prim(){\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0.0;\n\t\n\twhile( true ){\n\t\tint v = -1;\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tif( !used[u] && (v == -1 || mincost[u] < mincost[v] ) )\n\t\t\t\tv = u;\n\t\t}\n\t\t\n\t\tif( v == -1 ) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tmincost[u] = min( mincost[u] , cost[v][u] );\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble D(cell c1, cell c2){\n\tdouble dx = c1.x - c2.x;\n\tdouble dy = c1.y - c2.y;\n\tdouble dz = c1.z - c2.z;\n\tdouble d = sqrt( dx * dx + dy * dy + dz * dz ) - c1.r - c2.r;\n\tif( d < 0.0 ) \n\t\td = 0.0;\n\treturn d;\n}\n\nint main(){\n\twhile( scanf(\"%d\", &n ) , n ){\n\t\tvector<cell> v;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x,y,z,r;\n\t\t\tcell c;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &z, &r);\n\t\t\tc.x = x;\n\t\t\tc.y = y;\n\t\t\tc.z = z;\n\t\t\tc.r = r;\n\t\t\tv.push_back( c );\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = D( v[i] , v[j] );\n\t\t\t\tadd_edge( i , j , d );\n\t\t\t}\n\t\t}\n\t\tdouble ans = prim();\n\t\tprintf(\"%.6f\\n\", ans );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\n\nclass UF{\npublic:\n  Int V;\n  vector<Int> par,rnk,sz;\n  UF(){}\n  UF(Int V):V(V),par(V),rnk(V,0),sz(V,1){for(Int i=0;i<V;i++)par[i]=i;}\n\n  Int find(Int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n\n  void unite(Int x,Int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rnk[x]<rnk[y])par[x]=y, sz[y] += sz[x];\n    else{\n      par[y]=x;\n      sz[x] += sz[y];\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  bool same(Int x,Int y){return find(x)==find(y);}\n\n  Int size(Int x){return sz[find(x)];}\n};\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(3);\n\n  while(1){\n    Int N;\n    cin>>N;\n    if(N == 0) break;\n\n    using T = tuple<Double, Double, Double, Double>;\n    vector<T> A(N);\n    for(Int i=0;i<N;i++){\n      Double x, y, z, r;\n      cin>>x>>y>>z>>r;\n      A[i] = T(x, y, z, r);\n    }\n\n    auto calcDis=[&](T s, T t){\n      Double x, y, z, r; tie(x, y, z, r) = s;\n      Double a, b, c, d; tie(a, b, c, d) = t;\n      Double dis = sqrt((x - a) * (x - a) + (y - b) * (y - b) + (z - c) * (z - c));\n      Double res = max((Double)0, (dis - (r + d)));\n      return res;\n    };\n\n    using E = tuple<Double, Int, Int>;\n    vector<E> edge;\n    for(Int i=0;i<N;i++)\n      for(Int j=i+1;j<N;j++){\n        Double cost = calcDis(A[i], A[j]);\n        edge.emplace_back(cost, i, j);\n      }\n\n    sort(edge.begin(), edge.end());\n    UF uf(N);\n    Double ans = 0;\n    for(auto e:edge){\n      Double c;\n      Int a, b; tie(c, a, b) = e;\n      if(uf.same(a, b)) continue;\n      uf.unite(a, b);\n      ans += c;\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS 0.0001\n\ntypedef struct {\n  double x;\n  double y;\n  double z;\n  double r;\n} Cell;\n\nbool eq(double a, double b){\n  return abs(a-b) < EPS;\n}\n\ndouble cellLength( Cell a, Cell b){\n  double l = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)) - (a.r + b.r);\n  if(l <= 0) return 0;\n  else return l;\n}\n\nint main(void){\n  int n;\n  double btw[101][101];\n  Cell cell[101];\n  while(cin >> n, n){\n    for(int i=0; i < n; i++){\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      Cell tmp = {x, y, z, r};\n      cell[i] = tmp;\n    }\n\n    for(int p=0; p < n; p++){\n      for(int q=0; q < n; q++){\n        btw[p][q] = cellLength(cell[p], cell[q]);\n      }\n    }\n\n    //prim\n    double mincost[101];\n    bool used[101];\n    for(int i=0; i < n; i++){\n      mincost[i] = INT_MAX-1;\n      used[i] = false;\n    }\n    mincost[0] = 0;\n    double res = 0;\n\n    while(true){\n      int v = -1;\n      for(int u=0; u < n; u++){\n        if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n      }\n\n      if(v == -1) break;\n      used[v] = true;\n      res += mincost[v];\n\n      for(int u=0; u < n; u++){\n        mincost[u] = min(mincost[u], btw[v][u]);\n      }\n    }\n    printf(\"%f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec secondstruct edge{ int u, v, cost; };\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nstruct edge{ int u, v; double cost; };\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\nint par[100];\nint rank[100];\nedge es[10000];\nint V, E;\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\t\n\tif(rank[x] < rank[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\ndouble kruskal(){\n\tsort(es, es+E, comp);\n\tdouble res = 0.0;\n\tfor(int i = 0; i < E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tdouble x[100], y[100], z[100], r[100];\n\trep(i,V) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\tinit(V);\n\tE = 0;\n\trep(i,V){\n\t\tfor(int j = i+1; j < V; j++){\n\t\t\tif((r[j]+r[i])*(r[j]+r[i]) < (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j])){\n\t\t\t\tedge e;\n\t\t\t\te.u = i;\n\t\t\t\te.v = j;\n\t\t\t\te.cost = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[j]-r[i];\n\t\t\t\tes[E] = e;\n\t\t\t\tE++;\n\t\t\t} else{\n\t\t\t\tunite(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.3f\\n\", kruskal());\n}\n\nint main(){\n\twhile(cin >> V,V) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst double INF = 1000000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\t//if(i==j)\n\t\t\t\t//\tcontinue;\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.IOException;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\tint[] par;\n\n\tclass Ball {\n\t\tdouble x, y, z;\n\t\tdouble r;\n\n\t\tBall(double x, double y, double z, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tdouble len;\n\t\tint x, y;\n\n\t\tEdge(double len, int x, int y) {\n\t\t\tthis.len = len;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (this.len - o.len > 0) return 1;\n\t\t\tif (this.len - o.len < 0) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble dist(Ball a, Ball b) {\n\t\tdouble res = 0;\n\t\tres = Math.hypot(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n\t\tres = Math.hypot(res, Math.abs(a.z - b.z));\n\t\treturn res;\n\t}\n\n\tboolean isTouching(Ball a, Ball b) {\n\t\treturn dist(a, b) < a.r + b.r;\n\t}\n\n\tvoid union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tpar[x] = y;\n\t}\n\n\tboolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn root(par[x]);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBall[] b = new Ball[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tb[i] = new Ball(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\n\t\t\tpar = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\n\t\t\tList<Edge> list = new LinkedList<Edge>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!isTouching(b[i], b[j])) {\n\t\t\t\t\t\tlist.add(new Edge(dist(b[i], b[j]) - b[i].r - b[j].r, i, j));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunion(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble sum = 0;\n\t\t\tCollections.sort(list);\n\t\t\tfor (Edge E: list) {\n\t\t\t\tif (!find(E.x, E.y)) {\n\t\t\t\t\tunion(E.x, E.y);\n\t\t\t\t\tsum += E.len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 101;\nbool used[MAX];\n\nstruct data{double x,y,z,r;};\nstruct State{\n  data d;\n  double t;\n  int n;\n  State(){}\n  State(data d, double t, int n):d(d),t(t),n(n){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\n\nint N;\nvector<data> V;\n\nvoid init(){\n  V.clear();\n  V.resize(N);\n  fill(used,used+MAX,false);\n}\n\nvoid input(){\n  for(int i = 0; i < N; i++)\n    cin >> V[i].x >> V[i].y >> V[i].z >> V[i].r;\n}\n\n\ndouble getDis(data d1, data d2){\n  return sqrt(pow(d1.x-d2.x,2.0)+pow(d1.y-d2.y,2.0)+pow(d1.z-d2.z,2.0));\n}\nvoid solve(){\n  priority_queue<State> Q;\n  Q.push(State(V[0],0,0));\n  \n  double ans = 0;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    if(used[now.n]) continue;\n    used[now.n] = true;\n  \n    ans += now.t;\n    \n    for(int i = 0; i < N; i++){\n      double dis = max(getDis(now.d,V[i])-now.d.r-V[i].r,0.0);\n      if(!used[i]) Q.push(State(V[i],dis,i));\n    }\n  }\n  printf(\"%.3f\\n\",ans);\n}\n\nint main(){\n  while(cin >> N && N){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\n\nvector<pair<int,double> > E[100];\nint n;\n\ndouble prim(){\n  bool used[n];\n  memset(used,0,sizeof(used));\n  priority_queue<pair<double,int> > Q;\n  Q.push(mp(0,0));\n  double ret=0;\n  while(!Q.empty()){\n    double cc=-Q.top().F;\n    int from=Q.top().S;\n    Q.pop();\n    if(used[from])continue;\n    used[from]=true;\n    ret+=cc;\n    \n    rep(i,E[from].size()){\n      int to=E[from][i].F;\n      double co=E[from][i].S;\n      if(used[to])continue;\n      Q.push(mp(-co,to));\n    }\n  }\n  return ret;\n}\n\nmain(){\n\n  while(cin>>n,n){\n    double x[n],y[n],z[n],r[n];\n    rep(i,n)E[i].clear();\n\n    rep(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\n    rep(i,n){\n      rep(j,i){\n\tdouble tx=x[j]-x[i],ty=y[j]-y[i],tz=z[j]-z[i];\n\tdouble len=sqrt(tx*tx+ty*ty+tz*tz);\n\tdouble cost=len-r[i]-r[j];\n\tif(cost<0)cost=0;\n\tE[i].pb(mp(j,cost));\n\tE[j].pb(mp(i,cost));\n      }\n    }\n\n    printf(\"%.5f\\n\",prim());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<queue>\n#include<cstdio>\n#define inf 1000000001\n#define f first\n#define s second\nusing namespace std;\n\nint n;\ndouble map[101][101];\n  \ndouble Prim()\n{\n  priority_queue<pair<double,int> > PQ;\n  int color[100];\n  double d[100];\n  for(int i=0;i<n;i++){\n    d[i]=inf;\n    color[i]=0;\n  }\n  d[0]=0;\n  PQ.push(make_pair(0,0));\n  color[0]=0;\n  while(!PQ.empty()){\n    pair<double,int> p=PQ.top();PQ.pop();\n    int u=p.s;\n    color[u]=2;\n\n    if(d[u]<p.f*(-1))continue;\n\n    for(int i=0;i<n;i++){\n      if(color[i]==2 || map[u][i]==inf)continue;\n      if(d[i]>map[u][i]){\n\td[i]=map[u][i];\n\tPQ.push(make_pair(d[i]*(-1),i));\n\tcolor[i]=1;\n      }\n    }\n  }\n  double ans=0;\n  for(int i=0;i<n;i++)ans+=d[i];\n  return ans;\n}  \n\nint main()\n{\n  double x[101],y[101],z[101],r[101];\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)map[i][j]=inf;\n\telse {\n\t  double d=sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]) );\n\t  map[i][j]=d-(r[i]+r[j]);\n\t  if(map[i][j]<0)map[i][j]=0;\n\t}\n      }\n    }\n    printf(\"%.3f\\n\",Prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define NODE_MAX 105\n\ntypedef vector<double> vd;\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n; cin >> n;\n\t\tif (n == 0) return 0;\n\n\t\tvd x(n), y(n), z(n), r(n);\n\t\trep(i, 0, n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\n\t\tdouble adj[NODE_MAX][NODE_MAX];\n\t\trep(a, 0, n) rep(b, 0, n)\n\t\t{\n\t\t\tadj[a][b] = sqrt(abs(x[a] - x[b])*abs(x[a] - x[b]) + abs(y[a] - y[b])*abs(y[a] - y[b]) + abs(z[a] - z[b])*abs(z[a] - z[b])) - r[a] - r[b];\n\t\t\tif (adj[a][b] < 0) adj[a][b] = 0;\n\t\t}\n\n\t\tdouble ans = 0;\n\t\tbool finished[NODE_MAX] = { false };\n\t\tfinished[0] = true;\n\t\trep(i, 0, n - 1)\n\t\t{\n\t\t\tint from = -1;\n\t\t\tint to = -1;\n\t\t\tdouble _min = 10000;\n\t\t\trep(a, 0, n) rep(b, 0, n)\n\t\t\t{\n\t\t\t\tif (finished[a] == true && finished[b] == false)\n\t\t\t\t{\n\t\t\t\t\tif (adj[a][b] < _min)\n\t\t\t\t\t{\n\t\t\t\t\t\tfrom = a;\n\t\t\t\t\t\tto = b;\n\t\t\t\t\t\t_min = adj[a][b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinished[to] = true;\n\t\t\tans += _min;\n\t\t}\n\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tq.push((Edge){i, j, 0.0});\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && c<n-1) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\tans += e.cost;\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll> > P3;\n\nconst ll MOD = ll(1e9 + 7);\nconst ll LLINF = LLONG_MAX;\nconst int IINF = INT_MAX;\nconst int MAX_V = int(1e2) + 5;\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\nstring dir = \"RDLU\";\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define SORT(v) sort((v).begin(), (v), end())\n#define SORTR(v) sort((v).rbegin(), (v), rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct UnionFindTree {\n    int par[MAX_V];\n    int rank[MAX_V];\n\n    void init(int n) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct edge {\n    int u, v;\n    double cost;\n};\n\nbool comp(const edge &e1, const edge &e2) { return e1.cost < e2.cost; }\n\nvector<edge> es;\n\ndouble kruskal(int V) {\n    sort(es.begin(), es.end(), comp);\n    UnionFindTree a;\n    a.init(V);\n    double res = 0;\n    for (int i = 0; i < es.size(); i++) {\n        edge e = es[i];\n        if (!a.same(e.u, e.v)) {\n            a.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if(n==0)break;\n        vector<double> x(n),y(n),z(n),r(n);\n        es.clear();\n        REP(i,n){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(j,n){\n            REP(i,j){\n                double c;\n                c = pow(pow(abs(x[i]-x[j]),2)+pow(abs(y[i]-y[j]),2)+pow(abs(z[i]-z[j]),2),0.5);\n                c = max(0.0,c-r[i]-r[j]);\n                es.push_back({i,j,c});\n            }\n        }\n        printf(\"%.3lf\\n\",kruskal(n));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll big=1e18;\n\nint main() {\n    int n;\n    vector<double> ansarr;\n    while(true){\n        cin>>n;\n        if(n==0) break;\n        double x[n], y[n], z[n], r[n];\n        for(int i=0;i<n;++i){\n            cin>>x[i]>>y[i]>>z[i]>>r[i];\n        }\n        vector<vector<pair<int, double> > > edge(n);\n        double zero = 0;\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j){\n                if(i==j) continue;\n                edge[i].push_back(mp(j, max(zero, sqrt(pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2)) - r[i] - r[j])));\n            }\n        }\n        priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n        que.push(mp(0, 0));\n        pair<double, int> state;\n        double dist;\n        int town;\n        double DP[n];\n\n        for(int i=0;i<n;++i){\n            DP[i] = -1;\n        }\n\n        while(!que.empty()){\n            state = que.top();que.pop();\n            dist = state.fi;\n            town = state.se;\n            if(DP[town] != -1) continue;\n            DP[town] = dist;\n            for(int i=0;i<edge[town].size();++i){\n                if(DP[edge[town][i].fi] != -1) continue;\n                que.push(mp(edge[town][i].se, edge[town][i].fi));\n            }\n        }\n        double ans = 0;\n        for(int i=0;i<n;++i){\n            ans += DP[i];\n        }\n        ansarr.push_back(ans);\n    }\n    for(int i=0;i<ansarr.size();++i){\n        cout<<fixed<<setprecision(3)<<ansarr[i]<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<double, int>P;\n\ndouble x[100], y[100], z[100], r[100], d[100][100];\nbool used[100];\ndouble distance(double x1, double y1, double z1, double r1, double x2, double y2, double z2, double r2) {\n\treturn max(0., sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)) - r1 - r2);\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n\t\trep(i, n)for (int j = i + 1; j < n; j++)d[i][j] = d[j][i] = distance(x[i], y[i], z[i], r[i], x[j], y[j], z[j], r[j]);\n\t\tdouble sum = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\tpriority_queue<P, vector<P>, greater<P>>que; que.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (used[p.second])continue;\n\t\t\tused[p.second] = true;\n\t\t\tsum += p.first;\n\t\t\trep(i, n)que.push(P(d[p.second][i], i));\n\t\t}\n\t\tprintf(\"%.7lf\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct Sphere{\n    double x;\n    double y;\n    double z;\n    double r;\n};\n\nint n;\nvector< vector<double> > costs;\n\nint main(void){\n    double res;\n    for(; cin >> n, n; printf(\"%.3f\\n\", res)){\n        res = 0.;\n        vector<Sphere> spheres(n);\n        rep(i, n) cin >> spheres[i].x >> spheres[i].y >> spheres[i].z >> spheres[i].r;\n\n        costs = vector< vector<double> >(n, vector<double>(n));\n        rep(u, n){\n            range(v, u, n){\n                double d = sqrt(sqr(spheres[u].x - spheres[v].x) \n                              + sqr(spheres[u].y - spheres[v].y) \n                              + sqr(spheres[u].z - spheres[v].z));\n                costs[u][v] = costs[v][u] = max(0., d - (spheres[u].r + spheres[v].r));\n            }\n        }\n\n        vector<double> minCost(n, inf);\n        vi used(n);\n\n        minCost[0] = 0;\n        while(1){\n            int v = -1;\n            rep(u, n){\n                if(!used[u] && (v == -1 || minCost[u] < minCost[v])) v = u;\n            }\n            if(v == -1) break;\n\n            used[v] = true;\n            res += minCost[v];\n\n            rep(u, n){\n                minCost[u] = min(minCost[u], costs[v][u]);\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1127\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint c[100][100];\n\nstruct P{\n    double x,y,z,r;\n    double abs(){\n        return sqrt(x*x+y*y+z*z);\n    }\n};\n\nP operator - (P a,P b){\n    a.x -= b.x;\n    a.y -= b.y;\n    a.z -= b.z;\n    return a;\n}\n\n\n\nint uf[1000];\nint get(int x){\n    return uf[x] = (uf[x]==x?x:get(uf[x]));\n}\nint unite(int x,int y){ uf[get(x)] = get(y); }\n\ndouble calc(P a,P b){\n    return max((a-b).abs()-a.r-b.r,0.);\n    \n}\nint main(){\n    int n;\n    while(cin >> n && n){\n        for(int i = 0 ; i < 1000 ; i++) uf[i] = i;\n        vector<P> pts(n);\n        for(int i = 0 ; i < n ; i++){\n            cin >> pts[i].x >> pts[i].y >> pts[i].z >> pts[i].r;\n        }\n        double ans = 0;\n        vector< pair<double,pair<int,int> > > e;\n        for(int i = 0 ; i < n ; i++){\n            for(int j = 0 ; j < n ; j++){\n                double dist = calc(pts[i],pts[j]);\n                e.push_back(make_pair(dist,make_pair(i,j)));\n            }\n        }\n        sort(e.begin(),e.end());\n        for(int i = 0 ; i < e.size() ; i++){\n            if( get(e[i].second.first) != get(e[i].second.second)){\n                ans += e[i].first;\n                unite(e[i].second.first,e[i].second.second);\n            }\n        }\n        printf(\"%.10lf%c\",ans,10    );\n    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\nconst double eps = 1e-8;\n\nint root(vector<int> & ufa,int i)\n{\n\tif(ufa[i] != i)\n\t\tufa[i] = root(ufa,ufa[i]);\n\treturn ufa[i];\n}\n\nvoid join(vector<int> & ufa,int i,int j)\n{\n\tint ri = root(ufa,i);\n\tint rj = root(ufa,j);\n\tufa[ri] = rj;\n}\n\nstruct e\n{\n\tint s;\n\tint t;\n\tdouble cst;\n};\n\nbool operator<(const e & lhs,const e & rhs)\n{\n\treturn lhs.cst < rhs.cst;\n}\n\nint main(void) {\n\tcout.precision(3);\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tvector<double> z(n);\n\t\tvector<double> r(n);\n\t\tvector<int> ufa(n);\n\t\tREP(i,n)ufa[i]=i;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tvector<vector<double> > dist_big(n,vector<double>(n,INF));\n\t\tREP(i,n)REP(j,n)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tdouble d = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\tdist_big[i][j]=dist_big[j][i]=sqrt(d)-(r[i]+r[j]);\n\t\t\tif(d <= (r[i]+r[j]+eps)*(r[i]+r[j]+eps))\n\t\t\t{\n\t\t\t\tjoin(ufa,i,j);\n\t\t\t}\n\t\t}\n\t\tset<int> sec;\n\t\tREP(i,n)\n\t\t\tsec.insert(root(ufa,i));\n\t\tint secn = sec.size();\n\t\tif(secn > 1)\n\t\t{\n\t\t\tvector<int> roots;\n\t\t\tFORIT(i,sec)\n\t\t\t\troots.push_back(*i);\n\t\t\tvector<vector<double> > dist(secn,vector<double>(secn,INF));\n\t\t\tREP(i,n)REP(j,n)\n\t\t\t{\n\t\t\t\tif(ufa[i]==ufa[j])continue;\n\t\t\t\tint di,dj;\n\t\t\t\tREP(k,secn)\n\t\t\t\t{\n\t\t\t\t\tif(roots[k]==ufa[i])di=k;\n\t\t\t\t\tif(roots[k]==ufa[j])dj=k;\n\t\t\t\t}\n\t\t\t\tdist[di][dj]=min(dist[di][dj],dist_big[i][j]);\n\t\t\t}\n\t\t\tvector<e> edge;\n\t\t\tREP(i,secn)REP(j,i)\n\t\t\t{\n\t\t\t\te p = {i,j,dist[i][j]};\n\t\t\t\tedge.push_back(p);\n\t\t\t}\n\t\t\tsort(ALL(edge));\n\t\t\tvector<int> ufa2(secn);\n\t\t\tREP(i,secn)ufa2[i]=i;\n\t\t\tdouble cost = 0.0;\n\t\t\tREP(i,edge.size())\n\t\t\t{\n\t\t\t\te p = edge[i];\n\t\t\t\tif(root(ufa2,p.s) != root(ufa2,p.t))\n\t\t\t\t{\n\t\t\t\t\tjoin(ufa2,p.s,p.t);\n\t\t\t\t\tcost += p.cst;\n\t\t\t\t\tsecn--;\n\t\t\t\t\tif(secn == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout  << setiosflags(ios::fixed)<< cost << endl;\n\t\t}\n\t\telse\n\t\t\tcout << setiosflags(ios::fixed)<< 0.0 << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\nint n;\ndouble ans;\ndouble x[105];\ndouble y[105];\ndouble z[105];\ndouble r[105];\ndouble dis[105][105];\ndouble mincost[105];\nbool used[105];\ndouble prim()\n{\n  for(int i=0;i<n;i++)\n    {\n      mincost[i]=inf;\n      used[i]=false;\n    }\n  mincost[0]=0;\n  double ret=0;\n  while(true)\n    {\n      int v=-1;\n      for(int u=0;u<n;u++)\n\t{\n\t  if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n\t}\n      if(v==-1) break;\n      used[v]=true;\n      ret+=mincost[v];\n      for(int u=0;u<n;u++)\n\t{\n\t  mincost[u]=min(mincost[u],dis[v][u]);\n\t}\n    }\n  return ret;\n}\n\nint main()\n{\n  while(cin >> n &&n)\n    {\n      memset(dis,inf,sizeof(dis));\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t}\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<n;j++)\n\t    {\n\t      if(i!=j)\n\t\t{\n\t\t  dis[i][j]=max(0.0,sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2))-r[i]-r[j]);\n\t\t}\n\t    }\n\t}\n      ans=prim();\n      if(ans<1e-9)\n\t{\n\t  cout << fixed << setprecision(3) << 0.000 << endl;\n\t}\n      else\n\t{\n\t  cout << fixed << setprecision(3) << ans << endl;\n\t}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntemplate<typename T>\nclass UnionFind {\n    int size_;\n    std::vector<T> par;\n    std::vector<T> rank;\n    public:\n    UnionFind(int size_) : size_(size_) {\n        par.resize(size_);\n        rank.resize(size_);\n        for(int i=0; i<size_; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    T find(T x) {\n        return par[x] == x ? x : par[x] = find(par[x]);\n    }\n    void unite(T x,T y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]) {\n            par[x] = y;\n        }\n        else {\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(T x,T y) {\n        return find(x) == find(y);\n    }\n};\nint n;\nstruct Sphere {\n    double x,y,z,r;\n};\nstruct Edge {\n    int from;\n    int to;\n    double cost;\n\n    bool operator<(const Edge &rth) const {\n        return cost < rth.cost;\n    }\n};\ndouble pow2(double x) {\n    return x*x;\n}\ndouble dist(Sphere s1, Sphere s2) {\n    double t;\n    t=pow2(s1.x-s2.x);\n    t+=pow2(s1.y-s2.y);\n    t+=pow2(s1.z-s2.z);\n    t=sqrt(t);\n\n    t=t-s1.r-s2.r;\n\n    if(t<0) t=0;\n    return t;\n}\nvoid solve() {\n    UnionFind<int> uf(102);\n    vector<Edge> edges;\n    Sphere sphere[102];\n    rep(i,n) {\n        double x,y,z,r;\n        cin>>x>>y>>z>>r;\n        sphere[i]={x,y,z,r};\n    }\n    rep(i,n) rep(j,n) if(i!=j) {\n        double d=dist(sphere[i],sphere[j]);\n        edges.push_back({i,j,d});\n    }\n\n    sort(all(edges));\n    double ans=0;\n\n    rep(i,edges.size()) {\n        Edge e = edges[i];\n        if(!uf.same(e.from,e.to)) {\n            ans+=e.cost;\n            uf.unite(e.from,e.to);\n        }\n    }\n\n    printf(\"%.3f\\n\",ans);\n}\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\n\ndouble cell[110][4];\ndouble dist[110][110]; // お互いの距離\n\nint par[110];//親\nint rank2[110];//木の深さ\n\nvoid init(int n){\n  for(int i = 0;i < n;i++){\n    par[i] = i;\n    rank2[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank2[x] < rank2[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank2[x] == rank2[y])rank2[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n  \n  \n  \n\n\n\nint main(){\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0)break;\n        init(n);\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < 4;j++){\n                cin >> cell[i][j];\n            }\n        }\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < n;j++){\n                double xyz = 0.0,rsum = cell[i][3] + cell[j][3];\n                for(int k = 0;k < 3;k++){\n                    xyz += (cell[i][k]-cell[j][k])*(cell[i][k]-cell[j][k]);\n                }\n                if(rsum*rsum >= xyz){ // iとjはつながっている\n                    unite(i,j);\n                }else{\n                    dist[i][j] = sqrt(xyz) - rsum;\n                    dist[j][i] = sqrt(xyz) - rsum;\n                }\n            }\n        }\n        double ans = 0.0;\n        while(true){\n            int flag = 0;\n            int a,b;\n            double distmin = 1000000.0;\n            for(int i = 0;i < n;i++){\n                for(int j = i+1;j < n;j++){\n                    if(same(i,j) == false && distmin > dist[i][j]){\n                        a = i;\n                        b = j;\n                        distmin = dist[i][j];\n                        flag = 1;\n                    }\n                }\n            }\n            if(flag == 0)break;\n            unite(a,b);\n            ans += distmin;\n        }\n       // ans += 0.00001;\n        //cout << round(ans*1000)/1000  << endl;\n        printf(\"%.3f\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n *\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for(int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef vector<vll> vvll;\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n  return sqrt(SQ(x1 - x2) + SQ(y1 - y2) + SQ(z1 - z2));\n}\n\nstruct Station {\n  double x, y, z, r;\n};\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<Station> stations;\n    REP(i, n){\n      Station st;\n      cin >> st.x >> st.y >> st.z >> st.r;\n      stations.push_back(st);\n    }\n\n    double ans = 0;\n    set<int> cell;\n\n    multimap<double, int> corridor;\n    corridor.insert({0, 0});\n\n    while (cell.size() < n) {\n      double len = corridor.begin()->first;\n      int c = corridor.begin()->second;\n      corridor.erase(corridor.begin());\n\n      if (!cell.insert(c).second) continue;\n      ans += len;\n\n      for (int i = 0; i < n; i++) {\n        if (cell.find(i) == cell.end()) {\n          Station st = stations[i];\n          Station stc = stations[c];\n          corridor.insert({max(0.0, dist(st.x, st.y, st.z, stc.x, stc.y, stc.z) - st.r - stc.r), i});\n        }\n      }\n    }\n\n    printf(\"%.3f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define MYDEBUG\n#include <bits/stdc++.h>\n#ifdef MYDEBUG\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define debug(x)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define all(x) x.begin(), x.end()\n#define rep(i,from,to) for(int i=from; i<to; ++i)\n#define REP(i,from,to) for(int i=from; i<=to; ++i)\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::vector;\nusing std::ostream;\nusing std::swap;\nusing std::max;\nusing std::min;\nusing std::queue;\ntypedef struct edge edge;\ntypedef struct unionfind unionfind;\ntypedef struct Graph Graph;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  out << \"[\";\n  size_t last = v.size() - 1;\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i];\n    if (i != last)\n      out << \",\";\n  }\n  out << \"]\";\n  return out;\n}\n\nstruct unionfind{\n\tvector<int> par;\n\tvector<int> rank;\n\tunionfind(int n) {\n\t\tpar = vector<int>(n);\n\t\trank = vector<int>(n);\n\t\trep(i,0,n){//0????????????\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}\n\t\treturn par[x] = find(par[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tvoid unite(int x, int y){//rank[x] > rank[y]?????????\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){\n\t\t\treturn;\n\t\t}\n\t\tif(rank[x] < rank[y]){\n\t\t\tswap(x,y);\n\t\t}\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t\trank[y] = 0;\n\t}\n\t\n\tint size(int x){\n\t\treturn rank[x];\n\t}\n};\n\nstruct edge{\n\tint from, to;\n\tdouble cost;\n\tedge(int from, int to, double cost){\n\t\tthis->from = from;\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t}\n\t\n\tedge(){\n\t\t*this = edge(-1,-1,-1);\n\t}\n\t\n\tbool operator<(const edge& e) const{\n\t\treturn cost < e.cost;\n\t}\n};\n\nclass Graph{\n\tpublic:\n\tstatic double kruskal(vector<edge>& es, int n){\n\t\tsort(all(es));\n\t\tdouble min_cost = 0;\n\t\tunionfind uf(n);\n\t\trep(i,0,es.size()){\n\t\t\tedge &e = es[i];\n\t\t\tif(!uf.same(e.from, e.to)){\n\t\t\t\tmin_cost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\t\t}\n\t\treturn min_cost;\n\t}\n};\n\nstruct sphere{\n\tdouble x,y,z,r;\n\tsphere(double x, double y, double z, double r){\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->z = z;\n\t\tthis->r = r;\n\t}\n\tdouble dist(sphere& s){\n\t\treturn std::sqrt((x-s.x)*(x-s.x) + (y-s.y)*(y-s.y) + (z-s.z)*(z-s.z));\n\t}\n\tdouble corridor(sphere& s){\n\t\tdouble d = dist(s) - r - s.r;\n\t\tif(d<=eps){\n\t\t\treturn 0.0;\n\t\t}else{\n\t\t\treturn d;\n\t\t}\n\t}\n};\n\ntypedef struct sphere sphere;\nconst int maxn = 100100;\nvector<edge> g;\nvector<sphere> sp;\nint n, m;\n\nvoid solve(){\n\tifcin(\"/storage/emulated/0/AppProjects/AtCoder/jni/in.txt\");\n\twhile(cin>>n, n){\n\t\tg = vector<edge>();\n\t\tsp = vector<sphere>();\n\t\trep(m,0,n){\n\t\t\tdouble x,y,z,r;\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tsp.push_back(sphere(x,y,z,r));\n\t\t\trep(i,0,sp.size()){\n\t\t\t\tsphere& s1 = sp[i];\n\t\t\t\trep(k,0,sp.size()){\n\t\t\t\t\tsphere& s2 = sp[k];\n\t\t\t\t\tdouble cost = s1.corridor(s2);\n\t\t\t\t\tg.push_back(edge(i, k, cost));\n\t\t\t\t\tg.push_back(edge(k, i, cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",Graph::kruskal(g, n));\n\t}\n\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<0)x=0;\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<fixed<<setprecision(3)<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;cin>>a;return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ninline double sq(double x){ return x*x; }\ntypedef pair<double, int> P;\nint main(){\n  int n;\n  while(cin>>n,n){\n    double x[100],y[100],z[100],r[100];\n    REP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    double d[100][100];\n    REP(i,n)REP(j,n){\n      d[i][j] = sqrt(sq(x[i]-x[j]) + sq(y[i]-y[j]) + sq(z[i]-z[j])) - (r[i] + r[j]);\n      d[i][j] = max(0.0, d[i][j]);\n    }\n    priority_queue<P> que;\n    que.push(P(0,0));\n    bool used[100] = {};\n    double ans = 0;\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      p.first *= -1;\n      if(used[p.second]) continue;\n      used[p.second] = true;\n      ans += p.first;\n      REP(i,n)if(!used[i]){\n        que.push(P(-d[p.second][i], i));\n      }\n    }\n    printf(\"%.3lf\\n\",ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nstruct E {\n\tint from, to;\n\tdouble cost;\n\tE(int a, int b, double c) {\n\t\tfrom = a; to = b; cost = c;\n\t}\n\tE();\n\tbool operator < (E b) {\n\t\treturn this->cost < b.cost;\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tvector<E> v;\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tv.push_back(E(i, j, max(double(0), sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j])) - r[i] - r[j])));\n\t\t\t}\n\t\t}\n\t\tsort(ALL(v));\n\t\tUnionFind uf(n);\n\t\tdouble ans = 0;\n\t\tREP(i, v.size()) {\n\t\t\tif (!uf.same(v[i].from, v[i].to)) {\n\t\t\t\tuf.unite(v[i].from, v[i].to);\n\t\t\t\tans += v[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(12)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<double, P> E;\n\nstruct UnionFind\n{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint n;\ndouble x[105], y[105], z[105], r[105];\nvector<E> vec;\nUnionFind uf(105);\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t\n\t\tvec.clear();\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tdouble dist = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j])) - (r[i]+r[j]);\n\t\t\t\tvec.push_back(E(max(0.0, dist), P(i, j)));\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\tuf.init();\n\t\tdouble ans = 0, w; llint u, v;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tw = vec[i].first, u = vec[i].second.first, v = vec[i].second.second;\n\t\t\tif(uf.same(u, v)) continue;\n\t\t\tuf.unite(u, v);\n\t\t\tans += w;\n\t\t}\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\ndouble EPS = 1e-9;\n\nint n;\ndouble x[110], y[110], z[110], r[110];\n\ndouble pow2(double x) { return x * x; }\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n\treturn sqrt( pow2(x1 - x2) + pow2(y1 - y2) + pow2(z1 - z2) );\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) {}\n\t\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\t\n\tbool sameSet(int x, int y) { return root(x) == root(y); }\n\t\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\t\n\tint size(int x) { return -data[root(x)]; }\n};\n\nstruct Edge {\n\tint f, t; double c;\n\tEdge(int _f, int _t, double _c) : f(_f), t(_t), c(_c) {}\n};\nbool operator < (const Edge& a, const Edge& b) { return a.c + EPS < b.c; }\n\nvoid solve() {\n\tvector<Edge> edges;\n\t\n\tfor_(i,0,n) for_(j,i + 1,n) {\n\t\tdouble d = dist(x[i], y[i], z[i], x[j], y[j], z[j]);\n\t\tedges.push_back( Edge(i, j, max(0.0, d - r[i] - r[j])) );\n\t}\n\t\n\tsort(allof(edges));\n\t\n\tUnionFind uf(n);\n\tdouble ans = 0.0;\n\tint e_size = (int)edges.size();\n\t\n\tfor_(i,0,e_size) {\n\t\tEdge e = edges[i];\n\t\tif (!uf.sameSet(e.f, e.t)) {\n\t\t\tuf.unionSet(e.f, e.t);\n\t\t\tans += e.c;\n\t\t}\n\t}\n\t\n\tprintf(\"%.3lf\\n\", ans);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor_(i,0,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cstdio>\nusing namespace std;\n\n#define WHITE 0\n#define EPS 1e-10\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 1000\n#define INF 999999999.99\n\nlong double x[MAX_N][MAX_N];\nlong double MIN[MAX_N], color[MAX_N];\nlong double X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nlong double b, sum, sum_min;\nint n, c, a;\n\nvoid prim() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tMIN[j] = INF;\n\t\t\tcolor[j] = WHITE;\n\t\t}\n\t\tb = INF;\n\t\ta = n;\n\t\tcolor[i] = GRAY;\n\t\tMIN[i] = 0;\n\t\twhile (a != 0) {\n\t\t\tb = INF;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor[c] = BLACK;\n\t\t\ta -= 1;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (color[k] != BLACK && x[c][k] >= -EPS) {\n\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum += MIN[j];\n\t\t}\n\t\tsum_min = min(sum_min, sum);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tsum_min = INF;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tX[i] = 0; Y[i] = 0; Z[i] = 0;\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = -INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tlong double X1 = (X[i] - X[j])*(X[i] - X[j]);\n\t\t\t\tlong double Y1 = (Y[i] - Y[j])*(Y[i] - Y[j]);\n\t\t\t\tlong double Z1 = (Z[i] - Z[j])*(Z[i] - Z[j]);\n\t\t\t\tlong double dist = sqrtl(X1 + Y1 + Z1);\n\t\t\t\tlong double dist2 = dist - R[i] - R[j];\n\t\t\t\tx[i][j] = max(0.0l, dist2);\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tsum_min *= 10000;\n\t\tsum_min += 5;\n\t\tsum_min /= 10;\n\t\tint RES = sum_min;\n\t\tprintf(\"%d.%03d\\n\", RES / 1000, RES % 1000);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\n//int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint par[10000];\nint ran[10000];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tran[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\nvoid unit(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return ;\n\tif(ran[x]<ran[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(ran[x]==ran[y])ran[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n};\n\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost<e2.cost;\n}\n\n\nedge es[10000];\nint V,E;\n\ndouble kruskal(){\n\tsort(es,es+E,comp);\n\tinit(V);\n\tdouble res=0.0;\n\tfor(int i=0;i<E;i++){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunit(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\ndouble x[1000],y[1000],z[1000],r[1000];\nint main(){\n\twhile(1){\n\t\tcin>>V;\n\t\tif(V==0)break;\n\t\tE=V*(V-1)/2;\n\t\tREP(i,V){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tint cc=0;\n\t\tfor(int i=0;i<V-1;i++){\n\t\t\tfor(int j=i+1;j<V;j++){\n\t\t\t\tdouble t=sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])+(z[j]-z[i])*(z[j]-z[i]))-r[i]-r[j];\n\t\t\t\tif(t<=0)t=0.0;\n\t\t\t\tes[cc]=edge{i,j,t};\n\t\t\t\tcc++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",kruskal());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 101;\nbool used[MAX];\n\nstruct data{double x,y,z,r;};\nstruct State{\n  data d;\n  double t;\n  int n;\n  State(){}\n  State(data d, double t, int n):d(d),t(t),n(n){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\n\nint N;\nvector<data> V;\n\nvoid init(){\n  V.clear();\n  V.resize(N);\n  fill(used,used+MAX,false);\n}\n\nvoid input(){\n  for(int i = 0; i < N; i++)\n    cin >> V[i].x >> V[i].y >> V[i].z >> V[i].r;\n}\n\n\ndouble getDis(data d1, data d2){\n  return sqrt(pow(d1.x-d2.x,2.0)+pow(d1.y-d2.y,2.0)+pow(d1.z-d2.z,2.0));\n}\nvoid solve(){\n  priority_queue<State> Q;\n  Q.push(State(V[0],0,0));\n  \n  double ans = 0;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    if(used[now.n]) continue;\n    used[now.n] = true;\n  \n    ans += now.t;\n    \n    for(int i = 0; i < N; i++){\n      double dis = max(getDis(now.d,V[i])-now.d.r-V[i].r,0.0);\n      if(!used[i]) Q.push(State(V[i],dis,i));\n    }\n  }\n  printf(\"%.3f\\n\",ans);\n}\n\nint main(){\n  while(cin >> N && N){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing vvd = std::vector<vd>;\n\n\tdouble square(double x) { return x * x; }\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tvvd edge(n, vd(n));\n\t\tstd::vector<double> x(n), y(n), z(n), r(n);\n\t\tfor (int i{}; i < n; i++)\n\t\t\tscanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n\t\tfor (int i{}; i < n; i++)\n\t\t{\n\t\t\tfor (int j{}; j < n; j++)\n\t\t\t{\n\t\t\t\tdouble distance{sqrt(square(x[i] - x[j]) + square(y[i] - y[j]) + square(z[i] - z[j]))};\n\t\t\t\tedge[i][j] = std::max(0.0, distance - r[i] - r[j]);\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<bool> used(n);\n\t\tused[0] = true;\n\t\tstd::vector<double> distance(n);\n\t\tdistance = edge[0];\n\t\tdouble ans{};\n\t\tfor (int size{1}; size < n; size++)\n\t\t{\n\t\t\tint min_i{};\n\t\t\tdouble min{1e9};\n\t\t\tfor (int i{}; i < n; i++)\n\t\t\t\tif (!used[i] && distance[i] < min)\n\t\t\t\t{\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin = distance[i];\n\t\t\t\t}\n\n\t\t\tans += min;\n\t\t\tused[min_i] = true;\n\t\t\tfor (int i{}; i < n; i++)\n\t\t\t\tdistance[i] = std::min(distance[i], edge[min_i][i]);\n\t\t}\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint n;\ndouble x[101], y[101], z[101], r[101], res;\nstruct Edge { int u, v; double cost; } tmp;\nvector<Edge> edge;\n\nbool comp(const Edge &e1, const Edge &e2)\n{\n    return e1.cost < e2.cost;\n}\n\ndouble sq(double x) { return x * x; }\ndouble dis(int i, int j)\n{\n    return max(0.0, sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j])) - r[i] - r[j]);\n}\n\nclass UnionFind\n{\nprivate:\n\tint par[101];\n\tint rank[101];\n\npublic:\n\tvoid Init(int n)\n\t{\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tpar[i] = i, rank[i] = 0;\n\t}\n\tint Find(int x)\n\t{\n\t\tif(par[x] == x) return x;\n\t\telse return Find(par[x]);\n\t}\n\tvoid Unite(int x, int y)\n\t{\n\t\tx = Find(x); y = Find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\telse par[y] = x;\n\t\tif(rank[x] == rank[y]) ++rank[x];\n\t}\n\tbool Same(int x, int y)\n\t{\n\t\treturn Find(x) == Find(y);\n\t}\n} uft;\n\nint main()\n{\n    while(cin >> n && n)\n    {\n\t\tres = 0.0;\n\t\tuft.Init(n);\n        edge.clear();\n        for(int i = 0; i < n; ++i)\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        for(int i = 0; i < n; ++i)\n        {\n            for(int j = i + 1; j < n; ++j)\n            {\n                tmp.u = i, tmp.v = j;\n                tmp.cost = dis(i, j);\n                edge.push_back(tmp);\n            }\n        }\n\t\tsort(edge.begin(), edge.end(), comp);\n\t\tfor(int i = 0, c = 0; c < n - 1; ++i)\n\t\t{\n\t\t\ttmp = edge[i];\n\t\t\tif(!uft.Same(tmp.u, tmp.v))\n\t\t\t{\n\t\t\t\tuft.Unite(tmp.u, tmp.v);\n\t\t\t\tres += tmp.cost;\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\n\nconst double INF = 1e12;\nconst int MAX = 100;\nint N;\n\nstruct S{\n  double x,y,z,r;\n  S(double _x,double _y,double _z,double _r){\n    x = _x; y = _y; z = _z; r = _r;\n  }\n};\n\ntypedef pair<double,int>P;\n\nvector<S>vec;\ndouble G[MAX][MAX];\nbool vis[MAX];\n\nvoid input(){\n  for(int i = 0 ; i < N ; i++){\n    double x,y,z,r;\n    cin >> x >> y >> z >> r;\n    vec.push_back(S(x,y,z,r));\n  }\n}\n\ndouble getDist(S s1,S s2){\n  double x,y,z,d;\n  x = s1.x - s2.x;\n  y = s1.y - s2.y;\n  z = s1.z - s2.z;\n  d = sqrt(x*x + y*y + z*z);\n  return max(0.0,d - (s1.r + s2.r));\n}\n\nvoid make(){\n  for(int i = 0 ; i < N ; i++){\n    for(int j = i+1 ; j < N ; j++){\n      G[i][j] = G[j][i] = getDist(vec[i],vec[j]);\n    }\n  }\n}\n\ndouble prim(){\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(0.0,0));\n  double res = 0.0;\n  while(que.size()){\n    P p = que.top(); que.pop();\n    double cost = p.first;\n    int now = p.second;\n    if(vis[now])continue;\n    vis[now] = true;\n    res += cost;\n    for(int i = 0 ; i < N ; i++){\n      if(G[now][i] < 0)continue;\n      if(vis[i])continue;\n      que.push(P(G[now][i],i));\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  vec.clear();\n  for(int i = 0 ; i < MAX;  i++){\n    vis[i] = false;\n    for(int j = 0 ; j < MAX; j++){\n      G[i][j] = -INF;\n    }\n  }\n}\n\nvoid solve(){\n  init();\n  input();\n  make();\n  printf(\"%.3f\\n\",prim());\n}\n\nint main(){\n  while(cin >> N,N){\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint ps[100], rs[100];\ndouble x[100], y[100], z[100], r[100];\n\ninline double sq(double x) {\n  return x * x;\n}\n\nint find(int x) {\n  if (ps[x] == x)\n    return x;\n  return ps[x] = find(ps[x]);\n}\n\nbool merge(int x, int y) {\n  int xr = find(x), yr = find(y);\n  if (xr == yr)\n    return false;\n  if (rs[xr] < rs[yr])\n    ps[xr] = yr;\n  else if (rs[xr] > rs[yr])\n    ps[yr] = xr;\n  else {\n    ps[yr] = xr;\n    rs[xr]++;\n  }\n  return true;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    scanf(\"%d\", &n);\n    if (!n) return 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n      ps[i] = i;\n      rs[i] = 0;\n    }\n    vector<pair<double, pair<int, int> > > es;\n    for (int i = 1; i < n; i++)\n      for (int j = 0; j < i; j++)\n        es.push_back(make_pair(max(sqrt(sq(x[j]-x[i])+sq(y[j]-y[i])+sq(z[j]-z[i]))-(r[i]+r[j]), 0.0), make_pair(i, j)));\n    sort(es.begin(), es.end());\n    double cost = 0.0;\n    for (int i = 0, j = 0; j < n-1 && i < es.size(); i++)\n      if (merge(es[i].second.first, es[i].second.second)) {\n        j++;\n        cost += es[i].first;\n      }\n    printf(\"%.3f\\n\", cost);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nusing vd=vector<double>;\nusing data=tuple<double,int,int>;\n\ndouble hypot3(double x,double y,double z){\n\treturn sqrt(x*x+y*y+z*z);\n}\ndouble dist(vd a, vd b){\n\tauto d=hypot3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);\n\treturn max(d-a[3]-b[3],0.0);\n}\n\nstruct UnionFind{\n\tvi p;\n\tUnionFind(int s):p(s,-1){}\n\tvoid unite(int a,int b){\n\t\ta=root(a);b=root(b);\n\t\tif(a!=b){\n\t\t\tif(p[b]<p[a])swap(a,b);\n\t\t\tp[a]+=p[b];p[b]=a;\n\t\t}\n\t}\n\tbool same(int a,int b){return root(a)==root(b);}\n\tint root(int a){return p[a]<0?a:p[a]=root(p[a]);}\n};\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vd> cell(n,vd(4));\n\t\tvector<data> edge;\n\t\trep(i,n) {\n\t\t\trep(j,4) cin>>cell[i][j];\n\t\t\trep(j,i) edge.emplace_back(dist(cell[i],cell[j]),i,j);\n\t\t}\n\t\tsort(all(edge),[](data a,data b){return get<0>(a)<get<0>(b);});\n\n\t\tUnionFind uf(n);\n\t\tdouble ans=0;\n\t\tfor(auto e:edge){\n\t\t\tdouble d; int a,b;\n\t\t\ttie(d,a,b)=e;\n\t\t\tif(!uf.same(a,b)){\n\t\t\t\tans+=d;\n\t\t\t\tuf.unite(a,b);\n\t\t\t}\n\t\t}\n\t\tcout.precision(3);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nint n;\n\nstruct UnionFind {\n    vector<int> par, cnt;\n\n    UnionFind(int n): par(n, -1), cnt(n) {}\n    int find(int x) {\n        if (par[x]<0) return x;\n        return par[x] = find(par[x]);\n    }\n    bool same(int i, int j) {\n        // iとjが同じグループかどうかを判別する\n        return find(i) == find(j);\n    }\n    int size(int x) {\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y) {\n        // iとjを併合する\n        x = find(x);\n        y = find(y);\n        bool ok = (-par[x]>cnt[x] || -par[y]>cnt[y]);\n        if (x == y) {\n            cnt[x]++;\n        } else if (par[x] > par[y]) {\n            par[y] += par[x];\n            par[x] = y;\n            cnt[y] += cnt[x]+1;\n        } else {\n            par[x] += par[y];\n            par[y] = x;\n            cnt[x] += cnt[y]+1;\n        }\n        return ok;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        V<double> x(n), y(n), z(n), r(n);\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        priority_queue< P<double, P<int, int> > > pq;\n        UnionFind uni(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]) <= (r[i] + r[j]) * (r[i] + r[j])) {\n                    uni.unite(i, j);\n                } else {\n                    pq.push(make_pair(-(sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j])) - (r[i] + r[j])), make_pair(i, j)));\n                }\n            }\n        }\n\n        double ans = 0;\n        while (!pq.empty()) {\n            P<double, P<int, int> > q = pq.top(); pq.pop();\n            if (!uni.same(q.second.first, q.second.second)) {\n                uni.unite(q.second.first, q.second.second);\n                ans -= q.first;\n            }\n        }\n        cout << fixed << setprecision(3) << ans << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef double Weight;\nconst Weight INF = 1e9;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int f, int t, Weight c) :\n        src(f), dst(t), weight(c) {}\n};\nbool operator<(const Edge &a, const Edge &b) {\n    return a.weight != b.weight ? a.weight > b.weight :\n        a.src != b.src ? a.src < b.src : a.dst < b.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nWeight Prim(const Graph &g, int r = 0) {\n    int n = g.size();\n    Edges T;\n    Weight total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<Edge> que;\n    que.push(Edge(-1, r, 0));\n\n    while (!que.empty()) {\n        Edge e = que.top();  que.pop();\n        if (visited[e.dst])\n            continue;\n        T.push_back(e);\n        total += e.weight;\n        visited[e.dst] = true;\n        for (auto f = g[e.dst].begin(); f != g[e.dst].end(); ++f)\n            if (!visited[f->dst])\n                que.push(*f);\n    }\n\n    return total;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(6) << setiosflags(ios::fixed); // printf(\"%.4f\", x);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        Graph g(n);\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                double d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])\n                    + (z[i] - z[j]) * (z[i] - z[j]);\n\n                if (d <= (r[i] + r[j]) * (r[i] + r[j]))\n                    d = 0.0;\n                else\n                    d = sqrt(d) - r[i] - r[j];\n\n                g[i].push_back(Edge(i, j, d));\n                g[j].push_back(Edge(j, i, d));\n            }\n\n        cout << Prim(g) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nconst int INF = numeric_limits<int>::max() / 2;\n\nstruct cell {\n\tdouble x, y, z, r;\n};\n\ndouble calc(cell p, cell q) {\n\tdouble tmp = sqrt((p.x - q.x)*(p.x - q.x) + (p.y - q.y)* (p.y - q.y) + (p.z - q.z)*(p.z - q.z));\n\tif (tmp <= p.r + q.r) return 0;\n\telse return (-p.r - q.r + tmp);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<cell> cells;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcell c;\n\t\t\tcin >> c.x >> c.y >> c.z >> c.r;\n\t\t\tcells.push_back(c);\n\t\t}\n\t\tvector<vector<double> > dis(n, vector<double>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) dis[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tdis[i][j] = calc(cells[i], cells[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> used(n, false);\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tdouble res = 0;\n\t\tque.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (used[p.second]) continue;\n\t\t\tused[p.second] = true;\n\t\t\tres += p.first;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!used[i]) {\n\t\t\t\t\tque.push(P(dis[p.second][i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed<<setprecision(3)<<res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG(C) cerr << #C << \" = \" << C << endl\n\nusing namespace std;\n\nconst int MAX = 111;\ndouble x[MAX], y[MAX], z[MAX], r[MAX];\nbool vis[MAX];\n\ninline double dist(int p, int q) {\n  return max<double>(0.0, sqrt((x[p] - x[q]) * (x[p] - x[q]) + (y[p] - y[q]) * (y[p] - y[q]) + (z[p] - z[q]) * (z[p] - z[q])) - r[p] - r[q]);\n}\n\nvoid solve(int n) {\n  memset(vis, false, sizeof(vis));\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", x + i, y + i, z + i, r + i);\n  }\n  priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n  pq.push(make_pair(0, 0));\n  double ans = 0;\n  while (!pq.empty()) {\n    auto e = pq.top();\n    pq.pop();\n    if (vis[e.second]) {\n      continue;\n    }\n    vis[e.second] = true;\n    ans += e.first;\n    for (int i = 0; i < n; i++) {\n      if (i != e.second && !vis[i]) {\n        pq.push(make_pair(dist(e.second, i), i));\n      }\n    }\n  }\n  printf(\"%.3lf\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    int n;\n    scanf(\"%d\", &n);\n    if (n == 0) {\n      break;\n    }\n    solve(n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const float EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ndouble path[100][100];\ndouble mincost[100];\nbool used[100];\n\nclass Data{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n\tData(double _x,double _y,double _z,double _r){\n\t\tx = _x;\n\t\ty = _y;\n\t\tz = _z;\n\t\tr = _r;\n\t}\n};\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tvector<Data> nodes;\n\n\t\tfill((bool*)used,(bool*)used + 100,false);\n\t\tfill((double*)mincost,(double*)mincost + 100,numeric_limits<double>::max());\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y,z,r;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&x,&y,&z,&r);\n\t\t\tnodes.push_back(Data(x,y,z,r));\n\t\t}\n\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble diff = sqrt((nodes[i].x-nodes[j].x) * (nodes[i].x-nodes[j].x)\n\t\t\t\t\t+ (nodes[i].y-nodes[j].y) * (nodes[i].y-nodes[j].y)\n\t\t\t\t\t+ (nodes[i].z-nodes[j].z) * (nodes[i].z-nodes[j].z));\n\t\t\t\tdouble cost = (diff - (nodes[i].r + nodes[j].r) >= 0 ? diff - (nodes[i].r + nodes[j].r) : 0);\n\t\t\t\tpath[i][j] = path[j][i] = cost;\n\t\t\t}\n\t\t}\n\n\n\t\tmincost[0]=0;\n\n\t\tdouble res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v])){\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\tres+=mincost[v];\n\t\t\t\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = min(mincost[u],path[v][u]);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tprintf(\"%.3lf\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\ndouble dd(double a) {return a*a;}\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    vector<double> x,y,z,r;\n    x.resize(n);\n    y.resize(n);\n    z.resize(n);\n    r.resize(n);\n    REP(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    vector<vector<double> > dist;\n    dist.resize(n);\n    REP(i,n) dist[i].resize(n);\n    REP(i,n) REP(j,n) dist[i][j]=max(0.0,sqrt(dd(x[i]-x[j])+dd(y[i]-y[j])+dd(z[i]-z[j]))-r[i]-r[j]);\n    priority_queue<pair<double,int> > prim;\n    // negc,next\n    prim.push(make_pair(0.0,0));\n    set<int> already;\n    double answer=0.0;\n    while(!prim.empty()){\n      double negc=prim.top().first;\n      int tmp=prim.top().second;\n      prim.pop();\n      if(!already.insert(tmp).second) continue;\n      answer-=negc;\n      REP(j,n) prim.push(make_pair(-dist[tmp][j],j));\n    }\n    cout << fixed << setprecision(3) << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ndouble dist(double x1,double y1,double z1,double x2,double y2,double z2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n}\n\nconst double INF=(double)(1<<30);\ndouble G[100][100];\ndouble mindist[100];\nbool used[100];\ndouble x[100],y[100],z[100],r[100];\n\nint main(){\n    int n, i, j;\n    while(cin>>n,n){\n        for(i=0;i<n;i++) cin>>x[i]>>y[i]>>z[i]>>r[i];\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n                double d=dist(x[i],y[i],z[i],x[j],y[j],z[j]);\n                G[i][j]=d-r[i]-r[j]>=0?d-r[i]-r[j]:0.0;\n            }\n        }\n        double ans=0.0;\n        for(i=0;i<n;i++){\n            mindist[i]=G[0][i];\n            used[i]=false;\n        }\n        used[0]=true;\n        for(i=0;i<n;i++){\n            int id=-1;\n            double m=INF;\n            for(j=0;j<n;j++){\n                if(used[j]) continue;\n                if(mindist[j]<m){\n                    m=mindist[j];id=j;\n                }\n            }\n            if(id==-1)break;\n            used[id]=true;\n            ans+=m;\n            for(j=0;j<n;j++)\n                mindist[j]=min(mindist[j],G[id][j]);\n        }\n        printf(\"%.3lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble x[101],y[101],z[101],r[101];\nconst int MAX_N=101;\nstruct edge{\n    int src,dst;\n    double cost;\n    edge(int src,int dst,double cost):\n    src(src),dst(dst),cost(cost){}\n    };\nbool operator < (const edge &m,const edge &f){\n    return m.cost!=f.cost?m.cost<f.cost:\n    m.src!=f.src?m.src<f.src:m.dst<f.dst;\n}\nstruct UnionFind{\n    int par[MAX_N],rank[MAX_N]; \n    void init(int n){\n        for (int i=0;i<n;i++){par[i]=i;rank[i]=0;}\n    } \n    int find(int x){\n        if (x==par[x]) return (x);\n        return (par[x]=find(par[x]));\n    }\n    void unite(int x, int y){\n        x=find(x);y=find(y);       \n        if(x==y) return;\n        if(rank[x]<rank[y]){par[x]=y;}\n        else{par[y]=x;if(rank[x]==rank[y]) rank[x]++;}\n    } \n    bool same(int x, int y){return (find(x) == find(y));} \n};\nvector<edge> ve;\nint n;\ndouble kruskal(){\n    sort(ve.begin(),ve.end());\n    UnionFind uf;\n    uf.init(n);\n    double res=0;\n    rep(i,ve.size()){\n        edge m=ve[i];\n        if(!uf.same(m.src,m.dst)){\n            uf.unite(m.src,m.dst);\n            res +=m.cost;\n        }\n    }\n    return res;\n}\nint main(){\n    while(cin>>n,n){\n        ve.clear();\n        rep(i,n) cin>>x[i]>>y[i]>>z[i]>>r[i];\n        rep(i,n)FOR(j,i+1,n){\n            double tx=x[i]-x[j],ty=y[i]-y[j],tz=z[i]-z[j];\n            double tr=r[i]+r[j];\n            ve.pb(edge(i,j,max(0.0,sqrt(tx*tx+ty*ty+tz*tz)-tr)));\n        }\n        cout<<fixed<<setprecision(3)<<kruskal()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll MOD = 1e9+7;\n\nclass UF\n{\n  public:\n  int s;//木の頂点数\n  vector<int> par;//親\n  vector<int> rank;//木の深さ\n  vector<int> size;//木の直径\n  //コンストラクタ\n  //n要素で初期化\n  UF(int n)\n  {\n    s=n;\n    par.resize(s);\n    rank.resize(s);\n    size.resize(s);\n    for(int i=0;i<n;i++)\n    {\n      par[i]=i;\n      rank[i]=0;\n      size[i]=1;\n    }\n  }\n  //木の根を求める\n  int find(int x)\n  {\n    if(par[x]==x)\n      return x;\n    else\n      return par[x]=find(par[x]);\n  }\n  //xとyの属する集合を併合\n  void unite(int x,int y)\n  {\n    x=find(x);\n    y=find(y);\n    if(x==y)\n      return;\n  \n    if(rank[x]<rank[y])\n    {\n      par[x]=y;\n      size[y]+=size[x];\n    }else{\n      par[y]=x;\n      size[x]+=size[y];\n      if(rank[x]==rank[y])\n        rank[x]++;\n    }\n  }\n  //xとyが同じ集合に属するか否か\n  bool same(int x,int y)\n  {\n    return find(x)==find(y);\n  }\n  //xが属する集合の大きさを求める\n  int getsize(int x)\n  {\n    return size[par[x]];\n  }\n};\ndouble x[100];\ndouble y[100];\ndouble z[100];\ndouble r[100];\ndouble dist[100][100];\npriority_queue<pair<double,P>,vector<pair<double,P>>,greater<pair<double,P>>> q;\n//中心間の距離の2乗を求める\ndouble jou2(int i,int j)\n{\n\treturn (x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])+(z[j]-z[i])*(z[j]-z[i]);\n}\nint main()\n{\n\tint n;\n\tdouble ans;\n  while(1)\n\t{\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tUF u=UF(n);\n\t\tq=priority_queue<pair<double,P>,vector<pair<double,P>>,greater<pair<double,P>>>();\n\t\tans=0.0;\n\t\tfill(dist[0],dist[100],1e14-1);\n\t\t//全点間の距離を求め距離0のものをuniteする\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t{\n\t\t\t\tdist[i][j]=max(0.0,sqrt(jou2(i,j))-r[i]-r[j]);\n\t\t\t\tif(dist[i][j]==0.0)\n\t\t\t\t\tu.unite(i,j);\n\t\t\t\telse\n\t\t\t\t\tq.push(make_pair(dist[i][j],P(i,j)));\n\t\t\t}\n\t\t}\n\t\t//距離の短いものからuniteしていく\n\t\twhile(u.getsize(0)!=n)\n\t\t{\n\t\t\tif(q.empty())\n\t\t\t\tbreak;\n\t\t\tauto p=q.top();q.pop();\n\t\t\tif(!u.same(p.second.first,p.second.second))\n\t\t\t{\n\t\t\t\tu.unite(p.second.first,p.second.second);\n\t\t\t\tans+=p.first;\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(3)<<ans<<endl;\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100],sum,mn,maxd=99999999.9;\nint n,m,mx=(1<<20),a,b,c,t,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt((x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) + (z[i]-z[j]) * (z[i]-z[j]));\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    for(int i=0;i<n;i++) {\n      cin>>x[i]; cin>>y[i]; cin>>z[i]; cin>>r[i];\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tmap[i][j]=maxd;\n      }\n      p[i]=0;\n      d[i]=maxd;\n      visited[i]=0;\n    }\n    \n    for(int i=0; i<n; i++) {\n      for(int j=0; j<n; j++) {\n\tif(i==j) continue;\n\tmap[i][j] = compute(i, j);\n\tmap[i][j]-=(r[i]+r[j]);\n\tif(map[i][j]<0)map[i][j]=0;\n      }\n    }\n\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\t//\tcout<<map[i][j]<<endl;\n      }\n    }\n    \n    sumcor=0.0;\n    d[0]=0.0;\n    while(1){\n      mn=maxd;\n      for(int i=0;i<n;i++){\n\tif(d[i]<mn&&visited[i]==0){\n\t  mn=d[i];\n\t  t=i;\n\t}\n      }\n      if(mn==maxd)break;\n      visited[t]=1;\n      for(int v=0;v<n;v++){\n\tif(map[t][v]<d[v]&&visited[v]==0){\n\t  d[v]=map[t][v];\n\t  p[v]=t;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)if(map[i][p[i]]!=maxd)sumcor+=map[i][p[i]];\n    printf(\"%4.3f\\n\",sumcor);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j);\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nstruct Edge{\n  int to;\n  double cost;\n\n  Edge(int t, double c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\n\ndouble prim(vector< vector<Edge> >& edges){\n  const int V = edges.size();\n  double res = 0;\n  vector<bool> visited(V, false);\n  priority_queue<Edge, vector<Edge>, greater<Edge> > pq;\n\n  pq.push(Edge(0,0));\n  for(int i=0;i<V;++i){\n\tEdge edge = pq.top(); pq.pop();\n\tint v = edge.to;\n\tif(visited[v]){\n\t  --i;\n\t  continue;\n\t}\n\tvisited[v] = true;\n\tres += edge.cost;\n\n\tfor(auto& e:edges[v]){\n\t  pq.push(e);\n\t}\n  }\n\n  return res;\n}\n\ndouble x[101], y[101], z[101], r[101];\ndouble dist(int i, int j){\n  double dx = x[i]-x[j], dy = y[i]-y[j], dz=z[i]-z[j];\n  return dx*dx+dy*dy+dz*dz;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N && N){\n\tREP(i,N) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\tUnionFind uf(N);\n\tREP(i,N)REP(j,N)\n\t  if(dist(i,j)<=(r[i]+r[j])*(r[i]+r[j]))\n\t\tuf.unite(i,j);\n\t\n\tdouble e[101][101];\n\tfill((double*)e, (double*)e+101*101, 10000000);\n\tset<int> root;\n\tREP(i,N) root.insert(uf.find(i));\n\tVI node(root.begin(), root.end());\n\n\tREP(i,N){\n\t  e[i][i] = 0;\n\t  REP(j,N){\n\t  int ri = uf.find(i), rj = uf.find(j);\n\t  if(ri != rj)\n\t\te[ri][rj] = e[rj][ri]\n\t\t  = min(e[ri][rj], sqrt(dist(i,j)) - r[i] - r[j]);\n\t  }\n\t}\n\tvector< vector<Edge> > edge(SZ(node));\n\tREP(i,SZ(node)){\n\t  REP(j,SZ(node)){\n\t\tedge[i].PB(Edge(j, e[node[i]][node[j]]));\n\t\tedge[j].PB(Edge(i, e[node[j]][node[i]]));\n\t  }\n\t}\n\tcout << fixed << setprecision(3) << prim(edge) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <stdio.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <time.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> Pii;\ntypedef pair<int, ll> Pil;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ll, int> Pli;\n\n#define fi first\n#define se second\n#define mp make_pair\n \nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1ll << 60;\nconst double PI = 2 * asin(1);\n\nvoid yes() {printf(\"yes\\n\");}\nvoid no() {printf(\"no\\n\");}\nvoid Yes() {printf(\"Yes\\n\");}\nvoid No() {printf(\"No\\n\");}\nvoid YES() {printf(\"YES\\n\");}\nvoid NO() {printf(\"NO\\n\");}\n\nint N;\ndouble X[105], Y[105], Z[105], R[105], Dist[105][105];\nbool visited[105];\n\nint Solve(){\n  fill(visited, visited + N, false);\n  for (int i = 0; i < N; i++){\n    cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n  }\n  for (int i = 0; i < N; i++){\n    for (int j = 0; j < N; j++){\n      double now = (X[i] - X[j]) * (X[i] - X[j]);\n      now += (Y[i] - Y[j]) * (Y[i] - Y[j]);\n      now += (Z[i] - Z[j]) * (Z[i] - Z[j]);\n      now = sqrt(now);\n      Dist[i][j] = max(now - R[i] - R[j], (double)0);\n    }\n  }\n\n  double ans = 0;\n  visited[0] = true;\n  priority_queue < pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n  for (int i = 1; i < N; i++) que.push(mp(Dist[0][i], i));\n\n  while (!que.empty()){\n    pair <double, int> Q = que.top(); que.pop();\n    if (visited[Q.se]) continue;\n    ans += Q.fi;\n    visited[Q.se] = true;\n    for (int i = 0; i < N; i++){\n      if (visited[i]) continue;\n      que.push(mp(Dist[Q.se][i], i));\n    }\n  }\n  printf(\"%.3lf\\n\", ans);\n\n  return 0;\n}\n\nint main(){\n\n  while (cin >> N){\n    if (N == 0) return 0;\n    Solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;scanf(\"%lf\",&a);return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    printf(\"%.3lf\\n\",prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate<typename T>\nstruct edge {\n    int src,to;\n    T cost;\n\n    edge() = default;\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    bool operator<(const edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ndouble f(double x, double y, double z) {\n    return sqrt(x*x+y*y+z*z);\n}\n\n\nstruct UnionFind {\n    vector<int> node;\n\n    UnionFind() = default;\n    UnionFind(int x) {init(x);}\n\n    void init(int x) {\n        node.assign(x,-1);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (node[x] > node[y]) swap(x,y);\n        node[x] += node[y];\n        node[y] = x;\n        return true; \n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int root(int x) {\n        if (node[x] < 0) return x;\n        return node[x] = root(node[x]);\n    }\n\n    int size(int x) {\n        return -node[root(x)];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    while (true) {\n        int N; cin >> N;\n        if (!N) break;\n        vector<double> x(N),y(N),z(N),r(N);\n\n        vector<edge<double>> A;\n        rep(i,N) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        rep(i,N) {\n            for (int j = i+1; j < N; ++j) {\n                double d = max(0.0,f(x[i]-x[j],y[i]-y[j],z[i]-z[j]) - r[i] - r[j]);\n                A.emplace_back(i,j,d);\n            }\n        }\n\n        UnionFind uf(N);\n        sort(all(A));\n        double ans = 0;\n        for (auto &e : A) {\n            if (uf.same(e.src,e.to)) continue;\n            uf.merge(e.src,e.to);\n            ans += e.cost;\n        }\n\n        cout << fixed << setprecision(3) << ans << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <new>\n#include <sstream>\n#include <complex>\n#define BIT(nr) (1ULL << (nr))\n#define int long long\n#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t\n#define LL_HALFMAX 9223372036854775807 / 2\t\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\nusing namespace std;\n\nusing Weight = double;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n\tbool operator<(const Edge& right) const {\n\t\treturn dst < right.dst;\n\t}\n};\n\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nstruct uf_tree {\n\tstd::vector<int> parent;\n\tint __size;\n\tuf_tree(int size_) : parent(size_, -1), __size(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif ((x = find(x)) != (y = find(y))) {\n\t\t\tif (parent[y] < parent[x]) std::swap(x, y);\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\t__size--;\n\t\t}\n\t}\n\tbool is_same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }\n\tint size(int x) { return -parent[find(x)]; }\n\tint size() { return __size; }\n};\n\nclass Vector3D {\npublic:\n\tdouble x, y, z;\n\tVector3D(double x, double y, double z) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->z = z;\n\t}\n\n\tVector3D operator- (Vector3D right) {\n\t\treturn Vector3D(right.x - x, right.y - y, right.z - z);\n\t}\n\n\tdouble Length() {\n\t\treturn sqrtl(x * x + y * y + z * z);\n\t}\n};\n\nbool solve() {\n\tint n;\n\tcin >> n;\n\tif (n == 0) {\n\t\treturn false;\n\t}\n\n\tvector<Vector3D> points;\n\tvector<double> r;\n\trep(i, n) {\n\t\tdouble x, y, z, ri;\n\t\tcin >> x >> y >> z >> ri;\n\n\t\tpoints.emplace_back(x, y, z);\n\t\tr.push_back(ri);\n\t}\n\n\tauto cmp = [](const Edge& l, const Edge& r) {\n\t\treturn l.weight < r.weight;\n\t};\n\n\tvector<Edge> es;\n\n\trep(i, n) {\n\t\tREP(j, i + 1, n) {\n\t\t\tdouble cand = (points[j] - points[i]).Length() - (r[i] + r[j]);\n\t\t\tdouble cost = max(0.0L, cand);\n\t\t\tes.emplace_back(i, j, cost);\n\t\t}\n\t}\n\n\t// MST\n\tdouble ans = 0;\n\n\tuf_tree uf(n);\n\tsort(ALLOF(es), cmp);\n\n\tfor (auto e : es) {\n\t\tif (!uf.is_same(e.src, e.dst)) {\n\t\t\tuf.unite(e.src, e.dst);\n\t\t\tans += e.weight;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(3) << ans << \"\\n\";\n\n\treturn true;\n}\n\nsigned main() {\n\twhile(solve()){}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\nusing vd=vector<double>;\nusing data=tuple<double,int,int>;\n\ndouble hypot3(double x,double y,double z){\n\treturn sqrt(x*x+y*y+z*z);\n}\ndouble dist(vd a, vd b){\n\tauto d=hypot3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);\n\treturn max(d-a[3]-b[3],0.0);\n}\n\nstruct UnionFind{\n\tint n; vi par;\n\tUnionFind(int N){n=N; par.resize(n); iota(all(par),0);}\n\tint root(int a){return par[a]=par[a]==a?a:root(par[a]);}\n\tbool same(int a, int b){return root(a)==root(b);}\n\tvoid unite(int a, int b){a=root(a),b=root(b);if(a!=b) par[a]=b;}\n};\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vd> cell(n,vd(4));\n\t\tvector<data> edge;\n\t\trep(i,n) {\n\t\t\trep(j,4) cin>>cell[i][j];\n\t\t\trep(j,i) edge.emplace_back(dist(cell[i],cell[j]),i,j);\n\t\t}\n\t\tsort(all(edge),[](data a,data b){return get<0>(a)<get<0>(b);});\n\n\t\tUnionFind uf(n);\n\t\tdouble ans=0;\n\t\tfor(auto e:edge){\n\t\t\tdouble d; int a,b;\n\t\t\ttie(d,a,b)=e;\n\t\t\tif(!uf.same(a,b)){\n\t\t\t\tans+=d;\n\t\t\t\tuf.unite(a,b);\n\t\t\t}\n\t\t}\n\t\tcout.precision(10);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) { // size(x) > size(y)\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nusing weight = double;\n\nstruct edge {\n    int from, to;\n    weight cost;\n    bool operator<(edge const& rhs) const {\n        return cost < rhs.cost;\n    }\n};\n\nusing edges = std::vector<edge>;\n\nconstexpr double eps = 1e-8;\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2));\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        for(int i=0; i<n; ++i) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        edges es;\n        union_find uf(n);\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                double d = dist(x[i], y[i], z[i], x[j], y[j], z[j]);\n                if(d > r[i] + r[j] + eps) {\n                    es.push_back((edge){i, j, d - r[i] - r[j]});\n                } else {\n                    uf.unite(i, j);\n                }\n            }\n        }\n        sort(es.begin(), es.end());\n        double res = 0;\n        for(int i=0; i<es.size(); ++i) {\n            edge e = es[i];\n            if(!uf.same(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n        cout << fixed << setprecision(3) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n\nusing namespace std;\nusing ll = long long;\n\nstruct UnionFind {\n  vector<int> par;//parent\n  vector<int>nodes;\n  UnionFind(int N): par(N), nodes(N)\n  {\n    for(int i = 0; i < N; i++){\n      par[i] = i;\n      nodes[i] = 1;\n    }\n  }\n  int root(int x) {//find the root and path compression\n    if(par[x] == x) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y){\n    int rx = root(x);\n    int ry = root(y);\n    if(rx == ry) return;\n    nodes[ry] += nodes[rx];\n    par[rx] = ry;\n  }\n  bool same(int x, int y){\n    int rx = root(x);\n    int ry = root(y);\n    return rx == ry;\n  }\n};\n\nstruct node{\n  double x, y, z, r;\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n;\n  while(cin>> n && n){\n    double ans = 0;\n    vector<node> V(n);\n    for(int i = 0; i < n; i++){\n      cin >> V[i].x >> V[i].y >> V[i].z >> V[i].r;\n    }\n    vector<pair<double, pair<int, int>>> edge;\n    UnionFind U(n);\n    for(int i = 0; i < n; i++){\n      for(int j = i+1; j < n; j++){\n        double cost = sqrt(pow(V[i].x - V[j].x,2.0)+pow(V[i].y - V[j].y,2.0)+pow(V[i].z - V[j].z,2.0)) - V[i].r - V[j].r;\n        if(cost > 0) edge.push_back({cost, {i, j}});\n        else if(!U.same(i, j)) U.unite(i, j);\n      }\n    }\n    sort(edge.begin(), edge.end(), [](pair<double, pair<int, int>> a, pair<double, pair<int, int>> b){\n      return a.first < b.first;\n    });\n    for(auto e : edge){\n      if(!U.same(e.second.first, e.second.second)){\n        U.unite(e.second.first, e.second.second);\n        ans += e.first;\n      }\n    }\n    cout << fixed << setprecision(3) << ans << endl;\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    \n    printf(\"%lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\ndouble x[100],y[100],z[100],r[100];\nvector<pair<double,pa>> ve;\n\ndouble bi(double r){\n\treturn r*r;\n}\ndouble dis(int i,int j){\n\tdouble d=sqrt(bi(x[i]-x[j])+bi(y[i]-y[j])+bi(z[i]-z[j]));\n\tdouble r1=abs(r[i]-r[j]);\n\tdouble r2=r[i]+r[j];\n\tif(r2<d) return d-r2;\n\tif(r1<d) return 0;\n\t//return r1-d;\n\treturn 0;\n}\n\nvoid solve(){\n\tint n;\n\tcin>>n;\n\tif(n==0) exit(0);\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\tve.clear();\n\tshoki(110);\n\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t//\tcout<<i<<\" \"<<j<<\" \"<<dis(i,j)<<endl;\n\t\t\t\tve.pb({dis(i,j),{i,j}});\n\t}\n\tsort(ve.begin(),ve.end());\n\tdouble ans=0;\n\tfor(auto v:ve){\n\t\tif(same(v.second.first,v.second.second))continue;\n\t\tunite(v.second.first,v.second.second);\n\t\tans+=v.first;\n\t}\n\tprintf(\"%.10lf\\n\",ans);\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n \twhile(1)solve();\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define vi vector<int>\n#define vl vector<long long>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define REPD(i, n) for (int i = (int)(n-1); i >= 0; i--)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define FORD(i, a, b) for (int i = (int)(a); i >= (int)(b); i--)\n#define INF 1e18\n#define MOD 1e9+7;\n\ntemplate<class T> bool chmax(T &a, const T & b) {\n    if (a<b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> bool chmin(T &a, const T & b) {\n    if (a>b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct edge {int u, v; double cost;};\nstruct cell {double x, y, z, r;};\nconst int MAX_N = 1e5+10;\nedge es[MAX_N];\ncell cells[MAX_N];\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    UnionFind(int N) : par(N), rank(N) { \n        for(int i = 0; i < N; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) { \n        if (par[x] == x) return x;\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) { \n        x = find(x); \n        y = find(y); \n        if (rank[x] > rank[y]) {\n            par[y] = x;\n        } else {\n            par[x] = y;\n            if (rank[x] == rank[y]) rank[y]++;\n        }\n    }\n\n    bool same(int x, int y) { \n        return find(x) == find(y);\n    }\n};\n\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\ndouble kruskal(int n, int m) {\n    UnionFind uf(n);\n    sort(es, es+m, comp);\n    double res = 0;\n    REP(i, m) {\n        if (!uf.same(es[i].u, es[i].v)) {\n            uf.unite(es[i].u, es[i].v);\n            res += es[i].cost;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (1) {\n    \tint n;\n    \tcin >> n;\n        if (n == 0) break;\n    \tREP(i, n) {\n        \tdouble a, b, c, d;\n        \tcin >> a >> b >> c >> d;\n        \tcells[i] = {a, b, c, d};\n    \t}\n    \tint pos = 0;\n    \tFOR(i, 0, n) {\n        \tFOR(j, i+1, n) {\n            \tdouble cnt_d = sqrt(pow(cells[i].x-cells[j].x, 2)+pow(cells[i].y-cells[j].y, 2)+pow(cells[i].z-cells[j].z, 2));\n            \tdouble dist = cnt_d-cells[i].r-cells[j].r;\n            \tif (dist < 0) es[pos] = {i, j, 0};\n            \telse es[pos] = {i, j, dist};\n            \t++pos;\n        \t}\n    \t}\n    \tcout << fixed << setprecision(3) << kruskal(n, pos) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\n#define N 100\n#define MAX (1<<21)\n\ntypedef pair<double,int> PI;\n#define MP make_pair\n\ndouble d[N];\ndouble cost[N][N];\nint hantei[N];\n\nvoid prim(int n){\n  priority_queue<PI,vector<PI>,greater<PI> > Q;\n  for(int i=0;i<n;i++){d[i] = MAX;hantei[i]=0;}\n  Q.push(MP(0,0) );\n  d[0]=0;\n  while(!Q.empty()){\n    int now = Q.top().second;\n    Q.pop();\n    hantei[now]=1;\n\n    for(int i=0;i<n;i++){\n      if (i == now || hantei[i]==1)continue;\n      if (cost[now][i] < d[i]){\n        //cout << now<<\" to \" << i <<\" \"<<cost[now][i] << endl;\n        d[i]=cost[now][i];\n        Q.push(make_pair(cost[now][i],i));\n      }\n    }  \n  }//while end\n  \n\n\n\n}\n\n\n\n\nint main(){\n  while(1){\n    int n;\n    double in[100][4];\n    cin >> n;\n    if (n ==0)break;\n    for(int i=0;i<n;i++)\n      cin >> in[i][0] >> in[i][1] >> in[i][2] >> in[i][3];\n    \n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if (i == j){cost[i][j]=MAX;continue;}\n        double distance = sqrt( pow(in[i][0]-in[j][0],2)+pow(in[i][1]-in[j][1],2)+pow(in[i][2]-in[j][2],2));\n        //cout << distance << endl;\n        if ( distance > in[i][3]+in[j][3])cost[i][j] = distance - (in[i][3]+in[j][3]);\n        else if (distance <= in[i][3]+in[j][3])cost[i][j] = 0;\n      }\n    }\n\n\n\n    \n    prim(n);\n    double total = 0;\n    for(int i=0;i<n;i++){total+= d[i];}\n    printf(\"%.3lf\\n\",total);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define INF 1e16\nusing namespace std;\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\t// ------ Variables ------ //\n\tint V, E; vector<vector<pair<int, long double> > > G;\n\n\t// ------ Constructors ------ //\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long double> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long double> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long double> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\n\t// ------ Basic Functions ------ //\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long double w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long double w) { add1(v1, v2, w); add1(v2, v1, w); }\n\n\t// ------ Operators ------ //\n\tbool operator==(const Graph2& g) const { return G == g.G; }\n\tbool operator!=(const Graph2& g) const { return G != g.G; }\n\tvector<pair<int, long double> > operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tlong double minspan() {\n\t\tvector<long double> d(V, INF);\n\t\tvector<bool> used(V, false);\n\t\tpriority_queue<pair<long double, int> > que;\n\t\tfor (int i = 0; i < V; i++) d[i] = INF;\n\t\td[0] = 0; que.push(make_pair(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int> pa = que.top(); que.pop();\n\t\t\tint u = pa.second; used[u] = true;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first;\n\t\t\t\tif (d[v] > G[u][i].second && !used[v]) {\n\t\t\t\t\td[v] = G[u][i].second; que.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double sum = 0;\n\t\tfor (int i = 0; i < V; i++) sum += d[i];\n\t\treturn sum;\n\t}\n};\n// ------ Main ------ //\nint n; long double x[111], y[111], z[111], r[111];\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tGraph2 G(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tlong double dist = sqrtl((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\tG.add2(i, j, (dist > r[i] + r[j]) ? (dist - r[i] - r[j]) : 0);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3Lf\\n\", G.minspan());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v(n);\n\t\tfor(q=m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v[i]={x,y,z,r},parent[i]=i;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t\t}\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  int *par, *rank;\npublic:\n  UnionFind() {\n    par = NULL;\n    rank = NULL;\n  }\n  UnionFind(int n) {\n    par = new int[n];\n    rank = new int[n];\n    while(n--) {\n      par[n] = n;\n      rank[n] = 0;\n    }\n  }\n  int find(int x) {\n    return par[x] == x ? x : par[x] = find(par[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\nstruct Edge {\n  int a, b;\n  double cost;\n  bool operator < (const Edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nconst int MAXN = 101;\nint n;\ndouble x[MAXN], y[MAXN], z[MAXN], r[MAXN];\n\ninline double dist(int i, int j) {\n  return max(0.0, sqrt((x[i]-x[j])*(x[i]-x[j])+\n                       (y[i]-y[j])*(y[i]-y[j])+\n                       (z[i]-z[j])*(z[i]-z[j])) - (r[i]+r[j]));\n}\n\nint main() {\n  while(cin >> n && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    vector<Edge> v;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        v.push_back((Edge){i,j,dist(i,j)});\n      }\n    }\n    sort(v.begin(), v.end());\n    UnionFind uf(n);\n    double res = 0;\n    for(int k = 0; k < v.size(); ++k) {\n      if(!uf.same(v[k].a, v[k].b)) {\n        uf.unite(v[k].a, v[k].b);\n        res += v[k].cost;\n      }\n    }\n    cout << fixed << setprecision(3) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,N) for(int i=0;i<N;i++)\n#define rep2(i,N) for(int i=1;i<=N;i++)\nusing namespace std;\nlong long  INF=1e18;\nlong long mod=1e9+7;\nstruct UnionFind {\n    private:vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n    public: int group_count;\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n        group_count=N;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n        group_count--;\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n    \n};\ndouble cal_dist(double x1,double x2,double y1,double y2,double z1,double z2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n}\n\n\nint main(){\n    while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n\n    double x[n],y[n],z[n],r[n];\n    rep(i,n){\n        double nz;\n        cin>>x[i]>>y[i]>>z[i]>>r[i];\n    }\n    multimap<double,pair<int,int>>edge;\n    UnionFind uf(n);\n    for(int i=0;i<n;i++){\n        for(int k=i+1;k<n;k++){\n            \n            double d=cal_dist(x[i],x[k],y[i],y[k],z[i],z[k]);\n            if(d<=r[i]+r[k]){\n                uf.unite(i,k);\n            }\n            else{\n                d-=(r[i]+r[k]);\n            edge.emplace(make_pair(d,make_pair(i,k)));\n            }\n        }\n    }\n    double ans=0;\n    if(!edge.empty()){\n        auto it=edge.begin();\n\n        while(uf.group_count>1){\n            int one=it->second.first;\n            int two=it->second.second;\n            if(!uf.same(one,two)){\n                ans+=it->first;\n            }\n            uf.unite(one,two);\n            it++;\n        }\n    }\n        printf(\"%.3lf\\n\",ans);\n    }\n\n    \n\n\n    return 0;\n\n}\n/*\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v(n);\n\t\tfor(q=m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v[i]=push_back({x,y,z,r}),parent[i]=i;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t\t}\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for(int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef vector<vll> vvll;\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n  return sqrt(SQ(x1 - x2) + SQ(y1 - y2) + SQ(z1 - z2));\n}\n\nstruct Station {\n  double x, y, z, r;\n};\n\nint main() {\n  int n;\n  while(cin >> n) {\n    vector<Station> stations;\n    REP(i, n){\n      Station st;\n      cin >> st.x >> st.y >> st.z >> st.r;\n      stations.push_back(st);\n    }\n\n    double ans = 0;\n    set<int> cell;\n\n    multimap<double, int> corridor;\n    corridor.insert({0, 0});\n\n    while (cell.size() < n) {\n      double len = corridor.begin()->first;\n      int c = corridor.begin()->second;\n      corridor.erase(corridor.begin());\n\n      if (!cell.insert(c).second) continue;\n      ans += len;\n\n      for (int i = 0; i < n; i++) {\n        if (cell.find(i) == cell.end()) {\n          Station st = stations[i];\n          Station stc = stations[c];\n          corridor.insert({max(0.0, dist(st.x, st.y, st.z, stc.x, stc.y, stc.z) - st.r - stc.r), i});\n        }\n      }\n    }\n\n    printf(\"%.3f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100\n#define MAX_E 10000\n\nint V,E,par[MAX_V],rank[MAX_V];\n\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) \n    : x(x),y(y),z(z),r(r) {}\n};\n\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) \n    : u(u),v(v),dist(dist) {}\n};\n\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n\nEdge es[MAX_E];\n\nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n\ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n\nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.8f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nstruct UnionFind {\n    int node[110];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return node[x] < 0 ? x : find(node[x]);\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size(x) < size(y)) swap(x, y);\n        node[x] += node[y];\n        node[y] = x;\n    }\n\n    int size(int x) {\n        return -node[x];\n    }\n};\n\nstruct Elem {\n    int from, to;\n    double d;\n    bool operator<(const Elem &e) const {\n        return d < e.d;\n    }\n};\n\nconst double EPS = 1e-8;\n\ndouble coor[110][3], r[110];\ndouble dist(int p, int q) {\n    double val = 0;\n    for(int i=0; i<3; i++) {\n        double diff = coor[p][i] - coor[q][i];\n        val += diff * diff;\n    }\n    return max(0.0, sqrt(val) - r[p] - r[q]);\n}\n\nint main() {\n    int N;\n    while(1) {\n        scanf(\"%d\", &N);\n        if(N == 0) break;\n\n        for(int i=0; i<N; i++) {\n            scanf(\"%lf%lf%lf%lf\", &coor[i][0], &coor[i][1], &coor[i][2], &r[i]);\n        }\n\n        UnionFind uf;\n        vector<Elem> lines;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                double dist_ij = dist(i, j);\n                if(dist_ij < EPS) {\n                    uf.unite(i, j);\n                    continue;\n                }\n                lines.push_back(Elem{i, j, dist_ij});\n            }\n        }\n        sort(lines.begin(), lines.end());\n\n        double ans = 0.0;\n        for(auto e : lines) {\n            int s = e.from, t = e.to;\n            double cost = e.d;\n            if(uf.same(s, t)) continue;\n            uf.unite(s, t);\n            ans += cost;\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to;\n    double cost;\n};\nusing Edges=vector<Edge>;\n\nclass UnionFind{\n    vector<int> par;\n    vector<int> rank;\n    public:\n    UnionFind(int n):par(n,0),rank(n,0){\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        else return par[x]=find(par[x]);\n    }\n    int merge(int x,int y){\n        x=find(x),y=find(y);\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            if(rank[x]==rank[y]) rank[x]++;\n            par[y]=x;\n        }\n    }\n    bool same(int x,int y){return find(x)==find(y);}\n};\n\ndouble MST(int n,Edges &edges){\n    double res=0;\n    UnionFind u(n);\n    sort(begin(edges),end(edges),[](Edge lhs,Edge rhs){return lhs.cost<rhs.cost;});\n    for(int i=0;i<edges.size();i++){\n        if(!u.same(edges[i].from,edges[i].to)){\n            res+=edges[i].cost;\n            u.merge(edges[i].from,edges[i].to);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cout<<setprecision(3)<<fixed;\n    while(cin>>n,n){        \n        vector<double> x(n),y(n),z(n),r(n);\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>z[i]>>r[i];\n        }\n        auto dbl=[](double v){return v*v;};\n        auto dist=[&](int i,int j){\n            return sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j])+dbl(z[i]-z[j]));\n        };\n        Edges edges;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                edges.push_back(Edge{i,j,max(double(0),dist(i,j)-r[i]-r[j])});\n            }\n        }\n        cout<<MST(n,edges)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nvector<int> uf;\n\nint root(int x){\n  if(x==uf[x]) return x;\n  else return uf[x]=root(uf[x]);\n}\n\nvoid uni(int x,int y){\n  x=root(x);\n  y=root(y);\n  if(x!=y) uf[x]=y;\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    uf=vector<int>(n);\n    for(int i=0;i<n;i++) uf[i]=i;\n    vector<LD> x(n),y(n),z(n),r(n);\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    priority_queue<pair<LD,pair<int,int>>> kr;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n        kr.push({-max(0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j]),{i,j}});\n      }\n    }\n    pair<LD,pair<int,int>> now;\n    LD d;\n    int a,b;\n    LD ans=0;\n    while(!kr.empty()){\n      now=kr.top();\n      kr.pop();\n      d=-now.first;\n      a=now.second.first;\n      b=now.second.second;\n      if(root(a)!=root(b)){\n        uni(a,b);\n        ans+=d;\n      }\n    }\n    cout << fixed << setprecision(3) << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j;\n\tdouble x,y,z;\n\tfor(;cin>>n,n;){\n\t\tvector<tuple<double,double,double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z,v.push_back(make_tuple(x,y,z));\n\t\tfor(m=i=0;i<n;i++)for(j=i+1,j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=fabs(get<k>(v[i])-get<k>(v[j]));\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define EPS 1e-9\n#define fst first\n\nusing namespace std;\n\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n\n\n#define MAXN 100\nint n;\n\nWeight x[MAXN],y[MAXN],z[MAXN],r[MAXN];\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\n\ndouble solve() {\n  Graph g;\n  for(int i=0;i<n;i++) {\n    Edges es, es2;\n    for(int j=0;j<n;j++) {\n      if(i==j) {es.pb(Edge(i,j,0)); es2.pb(Edge(j,i,0));continue; }\n      double ldis = sqrt(pow(x[i]-x[j],2.0)+pow(y[i]-y[j],2.0)+pow(z[i]-z[j],2.0));\n      ldis = ldis - (r[i]+r[j]);\n      //printf(\"ldis=%lf\\n\",ldis);\n      if(LT(0, ldis)) { //0 < ldis\n\tes.pb(Edge(i,j,ldis)); es2.pb(Edge(j,i,ldis));\n      } else { es.pb(Edge(i,j,0)); es2.pb(Edge(j,i,0)); }\n    }\n    g.pb(es);\n  }\n  pair<Weight,Edges> ans;\n  ans = minimumSpanningTree(g);\n  return ans.fst;\n}\n\nmain() {\n  while(cin>>n,n) {\n    REP(j,n) {\n      cin>>x[j]>>y[j]>>z[j]>>r[j];\n    }\n    printf(\"%.3lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])break;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i,a,n) for(ll i=a;i<(ll)(n);i++)\n\nstruct Cell {\n   double x,y,z,r;\n};\n\n//参考: https://competitive-kivantium.hateblo.jp/entry/2016/07/07/230307\n//     https://programgenjin.hatenablog.com/entry/2019/03/19/101827\n\nint main(){\n   int n;\n   while(cin>>n, n){\n      Cell cells[n];\n      for(int i=0; i<n; i++){\n         cin>>cells[i].x>>cells[i].y>>cells[i].z>>cells[i].r;\n      }\n\n      double cost[n][n];\n      for(int i=0; i<n; i++){\n         for(int j=0; j<n; j++){\n            cost[i][j] = max(sqrt(pow(cells[i].x-cells[j].x, 2)+pow(cells[i].y-cells[j].y, 2)+pow(cells[i].z-cells[j].z, 2))-cells[i].r-cells[j].r, 0.0);\n         }\n      }\n      //プリム法\n      vector<double> minCost(n, 10e9);\n      vector<bool> visited(n, false);\n      minCost[0] = 0;\n      double sum = 0;\n      while(true){\n         int v = -1;\n         for(int i=0; i<n; i++){\n            //未到達で、最小のコストの辺を選ぶ\n            if(!visited[i] && (v==-1 || minCost[i] < minCost[v])) v = i;\n         }\n         if(v == -1) break;\n         visited[v] = true;\n         sum += minCost[v];\n\n         for(int i=0; i<n; i++){\n            minCost[i] = min(minCost[i], cost[v][i]);\n         }\n      }\n      cout << fixed << setprecision(3) <<  sum << endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n#define MAX 100\ntypedef pair<int,int> pii;\ntypedef pair<double,pii> pp;\n\nstruct union_find {\n    int rnk[MAX], par[MAX];\n\n    union_find(int n) { for(int i = 0; i < n; i++) rnk[i] = 1, par[i] = i; }\n\n    int find(int x) {\n        if(x == par[x]) return x;\n        else return par[x] = find(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if(rnk[x] > rnk[y]) par[y] = x;\n        else{\n            par[x] = y;\n            if(rnk[x] == rnk[y]) rnk[y]++;\n        }\n        return true;\n    }\n};\n\ninline double cor(vector<double> a, vector<double> b) {\n    double ret = sqrt((a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]));\n    ret -= a[3]+b[3];\n    if (ret <= 0) return 0;\n    else return ret;\n}\n\nint main(void) {\n    int n;\n    while (cin>>n && n) {\n        vector<vector<double> > v(n, vector<double>(4));\n        for (int i = 0; i < n; i++) cin >> v[i][0] >> v[i][1] >> v[i][2] >> v[i][3];\n        \n        vector<vector<double> > l(n, vector<double>(n));\n        priority_queue<pp, vector<pp>, greater<pp> > que;\n        union_find uf(n);\n        for (int i = 0; i < n-1; i++) {\n            for (int j = i+1; j < n; j++) {\n                pp t = make_pair(cor(v[i],v[j]), make_pair(i,j));\n                que.push(t);\n            }\n        }\n        double ans = 0;\n        while (!que.empty()) {\n            pp t = que.top();\n            que.pop();\n            if (uf.unite(t.second.first, t.second.second)) ans += t.first;\n        }\n        printf(\"%.3lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD=1000000007;\n#define INF 1LL<<30\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\nstruct UnionFind{\n    vector<int> par;\n\n    UnionFind(int n) : par(n,-1) { }\n    void init(int n) { par.assign(n,-1); }\n\n    int root(int x){\n        if(par[x]<0) return x;\n        else return par[x]=root(par[x]);\n    }\n\n    bool issame(int x,int y){\n        return root(x)==root(y);\n    }\n\n    bool merge(int x,int y){\n        x=root(x);\n        y=root(y);\n        if(x==y) return false;\n        if(par[x]>par[y]) swap(x,y);\n        par[x]+=par[y];\n        par[y]=x;\n        return true;\n    }\n\n    int size(int x){\n        return -par[root(x)];\n    }\n};\n\nint main(){\n    while(1){\n        int N;\n        cin>>N;\n        if(N==0) return 0;\n\n        double x[N],y[N],z[N],r[N];\n        rep(i,N) cin>>x[i]>>y[i]>>z[i]>>r[i];\n\n        using pint = pair<int,int>;\n        using Edge = pair<double, pint>;\n        vector<Edge> edges;\n\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                double l=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n                if(l>r[i]+r[j]){\n                    edges.push_back({l-(r[i]+r[j]), pint(i, j)});\n                }\n                else{\n                    edges.push_back({0, pint(i, j)});\n                }\n            }\n        }\n\n        // Kruskal 法\n        sort(all(edges));\n        // unionfindのスニペット読み込んで\n        UnionFind uf(N);\n        double res = 0;\n        \n        for (auto e : edges) {\n            int u = e.second.first, v = e.second.second;\n            double cost = e.first;\n            if (uf.issame(u, v)) continue;\n            uf.merge(u, v);\n            res += cost;\n        }\n\n        cout<<fixed<<setprecision(3)<<res<<endl;\n\n    }\n\n    \n}\n\n\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 100\n#define MAX_E 10000\n \nint V,E,par[MAX_V],rnk[MAX_V];\n \nstruct Colony{\n    double x,y,z,r;\n    Colony(){}\n    Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\n \nstruct Edge{\n    int u,v;\n    double dist;\n    Edge(){}\n    Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\n \nbool comp(const Edge &e1,const Edge &e2){\n    return e1.dist < e2.dist;\n}\n \nEdge es[MAX_E];\n \nvoid init(){\n    for(int i = 0 ; i < V ; i++){\n\tpar[i] = i;\n\trnk[i] = 0;\n    }\n}\n \nint find(int x){\n    if(par[x] == x){\n\treturn x;\n    }\n    return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n \n    if(x == y) return;\n \n    if(rnk[x] < rnk[y]){\n\tpar[x] = y;\n    }else{\n\tpar[y] = x;\n\tif(rnk[x] == rnk[y]){\n\t    rnk[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return find(x) == find(y);\n}\n \ndouble kruskal(){\n    sort(es,es+E,comp);\n    init();\n    double res = 0.0;\n    for(int i = 0 ; i < E ; i++){\n\tEdge e = es[i];\n\tif(!same(e.u,e.v)){\n\t    unite(e.u,e.v);\n\t    res += e.dist;\n\t}\n    }\n    return res;\n}\n \ndouble getDist(const Colony &c1,const Colony &c2){\n    return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n \nint main(){\n    while(cin >> V,V){\n\tE = 0;\n\tdouble x,y,z,r;\n\tColony C[MAX_V];\n\tfor(int i = 0 ; i < V ; i++){\n\t    cin >> x >> y >> z >> r;\n\t    C[i] = Colony(x,y,z,r);\n\t}\n     \n\tfor(int i = 0 ; i < V ; i++){\n\t    for(int j = i+1 ; j < V ; j++){\n\t\tdouble dist = getDist(C[i],C[j]);\n\t\tes[E++] = Edge(i,j,max(dist,0.0));\n\t    }\n\t}\n\tprintf(\"%.3f\\n\",kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  atcodder.xcode\n//  main.cpp\n//  Created by conan1024hao on 2019/11/07.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリ\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint cmp(P a,P b){\n        if(a.fi!=b.fi)\n        return a.fi>b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\nstruct unionfind{\n    vector<int> rank,parent,size;\n    unionfind(int n){\n        for(int i=0;i<n;i++){\n            rank.push_back(1);//树的高度\n            parent.push_back(i);//根\n            size.push_back(1);//树大小\n        }\n    }\n    int getroot(int x){\n        if(parent[x]==x)\n            return x;\n        return parent[x]=getroot(parent[x]);//押平路径加速以后的查找\n    }\n    bool issame(int a,int b){\n        return getroot(a)==getroot(b);\n    }\n    void unite(int a,int b){\n        a=getroot(a);\n        b=getroot(b);\n        if(a==b)\n            return;\n        else if(rank[a]>rank[b]){ //合并到高的树下\n            parent[b]=a;\n            size[a]+=size[b];\n        }\n        else if(rank[a]==rank[b]){\n            parent[b]=a;\n            rank[a]++;\n            size[a]+=size[b];\n        }\n        else{\n            parent[a]=b;\n            size[b]+=size[a];\n        }\n    }\n};\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    int n;\n    cin>>n;\n    while(n){\n        vector<double> x(n),y(n),z(n),r(n);\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>z[i]>>r[i];\n        }\n        unionfind uf(n);\n        double sum2=0;\n        vector<pair<double,pair<int,int> > > rx;\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                double minx=INF;\n                chmin(minx,mmax(0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j]));\n                rx.push_back(make_pair(minx,make_pair(i,j)));\n            }\n        }\n        sort(all(rx));\n        for(int i=0;i<rx.size();i++){\n            if(!uf.issame(rx[i].se.fi,rx[i].se.se)){\n                sum2+=rx[i].fi;\n                uf.unite(rx[i].se.fi,rx[i].se.se);\n            }\n        }\n        printf(\"%.3lf\\n\",sum2);\n        cin>>n;\n    }\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef pair<double, int> P;\n\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\nvector<P> edge[101];\n\ndouble sq(double x)\n{\n    return x * x;\n}\n\ndouble dis(int i, int j)\n{\n    double d = sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n    return max(0.0, d - r[i] - r[j]);\n}\n\nint main()\n{\n    int n;\n    double res;\n\n    while(cin >> n && n)\n    {\n        res = 0.0;\n        for (int i = 0; i < n; ++i) {\n            edge[i].clear();\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n            for (int j = 0; j < i; ++j) {\n                double d = dis(i, j);\n                edge[i].push_back(P(d, j));\n                edge[j].push_back(P(d, i));\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> h;\n        fill_n(used, n, false);\n        h.push(P(0.0, 0));\n        while (n) {\n            P p = h.top(); h.pop();\n            int v = p.second;\n            if (used[v]) continue;\n            --n;\n            res += p.first;\n            used[v] = true;\n            for (size_t j = 0; j < edge[v].size(); ++j)\n                if (! used[edge[v][j].second])\n                    h.push(edge[v][j]);\n        }\n        cout << fixed << setprecision(3) << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define INF 1e16\nusing namespace std;\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\t// ------ Variables ------ //\n\tint V, E; vector<vector<pair<int, long double> > > G;\n\n\t// ------ Constructors ------ //\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long double> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long double> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long double> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\n\t// ------ Basic Functions ------ //\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long double w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long double w) { add1(v1, v2, w); add1(v2, v1, w); }\n\n\t// ------ Operators ------ //\n\tbool operator==(const Graph2& g) const { return G == g.G; }\n\tbool operator!=(const Graph2& g) const { return G != g.G; }\n\tvector<pair<int, long double> > operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tlong double minspan() {\n\t\tvector<long double> d(V, INF);\n\t\tvector<bool> used(V, false);\n\t\tpriority_queue<pair<long double, int> > que;\n\t\tfor (int i = 0; i < V; i++) d[i] = INF;\n\t\td[0] = 0; que.push(make_pair(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int> pa = que.top(); que.pop();\n\t\t\tint u = pa.second; used[u] = true;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first;\n\t\t\t\tif (d[v] > G[u][i].second && !used[v]) {\n\t\t\t\t\td[v] = G[u][i].second; que.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double sum = 0;\n\t\tfor (int i = 0; i < V; i++) sum += d[i];\n\t\treturn sum;\n\t}\n};\n// ------ Main ------ //\nint n; long double x[111], y[111], z[111], r[111];\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tGraph2 G(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tlong double dist = sqrtl((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\tG.add2(i, j, (dist > r[i] + r[j]) ? (dist - r[i] - r[j]) : 0);\n\t\t\t}\n\t\t}\n\t\tcout << G.minspan() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <math.h>\n#define N 101\n#define INFTY 200000000\nusing namespace std;\nvoid prim();\nint n,p[N];\ndouble M[N][N],d[N],x[N],y[N],z[N],r[N];\nstring color[N];\nint main(){\n  int i,j;\n  double min,xc,yc,zc;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    for(i=0;i<n;i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tM[i][j]=-1;\n      }\n    }\n    for(i=0;i<n-1;i++){\n      for(j=i+1;j<n;j++){\n\txc=x[i]-x[j];\n\tyc=y[i]-y[j];\n\tzc=z[i]-z[j];\n\tif(xc<0) xc*=-1;\n\tif(yc<0) yc*=-1;\n\tif(zc<0) zc*=-1;\n\tM[i][j]=M[j][i]=sqrt(xc*xc+yc*yc+zc*zc)-r[i]-r[j];\n\tif(M[i][j]<0) M[i][j]=M[j][i]=0;\n      }\n    }\n    prim();\n    min=0.0;\n    for(i=0;i<n;i++){\n      if(d[i]!=INFTY) min+=d[i];\n      else{\n\tmin=0;\n\tbreak;\n      }\n    }\n    printf(\"%.3f\",min);\n    cout << endl;\n  }\n  return 0;\n}\nvoid prim(){\n  int i,j,mincost,u;\n  for(i=0;i<n;i++) color[i]=\"WHITE\",d[i]=INFTY;\n  d[0]=0;\n  p[0]=-1;\n  while(1){\n    mincost=INFTY;\n    for(i=0;i<n;i++){\n      if(color[i]!=\"BLACK\"&&d[i]<mincost){\n\tmincost=d[i];\n\tu=i;\n      }\n    }\n    if(mincost==INFTY) break;\n    color[u]=\"BLACK\";\n    for(i=0;i<n;i++){\n      if(color[i]!=\"BLACK\"&&M[u][i]!=-1){\n\tif(M[u][i]<d[i]){\n\t  d[i]=M[u][i];\n\t  p[i]=u;\n\t  color[i]=\"GLAY\";\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<cmath>\n#include<set>\nusing namespace std;\n\n#define NONE DBL_MAX\n\nstruct Sphere{\n  double x,y,z,r;\n};\n\ndouble dist(Sphere a, Sphere b)\n{\n  double d=sqrt( pow(a.x-b.x,2.0)+pow(a.y-b.y,2.0)+pow(a.z-b.z,2.0) );\n  return a.r+b.r<d?d-a.r-b.r:0.0;\n}\n\ndouble prim(vector< vector<double> >v)\n{\n  double sum=0.0;\n  int n=v.size();\n  set<int>selected;\n  set<int>::iterator it;\n  double mincost;\n  int mini;\n  selected.insert(0);\n  while(selected.size()!=n){\n    mincost=INT_MAX;\n    for(it=selected.begin();it!=selected.end();it++){\n      for(int i=0;i<n;i++){\n        if(selected.find(i)!=selected.end())continue;\n        if(v[*it][i]==NONE)continue;\n        if(v[*it][i]>=mincost)continue;\n        mincost=v[*it][i];\n        mini=i;\n       }\n     }\n    if(mini==NONE)break;\n    sum+=mincost;\n    selected.insert(mini);\n  }\n  return sum;\n}\n\nint main()\n{\n  int n;\n  double x,y,z,r;\n  while(cin>>n,n){\n    vector<Sphere>list(n);\n    vector< vector<double> >A(n,vector<double>(n,NONE));\n    for(int i=0;i<n;i++)cin>>list[i].x>>list[i].y>>list[i].z>>list[i].r;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tA[i][j]=A[j][i]=dist(list[i],list[j]);\n      }\n    }\n    printf(\"%.3f\\n\",prim(A));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\nconst double eps = 1e-8;\n\nint root(vector<int> & ufa,int i)\n{\n\tif(ufa[i] != i)\n\t\tufa[i] = root(ufa,ufa[i]);\n\treturn ufa[i];\n}\n\nvoid join(vector<int> & ufa,int i,int j)\n{\n\tint ri = root(ufa,i);\n\tint rj = root(ufa,j);\n\tufa[ri] = rj;\n}\n\nstruct e\n{\n\tint s;\n\tint t;\n\tdouble cst;\n};\n\nbool operator<(const e & lhs,const e & rhs)\n{\n\treturn lhs.cst < rhs.cst;\n}\n\nint main(void) {\n\tcout.precision(3);\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tvector<double> z(n);\n\t\tvector<double> r(n);\n\t\tvector<int> ufa(n);\n\t\tREP(i,n)ufa[i]=i;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tvector<vector<double> > dist_big(n,vector<double>(n,INF));\n\t\tREP(i,n)REP(j,n)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tint d = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\tdist_big[i][j]=dist_big[j][i]=sqrt(d)-(r[i]+r[j]);\n\t\t\tif(d <= (r[i]+r[j]+eps)*(r[i]+r[j]+eps))\n\t\t\t{\n\t\t\t\tjoin(ufa,i,j);\n\t\t\t}\n\t\t}\n\t\tset<int> sec;\n\t\tREP(i,n)\n\t\t\tsec.insert(root(ufa,i));\n\t\tint secn = sec.size();\n\t\tif(secn > 1)\n\t\t{\n\t\t\tvector<int> roots;\n\t\t\tFORIT(i,sec)\n\t\t\t\troots.push_back(*i);\n\t\t\tvector<vector<double> > dist(secn,vector<double>(secn,INF));\n\t\t\tREP(i,n)REP(j,n)\n\t\t\t{\n\t\t\t\tif(ufa[i]==ufa[j])continue;\n\t\t\t\tint di,dj;\n\t\t\t\tREP(k,secn)\n\t\t\t\t{\n\t\t\t\t\tif(roots[k]==ufa[i])di=k;\n\t\t\t\t\tif(roots[k]==ufa[j])dj=k;\n\t\t\t\t}\n\t\t\t\tdist[di][dj]=min(dist[di][dj],dist_big[i][j]);\n\t\t\t}\n\t\t\tvector<e> edge;\n\t\t\tREP(i,secn)REP(j,i)\n\t\t\t{\n\t\t\t\te p = {i,j,dist[i][j]};\n\t\t\t\tedge.push_back(p);\n\t\t\t}\n\t\t\tsort(ALL(edge));\n\t\t\tvector<int> ufa2(secn);\n\t\t\tREP(i,secn)ufa2[i]=i;\n\t\t\tdouble cost = 0.0;\n\t\t\tREP(i,edge.size())\n\t\t\t{\n\t\t\t\te p = edge[i];\n\t\t\t\tif(root(ufa2,p.s) != root(ufa2,p.t))\n\t\t\t\t{\n\t\t\t\t\tjoin(ufa2,p.s,p.t);\n\t\t\t\t\tcost += p.cst;\n\t\t\t\t\tsecn--;\n\t\t\t\t\tif(secn == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout  << setiosflags(ios::fixed)<< cost << endl;\n\t\t}\n\t\telse\n\t\t\tcout << setiosflags(ios::fixed)<< 0.0 << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nstruct UnionFind{\n    vector<int> par,num;\n    vector<bool> done;\n    UnionFind(int n):par(n),num(n,1),done(n,false){\n        iota(par.begin(),par.end(),0);  //include<numeric>\n    }\n    int find(int v){\n        return (par[v]==v)?v:(par[v]=find(par[v]));\n    }\n    void unite(int u,int v){\n        u=find(u),v=find(v);\n        if(u==v)return;\n        if(num[u]<num[v])swap(u,v);\n        num[u]+=num[v];\n        par[v]=u;\n        done[u]=done[u]|done[v];\n    }\n    bool same(int u,int v){\n        return find(u) == find(v);\n    }\n    bool ispar(int v){\n        return v=find(v);\n    }\n    int size(int v){\n        return num[find(v)];\n    }\n};\n\ndouble dist(double x,double y,double z,double r,double xx,double yy,double zz,double rr){\n\treturn max(sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy)+(z-zz)*(z-zz))-r-rr,0.0);\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tUnionFind uf(n);\n\t\tvector<pair<double,pair<int,int>>> v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tv.push_back(make_pair(dist(x[i],y[i],z[i],r[i],x[j],y[j],z[j],r[j]),make_pair(i,j)));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tdouble res=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(uf.same(v[i].second.first,v[i].second.second))continue;\n\t\t\tres+=v[i].first;\n\t\t\tuf.unite(v[i].second.first,v[i].second.second);\n\t\t}\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ:option\n    int size;//集合の個数:option\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);\n        ss=vector<int>(n,1);\n        size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;\n            ss[y]+=ss[x];\n        }else{\n            par[y] = x;\n            ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n};\n\nnamespace SpanningTree{\n\ttypedef double Cost;\n\tstruct Edge{\n\t\tint from,to;Cost cost;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost) {};\n\n\t\tbool operator<(Edge r) const{return cost<r.cost;}\n\t\tbool operator>(Edge r) const{return cost>r.cost;}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n\n\t//O(E*log(V))\n\t// verified by ACAC002 B\n\t// http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899132&cid=ACAC002\n\tCost kruskal(Graph g){\n\t\tconst int V=g.size();\n\t\tUnionFind uf=UnionFind(V);\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> que;\n\t\tREP(u,V)for(Edge e:g[u])\n\t\t\tque.push(e);\n\t\tCost res=0;\n\t\twhile(!que.empty()){\n\t\t\tEdge e=que.top();que.pop();\n\t\t\tif(!uf.same(e.from,e.to)){\n\t\t\t\tuf.unite(e.from,e.to);\n\t\t\t\tres+=e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nusing namespace SpanningTree;\n\n\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N;nextInt(N);\n\t\t\tif(N==0)return;\n\t\t\tGraph g(N);\n\t\t\tvector<double> xs(N),ys(N),zs(N),rs(N);\n\t\t\tREP(i,N){\n\t\t\t\tnextDouble(xs[i]);nextDouble(ys[i]);nextDouble(zs[i]);nextDouble(rs[i]);\n\t\t\t}\n\t\t\tREP(i,N)REP(j,N){\n\t\t\t\tdouble d=max(sqrt(pow(xs[i]-xs[j],2)+pow(ys[i]-ys[j],2)+pow(zs[i]-zs[j],2))-rs[i]-rs[j],0.0);\n\t\t\t\tg[i].push_back(Edge(i,j,d));\n\t\t\t}\n\n\t\t\tcout <<SpanningTree::kruskal(g)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(3);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v(n);\n\t\tfor(q=m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v[i]={x,y,z,r},parent[i]=i;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t\t}\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint N;\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    Circle(D x, D y, D z, D r): x(x), y(y), z(z), r(r){};\n};\n\nclass Edge{\npublic:\n    int to;\n    double cost;\n    Edge(int to, double cost): to(to), cost(cost){};\n    \n    bool operator > (const Edge& right) const{\n        return cost > right.cost;\n    }\n};\n\nD prim(vector<vector<Edge>>& G, int root){\n    int V = G.size();\n    D res = 0;\n    vector<bool> visited(V, false);\n    priority_queue<Edge, vector<Edge>, greater<Edge>> queue;\n    queue.push(Edge(root, 0));\n    \n    while(!queue.empty()){\n        auto edge = queue.top(); queue.pop();\n        if(visited[edge.to])\n            continue;\n        res += edge.cost;\n        visited[edge.to] = true;\n        for(int i=0; i<G[edge.to].size(); i++){\n            if(!visited[G[edge.to][i].to])\n                queue.push(G[edge.to][i]);\n        }\n    }\n    return res;\n}\n\nD dist(Circle& c1, Circle& c2){\n    //???????????????????????????0?????????\n    D d1 = sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y) + (c1.z-c2.z)*(c1.z-c2.z));\n    D d2 = abs(c1.r-c2.r);\n    \n    return GE(d1, d2) ? max(d1-c1.r-c2.r, 0.0) : 0;\n}\n\nvoid solve(){\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r; cin >> x >> y >> z >> r;\n        circles.push_back(Circle(x, y, z, r));\n    }\n    vector<vector<Edge>> G(N);\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++){\n            double d = dist(circles[i], circles[j]);\n            G[i].push_back(Edge(j, d));\n        }\n    }\n    cout << prim(G, 0) << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(16);\n    \n    while(cin>>N, N)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nclass GeometryUtil {\n\tpublic:\n\t\tbool eql(double a, double b) { return abs(a - b) < EPS; }\n\t\tbool lt(double a, double b) { return b - a >= EPS; }\n\t\tbool lte(double a, double b) { return lt(a, b) || eql(a, b); }\n\t\tbool gt(double a, double b) { return !lte(a, b); }\n\t\tbool gte(double a, double b) { return !lt(a, b); }\n\t\tbool eql(P a, P b) { return eql(a.Y, b.Y) && eql(a.X, b.X); }\n\t\tGeometryUtil() {\n\t\t}\n};\n\nGeometryUtil geo = GeometryUtil();\n\ntemplate<typename T>\nclass Vector3D {\n\tpublic:\n\t\tT x, y, z;\n\t\tVector3D(T _x, T _y, T _z): x(_x), y(_y), z(_z) {\n\t\t}\n\n\t\tT abs() {\n\t\t\treturn sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n\t\t}\n\n\t\tT dot(Vector3D<T> rhs) {\n\t\t\treturn x * rhs.x + y * rhs.y + z * rhs.z;\n\t\t}\n\n\t\tVector3D<T> cross(Vector3D<T> rhs) {\n\t\t\treturn Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);\n\t\t}\n\n\t\t// check if this Vector3D (as a point) is on a line (a-b)\n\t\tbool is_upon(const Vector3D<T> a, const Vector3D<T> b) const {\n\t\t\tdump((b-a).cross(b-(*this)).abs());\n\t\t\tdump(geo.eql((b-a).cross(b-(*this)).abs(), 0));\n\t\t\tdump((b-a).dot((*this)-a));\n\t\t\tdump(geo.gt( (b-a).dot((*this)-a), 0 ));\n\t\t\tdump((a-b).dot((*this)-b));\n\t\t\tdump(geo.gt( (a-b).dot((*this)-b), 0 ));\n\n\t\t\treturn geo.eql( (b-a).cross(b-(*this)).abs(), 0 ) &&\n\t\t\t\tgeo.gt( (b-a).dot((*this)-a), 0 ) &&\n\t\t\t\tgeo.gt( (a-b).dot((*this)-b), 0 );\n\t\t}\n\n\t\t// Add vector\n\t\tVector3D<T> operator+(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x + rhs.x, y + rhs.y, z + rhs.z);\n\t\t}\n\n\t\t// Subtract vecrtor\n\t\tVector3D<T> operator-(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x - rhs.x, y - rhs.y, z - rhs.z);\n\t\t}\n\n\t\t// Multiply by scala value\n\t\ttemplate<typename Scala>\n\t\tVector3D<T> operator*(const Scala rhs) const {\n\t\t\treturn Vector3D<T>(x * rhs, y * rhs, z * rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Vector3D<T>& v) {\n\treturn out << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\";\n}\n\ntemplate<typename T>\nclass Sphere {\n\tpublic:\n\t\tT x, y, z, r;\n\t\tSphere(T _x, T _y, T _z, T _r) : x(_x), y(_y), z(_z), r(_r) {\n\t\t}\n\n\t\t// distance of the centers of spheres\n\t\tT distance(const Sphere& rhs) const {\n\t\t\t// move two spheres so that the center of (*this) comes to the origin\n\t\t\tSphere _r(rhs.x - x, rhs.y - y, rhs.z - z, rhs.r);\n\t\t\treturn Vector3D<T>(_r.x, _r.y, _r.z).abs();\n\t\t}\n\n\t\t// check if this sphere is completely inside of rhs\n\t\tbool is_inside_of(const Sphere& rhs) const {\n\t\t\treturn geo.lt(distance(rhs) + r, rhs.r);\n\t\t}\n\n\t\t// check if this sphere is completely outside of rhs\n\t\tbool is_outside_of(const Sphere& rhs) const {\n\t\t\treturn geo.gt(distance(rhs) - r, rhs.r);\n\t\t}\n\n\t\t// check if this sphere is touching with rhs\n\t\tbool is_touching_with(const Sphere& rhs) const {\n\t\t\treturn\n\t\t\t\tgeo.eql(distance(rhs), r + rhs.r) ||\n\t\t\t\t((*this).is_inside_of(rhs) && geo.eql(distance(rhs) + r, rhs.r)) ||\n\t\t\t\t(rhs.is_inside_of((*this)) && geo.eql(distance(rhs) + rhs.r, r));\n\t\t}\n\n\t\tbool is_overlapping_with(const Sphere& rhs) const {\n\t\t\treturn !is_inside_of(rhs) && !is_outside_of(rhs) && !is_touching_with(rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Sphere<T>& s) {\n\treturn out << \"(\" << s.x << \", \" << s.y << \", \" << s.z << \", \" << s.r << \")\";\n}\n\nclass UnionFindTree {\n\tint n;\n\tVI parent;\n\tpublic:\n\t\tUnionFindTree(int _n): n(_n) {\n\t\t\tparent = VI(n);\n\t\t\tREP (i, n) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\n\t\tint group(int x) {\n\t\t\tif (parent[x] == x) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn parent[x] = group(parent[x]);\n\t\t\t}\n\t\t}\n\n\t\tbool united(int x, int y) {\n\t\t\treturn group(x) == group(y);\n\t\t}\n\n\t\tvoid unite(int x, int y) {\n\t\t\tx = group(x);\n\t\t\ty = group(y);\n\t\t\tparent[x] = y;\n\t\t}\n};\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tdump(n);\n\t\tvector< Sphere<double> > cells;\n\t\tREP (i, n) {\n\t\t\tdouble x, y, z, r; cin >> x >> y >> z >> r;\n\t\t\tcells.PB(Sphere<double>(x,y,z,r));\n\t\t}\n\t\tVVD costs(n, VD(n, INF));\n\t\tREP (i, n) {\n\t\t\tREP (j, n) {\n\t\t\t\tif (i == j) { costs[i][j] = costs[j][i] = 0; continue; }\n\t\t\t\tif (cells[i].is_touching_with(cells[j]) || cells[i].is_overlapping_with(cells[j])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = 0;\n\t\t\t\t} else if (cells[i].is_inside_of(cells[j])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = cells[j].r - cells[i].distance(cells[j]) - cells[i].r;\n\t\t\t\t} else if (cells[j].is_inside_of(cells[i])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = cells[i].r - cells[i].distance(cells[j]) - cells[j].r;\n\t\t\t\t} else {\n\t\t\t\t\t// outside of each other\n\t\t\t\t\tcosts[i][j] = costs[j][i] = cells[i].distance(cells[j]) - cells[i].r - cells[j].r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP (i, n) {\n\t\t\tREP (j, n) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tif (cells[i].is_inside_of(cells[j])) {\n\t\t\t\t\tcosts[i][j] = costs[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdumpl(costs);\n\n\t\tdouble ans = 0;\n\t\tUnionFindTree ut(n);\n\t\ttypedef pair<double, PII> PDPII;\n\t\tvector<PDPII> edges; // (cost, (from, to))\n\t\tREP (i, n) {\n\t\t\tFOR (j, i+1, n) {\n\t\t\t\tedges.PB(MP(costs[i][j], MP(i, j)));\n\t\t\t}\n\t\t}\n\t\tSORT(edges);\n\n\t\tREP (i, edges.size()) {\n\t\t\tdouble cost = edges[i].F;\n\t\t\tint from = edges[i].S.F;\n\t\t\tint to = edges[i].S.S;\n\t\t\tif (ut.united(from, to)) { continue; }\n\t\t\tut.unite(from, to);\n\t\t\tdump(from);\n\t\t\tdump(to);\n\t\t\tdump(cost);\n\t\t\tans += cost;\n\t\t}\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {\n    }\n    int root(int x) {\n        return (data[x] < 0) ? x : data[x] = root(data[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nusing T = tuple<double, double, double, double>;\ndouble d(T a, T b) {\n    double x1, y1, z1, r1, x2, y2, z2, r2;\n    tie(x1, y1, z1, r1) = a;\n    tie(x2, y2, z2, r2) = b;\n    return max(0.0, sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)) -\n                        r1 - r2);\n}\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) return 0;\n        vector<T> v(n);\n        rep(i, n) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            v[i] = make_tuple(x, y, z, r);\n        }\n\n        vector<tuple<double, int, int>> es;\n        rep(i, n) {\n            rep(j, i) {\n                es.emplace_back(d(v[i], v[j]), i, j);\n            }\n        }\n        sort(all(es));\n\n        double ans = 0;\n        UnionFind uf(n);\n        for (auto e : es) {\n            double c;\n            int a, b;\n            tie(c, a, b) = e;\n            if (!uf.find(a, b)) {\n                uf.unite(a, b);\n                ans += c;\n            }\n        }\n        cout <<fixed<<setprecision(3)<< ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <tuple>\n#include <iomanip>\n#include <cmath>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef tuple<double,int,int> T;\n\nclass UnionFind {\npublic:\n    vector<int> par;\n    int size;\n    UnionFind(int n) {\n        size = n;\n        par.resize(n);\n        REP (i, 0, n) par[i] = i;\n    }\n    int find(int n) {\n        return (n == par[n] ? n : par[n] = find(par[n]));\n    }\n    bool unite(int a, int b) {\n        a = find(a);\n        b = find(b);\n        if (a == b) return false;\n        par[a] = b;\n        size--;\n        return true;\n    }\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        REP (i, 0, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        UnionFind uf(n);\n        vector<T> v;\n        v.reserve(n * n);\n        REP (i, 0, n) REP (j, i + 1, n) {\n            double dis = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n            v.push_back(make_tuple(max(0.0, dis - r[i] - r[j]), i, j));\n        }\n        sort(begin(v), end(v));\n        double ans = 0;\n        REP (i, 0, v.size()) {\n            T tp = v[i];\n            if (uf.unite(get<1>(tp), get<2>(tp))) {\n                ans += get<0>(tp);\n            }\n        }\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOTCONNECTED 0 // WHITE\n#define CANDIDATE 1 // GRAY\n#define CONNECTED 2 // BLACK\nusing namespace std;\ndouble getDistance(vector<double>, vector<double>);\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<vector<double> > cells;\n    for(int i = 0; i < n; ++i) {\n      double y, x, z, r;\n      cin >> x >> y >> z >> r;\n      cells.push_back(vector<double>({x, y, z, r}));\n    }\n    vector<int> minWeights(n, INT_MAX); // d\n    minWeights[0] = 0;\n    vector<int> states(n, NOTCONNECTED); // color\n    vector<int> parents(n, -1); // p\n    while(true) {\n      int minv = INT_MAX;\n      int u = -1;\n      for(int i = 0; i < n; ++i) {\n        if(minv > minWeights[i] && states[i] != CONNECTED) {\n          u = i;\n          minv = minWeights[i];\n        }\n      }\n      if(u == -1) break;\n      states[u] = CONNECTED;\n      for(int v = 0; v < n; ++v) {\n        if(states[v] != CONNECTED && minWeights[v] > getDistance(cells[u], cells[v])) {\n          minWeights[v] = getDistance(cells[u], cells[v]);\n          parents[v] = u;\n          states[v] = CANDIDATE;\n        }\n      }\n    }\n    double ans = 0;\n    for(int i = 0; i < n; ++i) {\n      if(parents[i] != -1) ans += getDistance(cells[i], cells[parents[i]]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\ndouble getDistance(vector<double> a, vector<double> b) {\n  double dx = abs(a[0] - b[0]);\n  double dy = abs(a[1] - b[1]);\n  double dz = abs(a[2] - b[2]);\n  double ans = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - a[3] - b[3];\n  return ans < 0 ? 0 : ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct edge_t {\n    int from, to;\n    double cost;\n    edge_t(int from, int to, double cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const edge_t &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const edge_t &o) const {\n        return (cost > o.cost);\n    }\n};\nstruct state_t {\n    int v;\n    double min_cost;\n    state_t(int v, double min_cost) : v(v), min_cost(min_cost) {}\n    bool operator<(const state_t &o) const {\n        return (min_cost < o.min_cost);\n    }\n    bool operator>(const state_t &o) const {\n        return (min_cost > o.min_cost);\n    }\n};\ntypedef vector<edge_t> vertex_t;\nstruct graph_t {\n    vector<vertex_t> g;\n\n    graph_t() {}\n\n    graph_t(int vertex_count) {\n        g.resize(vertex_count);\n    }\n    graph_t(vector<vertex_t> g) : g(g) {}\n\n    inline vertex_t& operator[](int index) {\n        return g[index];\n    }\n\n    inline void push_back(vertex_t v) {\n        g.push_back(v);\n    }\n\n    inline void add_edge(int from, int to, double cost) {\n        g[from].push_back(edge_t(from, to, cost));\n    }\n\n    double prim() {\n        bool used[g.size()];\n        double min_span_cost = 0;\n        priority_queue< edge_t, vector<edge_t>, greater<edge_t> > q;\n\n        fill(used, used+g.size(), false);\n\n        used[0] = true;\n        for (int i = 0; i < g[0].size(); i++) {\n            q.push(g[0][i]);\n        }\n\n        while (!q.empty()) {\n            edge_t e = q.top(); q.pop();\n            if (used[e.to]) continue;\n            used[e.to] = true;\n            min_span_cost += e.cost;\n            for (int i = 0; i < g[e.to].size(); i++) {\n                q.push(g[e.to][i]);\n            }\n        }\n\n        return min_span_cost;\n    }\n};\n\nstruct Point {\n    double x, y, z;\n    Point() {}\n    Point(double x, double y, double z) : x(x), y(y), z(z) {}\n    double distance (const Point &o) const {\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y) + (z - o.z) * (z - o.z));\n    }\n};\n\nint main() {\n    int n; \n    while (cin >> n) {\n        if (n == 0) break;\n        double rs[n];\n        Point ps[n];\n        graph_t graph(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y >> ps[i].z >> rs[i];\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                double distance = ps[i].distance(ps[j]);\n                double cost = 0;\n                if (distance > rs[i] + rs[j]) cost = distance - rs[i] - rs[j];\n                graph.add_edge(i, j, cost);\n            }\n        }\n        printf(\"%.3f\\n\", graph.prim());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1127 : Building a Space Station **/\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tEdge(int from_, int to_, double cost_) : from(from_), to(to_), cost(cost_){}\n\tbool operator <(const Edge &rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int v) : data(v, -1) {}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x: (data[x] = root(data[x]));\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x != y) {\n\t\t\tif (size(y) > size(x)) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ndouble kruskal(const int v, vector<Edge> es) {\n\tsort(es.begin(), es.end());\n\tdouble ans = 0;\n\tUnionFind uf(v);\n\tfor (int i=0; i<es.size(); i++) {\n\t\tif (uf.same(es[i].from, es[i].to)) continue;\n\t\tuf.merge(es[i].from, es[i].to);\n\t\tans += es[i].cost;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin>>n, n) {\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tvector<Edge> e;\n\t\t\n\t\trep(i, n) {\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdouble d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\t\td -= r[i] + r[j];\n\t\t\t\t\td = max(0.0, d);\n\t\t\t\t\te.push_back(Edge(i, j, d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\", kruskal(n, e));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cstdio>\nusing namespace std;\n\n#define WHITE 0\n#define EPS 1e-10\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 1000\n#define INF 999999999.99\n\nlong double x[MAX_N][MAX_N];\nlong double MIN[MAX_N], color[MAX_N];\nlong double X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nlong double b, sum, sum_min;\nint n, c, a;\n\nvoid prim() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tMIN[j] = INF;\n\t\t\tcolor[j] = WHITE;\n\t\t}\n\t\tb = INF;\n\t\ta = n;\n\t\tcolor[i] = GRAY;\n\t\tMIN[i] = 0;\n\t\twhile (a != 0) {\n\t\t\tb = INF;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor[c] = BLACK;\n\t\t\ta -= 1;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (color[k] != BLACK && x[c][k] >= -EPS) {\n\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum += MIN[j];\n\t\t}\n\t\tsum_min = min(sum_min, sum);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tsum_min = INF;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tX[i] = 0; Y[i] = 0; Z[i] = 0;\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = -INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tlong double X1 = (X[i] - X[j])*(X[i] - X[j]);\n\t\t\t\tlong double Y1 = (Y[i] - Y[j])*(Y[i] - Y[j]);\n\t\t\t\tlong double Z1 = (Z[i] - Z[j])*(Z[i] - Z[j]);\n\t\t\t\tlong double dist = sqrtl(X1 + Y1 + Z1);\n\t\t\t\tlong double dist2 = dist - R[i] - R[j];\n\t\t\t\tx[i][j] = max(0.0l, dist2);\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tsum_min *= 10000;\n\t\tsum_min += 5;\n\t\tsum_min /= 10;\n\t\tint RES = sum_min;\n\t\tprintf(\"%03d.%03d\\n\", RES / 1000, RES % 1000);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ntypedef struct UnionFindTree{\n    vector<int> par;\n\n    UnionFindTree(int n): par(n, -1){}\n\n    int find(int x){\n        if(par[x] < 0) return x;\n        return par[x] = find(par[x]);\n    }\n\n    int size(int x){\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n}UF;\n\ntemplate<class T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n\ntemplate<class T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n\n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n\n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n\n    pair<bool, vector<T>> bellman_ford(int s){\n        T d_INF = numeric_limits<T>::max();\n        vector<T> d(n, d_INF);\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        d[s] = 0;\n        rep(i, n)for(edge<T> &e: E){\n            if(d[e.from] != d_INF && d[e.from] + e.cost < d[e.to]){\n                d[e.to] = d[e.from] + e.cost;\n                if(i == n-1) return make_pair(true, d);\n            }\n        }\n        return make_pair(false, d);\n    }\n\n    vector<T> dijkstra(int s){\n        using P = pair<T, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<T> d(n, numeric_limits<T>::max());\n        d[s] = 0;\n        que.push(P((T)0, s));\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(edge<T> &e : G[v]){\n                if(d[e.to] > d[v] + e.cost){\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n        return d;\n    }\n\n    pair<bool, vector<vector<T>>> warshall_floyd(){\n        T d_INF = numeric_limits<T>::max();\n        vector<vector<T>> d = vector<vector<T>>(n, vector<T>(n, d_INF));\n        rep(i, n){\n            for(edge<T> &e: G[i]) d[i][e.to] = e.cost;\n            d[i][i] = 0;\n        }\n        rep(k, n)rep(i, n)rep(j, n)if(d[i][k] < d_INF && d[k][j] < d_INF){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        rep(i, n)if(d[i][i] < 0) return make_pair(true, d);\n        return make_pair(false, d);\n    }\n\n    pair<T, Graph<T>> kruskal(){\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        sort(E.begin(), E.end(), [](const edge<T> &e1, const edge<T> &e2){return e1.cost < e2.cost;});\n        UF uf(n);\n        T ret = 0;\n        Graph<T> MST(n);\n        for(edge<T> &e: E){\n            if(!uf.same(e.from, e.to)){\n                uf.unite(e.from, e.to);\n                ret += e.cost;\n                MST.add_edge(e.from, e.to, e.cost);\n                MST.add_edge(e.to, e.from, e.cost);\n            }\n        }\n        return {ret, MST};\n    }\n\n    pair<bool, vector<int>> toposo(){\n        vector<int> ret(n, -1), in(n, 0);\n        rep(i, n)for(edge<T> &e: G[i]) ++in[e.to];\n        int cur = 0;\n        stack<int> st;\n        rep(i, n)if(!in[i]) st.push(i);\n        if(st.empty()) return make_pair(false, ret);\n        while(!st.empty()){\n            int v = st.top(); st.pop();\n            ret[cur++] = v;\n            for(edge<T> &e: G[v]){\n                if(!in[e.to]) return make_pair(false, ret);\n                --in[e.to];\n                if(!in[e.to]) st.push(e.to);\n            }\n        }\n        return make_pair(cur==n, ret);\n    }\n\n    bool has_cycle(){\n        return !toposo().fi;\n    }\n\n    void scc_dfs(int v, vector<bool> &used, vector<int> &vs){\n        used[v] = true;\n        for(edge<T> &e: G[v])if(!used[e.to]) scc_dfs(e.to, used, vs);\n        vs.push_back(v);\n    }\n\n    void scc_rdfs(int v, int k, vector<int> &cmp, vector<bool> &used, vector<vector<int>> &rG){\n        used[v] = true;\n        cmp[v] = k;\n        for(int nv: rG[v])if(!used[nv]) scc_rdfs(nv, k, cmp, used, rG);\n    }\n\n    tuple<int, vector<int>, vector<vector<int>>> scc(){\n            vector<vector<int>> rG(n);\n            rep(i, n)for(edge<T> &e: G[i]) rG[e.to].push_back(i);\n            vector<bool> used(n, false);\n            vector<int> vs;\n            vector<int> vtoc(n);\n            rep(i, n)if(!used[i]) scc_dfs(i, used, vs);\n            fill(used.begin(), used.end(), false);\n            int k = 0;\n            vector<vector<int>> ctov=vector<vector<int>>(n, vector<int>());\n            rrep(i, n)if(!used[vs[i]]) scc_rdfs(vs[i], k++, vtoc, used, rG, ctov);\n            return make_tuple(k, vtoc, ctov);\n    }\n\n    int bridge_dfs(int v, int pv, int &idx, vector<int> &ord, vector<int> &low, vector<pii> &bridge){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=pv){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], bridge_dfs(nv, v, idx, ord, low, bridge));\n                if(low[nv]>ord[v]) bridge.emplace_back(min(v, nv), max(v, nv));\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<pii> get_bridge(){\n        vector<int> ord(n, -1), low(n, -1);\n        vector<pii> bridge;\n        int idx=0;\n        bridge_dfs(0, -1, idx, ord, low, bridge);\n        sort(bridge.begin(), bridge.end());\n        bridge.erase(unique(bridge.begin(), bridge.end()), bridge.end());\n        return bridge;\n    }\n\n    int art_dfs(int v, int prev, int &idx, vector<int> &ord, vector<int> &low, vector<int> &art){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=prev){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], art_dfs(nv, v, idx, ord, low, art));\n                if((prev<0 && ord[nv]!=1) || (prev>=0 && low[nv]>=ord[v])){\n                    art.push_back(v);\n                }\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<int> get_art(){\n        vector<int> ord(n, -1), low(n, -1), art;\n        int idx=0;\n        art_dfs(0, -1, idx, ord, low, art);\n        sort(art.begin(), art.end());\n        art.erase(unique(art.begin(), art.end()), art.end());\n        return art;\n    }\n};\n\nconstexpr double eps=1e-9;\nconstexpr double PI=3.14159265358979323846264338327950;\n\ninline int sgn(double x){\n    if(x<-eps) return -1;\n    if(x>eps) return 1;\n    return 0;\n}\n\ninline bool EQ(double x, double y){\n    return sgn(x-y)==0;\n}\n\ninline bool GE(double x, double y){\n    return sgn(x-y)==1;\n}\n\ninline bool LE(double x, double y){\n    return sgn(x-y)==-1;\n}\n\ninline bool GEQ(double x, double y){\n    return sgn(x-y)>=0;\n}\n\ninline bool LEQ(double x, double y){\n    return sgn(x-y)<=0;\n}\n\nint main(){\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        Graph<double> gr(n);\n        double x[n], y[n], z[n], r[n];\n        rep(i, n) scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n        rep(i, n)For(j, i+1, n){\n            double d = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]);\n            double tmp = LEQ(d, (r[i]+r[j])*(r[i]+r[j])) ? 0 : sqrt(d)-r[i]-r[j];\n            gr.add_edge(i, j, tmp);\n        }\n        printf(\"%.3lf\\n\", gr.kruskal().fi);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z;\n\tfor(;cin>>n,n;){\n\t\tvector<tuple<double,double,double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z,v.push_back(make_tuple(x,y,z));\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=fabs(get<(const int)k>(v[i])-get<k>(v[j]));\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\n\nlong double x[105], y[105], z[105], r[105];\n\nlong double dist(int i, int j) {\n    double sum = 0.0;\n    sum += pow(x[i]-x[j], 2);\n    sum += pow(y[i]-y[j], 2);\n    sum += pow(z[i]-z[j], 2);\n    return pow(sum, 0.5);\n}\n\ntypedef pair<long double, i_i> d_i_i;\n\nint main() {\n    cout << fixed << setprecision(3);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        UnionFind uni(n + 1);\n        for(int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        priority_queue<d_i_i, vector<d_i_i>, greater<d_i_i> > que;\n        for(int i = 1; i <= n; i++) {\n            for(int j = i + 1; j <= n; j++) {\n                long double now = dist(i, j) - r[i] - r[j];\n                if(now < 0) now = 0.0;\n                que.push({now, {i, j}});\n            }\n        }\n        long double sum = 0.0;\n        while(uni.size(1) != n) {\n            d_i_i now = que.top();\n            que.pop();\n            //cerr << now.first << endl;\n            int i = now.second.first;\n            int j = now.second.second;\n            if(!uni.issame(i, j)) {\n                sum += now.first;\n                uni.merge(i, j);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vchar = vector<char>;\nusing vvchar = vector<vchar>;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#pragma region Debug\nistream &operator>>(istream &is, P &a)\n{\n    return is >> a.first >> a.second;\n}\nostream &operator<<(ostream &os, const P &a) { return os << \"(\" << a.first << \",\" << a.second << \")\"; }\n\ntemplate <typename T>\nvoid view(const std::vector<T> &v)\n{\n    for (const auto &e : v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv)\n{\n    for (const auto &v : vv)\n    {\n        view(v);\n    }\n}\n#pragma endregion\n\n#pragma region UnionFind\nstruct UnionFind\n{\n    vector<int> d;\n    // d[x] is the index of the parent of x\n    // d[x] is -size if x is a root\n\n    UnionFind(int n) : d(vector<int>(n, -1)) {}\n    int root(int x)\n    {\n        if (d[x] < 0)\n        {\n            return x;\n        }\n        return d[x] = root(d[x]);\n    }\n\n    bool unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if (x == y)\n        {\n            return false;\n        }\n        if (d[x] > d[y])\n            swap(x, y); // x always bigger tree\n\n        d[x] += d[y];\n        d[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    int size(int x) { return -d[root(x)]; }\n};\n#pragma endregion\n\nstruct sphere\n{\n    double x, y, z, r;\n    sphere(double xx = 0, double yy = 0, double zz = 0, double rr = 0) : x(xx), y(yy), z(zz), r(rr) {}\n    double dist(sphere &other)\n    {\n        double dx = x - other.x, dy = y - other.y, dz = z - other.z;\n        return sqrt(dx * dx + dy * dy + dz * dz) - r - other.r;\n    }\n    bool intersect(sphere &other)\n    {\n        return dist(other) < 0;\n    }\n};\n\nstruct edge\n{\n    int s, t;\n    double d;\n    edge(int ss, int tt, double dd) : s(ss), t(tt), d(dd) {}\n    bool operator>(const edge &r) const { return d > r.d; }\n};\n\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        vector<sphere> p(n);\n        UnionFind uft(n);\n        rep(i, n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n        priority_queue<edge, vector<edge>, greater<edge>> q;\n        rep(i, n) rep(j, n)\n        {\n            if (p[i].intersect(p[j]))\n            {\n                uft.unite(i, j);\n            }\n            else\n            {\n                q.push(edge(i, j, p[i].dist(p[j])));\n            }\n        }\n\n        long double ans = 0;\n        while (q.size())\n        {\n            edge e = q.top();\n            q.pop();\n            if (uft.unite(e.s, e.t))\n            {\n                ans += e.d;\n            }\n        }\n\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <typename T>\nclass Edge\n{\npublic:\n\n\tLL from,to;\n\tT cost;\n\t\n\tEdge(LL _from,LL _to,T _cost){\n\t\tfrom=_from;\n\t\tto=_to;\n\t\tcost=_cost;\n\t}\n\t\n\tbool operator<(const Edge& e) const {\n\t\treturn cost<e.cost;\n\t}\n};\n\ntemplate <typename T>\nclass UF{\npublic:\n\tvector<T> par,rank;\n\n\tUF(T n){\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor(T i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tT find(T x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(T x, T y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(T x, T y){\n\n\t\treturn find(x)==find(y);\n\t}\n};\n\ntemplate <typename T>\nclass Graph\n{\npublic:\n\tlong long n;\n\tvector<Edge<T> > ve;\n\tGraph(vector<Edge<T> > _ve,LL _n){\n\t\tve=_ve;\n\t\tn=_n;\n\n\t}\n\t\n\tvector<Edge<T> > kruskal(){\n\t\t\n\t\tvector<Edge<T> > res;\n\t\tsort(ve.begin(),ve.end());\n\t\t\n\t\tUF<LL> uf(n);\n\t\t\n\t\tfor(LL i=0;i<ve.size();i++){\n\t\t\tEdge<T> e=ve[i];\n\t\t\tif(!uf.same(e.from,e.to)){\n\t\t\t\tres.push_back(e);\n\t\t\t\tuf.unite(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\t\n\t\tvector<Edge<double> > ve;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble d=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\t\tve.push_back(Edge<double>(i,j,max(0.0,sqrt(d)-r[i]-r[j])));\n\t\t\t}\n\t\t}\n\t\t\n\t\tGraph<double> G(ve,n);\n\n\t\tvector<Edge<double> > MST=G.kruskal();\n\t\t\n\t\tdouble res=0;\n\t\tfor(int i=0;i<MST.size();i++) res+=MST[i].cost;\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define dis(p,q,r) ((p)*(p)+(q)*(q)+(r)*(r))\nstruct pi{\n  bool operator()(const pair<pair<int,int>,double>& p,const pair<pair<int,int>,double>& q){\n    return p.second<q.second;\n  }\n};\nint main(){\n  int i,j,k;\n  int n;\n  while(scanf(\"%d\",&n),n){\n    double x[100],y[100],z[100],r[100];\n    vector<pair<pair<int,int>,double> > a;\n    a.reserve(n*(n-1)/2);\n    for(i=0;i<n;++i){\n      scanf(\"%lf%lf%lf%lf\",x+i,y+i,z+i,r+i);\n      for(j=0;j<i;++j)\n\ta.push_back(make_pair(make_pair(j,i),max(0.0,sqrt(dis(x[i]-x[j],y[i]-y[j],z[i]-z[j]))-r[i]-r[j])));\n    }\n    sort(a.begin(),a.end(),pi());\n    int b[100];\n    for(i=0;i<n;++i)\n      b[i]=i;\n    double sm=0;\n    j=1;\n    for(i=0;j<n;++i){\n      int p,q;\n      double r;      \n      p=a[i].first.first;\n      q=a[i].first.second;\n      r=a[i].second;\n      if(b[p]==b[q])\n\tcontinue;\n      sm+=r;\n      for(k=0;k<n;++k){\n\tif(k!=q&&b[k]==b[q])\n\t  b[k]=b[p];\n      }\n      b[q]=b[p];\n      ++j;\n    }\n    printf(\"%.3lf\\n\",sm);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nstruct UnionFind {\n    vector<int> par; // uf(x,y)->y\n    UnionFind() {}\n    UnionFind(int NV) { init(NV); }\n    void init(int NV) { par.clear(); rep(i, 0, NV) par.push_back(i); }\n    void reset() { rep(i, 0, par.size()) par[i] = i; }\n    int operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n    void operator()(int x, int y) { x = operator[](x); y = operator[](y); if (x != y) par[x] = y; }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\nint N;\ndouble X[101], Y[101], Z[101], R[101];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> N) {\n        if (N == 0) return;\n        rep(i, 0, N) cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\n        vector<pair<double, pair<int, int>>> E;\n        rep(a, 0, N) rep(b, a + 1, N) {\n            double dx = X[a] - X[b];\n            double dy = Y[a] - Y[b];\n            double dz = Z[a] - Z[b];\n            double d = sqrt(dx*dx + dy * dy + dz*dz);\n\n            double c = max(0.0, d - R[a]- R[b]);\n\n            E.push_back({ c, {a, b} });\n        }\n        sort(all(E));\n\n        UnionFind uf(N);\n        double ans = 0;\n        fore(p, E) {\n            double a; int b, c;\n            a = p.first;\n            b = p.second.first;\n            c = p.second.second;\n\n            if (uf[b] != uf[c]) {\n                uf(b, c);\n                ans += a;\n            }\n        }\n\n        printf(\"%.3f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\nusing P = pair<int, int>;\n\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\n\n\nint main() {\n  while(true) {\n    int n;\n    double x[100], y[100], z[100], r[100];\n    vector<pair<double, pair<double, double>>> es;\n    cin >> n;\n    if(n == 0) break;\n    rep(i, n) {\n      double a, b, c, d;\n      cin >> a >> b >> c >> d;\n      x[i] = a;\n      y[i] = b;\n      z[i] = c;\n      r[i] = d;\n    }\n\n    UnionFind tree(n);\n\n    for(int i = 0; i < n; i++) {\n      for(int j = i+1; j < n; j++) {\n        double dist = (x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) + (z[i]-z[j]) * (z[i]-z[j]);\n        dist = sqrt(dist); \n        // cout << dist << endl;\n        if(dist <= r[i] + r[j]) {\n          tree.unite(i, j);\n          continue;\n        }\n        if(dist > r[i] + r[j]) {\n          pair<double, pair<double, double>> p;\n          p.first = dist - r[i] - r[j];\n          p.second.first = i;\n          p.second.second = j;\n          es.push_back(p);\n          // cout << p.first << \" \" << i << \" \" << j << endl;\n          // cout << 1 << endl;\n        }\n      }\n    }\n\n    sort(es.begin(), es.end());\n\n\n    double ans = 0.000;\n\n    for(int i = 0; i < es.size(); i++) {\n      int nx, ny;\n      nx = es[i].second.first;\n      ny = es[i].second.second;\n      if(tree.same(nx, ny)) {\n        continue;\n      } else {\n        tree.unite(nx, ny);\n        ans += es[i].first;\n        // cout << std::fixed << std::setprecision(3) << es[i].first << endl;\n      }\n    }\n    // cout << endl;\n    cout << std::fixed << std::setprecision(3) << ans << endl;\n    // cout << std::fixed << std::setprecision(3) << es[0].first << endl;\n    // cout << std::fixed << std::setprecision(3) << x[0] << endl;\n    // cout << std::fixed << std::setprecision(3) << y[0] << endl;\n    // cout << std::fixed << std::setprecision(3) << z[0] << endl;\n    // cout << std::fixed << std::setprecision(3) << es[0].first << endl;\n\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\t// ------ Variables ------ //\n\tstatic const long double INF = 1000000000000000000;\n\tint V, E; vector<vector<pair<int, long double> > > G;\n\n\t// ------ Constructors ------ //\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long double> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long double> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long double> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\n\t// ------ Basic Functions ------ //\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long double w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long double w) { add1(v1, v2, w); add1(v2, v1, w); }\n\n\t// ------ Operators ------ //\n\tbool operator==(const Graph2& g) const { return G == g.G; }\n\tbool operator!=(const Graph2& g) const { return G != g.G; }\n\tvector<pair<int, long double> > operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tlong double minspan() {\n\t\tvector<long double> d(V, INF);\n\t\tvector<bool> used(V, false);\n\t\tpriority_queue<pair<long doubleg, int> > que;\n\t\tfor (int i = 0; i < V; i++) d[i] = INF;\n\t\td[0] = 0; que.push(make_pair(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int> pa = que.top(); que.pop();\n\t\t\tint u = pa.second; used[u] = true;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first;\n\t\t\t\tif (d[v] > G[u][i].second && !used[v]) {\n\t\t\t\t\td[v] = G[u][i].second; que.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double sum = 0;\n\t\tfor (int i = 0; i < V; i++) sum += d[i];\n\t\treturn sum;\n\t}\n};\n// ------ Main ------ //\nint n; long double x[111], y[111], x[111], r[111];\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tGraph2 G(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tlong double dist = sqrtl((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\tG.add2(i, j, (dist > r[i] + r[j]) ? (dist - r[i] - r[j]) : 0)\n\t\t\t}\n\t\t}\n\t\tcout << G.minspan() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst double INF = 1000000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\t//if(i==j)\n\t\t\t\t//\tcontinue;\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\tif(cost[i][j]<0)\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\ntypedef pair<double ,pair<int, int> > pdii; // distance, point1, point2\n\nint n;\ndouble dis[100][100];\nint unit[100];\nvector<pdii> difdis(100);\n\ndouble x[100], y[100], z[100], r[100];\ndouble cordis;\n\ndouble dis3d(double x1, double y1, double z1, double x2, double y2, double z2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n}\n\nbool allunited(){\n    int u = unit[0];\n    REP(i, n){\n        if(unit[i] != u) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        REP(i, n){\n            cin >> x[i];\n            cin >> y[i];\n            cin >> z[i];\n            cin >> r[i];\n        }\n\n        REP(i, n){\n            REP(j, n){\n                if(i==j){\n                    dis[i][j] = 0;\n                } else {\n                    dis[i][j] = dis3d(x[i], y[i], z[i], x[j], y[j], z[j]) - (r[i]+r[j]);\n                }\n            }\n        }\n\n        REP(i, n) unit[i] = i;\n        REP(i, n){\n            for(int j=i+1; j<n; j++){\n                if(dis[i][j]<=0){\n                    unit[j] = unit[i];\n                }\n            }\n        }\n\n        cordis = 0;\n        while(1){\n            if(allunited()) break;\n\n            difdis = vector<pdii>();\n            REP(i, n){\n                for(int j=i+1; j<n; j++){\n                    if(unit[i] != unit[j]){\n                        difdis.push_back(pdii(dis[i][j], make_pair(i, j)));\n                    }\n                }\n            }\n\n            sort(difdis.begin(), difdis.end());\n            cordis += difdis[0].first;\n            int ci = difdis[0].second.first;\n            int cj = difdis[0].second.second;\n            \n            int ucj = unit[cj];\n            REP(i, n){\n                if(unit[i] == ucj){\n                    unit[i] = unit[ci];\n                }\n            }\n        }\n\n        cout << fixed << setprecision(3) << cordis << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    \n    printf(\"%lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<cmath>\n#include<set>\nusing namespace std;\n\n#define NONE DBL_MAX\n\nstruct Sphere{\n  double x,y,z,r;\n};\n\ndouble dist(Sphere a, Sphere b)\n{\n  double d=sqrt( pow(a.x-b.x,2.0)+pow(a.y-b.y,2.0)+pow(a.z-b.z,2.0) );\n  return a.r+b.r<d?d-a.r-b.r:0.0;\n}\n\ndouble prim(vector< vector<double> >v)\n{\n  double sum=0.0;\n  int n=v.size();\n  set<int>selected;\n  set<int>::iterator it;\n  double mincost;\n  int mini;\n  selected.insert(0);\n  while(selected.size()!=n){\n    mincost=DBL_MAX;\n    for(it=selected.begin();it!=selected.end();it++){\n      for(int i=0;i<n;i++){\n        if(selected.find(i)!=selected.end())continue;\n        if(v[*it][i]==NONE)continue;\n        if(v[*it][i]>=mincost)continue;\n        mincost=v[*it][i];\n        mini=i;\n       }\n     }\n    if(mini==NONE)break;\n    sum+=mincost;\n    selected.insert(mini);\n  }\n  return sum;\n}\n\nint main()\n{\n  int n;\n  double x,y,z,r;\n  while(cin>>n,n){\n    vector<Sphere>list(n);\n    vector< vector<double> >A(n,vector<double>(n,NONE));\n    for(int i=0;i<n;i++)cin>>list[i].x>>list[i].y>>list[i].z>>list[i].r;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tA[i][j]=A[j][i]=dist(list[i],list[j]);\n      }\n    }\n    printf(\"%.3f\\n\",prim(A));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n\n\nstruct Union_Find\n{\n    vector <int> parent;\n    Union_Find(int N) : parent(N)\n    {\n        for(int i = 0; i < N; i++) parent[i] = i;\n    }\n    int root(int n)\n    {\n        if (parent[n]==n) return n;\n        else\n        {\n            return root(parent[n]);\n        }\n    }\n\n    void unite(int i,int j)\n    {\n        int rx,ry;\n        rx=root(i);\n        ry=root(j);\n        if (rx==ry) return;\n        else\n        {\n            \n            if (rx<ry)\n            {\n                parent[ry]=rx;\n                return;\n            }\n            else\n            {\n                parent[rx]=ry;\n                return;\n            }\n        }\n    }\n    bool same(int i, int j)\n    {\n        if (root(i)==root(j)) return true;\n        else return false;\n    }\n};\n\nint main()\n{\n    int N;\n    while (true)\n    {\n        cin >> N;\n        if (N==0) break;\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>> que;\n        vector<tuple<double,double,double,double>> cells(N);\n        double x,y,z,r;\n        for (int i=0;i<N;i++)\n        {\n            cin >> x >> y >> z >> r;\n            cells[i]=make_tuple(x,y,z,r);\n        } \n        for (int i=0;i<N;i++)\n        {\n            for (int j=i+1;j<N;j++)\n            {\n                double x1,x2,y1,y2,z1,z2,r1,r2;\n                x1=get<0>(cells[i]);\n                y1=get<1>(cells[i]);\n                z1=get<2>(cells[i]);\n                r1=get<3>(cells[i]);\n                x2=get<0>(cells[j]);\n                y2=get<1>(cells[j]);\n                z2=get<2>(cells[j]);\n                r2=get<3>(cells[j]);\n                double R=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n                R=R-r1-r2;\n                if (R<0) R=0;\n                que.push(mp(R,mp(i,j)));\n            }\n        }\n        int a,b;\n        Union_Find solve(N);\n        double ans=0;\n        while (!que.empty())\n        {\n            a=que.top().second.first;\n            b=que.top().second.second;\n            if (!solve.same(a,b))\n            {\n                solve.unite(a,b);\n                ans+=que.top().first;\n            }\n            que.pop();\n        }\n        cout <<fixed <<setprecision(3) << ans << endl;\n    }\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define MAX_V 100\n#define MAX_E 10000\nint V,E,par[MAX_V],rnk[MAX_V];\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n \nEdge es[MAX_E];\n \nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n \nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n \n  if(x == y) return;\n \n  if(rnk[x] < rnk[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rnk[x] == rnk[y]){\n      rnk[x]++;\n    }\n  }\n}\n \nbool same(int x,int y){\n  return find(x) == find(y);\n}\n \ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n \ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n \nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[MAX_V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n     \n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.3f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nstruct point{\n    double x;\n    double y;\n    double z;\n    double r;\n};\n\npoint p[100];\ndouble d[100][100];\n\ndouble get_dist(point a, point b){\n    double tmp = sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0) + pow(a.z - b.z, 2.0));\n    return max(tmp - (a.r + b.r), 0.0);\n}\n\nvoid calc_dist(int n){\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = get_dist(p[i], p[j]);\n            d[i][j] = dist;\n            d[j][i] = dist;\n        }\n    }\n}\n\ndouble prim(int n){\n    bool used[100];\n    double mincost[100];\n    double inf = 100000.0;\n    for (int i = 0; i < n; i++) {\n        used[i] = false;\n        mincost[i] = inf;\n    }\n    mincost[0] = 0.0;\n    double res = 0.0;\n    \n    while (true) {\n        int v = -1;\n        for (int u = 0; u < n; u++) {\n            if (!used[u] && (v == -1 || mincost[u] < mincost[v]))\n                v = u;\n        }\n        if (v == -1) break;\n        used[v] = true;\n        res += mincost[v];\n        for (int u = 0; u < n; u++) {\n            mincost[u] = min(mincost[u], d[v][u]);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n        }\n        calc_dist(n);\n        printf(\"%.3f\\n\",prim(n));\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z;\n\tfor(;cin>>n,n;){\n\t\tvector<tuple<double,double,double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z,v.push_back(make_tuple(x,y,z));\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=fabs(get<k>(v[i])-get<k>(v[j]));\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127\n//Building a Space Station\n#include <bits/stdc++.h>\n#if LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\nusing namespace std;\nusing ll=long long;\nconst ll LINF = 0x1fffffffffffffff;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\ntemplate<class T>bool chmax(T &a, const T &b) {if (a<b) { a=b; return 1; } return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if (b<a) { a=b; return 1; } return 0;}\n\ntemplate< typename T >\nstruct edge {\n\tint src, to;\n\tT cost;\n\tedge(int _to, T _cost) : src(-1), to(_to), cost(_cost) {}\n\tedge(int _src, int _to, T _cost) : src(_src), to(_to), cost(_cost) {}\n\tedge &operator=(const int &x) {\n\t\tto = x;\n\t\treturn *this;\n\t}\n\toperator int() const { return to; }\n};\n\ntemplate< typename T>\nstruct node {\n\tvector<edge<T>> edges;\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< node< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nbool operator<(const edge<T> &e, const edge<T> &f) { return e.cost > f.cost; }\ntemplate< typename T >\nstd::pair<T, Edges<T>> prim(const WeightedGraph<T> &g, int r = 0) {\n  Edges<T> edges;\n  T total = T();\n  std::vector<int> vis(g.size());\n  std::priority_queue<edge<T>> q;\n  q.emplace(-1, r, 0);\n  while (q.size()) {\n    auto e = q.top();\n    q.pop();\n    if (vis[e.to]) continue;\n    vis[e.to] = true;\n    total += e.cost;\n    if (e.src != -1) edges.emplace_back(e);\n    for (auto &f : g[e.to].edges)\n      if (!vis[f.to]) q.emplace(f);\n  }\n  return std::make_pair(total, edges);\n}\n\nbool solve(){\n  ll n; cin>>n;\n  if(n<=0) return false;\n  struct Posr{\n    double x,y,z,r;\n  };\n  vector<Posr> tbl;\n  REP(i,n){\n    Posr pr;\n    cin>>pr.x>>pr.y>>pr.z>>pr.r;\n    tbl.emplace_back(move(pr));\n  }\n  auto length = [](const Posr& p0, const Posr& p1){\n    auto x=p0.x-p1.x;\n    auto y=p0.y-p1.y;\n    auto z=p0.z-p1.z;\n    return sqrt(x*x+y*y+z*z);\n  };\n\n  WeightedGraph<double> graph(n);\n  FOR(i,0,tbl.size()){\n    FOR(j,i+1,tbl.size()){\n      const auto& p0=tbl.at(i);\n      const auto& p1=tbl.at(j);\n      auto len = length(p0,p1);\n      auto cost=max<double>(0,len-p0.r-p1.r);\n      graph.at(i).edges.emplace_back(i,j,cost);\n      graph.at(j).edges.emplace_back(j,i,cost);\n    }\n  }\n\n  auto mst=prim(graph);\n  cout<<fixed<<std::setprecision(3)<<mst.first<<endl;\n\n  return true;\n}\nint main() {\n#if LOCAL&01\n  //std::ifstream in(\"./test/sample-1.in\");\n  std::ifstream in(\"./input.txt\");\n  std::cin.rdbuf(in.rdbuf());\n#else\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n#endif\n  while(solve()){\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,a,n) for(int i=(a); i<(n); i++)\n#define all(v) v.begin(), v.end()\n#define fi first\n#define se second\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nstruct UnionFind {\n\tvector<int> data;\n\n\tUnionFind(int sz) {\n\t\tdata.assign(sz, -1);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return;\n\t\tif (data[x] > data[y]) swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t}\n\n\tint find(int k) {\n\t\tif(data[k] < 0) return(k);\n\t\treturn data[k] = find(data[k]);\n\t}\n\n\tbool same(int x, int y)\t{\n\t\treturn find(x) == find(y);\n\t}\n\n\tint size(int k)\t{\n\t\treturn -data[find(k)];\n\t}\n};\n\nstruct edge{\n\tint u, v;\n\tdouble cost;\n};\n\nstruct sphere{\n\tdouble x, y, z, r;\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t// ifstream in(\"input.txt\");\n\t// cin.rdbuf(in.rdbuf());\n\n\n\twhile(true) {\n\t\tint n; cin >> n;\n\t\tif (!n) break;\n\n\t\tvector<sphere> a(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y, z, r; cin >> x >> y >> z >> r;\n\t\t\ta[i] = sphere{x, y, z, r};\n\t\t}\n\n\t\tvector<edge> b;\n\t\trep(i, n) FOR(j, i, n) {\n\t\t\tif (i==j) continue;\n\t\t\tdouble distance = \n\t\t\t\tpow(a[i].x-a[j].x, 2) +\n\t\t\t\tpow(a[i].y-a[j].y, 2) +\n\t\t\t\tpow(a[i].z-a[j].z, 2);\n\t\t\tdistance = max(0.0, pow(distance, 0.5) - a[i].r - a[j].r);\n\t\t\tb.push_back(edge{i, j, distance});\n\t\t}\n\n\t\tUnionFind uf(n);\n\t\tsort(all(b), [](edge& a, edge& b){return a.cost<b.cost;});\n\n\t\t// for(const auto&e: b) {\n\t\t// \tcout << e.u <<\" \" << e.v << \" \" << e.cost << endl;\n\t\t// }\n\n\t\tdouble ans = 0;\n\t\tfor(const auto& bb: b) {\n\t\t\tif (!uf.same(bb.u, bb.v)) {\n\t\t\t\tuf.unite(bb.u, bb.v);\n\t\t\t\tans += bb.cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << fixed << setprecision(3) << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS 0.001\n\ntypedef struct {\n  double x;\n  double y;\n  double z;\n  double r;\n} Cell;\n\nbool eq(double a, double b){\n  return abs(a-b) < EPS;\n}\n\ndouble cellLength( Cell a, Cell b){\n  double l = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)) - (a.r + b.r);\n  if(l <= 0) return 0;\n  else return l;\n}\n\nint main(void){\n  int n;\n  double btw[101][101];\n  Cell cell[101];\n  while(cin >> n, n){\n    for(int i=0; i < n; i++){\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      Cell tmp = {x, y, z, r};\n      cell[i] = tmp;\n    }\n\n    for(int p=0; p < n; p++){\n      for(int q=0; q < n; q++){\n        btw[p][q] = cellLength(cell[p], cell[q]);\n      }\n    }\n\n    //prim\n    double mincost[101];\n    bool used[101];\n    for(int i=0; i < n; i++){\n      mincost[i] = INT_MAX-1;\n      used[i] = false;\n    }\n    mincost[0] = 0;\n    double res = 0;\n\n    while(true){\n      int v = -1;\n      for(int u=0; u < n; u++){\n        if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n      }\n\n      if(v == -1) break;\n      used[v] = true;\n      res += mincost[v];\n\n      for(int u=0; u < n; u++){\n        mincost[u] = min(mincost[u], btw[v][u]);\n      }\n    }\n    printf(\"%f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])continue;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(22)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define REPR(i,n) for(int i=(n); i >= 0; --i)\n#define FOR(i, m, n) for(int i = (m); i < (n); ++i)\n// #define INF 1e9\nconst ll INF = 1LL << 60;\n\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i,n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nstruct Edge{\n  int a, b;\n  double cost;\n  Edge(int a = 0, int b= 0, double cost = 0){\n    this->a = a;\n    this->b = b;\n    this->cost = cost;\n  }\n  bool operator<(const Edge& o) const{\n    return cost < o.cost;\n  }\n};\n\nstruct Point{\n  double x, y, z;\n  Point(double x = 0, double y = 0, double z=0){\n    this->x = x;\n    this->y = y;\n    this->z = z;\n  }\n};\ndouble square(double a){\n  return a * a;\n}\ndouble calcDist(Point a, Point b){\n  return sqrt(square(a.x-b.x)+square(a.y-b.y)+square(a.z-b.z));\n}\n\nbool isCoverd(Point a, double ar, Point b, double br){\n  return calcDist(a, b) <= ar+br;\n}\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if(n==0) break;\n    vector<double> x(n), y(n), z(n), r(n);\n    vector<Point> pt(n);\n    REP(i, n){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n      pt[i] = Point(x[i], y[i], z[i]);\n    }\n    \n    UnionFind uf(n);\n    vector<Edge> edges;\n    REP(i, n){\n      FOR(j, i+1, n){\n        if(isCoverd(pt[i], r[i], pt[j], r[j])){\n          // cout << \"i:\" << i << \" j:\" << j << \" isCoverd\" << endl;\n          uf.unite(i, j);\n        }\n        else{\n          // cout << \"i:\" << i << \" j:\" << j << \" isNotCovered\" << endl;\n          edges.push_back(Edge(i, j, calcDist(pt[i], pt[j])-r[i]-r[j]));\n        }\n      }\n    }\n    sort(edges.begin(), edges.end());\n    // for(auto e: edges){\n    //   cout << \"a:\" << e.a << \" b:\" << e.b << \" cost:\" << e.cost << endl;\n    // }\n    // cout << \"--------------------------------------\" << endl;\n    double ans = 0;\n    for(auto e : edges){\n      if(!uf.same(e.a, e.b)){\n        ans += e.cost;\n        uf.unite(e.a, e.b);\n        // cout << \"a:\" << e.a << \" b:\" << e.b << \" cost:\" << e.cost << endl;\n      }\n    }\n    printf(\"%.3f\\n\", ans);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define rep(i, a, n) for(int i = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int i = (int)(a);(i) <= (int)(n);++(i))\n#define repif(i, a, x) for(int i = (int)(a);(x);++(i))\n#define repr(i, a, n) for(int i = ((int)(a)-1);(i) >= (int)(n);--(i))\n#define reper(i, a, n) for(int i = (int)(a);(i) >= (int)(n);--(i))\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define CEIL(x) ((int)ceil(((double)x)))\n#define POW(x, y) ((int)pow(x, y))\n#define UNIQUE(x) (x).erase(unique(ALL((x))), end(x))\n#define gcd(x, y) __gcd(x, y)\n#define lcm(x, y) ((x)/gcd(x,y)*(y))\n#define isin(x, l, r) ((l) <= (x) and (x) < (r))\n#define fcout(n) cout << fixed << setprecision(n)\n#define rcout(n) cout << right << setw(n)\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define PI (acosl(-1))\n#define EPS (1e-10)\n#define INF LLONG_MAX\n#define INF32 INT32_MAX\n#define MOD 1000000007LL\nusing namespace std;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing PII = pair<int, int>;\nusing TIII = tuple<int, int, int>;\nusing VPII = vector<pair<int, int>>;\nusing VTIII = vector<tuple<int, int, int>>;\nusing Complex = complex<double>;\ntemplate<typename T, template<typename> typename C = less> using PQ = priority_queue<T, vector<T>, C<T>>;\ntemplate<typename T> inline bool chmax(T& a, const T& b, bool t = false){ if(a<b or (t and a==b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a, const T& b, bool t = false){ if(a>b or (t and a==b)){ a=b; return true; } return false; }\n\n\ntemplate<typename T>\nstruct Kruskal {\n    struct Edge {\n        int from, to;\n        T cost;\n        bool used;\n        Edge(int from, int to, T cost) : from(from), to(to), cost(cost), used(false){}\n        bool operator<(const Edge& e) const {\n            return cost < e.cost;\n        }\n    };\n    struct UF {\n        vector<int> r, p;\n        UF() = default;\n        UF(int sz) : r(sz, 1), p(sz){ iota(begin(p), end(p), 0LL); }\n        int find(int x){\n            return (x == p[x] ? x : p[x] = find(p[x]));\n        }\n        bool same(int x, int y){\n            return find(x) == find(y);\n        }\n        void unite(int x, int y){\n            x = find(x), y = find(y);\n            if(x == y) return;\n            if(r[x] < r[y]) swap(x, y);\n            r[x] += r[y];\n            p[y] = x;\n        }\n    };\n    vector<Edge> es;\n    UF uf;\n    Kruskal() = default;\n    Kruskal(int n) : uf(n){}\n    void addEdge(int u, int v, T c){\n        es.emplace_back(u, v, c);\n    }\n    T build(){\n        sort(begin(es), end(es));\n        T res = 0;\n        for(auto& e : es){\n            if(!uf.same(e.from, e.to)){\n                res += e.cost;\n                uf.unite(e.from, e.to);\n                e.used = true;\n            }\n        }\n        return res;\n    }\n    Edge operator[](int i) const {\n        return es[i];\n    }\n    vector<Edge> edgeSet(){\n        return es;\n    }\n};\n\n\nstruct Point3D {\n    double x, y, z;\n    Point3D(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z){}\n};\ninline Point3D operator-(const Point3D& p, const Point3D& q){ return Point3D(p.x-q.x, p.y-q.y, p.z-q.z); }\ninline double norm(const Point3D& p){ return p.x*p.x+p.y*p.y+p.z*p.z; }\ninline double abs(const Point3D& p){ return sqrtl(norm(p)); }\n\n\nstruct Sphere {\n    Point3D p;\n    double r;\n    Sphere(double x = 0, double y = 0, double z = 0, double r = 0) : p(x, y, z), r(r){}\n};\ninline double dist(const Sphere& a, const Sphere& b){ return abs(a.p-b.p)-a.r-b.r; }\n\n\nsigned main(){\n    int n;\n    while(cin >> n, n){\n        vector<Sphere> s;\n        rep(i, 0, n){\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            s.emplace_back(x, y, z, r);\n        }\n        Kruskal<double> G(n);\n        rep(i, 0, n) rep(j, i+1, n){\n            double e = dist(s[i], s[j]);\n            if(e > EPS) G.addEdge(i, j, e);\n            else G.addEdge(i, j, 0);\n        }\n        fcout(3) << G.build() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst double EPS = 1e-10;\n\nint n;\ndouble x[110], y[110], z[110], r[110];\n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       for(int i = 0; i < n; i++) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nstruct edge{\n    int u, v;\n    double cost;\n    bool operator<(const edge &e) const{\n        return cost < e.cost;\n    }\n};\n\nvector<edge> es; \n\ndouble kruskal(){\n    double res = 0;    \n    UF uf(n);\n    sort(es.begin(), es.end());\n    for(int i = 0; i < es.size(); i++){\n        edge e = es[i];\n        if(!uf.same(e.u, e.v)){\n            uf.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\ndouble dist(int i, int j){\n    return sqrt((x[j]-x[i])*(x[j]-x[i]) + (y[j]-y[i])*(y[j]-y[i]) + (z[j]-z[i])*(z[j]-z[i]));\n}\n\nsigned main(){\n    while(cin >> n, n){\n        es.clear();\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                double tmp = dist(i, j) - r[i] - r[j];\n                if(tmp < EPS) tmp = 0.0;\n                es.push_back({i, j, tmp});\n            }\n        }\n        double ans = kruskal();\n        printf(\"%.10f\\n\", ans);\n    }    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS (10e-11)\n\nint solve() {\n\t\n\tint n;\n\tcin >> n;\n\tif( n == 0 ) return 1;\n\n\tvector< vector< long double > > src(4, vector< long double >( n ) );\n\tvector< vector< long double > > dist(n, vector< long double >( n, 0.0 ) );\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < 4; j++ ) {\n\t\t\tcin >> src[j][i];\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = i + 1; j < n; j++ ) {\n\t\t\tlong double d = sqrt( \n\t\t\t\t(src[0][i] - src[0][j]) * (src[0][i] - src[0][j]) + \n\t\t\t\t(src[1][i] - src[1][j]) * (src[1][i] - src[1][j]) +\n\t\t\t\t(src[2][i] - src[2][j]) * (src[2][i] - src[2][j]) );\n\t\t\tif( d > src[3][i] + src[3][j] + EPS ) {\n\t\t\t\td -= src[3][i] + src[3][j];\n\t\t\t\tdist[j][i] = d;\n\t\t\t\tdist[i][j] = dist[j][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double distsum = 0.0;\n\tbitset<100> flg(0);\n\tflg.set(0);\n\t\t\n\twhile( flg.count() < n ) {\n\t\tlong double mindist = 10e20;\n\t\tint p, q;\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tif( !flg[j] ) continue;\t\t\t//j????¨????????????????\n\t\t\tfor( int k = 0; k < n; k++ ) {\n\t\t\t\tif( flg[k] ) continue;\t\t//k???????¨??????????\n\t\t\t\tif( j == k ) continue;\n\t\t\t\tif( dist[j][k] + EPS < mindist ) {\n\t\t\t\t\tp = j;\n\t\t\t\t\tq = k;\n\t\t\t\t\tmindist = dist[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdistsum += mindist;\n\t\tflg.set(q);\n\t}\n\n\tprintf(\"%.6llf\\n\",distsum);\n\n\treturn 0;\n}\n     \nint main(void){\n\twhile(1){\n\t\tif( solve() ) break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nstruct point{\n  double x, y, z, r;\n  point(){}\n  point(double x, double y, double z, double r):x(x), y(y), z(z), r(r){}\n};\nbool used[111];\nint n;\n\npoint pos[111];\n\ndouble dist(point p, point q)\n{\n  double x = p.x - q.x, y = p.y - q.y, z = p.z - q.z;\n  double d = sqrt(x*x + y*y + z*z);\n  return max(d - p.r - q.r, 0.0);\n}\n\ndouble prim()\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  double total = 0.0;\n  fill(used, used + 111, false);\n  que.push(P(0.0, 0));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int now = p.second;\n    double d = p.first;\n    if(used[now]) continue;\n    used[now] = true;\n    total += d;\n    for(int i = 0; i < n; i++){\n      if(i == now) continue;\n      que.push(P(dist(pos[now], pos[i]), i));\n    }\n  }\n  return total;\n}\n\nint main()\n{\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      pos[i] = point(x, y, z, r);\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst double INF = 1000000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\t//UnionFindTree uft(n);\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tfor(int j = i+1; j < n; j++){\n\t\t//\t\t//if(i==j)\n\t\t//\t\t//\tcontinue;\n\t\t//\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t//\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t//\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t//\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t//\t\tif(EQ(dist,(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r))){\n\t\t//\t\t\tuft.unite(i,j);\n\t\t//\t\t\tbreak;\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\t//if(uft.same(i,j)){\n\t\t\t\t//\tcost[i][j]=0;\n\t\t\t\t//}\n\t\t\t\t//else{\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\tif(cost[i][j]<0)\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define REP(i, d, n) for(int i=(d); i<(n); ++i)\n#define all(v) v.begin(), v.end()\n\nvector<double> x, y, z, r;\n\ndouble getdist(int a, int b) {\n\tdouble dx = x[a] - x[b];\n    double dy = y[a] - y[b];\n    double dz = z[a] - z[b];\n\tdouble d = sqrt(dx * dx + dy * dy + dz * dz);\n\treturn max(d - (r[a] + r[b]), 0.);\n}\n\ndouble prim(int n) {\n    using P = pair<double, int>;\n    \n    double res = 0.;\n    vector<bool> used(n, false);\n    // P -> first : コスト, second : 行先\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.emplace(0., 0);\n    // コストが小さい順に出しいく\n    while (!que.empty()) {\n        P p = que.top();\n        que.pop();\n        if(used[p.second]){\n            continue;\n        }\n        int pos = p.second;\n        used[pos] = true;\n        res += p.first;\n        for(int i = 0; i < n; ++i){\n            if(!used[i] && i != pos){\n                que.emplace(getdist(pos, i), i);\n            }\n        }\n    }\n    return res;\n}\n\nsigned main() {\n\n    int n;\n    while(true){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        x.resize(n); \n        y.resize(n);\n        z.resize(n);\n        r.resize(n);\n        rep(i, n){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        cout << fixed << setprecision(3) << prim(n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define IOS std::cin.tie(0),std::ios::sync_with_stdio(false)\n\nnamespace idaten {\n\n\tusing namespace std;\n\tusing ll = int_fast64_t;\n\tusing ull = uint_fast64_t;\n\tusing P = std::pair<int64_t, int64_t>;\n\ttemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\n\ttemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\n\ttemplate<class T> inline std::istream& operator >> (std::istream& is, std::vector<T>& v) { for (T& x : v) { is >> x; }return is; }\n\ttemplate<class T> inline std::ostream& operator << (std::ostream& os, const std::vector<T>& v) {\n\t\tfor (auto itr = v.begin(); itr != v.end();) { os << (*itr) << ((++itr != v.end()) ? \" \" : \"\"); }\n\t\treturn os;\n\t}\n\ttemplate<class V, typename T>inline void fill(V& v, const T& val) { v = val; }\n\ttemplate<class V, typename T>inline void fill(std::vector<V>& v, const T& val) { for (V& x : v) { fill(x, val); } }\n\ttemplate<class V, typename H>inline void resize(std::vector<V>& v, const H h) { v.resize(h); }\n\ttemplate<class V, typename H, typename... T>inline void resize(std::vector<V>& v, const H& h, const T& ... t) { v.resize(h); for (auto& x : v) { resize(x, t...); } }\n\tinline void put() {}\n\ttemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\n\ttemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\n\n\tclass UnionFind {\n\tprivate:\n\t\tvector<int> par, height, size;\n\tpublic:\n\t\tUnionFind(int n) {\n\t\t\tpar.resize(n);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t\theight.resize(n, 0);\n\t\t\tsize.resize(n, 1);\n\t\t}\n\t\tint root(int x) {\n\t\t\tif (par[x] == x) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\tpar[x] = root(par[x]);\n\t\t\t\treturn par[x];\n\t\t\t}\n\t\t}\n\t\tbool same(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tvoid unite(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)return;\n\t\t\tif (height[x] < height[y]) {\n\t\t\t\tpar[x] = y;\n\t\t\t\tsize[y] += size[x];\n\t\t\t} else {\n\t\t\t\tpar[y] = x;\n\t\t\t\tsize[x] += size[y];\n\t\t\t\tif (height[x] == height[y])height[x]++;\n\t\t\t}\n\t\t}\n\t\tint cnt(int x) {\n\t\t\tx = root(x);\n\t\t\treturn size[x];\n\t\t}\n\t};\n\n\ttemplate<typename T>\n\tclass MinimumSpanningTree {\n\tprivate:\n\t\tvector<int> from, to;\n\t\tvector<pair<T, int>> cost;\n\t\tint n, m;\n\tpublic:\n\t\tMinimumSpanningTree<T>(vector<int>& from, vector<int>& to, vector<T>& cost, int n) : from(from), to(to), n(n) {\n\t\t\tthis->m = (int)cost.size();\n\t\t\tthis->cost.resize(m);\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tthis->cost[i].first = cost[i];\n\t\t\t\tthis->cost[i].second = i;\n\t\t\t}\n\t\t\tsort(this->cost.begin(), this->cost.end());\n\t\t}\n\t\tvector<int> Kruskal() {\n\t\t\tvector<int> res; //mstを構成するindexの集合\n\t\t\tUnionFind uf(this->n);\n\t\t\tfor (int i = 0; i < this->m; ++i) {\n\t\t\t\tint index = this->cost[i].second;\n\t\t\t\tif (!uf.same(this->from[index], this->to[index])) {\n\t\t\t\t\tres.push_back(index);\n\t\t\t\t\tuf.unite(this->from[index], this->to[index]);\n\t\t\t\t}\n\t\t\t\tif (res.size() == n - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\n\n\tvoid solve() {\n\t\tIOS;\n\t\tint n;\n\t\tcin >> n;\n\t\tcout << fixed << setprecision(3);\n\t\twhile (n) {\n\t\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\t\tREP(i, n) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t\t}\n\t\t\tvector<int> from, to;\n\t\t\tvector<double> cost;\n\t\t\tREP(i, n) {\n\t\t\t\tFOR(j, i + 1, n) {\n\t\t\t\t\tdouble dx = (x[i] - x[j]);\n\t\t\t\t\tdouble dy = (y[i] - y[j]);\n\t\t\t\t\tdouble dz = (z[i] - z[j]);\n\t\t\t\t\tdouble c = sqrt(dx * dx + dy * dy + dz * dz);\n\t\t\t\t\tc = max(0.0, c - r[i] - r[j]);\n\t\t\t\t\tfrom.push_back(i);\n\t\t\t\t\tto.push_back(j);\n\t\t\t\t\tcost.push_back(c);\n\t\t\t\t\t//to.push_back(i);\n\t\t\t\t\t//from.push_back(j);\n\t\t\t\t\t//cost.push_back(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMinimumSpanningTree<double> mst(from, to, cost, n);\n\t\t\tauto krs = mst.Kruskal();\n\t\t\tdouble res = 0;\n\t\t\tfor (auto&& v : krs) {\n\t\t\t\tres += cost[v];\n\t\t\t}\n\t\t\tput(res);\n\t\t\tcin >> n;\n\t\t}\n\t\t\n\t}\n} // namespace idaten\n\nint main() {\n\tidaten::solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n\n// Union-Findの実装\nconst int MAX_N = 10000; // 今回の場合、頂点の数の最大値\n\nstruct UnionFind\n{\n  // par[i]:要素iが属する木の親の番号、i==par[i]のときは要素iが木の根となる\n  int par[MAX_N];\n  \n  // rank[i]:根が要素iの木の高さ(ランク)\n  int rank[MAX_N];\n  \n  // コンストラクタ\n  // 各要素iが要素iを根とする高さ0の木に存在するものとして初期化を行う\n  UnionFind(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  // 要素xが属する木の根を得るメソッド\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  // 2つの要素xとyが属する木を併合するメソッド\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属している場合\n    if(x == y) return;\n\n    // 効率化の工夫としてランクが低いものから高いものへ辺を張る\n    if(rank[x] < rank[y]) par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++; // ランクが等しい場合\n    }\n  }\n\n  // 2つの要素xとyが属する木の根が同じならtrueを返すメソッド\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\n\n// 辺の情報を表す構造体\nstruct Edge{\n  int u, w;\n  double cost;\n};\n\n// Edgeをコストの小さい順にソートするための比較関数\nbool comp(const Edge &e1, const Edge &e2)\n{\n  return e1.cost < e2.cost;\n}\n\nconst int MAX_E = 100000; // 辺の数の最大値\nEdge es[MAX_E]; // グラフ上の辺を保存する配列\nint v, e; // 頂点の数と辺の数\n\n\ndouble kruskal()\n{\n  sort(es, es + e, comp); // 辺をコストの小さい順にソート\n  UnionFind uf(v); // Union-Findの準備\n  double ans = 0; // 最小全域木(森)の辺の総コスト\n\n  // 全域木に辺を追加していく\n  for(int i = 0; i < e; i++){\n    // コストの小さい辺から調べる\n    Edge et = es[i];\n\n    // もし辺の両端の頂点が同じ連結成分属していないならば\n    if(!uf.same(et.u, et.w)){\n      uf.unite(et.u, et.w); // 同じ連結成分に属させる\n      ans += et.cost; // その辺を全域木に追加\n    }\n  }\n\n  return ans;\n}\n\ntypedef struct sphere{\n  double x, y, z, r;\n} Sphere;\n\n\nint main()\n{\n  int n;\n  cin >> n;\n  v = n;\n  e = 0;\n  for(int i = n - 1; i > 0; i--)\n    e += i;\n  Sphere s[100];\n  for(int i = 0; i < n; i++)\n    cin >> s[i].x >> s[i].y >> s[i].z >> s[i].r;\n  for(int i = 0, k = 0; i < n; i++){\n    for(int j = i + 1; j < n; j++, k++){\n      Edge et;\n      et.u = i;\n      et.w = j;\n      et.cost = sqrt(pow(s[i].x - s[j].x, 2) + pow(s[i].y - s[j].y, 2) + pow(s[i].z - s[j].z, 2)) - s[i].r - s[j].r;\n      if(et.cost < 0)\n        et.cost = 0;\n      es[k] = et;\n    }\n  }\n  printf(\"%.3lf\\n\", kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<stdio.h>\nusing namespace std;\n#define inf 1<<21\nstruct cell{\n  double x,y,z,r;\n};\ndouble dis(cell a,cell b){\n  double o=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z))-(a.r+b.r);\n  if(o<=0) return 0;\n  return o;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int i,j,k;\n    vector<cell> cells;\n    cell c;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.z >> c.r;\n      cells.push_back(c);\n    }\n    \n    double cost[100][100]={{}};\n    for(i=0;i<n;i++){\n      for(j=i;j<n;j++){\n\tif(i==j) cost[i][j]=inf;\n\telse{\n\t  cost[i][j]=dis(cells[i],cells[j]);\n\t  cost[j][i]=cost[i][j];\n\t  //cout << cost[i][j] << \":\" << i << j << endl;\n\t}\n      }\n    }\n    \n    int color[100]={},d[100]={},p[100]={};\n    fill(d,d+100,inf);\n    fill(p,p+100,-1);\n    double sum=0,minv;\n    int u;\n    d[0]=0;\n    while(1){\n      minv=inf;\n      u=-1;\n      for(i=0;i<n;i++){\n\tif(minv>d[i]&&color[i]!=2){\n\t  u=i;\n\t  minv=d[i];\n\t}\n      }\n      if(u==-1) break;\n      color[u]=2;\n      for(i=0;i<n;i++){\n\tif(color[i]!=2&&u!=i){\n\t  if(d[i]>cost[u][i]){\n\t    d[i]=cost[u][i];\n\t    p[i]=u;\n\t    color[i]=1;\n\t  }\n\t}\n      }\n      \n    }\n    for(i=0;i<n;i++){\n      //  cout << p[i] << endl;\n      if(p[i]!=-1) sum+=cost[i][p[i]];\n    }\n    printf(\"%.3f\\n\",sum);\n    \n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[111], y[111], z[111], r[111];\ndouble d[111][111];\nint visit[111];\n\nint main(){\n\tint n;\n\twhile(cin>>n, n){\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tREP(i,n)FOR(j,i+1,n)d[i][j] = d[j][i] = max(sqrt(pow(x[i]-x[j], 2.0)+pow(y[i]-y[j], 2.0)+pow(z[i]-z[j], 2.0))-r[i]-r[j], 0.0);\n\t\tpriority_queue<pair<double, PII>, vector<pair<double,PII> >, greater<pair<double,PII> > > q;\n\t\tvisit[0]=1;\n\t\tFOR(i,1,n)q.push(MP(d[0][i], MP(0, i)));\n\t\tdouble ret = 0.0;\n\t\twhile(!q.empty()){\n\t\t\tpair<double, PII> tmp;\n\t\t\ttmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(visit[tmp.second.second])continue;\n\t\t\tret += tmp.first;\n\t\t\tvisit[tmp.second.second] = 1;\n\t\t\tREP(i,n)if(i!=tmp.second.second)q.push(MP(d[tmp.second.second][i], MP(tmp.second.second, i)));\n\t\t}\n\t\tprintf(\"%.3f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;scanf(\"%lf\",&a);return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    printf(\"%.3lf\\n\",prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最小全域技を求める\n// O(E log V)\n// verify http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_A\n\n\n// 最小全域木を求めるアルゴリズム\n// Union Find を使う方\n// O(E log V)\n// verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_A&lang=jp\n\nstruct UnionFind{\n    \n    vector<int> M_par;\n    vector<int> M_rank;\n    vector<int> M_size;\n\nprivate:\n    void init(int n = 1){\n        M_par.resize(n);\n        M_rank.resize(n);\n        M_size.resize(n);\n        for(int i = 0; i < n; i++){\n            M_par[i] = i;\n            M_rank[i] = 0;\n            M_size[i] = 1;\n        }\n    }\n\npublic:\n\n    UnionFind(size_t n = 1){\n        init(n);\n    }\n\n    size_t find(size_t x){\n        if(M_par[x] == x) return x;\n        size_t r = find(M_par[x]);\n        return M_par[x] = r;\n    }\n    \n    bool same(size_t x, size_t y){\n        return find(x) == find(y);\n    }\n\n    bool unite(size_t x, size_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(M_rank[x] < M_rank[y]) swap(x, y);\n        if(M_rank[x] == M_rank[y]) M_rank[x]++;\n        M_par[y] = x;\n        M_size[x] = M_size[x] + M_size[y];\n        return true;\n    }\n\n    size_t size(size_t x){\n        return M_size[find(x)];\n    }\n\n};\n\n\n// [入力] undirected-graph [出力] コスト\ntemplate<typename T>\nT kruskal(vector<vector<pair<int, T>>> &g){\n    \n    int n = (int)g.size();\n    //{cost, {to, from}}\n    vector<pair<T, pair<int, int>>> edges;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < g[i].size(); j++){\n            edges.push_back({g[i][j].second, {i, g[i][j].first}});\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n    UnionFind uf(n);\n    T ret = 0;\n    for(int i = 0; i < (int)edges.size(); i++){\n        if(uf.unite(edges[i].second.first, edges[i].second.second)) ret += edges[i].first;\n    }\n\n    return ret;\n}\n\nsigned main(){\n    \n    while(1){    \n        int n; cin >> n;\n        if(!n) break;\n        vector<vector<pair<int, double>>> g(n);\n        vector<double> x(n);\n        vector<double> y(n);\n        vector<double> z(n);\n        vector<double> r(n);\n        for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                \n                double cost = max(0.0, sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j])) - r[i] - r[j]);\n                if(cost < 1e-9) cost = 0.0;\n                g[i].push_back({j, cost});\n                g[j].push_back({i, cost});\n            }\n        }\n\n        double ans = kruskal<double>(g);\n        printf(\"%.3f\\n\", ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nstruct Node {\n\tlong double x, y, z, r;\n};\n\nlong double dis(Node a, Node b) {\n\tlong double ret = 0;\n\tret = max(ret, sqrt(powl(a.x - b.x, 2) + powl(a.y - b.y, 2) + powl(a.z - b.z, 2)) - a.r - b.r);\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N, N) {\n\t\tUnionFind uf(N);\n\t\tvector<Node>node(N);\n\t\tfor (auto &i : node) {\n\t\t\tcin >> i.x >> i.y >> i.z >> i.r;\n\t\t}\n\t\tvector<pair<long double, pair<int, int>>>edge;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tedge.push_back({ dis(node[i],node[j]),{i,j} });\n\t\t\t}\n\t\t}\n\t\tsort(edge.begin(), edge.end());\n\t\tlong double ans = 0;\n\t\tfor (auto i : edge) {\n\t\t\tif (uf.Check_Same(i.second.first, i.second.second))continue;\n\t\t\tans += i.first;\n\t\t\tuf.Unite(i.second.first, i.second.second);\n\t\t}\n\t\tcout << fixed << setprecision(3) << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nstruct point{\n  double x, y, z, r;\n  point(){}\n  point(double x, double y, double z, double r):x(x), y(y), z(z), r(r){}\n};\nbool used[111];\nint n;\n\npoint pos[111];\n\ndouble dist(point p, point q)\n{\n  double x = p.x - q.x, y = p.y - q.y, z = p.z - q.z;\n  double d = sqrt(x*x + y*y + z*z);\n  return max(d - p.r - q.r, 0.0);\n}\n\ndouble prim()\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  double total = 0.0;\n  fill(used, used + 111, false);\n  que.push(P(0.0, 0));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int now = p.second;\n    double d = p.first;\n    if(used[now]) continue;\n    used[now] = true;\n    total += d;\n    for(int i = 0; i < n; i++){\n      if(i == now) continue;\n      que.push(P(dist(pos[now], pos[i]), i));\n    }\n  }\n  return total;\n}\n\nint main()\n{\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      pos[i] = point(x, y, z, r);\n    }\n    printf(\"%.10f\\n\", prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi p,r,s;\n\tUnion_Find_Tree(int n){\n\t\tp=r=vi(n);\n\t\ts=vi(n,1);\n\t\tfor(int i=0;i<n;i++) p[i]=i;\n\t}\n\tint Par(int x){\n\t\tif(p[x]==x) return x;\n\t\treturn p[x]=Par(p[x]);\n\t}\n\tint Size(int x){return s[Par(x)];}\n\tbool Unite(int x,int y){\n\t\tx=Par(x);\n\t\ty=Par(y);\n\t\tif(x==y) return 0;\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\ts[y]+=s[x];\n\t\t}\n\t\telse{\n\t\t\tp[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tif(r[x]==r[y]) r[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){return Par(x)==Par(y);}\n};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvd x(n),y(n),z(n),r(n);\n\t\tvector<pair<double,P>> a;\n\t\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++){\n\t\t\tdouble X=x[j]-x[i],Y=y[j]-y[i],Z=z[j]-z[i];\n\t\t\tdouble d=sqrt(X*X+Y*Y+Z*Z);\n\t\t\ta.push_back(make_pair(max(0.0,d-(r[i]+r[j])),make_pair(i,j)));\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tUnion_Find_Tree uft(n);\n\t\tdouble res=0;\n\t\tfor(auto p:a){\n\t\t\tint u=p.second.first,v=p.second.second;\n\t\t\tif(!uft.Same(u,v)){\n\t\t\t\tuft.Unite(u,v);\n\t\t\t\tres+=p.first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = -1;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      res += d[t];\n      //if (p[t] != -1) res += map[t][p[t]];\n      //printf(\"res: %.3f\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    printf(\"%.3f\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<double, double> Pd;\ntypedef pair<double, Pd> PPd;\n\nint par[200];\nint ran[200];\ndouble x[200];\ndouble y[200];\ndouble z[200];\ndouble r[200];\n\nvoid init(int n){\n  for(int i = 0; i < n; i++){\n    par[i]  = i;\n    ran[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){ \n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return ;\n  if(ran[y] > ran[x]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(ran[y] == ran[x]) ran[x]++;\n  }\n}\n\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i = 0; i < n; i++){\n      scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n    }\n    init(n);\n    priority_queue<PPd, vector<PPd>, greater<PPd> > que;\n    for(int i = 1; i < n; i++){\n      for(int j= 0; j < i; j++){\n\tdouble dx = x[i] - x[j];\n\tdouble dy = y[i] - y[j];\n\tdouble dz = z[i] - z[j];\n\tque.push(PPd(sqrt(dx*dx + dy*dy + dz*dz) - r[i] - r[j], Pd(i, j)));\n      }\n    }\n    double res = 0;\n    while(!que.empty()){\n      PPd ppd = que.top();\n      que.pop();\n      if(!same(ppd.second.first, ppd.second.second)){\n\tunite(ppd.second.first, ppd.second.second);\n\tres += max(0.0, ppd.first);\n      }\n    }\n    cout << fixed << setprecision(3) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\nconst ll INF = 1LL << 50;\n\nconst ll mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<ll> par, sizes;\n  ll cnt;\n  UnionFind(ll N) : par(N), sizes(N, 1), cnt(N) {\n    for (ll i = 0; i < N; i++) par[i] = i;\n  }\n\n  ll find(ll x) { return par[x] == x ? x : par[x] = find(par[x]); }\n\n  bool same(ll x, ll y) { return find(x) == find(y); }\n\n  ll size(ll x) { return sizes[find(x)]; }\n\n  void unite(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n    cnt--;\n  }\n\n  ll count() const { return cnt; }\n};\n\nint main() {\n  using TD = tuple<double, ll, ll>;\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0) break;\n\n    vector<double> xs(n), ys(n), zs(n), rs(n);\n    rep(i, n) cin >> xs[i] >> ys[i] >> zs[i] >> rs[i];\n\n    priority_queue<TD, vector<TD>, greater<TD>> pq;\n    for (ll i = 0; i < n - 1; i++) {\n      for (ll j = 0; j < n; j++) {\n        double d = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n        d += (ys[i] - ys[j]) * (ys[i] - ys[j]);\n        d += (zs[i] - zs[j]) * (zs[i] - zs[j]);\n        d = max(0.0, sqrt(d) - rs[i] - rs[j]);\n        pq.emplace(d, i, j);\n      }  // j\n    }    // i\n    UnionFind uf(n);\n    double ans = 0.0;\n    while (!pq.empty()) {\n      double d;\n      ll u, v;\n      tie(d, u, v) = pq.top();\n      pq.pop();\n      if(!uf.same(u, v)){\n        uf.unite(u, v);\n        ans += d;\n      }\n    }\n    printf(\"%.3f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing edge = tuple<double, int, int>;  // w, s, t\n\nstruct unionFind {\n  vector<int> d;  // 根： 木のサイズ x -1, それ以外： 親のID\n  unionFind(int n = 0) : d(n, -1) {}\n  int find(int x) {\n    if (d[x] < 0) return x;\n    return d[x] = find(d[x]);\n  }\n  bool unite(int x, int y) {\n    // root化しておく\n    x = find(x);\n    y = find(y);\n    if (x == y) return false;\n\n    // x を y に unite\n    // d[x] のほうが多きい（=サイズが小さい）場合はswap\n    if (d[x] > d[y]) swap(x, y);\n    d[x] += d[y];\n    d[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -d[find(x)]; }\n} uf;\n\nvector<edge> G;\nint V;\n\nvoid kruskal() {\n  double ans = 0;\n  sort(G.begin(), G.end());\n  for (edge e : G) {\n    double w = get<0>(e);\n    int s = get<1>(e), t = get<2>(e);\n    if (!uf.same(s, t)) {\n      uf.unite(s, t);\n      ans += w;\n    }\n  }\n  printf(\"%.3lf\\n\", ans);\n}\n\nint main() {\n  while (1) {\n    cin >> V;\n    if (V == 0) break;\n    vector<double> x(V);\n    vector<double> y(V);\n    vector<double> z(V);\n    vector<double> r(V);\n    rep(i, V) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n    uf = unionFind(V);\n    rep(i, V) uf.d[i] = -1;\n    G = vector<edge>();\n    rep(i, V) rep(j, V) {\n      if (i == j) continue;\n      double dist =\n          sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) +\n               (z[i] - z[j]) * (z[i] - z[j])) -\n          (r[i] + r[j]);\n\n      // 触れていない場合は廊下を作る\n      // あとでkruskalで間引く\n      // 触れいているときはすでにつながっていると考える\n      if (dist > 0.0)\n        G.push_back(edge(dist, i, j));\n      else\n        uf.unite(i, j);\n    }\n    kruskal();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(3)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to;\n\tdouble cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstruct a\n{\n\tdouble x, y, z, r;\n};\nvector<a> v;\nint par[105];\nvector<edge> es;\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x == y) return;\n\tpar[y] = x;\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t}\n}\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tv.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, z, r;\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tv.push_back(a{ x, y, z, r });\n\t\t}\n\t\tes.clear();\n\t\tinit_UFT(n);\n\t\tREP(i, n)FOR(j, i + 1, n)\n\t\t{\n\t\t\tdouble dif = sqrt(pow((v[i].x - v[j].x), 2) + pow((v[i].y - v[j].y), 2) + pow((v[i].z - v[j].z), 2)) - v[i].r - v[j].r;\n\t\t\tif (dif > 0)\n\t\t\t{\n\t\t\t\tes.push_back(edge{ i, j, dif });\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunite(i, j);\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(es));\n\t\tdouble sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(par[es[i].from], par[es[i].to]))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << D10 << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,m,n) for(int i=(m); i<(int)(n); i++)\n#define RREP(i,m,n) for(int i=(int)(n-1); i>=m; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define fi first\n#define se second\n#define debug(...) {cerr<<\"[L\"<<__LINE__<<\"] \"; _debug(__VA_ARGS__);}\n\ntemplate<typename T>\nstring join(const vector<T>&v, string del=\", \"){ stringstream s;\n    for(auto x : v) s << del << x; return s.str().substr(del.size());\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<T>&v){\n    if(v.size()) o << \"[\" << join(v) << \"]\"; return o;\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<vector<T> >&vv){\n    int l = vv.size();\n    if(l){ o<<endl; rep(i,l) o << (i==0 ? \"[ \" : \",\\n  \" ) << vv[i] << (i==l-1 ? \" ]\" : \"\"); }\n    return o;\n}\ninline void _debug(){cerr<<endl;}\ntemplate<class First, class... Rest>\nvoid _debug(const First& first, const Rest&... rest){cerr<<first<<\" \";_debug(rest...);}\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nconst double PI = (1*acos(0.0));\nconst double EPS = 1e-9;\nconst int INF = 0x3f3f3f3f;\nconst ll INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst ll mod = 1e9 + 7;\n\ninline void finput(string filename) {\n    freopen(filename.c_str(), \"r\", stdin);\n}\n\nstruct UnionFind {\n    int n;\n    vector<int> dat;\n    UnionFind(int size): n(size), dat(size, -1) { }\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (dat[y] < dat[x]) swap(x, y);\n            dat[x] += dat[y];\n            dat[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n    int root(int x){\n        return dat[x] < 0 ? x : dat[x] = root(dat[x]);\n    }\n    int size(int x){\n        return -dat[root(x)];\n    }\n};\nstruct Edge{\n    int from, to;\n    double cost;\n    Edge(int from, int to, double cost) : from(from), to(to), cost(cost){}\n    bool operator<(const Edge &e){\n        return cost < e.cost;\n    }\n};\nstruct Sphere{\n    double x, y, z, r;\n    Sphere(double x, double y, double z, double r) : x(x), y(y), z(z), r(r){}\n};\ndouble calc_dist(Sphere &s1, Sphere &s2){\n    return sqrt((s1.x-s2.x)*(s1.x-s2.x) + (s1.y-s2.y)*(s1.y-s2.y) + (s1.z-s2.z)*(s1.z-s2.z));\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    // finput(\"./input\");\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        vector<Sphere> ss;\n        vector<Edge> es;\n        UnionFind uf(n);\n        rep(i,n){\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            ss.emplace_back(x, y, z, r);\n        }\n        rep(i,n) REP(j,i+1,n){\n            double d = calc_dist(ss[i], ss[j]);\n            double rd = (ss[i].r + ss[j].r);\n            if(d <= rd){\n                uf.unite(i, j);\n            }else{\n                es.emplace_back(i, j, d - rd);\n            }\n        }\n\n        auto kruskal = [&](){\n            sort(es.begin(), es.end());\n            double res = 0;\n            for(auto e : es){\n                if(!uf.same(e.from, e.to)){\n                    uf.unite(e.from, e.to);\n                    res += e.cost;\n                }\n            }\n            return res;\n        };\n        cout << fixed << setprecision(3) << kruskal() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SQ(a) ((a)*(a))\ntypedef tuple<double, int, int> Tp;\n#define at(t, i) get<i>(t)\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nstruct Point {\n\tdouble x, y, z;\n\tPoint(){}\n\tPoint(double x, double y, double z): x(x), y(y), z(z){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(){}\n\tCircle(double x, double y, double z, double r): p(x, y, z), r(r){}\n};\n\ninline double dist(Point &a, Point &b)\n{\n\treturn sqrt(SQ(a.x - b.x) + SQ(a.y - b.y) + SQ(a.z - b.z));\n}\n\ninline double dist(Circle &a, Circle &b)\n{\n\treturn max(0.0, dist(a.p, b.p) - a.r - b.r);\n}\n\nint n;\nCircle cs[100];\n\nint main()\n{\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdouble x, y, z, r;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &z, &r);\n\t\t\tcs[i] = Circle(x, y, z, r);\n\t\t}\n\t\t\n\t\tvector<Tp> es;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i == j) continue;\n\t\t\t\tes.push_back(Tp(dist(cs[i], cs[j]), i, j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(es.begin(), es.end());\n\t\t\n\t\tdouble res = 0.0;\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < es.size(); i++){\n\t\t\tdouble cost = at(es[i], 0);\n\t\t\tint a = at(es[i], 1), b = at(es[i], 2);\n\t\t\tif (uf.unite(a, b)) res += cost;\n\t\t}\n\t\t\n\t\tprintf(\"%.3f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nstruct UnionFind {\n\tvector<int> par;\n\t\n\tUnionFind(int n) : par(n) {\n\t\tfor (int i = 0; i < n; i++) par[i] = i;\n\t}\n\t\n\tint root(int x) {\n\t\treturn par[x] == x ? x : par[x] = root(par[x]);\n\t}\n\t\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x != y) par[x] = y;\n\t}\n\t\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n};\n\nstruct Cell { double x, y, z, r; };\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator <(const Edge &e) { return cost < e.cost; }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tvector<Cell> cells(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y, z, r;\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tcells[i] = {x, y, z, r};\n\t\t}\n\t\tvector<Edge> edges;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble dx = cells[i].x - cells[j].x;\n\t\t\t\tdouble dy = cells[i].y - cells[j].y;\n\t\t\t\tdouble dz = cells[i].z - cells[j].z;\n\t\t\t\tdouble dr = cells[i].r + cells[j].r;\n\t\t\t\tdouble cost = max(0.0, sqrt(dx * dx + dy * dy + dz * dz) - dr);\n\t\t\t\tedges.push_back({i, j, cost});\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tUnionFind uf(n);\n\t\tdouble ans = 0;\n\t\tfor (auto a : edges) {\n\t\t\tif (!uf.same(a.from, a.to)) {\n\t\t\t\tuf.unite(a.from, a.to);\n\t\t\t\tans += a.cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, P> DP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n//// UnionFind\nstruct UnionFind{\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t\treturn true;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint n;\ndouble x[111],y[111],z[111],r[111];\nvector<DP> es;\n\ndouble dist(int i,int j){\n\treturn sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2));\n}\n\nbool judge(int i,int j){\n\tif(dist(i,j)<=r[i]+r[j])return true;\n\telse return false;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tes.clear();\n\t\tUnionFind uf(n);\n\t\trep(i,n)rep(j,i){\n\t\t\tif(judge(i,j))uf.unite(i,j);\n\t\t\telse{\n\t\t\t\tes.pb(DP(dist(i,j)-r[i]-r[j],P(i,j)));\n\t\t\t}\n\t\t}\n\t\tsort(all(es));\n\t\tdouble res=0;\n\t\trep(i,es.size()){\n\t\t\tif(uf.same(es[i].se.fi,es[i].se.se))continue;\n\t\t\tres+=es[i].fi;\n\t\t\tuf.unite(es[i].se.fi,es[i].se.se);\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n//#include <cfenv>\n//#define _GNU_SOURCE 1\n#define square(x) ((x)*(x))\nusing namespace std;\nconst double INF = 1000.0;\n \n/*static void attribute((constructor)) trapfpe()\n{\nfeenableexcept(FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW);\n}\n*/ //何かの痕跡\nint n,a;\ndouble dis[100][101];\ndouble dis2[100][101];\ndouble fdis[100][101];\ndouble touch[100][101];\ndouble geo[100][5];\ndouble mincost[101];\nbool used[101];\nint par[101];\nint rank[101];\n//struct edge{ int to,from,cost; };\nvector<int> set[100],set2[100],fset[100];\n \nvoid init(int n);\nint find(int x);\nvoid unite(int x,int y);\nbool same(int x,int y);\ndouble prim();\n\n\nint main()\n{\n  while(cin >> n,n){\n    init(n);\n    \n    for(int i=0;i<n;i++){\n      //cin >> ((double)geo[i][0]) >> ((double)geo[i][1]) >> ((double)geo[i][2]) >> ((double)geo[i][3]); \n      //cout << square(geo[i][3]) << endl;\n      scanf(\"%lf %lf %lf %lf\", &geo[i][0], &geo[i][1], &geo[i][2], &geo[i][3]);\n    }\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tdis[i][j] = (double)sqrt((double)square(geo[i][0]-geo[j][0]) + (double)square(geo[i][1]-geo[j][1]) + (double)square(geo[i][2]-geo[j][2]));\n\ttouch[i][j] = geo[i][3]+geo[j][3];\n\tdis2[i][j] = dis[i][j] - touch[i][j]; //cout <<dis2[i][j] << endl;\n\tif(touch[i][j]>dis[i][j]) unite(i,j);\n      }\n    }\n    \n    int p;\n    for(int i=0;i<n;i++){\n      p = find(i);\n      set[p].push_back(i);\n    }\n    a = 0;\n    for(int i=0;i<n;i++){\n      if(set[i].empty()) continue;\n      set2[a] = set[i];\n      a++;\n    }\n    \n    for(int i=0;i<a;i++){\n      for(int j=0;j<a;j++){\n\tif(i==j)continue;\n\tdouble dmin = INF;\n\tfor(int k=0;k<set2[i].size();k++){\n\t  for(int l=0;l<set2[j].size();l++){\n\t    dmin = min(dmin,dis2[set2[i][k]][set2[j][l]]);\n\t  }\n\t}\n\tfdis[i][j] = dmin; //cout<< dmin << endl;\n\tdmin = INF;\n      }\n    }\n    \n    printf(\"%.3f\\n\",prim());\n    \n    for(int i=0;i<n;i++) set[i].clear();\n    for(int i=0;i<a;i++) set2[i].clear();\n    \n  }\n  \n}\n\nvoid init(int n)\n{\n  for(int i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x)\n{\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x==y) return;\n  \n  if(rank[x]<rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y)\n{\n  return find(x)==find(y);\n}\n\ndouble prim()\n{\n  for(int i=0;i<a;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n  double res = 0.0;\n  \n  while(true){\n    int v = -1;\n    for(int i=0;i<a;i++){\n      if(!used[i] && (v==-1 || mincost[i]<mincost[v])) v = i;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v]; //cout << mincost[v] << ' ' << res << endl;\n    \n    for(int i=0;i<a;i++){\n      mincost[i] = min(mincost[i],fdis[v][i]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 100\n#define INF 1<<30\nint n;\ndouble cost[MAX][MAX];\ndouble mincost[MAX];\nbool used[MAX];\ndouble prim(){\n  for(int i=0;i<n;i++)mincost[i]=INF,used[i]=false;\n    mincost[0]=0;\n  double res=0;\n  while(1){\n    int v=-1;\n    for(int u=0;u<n;u++)\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v]))v=u;\n    if(v==-1)break;\n    used[v]=1;\n    res+=mincost[v];\n    for(int u=0;u<n;u++)mincost[u]=min(mincost[u],cost[v][u]);\n  }\nreturn res;\n}\nmain(){\n  while(cin>>n,n){\n    double a[n][3],r[n];\n    r(i,n)cin>>a[i][0]>>a[i][1]>>a[i][2]>>r[i];\n    r(i,n)r(j,n){\n      double t=sqrt(abs((a[i][0]-a[j][0])*(a[i][0]-a[j][0]))+abs((a[i][1]-a[j][1])*(a[i][1]-a[j][1]))+abs((a[i][2]-a[j][2])*(a[i][2]-a[j][2])));\n      t-=r[i]+r[j];\n      if(t<0)t=0;\n      cost[i][j]=t;\n    }\n    double ans=prim();\n    printf(\"%.3f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ld cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\nld kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tld res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { ld x, y, z, r; };\nld dis(point a,point b) {\n\tld res;\n\tres = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n\tres -= a.r + b.r;\n\tif (res < eps) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[100];\n\t\tld x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(5) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1127\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint c[100][100];\n\nstruct P{\n    double x,y,z,r;\n    double abs(){\n        return sqrt(x*x+y*y+z*z);\n    }\n};\n\nP operator - (P a,P b){\n    a.x -= b.x;\n    a.y -= b.y;\n    a.z -= b.z;\n    return a;\n}\n\n\n\nint uf[1000];\nint get(int x){\n    return uf[x] = (uf[x]==x?x:get(uf[x]));\n}\nint unite(int x,int y){ uf[get(x)] = get(y); }\n\ndouble calc(P a,P b){\n    return max((a-b).abs()-a.r-b.r,0.);\n    \n}\nint main(){\n    int n;\n    while(cin >> n && n){\n        for(int i = 0 ; i < 1000 ; i++) uf[i] = i;\n        vector<P> pts(n);\n        for(int i = 0 ; i < n ; i++){\n            cin >> pts[i].x >> pts[i].y >> pts[i].z >> pts[i].r;\n        }\n        double ans = 0;\n        vector< pair<double,pair<int,int> > > e;\n        for(int i = 0 ; i < n ; i++){\n            for(int j = 0 ; j < n ; j++){\n                double dist = calc(pts[i],pts[j]);\n                e.push_back(make_pair(dist,make_pair(i,j)));\n            }\n        }\n        sort(e.begin(),e.end());\n        for(int i = 0 ; i < e.size() ; i++){\n            if( get(e[i].second.first) != get(e[i].second.second)){\n                ans += e[i].first;\n                unite(e[i].second.first,e[i].second.second);\n            }\n        }\n        printf(\"%.3lf%c\",ans,10);\n    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<double,pi> P;\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nint n;\ndouble x[100],y[100],z[100],r[100];\n\ninline double dist(int i, int j)\n{\n    return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]) );\n}\n\ninline double make_edge(int i, int j)\n{\n    double ret=dist(i,j)-r[i]-r[j];\n    return ret>0?ret:0;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %lf %lf %lf %lf\", &x[i], &y[i], &z[i], &r[i]);\n\n        vector<P> e;\n        rep(i,n)rep(j,i) e.pb(P(make_edge(i,j),pi(i,j)));\n        sort(all(e));\n\n        double ans=0;\n        UF uf(n);\n        rep(i,e.size())\n        {\n            int a=e[i].se.fi, b=e[i].se.se;\n            if(!uf.same(a,b))\n            {\n                uf.unite(a,b);\n                ans+=e[i].fi;\n            }\n\n            if(uf.size(0)==n) break;\n        }\n\n        printf(\"%.3f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(q=m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\n\nsigned main(){\n  cin.tie(0);\t\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(3);\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    double p[n][4],cost[101][101];\n    rep(i,n) cin>>p[i][0]>>p[i][1]>>p[i][2]>>p[i][3];\n    rep(i,n){\n      rep(j,n){\n\tif(i==j) cost[i][j]=INF;\n\telse{\n\t  cost[i][j]=max((double)0,sqrt(pow(p[i][0]-p[j][0],2)+pow(p[i][1]-p[j][1],2)+pow(p[i][2]-p[j][2],2))-p[i][3]-p[j][3]);\n\t}\n      }\n    }\n    double mincost[101];\n    bool flag[101]={0};\n    rep(i,n) mincost[i]=INF;\n    mincost[0]=0;\n    double ans=0;\n    while(1){\n      int v=-1;\n      rep(i,n){\n\tif(!flag[i] && (v==-1 || mincost[i]<mincost[v])) v=i;\n      }\n      if(v==-1) break;\n      flag[v]=true;\n      ans+=mincost[v];\n      rep(i,n){\n\tmincost[i]=min(mincost[i],cost[v][i]);\n      }\n    }\n    cout<<ans<<endl;\n  }\n\t \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\nusing namespace std;\n\ndouble calcDis(double x1, double y1, double z1, double x2, double y2, double z2){\n  return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2));\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x[100], y[100], z[100], r[100];\n    for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    \n    set<int> cell;\n    double ans = 0;\n    \n    multimap<double, int> corridor;\n    corridor.insert(make_pair(0.0, 0));\n    \n    while(cell.size() < n) {\n      double len = corridor.begin()->first;\n      int c = corridor.begin()->second;\n      corridor.erase(corridor.begin());\n      \n      if(!cell.insert(c).second) continue;\n      ans += len;\n      \n      for(int i = 0; i < n; i++){\n        if(cell.find(i) == cell.end()){\n          corridor.insert(make_pair(max(0.0, calcDis(x[i], y[i], z[i], x[c], y[c], z[c]) - r[i] - r[c]), i));\n        }\n      }\n    }\n    printf(\"%.3f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to;\n\t\tdouble cost;\n\t};\n\tvector<edge>G;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,double c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tdouble krk(){\n\t\tdouble sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tdouble in[110][4];\n\t\trep(i,n)rep(j,4)cin>>in[i][j];\n\t\tdouble dis[110][110];\n\t\trep(i,n)rep(j,n)if(i!=j)\n\t\t\tdis[i][j]=max<double>(0,sqrt((in[i][0]-in[j][0])*(in[i][0]-in[j][0])+(in[i][1]-in[j][1])*(in[i][1]-in[j][1])+(in[i][2]-in[j][2])*(in[i][2]-in[j][2]))-in[i][3]-in[j][3]);\n\t\tKRK krk(n);\n\t\trep(i,n)loop(j,i+1,n){\n\t\t\tkrk.add_edge(i,j,dis[i][j]);\n\t\t\tkrk.add_edge(j,i,dis[j][i]);\n\t\t}\n\t\tprintf(\"%.3f\\n\",krk.krk());\n\t}\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate <class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct sphere{\n\tdouble x,y,z,r;\n\t//sphere(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\ndouble dist(const sphere &left, const sphere &right){\n\tdouble p=sqrt(pow(left.x-right.x,2)+pow(left.y-right.y,2)+pow(left.z-right.z,2));\n\tdouble d=p-left.r-right.r;\n\tif(d<EPS){\n\t\treturn 0.000;\n\t}else{\n\t\treturn d;\n\t}\n}\n#define MAX INT_MAX/10\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<sphere> s(n);\n\t\tREP(i,n){\n\t\t\tcin>>s[i].x>>s[i].y>>s[i].z>>s[i].r;\n\t\t}\n\n\t\tvvd d(n,vd(n,MAX));\n\n\t\tREP(i,n)REP(j,n){\n\t\t\td[i][j]=dist(s[i],s[j]);\n\t\t}\n\n\t\tvi dones(n,0);\n\t\tdones[0]=1;\n\n\t\tdouble res=0;\n\t\twhile(find(ALL(dones),0)!=dones.end()){\n\t\t\tdouble mindist=MAX;\n\t\t\tint minindex=-1;\n\t\t\tREP(i,n){\n\t\t\t\tif(dones[i]){\n\t\t\t\t\tREP(j,n){\n\t\t\t\t\t\tif(!dones[j]){\n\t\t\t\t\t\t\tif(mindist>d[i][j]){\n\t\t\t\t\t\t\t\tmindist=d[i][j];\n\t\t\t\t\t\t\t\tminindex=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(minindex!=-1);\n\t\t\tres+=mindist;\n\t\t\tdones[minindex]=1;\n\t\t}\n\n\t\tprintf(\"%.5f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<long double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n#define INF 1LL<<60\n\nstruct cell {\n    double x, y, z, r;\n};\n\nstruct edge {\n    int from;\n    int to;\n    double d;\n\n    bool operator<(const edge& other) const {\n        if (d < other.d) return true;\n        else return false;\n    }\n};\n\nclass UnionFind {\npublic:\n    int rank;\n    vector <int> par; // 各元の親を表す配列\n    vector <int> siz; // 素集合のサイズを表す配列(1 で初期化)\n\n    // Constructor\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        rank = sz_;\n        for (int i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n    }\n    void init(int sz_) {\n        rank = sz_;\n        par.resize(sz_);\n        siz.assign(sz_, 1);  // resize だとなぜか初期化されなかった\n        for (int i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n    }\n\n    // Member Function\n    // Find\n    int root(int x) { // 根の検索\n        while (par[x] != x) {\n            x = par[x] = par[par[x]]; // x の親の親を x の親とする\n        }\n        return x;\n    }\n\n    // Union(Unite, Merge)\n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        // merge technique（データ構造をマージするテク．小を大にくっつける）\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        rank--;\n        return true;\n    }\n\n    bool issame(int x, int y) { // 連結判定\n        return root(x) == root(y);\n    }\n\n    int size(int x) { // 素集合のサイズ\n        return siz[root(x)];\n    }\n};\n\nint main() {\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<cell> cells(n);\n        REP(i, n) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            cell c = {x, y, z, r};\n            cells[i] = c;\n        }\n\n        UnionFind uf = UnionFind(n);\n\n        vector<edge> edges;\n        REP(i, n)\n            FOR(j, i + 1, n-1) {\n                cell c1 = cells[i];\n                cell c2 = cells[j];\n                double d2 = pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2) + pow(c1.z - c2.z, 2);\n                double d = sqrt(d2);\n\n                if(d <= c1.r + c2.r)\n                    uf.merge(i, j);\n                else {\n                    edge e = {i, j, d - c1.r - c2.r};\n                    edges.push_back(e);\n                }\n            }\n        sort(ALL(edges));\n\n        vector<edge> tree;\n        for(edge e: edges) {\n            if(!uf.issame(e.from, e.to)) {\n                uf.merge(e.from, e.to);\n                tree.push_back(e);\n            }\n        }\n\n        double ans = 0;\n        for(edge e: tree)\n            ans += e.d;\n        ans = round(1000 * ans) / 1000;\n        // cout << ans << endl;\n        printf(\"%.3f\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = (0); i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define show2(x,y) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << endl\n#define show3(x,y,z) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) <<  \", \" << #z << \" = \" << (z) << endl\n#define showv(v) rep(i,v.size()) printf(\"%d%c\", v[i], i==v.size()-1?'\\n':' ')\n#define showv2(v) rep(j,v.size()) showv(v[j])\n#define showt(t,n) rep(i,n) printf(\"%d%c\", t[i], i==n-1?'\\n':' ')\n#define showt2(t,r,c) rep(j,r) showt(t[j],c)\n#define showvp(p) rep(i,p.size()) printf(\"%d %d\\n\", p[i].first, p[i].second)\n#define printv(v) rep(i,v.size()) printf(\"%d\\n\", v[i])\n#define printt(t,n) rep(i,n) printf(\"%d\\n\", t[i])\n#define incl(v,x) (find(all(v),x)!=v.end())\n#define incls(s,c) (s.find(c)!=string::npos)\n#define lb(a,x) distance((a).begin(),lower_bound(all(a),(x)))\n#define ub(a,x) distance((a).begin(),upper_bound(all(a),(x)))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define bit(n,k) ((n>>k)&1) // nのk bit目\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define SP << \" \" <<\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing vp = vector<P>;\nusing vt = vector<T>;\nconst int mod = 1000000007;\nconst double EPS = 1e-9;\n//const long double EPS = 1e-14;\nconst int INF = (1<<30)-1;\nconst ll LINF = (1LL<<62)-1;\n#define dame { puts(\"No\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\ninline int in() { int x; cin >> x; return x;}\ninline ll lin() { ll x; cin >> x; return x;}\ninline char chin() { char x; cin >> x; return x;}\ninline string stin() { string x; cin >> x; return x;}\ninline double din() { double x; cin >> x; return x;}\n//template<class T = int> inline T in() { T x; cin >> x; return (x);}\ntemplate<typename T>inline ll suma(const vector<T>& a) { ll res(0); for (auto&& x : a) res += x; return res;}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nchar itoa(int n) { return n + '0';}\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) { return a/gcd(a,b)*b;}\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0, 1, 0,-1};\n\nint n;\n\nconst int MAX_V = 105;\nconst int MAX_E = MAX_V*(MAX_V+1)/2;\n//int V; // 頂点数\nint E; // 辺の本数\n\nstruct edge{ int u, v; double cost;};\nvector<edge> es(MAX_E);\n//edge es[MAX_E];\n\nstruct UnionFind {\n  vector<int> d;\n  UnionFind(int n): d(n,-1) {}\n  int find(int x) {\n    if (d[x] < 0) return x;\n    return d[x] = find(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (d[x] > d[y]) swap(x,y); // -d[x] < -d[y]\n    d[x] += d[y];\n    d[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n  int size(int x) { return -d[find(x)];}\n};\n\n// クラスカル法: 最小全域木のコストの合計値を返す O(|E|log|V|)\ndouble kruskal() {\n  auto comp = [](const edge& e1, const edge& e2) {\n    return e1.cost + EPS < e2.cost;\n    //return e1.cost < e2.cost;\n  };\n  sort(all(es), comp);\n  //sort(es, es + E, comp);\n  UnionFind uf(MAX_V);\n  double res = 0;\n  for (int i = 0; i < es.size(); ++i) {\n    edge e = es[i];\n    if (!uf.same(e.u, e.v)) {\n      uf.unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\ndouble solve() {\n  vector<double> x(n), y(n), z(n), r(n);\n  rep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n  es = vector<edge>();\n  rep(j,n)rep(i,j) {\n    double d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]));\n    double w = d - r[i] - r[j];\n    if (w + EPS < 0.0) w = 0.0;\n    es.pb({i,j,w});\n    es.pb({j,i,w});\n  }\n  double ans = kruskal();\n  return ans;\n}\n\nint main () {\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    double ans = solve();\n    printf(\"%.3f\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef double ld;\ntypedef long long ll;\ntypedef pair<int,int> P;\nld n,A[100],B[100],C[100],R[100],ra[101],fa[101],ans;\nvector<pair<ld,P>> v;\n\nll find(ll x){\n    if(x==fa[x])return x;\n    return fa[x]=find(fa[x]);\n}\nvoid uni(ll x,ll y){\n    x=find(x),y=find(y);\n    if(x==y)return ;\n    if(ra[x]<ra[y])swap(x,y);\n    fa[y]=x;\n    if(ra[x]==ra[y])ra[x]++;\n    return ;\n}\n\nint main(void){\n    while(1){\n    cin>>n;\n    if(n==0)return 0;\n    v={};\n    ans=0;\n    for(int i=0;i<101;i++)fa[i]=i;\n    for(int i=0;i<n;i++){\n        cin>>A[i]>>B[i]>>C[i]>>R[i];\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            ld L=(A[i]-A[j])*(A[i]-A[j])+(B[i]-B[j])*(B[i]-B[j])+(C[i]-C[j])*(C[i]-C[j]);\n            L=pow(L,0.5);\n            L-=R[i]+R[j];\n            if(L<0)L=0;\n            v.push_back({L,{i,j}});\n        }\n    }\n    sort(v.begin(),v.end());\n    for(auto x:v){\n        if(find(x.S.F)!=find(x.S.S))ans+=x.F;\n        uni(x.S.F,x.S.S);\n    }\n    //cout<<ans<<endl;\n    //cout<<setprecision(10)<<ans<<endl;\n    printf(\"%.3f\\n\",ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ld cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\nld kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tld res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { ld x, y, z, r; };\nld dis(point a,point b) {\n\tld res;\n\tres = sqrt(pow(a.x-b.x,2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n\tres -= (a.r + b.r);\n\tif (res < 0) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[101];\n\t\tld x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(3) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    \n    printf(\"%lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ndouble minSpanningTree(const vector<vector<double> >& graph)\n{\n    int n = graph.size();\n    vector<bool> used(n, false);\n    int usedNum = 0;\n    vector<double> minCost(n, DBL_MAX);\n    priority_queue<pair<double,int> ,vector<pair<double,int> >, greater<pair<double,int> > > q;\n    q.push(make_pair(0, 0));\n\n    double ret = 0;\n    while(!q.empty()){\n        pair<double, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(used[v])\n            continue;\n        ret += p.first;\n        used[v] = true;\n        if(++usedNum == n)\n            return ret;\n        for(int i=0; i<n; ++i){\n            if(!used[i] && graph[v][i] >= 0 && graph[v][i] < minCost[i]){\n                minCost[i] = graph[v][i];\n                q.push(make_pair(graph[v][i], i));\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<double> x(n), y(n), z(n), r(n);\n        for(int i=0; i<n; ++i)\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        vector<vector<double> > dist(n, vector<double>(n));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                dist[i][j] = sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0));\n                dist[i][j] -= r[i] + r[j];\n                dist[i][j] = max(dist[i][j], 0.0);\n            }\n        }\n\n        double ret = minSpanningTree(dist);\n        printf(\"%.3f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n  \nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tdouble x[101], y[101], z[101], r[101];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tdouble kyori_pow2[101][101];\n\t\tbool ischecked[101];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tkyori_pow2[i][i] = 0.0;\n\t\t\tischecked[i] = false;\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdouble k = sqrt(pow((x[i] - x[j]), 2) + pow((y[i] - y[j]), 2) + pow((z[i] - z[j]), 2));\n\t\t\t\tkyori_pow2[i][j] = max(0.0, k - r[i] - r[j]);\n\t\t\t\tkyori_pow2[j][i] = max(0.0, k - r[i] - r[j]);\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0.0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble mind = 10000000.0;\n\t\t\tint j = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(ischecked[k]) continue;\n\t\t\t\tif(kyori_pow2[0][k] < mind){\n\t\t\t\t\tmind = kyori_pow2[0][k];\n\t\t\t\t\tj = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j == -1) break;\n\t\t\tans += mind;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tkyori_pow2[0][k] = min(kyori_pow2[0][k], kyori_pow2[j][k]);\n\t\t\t}\n\t\t\tischecked[j] = true;\n\t\t}\n\t\tprintf(\"%.4f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\ntemplate <class T>\nT sq(T x) { return x * x; }\n\nstruct Ball {\n    ldouble x, y, z, r;\n};\n\nldouble dist(Ball a, Ball b) {\n    return sqrtl(sq(a.x - b.x) + sq(a.y - b.y) + sq(a.z - b.z)) - (a.r + b.r);\n}\n\nstruct UnionFind {\n    vector<int> par;\n\n    UnionFind(int n) : par(n) {\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        return par[v] == v ? v : par[v] = find(par[v]);\n    }\n\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        par[v] = u;\n    }\n\n    bool same(int u, int v) {\n        return find(u) == find(v);\n    }\n};\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (n == 0) return false;\n\n    vector<Ball> balls(n);\n    for (auto& b : balls) {\n        cin >> b.x >> b.y >> b.z >> b.r;\n    }\n\n    vector<tuple<ldouble, int, int>> edges;\n    for (int u = 0; u < n; ++u) {\n        for (int v = u + 1; v < n; ++v) {\n            ldouble l = max(0.0L, dist(balls[u], balls[v]));\n            edges.emplace_back(l, u, v);\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n    for (auto t : edges) {\n        ldouble l;\n        int u, v;\n        tie(l, u, v) = t;\n    }\n\n    UnionFind uf(n);\n    ldouble ans = 0;\n    for (auto t : edges) {\n        ldouble l;\n        int u, v;\n        tie(l, u, v) = t;\n        if (uf.same(u, v)) continue;\n\n        ans += l;\n        uf.unite(u, v);\n    }\n\n    cout << fixed << setprecision(3) << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i <= (n); i++)\n#define show(a, n) rep(i,n) {cout<<a[i]<<' ';} cout<<endl\n#define show2(a, n, m) rep(i, n) { rep(j, m) {cout << a[i][j] << ' ';} cout << endl;} \n#define chmin(a, b) a = min(a, b)\n#define chmax(a, b) a = max(a, b)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<long long, long long> pll;\ntypedef long double ld;\n\nconst int INF = 1 << 30;\nconst long long INFL = 1LL << 60;\nconst int MOD = 1000000007;\nconst int MAX = 100000;\nconst int N = 100010;\n\nstruct UnionFind {\n\tvector<int> par;\n\n\tUnionFind(int N) : par(N) {\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tbool issame(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\tif (rx == ry) return;\n\t\tpar[rx] = ry;\n\t}\n};\n\ntypedef tuple<ld, int, int> tup;\n\nint main() {\n\tcout << fixed << setprecision(3);\n\tvector<ld> ans;\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tvector<ld> x(n), y(n), z(n), r(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tvector<tup> v;\n\t\trep(i, n - 1) for(int j = i + 1; j < n; j++) {\n\t\t\tld d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]));\n\t\t\td = max(d - r[i] - r[j], (ld)0.0);\n\t\t\tv.push_back(tup(d, i, j));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tUnionFind uf(n);\n\t\tld tmp = 0.0;\n\t\trep(i, v.size()) {\n\t\t\tld d;\n\t\t\tint j, k;\n\t\t\ttie(d, j, k) = v[i];\n\t\t\tif(uf.issame(j, k)) continue;\n\t\t\ttmp += d;\n\t\t\tuf.merge(j, k);\n\t\t}\n\t\tans.push_back(tmp);\n\t}\n\tfor(auto i: ans) cout << i << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nusing Real = double;\nReal scan() {\n    Real x; scanf(\"%lf\", &x);\n    return (Real)x;\n}\nclass UnionFind {\npublic:\n\tvector<ll> Parent;\n\tUnionFind(ll N) {\n\t\tParent = vector<ll>(N, -1);\n\t}\n\tll root(ll A) {\n\t\tif (Parent[A] < 0) {\n\t\t\treturn A;\n\t\t}\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\tll size(ll A) {\n\t\treturn -Parent[root(A)];\n\t}\n\n\tbool connect(ll A, ll B) {\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\treturn false;\n\t\t}\n\t\tif (size(A) < size(B)) {\n\t\t\tswap(A, B);\n\t\t}\n\n\t\tParent[A] += Parent[B];\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n\n};\n\nclass Edge {\npublic:\n\tint source, target;\n\tReal cost;\n\tEdge(int source = 0, int target = 0, Real cost = 0) :\n\t\tsource(source), target(target), cost(cost) {}\n\tbool operator<(const Edge& e)const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nReal kuraskal(int N, vector<Edge>& edges) {\n\tReal totalCost = 0;\n\tsort(edges.begin(), edges.end());\n\tUnionFind uni(N + 1);\n\tfor (int i = 0; i < edges.size(); i++) {\n\t\tEdge e = edges[i];\n\t\tif (uni.root(e.source) != uni.root(e.target)) {\n\t\t\ttotalCost += e.cost;\n\t\t\tuni.connect(e.source, e.target);\n\t\t}\n\t}\n\treturn totalCost;\n}\n\nReal dist(Real x1, Real y1, Real z1, Real x2, Real y2, Real z2) {\n\tx2 -= x1; y2 -= y1; z2 -= z1;\n\treturn sqrt(x2 * x2 + y2 * y2 + z2 * z2);\n}\nvoid solve() {\n\tint n; scanf(\"%d\", &n); if (n == 0) exit(0);\n    vector<Real> x(n), y(n), z(n), r(n);\n\tfor (int i = 0; i < n; i++) x[i] = scan(), y[i] = scan(), z[i] = scan(), r[i] = scan();\n\tvector<Edge> edges;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tReal d = max(0.0, dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j]);\n\t\t\tedges.emplace_back(i, j, d);\n\t\t}\n\t}\n\tprintf(\"%.3f\\n\", kuraskal(n, edges));\n}\n\nint main()\n{\n    /*\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    */\n\n    int kkt = 89;\n    while (kkt) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\t\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\t\n\tinline bool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn false;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\n\t\treturn true;\n\t}\n};\ntypedef long double weight;\n\nstruct edge {\n\tint u, v;\n\tweight cost;\n\tedge(int u, int v, weight c):u(u), v(v), cost(c){}\n\n\tbool operator< (const edge& o) const {\n\t\treturn cost < o.cost;\n\t}\n};\n\nint n;\nvector<edge> es;\n\nweight kruskal() {\n\tsort(es.begin(), es.end());\n\tunion_find uf(n);\n\n\tweight res = 0;\n\tfor(int i = 0; i < es.size(); ++i)\n\t\tif(uf.unite(es[i].u, es[i].v))\n\t\t\tres += es[i].cost;\n\n\treturn res;\n}\n\ninline weight dist(weight x1, weight y1, weight z1, weight x2, weight y2, weight z2) {\n\tconst weight dx = x1 - x2, dy = y1 - y2, dz = z1 - z2;\n\treturn sqrtl(dx * dx + dy * dy + dz * dz);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tvector<weight> x(n), y(n), z(n), r(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tscanf(\"%Lf %Lf %Lf %Lf\", &x[i], &y[i], &z[i], &r[i]);\n\n\t\tes.clear();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst weight cost = max(0.0L, dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j]);\n\t\t\t\tes.push_back(edge(i, j, cost));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10Lf\\n\", kruskal());\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Building a Space Station\n//Level: 2\n//Category: グラフ,Graph,最小全域木,MST\n//Note:\n\n/**\n * 球体と球体を最短距離で結ぶには、中心同士を結ぶような線分で結べばよい。\n * 交差している球の間にはコスト0の辺があるものとして、最小全域木を求めればよい。\n *\n * オーダーは O(N^2 log N)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct DisjointSet/*{{{*/\n{\n  vector<int> parent;\n\n  int root(int x)\n  {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      parent[x] = root(parent[x]);\n      return parent[x];\n    }\n  }\n\n  explicit DisjointSet(int n) : parent(n, -1) {}\n\n  bool unite(int x, int y)\n  {\n    const int a = root(x);\n    const int b = root(y);\n    if (a != b) {\n      if (parent[a] < parent[b]) {\n        parent[a] += parent[b];\n        parent[b] = a;\n      } else {\n        parent[b] += parent[a];\n        parent[a] = b;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool find(int x, int y) { return root(x) == root(y); }\n  int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nstruct Sphere {\n    double x, y, z, r;\n\n    double distance(const Sphere &s) const {\n        const double dx = x - s.x;\n        const double dy = y - s.y;\n        const double dz = z - s.z;\n        const double d = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - r - s.r;\n        return d < 0 ? 0 : d;\n    }\n};\n\nstruct Edge {\n    int a, b;\n    double cost;\n\n    Edge(int a, int b, double c) : a(a), b(b), cost(c) {}\n\n    bool operator <(const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nbool solve() {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    vector<Sphere> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> nodes[i].x >> nodes[i].y >> nodes[i].z >> nodes[i].r;\n    }\n\n    vector<Edge> edges;\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < i; ++j) {\n            edges.emplace_back(i, j, nodes[i].distance(nodes[j]));\n        }\n    }\n    sort(begin(edges), end(edges));\n\n    DisjointSet ds(N);\n    double ans = 0;\n    for (auto &e : edges) {\n        if(ds.unite(e.a, e.b)) {\n            ans += e.cost;\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(3);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\n#define reps(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, N) reps(i, 0, N-1)\n#define deps(i, E, S) for (ll i = (E); i >= (S); i--)\n#define dep(i, N) deps(i, N-1, 0)\nconst ll INF = 1LL << 60;\nconst int INF_INT = 1 << 30;\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\nstruct mll {\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val = (val + b.val) % MOD; return *this; }\n\tmll &operator -= (const mll &b) { val = (val + MOD - b.val) % MOD; return *this; }\n\tmll &operator *= (const mll &b) { val = (val*b.val) % MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c = b.val, d = MOD, u = 1, v = 0;\n\t\twhile (d) {\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b) {\n\t\tchmin(b, a - b);\n\t\tif (b < 0) return mll(0);\n\t\tmll c = 1;\n\t\trep(i, b) c *= a - i;\n\t\trep(i, b) c /= i + 1;\n\t\treturn c;\n\t}\n};\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nstruct Fast {\n\tFast() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast; //cin,cout高速化のおまじない＋桁数指定\n\nll mll::MOD = (ll)(1e9 + 7);// 998244353ll;\n\n\n//◆--↓--グラフテンプレート--↓--\ntemplate<typename T>\nstruct edge {\n\tll src, to;\n\tT cost;\n\tedge(ll to, T cost) : src(-1), to(to), cost(cost) {}\n\tedge(ll src, ll to, T cost) : src(src), to(to), cost(cost) {}\n\tedge &operator=(const ll &x) {\n\t\tto = x;\n\t\treturn *this;\n\t}\n\toperator ll() const { return to; }\n};\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<ll>>;\ntemplate<typename T>\nusing Matrix = vector<vector<T >>;\n//--↑--グラフテンプレート--↑--\n\n//◆--↓--最小全域木(Kruskal) : O(E * logV)--↓--\nstruct UnionFind {\n\tvector<ll> data;\n\n\tUnionFind(ll sz) {\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(ll x, ll y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return (false);\n\t\tif (data[x] > data[y]) swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tll find(ll k) {\n\t\tif (data[k] < 0) return (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(ll k) {\n\t\treturn (-data[find(k)]);\n\t}\n};\n\ntemplate<typename T>\nT kruskal(Edges<T> &edges, ll V) {\n\tsort(begin(edges), end(edges), [](const edge<T> &a, const edge<T> &b) {\n\t\treturn (a.cost < b.cost);\n\t});\n\tUnionFind tree(V);\n\tT ret = 0;\n\tfor (auto &e : edges) {\n\t\tif (tree.unite(e.src, e.to)) ret += e.cost;\n\t}\n\treturn (ret);\n}\n//--↑--最小全域木(Kruskal)--↑--\n\nint main() {\n\twhile (true) {\n\t\tll N;\n\t\tcin >> N;\n\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<double> X(N);\n\t\tvector<double> Y(N);\n\t\tvector<double> Z(N);\n\t\tvector<double> R(N);\n\t\trep(i, N) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\t\t}\n\n\t\t//usage\n\t\t//  ll V, E;\n\t\t//  scanf(\"%d %d\", &V, &E);\n\t\t//  Edges<ll> edges;\n\t\t//  for(ll i = 0; i < E; i++) {\n\t\t//\tll a, b, c;\n\t\t//\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t//\tedges.emplace_back(a, b, c);\n\t\t//  }\n\t\t//  printf(\"%d\\n\", kruskal(edges, V));\n\n\t\tEdges<double> edges;\n\t\trep(i, N) rep(j, N) {\n\t\t\tif (i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdouble subX = X[i] - X[j];\n\t\t\tdouble subY = Y[i] - Y[j];\n\t\t\tdouble subZ = Z[i] - Z[j];\n\t\t\tdouble dist = sqrt(subX * subX + subY * subY + subZ * subZ);\n\t\t\tdouble cost = max(0.0, dist - R[i] - R[j]);\n\n\t\t\tedges.emplace_back(i, j, cost);\n\t\t\tedges.emplace_back(j, i, cost);\n\t\t}\n\n\t\tdouble result = kruskal(edges, N);\n\n\t\tstd::cout << std::fixed;\n\t\tcout << std::setprecision(3) << result << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100\n#define MAX_E 10000\n\nint V,E,par[MAX_V],rank[MAX_V];\n\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\n\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\n\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n\nEdge es[MAX_E];\n\nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n\ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n\nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[MAX_V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n    \n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.8f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntemplate<typename T> inline T sqr(T x) { return x * x; }\n\nstruct Sphere { double x, y, z, r; };\n\nistream& operator>>(istream& is, Sphere& s) { \n    return is >> s.x >> s.y >> s.z >> s.r;\n}\n\ndouble dist(const Sphere& a, const Sphere& b) {\n    double retval = sqrt(sqr(a.x - b.x) + sqr(a.y - b.y) + sqr(a.z - b.z)) - a.r - b.r;\n    return max(0.0, retval);\n}\n\nstruct Edge {\n    int src, dst;\n    double wt;\n    Edge(int src_, int dst_, double wt_) : src(src_), dst(dst_), wt(wt_) {}\n    bool operator>(const Edge& rhs) const { return wt > rhs.wt; }\n};\n\ntypedef vector<Edge> Edges;\n\nstruct UnionFind {\n    UnionFind(size_t n) : data(n, -1) {}\n    int root(size_t x) { return data[x] < 0? x: data[x] = root(data[x]); }\n    bool unite(size_t x, size_t y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (data[y] < data[x]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return true;\n    }\nprivate:\n    vector<int> data;\n};\n\ndouble solve(const vector<Sphere>& cell) { // kruskal\n    double retval = 0.0;\n    Edges stree;\n    UnionFind uf(cell.size());\n    priority_queue<Edge, vector<Edge>, greater<Edge>> Q;\n    rep(i, cell.size()) rep(j, i) Q.emplace(i, j, dist(cell[i], cell[j]));\n    for (; stree.size() < cell.size() - 1 && !Q.empty();) {\n        Edge e = Q.top(); Q.pop();\n        if (!uf.unite(e.src, e.dst)) continue;\n        stree.push_back(e);\n        retval += e.wt;\n    }\n    return retval;\n}\n\nint main() {\n    for (int n; cin >> n, n;) {\n        vector<Sphere> cell(n);\n        for (auto& e: cell) cin >> e;\n        cout << fixed << setprecision(3) << solve(cell) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct Sphere{\n    double x;\n    double y;\n    double z;\n    double r;\n};\n\nint n;\nvector< vector<double> > costs;\n\nint main(void){\n    double res;\n    for(; cin >> n, n; cout << res << endl){\n        res = 0.;\n        vector<Sphere> spheres(n);\n        rep(i, n) cin >> spheres[i].x >> spheres[i].y >> spheres[i].z >> spheres[i].r;\n\n        costs = vector< vector<double> >(n, vector<double>(n));\n        rep(u, n){\n            range(v, u, n){\n                double d = sqrt(sqr(spheres[u].x - spheres[v].x) \n                              + sqr(spheres[u].y - spheres[v].y) \n                              + sqr(spheres[u].z - spheres[v].z));\n                costs[u][v] = costs[v][u] = max(0., d - (spheres[u].r + spheres[v].r));\n            }\n        }\n\n        vector<double> minCost(n, inf);\n        vi used(n);\n\n        minCost[0] = 0;\n        while(1){\n            int v = -1;\n            rep(u, n){\n                if(!used[u] && (v == -1 || minCost[u] < minCost[v])) v = u;\n            }\n            if(v == -1) break;\n\n            used[v] = true;\n            res += minCost[v];\n\n            rep(u, n){\n                if(!used[u]){\n                    minCost[u] = min(minCost[u], costs[v][u]);\n                }\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = -1;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      //res += d[t];\n      if (p[t] != -1) res += map[t][p[t]];\n      //printf(\"res: %.3lf\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    //res += d[p[t]];\n    printf(\"%.3lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <math.h>\nusing namespace std;\n#define INF 1<<28\nconst double eps=1e-8 ;\n\ndouble sqrt1(double a)\n{\n    return a*a;\n}\ndouble x[123],y[123],z[142],r[231];\n\ndouble dis(int i,int j)\n{\n    return sqrt(sqrt1(x[i]-x[j])+sqrt1(y[i]-y[j])+sqrt1(z[i]-z[j]));\n}\n\nint vis[1230];\n\ndouble map[123][123];\ndouble d[1001];\n\nint n;\n\nvoid prim()\n{\n\tdouble ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tvis[i]=0;\n\t\td[i]=INF;\n\t}\n\td[1]=0;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k=0,m=INF;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!vis[j]&&d[j]<m)\n\t\t\t{\n\t\t\t\tm=d[j];k=j;\n\t\t\t}\n\t\t}\n\n        if(m >= INF)\n            break;\n\t\tvis[k]=1;\n\t\tans+=d[k];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!vis[j]&&d[j]>map[k][j])\n\t\t\t{\n\t\t\t\td[j]=map[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.3lf\\n\",ans);\n}\n\nint main()\n{\n\twhile(cin>>n)\n\t{\n\t\tif(n==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\t//printf(\"%lf----------\\n\",dis(i,j));\n\t\t\t\tif(dis(i,j)-r[i]-r[j]<=0)\n\t\t\t\tmap[i][j]=0;\n\t\t\t\telse if(dis(i,j)-r[i]-r[j]>eps)\n\t\t\t\tmap[i][j]=dis(i,j)-r[i]-r[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprim();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nstruct Edge{\n    int u, v;\n    T cost;\n    \n    Edge() = default;\n    Edge(int u, int v, T cost) : u(u), v(v), cost(cost) {}\n\n    bool operator<(const Edge& other) const{\n        return cost < other.cost;\n    }\n};\n\nstruct UnionFind{\n    int sz;     // vertex number\n    vector<int> par;\n    vector<int> rank;\n\n    UnionFind(int n) : sz(n) {\n        par.resize(sz);\n        rank.assign(sz, 0);\n        for(int i = 0; i < sz; ++i){\n            par[i] = i;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else    return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n        x = find(x), y = find(y);\n        if(x == y)  return;\n        if(rank[x] < rank[y])   par[x] = y;\n        else{\n            par[y] = x;\n            if(rank[x] == rank[y])  ++rank[x];\n        }\n    }\n};\n\n// クラスカル法を適用してグラフの最小全域木を求める\ntemplate<typename T>\nT Kruskal(vector<Edge<T>> &es, int VertexNumber){\n    T res = 0;    \n    sort(es.begin(), es.end());\n    int sz = es.size();\n    UnionFind tree(VertexNumber);\n    for(int i = 0; i < sz; ++i){\n        if(!tree.same(es[i].u, es[i].v)){\n            tree.unite(es[i].u, es[i].v);\n            res += es[i].cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    using ld = long double;\n    constexpr ld eps = 1e-9;\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)  return 0;\n        vector<ld> x(n), y(n), z(n), r(n);\n        for(int i = 0; i < n; ++i)  cin >> x[i] >> y[i] >> z[i] >> r[i];\n        auto get_dist = [&](int i, int j){\n            ld X = x[i] - x[j], Y = y[i] - y[j], Z = z[i] - z[j];\n            ld d = sqrt(X * X + Y * Y + Z * Z) - r[i] - r[j];\n            return d < eps ? 0.0 : d;\n        };\n        vector<Edge<ld>> es;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < i; ++j){\n                es.emplace_back(j, i, get_dist(i, j));\n            }\n        }\n        cout << fixed << setprecision(3);\n        cout << Kruskal(es, n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tuf.unite(i, j);\n\t\t\t\t\t++c;\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && n!=c) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t++c;\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nclass DisjointSet{\nprivate:\n  vector<int> rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n  }\n  void build(){\n    for(int i = 0; i < rank.size(); i++){\n      makeSet(i);\n    }\n  }\n  void makeSet(int x){\n    p[x] = x, rank[x] = 0;\n  }\n  void Union(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  int findSet(int x){\n    return( x != p[x] ? p[x] = findSet(p[x]) : p[x]);\n  }\n};\nstruct edge{\n  int u, v;\n  double cost;\n  bool operator<(const edge& hoge)const{\n    return cost < hoge.cost;\n  }\n};\ntypedef vector< edge > Edges;\nvoid add_edge(Edges& info, int u, int v, double cost){\n  info.push_back( (edge){ u, v, cost});\n}\ndouble kruskal(Edges& edges, int V){\n  sort( edges.begin(), edges.end());\n  DisjointSet uf_tree(V); uf_tree.build();\n  double ret = 0.0;\n  for(int i = 0; i < edges.size(); i++){\n    edge& e = edges[i];\n    if(uf_tree.findSet(e.u) != uf_tree.findSet(e.v)){\n      uf_tree.Union( e.u, e.v);\n      ret += e.cost;\n    }\n  }\n  return ret;\n}\n\ndouble GetDist( double x1, double y1, double z1, double r1,\n                double x2, double y2, double z2, double r2){\n  double dx = fabs( x2 - x1), dy = fabs( y2 - y1), dz = fabs( z2 - z1);\n  double dist = max(sqrt( dx * dx + dy * dy + dz * dz) - r1 - r2, 0.0);\n  return dist;\n}\n\nint main(){\n  int n;\n  double x[100], y[100], z[100], r[100];\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    Edges edges;\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        add_edge( edges, i, j, GetDist( x[i], y[i], z[i], r[i], x[j], y[j], z[j], r[j]));\n      }\n    }\n    cout << fixed << setprecision(5) << kruskal(edges, n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct edge {\n  int p, q;\n  double d;\n  bool operator<(const edge &e) const { return d < e.d; }\n};\n\nint N;\ndouble X[100], Y[100], Z[100], R[100];\n\ndouble dist(int i, int j) {\n  double dx = X[i] - X[j];\n  double dy = Y[i] - Y[j];\n  double dz = Z[i] - Z[j];\n  return max(sqrt(dx * dx + dy * dy + dz * dz) - R[i] - R[j], 0.0);\n}\n\nint find(int *a, int i) { return a[i] == i ? i : (a[i] = find(a, a[i])); }\nvoid unite(int *a, int i, int j) { if(find(a, i) != find(a, j)) a[find(a, i)] = find(a, j); }\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\n    vector<edge> e;\n    REP(i, 0, N) REP(j, i + 1, N) e.push_back((edge) { i, j, dist(i, j) });\n    sort(e.begin(), e.end());\n\n    double ans = 0.0;\n    int g[100];\n    REP(i, 0, N) g[i] = i;\n    REP(i, 0, e.size()) if(find(g, e[i].p) != find(g, e[i].q)) {\n      ans += e[i].d;\n      unite(g, e[i].p, e[i].q);\n    }\n    printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> par;\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    for(int i=0;i<n;i++) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  long long int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main(){\n\n  int n;\n  cin >> n;\n\n  vector<double> p;\n\n  while(n!=0){\n    long double x[n],y[n],z[n],r[n];\n\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n\n    UnionFind tree(n);\n    vector<tuple<long double,int,int> > G;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        long double l=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2))-r[i]-r[j];\n        if(l<=0)tree.unite(i,j);\n        else{\n          G.push_back(make_tuple(l,i,j));\n        }\n      }\n    }\n\n    sort(G.begin(),G.end());\n\n    double s=0;\n\n    for(int i=0;i<G.size();i++){\n      if(tree.same(get<1>(G[i]),get<2>(G[i])));\n      else{\n        tree.unite(get<1>(G[i]),get<2>(G[i]));\n        s+=get<0>(G[i]);\n      }\n    }\n\n    p.push_back(s);\n\n\n    cin >> n;\n  }\n\n  for(int i=0;i<p.size();i++) printf(\"%.3lf\\n\",p[i]);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nstruct station{\n\tdouble x,y,z,r;\n};\ndouble dist(station &a,station &b){\n\treturn pow(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2),0.5)-a.r-b.r;\n}\nint uft[100];\nvoid init(){\n\tfor(int i = 0; i < 100; ++i) uft[i] = i;\n}\nint find(int v){\n\tif(uft[v] == v) return v;\n\telse return uft[v] = find(uft[v]);\n}\nvoid uni(int v,int w){\n\tuft[find(w)] = find(v);\n}\ntypedef pair<double,pair<int,int> > P;\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tinit();\n\t\tstation s[100];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> s[i].x >> s[i].y >> s[i].z >> s[i].r;\n\t\t}\n\t\tP p[10000];\n\t\tint m = 0;\n\t\tfor(int i = 0; i < n; ++i)for(int j = 0; j < n; ++j){\n\t\t\tdouble d = dist(s[i],s[j]);\n\t\t\tif(d > 0) p[m++] = P(d,pair<int,int>(i,j));\n\t\t\telse uni(i,j);\n\t\t}\n\t\tsort(p,p+m);\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tif(find(p[i].second.first) != find(p[i].second.second)){\n\t\t\t\tsum += p[i].first;\n\t\t\t\tuni(p[i].second.first,p[i].second.second);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct Sphere{\n    double x;\n    double y;\n    double z;\n    double r;\n};\n\nint n;\n\nvector< vector<double> > costs;\nvi used;\nvvi connected;\n\nvoid dfs(int node);\n\nint main(void){\n    double res;\n    for(; cin >> n, n; cout << res << endl){\n        res = 0.;\n        vector<Sphere> spheres(n);\n        rep(i, n) cin >> spheres[i].x >> spheres[i].y >> spheres[i].z >> spheres[i].r;\n\n        costs = vector< vector<double> >(n, vector<double>(n));\n        rep(i, n){\n            range(j, i, n){\n                double d = sqrt(sqr(spheres[i].x - spheres[j].x) \n                              + sqr(spheres[i].y - spheres[j].y) \n                              + sqr(spheres[i].z - spheres[j].z));\n                costs[i][j] = max(0., d - (spheres[i].r + spheres[j].r));\n            }\n        }\n\n        connected = vvi(n, vi(n, 1));\n        vvi checked(n, vi(n));\n        rep(i, n * n){\n            double cost = 0.; pii sz;\n            rep(j, n){\n                range(k, j + 1, n){\n                    if(!checked[j][k] && cost < costs[j][k])\n                        cost = costs[j][k], sz = mp(j, k);\n                }\n            }\n            if(sz == mp(0, 0)) continue;\n            checked[sz.first][sz.second] = true;\n\n            connected[sz.first][sz.second] = false;\n            used = vi(n);\n            dfs(0);\n\n            bool ok = true;\n            rep(j, n){\n                if(!used[j]) ok = false;\n            }\n\n            if(!ok) connected[sz.first][sz.second] = true;\n        }\n\n        rep(i, n) range(j, i + 1, n) if(connected[i][j]) res += costs[i][j];\n    }\n\n\treturn 0;\n}\n\nvoid dfs(int node){\n    if(used[node]) return;\n\n    used[node] = true;\n\n    rep(i, n){\n        if(connected[min(node, i)][max(node, i)]) dfs(i);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0, sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nstruct Node{\n    int id, v;\n    bool done = false;\n    Node(int id, int v=INT_INF): id(id), v(v) {}\n    Node(): id(0), v(INT_INF) {}\n};\n\nbool operator>(Node a, Node  b){\n    return a.v > b.v;\n}\n\nstruct Edge{\n    int from, to, id;\n    double cost;\n    Edge(int from, int to, double cost=1, int id=-1): from(from), to(to), cost(cost), id(id) {}\n};\n\nbool operator>(Edge a, Edge  b){\n    return a.cost > b.cost;\n}\n\nstruct Graph{\n    int N;\n    vector<vector<Edge>> adj;\n    vector<Node> node;\n\n    Graph(int N): N(N) {\n        adj.assign(N, vector<Edge>());\n        node.assign(N, Node());\n        for(int i=0; i<N; ++i) node[i].id = i;\n    }\n\n    Graph() {}\n\n    void add_edge(int i, int j, double cost=1, int id=-1){\n        Edge e(i, j, cost, id);\n        adj[i].emplace_back(e);\n    }\n\n    vector<Edge> get_adj(Node node){\n        return adj[node.id];\n    }\n\n    void assign(int n){\n        N = n;\n        adj.assign(N, vector<Edge>());\n        node.assign(N, Node());\n        for(int i=0; i<N; ++i) node[i].id = i;\n    }\n};\n\nstruct UnionFind{\n    vector<int> par; // par[i]:iの親の番号\n    vector<int> s; // s[i]:iの属する木のノード数\n    int n_group; // 木の数\n    \n    UnionFind(int N) : par(N) {\n        for(int i=0; i<N; i++) par[i] = i;\n        s.assign(N, 1);\n        n_group = N;\n    }\n    \n    int root(int x){ // xが属する木の根\n        if(par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n    \n    void unite(int x, int y){ // xとyの木を併合\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return;\n        par[rx] = ry;\n        s[ry] += s[rx];\n        s[rx] = 0;\n        n_group--;\n    }\n    \n    bool same(int x, int y){ // xとyが同じ木に属するかどうか\n        return root(x) == root(y);\n    }\n\n    int size(int x){ // xが属する木のノード数\n        return s[root(x)];\n    }\n};\n\ndouble f(double x){\n    return x*x;\n}\n\ndouble round_n(double number, double n)\n{\n    number = number * pow(10,n-1); //四捨五入したい値を10の(n-1)乗倍する。\n    number = round(number); //小数点以下を四捨五入する。\n    number /= pow(10, n-1); //10の(n-1)乗で割る。\n    return number;\n}\n\nint main(void){\n    int N; cin >> N;\n\n    while(N != 0){\n        Graph G(N);\n        vector<double> x(N), y(N), z(N), r(N);\n        REP(i,N) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        REP(i,N-1)FOR(j,i+1,N){\n            double cost = max((double)0,sqrt(f(x[i]-x[j])+f(y[i]-y[j])+f(z[i]-z[j])) - (r[i]+r[j]));\n            G.add_edge(i,j,cost);\n            G.add_edge(j,i,cost);\n        }\n\n        UnionFind uf(N);\n        double ans = 0;\n        priority_queue<Edge,vector<Edge>,greater<Edge>> q;\n        q.push(Edge(0,0,0));\n        while(q.size()){\n            Edge n = q.top(); q.pop();\n            if(G.node[n.to].done) continue;\n            G.node[n.to].done = true;\n            if(!uf.same(n.from,n.to)){\n                uf.unite(n.from, n.to);\n                ans += n.cost;\n            }\n            for(Edge e : G.adj[n.to]){\n                q.push(e);\n            }\n        }\n        cout << fixed << setprecision(3) << round_n(ans, 4) << en;\n        cin >> N;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nvector<vector<long double> > cost;\t// cost[u][v] ?????? e = (u, v) ????????????(?????¨???????????´?????? INF)\nvector<long double> mincost;\t\t// ?????? X ???????????????????°??????????\nvector<bool> used;\t\t\t// ?????? i ??? X ????????????????????????\nll V;\t\t\t\t\t\t// ????????°\nlong double prim() {\n\tREP(i, V) {\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tlong double res = 0;\n\twhile(true) {\n\t\tll v = -1;\n\t\tREP(u, V) {\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v =u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tREP(u, V) {\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>V;\n\t\tif(V == 0) break;\n\t\tlong double p[V][4];\n\t\tcost.resize(0);\n\t\tcost.resize(V);\n\t\tREP(i, V) cost[i].resize(V);\n\t\tmincost.resize(0);\n\t\tmincost.resize(V);\n\t\tused.resize(0);\n\t\tused.resize(V);\n\t\tREP(i, V) cin>>p[i][0]>>p[i][1]>>p[i][2]>>p[i][3];\n\t\tREP(i, V) {\n\t\t\tREP(j, V) {\n\t\t\t\tif(i == j) cost[i][j] = INF;\n\t\t\t\telse {\n\t\t\t\t\tlong double dist = sqrt( pow(p[i][0] - p[j][0], 2) + pow(p[i][1] - p[j][1], 2) +\n\t\t\t\t\t\t\t\t\t\t\tpow(p[i][2] - p[j][2], 2) );\n\t\t\t\t\tif(p[i][3] + p[j][3] - dist > EPS) cost[i][j] = 0;\n\t\t\t\t\telse cost[i][j] = dist - (p[i][3] + p[j][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<showpoint<<setprecision(3)<<prim()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nstruct station{\n\tdouble x,y,z,r;\n};\ndouble dist(station &a,station &b){\n\treturn pow(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2),0.5)-a.r-b.r;\n}\nint uft[100];\nvoid init(){\n\tfor(int i = 0; i < 100; ++i) uft[i] = i;\n}\nint find(int v){\n\tif(uft[v] == v) return v;\n\telse return uft[v] = find(uft[v]);\n}\nvoid uni(int v,int w){\n\tuft[find(w)] = find(v);\n}\ntypedef pair<double,pair<int,int> > P;\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tinit();\n\t\tstation s[100];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> s[i].x >> s[i].y >> s[i].z >> s[i].r;\n\t\t}\n\t\tP p[10000];\n\t\tint m = 0;\n\t\tfor(int i = 0; i < n; ++i)for(int j = 0; j < n; ++j){\n\t\t\tdouble d = dist(s[i],s[j]);\n\t\t\tif(d > 0) p[m++] = P(d,pair<int,int>(i,j));\n\t\t\telse uni(i,j);\n\t\t}\n\t\tsort(p,p+m);\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tif(find(p[i].second.first) != find(p[i].second.second)){\n\t\t\t\tsum += p[i].first;\n\t\t\t\tuni(p[i].second.first,p[i].second.second);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define P pair<float, pair<int,int> >\n#define sqr(x) ((x) * (x))\n\nusing namespace std;\n\nint parent[100],rank[100];\n\nint findset(int x){\n  if(x!=parent[x]) parent[x] = findset(parent[x]);\n  return parent[x];\n}\n\nvoid link(int x,int y){\n  if(rank[x]>rank[y])\n    parent[y]=x;\n  else{\n    parent[x]=y;\n    if(rank[x]==rank[y]) rank[y]++;\n  }\n}\n\nvoid merge(int x,int y){\n  link(findset(x),findset(y));\n}\n\nbool sameset(int x,int y){\n  return findset(x)==findset(y);\n}\n\nfloat x[100],y[100],z[100],r[100];\nvector<P> tako;\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    tako.clear();\n    for(int i=0; i<n; i++){\n      float xx,yy,zz,rr;\n      scanf(\"%f %f %f %f\",&xx,&yy,&zz,&rr);\n      x[i]=xx; y[i]=yy; z[i]=zz; r[i]=rr;\n\n      parent[i]=i; rank[i]=0;\n    }\n\n    for(int i=0; i<n-1; i++) for(int j=i+1; j<n; j++){\n      float dist = sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j])+sqr(z[i]-z[j]))-r[i]-r[j];\n      //      printf(\"dist: %f, x: %d, y: %d\\n\",dist,i,j);\n      dist = dist>0?dist:0;\n      tako.push_back(make_pair(dist,make_pair(i,j)));\n    }\n    sort(tako.begin(),tako.end());\n\n    float ans=0;\n    for(int i=0; i<tako.size(); i++){\n      float dist = tako[i].first;\n      int x=tako[i].second.first, y=tako[i].second.second;\n      if(sameset(x,y)) continue;\n      ans+=dist;\n      merge(x,y);\n    }\n\n    printf(\"%.3f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <math.h>\nusing namespace std;\n#define INF 1<<28\nconst double eps=1e-8 ;\n\ndouble sqrt1(double a)\n{\n    return a*a;\n}\ndouble x[123],y[123],z[142],r[231];\n\ndouble dis(int i,int j)\n{\n    return sqrt(sqrt1(x[i]-x[j])+sqrt1(y[i]-y[j])+sqrt1(z[i]-z[j]));\n}\n\nint vis[1230];\n\ndouble map[123][123];\ndouble d[1001];\n\nint n;\n\nint prim()\n{\n    double ans = 0 ;\n    for(int i = 1 ; i <= n ; i++)\n    {\n        d[i] = INF ;\n        vis[i] = false ;\n    }\n    d[1] = 0 ;\n    for(int i = 1 ; i <= n ; i++)\n    {\n        int minn = INF ;\n        int flag = 0 ;\n        for(int j = 1 ; j <= n ; j++)\n        {\n            if(minn > d[j]&&!vis[j])\n            {\n                minn = d[j] ;\n                flag = j ;\n            }\n        }\n        if(minn >= INF)\n            break;\n        ans += minn ;\n        vis[flag] = true ;\n        for(j = 1 ; j <= n ; j++)\n        {\n            if(!vis[j]&&d[j]>map[flag][j])\n                d[j] = map[flag][j] ;\n        }\n    }\n    printf(\"%.3lf\\n\",ans);\n}\n\nint main()\n{\n\twhile(cin>>n)\n\t{\n\t\tif(n==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\t//printf(\"%lf----------\\n\",dis(i,j));\n\t\t\t\tif(dis(i,j)-r[i]-r[j]<=0)\n\t\t\t\tmap[i][j]=0;\n\t\t\t\telse if(dis(i,j)-r[i]-r[j]>eps)\n\t\t\t\tmap[i][j]=dis(i,j)-r[i]-r[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprim();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nstruct pos3\n{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pos3> ball(n);\n\t\tREP(i, n) {\n\t\t\tdouble a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tball[i] = { a,b,c,d };\n\t\t}\n\t\tvector<pair<double, pii>> dis;\n\t\tREP(i, n)\n\t\t\tFOR(j, i + 1, n) {\n\t\t\tdis.push_back({\n\t\t\t\tsqrt((ball[i].x - ball[j].x)*(ball[i].x - ball[j].x) +\n\t\t\t\t(ball[i].y - ball[j].y)*(ball[i].y - ball[j].y) +\n\t\t\t\t(ball[i].z - ball[j].z)*(ball[i].z - ball[j].z)) -\n\t\t\t\tsqrt((ball[i].r + ball[j].r)*(ball[i].r + ball[j].r))\n\t\t\t\t,{i,j} });\n\t\t}\n\t\tSORT(dis);\n\t\tUnionFind uf(n);\n\t\tdouble ans = 0.0;\n\t\tREP(i, dis.size()) {\n\t\t\tif (uf.find(dis[i].second.first) != uf.find(dis[i].second.second)) {\n\t\t\t\tuf.unite(dis[i].second.first, dis[i].second.second);\n\t\t\t\tans += max(0.0, dis[i].first);\n\t\t\t\tbool clear = true;\n\t\t\t\tFOR(i, 1, n)\n\t\t\t\t\tif (uf.find(0) != uf.find(i))\n\t\t\t\t\t\tclear = false;\n\t\t\t\tif (clear)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ld cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nvector<edge> es;\nint V;\nld kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tld res = 0;\n\tfor (int i = 0; i < (int)es.size(); i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nstruct point { ld x, y, z, r; };\nld dis(point a,point b) {\n\tld res;\n\tres = sqrt(pow(a.x-b.x,2.0) + pow(a.y - b.y, 2.0) + pow(a.z - b.z, 2.0));\n\tres -= (a.r + b.r);\n\tif (res < 0) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin>>V,V){\n\t\tes.clear();\n\t\tpoint p[101];\n\t\tld x, y, z, r;\n\t\trep(i, V) {\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tp[i] = { x,y,z,r };\n\t\t}\n\t\trep(i, V) {\n\t\t\tRep(j, i + 1, V) {\n\t\t\t\tes.push_back({ i,j,dis(p[i],p[j]) });\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(5) << kruskal() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nstruct edge { int from, to; double dist; };\n\nstruct UnionFind {\n\tvector<int> vec;\n\tUnionFind(int n) { vec.resize(n, -1); };\n\n\tbool unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return false;\n\t\tif (vec[a] > vec[b]) swap(a, b);\n\t\tvec[a] += vec[b];\n\t\tvec[b] = a;\n\t\treturn true;\n\t}\n\tbool same(int a, int b) { return find(a) == find(b); }\n\tint find(int x) { return vec[x] < 0 ? x : vec[x] = find(vec[x]); }\n\tint size(int x) { return -vec[find(x)]; };\n};\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\tvector<edge> graph;\n\t\tusing tup = tuple<double, double, double, double>;\n\t\tvector<tup> v(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y, z, r; cin >> x >> y >> z >> r;\n\t\t\tv[i] = tup(x, y, z, r);\n\t\t}\n\n\t\tUnionFind uf(n);\n\t\trep(i, n) rep(j, i + 1, n) {\n\t\t\tauto a = v[i], b = v[j];\n\t\t\tdouble d = hypot(hypot(get<0>(a) - get<0>(b), get<1>(a) - get<1>(b)), get<2>(a) - get<2>(b)) - get<3>(a) - get<3>(b);\n\t\t\tif (d <= 0) uf.unite(i, j);\n\t\t\telse graph.push_back(edge{ i, j, d });\n\t\t}\n\n\t\tdouble ans = 0;\n\t\tsort(all(graph), [](edge e1, edge e2) {return e1.dist < e2.dist; });\n\t\tfor (auto& e : graph) if (!uf.same(e.from, e.to)) {\n\t\t\tuf.unite(e.from, e.to);\n\t\t\tans += e.dist;\n\t\t}\n\n\t\tprintf(\"%.6f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j),q++;\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdiss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])break;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(22)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nstruct Edge {\n  size_t src, dst;\n  double cost;\n  Edge(size_t src, size_t dst, double cost): src(src), dst(dst), cost(cost) {};\n  bool operator <(const Edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nclass UnionFind {\n  size_t n;\n  std::vector<int> size;\n\npublic:\n  UnionFind(size_t n): n(n), size(n, -1) {}\n\n  bool unite(size_t u, size_t v) {\n    u = find_root(u);\n    v = find_root(v);\n    if (u == v) return false;\n\n    if (-size[u] < -size[v])\n      std::swap(u, v);\n\n    // u >= v\n    size[u] += size[v];\n    size[v] = u;\n\n    return true;\n  }\n\n  size_t find_root(size_t u) {\n    if (size[u] < 0) return u;\n    return (u = find_root(size[u]));\n  }\n\n  bool is_connected(size_t u, size_t v) {\n    return find_root(u) == find_root(v);\n  }\n};\n\ndouble kruskal(std::vector<std::vector<Edge>> &g) {\n  size_t v=g.size();\n  std::vector<Edge> es;\n  for (size_t i=0; i<v; ++i) {\n    for (size_t j=0; j<g[i].size(); ++j) {\n      es.emplace_back(g[i][j]);\n    }\n  }\n\n  size_t e=es.size();\n  std::sort(es.begin(), es.end());\n  UnionFind uf(v);\n  double res=0;\n  for (size_t i=0; i<e; ++i) {\n    Edge e=es[i];\n    if (!uf.is_connected(e.src, e.dst)) {\n      uf.unite(e.src, e.dst);\n      res += e.cost;\n    }\n  }\n\n  return res;\n}\n\ndouble hypot3d(double x, double y, double z) {\n  return sqrt(x*x+y*y+z*z);\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n\n  if (n == 0)\n    return 1;\n\n  std::vector<double> x(n), y(n), z(n), r(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &z[i], &r[i]);\n  }\n\n  std::vector<std::vector<Edge>> d(n, std::vector<Edge>(n, Edge(0, 0, 0)));\n  for (size_t i=0; i<n; ++i) {\n    for (size_t j=i+1; j<n; ++j) {\n      double dist=hypot3d(x[i]-x[j], y[i]-y[j], z[i]-z[j]);\n      if (dist <= r[i] + r[j]) {\n\td[i][j] = Edge(i, j, 0);\n\td[i][j] = Edge(j, i, 0);\n      } else {\n\td[i][j] = Edge(i, j, dist - (r[i]+r[j]));\n\td[j][i] = Edge(j, i, dist - (r[i]+r[j]));\n      }\n    }\n  }\n\n  printf(\"%.3f\\n\", kruskal(d));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst double eps = 1e-9;\nconst double inf = 1e9;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\t\n\t\tvector<vector<double> > dist(n, vector<double>(n, inf));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tdouble d = sqrt( (x[i]-x[j])*(x[i]-x[j]) \n\t\t\t\t\t+(y[i]-y[j])*(y[i]-y[j]) +(z[i]-z[j])*(z[i]-z[j]) );\n\t\t\t\tif(d-r[i]-r[j] < eps){\n\t\t\t\t\tdist[i][j] = dist[j][i] = 0.0;\n\t\t\t\t}else{\n\t\t\t\t\tdist[i][j] = dist[j][i] = d -r[i]-r[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> used(n, false);\n\t\tdouble total=0.0;\n\t\tpriority_queue<pair<double, int> > pq;\n\t\tpq.push(make_pair(0.0, 0));\n\t\twhile(!pq.empty()){\n\t\t\tdouble cost = -pq.top().first;\n\t\t\tint v = pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(used[v]) continue;\n\t\t\tused[v]=true;\n\t\t\ttotal+=cost;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tpq.push(make_pair(-dist[v][i], i));\n\t\t\t}\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(3);\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(3);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\n\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nconstexpr int DEB_LEN =20;\nconstexpr int DEB_LEN_H =12;\nstring deb_tos(const int &v) { if (abs(v) == inf || abs(v) == linf)return \"e\"; else return to_string(v); }\ntemplate<class T> string deb_tos(const T &a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string deb_tos(const vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), DEB_LEN);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << deb_tos(a[i]);        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            lens[wi] = max(lens[wi], sz(deb_tos(a[h][W[wi]])) + 1);            lens[wi] = max(lens[wi], sz(deb_tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            ss << std::right << std::setw(lens[wi]) << deb_tos(a[h][w]);            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), DEB_LEN_H});    W = min({W, sz(a[0]), DEB_LEN_H});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return deb_tos(a, hs, ws, key);}\ntemplate<class T> string deb_tos(const vector<vector<vector<T> > > &a, ll H = inf) {    stringstream ss;    if (H == inf)H = DEB_LEN_H;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << deb_tos(a[i], inf, inf, i);    }    return ss.str();}\ntemplate<class T, size_t A> string deb_tos(T (&a)[A]) { return deb_tos(vector<T>(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B> string deb_tos(T (&a)[A][B]) { return deb_tos(vector<vector<T> >(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B, size_t C> string deb_tos(T (&a)[A][B][C]) { return deb_tos(vector<vector<vector<T> > >(begin(a), end(a))); }\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<deb_tos(x)<<\", \"<< debugName(y)<<\" = \"<<deb_tos(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<deb_tos(x)  << \", \" <<  debugName(y)<<\" = \"<<deb_tos(y) <<\", \" debugName(z)<<\" = \"<<deb_tos(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) <<\", \" <<   debugName(y)<<\" = \"<<deb_tos(y) <<\", \" <<  debugName(z)<<\" = \"<<deb_tos(z) <<\", \" <<  debugName(a)<<\" = \"<<deb_tos(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) <<\", \" <<   debugName(y)<<\" = \"<<deb_tos(y) <<\", \" <<  debugName(z)<<\" = \"<<deb_tos(z) <<\", \" <<  debugName(a)<<\" = \"<<deb_tos(a)<<\", \" <<  debugName(b)<<\" = \"<<deb_tos(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.push_back(v);\n    r_ a;\n}\ntemplate<class T> v_<T>& operator+=(v_<T> & a,const v_<T> & b){\n    fora(v, b)a += v;\n    return a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    rep(i, sz(m)){os << m[i];if(i < sz(m)-1)os<<\" \";}   r_ os;}\nostream &operator<<(ostream &os, v_<char> &m) {rep(i, sz(m)){os << m[i];}   r_ os;}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<v_<T>> &m) {rep(i, sz(m)){os << m[i]; if(i < sz(m)-1)os << endl;}   r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nvoid out() { cout << \"\" << endl; }\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n\n//@formatter:off\n//よく使うクラス、構造体\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n//    VEC<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};\nvoid solve() {\n    while(cin>>N, N){\n        vd X(N),Y(N),Z(N),R(N);\n        rep(i, N)\n        {\n            cin>>X[i]>>Y[i]>>Z[i]>>R[i];\n        }\n        unionfind uf(N);\n        vector<tuple<dou,int,int>> ed;\n        rep(i, N){\n            rep(j, i){\n                dou dis = -R[i]-R[j];\n                dis += std::sqrt(pow(X[i]-X[j], 2)+\n                                 pow(Y[i]-Y[j], 2)+\n                                 pow(Z[i]-Z[j], 2)\n                                 );\n                if(dis <= 0){\n                    uf.unite(i, j);\n                }else{\n                    ed+=make_tuple(dis, i, j);\n                }\n            }\n        }\n        sort(ed);\n        dou res=0;\n\n        for(auto&& e : ed){\n            dou c;\n            int t, f;\n            tie(c, f,t) = e;\n            if(uf.unite(f, t)){\n                res += c;\n            }\n        }\n//        cout<<res<<endl;\n        out(res);\n    }\n\n\n}\n\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, P> Q;\n\nll n;\ndouble x[100], y[100], z[100], r[100];\n\ndouble square(double x) { return x * x; }\n\nclass UF {\n  ll par[100];\npublic:\n  UF() {\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x) {\n    if (x != par[x]) par[x] = find(par[x]);\n    return par[x];\n  }\n  void merge(ll x, ll y) {\n    x = find(x), y = find(y);\n    par[x] = y;\n  }\n  bool same(ll x, ll y) { return find(x) == find(y); }\n};\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll i = 0; i < n; i++) scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n    priority_queue<Q, vector<Q>, greater<Q>> pq;\n    for (ll i = 0; i < n; i++) for (ll j = i+1; j < n; j++) {\n      double temp = sqrt(square(x[i]-x[j]) + square(y[i]-y[j]) + square(z[i]-z[j])) - r[i] - r[j];\n      pq.push(Q(max(0.0, temp), P(i, j)));\n    }\n    UF uf;\n    double ans = 0.0;\n    while (!pq.empty()) {\n      Q p = pq.top(); pq.pop();\n      ll i = p.second.first, j = p.second.second;\n      double c = p.first;\n      if (uf.same(i, j)) continue;\n      uf.merge(i, j);\n      ans += c;\n    }\n    printf(\"%.3lf\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<double, P> PDP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 100\n\nstruct Point {\n  double x, y, z, r;\n};\n\nPoint p[MAX_N];\nint parent[MAX_N];\ndouble ans;\n\ndouble dis(int i, int j) {\n  return sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y)\n           + (p[i].z - p[j].z) * (p[i].z - p[j].z));\n}\n\ndouble  corridor(int i, int j) {\n  double d = dis(i, j);\n  if (d > p[i].r + p[j].r) return d - (p[i].r + p[j].r);\n  else return 0;\n}\n\nint find(int i) {\n  if (i == parent[i]) return i;\n  return parent[i] = find(parent[i]);\n}\n\nvoid unite(PDP v) {\n  int x = find(v.se.fi), y = find(v.se.se);\n  if (x == y) return;\n\n  parent[y] = x;\n  ans += v.fi;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n\n  while(cin >> n, n) {\n    rep(i, n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n    vector<PDP> v;\n    rep(i, n - 1)repl(j, i + 1, n)  v.pb(PDP(corridor(i, j), P(i, j)));\n    rep(i, n) parent[i] = i;\n\n    sort(all(v));\n    ans = 0;\n\n    rep(i, v.size()) unite(v[i]);\n\n    printf(\"%.3f\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) { parent.assign(n, -1); }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\ntypedef long double ld;\ntypedef ld Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<tuple<ld,ld,ld,ld>> vp;\n    REP(i,n){\n      ld x,y,z,r;\n      cin>>x>>y>>z>>r;\n      vp.emplace_back(x,y,z,r);\n    }\n    Edges es;\n    REP(i,n)REP(j,i) {\n      ld x1,y1,z1,r1,x2,y2,z2,r2;\n      tie(x1,y1,z1,r1) = vp[i];\n      tie(x2,y2,z2,r2) = vp[j];\n      ld d = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));\n      es.push_back((Edge){i,j,max((ld)0,d-r1-r2)});\n    }\n    auto res = kruskal(n, es);\n    ld sum = 0;\n    for(auto e:res) sum += e.weight;\n    cout<<setprecision(3)<<fixed<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r,t;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(q=m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r}),parent[i]=i;\n\t\t\tfor(j=0;j<i;j++){\n\t\t\t\tfor(x=k=0;k<3;k++)x+=(t=v[i][k]-v[j][k])*t;\n\t\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\t\tif(x<=0){if(unite(i,j))q++;}\n\t\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t\t}\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing DII = tuple<double, int, int>;\n\nstruct\tUnionFind {\n\tint\t\tsize;\n\tint\t\t*par;\n\tint\t\t*rank;\n\tint\t\tnum_group;\n\tUnionFind(int size): size(size), par(NULL), rank(NULL), num_group(size) {\n\t\tassert(size > 0);\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tassert(par != NULL && rank != NULL);\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t~UnionFind() {\n\t\tdelete [] par;\n\t\tdelete [] rank;\n\t\tpar = NULL;\n\t\trank = NULL;\n\t}\n\tint\t\tfind(int idx) {\n\t\tif (par[idx] == idx)\n\t\t\treturn idx;\n\t\treturn (par[idx] = find(par[idx]));\n\t}\n\tbool\tsame(int lhs, int rhs) {\n\t\tif (find(lhs) == find(rhs))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tvoid\tunite(int lhs, int rhs) {\n\t\tint\tpar_l = find(lhs), par_r = find(rhs);\n\t\tif (par_l == par_r)\n\t\t\treturn;\n\t\tif (rank[par_l] < rank[par_r]) {\n\t\t\tpar[par_l] = par_r;\n\t\t\t--num_group;\n\t\t} else {\n\t\t\tpar[par_r] = par_l;\n\t\t\tif (rank[par_l] == rank[par_r])\n\t\t\t\t++rank[par_l];\n\t\t\t--num_group;\n\t\t}\n\t}\n};\n\ndouble\tcalc_dist(const vector<double> &x_vec,\n\t\t\tconst vector<double> &y_vec, const vector<double> &z_vec,\n\t\t\tint i, int j)\n{\n\tdouble dx2 = (x_vec.at(i) - x_vec.at(j)) * (x_vec.at(i) - x_vec.at(j));\n\tdouble dy2 = (y_vec.at(i) - y_vec.at(j)) * (y_vec.at(i) - y_vec.at(j));\n\tdouble dz2 = (z_vec.at(i) - z_vec.at(j)) * (z_vec.at(i) - z_vec.at(j));\n\treturn sqrt(dx2 + dy2 + dz2);\n}\n\ndouble\tsolve(int n, const vector<double> &x_vec,\n\t\t\tconst vector<double> &y_vec, const vector<double> &z_vec,\n\t\t\tconst vector<double> &r_vec)\n{\n\tUnionFind\tuf(n);\n\tvector<DII>\tedge_vec;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tdouble\tdist = calc_dist(x_vec, y_vec, z_vec, i, j);\n\t\t\tdouble\tcost = dist - r_vec.at(i) - r_vec.at(j);\n\t\t\tif (cost <= 0) {\n\t\t\t\tuf.unite(i, j);\n\t\t\t} else {\n\t\t\t\tedge_vec.push_back(make_tuple(cost, i, j));\n\t\t\t}\n\t\t}\n\t}\n\tif (edge_vec.size() == 0 || uf.num_group == 1) \n\t\treturn 0.;\n\tsort(edge_vec.begin(), edge_vec.end());\n\tint i, j;\n\tdouble cost;\n\tdouble sum_cost = 0;\n\tfor (auto tpl : edge_vec) {\n\t\ttie(cost, i, j) = tpl;\n\t\tif (uf.same(i, j))\n\t\t\tcontinue;\n\t\tuf.unite(i, j);\n\t\tsum_cost += cost;\n\t\tif (uf.num_group == 1)\n\t\t\tbreak;\n\t}\n\treturn sum_cost;\n}\n\nint\tmain()\n{\n\tint\tn;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tvector<double>\tx_vec(n), y_vec(n), z_vec(n), r_vec(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> x_vec.at(i) >> y_vec.at(i) >> z_vec.at(i) >> r_vec.at(i);\n\t\tdouble result = solve(n, x_vec, y_vec, z_vec, r_vec);\n\t\tcout << fixed << setprecision(3) << result << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#define INF 1e16\nusing namespace std;\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\t// ------ Variables ------ //\n\tint V, E; vector<vector<pair<int, long double> > > G;\n\n\t// ------ Constructors ------ //\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long double> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long double> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long double> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\n\t// ------ Basic Functions ------ //\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long double w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long double w) { add1(v1, v2, w); add1(v2, v1, w); }\n\n\t// ------ Operators ------ //\n\tbool operator==(const Graph2& g) const { return G == g.G; }\n\tbool operator!=(const Graph2& g) const { return G != g.G; }\n\tvector<pair<int, long double> > operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tlong double minspan() {\n\t\tvector<long double> d(V, INF);\n\t\tvector<bool> used(V, false);\n\t\tpriority_queue<pair<long double, int> > que;\n\t\tfor (int i = 0; i < V; i++) d[i] = INF;\n\t\td[0] = 0; que.push(make_pair(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int> pa = que.top(); que.pop();\n\t\t\tint u = pa.second; used[u] = true;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first;\n\t\t\t\tif (d[v] > G[u][i].second && !used[v]) {\n\t\t\t\t\td[v] = G[u][i].second; que.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double sum = 0;\n\t\tfor (int i = 0; i < V; i++) sum += d[i];\n\t\treturn sum;\n\t}\n};\n// ------ Main ------ //\nint n; long double x[111], y[111], z[111], r[111];\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tGraph2 G(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tlong double dist = sqrtl((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n\t\t\t\tG.add2(i, j, (dist > r[i] + r[j]) ? (dist - r[i] - r[j]) : 0)\n\t\t\t}\n\t\t}\n\t\tcout << G.minspan() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ndouble x[100],y[100],z[100],r[100];\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]) ); \n}\n\nint main(){\n  int n;\n  double d[100][100];\n  int par[100];\n  int tmp;\n  int i,j,k,h,w;\n  double min,ans;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n      for(j=0;j<n;j++)d[i][j] = 0.0;\n      par[i] = i;\n    }\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tdouble len = dis(i,j);\n\tif(len > r[i]+r[j])d[i][j] = len - (r[i]+r[j]);\n\telse{\n\t  tmp = par[j];\n\t  for(k=0;k<n;k++){\n\t    if(par[k] == tmp)par[k] = par[i];\n\t  }\n\t}\n      }\n    }\n\n    ans = 0.0;\n    while(1){\n      for(i=1;i<n;i++){\n\tif(par[i]!=par[0])break;\n      }\n      if(i==n)break;\n\n      min = 1000001.0;\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++){\n\t  if(d[i][j] > 0.0 && min > d[i][j] && par[i] != par[j]){\n\t    min = d[i][j];\n\t    h = i;\n\t    w = j;\n\t  }\n\t}\n      }\n\n      ans += min;\n      tmp = par[w];\n      for(i=0;i<n;i++){\n\tif(par[i] == tmp)par[i] = par[h];\n      }\n    }\n\n    printf(\"%.3lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#define INF 1<<29\n#define MAX_V 200\nusing namespace std;\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;\ndouble prim(){\n\tfor(int i=0;i<V;i++){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tdouble res=0;\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v]))\n\t\t\tv=u;\n\t\t}\n\t\tif(v==-1)\n\t\tbreak;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(int u=0;u<V;u++){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>V,V){\n\t\tdouble x[MAX_V],y[MAX_V],z[MAX_V],r[MAX_V];\n\t\tfor(int i=0;i<V;i++)\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tfor(int i=0;i<V;i++)\n\t\tfor(int j=0;j<V;j++){\n\t\t\tif(i==j)\n\t\t\tcost[i][j]=INF;\n\t\t\telse{\n\t\t\t\tcost[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-(r[i]+r[j]);\n\t\t\t\tif(cost[i][j]<=0)\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\",prim());\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<deque>\n#include<queue>\n#include<list>\n#include<stack>\n#include<map>\n#include<vector>\n#define inf 0x3f3f3f3f\n#define N 2200000\n#define mod 1e9+9\n#define eps 1e-9\n#define clr(x,a) memset(x,a,sizeof(x))\n#define sqr(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst double PI=acos(-1.0);\n\nstruct ZT{\n    int st,en;\n    double cost;\n};\nZT zt[N];\nstruct BALL{\n    double x,y,z;\n    double r;\n};\nBALL ball[N];\nint n;\nint root[N];\nint finds(int x)\n{\n    if(root[x]!=x)\n        return root[x]=finds(root[x]);\n    return root[x];\n}\nint cmp(const ZT &a,const ZT &b)\n{\n    return a.cost<b.cost;\n}\nint main()\n{\n    while(~scanf(\"%d\",&n)&&n)\n    {\n        for(int h=0;h<n;h++)\n            scanf(\"%lf %lf %lf %lf\",&ball[h].x,&ball[h].y,&ball[h].z,&ball[h].r);\n        int ct=0;\n        for(int h=0;h<n;h++)\n            for(int i=h+1;i<n;i++)\n            {\n                double len=sqrt(sqr(ball[h].x-ball[i].x)+sqr(ball[h].y-ball[i].y)+sqr(ball[h].z-ball[i].z));\n                len-=ball[h].r+ball[i].r;\n                len=max(len,0.0);\n                zt[ct].st=h;\n                zt[ct].en=i;\n                zt[ct++].cost=len;\n            }\n        for(int h=0;h<=ct;h++)\n            root[h]=h;\n        sort(zt,zt+ct,cmp);\n        double sum=0;\n        for(int h=0;h<ct;h++)\n        {\n            int x=finds(zt[h].st);\n            int y=finds(zt[h].en);\n            if(x!=y)\n            {\n                root[x]=y;\n                sum+=zt[h].cost;\n            }\n        }\n        printf(\"%.3lf\\n\",sum);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<double, P> edge;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n;\ndouble x[111],y[111],z[111],r[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    UnionFind uf(n);\n    vector<edge> es;\n    rep(i,n)rep(j,i){\n      double dist=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2));\n      if(dist<=r[i]+r[j]){\n        uf.unite(i,j);\n      }else{\n        es.push_back(edge(dist-r[i]-r[j],P(i,j)));\n      }\n    }\n    double res=0;\n    sort(all(es));\n    rep(i,es.size()){\n      if(uf.same(es[i].se.fi,es[i].se.se))continue;\n      uf.unite(es[i].se.fi,es[i].se.se);\n      res+=es[i].fi;\n    }\n    printf(\"%.3f\\n\", res);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, s, n) for(int i = s; i < n; i++)\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> par;\n  \n  UnionFind(int N) : par(N){\n    for(int i = 0; i < N; i++) par[i] = i;\n  }\n  \n  int root(int x){\n    if (par[x] == x) return x;\n    return par[x] = root(par[x]);\n  }\n  \n  bool unite(int x, int y){\n    int rx = root(x);\n    int ry = root(y);\n    if (rx == ry) return false;\n    par[rx] = ry;\n    return true;\n  }\n  \n  bool same(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nstruct corridor {\n  int a, b;\n  double len;\n  corridor(int a, int b, double len) : a(a), b(b), len(len){}\n  \n  bool operator <(const corridor& rhs) const{\n    if (len != rhs.len) { return len < rhs.len; }\n    if (a != rhs.a) { return a < rhs.a; }\n    return b < rhs.b;\n  }\n};\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2) );\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    UnionFind tree(n);\n    vector<double> x(n), y(n), z(n), r(n);\n    rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n    vector<corridor> cor;\n    rep(i, n)rep2(j, i+1, n){\n      cor.push_back(corridor(i, j, max(0.0, dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j])));\n    }\n    sort(cor.begin(), cor.end());\n\n    double ans = 0.0;\n    int count = 0;\n    for(auto itr = cor.begin(); count < n - 1; itr++){\n      if (tree.unite(itr->a, itr->b)){\n        ans += itr->len;\n        count++;\n      }\n    }\n    cout << fixed << setprecision(3) << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n    vector<int> p;\n\n    UF(int n) {\n        p.resize(n);\n        for(int i=0;i<n;i++){\n            p[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if(x == p[x]){\n            return x;\n        }else{\n            return p[x] = find(p[x]);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        p[y] = p[x];\n    }\n};\n\nint main() {\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        UF uf(n);\n\n        vector<double> x(n), y(n), z(n), r(n);\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        vector<pair<double, pair<int, int>>> e;\n\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                double dx = x[i]-x[j];\n                double dy = y[i]-y[j];\n                double dz = z[i]-z[j];\n                e.push_back({max(0.0, sqrt(dx*dx+dy*dy+dz*dz)-r[i]-r[j]), {i, j}});\n            }\n        }\n\n        sort(e.begin(), e.end());\n\n        double ans = 0;\n        for(int i=0;i<(int)e.size();i++){\n            int x = e[i].second.first;\n            int y = e[i].second.second;\n            double d = e[i].first;\n            if(uf.find(x) != uf.find(y)){\n                ans += d;\n                uf.unite(x, y);\n            }\n        }\n\n        printf(\"%.3lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Point {\npublic:\n  Point() {}\n  Point(double x, double y, double z) {\n    c[0] = x;\n    c[1] = y;\n    c[2] = z;\n  }\n  double c[3];\n};\n\nclass Dist {\npublic:\n  Dist() {}\n  Dist(double d, int s2, int t2) {\n    dist = d;\n    s = s2;\n    t = t2;\n  }\n  double dist;\n  int s, t;\n};\n\nbool operator < (const Dist& a, const Dist& b) {\n  return a.dist < b.dist;\n}\n\ndouble CalcDist(const Point& a, const Point& b) {\n  double res = 0;\n  for(int i = 0; i < 3; ++i) {\n    res += (a.c[i] - b.c[i]) * (a.c[i] - b.c[i]);\n  }\n  return sqrt(res);\n}\n\nstd::vector<Dist> dists;\nstd::vector<std::pair<Point, double> > points;\n\nint n;\n\nint parent[128];\n\nvoid Init() {\n  dists.clear();\n  points.clear();\n  for(int i = 0; i < 128; ++i) {\n    parent[i] = i;\n  }\n}\n\nint Find(int x) {\n  if( parent[x] == x ) return x;\n  return parent[x] = Find(parent[x]);\n}\n\nbool Same(int x, int y) {\n  x = Find(x);\n  y = Find(y);\n  return x == y;\n}\n\nvoid Union(int x, int y) {\n  x = Find(x);\n  y = Find(y);\n  if( x == y ) return;\n  if( rand() % 2 ) std::swap(x, y);\n  parent[x] = y;                     \n}\n\n\nint main() {\n  for(;;) {\n    Init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      double x, y, z, r;\n      scanf(\"%lf %lf %lf %lf\", &x, &y, &z, &r);\n      points.push_back(std::pair<Point, double>(Point(x, y, z), r));\n    }\n    for(int i = 0; i < n; ++i) {\n      for(int j = i + 1; j < n; ++j) {\n        double d = CalcDist(points[i].first, points[j].first);\n        d = std::max(0.0, d - points[i].second - points[j].second);\n        dists.push_back(Dist(d, i, j));\n      }\n    }\n    std::sort(dists.begin(), dists.end());\n    double res = 0.0;\n    for(int i = 0; i < (int)dists.size(); ++i) {\n      int x = dists[i].s;\n      int y = dists[i].t;\n      double d = dists[i].dist;\n      if( Same(x, y) ) continue;\n      res += d;\n      Union(x, y);\n    }    \n    printf(\"%.3lf\\n\", res);\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n  \nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tdouble x[101], y[101], z[101], r[101];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tdouble kyori_pow2[101][101];\n\t\tbool ischecked[101];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tkyori_pow2[i][i] = 0.0;\n\t\t\tischecked[i] = false;\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdouble k = sqrt(pow((x[i] - x[j]), 2) + pow((y[i] - y[j]), 2) + pow((z[i] - z[j]), 2));\n\t\t\t\tkyori_pow2[i][j] = max(0.0, k - r[i] - r[j]);\n\t\t\t\tkyori_pow2[j][i] = max(0.0, k - r[i] - r[j]);\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0.0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble mind = 10000000.0;\n\t\t\tint j = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(ischecked[k]) continue;\n\t\t\t\tif(kyori_pow2[0][k] < mind){\n\t\t\t\t\tmind = kyori_pow2[0][k];\n\t\t\t\t\tj = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j == -1) break;\n\t\t\tans += mind;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tkyori_pow2[0][k] = min(kyori_pow2[0][k], kyori_pow2[j][k]);\n\t\t\t}\n\t\t\tischecked[j] = true;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, P> Q;\n\nll n;\ndouble x[100], y[100], z[100], r[100];\n\ndouble square(double x) { return x * x; }\n\nclass UF {\n  ll par[100];\npublic:\n  UF() {\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x) {\n    if (x != par[x]) par[x] = find(par[x]);\n    return par[x];\n  }\n  void merge(ll x, ll y) {\n    x = find(x), y = find(y);\n    par[x] = y;\n  }\n  bool same(ll x, ll y) { return find(x) == find(y); }\n};\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll i = 0; i < n; i++) scanf(\"%lf%lf%lf%lf\", &x[i], &y[i], &z[i], &r[i]);\n    priority_queue<Q, vector<Q>, greater<Q>> pq;\n    for (ll i = 0; i < n; i++) for (ll j = i+1; j < n; j++) {\n      double temp = sqrt(square(x[i]-x[j]) + square(y[i]-y[j]) + square(z[i]-z[j])) - r[i] - r[j];\n      pq.push(Q(max(0.0, temp), P(i, j)));\n    }\n    UF uf;\n    double ans = 0.0;\n    while (!pq.empty()) {\n      Q p = pq.top(); pq.pop();\n      ll i = p.second.first, j = p.second.second;\n      double c = p.first;\n      if (uf.same(i, j)) continue;\n      uf.merge(i, j);\n      ans += c;\n    }\n    printf(\"%.3lf\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,int> P;\n\nconst double INF = 1e10;\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        vector<vector<double> > dis(n, vector<double>(n, INF));\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double tdis = pow(x[i] - x[j], 2.0) + pow(y[i] - y[j], 2.0) + pow(z[i] - z[j], 2.0);\n                tdis = sqrt(tdis) - r[i] - r[j];\n                if (tdis < 0.0) tdis = 0.0;\n                dis[i][j] = dis[j][i] = tdis;\n            }\n        }\n\n        priority_queue<P, vector<P>, greater<P> > que;\n        vector<bool> used(n, false);\n        double res = 0.0;\n        for (int i = 0; i < n; i++) {\n            que.push(P(dis[0][i], i));\n        }\n        used[0] = true;\n        while (que.size()) {\n            P p = que.top(); que.pop();\n\n            if (used[p.second]) continue;\n            res += p.first;\n            used[p.second] = true;\n            for (int i = 0; i < n; i++) {\n                que.push(P(dis[p.second][i], i));\n            }\n        }\n\n        printf(\"%.6f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ndouble cost[101][101];\ndouble mincost[101];\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\ndouble INF = numeric_limits<double>::max();\nint main(void){\n    int n;\n    while(cin >> n && n) {\n        rep(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, n) rep(j, n) {\n            cost[i][j] = max(sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j], 0.0);\n        }\n        // prim\n        rep(i, n) {\n            mincost[i] = INF;\n            used[i] = false;\n        }\n        mincost[0] = 0;\n        double res = 0;\n\n        while(true) {\n            int v = -1;\n            rep(u, n) {\n                if(!used[u] && (v==-1 || mincost[u] < mincost[v])) v = u;\n            }\n            if(v == -1) break;\n            used[v] = true;\n            res += mincost[v];\n\n            rep(u, n) {\n                mincost[u] = min(mincost[u], cost[v][u]);\n            }\n        }\n        printf(\"%.3lf\\n\", res);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\ndouble hypot3(double x,double y,double z){\n\treturn sqrt(x*x+y*y+z*z);\n}\n\nstruct Cell{\n\tdouble x,y,z,r;\n};\n\nstruct Edge{\n\tint u,v;\n\tdouble cost;\n\tEdge(int _u,int _v,double c):u(_u),v(_v),cost(c){}\n\tbool operator<(const Edge &e)const{ return cost<e.cost; }\n};\n\nint uf[100];\nint UF_Root(int i){ return ~uf[i]?uf[i]=UF_Root(uf[i]):i; }\nbool UF_Find(int i,int j){ return UF_Root(i)==UF_Root(j); }\nvoid UF_Union(int i,int j){ uf[UF_Root(j)]=UF_Root(i); }\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tCell c[100];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&c[i].x,&c[i].y,&c[i].z,&c[i].r);\n\t\t\tuf[i]=-1;\n\t\t}\n\n\t\tpriority_queue<Edge> pq;\n\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\tdouble d=hypot3(c[i].x-c[j].x,c[i].y-c[j].y,c[i].z-c[j].z)-(c[i].r+c[j].r);\n\t\t\tif(d<0)\td=0;\n\t\t\tpq.push(Edge(i,j,-d));\n\t\t}\n\n\t\tint cnt=0;\n\t\tdouble total=0;\n\t\twhile(!pq.empty() && cnt<n-1){\n\t\t\tEdge e=pq.top();\tpq.pop();\n\t\t\tif(!UF_Find(e.u,e.v)){\n\t\t\t\tUF_Union(e.u,e.v);\n\t\t\t\ttotal+=-e.cost;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.3f\\n\",total);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nstruct E {\n\tint from, to;\n\tdouble cost;\n\tE(int a, int b, double c) {\n\t\tfrom = a; to = b; cost = c;\n\t}\n\tE();\n\tbool operator < (E b) {\n\t\treturn this->cost < b.cost;\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tvector<E> v;\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tv.push_back(E(i, j, max(double(0), sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j])) - r[i] - r[j])));\n\t\t\t}\n\t\t}\n\t\tsort(ALL(v));\n\t\tUnionFind uf(n);\n\t\tdouble ans = 0;\n\t\tREP(i, v.size()) {\n\t\t\tif (!uf.same(v[i].from, v[i].to)) {\n\t\t\t\tuf.unite(v[i].from, v[i].to);\n\t\t\t\tans += v[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(3)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define N 100\n\nconst int INF = (1 << 21);\n\nint label[N];\ndouble d[N],D[N][N],adj[N];\n\ndouble prim(int n){\n  double ret = 0;\n  REP(i,1,n+1)label[i]=0;\n  label[1] = 0 ;\n  adj[1] = 0;\n  REP(i,2,n+1){\n    d[i]=D[1][i];\n    adj[i]=1;\n  }\n  int c = 1;\n  \n  REP(i,1,n+1){\n    double dis = INF;\n    int w;\n    REP(j,1,n+1)\n      if (label[j] == 0 && d[j] < dis){dis=d[j];w=j;}\n    label[w]=1;c=w;\n    ret+=dis;\n    REP(j,1,n+1){\n      if (D[c][j] < d[j] && label[j] == 0){d[j]=D[c][j];adj[j]=c;}\n    }\n  }\n\n  return ret;\n}\n\n\nint main(){\n  while(1){\n    int n;\n    double in[101][4];\n    cin >> n;\n    if (n ==0)break;\n    for(int i=1;i<n+1;i++)\n      cin >> in[i][0] >> in[i][1] >> in[i][2] >> in[i][3];\n    \n    \n    for(int i=1;i<n+1;i++){\n      for(int j=1;j<n+1;j++){\n\tif (i == j){D[i][j]=0;continue;}\n\tdouble distance = sqrt( pow(in[i][0]-in[j][0],2)+pow(in[i][1]-in[j][1],2)+pow(in[i][2]-in[j][2],2));\n\tif ( distance > in[i][3]+in[j][3])D[i][j] = distance - (in[i][3]+in[j][3]);\n\telse if (distance <= in[i][3]+in[j][3])D[i][j] = 0;\n      }\n    }\n\n\n\n    \n    //prim(n);\n    //double total = 0;\n    //for(int i=0;i<n;i++){total+= d[i];}\n    printf(\"%.3lf\\n\",prim(n));\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define P pair<float, pair<int,int> >\n#define sqr(x) ((x) * (x))\n\nusing namespace std;\n\nint parent[100],rank[100];\n\nint findset(int x){\n  if(x!=parent[x]) parent[x] = findset(parent[x]);\n  return parent[x];\n}\n\nvoid link(int x,int y){\n  if(rank[x]>rank[y])\n    parent[y]=x;\n  else{\n    parent[x]=y;\n    if(rank[x]==rank[y]) rank[y]++;\n  }\n}\n\nvoid merge(int x,int y){\n  link(findset(x),findset(y));\n}\n\nbool sameset(int x,int y){\n  return findset(x)==findset(y);\n}\n\nfloat x[100],y[100],z[100],r[100];\nvector<P> tako;\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    tako.clear();\n    for(int i=0; i<n; i++){\n      double xx,yy,zz,rr;\n      scanf(\"%lf %lf %lf %lf\",&xx,&yy,&zz,&rr);\n      x[i]=xx; y[i]=yy; z[i]=zz; r[i]=rr;\n\n      parent[i]=i; rank[i]=0;\n    }\n\n    for(int i=0; i<n-1; i++) for(int j=i+1; j<n; j++){\n      double dist = sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j])+sqr(z[i]-z[j]))-r[i]-r[j];\n      //      printf(\"dist: %f, x: %d, y: %d\\n\",dist,i,j);\n      dist = dist>0?dist:0;\n      tako.push_back(make_pair(dist,make_pair(i,j)));\n    }\n    sort(tako.begin(),tako.end());\n\n    double ans=0;\n    for(int i=0; i<tako.size(); i++){\n      double dist = tako[i].first;\n      int x=tako[i].second.first, y=tako[i].second.second;\n      if(sameset(x,y)) continue;\n      ans+=dist;\n      merge(x,y);\n    }\n\n    printf(\"%.3f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nlong double tolerance(const long double& a, const long double& b, const long double& epsilon = eps) {\n    return epsilon * max({1.l, abs(a), abs(b)});\n}\n\n// a<0なら-1, a==0なら0, a>0なら1\nint sgn(const long double a, const long double& epsilon = eps) {\n    return (a > epsilon) - (a < -epsilon);\n}\n\n// a<bなら-1, a==bなら0, a>bなら1\nint compare(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return sgn(a - b, is_relative ? tolerance(a, b, epsilon) : epsilon);\n}\n\n// a==bか?\nbool is_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 0;\n}\n\n// a<bか?\nbool is_less(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == -1;\n}\n\n// a<=bか?\nbool is_less_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) <= 0;\n}\n\n// a>bか?\nbool is_greater(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 1;\n}\n\n// a>=bか?\nbool is_greater_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) >= 0;\n}\n\nclass union_find {\nprivate:\n    vector<int> parent, rank, gs;\n    int size;\n\npublic:\n    int count_group;\n    union_find() = default;\n    union_find(int n) { init(n); }\n\n    void init(int n) {\n        size = n;\n        count_group = n;\n        parent.resize(size);\n        rank.assign(size, 0);\n        gs.assign(size, 1);\n        for (int i = 0; i < size; ++i) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] == x)\n            return x;\n        else\n            return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) {\n            parent[x] = y;\n            gs[y] += gs[x];\n        } else {\n            parent[y] = x;\n            gs[x] += gs[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        --count_group;\n    }\n\n    bool is_same_group(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int group_size(int x) {\n        return gs[find(x)];\n    };\n};\n\nvoid solve(i64 n) {\n    //constexpr i64 mod = 1'000'000'007;\n    vector<long double> x(n),y(n),z(n),r(n);\n    rep(i,0,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n    using edge=tuple<long double,i64,i64>;\n\n    vector<edge> edges;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            long double dx=x[i]-x[j];\n            long double dy=y[i]-y[j];\n            long double dz=z[i]-z[j];\n            long double d=sqrtl(dx*dx+dy*dy+dz*dz);\n            edges.emplace_back(make_tuple(max<long double>(d-r[i]-r[j],0),i,j));\n        }\n    }\n\n    sort(begin(edges),end(edges));\n\n    union_find uf(n);\n    long double ans=0;\n    for(const auto& e:edges){\n        long double d;\n        i64 u,v;\n        tie(d,u,v)=e;\n\n        if(uf.is_same_group(u,v)) continue;\n        uf.unite(u,v);\n\n        ans+=d;\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(3);\n    for(;;){\n        i64 n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 100\n#define MAX_E 10000\n \nint V,E,par[MAX_V],rank[MAX_V];\n \nstruct Colony{\n    double x,y,z,r;\n    Colony(){}\n    Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\n \nstruct Edge{\n    int u,v;\n    double dist;\n    Edge(){}\n    Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\n \nbool comp(const Edge &e1,const Edge &e2){\n    return e1.dist < e2.dist;\n}\n \nEdge es[MAX_E];\n \nvoid init(){\n    for(int i = 0 ; i < V ; i++){\n\tpar[i] = i;\n\trank[i] = 0;\n    }\n}\n \nint find(int x){\n    if(par[x] == x){\n\treturn x;\n    }\n    return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n \n    if(x == y) return;\n \n    if(rank[x] < rank[y]){\n\tpar[x] = y;\n    }else{\n\tpar[y] = x;\n\tif(rank[x] == rank[y]){\n\t    rank[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return find(x) == find(y);\n}\n \ndouble kruskal(){\n    sort(es,es+E,comp);\n    init();\n    double res = 0.0;\n    for(int i = 0 ; i < E ; i++){\n\tEdge e = es[i];\n\tif(!same(e.u,e.v)){\n\t    unite(e.u,e.v);\n\t    res += e.dist;\n\t}\n    }\n    return res;\n}\n \ndouble getDist(const Colony &c1,const Colony &c2){\n    return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n \nint main(){\n    while(cin >> V,V){\n\tE = 0;\n\tdouble x,y,z,r;\n\tColony C[MAX_V];\n\tfor(int i = 0 ; i < V ; i++){\n\t    cin >> x >> y >> z >> r;\n\t    C[i] = Colony(x,y,z,r);\n\t}\n     \n\tfor(int i = 0 ; i < V ; i++){\n\t    for(int j = i+1 ; j < V ; j++){\n\t\tdouble dist = getDist(C[i],C[j]);\n\t\tes[E++] = Edge(i,j,max(dist,0.0));\n\t    }\n\t}\n\tprintf(\"%.3f\\n\",kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; double w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble prim(int n, vector<edge> G[]) {\n\tvector<double> w(n, DBL_MAX); w[0] = 0;\n\tpriority_queue<d_i, vector<d_i>, greater<d_i>> q;\n\tq.push(d_i(0, 0));\n\tdouble res = 0;\n\twhile (!q.empty()) {\n\t\td_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > w[u]) continue;\n\t\tres += w[u]; w[u] = -DBL_MAX;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (w[e.v] > e.w) {\n\t\t\t\tw[e.v] = e.w;\n\t\t\t\tq.push(d_i(e.w, e.v));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<edge> G[100];\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tG[i].clear();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdouble dx = x[i] - x[j], dy = y[i] - y[j], dz = z[i] - z[j];\n\t\t\t\tdouble l = max(0.0, sqrt(dx * dx + dy * dy + dz * dz) - (r[i] + r[j]));\n\t\t\t\tedge e = {i, j, l}, _e = {j, i, l};\n\t\t\t\tG[i].push_back(e); G[j].push_back(_e);\n\t\t\t}\n\t\tprintf(\"%.3f\\n\", prim(n, G));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,t;\ndouble MX = 1 << 20, mn;\ndouble mp[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmp[i][j] = MX;\n      }\n      p[i] = -1;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j){\n\t  mp[i][j] = 0;\n\t} else {\n\t  mp[i][j] = compute(i, j);\n\t}\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      res += d[t];\n      //if (p[t] != -1) res += mp[t][p[t]];\n      //printf(\"res: %.3f\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(mp[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = mp[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    printf(\"%.3f\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",x,y,z,r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j);\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n\tif(was_output)cout << \" \";\n\tcout << a;\n\twas_output = true;\n}\nvoid outendl(){\n\twas_output = false;\n\tcout << endl;\n}\n\nclass Vector3{\npublic:\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tVector3(double x_, double y_, double z_):x(x_), y(y_), z(z_){}\n\tVector3(){}\n};\n\nclass sphere{\npublic:\n\tVector3 p;\n\tdouble r;\n\tsphere(Vector3 p_, double r_):p(p_), r(r_){}\n\tsphere(){}\n};\n\nVector3 operator+(Vector3 a, Vector3 b){\n\treturn Vector3(a.x+b.x, a.y+b.y, a.z+b.z);\n}\nVector3 operator-(Vector3 a, Vector3 b){\n\treturn Vector3(a.x-b.x, a.y-b.y, a.z-b.z);\n}\nVector3 operator*(Vector3 a, double k){\n\treturn Vector3(a.x*k, a.y*k, a.z*k);\n}\ndouble abs(Vector3 a){\n\treturn sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\ndouble cul_distance(sphere a, sphere b){\n\treturn abs(a.p-b.p) - a.r - b.r;\n}\nbool is_connect_distance(sphere a, sphere b){\n\treturn cul_distance(a, b) <= 0.0001;\n}\n\ndouble func(int n){\n\tvector<sphere> spheres(n);\n\tforeach(i, spheres)cin>>i.p.x>>i.p.y>>i.p.z>>i.r;\n\tdouble res = 0;\n\tusing pdi = pair<double, int>;\n\tpriority_queuer<pdi> pq;\n\tvector<double> fast(n, INF);\n\tfast[0] = 0;\n\tpq.emplace(0, 0);\n\twhile(pq.size()){\n\t\tpdi d = pq.top();\n\t\tpq.pop();\n\t\tif(d.first != fast[d.second])continue;\n\t\tres += d.first;\n\t\trep(i, n){\n\t\t\tdouble dis = cul_distance(spheres[d.second], spheres[i]);\n\t\t\tchmax(dis, 0);\n\t\t\tif(dis < fast[i]){\n\t\t\t\tfast[i] = dis;\n\t\t\t\tpq.emplace(dis, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tprintf(\"%.3lf\\n\", func(n));\n\t}\n\n\n\n\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stdexcept>\n#include<cmath>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) D4(D2(a,b),D2(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define pf push_front\n#define LIM 100000\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<double,double> D2;\ntypedef pair<D2,D2> D4;\ntypedef pair<int,double> ID;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n;\nvector<ID> G[200];\ndouble d[200];\ndouble cost[200][200];\n\ndouble prime(){\n  double mincost[200];\n  bool used[200];\n  rep(i,200)\n    mincost[i] = INF,used[i] = false;\n  mincost[0] = 0;\n  double res = 0;\n\n  while(true){\n    int v = -1;\n    rep(u,n){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]))v = u;\n    }\n\n    if(v == -1)break;\n    used[v] = true;\n    res += mincost[v];\n\n    rep(u,n){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nbool judgement(D4 a, D4 b){\n  double len;\n  len = sqrt(pow(a.F.F - b.F.F,2)+pow(a.F.S - b.F.S,2)+pow(a.S.F - b.S.F,2));\n  if(len-(a.S.S+b.S.S) <= EPS)return false;\n  return true;\n}\n\n\nint main(){\n\n  while(true){\n    cin >> n;\n    if(n == 0)break;\n    rep(i,200)G[i].clear();\n    vector<D4> vec; \n    rep(i,n){\n      double x,y,z,r;\n      cin >> x >> y >> z >> r;\n      vec.pb(insert(x,y,z,r));\n    }\n\n   \n\n    /* --- 座標、コスト作成  --- */\n    rep(i,n){\n      rep(j,n){\n\tcost[i][j] = fabs(sqrt(pow(vec[i].F.F-vec[j].F.F,2)+pow(vec[i].F.S-vec[j].F.S,2)+pow(vec[i].S.F-vec[j].S.F,2)) - (vec[i].S.S + vec[j].S.S));\n\tif(!judgement(vec[i],vec[j])){\n\t  cost[i][j] = 0;\n\t}\n      }\n    }\n\n    cout << setiosflags(ios::fixed) << setprecision(3) << prime() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\nconst ll MOD = 10007;\n\ntemplate <typename T>\nstruct Prim {\n    typedef pair<T, int> P;\n\n    int n;\n    vll used;\n    vector<vector<P>> E; // cost, to\n\n    Prim(int n): n(n), used(n, false), E(n) {};\n\n    void add_edge(int s, int t, T w) {\n        // Undirected link\n        E[s].eb(w, t);\n        E[t].eb(w, s);\n    }\n\n    T operator()() {\n        used.assign(n, false);\n\n        // {cost, node}\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.emplace(T(0), 0); // cost, cur\n\n        T ret = T();\n        while(!q.empty()) {\n            auto p = q.top(); q.pop();\n            T cost = p.fi, cur = p.se;\n\n            if (used[cur]) continue;\n            used[cur] = true;\n            ret += cost;\n\n            for (auto e: E[p.se]) {\n                if(used[e.se]) continue;\n                q.emplace(e.fi, e.se);\n            }\n        }\n\n        return ret;\n    }\n};\n\nstruct station {\n    double x, y, z, r;\n    station(double x, double y, double z, double r) : x(x), y(y), z(z), r(r) {}\n};\n\ndouble p2(double x) {\n    return x * x;\n}\n\ndouble dist(station& s1, station& s2) {\n    double d = sqrt(p2(s1.x - s2.x) + p2(s1.y - s2.y) + p2(s1.z - s2.z));\n\n    if (d < s1.r + s2.r) return 0;\n    return d - s1.r - s2.r;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(3);\n\n    while(1) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vector<station> s;\n        REP(i, n) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            s.eb(x, y, z, r);\n        }\n\n        Prim<double> g(n);\n\n        REP(i, n) REP(j, n) {\n            double w = dist(s[i], s[j]);\n            g.add_edge(i, j, w);\n        }\n\n        print(g());\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nT kruskal(vector<edge<T>> &es, int V) {\n    UnionFind uf(V);\n    T ret = 0;\n    sort(es.begin(), es.end(), [](edge<T> &a,edge<T> &b){\n            return a.cost < b.cost;\n            });\n    for (auto &e : es) {\n        if (!uf.issame(e.src, e.to)) {\n            ret += e.cost;\n            uf.merge(e.src, e.to);\n        }\n    }\n    return ret;\n}\nstruct Cell {\n  double x, y, z, r;\n};\ndouble dist(Cell c1, Cell c2) {\n  return sqrt((c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y) + (c1.z - c2.z) * (c1.z - c2.z));\n}\nbool colide(Cell c1, Cell c2) {\n  return c1.r + c2.r + eps > dist(c1, c2);\n}\nvoid solve(int n) {\n  vector<Cell> v(n);\n  for(int i=0;i<n;++i) {\n    cin >> v[i].x >> v[i].y >> v[i].z >> v[i].r;\n  }\n  vector<edge<double>> edges;\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      if(colide(v[i], v[j])) {\n        edges.push_back({i, j, 0});\n        edges.push_back({j, i, 0});\n      } else {\n        edges.push_back({i, j, dist(v[i], v[j]) - v[i].r - v[j].r});\n        edges.push_back({j, i, dist(v[i], v[j]) - v[i].r - v[j].r});\n      }\n    }\n  }\n  printf(\"%.3f\\n\", round(kruskal(edges, n) * 1000) / 1000.0);\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-9\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n// start up //\nvoid solve();\nint main() { solve(); return 0; }\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x=0, double y=0, double z=0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x+_.x, y+_.y, z+_.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_,y*_,z*_); }\n\tP3 operator /(double _) const { return P3(x/_,y/_,z/_); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; }\n\tP3 cross(const P3 &_) const { return P3(y*_.z-z*_.y, z*_.x-x*_.z, x*_.y-y*_.x); }\n\tdouble sqlength() const { return x*x+y*y+z*z; }\n\tdouble length() const { return sqrt(sqlength()); }\n\tP3 direction() const { return *this / length(); }\n};\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x,y,z), r(r) { }\n};\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from, int to, double cost) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator > (const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\t\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.from;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j,N) if (parent[i] == -1) q.push(Path(i,j,costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i,n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i,n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i,n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss; \n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n/// template end ///\n\nvoid solve()\n{\n\tREP (testcase, INF)\n\t{\n\t\t// よみこみ\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tvector<Sphere> spheres;\n\t\tREP(i,N) { READ(double, x,y,z,r); spheres.push_back(Sphere(x,y,z,r)); }\n\n\t\t// cost[i][j] = 球i - 球j 間に廊下を作った時のコスト表\n\t\tvevector<double> costTable(N, N);\n\t\tREP(i,N) REP(j,N)\n\t\t{\n\t\t\tSphere &si = spheres[i], &sj = spheres[j];\n\t\t\tcostTable[i][j] = max((si.c - sj.c).length() - (si.r + sj.r), 0.0);\n\t\t}\n\n\t\t// 最少全域木\n\t\tdouble totalCost = prim(costTable).first;\n\n\t\twrite(totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <cstdio>\n#define INF 1<<27\n#define MAX_N 501\nusing namespace std;\nstruct edge{double x,y,z,r;};\nint V;\ndouble cost[MAX_N][MAX_N];\ndouble mincost[MAX_N];\nbool used[MAX_N];\n\ndouble centerdistance(edge&p,edge&q)\n{\n  return sqrt(pow(p.x - q.x,2) + pow(p.y - q.y,2) + pow(p.z - q.z,2));\n}\n\ndouble getcost(edge p[],int i,int j)\n{\n  if( centerdistance(p[i],p[j]) <= (p[i].r + p[j].r))return 0;\n  else return centerdistance(p[i],p[j]) - (p[i].r + p[j].r);  \n}\ndouble prim()\n{\n  mincost[0] = 0;\n  double res = 0;\n  while(true)\n    {\n      int v = -1;\n      for(int i = 0 ; i < V ; i++ )\n\t{\n\t  while(!used[i] && (v == -1 || mincost[i] < mincost[v]) )v = i;\n\t}\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v]; \n\n      for(int i = 0 ; i < V ; i++  )\n\t{\n\t  mincost[i] = min(mincost[i],cost[v][i]);\n\t}\n    }\n  return res;\n}\n\nint main()\n{\n\n  while(cin >> V,V)\n    {\n      fill(mincost,mincost + MAX_N,INF);\n      fill(cost[0],cost[MAX_N],INF);\n      fill(used,used+MAX_N,false);\n      edge p[V];\n      for(int i = 0 ; i < V ; i++ )\n\t{\n\t  cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n\t}\n      for(int i = 0 ; i < V-1 ; i++ ){\n\tfor(int j = i+1 ; j < V ; j++ ){\n\t  cost[j][i] = cost[i][j] = getcost(p,i,j);\n\t}\n      }\n\n      double res = prim();\n      printf(\"%.3f\\n\",res);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n\nusing namespace std;\n\ntypedef double elem;\n\nstruct node{\n  elem x,y,z,r;\n  vector<int> con;\n  vector<elem> cost;\n};\n\nstruct edge{\n  int src;\n  int dst;\n  elem cost;\n  edge(int s, int d, elem c):src(s),dst(d),cost(c){}\n  bool operator>(const edge &e)const{\n    return cost>e.cost;\n  }\n};\n\nelem dist(const node &a, const node &b){\n  double ret = sqrt(pow(a.x-b.x,2.0)+pow(a.y-b.y,2.0)+pow(a.z-b.z,2.0))-a.r-b.r;\n  if(ret<0)ret=0;\n  return ret;\n}\n\ntypedef vector<node> Graph;\n\nelem MST(Graph &G){\n  bool vis[G.size()];\n  elem ret=0;\n  for(int i = 0; i <(int)G.size(); ++i)vis[i]=false;\n  priority_queue<edge,vector<edge>,greater<edge> > Q;\n  Q.push( edge(-1,0,0) );\n  while(!Q.empty()){\n    edge e = Q.top(); Q.pop();\n    if( vis[e.dst] ) continue;\n    ret+=e.cost;\n    vis[e.dst]=true;\n    for(int i=0;i<(int)G[e.dst].con.size();++i){\n      if(!vis[G[e.dst].con[i]]){\n\tQ.push(edge(e.dst,G[e.dst].con[i],G[e.dst].cost[i]));\n      }\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    cin >> n;\n    if(n==0)break;\n    Graph G;\n    for(int i = 0; i < n; ++i){\n      node t;\n      cin >> t.x >> t.y >> t.z >> t.r;\n      G.push_back(t);\n    }\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n\telem d = dist(G[i],G[j]);\n\tG[i].con.push_back(j);\n\tG[j].con.push_back(i);\n\tG[i].cost.push_back(d);\n\tG[j].cost.push_back(d);\n      }\n    }\n\n    cout.precision(3);\n    cout << fixed << MST(G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nvector<vector<long double> > cost;\t// cost[u][v] ?????? e = (u, v) ????????????(?????¨???????????´?????? INF)\nvector<long double> mincost;\t\t// ?????? X ???????????????????°??????????\nvector<bool> used;\t\t\t// ?????? i ??? X ????????????????????????\nll V;\t\t\t\t\t\t// ????????°\nlong double prim() {\n\tREP(i, V) {\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tlong double res = 0;\n\twhile(true) {\n\t\tll v = -1;\n\t\tREP(u, V) {\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v =u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tREP(u, V) {\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>V;\n\t\tif(V == 0) break;\n\t\tlong double p[V][4];\n\t\tcost.resize(0);\n\t\tcost.resize(V);\n\t\tREP(i, V) cost[i].resize(V);\n\t\tmincost.resize(0);\n\t\tmincost.resize(V);\n\t\tused.resize(0);\n\t\tused.resize(V);\n\t\tREP(i, V) cin>>p[i][0]>>p[i][1]>>p[i][2]>>p[i][3];\n\t\tREP(i, V) {\n\t\t\tREP(j, V) {\n\t\t\t\tif(i == j) cost[i][j] = INF;\n\t\t\t\telse {\n\t\t\t\t\tlong double dist = sqrt( pow(p[i][0] - p[j][0], 2) + pow(p[i][1] - p[j][1], 2) +\n\t\t\t\t\t\t\t\t\t\t\tpow(p[i][2] - p[j][2], 2) );\n\t\t\t\t\tif(p[i][3] + p[j][3] - dist > EPS) cost[i][j] = 0;\n\t\t\t\t\telse cost[i][j] = dist - (p[i][3] + p[j][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<showpoint<<setprecision(39)<<prim()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\n#define N 100\n#define MAX (1<<21)\n\ntypedef pair<double,int> PI;\n#define MP make_pair\n\ndouble d[N];\ndouble cost[N][N];\nint hantei[N];\n\nvoid prim(int n){\n  priority_queue<PI,vector<PI>,greater<PI> > Q;\n  for(int i=0;i<n;i++){d[i] = MAX;hantei[i]=0;}\n  Q.push(MP(0,0) );\n  d[0]=0;\n  while(!Q.empty()){\n    int now = Q.top().second;\n    Q.pop();\n    hantei[now]=1;\n\n    for(int i=0;i<n;i++){\n      if (i == now || hantei[i]==1)continue;\n      if (cost[now][i] < d[i]){\n\t//cout << now<<\" to \" << i <<\" \"<<cost[now][i] << endl;\n\td[i]=cost[now][i];\n\tQ.push(make_pair(cost[now][i],i));\n      }\n    }  \n  }//while end\n  \n\n\n\n}\n\n\n\n\nint main(){\n  while(1){\n    int n;\n    double in[100][4];\n    cin >> n;\n    if (n ==0)break;\n    for(int i=0;i<n;i++)\n      cin >> in[i][0] >> in[i][1] >> in[i][2] >> in[i][3];\n    \n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif (i == j){cost[i][j]=MAX;continue;}\n\tdouble distance = sqrt( pow(in[i][0]-in[j][0],2)+pow(in[i][1]-in[j][1],2)+pow(in[i][2]-in[j][2],2));\n\t//cout << distance << endl;\n\tif ( distance > in[i][3]+in[j][3])cost[i][j] = distance - (in[i][3]+in[j][3]);\n\telse if (distance <= in[i][3]+in[j][3])cost[i][j] = 0;\n      }\n    }\n\n\n\n    \n    prim(n);\n    double total = 0;\n    for(int i=0;i<n;i++){total+= d[i];}\n    printf(\"%.3lf\\n\",total);\n\n\n  }\n  return 0;\n}\n\n\n\n\n\n/*\n\n0-1  0 \n0-3  69.255\n2-3  0\n4-3  4.579\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG(C) cerr << #C << \" = \" << C << endl\n\nusing namespace std;\n\nconst int MAX = 111;\ndouble x[MAX], y[MAX], z[MAX], r[MAX];\nbool vis[MAX];\n\ninline double dist(int p, int q) {\n  return max<double>(0.0, sqrt((x[p] - x[q]) * (x[p] - x[q]) + (y[p] - y[q]) * (y[p] - y[q]) + (z[p] - z[q]) * (z[p] - z[q])) - r[p] - r[q]);\n}\n\nvoid solve(int n) {\n  memset(vis, false, sizeof(vis));\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf%lf%lf%lf\", x + i, y + i, z + i, r + i);\n  }\n  priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n  pq.push(make_pair(0, 0));\n  double ans = 0;\n  while (!pq.empty()) {\n    auto e = pq.top();\n    pq.pop();\n    if (vis[e.second]) {\n      continue;\n    }\n    vis[e.second] = true;\n    ans += e.first;\n    for (int i = 0; i < n; i++) {\n      if (i != e.second && !vis[i]) {\n        pq.push(make_pair(dist(e.second, i), i));\n      }\n    }\n  }\n  printf(\"%.10lf\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    int n;\n    scanf(\"%d\", &n);\n    if (n == 0) {\n      break;\n    }\n    solve(n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 101;\nbool used[MAX];\n\nstruct data{double x,y,z,r;};\nstruct State{\n  data d;\n  double t;\n  int n;\n  State(){}\n  State(data d, double t, int n):d(d),t(t),n(n){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\n\nint N;\nvector<data> V;\n\nvoid init(){\n  V.clear();\n  V.resize(N);\n  fill(used,used+MAX,false);\n}\n\nvoid input(){\n  for(int i = 0; i < N; i++)\n    cin >> V[i].x >> V[i].y >> V[i].z >> V[i].r;\n}\n\n\ndouble getDis(data d1, data d2){\n  return sqrt(pow(d1.x-d2.x,2.0)+pow(d1.y-d2.y,2.0)+pow(d1.z-d2.z,2.0));\n}\nvoid solve(){\n  priority_queue<State> Q;\n  Q.push(State(V[0],0,0));\n  \n  double ans = 0;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    if(used[now.n]) continue;\n    used[now.n] = true;\n  \n    ans += now.t;\n    \n    for(int i = 0; i < N; i++){\n      double dis = max(getDis(now.d,V[i])-now.d.r-V[i].r,0.0);\n      if(!used[i]) Q.push(State(V[i],dis,i));\n    }\n  }\n  printf(\"%.3f\\n\",ans);\n}\n\nint main(){\n  while(cin >> N && N){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\n\nstruct sphere{\n  double x, y, z, r;\n  sphere(){}\n  sphere(double a, double b, double c, double d){\n    x = a; y = b; z = c; r = d;\n  }\n};\n\nstruct edge{\n  int from, to;\n  double cost;\n  edge(){}\n  edge(int a, int b, double c){\n    from = a; to = b; cost = c;\n  }\n};\n\nbool comp(edge p, edge q){\n  return p.cost < q.cost;\n}\n\nbool checker(sphere p, sphere q){\n  double dx = p.x - q.x;\n  double dy = p.y - q.y;\n  double dz = p.z - q.z;\n  \n  return dx*dx + dy*dy + dz*dz <= (p.r + q.r)*(p.r + q.r);\n}\n\ndouble kyori(sphere p, sphere q){\n  double dx = p.x - q.x;\n  double dy = p.y - q.y;\n  double dz = p.z - q.z;\n\n  return sqrt(dx*dx + dy*dy + dz*dz);\n  //return sqrt(pow(p.x - q.x, 2.0) + pow(p.y - q.y, 2.0) + pow(p.y - q.y, 2.0));\n}\n\nvector<int> par(110);\n\nvoid init(int n){\n  for(int i = 0; i < n; i++){\n   par.at(i) = i;\n  }\n}\n\nint root(int x){\n  if(par.at(x) == x) return x;\n  return par.at(x) = root(par.at(x));\n}\n\nvoid unite(int x, int y){\n  if(root(x) == root(y)) return;\n  par.at(root(x)) = root(y);\n}\n\nbool same(int x, int y){\n  return root(x) == root(y);\n}\n\nint main(){\nvector<double> result(0);\nwhile(true){\n  int n;\n  cin >> n;\n  if(n == 0) break;\n\n  init(n);\n\n  vector<sphere> cell(n);\n  for(int i = 0; i < n; i++){\n    double a, b, c, d;\n    cin >> a >> b >> c >> d;\n    cell.at(i) = sphere(a, b, c, d);\n  }\n\n  vector<edge> ed(0);\n  for(int i = 0; i < n; i++){\n    for(int j = i; j < n; j++){\n      if(checker(cell.at(i), cell.at(j))) unite(i, j);\n      else{\n        double c = kyori(cell.at(i), cell.at(j)) - cell.at(i).r - cell.at(j).r;\n        ed.push_back(edge(i, j, c));\n      }\n    }\n  }\n  sort(ALL(ed), comp);\n  double res = 0;\n  for(int i = 0; i < ed.size(); i++){\n    if(!same(ed.at(i).from, ed.at(i).to)){\n      unite(ed.at(i).from, ed.at(i).to);\n      res += ed.at(i).cost;\n    }\n  }\n  result.push_back(res);\n}\ncout << fixed << setprecision(3);\nfor(auto x: result) cout << x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing vpll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define debug(x) cerr << #x << \": \" << x << endl;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n// 最小全域木（kruskal）\ntemplate< typename T >\nstruct edge {\n  int from, to;\n  T cost;\n\n  edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n\n  edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\n\ntemplate< typename T >\nstruct MinimumSpanningTree {\n  T cost;\n  Edges< T > edges;\n};\n\ntemplate< typename T >\nMinimumSpanningTree< T > kruskal(Edges< T > &edges, int V) {\n  sort(begin(edges), end(edges), [](const edge< T > &a, const edge< T > &b) {\n    return a.cost < b.cost;\n  });\n  UnionFind tree(V);\n  T total = T();\n  Edges< T > es;\n  for(auto &e : edges) {\n    if(tree.unite(e.from, e.to)) {\n      es.emplace_back(e);\n      total += e.cost;\n    }\n  }\n  return {total, es};\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    ll n;\n    while(cin >> n) {\n        if(n == 0) return 0;\n\n        Edges<double> es;\n        vector<double> x(n), y(n), z(n), r(n);\n        rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        vector<vector<double>> dist(n, vector<double>(n));\n        rep(i, n) rep(j, n) {\n            if(i == j) dist[i][j] = 0.0;\n            double d = sqrt(pow(x[i]-x[j], 2) + pow(y[i]-y[j], 2) + pow(z[i]-z[j], 2));\n            dist[i][j] = max(0.0, d - r[i] - r[j]);\n            es.emplace_back(i, j, dist[i][j]);\n        }\n        double ans = kruskal(es, n).cost;\n        cout << fixed;\n        cout << setprecision(3) << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <typename T>\nclass Edge\n{\npublic:\n\n\tLL from,to;\n\tT cost;\n\t\n\tEdge(LL _from,LL _to,T _cost){\n\t\tfrom=_from;\n\t\tto=_to;\n\t\tcost=_cost;\n\t}\n\t\n\tbool operator<(const Edge& e) const {\n\t\treturn cost<e.cost;\n\t}\n};\n\ntemplate <typename T>\nclass UF{\npublic:\n\tvector<T> par,rank;\n\n\tUF(T n){\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor(T i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tT find(T x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(T x, T y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(T x, T y){\n\n\t\treturn find(x)==find(y);\n\t}\n};\n\ntemplate <typename T>\nclass Graph\n{\npublic:\n\tlong long n;\n\tvector<Edge<T> > ve;\n\tGraph(vector<Edge<T> > _ve,LL _n){\n\t\tve=_ve;\n\t\tn=_n;\n\n\t}\n\t\n\tvector<Edge<T> > kruskal(){\n\t\t\n\t\tvector<Edge<T> > res;\n\t\tsort(ve.begin(),ve.end());\n\t\t\n\t\tUF<LL> uf(n);\n\t\t\n\t\tfor(LL i=0;i<ve.size();i++){\n\t\t\tEdge<T> e=ve[i];\n\t\t\tif(!uf.same(e.from,e.to)){\n\t\t\t\tres.push_back(e);\n\t\t\t\tcout<<e.from<<\" \"<<e.to<<endl;\n\t\t\t\tuf.unite(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\t\n\t\tvector<Edge<double> > ve;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tdouble d=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\t\tve.push_back(Edge<double>(i,j,max(0.0,sqrt(d)-r[i]-r[j])));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ve.size()<<endl;\n\t\t\n\t\tGraph<double> G(ve,n);\n\n\t\tvector<Edge<double> > MST=G.kruskal();\n\t\t\n\t\tdouble res=0;\n\t\tfor(int i=0;i<MST.size();i++) res+=MST[i].cost;\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tq.push((Edge){i, j, 0.0});\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\tans += e.cost;\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n,0));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tbool flag = false;\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])continue;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(5)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint N;\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    Circle(D x, D y, D z, D r): x(x), y(y), z(z), r(r){};\n};\n\nclass Edge{\npublic:\n    int to;\n    double cost;\n    Edge(int to, double cost): to(to), cost(cost){};\n    \n    bool operator > (const Edge& right) const{\n        return cost > right.cost;\n    }\n};\n\nD prim(vector<vector<Edge>>& G, int root){\n    int V = G.size();\n    D res = 0;\n    vector<bool> visited(V, false);\n    priority_queue<Edge, vector<Edge>, greater<Edge>> queue;\n    queue.push(Edge(root, 0));\n    \n    while(!queue.empty()){\n        auto edge = queue.top(); queue.pop();\n        if(visited[edge.to])\n            continue;\n        res += edge.cost;\n        visited[edge.to] = true;\n        for(int i=0; i<G[edge.to].size(); i++){\n            if(!visited[G[edge.to][i].to])\n                queue.push(G[edge.to][i]);\n        }\n    }\n    return res;\n}\n\nD dist(Circle& c1, Circle& c2){\n    //???????????????????????????0?????????\n    D d1 = sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y) + (c1.z-c2.z)*(c1.z-c2.z));\n    D d2 = abs(c1.r-c2.r);\n    \n    return GE(d1, d2) ? max(d1-c1.r-c2.r, 0.0) : 0;\n}\n\nvoid solve(){\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r; cin >> x >> y >> z >> r;\n        circles.push_back(Circle(x, y, z, r));\n    }\n    vector<vector<Edge>> G(N);\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++){\n            double d = dist(circles[i], circles[j]);\n            G[i].push_back(Edge(j, d));\n        }\n    }\n    printf(\"%.3lf\\n\", prim(G, 0));\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    cout.precision(16);\n    \n    while(cin>>N, N)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct P {\n    int src;\n    int dst;\n    double cost;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vd x(n), y(n), z(n), r(n);\n        REP(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n        vvd E(n, vd(n));\n        REP(i, n) FOR(j, i+1, n) {\n            double xx = (x[i] - x[j]);\n            double yy = (y[i] - y[j]);\n            double zz = (z[i] - z[j]);\n            double v = sqrt(xx*xx + yy*yy + zz*zz) - r[i] - r[j];\n            E[i][j] = E[j][i] = v > 0 ? v : 0;\n        }\n\n        double ans = 0;\n        vb visited(n);\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({0, 0, E[0][0]});\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (visited[p.dst]) continue;\n            ans += E[p.src][p.dst];\n            visited[p.dst] = true;\n            REP(i, n) {\n                if (visited[p.dst]) {\n                    que.push({p.dst, i, E[p.dst][i]});\n                }\n            }\n        }\n        printf(\"%.03f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n\n  UnionFind(int n) : par(n), rank(n, 1) {\n    for(int i=0; i<n; ++i) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) swap(x, y);\n    par[y] = x;\n    rank[x] += rank[y];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n};\n\ntypedef double Cost;\n\nstruct edge{\n    int src, dst; Cost cost;\n    edge(int s, int t, Cost c) : src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost < rhs.cost;}\n};\n\nCost kruskal(int V, vector<edge> &edges) {\n    UnionFind uf(V);\n    sort(edges.begin(), edges.end());\n    Cost ans = 0;\n    for(auto e : edges) {\n        if(!uf.same(e.src, e.dst)) {\n            uf.unite(e.src, e.dst);\n            ans += e.cost;\n        }\n    }\n    return ans;\n}\n\nint main(void) {\n    int n;\n    while(cin >> n && n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        vector<edge> edges;\n        REP(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(i, n)  {\n            REP(j, n) {\n                if(i == j) continue;\n                double c = sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j];\n                edges.push_back(edge(i, j, max(0.0, c)));\n            }\n        }\n        printf(\"%.3f\\n\", kruskal(n, edges));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst double INF = 1e10;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<double> x(n),y(n),z(n),r(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tdouble edge[100][100];\n\t\tfor(int i=0;i<n-1;++i){\n\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\tdouble distance = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\tdouble cost = max(distance - r[i] - r[j] , 0.0);\n\t\t\t\tedge[i][j] = cost;\n\t\t\t}\n\t\t}\n\t\tdouble mincost[100];\n\t\tbool used[100];\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0.0; double ans=0;\n\t\twhile(1){\n\t\t\tint v = -1;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v])) v=i;\n\t\t\t}\n\t\t\tif(v == -1) break;\n\t\t\tused[v] = true;\n\t\t\tans += mincost[v];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tmincost[i] = min(mincost[i], edge[v][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.03f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble x[111], y[111], z[111], r[111];\ndouble d[111][111];\nint visit[111];\n\nint main(){\n\tint n;\n\twhile(cin>>n, n){\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tREP(i,n)FOR(j,i+1,n)d[i][j] = d[j][i] = max(sqrt(pow(x[i]-x[j], 2.0)+pow(y[i]-y[j], 2.0)+pow(z[i]-z[j], 2.0))-r[i]-r[j], 0.0);\n\t\tpriority_queue<pair<double, PII>, vector<pair<double,PII> >, greater<pair<double,PII> > > q;\n\t\tvisit[0]=1;\n\t\tFOR(i,1,n)q.push(MP(d[0][i], MP(0, i)));\n\t\tdouble ret = 0.0;\n\t\tint cnt = n-1;\n\t\twhile(!q.empty()){\n\t\t\tpair<double, PII> tmp;\n\t\t\ttmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(visit[tmp.second.second])continue;\n\t\t\tret += tmp.first;\n\t\t\tif(--cnt==0)break;\n\t\t\tvisit[tmp.second.second] = 1;\n\t\t\tREP(i,n)if(i!=tmp.second.second && (!visit[i]))q.push(MP(d[tmp.second.second][i], MP(tmp.second.second, i)));\n\t\t}\n\t\tprintf(\"%.3f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<regex>\n#include<cctype>\nusing namespace std;\n#define INFS (1LL<<28)\n#define INF (1LL<<60)\n#define DEKAI 1000000007\n#define MOD 998244353\n#define lp(i,n) for(int i=0;i<n;i++)\n#define double long double\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n#define __DECLARE__(C)    \\\n    template <typename T> \\\n    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n#define __DECLAREM__(C)               \\\n    template <typename T, typename U> \\\n    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n__DECLARE__(std::vector)\n__DECLARE__(std::deque)\n__DECLARE__(std::set)\n__DECLARE__(std::stack)\n__DECLARE__(std::queue)\n__DECLARE__(std::priority_queue)\n__DECLARE__(std::unordered_set)\n__DECLAREM__(std::map)\n__DECLAREM__(std::unordered_map)\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\ntemplate <typename... T>\nstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\ntemplate <typename T, std::size_t N>\nstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\ntemplate <typename Tuple, std::size_t N>\nstruct __TuplePrinter__ {\n    static void print(std::ostream &os, const Tuple &t) {\n        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n        os << \", \" << std::get<N - 1>(t);\n    }\n};\n\ntemplate <typename Tuple>\nstruct __TuplePrinter__<Tuple, 1> {\n    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n};\n\ntemplate <typename... T>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n    os << '(';\n    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n    os << ')';\n    return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n    return os << '(' << v.first << \", \" << v.second << ')';\n}\n\n#define __INNER__                             \\\n    os << '[';                                \\\n    for (auto it = begin(c); it != end(c);) { \\\n        os << *it;                            \\\n        os << (++it != end(c) ? \", \" : \"\");   \\\n    }                                         \\\n    return os << ']';\n\ntemplate <typename T, std::size_t N>\nstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n    __INNER__\n}\n\n#define __DEFINE__(C)                                           \\\n    template <typename T>                                       \\\n    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n        __INNER__                                               \\\n    }\n\n#define __DEFINEM__(C)                                             \\\n    template <typename T, typename U>                              \\\n    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n        __INNER__                                                  \\\n    }\n\n#define __DEFINEW__(C, M1, M2)                                  \\\n    template <typename T>                                       \\\n    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n        std::deque<T> v;                                        \\\n        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n        return os << v;                                         \\\n    }\n\n__DEFINE__(std::vector)\n__DEFINE__(std::deque)\n__DEFINE__(std::set)\n__DEFINEW__(std::stack, push_front, top)\n__DEFINEW__(std::queue, push_back, front)\n__DEFINEW__(std::priority_queue, push_front, top)\n__DEFINE__(std::unordered_set)\n__DEFINEM__(std::map)\n__DEFINEM__(std::unordered_map)\n}\n\n\n#define rep(i,n) lp(i,n)\nusing Weight = double;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nbool operator<(const Edge &e, const Edge &f) { return e.weight > f.weight; }\nstd::pair<Weight, Edges> prim(const Graph &g, int r = 0) {\n    Edges T;\n    Weight total = 0;\n    std::vector<int> vis(g.size());\n    std::priority_queue<Edge> q;\n    q.emplace(-1, r, 0);\n    while (q.size()) {\n        Edge e = q.top();\n        q.pop();\n        if (vis[e.dst]) continue;\n        vis[e.dst] = true;\n        total += e.weight;\n        if (e.src != -1) T.emplace_back(e);\n        for (auto &f : g[e.dst])\n            if (!vis[f.dst]) q.emplace(f);\n    }\n    return std::make_pair(total, T);\n}\n\nsigned main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tdouble x[100],y[100],z[100],r[100];\n\t\tlp(i,n){\n\t\t\tcin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\t}\n\t\tGraph g(n);\n\t\tlp(i,n){\n\t\t\tlp(j,n){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tdouble dx,dy,dz;\n\t\t\t\tdx=abs(x[i]-x[j]);\n\t\t\t\tdy=abs(y[i]-y[j]);\n\t\t\t\tdz=abs(z[i]-z[j]);\n\t\t\t\tdouble dist=sqrt(dx*dx+dy*dy+dz*dz)-r[i]-r[j];\n\t\t\t\tif(dist<0)dist=0;\n\t\t\t\tadd_edge(g,i,j,dist);\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(3)<<prim(g).first<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOTCONNECTED 0 // WHITE\n#define CANDIDATE 1 // GRAY\n#define CONNECTED 2 // BLACK\nusing namespace std;\ndouble getDistance(vector<double>, vector<double>);\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<vector<double> > cells;\n    for(int i = 0; i < n; ++i) {\n      double y, x, z, r;\n      cin >> x >> y >> z >> r;\n      cells.push_back(vector<double>({x, y, z, r}));\n    }\n    vector<int> minWeights(n, INT_MAX); // d\n    minWeights[0] = 0;\n    vector<int> states(n, NOTCONNECTED); // color\n    vector<int> parents(n, -1); // p\n    while(true) {\n      int minv = INT_MAX;\n      int u = -1;\n      for(int i = 0; i < n; ++i) {\n        if(minv > minWeights[i] && states[i] != CONNECTED) {\n          u = i;\n          minv = minWeights[i];\n        }\n      }\n      if(u == -1) break;\n      states[u] = CONNECTED;\n      for(int v = 0; v < n; ++v) {\n        if(states[v] != CONNECTED && minWeights[v] > getDistance(cells[u], cells[v])) {\n          minWeights[v] = getDistance(cells[u], cells[v]);\n          parents[v] = u;\n          states[v] = CANDIDATE;\n        }\n      }\n    }\n    double ans = 0;\n    for(int i = 0; i < n; ++i) {\n      if(parents[i] != -1) ans += getDistance(cells[i], cells[parents[i]]);\n    }\n    printf(\"%.3lf\", ans);\n    cout << endl;\n  }\n  return 0;\n}\n\ndouble getDistance(vector<double> a, vector<double> b) {\n  double dx = abs(a[0] - b[0]);\n  double dy = abs(a[1] - b[1]);\n  double dz = abs(a[2] - b[2]);\n  double ans = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - a[3] - b[3];\n  return ans < 0 ? 0 : ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<double, int> P;\nconst int INF = numeric_limits<int>::max() / 2;\n\nstruct cell {\n\tdouble x, y, z, r;\n};\n\ndouble calc(cell p, cell q) {\n\tdouble tmp = sqrt((p.x - q.x)*(p.x - q.x) + (p.y - q.y)* (p.y - q.y) + (p.z - q.z)*(p.z - q.z));\n\tif (tmp <= p.r + q.r) return 0;\n\telse return (-p.r - q.r + tmp);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<cell> cells;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcell c;\n\t\t\tcin >> c.x >> c.y >> c.z >> c.r;\n\t\t\tcells.push_back(c);\n\t\t}\n\t\tvector<vector<double>> dis(n, vector<double>(n, INF));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) dis[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tdis[i][j] = calc(cells[i], cells[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> used(n, false);\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\tdouble res = 0;\n\t\tque.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (used[p.second]) continue;\n\t\t\tused[p.second] = true;\n\t\t\tres += p.first;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!used[i]) {\n\t\t\t\t\tque.push(P(dis[p.second][i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed<<setprecision(10)<<res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\n#define uni(x) x.erase(unique(all(x)),x.end())\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<double, P> edge;\n#define INF INT_MAX/3\n#define MAX_N 1000\n#define M_INF 1000000000\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n;\ndouble x[111],y[111],z[111],r[111];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0) break;\n    rep(i,n) cin>>x[i]>>y[i]>>z[i]>>r[i];\n    UnionFind uf(n);\n    std::vector<edge> es;\n    rep(i,n) rep(j,i){\n      double dist=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)+pow(z[i]-z[j],2));\n      if(dist<=r[i]+r[j]){\n        uf.unite(i,j);\n      }else{\n        es.push_back(edge(dist-r[i]-r[j],P(i,j)));\n      }\n    }\n    double res= 0;\n    sort(all(es));\n    rep(i,es.size()){\n      if(uf.same(es[i].se.fi,es[i].se.se)) continue;\n      else {\n        uf.unite(es[i].se.fi,es[i].se.se);\n        res += es[i].fi;\n      }\n    }\n     printf(\"%.3f\\n\", res);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100],sum,mn,maxd=99999999.9;\nint n,m,mx=(1<<20),a,b,c,t,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt((x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) + (z[i]-z[j]) * (z[i]-z[j]));\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    for(int i=0;i<n;i++) {\n      cin>>x[i]; cin>>y[i]; cin>>z[i]; cin>>r[i];\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tmap[i][j]=maxd;\n      }\n      p[i]=0;\n      d[i]=maxd;\n      visited[i]=0;\n    }\n    \n    for(int i=0; i<n; i++) {\n      for(int j=0; j<n; j++) {\n\tif(i==j) continue;\n\tmap[i][j] = compute(i, j);\n\tmap[i][j]-=(r[i]+r[j]);\n\tif(map[i][j]<0)map[i][j]=0;\n      }\n    }\n\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\t//\tcout<<map[i][j]<<endl;\n      }\n    }\n    \n    sumcor=0.0;\n    d[0]=0.0;\n    while(1){\n      mn=maxd;\n      for(int i=0;i<n;i++){\n\tif(d[i]<mn&&visited[i]==0){\n\t  mn=d[i];\n\t  t=i;\n\t}\n      }\n      if(mn==maxd)break;\n      visited[t]=1;\n      for(int v=0;v<n;v++){\n\tif(map[t][v]<d[v]&&visited[v]==0){\n\t  d[v]=map[t][v];\n\t  p[v]=t;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)if(map[i][p[i]]!=maxd)sumcor+=map[i][p[i]];\n    printf(\"%4.3f\\n\",sumcor);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n \n#define pow2(x) ((x)*(x))\n#define N 100\n \nclass UnionFind {\n    int parent[N];\npublic:\n    void init(int n) {\n        for(int i=0; i<n; ++i) parent[i] = i;\n    }\n    int root(int x) {\n        if(x==parent[x]) return x;\n        return parent[x] = root(parent[x]);\n    }\n    bool issame(int x, int y) {\n        return root(x)==root(y);\n    }\n    int unite(int x, int y) {\n        if(root(x)==root(y)) return root(x);\n        if(root(x)<root(y)) {\n            parent[root(x)] = parent[root(y)];\n        }else {\n            parent[root(y)] = parent[root(x)];\n        }\n        return root(y);\n    }\n};\n \nstruct Edge {\n    int from, to;\n    double cost;\n    bool operator<(const Edge& e) const {\n        return cost < e.cost;\n    }\n        bool operator>(const Edge& e) const {\n        return cost > e.cost;\n    }\n};\n \nint main() {\n    int n, c;\n    UnionFind uf;\n    double x[N], y[N], z[N], r[N], ans;\n    priority_queue<Edge, vector<Edge>, greater<Edge> > q;\n    while(cin >> n && n) {\n        while(!q.empty()) q.pop();\n        uf.init(n); ans = 0.0; c = 0;\n        for(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        for(int i=0; i<n; ++i) {\n            for(int j=i+1; j<n; ++j) {\n                double rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n                if(rr <= pow2(r[j]+r[i])) {\n                    q.push((Edge){i, j, 0.0});\n                }else {\n                    q.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n                }\n            }\n        }\n        while(!q.empty() && c<n-1) {\n            Edge e = q.top(); q.pop();\n            if(!uf.issame(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                ans += e.cost;\n                ++c;\n            }\n        }\n        //cout << ans << endl;\n        printf(\"%.3f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nusing namespace std;\n\nstatic const ll INF = 1e15;\n\ntemplate<typename T>\nstatic inline void chmin(T & ref, const T  value) {\n    if (ref > value) ref = value;\n}\n\ntemplate<typename T>\nstatic inline void chmax(T & ref, const T value) {\n    if (ref < value) ref = value;\n}\n\nstruct warshall_floyd {\n    static void solve(vector<vector<ll>>& d) {\n        int n = d.size();\n        rep(k, n) {\n            rep(i, n) {\n                rep(j, n) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n    }\n};\n\n\nstruct edge {\n    int from;\n    int to;\n    double cost;\n    edge(){}\n    edge(int a, int b, double c) : from(a), to(b), cost(c){}\n};\n\nstruct UnionFind {\npublic:\n    vector <ll> par; // \n    vector <ll> siz; // \n\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nstruct KruskalRunner {\n    static bool orderByCost(const edge& e1, const edge& e2) {\n        return e1.cost < e2.cost;\n    }\n\n    double solve(int vCount, vector<edge>& edges) {\n        sort(edges.begin(), edges.end(), orderByCost);\n        UnionFind uf = UnionFind(vCount);\n        double sum = 0;\n        for (int i = 0; i < edges.size(); ++i) {\n            edge e = edges[i];\n            if (!uf.issame(e.from, e.to)) {\n                uf.merge(e.from, e.to);\n                sum += e.cost;\n            }\n        }\n        return sum;\n    }\n};\n\nstruct vector4 {\n    double x, y, z, r;\n\n    vector4 sub(vector4 o) {\n        vector4 diff;\n        diff.x = x - o.x;\n        diff.y = y - o.y;\n        diff.z = z - o.z;\n        diff.r = r - o.r;\n        return diff;\n    }\n};\n\nint main() {\n    vector<double> as;\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            cout << fixed << setprecision(3);\n            for (auto p : as) {\n                cout << p << endl;\n            }\n            return 0;\n        }\n        vector<vector4> cs(n);\n        rep(i, n) {\n            cin >> cs[i].x;\n            cin >> cs[i].y;\n            cin >> cs[i].z;\n            cin >> cs[i].r;\n        }\n        vector<vector<double>> dist(n, vector<double>(n, 0));\n        rep(i, n) {\n            rep(j, n) {\n                if (i == j) continue;\n                vector4 diff = cs[i].sub(cs[j]);\n                double dr2 = diff.x * diff.x + diff.y * diff.y+ diff.z * diff.z;\n                double d = sqrt(dr2);\n                double rsum = cs[i].r + cs[j].r;\n                dist[i][j] = max(0., d - rsum);\n            }\n        }\n        vector<edge> edges;\n        rep(i, n) {\n            rep(j, i) {\n                edges.emplace_back(i, j, dist[i][j]);\n            }\n        }\n        KruskalRunner r;\n        auto ans = r.solve(n, edges);\n        as.push_back(ans);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass uf{\n  int n;\n  vector<int> rank, parent;\npublic:\n  uf();\n  uf(int _n){\n    init(_n);\n  }\n  void init(int _n){\n    n = _n;\n    rank.resize(n);\n    parent.resize(n);\n    for (int i = 0; i < n; i++) {\n      rank[i] = 0;\n      parent[i] = i;\n    }\n  }\n  int find(int x){\n    if(x == parent[x])return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      parent[x] = y;\n    }else{\n      parent[y] = x;\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\n\nstruct sphere{\n  double x, y, z, r;\n};\n\nstruct edge{\n  int from, to;\n  double cost;\n  bool operator<(const edge &a)const{\n    return cost < a.cost;\n  }\n  bool operator>(const edge &a)const{\n    return cost > a.cost;\n  }\n};\ndouble dist(sphere a, sphere b){\n  double res = sqrt( (a.x - b.x)*(a.x - b.x) +\n                     (a.y - b.y)*(a.y - b.y) +\n                     (a.z - b.z)*(a.z - b.z) ) - (a.r + b.r);\n  if(res < 0)return 0;\n  else return res;\n}\n\nvector<vector<edge> > makeG(vector<sphere> s){\n  vector<vector<edge> > res(s.size());\n  for (int i = 0; i < s.size(); i++) {\n    for (int j = i + 1; j < s.size(); j++) {\n      res[i].push_back((edge){i, j, dist(s[i], s[j])});\n      res[j].push_back((edge){j, i, dist(s[i], s[j])});\n    }\n  }\n  return res;\n}\n\ndouble kruscal(vector<vector<edge> > g){\n  priority_queue<edge, vector<edge>, greater<edge> > que;\n  uf utree(g.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      que.push(g[i][j]);\n    }\n  }\n  double res = 0;\n  while(!que.empty()){\n    edge e = que.top();que.pop();\n    if(!utree.same(e.to, e.from)){\n      utree.unite(e.to, e.from);\n      res += e.cost;\n    }\n  }\n  return res;\n}\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    vector<sphere> s(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i].x >> s[i].y >> s[i].z >> s[i].r;\n    }\n    vector<vector<edge> >g = makeG(s);\n    // for (int i = 0; i < g.size(); i++) {\n    //   for (int j = 0; j < g[i].size(); j++) {\n    //     std::cout << g[i][j].to << \" \" << g[i][j].cost << std::endl;\n    //   }\n    // }\n    printf(\"%.3lf\\n\", kruscal(g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\nstruct Sphere {\n    double x;\n    double y;\n    double z;\n    double r;\n};\n\nstruct edge {\n    int from;\n    int to;\n    double cost;\n};\n\ndouble distance_center(Sphere s1, Sphere s2) {\n    double dx = abs(s1.x - s2.x);\n    double dy = abs(s1.y - s2.y);\n    double dz = abs(s1.z - s2.z);\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\ndouble distance_edge(Sphere s1, Sphere s2) {\n    double distance = distance_center(s1, s2);\n    distance -= (s1.r + s2.r);\n    return distance;\n}\n\nstruct UnionFind {\n\n    vector<int> par;\n    vector<int> sizes;\n\n    UnionFind(int N) :\n            par(N),\n            sizes(N, 1) {\n        for (int i = 0; i < N; i++)par[i] = i;\n    }\n\n    int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (sizes[x] < sizes[y]) swap(x, y);\n        par[y] = x;\n        sizes[x] += sizes[y];\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int getSize(int x) {\n        return sizes[find(x)];\n    }\n\n};\n\nbool comp(const edge &e1, const edge &e2) {\n    return e1.cost < e2.cost;\n}\n\nint main() {\n\n    while (true) {\n\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<Sphere> spheres(N);\n\n        for (int i = 0; i < N; i++) {\n            double x, y, z, r;\n            cin >> x >> y >> z >> r;\n            spheres[i] = (Sphere) {x, y, z, r};\n        }\n\n        vector<edge> edges;\n        UnionFind UF(N);\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                if (i == j) continue;\n                double distance = distance_edge(spheres[i], spheres[j]);\n                if (distance > 0.001) {\n                    edges.push_back((edge) {i, j, distance});\n                } else {\n                    UF.unite(i, j);\n                }\n            }\n        }\n\n        sort(edges.begin(), edges.end(), comp);\n\n        double ans = 0;\n        for (int i = 0; i < edges.size(); i++) {\n            edge e = edges[i];\n            if (!UF.same(e.from, e.to)) {\n                UF.unite(e.from, e.to);\n                ans += e.cost;\n            }\n        }\n\n        ans = round_n(ans, 3);\n        cout << fixed << setprecision(3) << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    vector<int> ss;//xの属する集合のサイズ:option\n    int size;//集合の個数:option\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);\n        ss=vector<int>(n,1);\n        size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y]){\n            par[x] = y;\n            ss[y]+=ss[x];\n        }else{\n            par[y] = x;\n            ss[x]+=ss[y];\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n};\n\nnamespace SpanningTree{\n\ttypedef double Cost;\n\tstruct Edge{\n\t\tint from,to;Cost cost;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost) {};\n\n\t\tbool operator<(Edge r) const{return cost<r.cost;}\n\t\tbool operator>(Edge r) const{return cost>r.cost;}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n\n\t//O(E*log(V))\n\t// verified by ACAC002 B\n\t// http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899132&cid=ACAC002\n\tCost kruskal(Graph g){\n\t\tconst int V=g.size();\n\t\tUnionFind uf=UnionFind(V);\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> que;\n\t\tREP(u,V)for(Edge e:g[u])\n\t\t\tque.push(e);\n\t\tCost res=0;\n\t\twhile(!que.empty()){\n\t\t\tEdge e=que.top();que.pop();\n\t\t\tif(!uf.same(e.from,e.to)){\n\t\t\t\tuf.unite(e.from,e.to);\n\t\t\t\tres+=e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nusing namespace SpanningTree;\n\n\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N;nextInt(N);\n\t\t\tif(N==0)return;\n\t\t\tGraph g(N);\n\t\t\tvector<double> xs(N),ys(N),zs(N),rs(N);\n\t\t\tREP(i,N){\n\t\t\t\tnextDouble(xs[i]);nextDouble(ys[i]);nextDouble(zs[i]);nextDouble(rs[i]);\n\t\t\t}\n\t\t\tREP(i,N)REP(j,N){\n\t\t\t\tdouble d=max(sqrt(pow(xs[i]-xs[j],2)+pow(ys[i]-ys[j],2)+pow(zs[i]-zs[j],2))-rs[i]-rs[j],0.0);\n\t\t\t\tg[i].push_back(Edge(i,j,d));\n\t\t\t}\n\n\t\t\tcout <<SpanningTree::kruskal(g)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\nint n;//細胞の数\n\ndouble cost[100][100];\ndouble mincost[100];//集合Xからの辺の最小コスト\nbool used[100];\ndouble X[100],Y[100],Z[100],R[100];\n#define INF 10000000\ndouble prime(){\n  for(int i = 0;i <n;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  double res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0;u <n;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v]))\n\tv = u;\n    }\n    if(v==-1)\n      break;\n    used[v] = true;\n    res +=mincost[v];\n    for(int u =0;u <n;u++){\n      mincost[u] =min(mincost[u],min(cost[v][u],cost[u][v]));\n    }\n  }\n  return res;\n}\n\n\n\nint main()\n{\n  while(cin>>n,n){\n    \n    for(int i = 0;i < n;i++){\n      cin>>X[i]>>Y[i]>>Z[i]>>R[i];\n    }\n    for(int i = 0;i < n-1;i++){\n      for(int j = i+1;j < n;j++){\n\tdouble du =(X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j])+(Z[i]-Z[j])*(Z[i]-Z[j]);\n\tdouble d =sqrt(du)-(R[i]+R[j]);\n\tif(d <=0){\n\t  cost[i][j] = 0;\n\t  cost[j][i] = 0;\n\t}else{\n\t  cost[i][j] = d;\n\t  cost[j][i] = d;\n\t}\n      }\n    }\n    printf(\"%.3lf\\n\",prime());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n/*Function Template*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define Rep(i, n) for(ll i = 1; i < (n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll m=0,s=0,a=n;\n  while(a!=0) s++, a/=10;\n  for(ll i=s-1;i>=0;i--) m+=n/((ll)pow(10,i))-(n/((ll)pow(10,i+1)))*10;\n  return m;\n}\n\n\nll Svec(vector<ll> v){\n  ll n=0;\n  for(ll i=0;i<v.size();i++) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  for(ll i=0;i<s.size()-1;i++){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\nstruct edge{double u,v,cost;};\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\nbool cmp(edge e1,edge e2){\n  return e1.cost<e2.cost;\n}\n/* Union-Find木 */\nstruct UnionFind {\n    vector<ll> par;\n    \n    UnionFind(ll n) : par(n, -1) { }\n    void init(ll n) { par.assign(n, -1); }\n    \n    ll root(ll x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n   \n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(ll x, ll y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    ll size(ll x) {\n        return -par[root(x)];\n    }\n};\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nint main() {\n  IOS;\n  while(1){\n    ll n;cin>>n;\n    if(n==0) return 0;\n    vector<double> x(n),y(n),z(n),r(n);\n    rep(i,n) cin>>x[i]>>y[i]>>z[i]>>r[i];\n    vector<edge> v;\n    rep(i,n) for(ll j=i+1;j<n;j++){\n      double tmp=max((double)0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j]);\n      v.push_back(edge{(double)i,(double)j,tmp});\n    }\n    UnionFind uf(n);\n    double ans=0;\n    sort(ALL(v),cmp);\n    rep(i,v.size()){\n      if(uf.issame(v[i].u,v[i].v)) continue;\n      ans+=v[i].cost;\n      uf.merge(v[i].u,v[i].v);\n    }\n    cout<<fixed<<setprecision(3)<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SQ(a) ((a)*(a))\ntypedef tuple<double, int, int> Tp;\n#define at(t, i) get<i>(t)\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nstruct Point {\n\tdouble x, y, z;\n\tPoint(){}\n\tPoint(double x, double y, double z): x(x), y(y), z(z){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(){}\n\tCircle(double x, double y, double z, double r): p(x, y, z), r(r){}\n};\n\ninline double dist(Point &a, Point &b)\n{\n\treturn sqrt(SQ(a.x - b.x) + SQ(a.y - b.y) + SQ(a.z - b.z));\n}\n\ninline double dist(Circle &a, Circle &b)\n{\n\treturn max(0.0, dist(a.p, b.p) - a.r - b.r);\n}\n\nint n;\nCircle cs[100];\n\nint main()\n{\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdouble x, y, z, r;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &z, &r);\n\t\t\tcs[i] = Circle(x, y, z, r);\n\t\t}\n\t\t\n\t\tvector<Tp> es;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i == j) continue;\n\t\t\t\tes.push_back(Tp(dist(cs[i], cs[j]), i, j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(es.begin(), es.end());\n\t\t\n\t\tdouble res = 0.0;\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < es.size(); i++){\n\t\t\tdouble cost = at(es[i], 0);\n\t\t\tint a = at(es[i], 1), b = at(es[i], 2);\n\t\t\tif (uf.unite(a, b)) res += cost;\n\t\t}\n\t\t\n\t\tprintf(\"%f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nstruct edge {\n\tint from, to;\n\tld cost;\n\tedge() {}\n\tedge(int from, int to, ld cost) : from(from), to(to), cost(cost) {}\n};\n\nbool operator<(const edge& l, const edge& r){\n\treturn l.cost < r.cost;\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tvector<int> rank;\n\tint root(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = root(data[a]);\n\t}\npublic:\n\tUnionFind(int n) : data(n, -1), rank(n, 1) {}\n\tbool Find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tvoid Union(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] < rank[b]) {\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t}\n\t\telse {\n\t\t\tdata[b] += data[a];\n\t\t\tdata[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint Size(int a) {\n\t\treturn -data[root(a)];\n\t}\n\tint Rank(int a) {\n\t\treturn rank[root(a)];\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(3);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<ld> x(n), y(n), z(n), r(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tld dx = x[j] - x[i], dy = y[j] - y[i], dz = z[j] - z[i];\n\t\t\t\tes.emplace_back(i, j, max((ld)0, sqrtl(dx * dx + dy * dy + dz * dz) - r[i] - r[j]));\n\t\t\t}\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tld res = 0;\n\t\tUnionFind uf(n);\n\t\tfor (auto e : es) {\n\t\t\tif (uf.Find(e.from, e.to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += e.cost;\n\t\t\tuf.Union(e.from, e.to);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<stdio.h>\nusing namespace std;\n#define inf 1<<21\nstruct cell{\n  double x,y,z,r;\n};\ndouble dis(cell a,cell b){\n  double o=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z))-(a.r+b.r);\n  if(o<=0) return 0;\n  return o;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int i,j,k;\n    vector<cell> cells;\n    cell c;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.z >> c.r;\n      cells.push_back(c);\n    }\n    \n    double cost[100][100]={{}};\n    for(i=0;i<n;i++){\n      for(j=i;j<n;j++){\n\tif(i==j) cost[i][j]=inf;\n\telse{\n\t  cost[i][j]=dis(cells[i],cells[j]);\n\t  cost[j][i]=cost[i][j];\n\t}\n      }\n    }\n    \n    int color[100]={},p[100]={};\n    double d[100]={};\n    for(i=0;i<n;i++){\n      color[i]=0;\n      d[i]=inf;\n      p[i]=-1;\n    }\n    double sum=0,minv;\n    int u;\n    d[0]=0;\n    while(1){\n      minv=inf;\n      u=-1;\n      for(i=0;i<n;i++){\n\tif(minv>d[i]&&color[i]!=2){\n\t  u=i;\n\t  minv=d[i];\n\t}\n      }\n      if(u==-1) break;\n      color[u]=2;\n      for(i=0;i<n;i++){\n\tif(color[i]!=2&&u!=i){\n\t  if(d[i]>cost[u][i]){\n\t    d[i]=cost[u][i];\n\t    p[i]=u;\n\t    color[i]=1;\n\t  }\n\t}\n      }\n      \n    }\n    for(i=0;i<n;i++){\n      if(p[i]!=-1) sum+=cost[i][p[i]];\n    }\n    \n    printf(\"%.3f\\n\",sum);\n    \n    cin >> n;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"/mnt/c/Users/leafc/dev/compro/lib/union_find.hpp\"\n#include <iostream>\n#include <vector>\n#ifndef UNION_FIND\n#define UNION_FIND\nclass UnionFind {\nprivate:\n  std::vector<int> parent;\n  std::vector<int> _size;\n\n  int root(int x) {\n    if (parent[x] == -1)\n      return x;\n    return parent[x] = root(parent[x]);\n  }\n\npublic:\n  UnionFind(const int s) {\n    parent = std::vector<int>(s, -1);\n    _size = std::vector<int>(s, 1);\n  }\n\n  void merge(int x, int y) {\n    int rx = root(x), ry = root(y);\n    if (rx == ry)\n      return;\n    if (_size[rx] < _size[ry])\n      std::swap(rx, ry);\n    parent[ry] = rx;\n    _size[rx] += _size[ry];\n    _size[ry] = _size[rx];\n  }\n\n  int size(int x) { return _size[x]; }\n\n  bool isSame(int x, int y) { return root(x) == root(y); }\n};\n#endif\n#line 1 \"/mnt/c/Users/leafc/dev/compro/lib/template.hpp\"\n\ntemplate <class T> struct kruskal_edge {\n  int from;\n  int to;\n  T cost;\n};\n\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n#define MM << \" \" <<\n\nusing namespace std;\n\ntemplate <class T> void say(bool val, T yes = \"Yes\", T no = \"No\") { cout << (val ? yes : no) << endl; }\n\ntemplate <class T> void chmin(T &a, T b) {\n  if (a > b)\n    a = b;\n}\n\ntemplate <class T> void chmax(T &a, T b) {\n  if (a < b)\n    a = b;\n}\n\n#line 3 \"tmp.cpp\"\n\ndouble distance(double x, double y, double z) {\n    return sqrt(x*x + y*y + z*z);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    vector<double> x(n), y(n), z(n), r(n);\n\n    REP(i, n) { cin >> x[i] >> y[i] >> z[i] >> r[i]; }\n\n    vector<kruskal_edge<double>> es;\n    UnionFind uf(n);\n    REP(i, n) {\n      FOR(j, i + 1, n) {\n        double d = distance(x[i] - x[j], y[i] - y[j], z[i] - z[j]);\n        if (d > r[i] + r[j]) {\n          es.push_back({i, j, d - r[i] - r[j]});\n        } else {\n          uf.merge(i, j);\n        }\n      }\n    }\n\n    double ans = 0;\n    sort(ALL(es), [](kruskal_edge<double> a, kruskal_edge<double> b) { return a.cost < b.cost; });\n    for (const auto e : es) {\n      if (uf.isSame(e.from, e.to))\n        continue;\n      uf.merge(e.from, e.to);\n      ans += e.cost;\n    }\n\n    coutd(3) << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct Point{\n    double x, y, z;\n    double r;\n};\n\n\ndouble dist(Point a, Point b){\n    auto pow = [](double a){return a * a; };\n    return sqrt(pow(b.x - a.x) + pow(b.y - a.y) + pow(b.z - a.z)) - (a.r + b.r);\n}\n\nclass Edge {\n    public:\n        int to;\n        double cost;\n        Edge(int to, double cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble prim(const Graph &g, int s = 0) {\n    int n = g.size();\n    double total = 0;\n\n    vector<bool> visited(n);\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n    //priority_queue<pair<double, int> > q;\n\n    q.push(make_pair(0,s));\n    while (not q.empty()) {\n        pair<double, int> u = q.top(); q.pop();\n        if (visited[u.second]) continue;\n        total += u.first;\n        visited[u.second] = true;\n        for(auto it : g[u.second]) {\n            if (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n        }\n    }\n    return total;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        Point p[105];\n        rep(i,n) cin >> p[i].x >> p[i].y >> p[i].z >> p[i].r;\n\n        Graph g(n);\n        rep(i,n){\n            rep(j,n){\n                if(i == j) continue;\n                double tmp = dist(p[i], p[j]);\n//                cout << i << ' ' << j << endl;\n//                show(tmp)\n                g[i].emplace_back(Edge{j,tmp < 0 ? 0 : tmp});\n            }\n        }\n        cout <<fixed << setprecision(10) <<  prim(g,0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = long double;\n// }}}\n\nusing Real = f80;\n\nconstexpr i64  INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr Real FINF = Real(1e100L);\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n//constexpr i64 MOD = INT64_C(998'244'353);\n\nconstexpr Real EPS = Real(1e-10L);\n\n// util {{{\nconstexpr Real PI = Real(3.141592653589793238462643383279502884197L);\n\nbool LT_EPS(Real lhs, Real rhs, Real eps=EPS) { return lhs < rhs-eps; }\nbool GT_EPS(Real lhs, Real rhs, Real eps=EPS) { return lhs > rhs+eps; }\nbool EQ_EPS(Real lhs, Real rhs, Real eps=EPS) { return std::abs(lhs-rhs) <= eps; }\n\nbool EQ_EXACT(Real lhs, Real rhs) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n    return lhs == rhs;\n#pragma GCC diagnostic pop\n}\n\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, SFINAE(is_signed<T>::value)>\nconstexpr T ABS(T x) noexcept {\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr i64 CMP(T x, T y) noexcept { return (y<x) - (x<y); }\n\ntemplate<typename T>\nconstexpr i64 SGN(T x) noexcept { return CMP(x,T(0)); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](i64, const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T=i64>\nauto vec_iota(i64 n, T init={}) {\n    vector<i64> res(n);\n    ALL(iota, res, init);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// math {{{\n/*constexpr*/ i64 GCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    return f_gcd(ABS(a), ABS(b));\n}\n\n/*constexpr*/ i64 LCM(i64 a, i64 b) noexcept {\n    ASSERT(a != 0 && b != 0);\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    a = ABS(a);\n    b = ABS(b);\n    return a / f_gcd(a,b) * b;\n}\n\n/*constexpr*/ tuple<i64,i64,i64> EXTGCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto impl = FIX([](auto&& self, i64 aa, i64 bb) -> tuple<i64,i64,i64> {\n        if(bb == 0) return make_tuple(aa, 1, 0);\n        i64 g,x,y; tie(g,x,y) = self(bb, aa%bb);\n        return make_tuple(g, y, x-(aa/bb)*y);\n    });\n    i64 g,x,y; tie(g,x,y) = impl(ABS(a), ABS(b));\n    x *= SGN(a);\n    y *= SGN(b);\n    return make_tuple(g, x, y);\n}\n// }}}\n\n// string {{{\nauto str_reserve(i64 cap) {\n    string res;\n    res.reserve(cap);\n    return res;\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan<pair<T1,T2>> {\n    static pair<T1,T2> scan(istream& in) {\n        T1 x = Scan<T1>::scan(in);\n        T2 y = Scan<T2>::scan(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan1<pair<T1,T2>> {\n    static pair<T1,T2> scan1(istream& in) {\n        T1 x = Scan1<T1>::scan1(in);\n        T2 y = Scan1<T2>::scan1(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T>\ntuple<T> tuple_scan_impl(istream& in) {\n    return make_tuple(Scan<T>::scan(in));\n}\n\ntemplate<typename T, typename... TS, SFINAE(sizeof...(TS) > 0)>\ntuple<T,TS...> tuple_scan_impl(istream& in) {\n    auto head = make_tuple(Scan<T>::scan(in));\n    return tuple_cat(head, tuple_scan_impl<TS...>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan<tuple<TS...>> {\n    static tuple<TS...> scan(istream& in) {\n        return tuple_scan_impl<TS...>(in);\n    }\n};\n\ntemplate<typename T>\ntuple<T> tuple_scan1_impl(istream& in) {\n    return make_tuple(Scan1<T>::scan1(in));\n}\n\ntemplate<typename T, typename... TS, SFINAE(sizeof...(TS) > 0)>\ntuple<T,TS...> tuple_scan1_impl(istream& in) {\n    auto head = make_tuple(Scan1<T>::scan1(in));\n    return tuple_cat(head, tuple_scan1_impl<TS...>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan1<tuple<TS...>> {\n    static tuple<TS...> scan1(istream& in) {\n        return tuple_scan1_impl<TS...>(in);\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD_VEC<T>(w));\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD1_VEC<T>(w));\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<Real> {\n    static void dbg(ostream& out, Real x) {\n        if(EQ_EXACT(x, FINF))\n            out << \"FINF\";\n        else if(EQ_EXACT(x, -FINF))\n            out << \"-FINF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<size_t N>\nstruct Dbg<char[N]> {\n    static void dbg(ostream& out, const char (&s)[N]) {\n        out << s;\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<stack<T,C>> {\n    static void dbg(ostream& out, stack<T,C> stk) {\n        out << \"[\";\n        while(!stk.empty()) {\n            dbg_write(out,stk.top()); stk.pop();\n            if(!stk.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<queue<T,C>> {\n    static void dbg(ostream& out, queue<T,C> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.front()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C, typename Comp>\nstruct Dbg<priority_queue<T,C,Comp>> {\n    static void dbg(ostream& out, priority_queue<T,C,Comp> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.top()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<typename Mod>\nclass ModIntT {\nprivate:\n    i64 v_;  // [0,Mod::value)\n\n    static i64 mod() { return Mod::value; }\n\n    static i64 normalize(i64 x) {\n        i64 res = x % mod();\n        if(res < 0) res += mod();\n        return res;\n    }\n\npublic:\n    ModIntT() : v_(0) {}\n    ModIntT(i64 v) : v_(normalize(v)) {}\n\n    explicit operator i64() const { return v_; }\n\n    ModIntT operator-() const { return ModIntT(-v_); }\n\n    ModIntT& operator+=(ModIntT rhs) {\n        v_ = normalize(v_ + rhs.v_);\n        return *this;\n    }\n    ModIntT& operator-=(ModIntT rhs) {\n        v_ = normalize(v_ - rhs.v_);\n        return *this;\n    }\n    ModIntT& operator*=(ModIntT rhs) {\n        v_ = normalize(v_ * rhs.v_);\n        return *this;\n    }\n\n    ModIntT& operator++() { return *this += 1; }\n    ModIntT& operator--() { return *this -= 1; }\n    ModIntT operator++(int) { return exchange(*this, *this+1); }\n    ModIntT operator--(int) { return exchange(*this, *this-1); }\n\n    ModIntT inv() const {\n        i64 g,x; tie(g,x,ignore) = EXTGCD(v_, mod());\n        ASSERT(g == 1);\n        return ModIntT(x);\n    }\n};\n\ntemplate<typename Mod>\nModIntT<Mod> operator+(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) += rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator+(ModIntT<Mod> lhs, i64 rhs) { return ModIntT<Mod>(lhs) += rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator+(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(rhs) += lhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator-(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) -= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator-(ModIntT<Mod> lhs, i64 rhs) { return ModIntT<Mod>(lhs) -= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator-(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(rhs) -= lhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator*(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) *= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator*(ModIntT<Mod> lhs, i64 rhs) { return ModIntT<Mod>(lhs) *= rhs; }\ntemplate<typename Mod>\nModIntT<Mod> operator*(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(rhs) *= lhs; }\n\ntemplate<typename Mod>\nbool operator==(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return i64(lhs) == i64(rhs); }\ntemplate<typename Mod>\nbool operator==(ModIntT<Mod> lhs, i64 rhs) { return lhs == ModIntT<Mod>(rhs); }\ntemplate<typename Mod>\nbool operator==(i64 lhs, ModIntT<Mod> rhs) { return ModIntT<Mod>(lhs) == rhs; }\ntemplate<typename Mod>\nbool operator!=(ModIntT<Mod> lhs, ModIntT<Mod> rhs) { return !(lhs == rhs); }\ntemplate<typename Mod>\nbool operator!=(ModIntT<Mod> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<typename Mod>\nbool operator!=(i64 lhs, ModIntT<Mod> rhs) { return !(lhs == rhs); }\n\ntemplate<typename Mod>\nstruct ProconHash<ModIntT<Mod>> {\n    size_t operator()(ModIntT<Mod> x) const noexcept {\n        return procon_hash_value(i64(x));\n    }\n};\n\ntemplate<typename Mod>\nstruct Scan<ModIntT<Mod>> {\n    static ModIntT<Mod> scan(istream& in) {\n        i64 v = Scan<i64>::scan(in);\n        return ModIntT<Mod>(v);\n    }\n};\n\ntemplate<typename Mod>\nstruct Fmt<ModIntT<Mod>> {\n    static void fmt(ostream& out, ModIntT<Mod> x) {\n        fmt_write(out, i64(x));\n    }\n};\n\ntemplate<typename Mod>\nstruct Dbg<ModIntT<Mod>> {\n    static void dbg(ostream& out, ModIntT<Mod> x) {\n        dbg_write(out, i64(x));\n    }\n};\n\ntemplate<i64 M>\nusing ModIntC = ModIntT<integral_constant<i64,M>>;\n\nusing ModInt = ModIntC<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 3;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cin.exceptions(ios::failbit | ios::badbit);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(2);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// union_find {{{\n\nstruct UnionFind {\n    vector<i64> ps_;  // 親ノード。ただし根の場合 -(集合の要素数)\n    i64 size_;\n\n    explicit UnionFind(i64 n) : ps_(n,-1), size_(n) {}\n\n    i64 size() const { return size_; }\n\n    i64 root(i64 x) {\n        i64 p = ps_[x];\n        if(p < 0) return x;\n        return ps_[x] = root(p);\n    }\n\n    i64 group_size(i64 x) {\n        return -ps_[root(x)];\n    }\n\n    void unite(i64 x, i64 y) {\n        i64 rx = root(x);\n        i64 ry = root(y);\n        if(rx == ry) return;\n\n        // 要素数が大きい方を根とする\n        i64 kx = -ps_[rx];\n        i64 ky = -ps_[ry];\n        if(kx < ky) swap(rx, ry);\n        ps_[rx] = -(kx + ky);\n        ps_[ry] = rx;\n\n        --size_;\n    }\n};\n// }}}\n\n//--------------------------------------------------------------------\n\nusing Sphere = tuple<Real,Real,Real,Real>;\n\nReal f_dist2(const Sphere& s1, const Sphere& s2) {\n    Real x1,y1,z1; tie(x1,y1,z1,ignore) = s1;\n    Real x2,y2,z2; tie(x2,y2,z2,ignore) = s2;\n\n    Real dx = x1 - x2;\n    Real dy = y1 - y2;\n    Real dz = z1 - z2;\n\n    return dx*dx + dy*dy + dz*dz;\n}\n\nbool is_connected(const Sphere& s1, const Sphere& s2, Real eps=EPS) {\n    Real r1 = get<3>(s1);\n    Real r2 = get<3>(s2);\n\n    Real d2   = f_dist2(s1, s2);\n    Real sum2 = (r1+r2)*(r1+r2);\n\n    return !GT_EPS(d2,sum2,eps);\n#if 0\n    Real d2   = f_dist2(s1, s2);\n    Real sum2 = (r1+r2)*(r1+r2);\n    Real dif2 = (r1-r2)*(r1-r2);\n\n    return !GT_EPS(dif2,d2,eps) && !GT_EPS(d2,sum2,eps);\n#endif\n}\n\nReal f_cost(const Sphere& s1, const Sphere& s2, Real eps=EPS) {\n    if(is_connected(s1,s2)) return 0;\n\n    Real r1 = get<3>(s1);\n    Real r2 = get<3>(s2);\n\n    Real d2   = f_dist2(s1, s2);\n    Real sum2 = (r1+r2)*(r1+r2);\n    Real dif2 = (r1-r2)*(r1-r2);\n\n    if(LT_EPS(d2,dif2,eps))\n        return sqrt(dif2) - sqrt(d2);\n    else if(LT_EPS(sum2,d2,eps))\n        return sqrt(d2) - sqrt(sum2);\n    else\n        ASSERT(false);\n}\n\nvoid solve(i64 N) {\n    auto SS = RD_VEC<Sphere>(N);\n\n#if 0\n#ifdef PROCON_LOCAL\n    REP(i, N) FOR(j, i+1, N) {\n        const auto& s1 = SS[i];\n        const auto& s2 = SS[j];\n        Real r1 = get<3>(s1);\n        Real r2 = get<3>(s2);\n        Real sum2 = (r1+r2)*(r1+r2);\n        Real dif2 = (r1-r2)*(r1-r2);\n        DBG(i, j, f_dist2(s1,s2), sum2, dif2);\n        DBG(i, j, is_connected(s1,s2));\n    }\n#endif\n#endif\n\n    auto es = vec_reserve<tuple<Real,i64,i64>>(N*(N-1)/2);  // (cost,i,j)\n    REP(i, N) FOR(j, i+1, N) {\n        Real cost = f_cost(SS[i], SS[j]);\n        es.emplace_back(cost, i, j);\n    }\n    ALL(sort, es);\n    //DBG(es);\n\n    UnionFind uf(N);\n    Real ans = 0;\n    for(const auto& e : es) {\n        if(SIZE(uf) == 1) break;\n        Real cost; i64 i,j; tie(cost,i,j) = e;\n        if(uf.root(i) == uf.root(j)) continue;\n        ans += cost;\n        uf.unite(i, j);\n    }\n    ASSERT(SIZE(uf) == 1);\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    for(;;) {\n        i64 N = RD();\n        if(N == 0) break;\n\n        solve(N);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ndouble dist(double x, double y, double z){\n\treturn sqrt(x*x + y*y + z*z);\n}\n\nstruct UnionFind{\n\tvl p;\n\tvl rank;\n\tvl cnt;\n\n\tUnionFind(ll n){\n\t\trank.resize(n,0);\n\t\tp.resize(n,0);\n\t\tcnt.resize(n,0);\n\t\trep(i,n){\n\t\t\tp[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t}\n\n\tll find(ll x){\n\t\tif(x != p[x]) p[x] = find(p[x]);\n\t\treturn p[x];\n\t}\n\n\tbool same(ll x, ll y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(ll x, ll y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x] > rank[y]){\n\t\t\tp[y] = x;\n\t\t\tcnt[x] += cnt[y];\n\t\t}else{\n\t\t\tp[x] = y;\n\t\t\tcnt[y] += cnt[x];\n\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t}\n\t}\n\n\tll size(ll x){\n\t\treturn cnt[find(x)];\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(!n) break;\n\t\tvd x(n),y(n),z(n),r(n);\n\t\trep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tvector<tuple<double,int,int>> v;\n\t\trep(i,n){\n\t\t\tREP(j,i+1,n){\n\t\t\t\tdouble d = dist(x[i]-x[j], y[i]-y[j], z[i]-z[j]) - (r[i]+r[j]);\n\t\t\t\tv.emplace_back(max(d,0.0),i,j);\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0.0;\n\t\tUnionFind uf(n);\n\t\tsort(all(v));\n\t\tfor(auto i : v){\n\t\t\tint u,v; double d;\n\t\t\ttie(d,u,v) = i;\n\t\t\tif(uf.same(u,v)) continue;\n\t\t\tans += d;\n\t\t\tuf.unite(u,v);\n\t\t}\n\t\tprintf(\"%.3f\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <queue>\n#include <stack>\n#include <climits>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst ll mod = 1000000007;\nconst int inf = 1e9;\nconst long long INF = 1LL << 60;   // INFの値は1152921504606846976\n\nstruct UnionFind{\n    vector<int> rank,p,size;\n    UnionFind(int n){\n        rank.resize(n,0);\n        p.resize(n,0);\n        size.resize(n,0);\n        for(int i = 0; i < n; i++){\n            p[i] = i;\n            rank[i] = 0;\n            size[i] = 1;\n        }\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    int root(int x){\n        if(x != p[x]){\n            p[x] = root(p[x]);\n        }\n        return p[x];\n    }\n    bool unite(int x,int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return false;\n        if(rank[rx] > rank[ry]){\n            p[ry] = rx;\n            size[rx] += size[ry];\n        }else{\n            p[rx] = ry;\n            size[ry] += size[rx];\n            if(rank[rx] == rank[ry]){\n                rank[ry]++;\n            }\n        }\n        return true;\n    }\n    int tree_size(int x){\n        return (size[root(x)]);\n    }\n};\n\n\n\ndouble pow (double a){\n    return a * a;\n}\n\nint main()\n{\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        double x[n],y[n],z[n],r[n];\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        vector<pair<double,pair<int,int> > > vec;\n        UnionFind uf(n);\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                double d = pow(x[i]-x[j]) + pow(y[i]-y[j]) + pow(z[i]-z[j]);\n                d = sqrt(d);\n                if(d <= r[i] + r[j]){\n                    uf.unite(i,j);\n                }else{\n                    vec.push_back(make_pair(d-r[i]-r[j],make_pair(i,j)));\n                }\n            }\n        }\n        double ans = 0;\n        sort(vec.begin(),vec.end());\n        for(auto edge : vec){\n            if(!uf.same(edge.second.first,edge.second.second)){\n                uf.unite(edge.second.first,edge.second.second);\n                ans += edge.first;\n            }\n        }\n        printf(\"%.3lf\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;using pll = pair<ll, ll>;using pdd = pair<double, double>;using pss = pair<string, string>;using pbb = pair<bool, bool>;\nusing ti3 = tuple<int, int, int>;using tl3 = tuple<ll, ll, ll>;using td3 = tuple<double, double, double>;using ts3 = tuple<string, string, string>;using tb3 = tuple<bool, bool, bool>;\nusing ti4 = tuple<int, int, int, int>;using tl4 = tuple<ll, ll, ll, ll>;using td4 = tuple<double, double, double, double>;using ts4 = tuple<string, string, string, string>;using tb4 = tuple<bool, bool, bool, bool>;\nusing vi = vector<int>;using vl = vector<ll>;using vd = vector<double>;using vs = vector<string>;using vb = vector<bool>;\nusing vvi = vector<vi>;using vvl = vector<vl>;using vvd = vector<vd>;using vvs = vector<vs>;using vvb = vector<vb>;\nusing v3i = vector<vvi>;using v3l = vector<vvl>;using v3d = vector<vvd>;using v3s = vector<vvs>;using v3b = vector<vvb>;\nusing vpii = vector<pii>;using vpll = vector<pll>;using vpdd = vector<pdd>;using vpss = vector<pss>;using vpbb = vector<pbb>;\nusing vti3 = vector<ti3>;using vtl3 = vector<tl3>;using vtd3 = vector<td3>;using vts3 = vector<ts3>;using vtb3 = vector<tb3>;\nusing mii = map<int, int>;using mll = map<ll, ll>;using mci = map<char, int>;using msi = map<string, int>;\nusing si = set<int>;using sl = set<ll>;using sd = set<double>;using ss = set<string>;using sb = set<bool>;\nusing spii = set<pii>;using spll = set<pll>;using spdd = set<pdd>;using spss = set<pss>;using spbb = set<pbb>;\nusing sti3 = set<ti3>;using stl3 = set<tl3>;using std3 = set<td3>;using sts3 = set<ts3>;using stb3 = set<tb3>;\n#define rep0(TIMES) for (int CNT = 0; CNT < (int)(TIMES); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT < (ll)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT > (ll)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT];\treturn RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\nconst int INF = 1e9 + 7;\n// db\n\nusing tdii = tuple<double, int, int>;\n\nvi par; // par[i]: 要素iの親\nvi dep; // dep[i]: 要素iが根であるときは，iを含む木の最も深い要素の(根を0とした)深さ(rank)。iが根であるといえなければ dep[root(i)] とする。\nvi siz; // siz[i]: 要素iが根であるときは，iを含む木の大きさ(要素数，size)。iが根であるといえなければ siz[root(i)] とする。\n\nint root(int x) {\n\tif (par[x] == x) return x;\n\telse return par[x] = root(par[x]); // 縮約\n}\n\nvoid unite(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return;\n\tif (dep[x] > dep[y]) { // xを根とする木の方が深い場合\n\t\tpar[y] = x; // xが根となる\n\t\tsiz[x] += siz[y];\n\t} else if (dep[x] < dep[y]) {\n\t\tpar[x] = y;\n\t\tsiz[y] += siz[x];\n\t} else { // 深さが等しい場合，xを根とすることとする\n\t\tpar[y] = x;\n\t\tdep[x] ++;\n\t\tsiz[x] += siz[y];\n\t}\n}\n\nbool same(int x, int y) {\n\treturn root(x) == root(y);\n}\n\nvoid UF(int N) { // 0-ind，要素数Nでの初期化に使用する\n\tpar.assign(N, -1); dep.assign(N, 0); siz.assign(N, 1);\n\trep(i, N) par[i] = i; // 全ての要素につき自身が根であるとして初期化\n}\n\n// 最小全域木とする\nvoid solve(int n) {\n\t// 0-ind\n\tvd x(n), y(n), z(n), r(n);\n\trep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t// dbv(x); dbv(y); dbv(z); dbv(r);\n\tpriority_queue<tdii, vector<tdii>, greater<tdii>> q; // tdiiの第1要素の降順\n\tvvd g(n, vd(n)); // costmat;\n\t/* グラフ入力受取 */\t\n\trep(i, n - 1) rep2(j, 1, n)\t{\n\t\tdouble d = max(sqrt(pow(x[j] - x[i], 2.0) + pow(y[j] - y[i], 2.0) + pow(z[j] - z[i], 2.0)) - (r[i] + r[j]), 0.0);\n\t\tq.push(tdii(d, i, j));\n\t\tg[i][j] = g[j][i] = d;\n\t}\n\t// dbvv(g);\n\tUF(n);\n\tint cnt = 0; // cnt: uniteの回数。N-K回行うとN-木森がK-木森になる\n\tdouble ans = 0.0;\n\twhile (cnt < n - 1) {\n\t\tdouble d; int i, j; tie(d, i, j) = q.top(); q.pop();\n\t\tif (!same(i, j)) {\t\t\t\n\t\t\tunite(i, j);\n\t\t\tcnt++;\n\t\t\tans += d;\n\t\t\t// dbs(i, j, d, cnt, ans);\n\t\t}\n\t}\n\tprint(ans);\n}\n\nint main() {\n\tprec(3);\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tif (n) solve(n);\n\t\telse break;\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cstdio>\nusing namespace std;\n\n#define WHITE 0\n#define EPS 1e-10\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 1000\n#define INF 999999999.99\n\nlong double x[MAX_N][MAX_N];\nlong double MIN[MAX_N], color[MAX_N];\nlong double X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nlong double b, sum, sum_min;\nint n, c, a;\n\nvoid prim() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tMIN[j] = INF;\n\t\t\tcolor[j] = WHITE;\n\t\t}\n\t\tb = INF;\n\t\ta = n;\n\t\tcolor[i] = GRAY;\n\t\tMIN[i] = 0;\n\t\twhile (a != 0) {\n\t\t\tb = INF;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor[c] = BLACK;\n\t\t\ta -= 1;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (color[k] != BLACK && x[c][k] >= -EPS) {\n\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tsum += MIN[j];\n\t\t}\n\t\tsum_min = min(sum_min, sum);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tsum_min = INF;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tX[i] = 0; Y[i] = 0; Z[i] = 0;\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = -INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tlong double X1 = (X[i] - X[j])*(X[i] - X[j]);\n\t\t\t\tlong double Y1 = (Y[i] - Y[j])*(Y[i] - Y[j]);\n\t\t\t\tlong double Z1 = (Z[i] - Z[j])*(Z[i] - Z[j]);\n\t\t\t\tlong double dist = sqrtl(X1 + Y1 + Z1);\n\t\t\t\tlong double dist2 = dist - R[i] - R[j];\n\t\t\t\tx[i][j] = max(0.0l, dist2);\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tsum_min *= 10000;\n\t\tsum_min += 5;\n\t\tsum_min /= 10;\n\t\tint RES = sum_min;\n\t\tprintf(\"%03d.%03d\", RES / 1000, RES % 1000);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\n#define int long long\n#define double long double\n\n#define REP(i, b) for(int i = 0; i < (b); i++)\n#define REPS(i, b) for(int i = 1; i <= (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vpi = vector<pi>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\n\nconst int INF = 1e18;\nconst int MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while(true)\n    {\n        int n; cin >> n;\n        if(n == 0) break;\n        vd x(n), y(n), z(n), r(n), d(n, INF);\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n        double ans = 0;\n        REP(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        d[0] = 0;\n        q.push(mp(0, 0));\n        while(!q.empty())\n        {\n            pair<double, int> p = q.top(); q.pop();\n            if(p.fi > d[p.se]) continue;\n            ans += d[p.se];\n            REP(i, n)\n            {\n                if(chmin(d[i], max(sqrtl(powl(x[i]-x[p.se], 2)+powl(y[i]-y[p.se], 2)+powl(z[i]-z[p.se], 2)) - r[i] - r[p.se], (double)0.0)))\n                {\n                    q.push(mp(d[i], i));\n                }\n            }\n        }\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repi(i, a, b) for (int i = int(a); i < int(b); ++i)\ntypedef long long ll;\nlong long mod = 1e9 + 7;\nconst int iINF = 0x3f3f3f3f;\nconst long long INF = 1LL << 60;\nusing namespace std;\n\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nstruct Cell\n{\n  double x, y, z, r;\n};\n\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  bool operator<(const Edge &o) const\n  {\n    return cost < o.cost;\n  }\n};\n\nstruct UnionFind\n{\n  vector<int> d;\n  UnionFind(int n = 0) : d(n, -1) {}\n  int find(int x)\n  {\n    if (d[x] < 0)\n      return x;\n    return d[x] = find(d[x]);\n  }\n  bool unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return false;\n    if (d[x] > d[y])\n      swap(x, y);\n    d[x] += d[y];\n    d[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -d[find(x)]; }\n};\n\nint main()\n{\n  int n;\n\n  for (;;)\n  {\n    cin >> n;\n    if (n == 0)\n      break;\n    vector<Cell> cells;\n    vector<Edge> es;\n\n    rep(i, n)\n    {\n      double x, y, z, r;\n      cin >> x >> y >> z >> r;\n      Cell c;\n      c.x = x;\n      c.y = y;\n      c.z = z;\n      c.r = r;\n      cells.push_back(c);\n    }\n\n    rep(i, cells.size()) repi(j, i + 1, cells.size())\n    {\n      Cell c1 = cells[i];\n      Cell c2 = cells[j];\n      double cost = sqrt(pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2) + pow(c1.z - c2.z, 2)) - c1.r - c2.r;\n      chmax(cost, 0.0);\n      Edge e;\n      e.a = i;\n      e.b = j;\n      e.cost = cost;\n      es.push_back(e);\n    }\n\n    // クラスカル法\n    sort(es.begin(), es.end());\n    UnionFind uf(n);\n    double ans = 0.0;\n\n    rep(ei, es.size())\n    {\n      Edge e = es[ei];\n\n      if (!uf.same(e.a, e.b))\n      {\n        ans += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    cout << fixed << setprecision(3) << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100\n#define MAX_E 10000\nint V,E,par[MAX_V],rank[MAX_V];\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n \nEdge es[MAX_E];\n \nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n \nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n \n  if(x == y) return;\n \n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n \nbool same(int x,int y){\n  return find(x) == find(y);\n}\n \ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n \ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n \nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[MAX_V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n     \n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.3f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n#define EPS 1e-6\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint par[1000];\n\nvoid init(int n){\n    REP(i,n){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if (par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid merge(int x, int y){\n    x = find(x);\n    y = find(y);\n    if (x==y) return;\n    par[x] = y;\n}\n\nstruct edge{ int u, v; double cost; };\n\nvector<edge> es;\nint n;\n\nbool comp(const edge &e1, const edge &e2){\n    return e1.cost < e2.cost;\n}\n\ndouble kruskal(){\n    sort(es.begin(), es.end(), comp);\n    init(n);\n    double res = 0;\n    REP(i,es.size()){\n        edge e = es[i];\n        if (!same(e.u, e.v)){\n            merge(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n && n){\n        es.clear();\n        vector<double> x(n), y(n), z(n), r(n);\n        REP(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        REP(i,n) REP(j,n) {\n            edge e;\n            e.u = i;\n            e.v = j;\n            double d = sqrt(pow(x[i]-x[j],2) + pow(y[i]-y[j],2) + pow(z[i]-z[j],2));\n            d -= r[i] + r[j];\n            if (d < 0) d = 0;\n            e.cost = d;\n            es.push_back(e);\n        }\n        printf(\"%.3f\\n\", kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <numeric>\n#include <vector>\n\nusing namespace std;\n\nstruct Cell{\n\tdouble x,y,z,r;\n\tCell(){}\n\tCell(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble getdist(const Cell& a,const Cell& b)\n{\n\tdouble dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z;\n\tdouble d=sqrt(dx*dx+dy*dy+dz*dz);\n\treturn max(.0,d-(a.r+b.r));\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Cell> cs(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>cs[i].x>>cs[i].y>>cs[i].z>>cs[i].r;\n\t\tvector<vector<double> > dist(n,vector<double>(n));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tdist[i][j]=getdist(cs[i],cs[j]);\n\t\t\n\t\tvector<double> ds(n,1e10),fs(n);\n\t\tds[0]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint cur=-1;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(!fs[j] && (cur==-1 || ds[cur]>ds[j]))\n\t\t\t\t\tcur=j;\n\t\t\tfs[cur]=1;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(!fs[j])\n\t\t\t\t\tds[j]=min(ds[j],dist[cur][j]);\n\t\t}\n\t\t\n\t\tcout<<fixed<<setprecision(3)<<accumulate(ds.begin(),ds.end(),.0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 66\n    https://onlinejudge.u-aizu.ac.jp/problems/1127\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* constant */\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 50;\nconst int NIL = -1;\n/* class */\nclass DisjointSet {\npublic:\n    vector<int> d;\n    DisjointSet () {}\n    DisjointSet (int len) { d.assign(len, -1); }\n\n    int find(int x) {\n        if (d[x] < 0) return x;\n        return d[x] = find(d[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        if (d[x] > d[y]) swap(x, y);\n        d[x] += d[y];\n        d[y] = x;\n        return true;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n    int size(int x) { return -d[find(x)];}\n};\nclass Edge {\npublic:\n    int u, v;\n    double w;\n    Edge () {}\n    Edge (int u, int v, double w) : u(u), v(v), w(w) {}\n    bool operator < (const Edge &e) const {\n        return w < e.w;\n    }\n};\nclass Cube {\npublic:\n    double x, y, z, r;\n    Cube () {}\n    Cube (double x, double y, double z, double r) :\n    x(x), y(y), z(z), r(r) {}\n};\n\n/* global variables */\n/* function */\nvoid kruscal(DisjointSet ds, vector<Edge> edges) {\n   // kruscal\n    sort(edges.begin(), edges.end());\n    double totalCost = 0.0;\n    for (Edge e : edges)\n        if (ds.unite(e.u, e.v))\n            totalCost += e.w;\n    cout << fixed << setprecision(3) << totalCost << '\\n';\n}\ndouble dist(Cube c1, Cube c2) {\n    double dx = c1.x - c2.x;\n    double dy = c1.y - c2.y;\n    double dz = c1.z - c2.z;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\ndouble calcDist(Cube c1, Cube c2) { return (dist(c1, c2) - (c1.r + c2.r)); }\nvoid solve(int N) {\n    vector<Cube> C(N, Cube());\n    for (int i = 0; i < N; i++) {\n        double x, y, z, r;\n        cin >> x >> y >> z >> r;\n        C[i] = Cube(x, y, z, r);\n    }\n    // if (球i, jが重なっている) 同じグループにいれる\n    // else つなぐ可能性がある\n    DisjointSet ds = DisjointSet(N);\n    vector<Edge> edges;\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = 0; j < N; j++) {\n            double d = calcDist(C[i], C[j]);\n            if (d <= 0) ds.unite(i, j);\n            else edges.push_back(Edge(i, j, d));\n        }\n    }\n    kruscal(ds, edges);\n}\n/* main */\nint main(){\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) return 0;\n        solve(N);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\nconst double eps = 1e-8;\n\nint root(vector<int> & ufa,int i)\n{\n\tif(ufa[i] != i)\n\t\tufa[i] = root(ufa,ufa[i]);\n\treturn ufa[i];\n}\n\nvoid join(vector<int> & ufa,int i,int j)\n{\n\tint ri = root(ufa,i);\n\tint rj = root(ufa,j);\n\tufa[ri] = rj;\n}\n\nstruct e\n{\n\tint s;\n\tint t;\n\tdouble cst;\n};\n\nbool operator<(const e & lhs,const e & rhs)\n{\n\treturn lhs.cst < rhs.cst;\n}\n\nint main(void) {\n\tcout.precision(3);\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tvector<double> x(n);\n\t\tvector<double> y(n);\n\t\tvector<double> z(n);\n\t\tvector<double> r(n);\n\t\tvector<int> ufa(n);\n\t\tREP(i,n)ufa[i]=i;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tvector<vector<double> > dist_big(n,vector<double>(n,INF));\n\t\tREP(i,n)REP(j,n)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tint d = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n\t\t\tdist_big[i][j]=dist_big[j][i]=sqrt(d)-(r[i]+r[j]);\n\t\t\tif(d <= (r[i]+r[j]+eps)*(r[i]+r[j]+eps))\n\t\t\t{\n\t\t\t\tjoin(ufa,i,j);\n\t\t\t}\n\t\t}\n\t\tset<int> sec;\n\t\tREP(i,n)\n\t\t\tsec.insert(root(ufa,i));\n\t\tint secn = sec.size();\n\t\tif(secn > 1)\n\t\t{\n\t\t\tvector<int> roots;\n\t\t\tFORIT(i,sec)\n\t\t\t\troots.push_back(*i);\n\t\t\tvector<vector<double> > dist(secn,vector<double>(secn,INF));\n\t\t\tREP(i,n)REP(j,n)\n\t\t\t{\n\t\t\t\tif(ufa[i]==ufa[j])continue;\n\t\t\t\tint di,dj;\n\t\t\t\tREP(k,secn)\n\t\t\t\t{\n\t\t\t\t\tif(roots[k]==ufa[i])di=k;\n\t\t\t\t\tif(roots[k]==ufa[j])dj=k;\n\t\t\t\t}\n\t\t\t\tdist[di][dj]=min(dist[di][dj],dist_big[i][j]);\n\t\t\t}\n\t\t\tvector<e> edge;\n\t\t\tREP(i,secn)REP(j,i)\n\t\t\t{\n\t\t\t\te p = {i,j,dist[i][j]};\n\t\t\t\tedge.push_back(p);\n\t\t\t}\n\t\t\tsort(ALL(edge));\n\t\t\tvector<int> ufa2(secn);\n\t\t\tREP(i,secn)ufa2[i]=i;\n\t\t\tdouble cost = 0.0;\n\t\t\tREP(i,edge.size())\n\t\t\t{\n\t\t\t\te p = edge[i];\n\t\t\t\tif(root(ufa2,p.s) != root(ufa2,p.t))\n\t\t\t\t{\n\t\t\t\t\tjoin(ufa2,p.s,p.t);\n\t\t\t\t\tcost += p.cst;\n\t\t\t\t\tsecn--;\n\t\t\t\t\tif(secn == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout  << setiosflags(ios::fixed)<< cost << endl;\n\t\t}\n\t\telse\n\t\t\tcout << 0.0 << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      res += d[t];\n      //res += d[p[t]];  // p[0] = 0;\n      //printf(\"res: %.3lf\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    //res += d[p[t]];\n    printf(\"%.3lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int rank[MAX_N];\n  int s[MAX_N];\n  bool used[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y; s[y] = s[x] + s[y];\n    } else {\n      par[y] = x; s[x] = s[x] + s[y];\n      if( rank[x] == rank[y] ) rank[x]++;\n    }\n  }\n  int size(int x) { return s[find(x)];}\n  bool same(int x, int y) { return find(x) == find(y);}\n  int group(int n) {\n    REP(i, n) used[find(i)] = true;\n    int ret = 0;\n    REP(i, n) if(used[i]) ret++;\n    return ret;\n  }\n};\nUnionFind uf;\n\ndouble x[105], y[105], z[105], r[105];\nvector<pair<double, PII>> e;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n    e.clear();\n    int m = 0;\n    REP(i, n) FOR(j, i+1, n) {\n      double d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j])) - r[i] - r[j];\n      if(d < 0) d = 0;\n      e.PB({d, {i, j}});\n      m++;\n    }\n    sort(ALL(e));\n\n    uf.init(n);\n    double ret = 0;\n    REP(i, m) {\n      if(!uf.same(e[i].second.first, e[i].second.second)) {\n        ret += e[i].first;\n        uf.unite(e[i].second.first, e[i].second.second);\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int rank[MAX_N];\n  int s[MAX_N];\n  bool used[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y; s[y] = s[x] + s[y];\n    } else {\n      par[y] = x; s[x] = s[x] + s[y];\n      if( rank[x] == rank[y] ) rank[x]++;\n    }\n  }\n  int size(int x) { return s[find(x)];}\n  bool same(int x, int y) { return find(x) == find(y);}\n  int group(int n) {\n    REP(i, n) used[find(i)] = true;\n    int ret = 0;\n    REP(i, n) if(used[i]) ret++;\n    return ret;\n  }\n};\nUnionFind uf;\n\ndouble x[105], y[105], z[105], r[105];\nvector<pair<double, PII>> e;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n    e.clear();\n    int m = 0;\n    REP(i, n) FOR(j, i+1, n) {\n      double d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j])) - r[i] - r[j];\n      if(d < 0) d = 0;\n      e.PB({d, {i, j}});\n      m++;\n    }\n    sort(ALL(e));\n\n    uf.init();\n    double ret = 0;\n    for(auto i: e) {\n      if(!uf.same(i.second.first, i.second.second)) {\n        ret += i.first;\n        uf.unite(i.second.first, i.second.second);\n      }\n    }\n    cout << fixed << setprecision(3) << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nclass DisjointSet{\nprivate:\n  vector<int> rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n  }\n  void build(){\n    for(int i = 0; i < rank.size(); i++){\n      makeSet(i);\n    }\n  }\n  void makeSet(int x){\n    p[x] = x, rank[x] = 0;\n  }\n  void Union(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  int findSet(int x){\n    return( x != p[x] ? p[x] = findSet(p[x]) : p[x]);\n  }\n};\nstruct edge{\n  int u, v;\n  double cost;\n  bool operator<(const edge& hoge)const{\n    return cost < hoge.cost;\n  }\n};\ntypedef vector< edge > Edges;\nvoid add_edge(Edges& info, int u, int v, double cost){\n  info.push_back( (edge){ u, v, cost});\n}\ndouble kruskal(Edges& edges, int V){\n  sort( edges.begin(), edges.end());\n  DisjointSet uf_tree(V); uf_tree.build();\n  double ret = 0.0;\n  for(int i = 0; i < edges.size(); i++){\n    edge& e = edges[i];\n    if(uf_tree.findSet(e.u) != uf_tree.findSet(e.v)){\n      uf_tree.Union( e.u, e.v);\n      ret += e.cost;\n    }\n  }\n  return ret;\n}\n\ndouble GetDist( double x1, double y1, double z1, double r1,\n                double x2, double y2, double z2, double r2){\n  double dx = fabs( x2 - x1), dy = fabs( y2 - y1), dz = fabs( z2 - z1);\n  double dist = max(sqrt( dx * dx + dy * dy + dz * dz) - r1 - r2, 0.0);\n  return dist;\n}\n\nint main(){\n  int n;\n  double x[100], y[100], z[100], r[100];\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    Edges edges;\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        add_edge( edges, i, j, GetDist( x[i], y[i], z[i], r[i], x[j], y[j], z[j], r[j]));\n      }\n    }\n    cout << fixed << setprecision(3) << kruskal(edges, n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stdexcept>\n#include<cmath>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) D4(D2(a,b),D2(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define pf push_front\n#define LIM 100000\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<double,double> D2;\ntypedef pair<D2,D2> D4;\ntypedef pair<int,double> ID;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n;\nvector<ID> G[200];\ndouble d[200];\ndouble cost[200][200];\nint par[200];\n\nstruct edge {int u,v; double cost;};\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nedge es[200];\nint V,E;\n\nvoid init(int x){\n  rep(i,x){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x)return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y)return;\n  par[x] = y;\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\n\n\nbool judgement(D4 a, D4 b){\n  double len;\n  len = sqrt(pow(a.F.F - b.F.F,2)+pow(a.F.S - b.F.S,2)+pow(a.S.F - b.S.F,2));\n  if(len-(a.S.S+b.S.S) <= EPS)return false;\n  return true;\n}\n\ndouble kraskal(){\n  sort(es,es+E,comp);\n  init(V);\n  double res = 0;\n  rep(i,E){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      unit(e.u,e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n\n  while(true){\n    cin >> n;\n    if(n == 0)break;\n    V = n;\n    E = n*n;   \n\n    \n    vector<D4> vec; \n    rep(i,n){\n      double x,y,z,r;\n      cin >> x >> y >> z >> r;\n      vec.pb(insert(x,y,z,r));\n    }\n\n   \n\n    /* --- 座標、コスト作成  --- */\n    rep(i,n){\n      rep(j,n){\n\tes[i*n+j].u = i,es[i*n+j].v = j,es[i*n+j].cost = fabs(sqrt(pow(vec[i].F.F-vec[j].F.F,2)+pow(vec[i].F.S-vec[j].F.S,2)+pow(vec[i].S.F-vec[j].S.F,2)) - (vec[i].S.S + vec[j].S.S));\n\tif(!judgement(vec[i],vec[j])){\n\t  es[i*n+j].cost = 0;\n\t}\n      }\n    }\n\n    cout << setiosflags(ios::fixed) << setprecision(3) << kraskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nstruct UnionFind\n{\n    int i;\n    vector<int> par;\n    vector<int> size;\n    UnionFind(int n): par(n),size(n,1){\n        for(i = 0;i < n;++i){\n            par.at(i) = i;\n        }\n    }\n    \n    int root(int x){\n        if(par.at(x) == x){\n            return x;\n        }else{\n            return par.at(x) = root(par.at(x));\n        }\n    }\n    \n    void unite(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry){\n            return;\n        }else{\n            if(size.at(rx) < size.at(ry)){\n                swap(rx,ry);\n            }\n            par.at(ry) = rx;\n            size.at(rx) += size.at(ry);\n            return;\n        }\n    }\n    \n    bool same(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n    \n    int get_size(int x){\n        return size.at(root(x));\n    }\n};\n\nint main()\n{\n    ll i,j;\n    while(true){\n        ll n;\n        cin >> n;\n        if(n == 0) return 0;\n        vector<double> x(n);\n        vector<double> y(n);\n        vector<double> z(n);\n        vector<double> r(n);\n        for(i = 0;i < n;++i){\n            cin >> x.at(i) >> y.at(i) >> z.at(i) >> r.at(i);\n        }\n\n        priority_queue<pair<double,pair<ll,ll>>> pq; //優先度付きキュー\n        for(i = 0;i < n-1;++i){\n            for(j = i+1;j < n;++j){\n                double kyori = sqrt(pow(x.at(i) - x.at(j), 2.0) + pow(y.at(i) - y.at(j), 2.0) + pow(z.at(i) - z.at(j), 2.0));\n                kyori = max(0.0, kyori - r.at(i) - r.at(j));\n                pq.emplace(-kyori, make_pair(i,j));\n                pq.emplace(-kyori, make_pair(j,i));\n            }\n        }\n        \n        double ans = 0; //最小全域木の重み\n        \n        UnionFind uf(n); //連結管理(UnionFind)\n        while(!pq.empty()){\n            auto x = pq.top();\n            pq.pop();\n            double w = -x.first;\n            ll s = x.second.first;\n            ll t = x.second.second;\n            if(uf.same(s,t)) continue; //連結は排除\n            ans += w;\n            uf.unite(s,t);\n        }\n\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-9\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n// start up //\nvoid solve();\nint main() { solve(); return 0; }\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x=0, double y=0, double z=0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x+_.x, y+_.y, z+_.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_,y*_,z*_); }\n\tP3 operator /(double _) const { return P3(x/_,y/_,z/_); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; }\n\tP3 cross(const P3 &_) const { return P3(y*_.z-z*_.y, z*_.x-x*_.z, x*_.y-y*_.x); }\n\tdouble sqlength() const { return x*x+y*y+z*z; }\n\tdouble length() const { return sqrt(sqlength()); }\n\tP3 direction() const { return *this / length(); }\n};\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x,y,z), r(r) { }\n};\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from, int to, double cost) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator > (const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\t\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.from;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j,N) if (parent[i] == -1) q.push(Path(i,j,costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n\tusing vector<vector<T>>::operator []; \n\tT& operator [](const POINT &index) { return (*this)[index.real()][index.imag()]; }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i,n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i,n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i,n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss; \n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n/// template end ///\n\nvoid solve()\n{\n\tREP (testcase, INF)\n\t{\n\t\t// よみこみ\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tvector<Sphere> spheres;\n\t\tREP(i,N) { READ(double, x,y,z,r); spheres.push_back(Sphere(x,y,z,r)); }\n\n\t\t// cost[i][j] = 球i - 球j 間に廊下を作った時のコスト表\n\t\tvevector<double> costTable(N, N);\n\t\tREP(i,N) REP(j,N)\n\t\t{\n\t\t\tSphere &si = spheres[i], &sj = spheres[j];\n\t\t\tcostTable[i][j] = max((si.c - sj.c).length() - (si.r + sj.r), 0.0);\n\t\t}\n\n\t\t// 最少全域木\n\t\tdouble totalCost = prim(costTable).first;\n\n\t\twrite(totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(i,n) for(ll i=0;i<n;++i)\n#define ALL(a) (a).begin(),(a).end()\n \nusing namespace std;\nusing ll  = long long;\nusing pll = pair<ll, ll>;\n \nconst ll MOD  = 1e9+7;\nconst ll LINF = 1LL << 60;\nconst int INF = 1e9 + 7;\n\nstruct UnionFind {\n    vector<ll> parent;\n    vector<ll> usize;\n \n    UnionFind(int n) : parent(n), usize(n, 1LL){\n        rep(i, n)parent[i]=i;\n    }\n    \n    int root(int x){\n        if(parent[x] == x) return x;\n        else return parent[x] = root(parent[x]);\n    }\n    \n    bool issame(int x, int y){\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n \n        if(x == y)return false;\n \n        if(parent[x] > parent[y]) swap(x, y);\n\n        usize[x] += usize[y];\n        parent[y] = x;\n \n        return true;\n    }\n    \n    int size(int x) {\n        return usize[root(x)];\n    }\n};\n\ndouble dist_a2b(vector<double> a, vector<double> b){\n    double dif_x, dif_y, dif_z;\n\n    dif_x = pow(a[0] - b[0], 2);\n    dif_y = pow(a[1] - b[1], 2);\n    dif_z = pow(a[2] - b[2], 2);\n\n    return sqrt(dif_x + dif_y + dif_z);\n}\n\ndouble solve(ll n, vector<vector<double>> cell, vector<double> sphere){\n    vector<double> dist;\n    vector<pll> cell_pair;\n    rep(i, n)rep(j, n){\n        if(i == j)continue;\n        dist.push_back(max(0.0, dist_a2b(cell[i], cell[j])-(sphere[i]+sphere[j])));\n        cell_pair.push_back(make_pair(i, j));\n    }\n\n    vector<ll> ord(dist.size());\n    iota(ALL(ord), 0);\n    sort(ALL(ord), [&](ll x, ll y){\n        return dist[x] < dist[y];\n    });\n\n    UnionFind uf(n);\n\n    double res = 0.0;\n    rep(i, dist.size()){\n        if(!uf.issame(cell_pair[ord[i]].first, cell_pair[ord[i]].second)){\n            res += dist[ord[i]];\n            uf.merge(cell_pair[ord[i]].first, cell_pair[ord[i]].second);\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    vector<double> ans;\n\n    while(true){\n        int n;\n        cin >> n;\n\n        if(n == 0)break;\n\n        vector<vector<double>> cl(n, vector<double>(3));\n        vector<double> sp(n);\n        rep(i, n){\n            cin >> cl[i][0] >> cl[i][1] >> cl[i][2] >> sp[i];\n        }\n\n        ans.push_back(solve(n, cl, sp));\n    }\n\n    rep(i, ans.size())printf(\"%.3f\\n\", ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Sphere>sps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong double x, y, z, r; cin >>x>>y>>z>> r;\n\t\t\tsps.emplace_back(Point3(x, y, z), r);\n\t\t}\n\t\tvector<vector<long double>>diss(n, vector<long double>(n,0));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)diss[i][j] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif (sps[i].r + sps[j].r > abs(sps[i].p - sps[j].p)) {\n\t\t\t\t\t\tbool flag = false;\n\t\t\t\t\t\tif (sps[i].r < sps[j].r) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sps[i].r < abs(sps[i].p - sps[j].p) + sps[j].r) {\n\n\t\t\t\t\t\t\tdiss[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//diss[i][j] = sps[i].r - (abs(sps[i].p - sps[j].p) + sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tswap(sps[i].r, sps[j].r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdiss[i][j] = abs(sps[i].p - sps[j].p) - sps[i].r - sps[j].r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<long double, int>, vector<pair<long double, int>>,greater<pair<long double,int>>>que;\n\t\tvector<bool>unit(n, false);\n\t\tque.push(make_pair(0,0));\n\t\tlong double ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long double, int>atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (unit[atop.second])continue;\n\t\t\telse {\n\t\t\t\tunit[atop.second] = true;\n\t\t\t\tans += atop.first;\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tif (!unit[i]) {\n\t\t\t\t\t\tque.push(make_pair(diss[atop.second][i],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(5)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[300][300];\nchar field[200][200];\n\n#define MAX 10000\ntemplate<class TYPE>\nclass Prim{\nprivate:\n  struct Edge{int to;TYPE cost;};\n  static const int INF = 1e+9+7;\n  vector<Edge> G[MAX];\n  TYPE mincost[MAX];\n  bool used[MAX];\n  int N;\n  int m;\n\npublic:\n  // Prim(){\n  //   cin >> N >> m;\n  //   for(int i = 0;i < m;i++){\n  //     int p,q;\n  //     TYPE r;\n  //     cin >> p >> q >> r;\n  //     G[p].pb(Edge{q,r});\n  //     G[q].pb(Edge{p,r});\n  //   }\n  // }\n\n  Prim(int n,int l){\n    N = n;\n    m = l;\n  }\n\n  void in(int p,int q,TYPE r){\n    // cin >> p >> q >> r;\n    G[p].pb(Edge{q,r});\n    G[q].pb(Edge{p,r});\n  }\n\n  TYPE prim(){\n    TYPE res = 0;\n    for(int i = 0;i < N;i++){\n      mincost[i] = INF;\n      used[i] = false;\n    }\n    mincost[0] = (TYPE)0;\n    while(1){\n      int v = -1;\n      for(int i = 0;i < N;i++){\n        if(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n      }\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n      for(int i = 0;i < G[v].size();i++){\n        mincost[G[v][i].to] = min(mincost[G[v][i].to],G[v][i].cost);\n      }\n    }\n    return res;\n  }\n};\n\nnamespace Geometry{\n  #define equals(a,b) (fabs((a) - (b)) < EPS)\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n  #define gprint(X) cout << fixed << setprecision(8) << (X) << endl\n  #define gprints(X,Y) cout << fixed << setprecision(8) << (X) << \" \" << (Y) << endl\n  const double EPS = 1e-10;\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n  \n  class Point{\n  public:\n    double x,y;\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator += (Point p){ return Point(x += p.x,y += p.y); }\n    Point operator -= (Point p){ return Point(x -= p.x,y -= p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n    bool operator < (const Point &p) const{ return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (const Point &p) const{ return equals(x,p.x) && equals(y,p.y); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n    friend ostream& operator << (ostream &os,Point &p){ return os << p.x << \" \" << p.y; }\n    friend istream& operator >> (istream &is,Point &p){ return is >> p.x >> p.y; }\n  };\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &seg){ return os << seg.p1 << \" \" << seg.p2; }\n    friend istream& operator >> (istream &is,Segment &seg){ return is >> seg.p1 >> seg.p2; }\n  };\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){ return os << c.c << \" \" << c.r; }\n    friend istream& operator >> (istream &is,Circle &c){ return is >> c.c >> c.r; }\n  };\n\n  typedef Point Vector;\n  typedef Segment Line;\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){ return  a.x * a.x + a.y * a.y; }\n  double abs(Vector a){ return sqrt(norm(a)); }\n  double dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\n  double cross(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\n  bool Orthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\n  bool Orthogonal(Point a1,Point a2,Point b1,Point b2){ return Orthogonal(a1 - a2,b1 - b2); }\n  bool Orthogonal(Segment s1,Segment s2){ return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0); }\n  bool Parallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\n  bool Parallel(Point a1,Point a2,Point b1,Point b2){ return Parallel(a1 - a2 , b1 - b2); }\n  bool Parallel(Segment s1,Segment s2){ return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0); }\n  bool less(const Point &a,const Point &b){ return (a.x != b.x) ? a.x < b.x : a.y < b.y; }\n  bool greater(const Point &a,const Point b){ return !less(a,b); }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  int ccw(Point &p0,Point p1,Point p2){\n    p1 -= p0;\n    p2 -= p0;\n    if(cross(p1,p2) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(p1,p2) < -EPS)return CLOCKWISE;\n    if(dot(p1,p2) < -EPS)return ONLINE_BACK;\n    if(p1.norm() < p2.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n  bool intersect(Segment s1,Segment s2){ return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2); }\n\n  double getDistance(Vector a,Vector b){ return abs(a - b); }\n  double getDistanceLP(Line l,Point p){ return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1)); }\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){ return atan2(p.y,p.x); }\n  Vector polar(double a,double r){ return Point(cos(r) * a, sin(r) * a); }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n  \n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  //=====================================================//\n  //==================== Andrew Scan ====================//\n  //=====================================================//\n \n  int Accw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return 1;\n    return -1;\n  }\n \n  Polygon andrewScan(Polygon s){\n    Polygon ans;\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && Accw(u[n-2],u[n-1],s[i]) != -1;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n \n    for(int i = s.size() - 3;i >= 0;i--){\n      for(int n = l.size();n >= 2 && Accw(l[n-2],l[n-1],s[i]) != -1;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--){\n      l.push_back(u[i]);\n    }\n    int f = 0;\n    for(int i = 1;i < l.size();i++){\n      if(l[f].y > l[i].y || (l[f].y == l[i].y && l[f].x > l[i].x)){\n        f = i;\n      }\n    }\n    for(int i = 0;i < l.size();i++){\n      ans.push_back(Point((int)l[(i + f)%l.size()].x,(int)l[(i + f)%l.size()].y));\n    }\n    return ans;\n  }\n\n  //=====================================================//\n  //======================== END ========================//\n  //=====================================================//\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nclass Circle2{\npublic:\n  double x,y,z;\n  double r;\n  Circle2(double x = 0.0,double y = 0.0,double z = 0.0,double r = 0.0): x(z),y(y),z(z),r(r){}\n  friend istream& operator >> (istream &is,Circle2 &c){ return is >> c.x >> c.y >> c.z >> c.r; }\n};\n\nint main(){\n  while(cin >> n,n){\n    vector<Circle2> vec;\n    Prim<double> ans(n,n*(n-1));\n    rep(i,0,n){\n      Circle2 a;\n      cin >> a;\n      vec.pb(a);\n    }\n    rep(i,0,n){\n      rep(j,i+1,n){\n        double distin = 0;\n        double dist1 = sqrt((vec[i].x - vec[j].x)*(vec[i].x - vec[j].x) + (vec[i].y - vec[j].y)*(vec[i].y - vec[j].y) + (vec[i].z - vec[j].z)*(vec[i].z - vec[j].z));\n        double dist2 = vec[i].r + vec[j].r;\n        if(dist1 > dist2)distin = dist1 - dist2;\n        // printf(\"%f , %f : %f\\n\",dist1,dist2,distin);\n        ans.in(i,j,distin);\n      }\n    }\n    cout << fixed << setprecision(3) << ans.prim() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct unionfind{\n  int par[100010]; // 親ノード  必要に応じて要素数を変えよう\n  int rank[100010]; // ランク　必要に応じて要素数を変えよう\n  unionfind(int n){\n    init(n);\n  }\n  void init(int n){\n    for(int i=0;i<=n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = root(par[x]);\n    }\n  }\n  int size(int x){\n    return rank[root(x)];\n  }\n  bool same(int x,int y) {\n    return root(x) == root(y);\n  }\n  void unite(int x,int y) {\n    x=root(x);\n    y=root(y);\n    if(x==y){\n      return;\n    }\n    if(rank[x]<rank[y]){\n      swap(x,y);\n    }\n    rank[x]=rank[x]+rank[y];\n    par[y]=x;\n  }\n};\nstruct edge{\n  int from;\n  int to;\n  double cost;\n  edge(int f,int t,double w) : from(f),to(t),cost(w){}\n};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost<e2.cost;\n}\nint main(){\n  int i,j,n;\n  while(1){\n    scanf(\"%d\\n\",&n);\n    if(n==0){\n      return 0;\n    }\n    vector<edge> g;\n    double x[110],y[110],z[110],r[110];\n    for(i=0;i<n;i++){\n      scanf(\"%lf %lf %lf %lf\\n\",&x[i],&y[i],&z[i],&r[i]);\n    }\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n        double len=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n        if(len-r[i]-r[j]<0){\n          len=0;\n        }\n        else{\n          len=len-r[i]-r[j];\n        }\n        g.push_back(edge(i,j,len));\n      }\n    }\n    double ans=0;\n    sort(g.begin(),g.end(),comp);\n    unionfind tree(110);\n    for(i=0;i<g.size();i++){\n      if(!tree.same(g[i].from,g[i].to)){\n        tree.unite(g[i].from,g[i].to);\n        ans+=g[i].cost;\n      }\n    }\n    printf(\"%.3lf\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nstruct Edge {\n  int to;\n  double cost;\n  Edge() {}\n  Edge(int to, double cost) : to(to), cost(cost) {}\n};\n\nconst int MAX_N = 101;\nint N;\ndouble X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nvector<Edge> E[MAX_N];\n\ndouble abs(double x, double y, double z) {\n  return sqrt(x*x+y*y+z*z);\n}\n\nvoid makeE() {\n  for(int i = 0; i < MAX_N; ++i) E[i].clear();\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      double cost = max(0.0,\n\t\t\tabs(X[i]-X[j],Y[i]-Y[j],Z[i]-Z[j]) - (R[i]+R[j]));\n      E[i].push_back(Edge(j,cost)); \n    }\n  }\n}\n  \ndouble prim() {\n  priority_queue<pair<double,int> > que;\n  bool vis[MAX_N];\n  fill(vis,vis+MAX_N,false);\n  que.push(make_pair(0.0,0));\n  double sum = 0;\n  while(!que.empty()) {\n    double cost = que.top().first;\n    int p = que.top().second;\n    que.pop();\n    if(vis[p]) continue;\n    vis[p] = true;\n    sum += -cost;\n    for(int i = 0; i < E[p].size(); ++i) {\n      Edge &e = E[p][i];\n      if(vis[e.to]) continue;\n      que.push(make_pair(-e.cost,e.to));\n    }\n  }\n  return sum;\n}\n\ndouble solve() {\n  makeE();\n  return prim();\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      scanf(\"%lf%lf%lf%lf\",&X[i],&Y[i],&Z[i],&R[i]);\n    }\n    printf(\"%.3f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst int INF = 1<<29;\n\ndouble prim(){\n  double ret = 0;\n  bool used[100]={};\n  double dist[100];\n  for(int i=0;i<n;++i) dist[i]=INF;\n  dist[0]=0;\n  while(true){\n    int id = -1;\n    double mindst = INF;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dist[i]){\n\tmindst = dist[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id] = true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dist[i]=min(dist[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;cin>>a;return a;}\n\nint main(){\n  while(cin>>n,n){\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n\n    cout << fixed << setprecision(10) << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma gcc optimize(\"Ofast\")\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nstruct Point {\n\tdouble x, y, z;\n\tPoint() : x(0), y(0), z(0) {}\n\tPoint(double x, double y, double z) : x(x), y(y), z(z) {}\n\tconst Point operator+(const Point &p) const { return Point(x + p.x, y + p.y, z + p.z); }\n\tconst Point operator-(const Point &p) const { return Point(x - p.x, y - p.y, z - p.z); }\n\tconst double norm2() const { return x * x + y * y + z * z; }\n\tconst double norm() const { return sqrt(norm2()); }\n};\n\nstruct Dsu {\n\tvi dsu;\n\tDsu(int n) {\n\t\tdsu = vi(n);\n\t\trep(i, 0, n) dsu[i] = i;\n\t}\n\tint find(int u) {\n\t\tif (u == dsu[u]) return u;\n\t\telse return dsu[u] = find(dsu[u]);\n\t}\n\tbool merge(int u, int v) {\n\t\tu = find(u), v = find(v);\n\t\tif (u == v) return false;\n\t\tdsu[v] = u;\n\t\treturn true;\n\t}\n};\n\nconst double eps = 1e-8;\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n; if (!n) break;\n\t\tvector<Point> p(n);\n\t\tvector<double> r(n);\n\t\trep(i, 0, n)\n\t\t\tcin >> p[i].x >> p[i].y >> p[i].z >> r[i];\n\t\tDsu dsu(n);\n\t\tint components = n;\n\t\trep(i, 0, n) rep(j, i + 1, n) {\n\t\t\tdouble dist = (p[i] - p[j]).norm();\n\t\t\tif (dist < r[i] + r[j] + eps) {\n\t\t\t\tif (dsu.merge(i, j)) components--;\n\t\t\t\t//printf(\"Mer %d %d\\n\", i, j);\n\t\t\t} else {\n\t\t\t\t//printf(\"Sep %d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t\tvector<pair<double, pair<int, int>>> edges;\n\t\trep(i, 0, n) rep(j, i + 1, n) if (dsu.find(i) != dsu.find(j)) {\n\t\t\tdouble adddist = (p[i] - p[j]).norm() - r[i] - r[j];\n\t\t\tedges.push_back({ adddist, { i, j } });\n\t\t}\n\t\tsort(all(edges));\n\t\tdouble ans = 0;\n\t\tfor (auto edge : edges) {\n\t\t\tif (components == 1) break;\n\t\t\tint u, v;\n\t\t\ttie(u, v) = edge.second;\n\t\t\tif (dsu.find(u) != dsu.find(v)) {\n\t\t\t\tdsu.merge(u, v);\n\t\t\t\tans += edge.first;\n\t\t\t\tcomponents--;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(3) << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n//#include <cfenv>\n//#define _GNU_SOURCE 1\n#define square(x) ((x)*(x))\nusing namespace std;\nconst double INF = 1000.0;\n\n/*static void attribute((constructor)) trapfpe()\n  {\n  feenableexcept(FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW);\n  }\n */ //何かの痕跡\nint n,a;\ndouble dis[100][101];\ndouble dis2[100][101];\ndouble fdis[100][101];\ndouble touch[100][101];\ndouble geo[100][5];\ndouble mincost[101];\nbool used[101];\nint par[101];\nint rank[101];\n//struct edge{ int to,from,cost; };\nvector<int> set[100],set2[100],fset[100];\n\nvoid init(int n);\nint find(int x);\nvoid unite(int x,int y);\nbool same(int x,int y);\ndouble prim();\n\n\nint main()\n{\n        while(cin >> n,n){\n                init(n);\n\n                for(int i=0;i<n;i++){\n                        //cin >> (double)geo[i][0] >> (double)geo[i][1] >> (double)geo[i][2] >> (double)geo[i][3]; cout << square(geo[i][3]) << endl;\n                        scanf(\"%lf %lf %lf %lf\",&geo[i][0],&geo[i][1],&geo[i][2],&geo[i][3]);\n                }\n                for(int i=0;i<n;i++){\n                        for(int j=0;j<n;j++){\n                                if(i==j)continue;\n                                dis[i][j]  = (double)sqrt((double)square(geo[i][0]-geo[j][0]) + (double)square(geo[i][1]-geo[j][1]) + (double)square(geo[i][2]-geo[j][2]));\n                                touch[i][j] = geo[i][3]+geo[j][3];\n                                dis2[i][j] = dis[i][j] - touch[i][j]; //cout <<dis2[i][j] << endl;\n                                if(touch[i][j]>dis[i][j]) unite(i,j);\n                        }\n                }\n                int p;\n                for(int i=0;i<n;i++){\n                        p = find(i);\n                        set[p].push_back(i);\n                }\n                a = 0;\n                for(int i=0;i<n;i++){\n                        if(set[i].empty()) continue;\n                        set2[a] = set[i];\n                        a++;\n                }\n\n                for(int i=0;i<a;i++){\n                        for(int j=0;j<a;j++){\n                                if(i==j)continue;\n                                double dmin = INF;\n                                for(int k=0;k<set2[i].size();k++){\n                                        for(int l=0;l<set2[j].size();l++){\n                                                dmin = min(dmin,dis2[set2[i][k]][set2[j][l]]);\n                                        }\n                                }\n                                fdis[i][j] = dmin; //cout<< dmin << endl;\n                                dmin = INF;\n                        }\n                }\n\n                printf(\"%.3f\\n\",prim());\n\n                for(int i=0;i<n;i++) set[i].clear();\n                for(int i=0;i<a;i++) set2[i].clear();\n\n        }\n\n}\n\nvoid init(int n)\n{\n        for(int i=0;i<n;i++){\n                par[i] = i;\n                rank[i] = 0;\n        }\n}\n\nint find(int x)\n{\n        if(par[x]==x){\n                return x;\n        }else{\n                return par[x] = find(par[x]);\n        }\n}\n\nvoid unite(int x,int y)\n{\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n\n        if(rank[x]<rank[y]){\n                par[x] = y;\n        }else{\n                par[y] = x;\n                if(rank[x]==rank[y])rank[x]++;\n        }\n}\n\nbool same(int x,int y)\n{\n        return find(x)==find(y);\n}\n\ndouble prim()\n{\n        for(int i=0;i<a;i++){\n                mincost[i] = INF;\n                used[i] = false;\n        }\n\n        mincost[0] = 0;\n        double res = 0.0;\n\n        while(true){\n                int v = -1;\n                for(int i=0;i<a;i++){\n                        if(!used[i] && (v==-1 || mincost[i]<mincost[v])) v = i;\n                }\n\n                if(v == -1) break;\n                used[v] = true;\n                res += mincost[v]; //cout << mincost[v] << ' ' << res << endl;\n\n                for(int i=0;i<a;i++){\n                        mincost[i] = min(mincost[i],fdis[v][i]);\n                }\n        }\n        return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct union_find\n{\n    vector<long long> par;  //親の番号　\n    vector<long long> rank; //木の深さ(根のランクは0)\n    vector<long long> siz;  //要素xが根なら木の頂点数を格納する\n    //初期化子リストを用いた初期化\n    union_find(long long N) : par(N), rank(N), siz(N)\n    {\n        for (long long i = 0; i < N; i++)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    //要素xが所属する木の根を再帰的に発見する\n    long long root(long long x)\n    {\n        if (par[x] == x)\n            return x;\n        return par[x] = root(par[x]); //経路圧縮\n    }\n    //要素xが属する木と要素yが属する木の併合\n    void unite(long long x, long long y)\n    {\n        long long rx = root(x);\n        long long ry = root(y);\n        if (rx == ry)\n            return; //同じ木に属してたらそのまま\n        if (rank[rx] < rank[ry])\n        {\n            par[rx] = ry; //根がryの木に併合\n            siz[ry] = siz[rx] + siz[ry];\n        }\n        else\n        {\n            par[ry] = rx; //根がrxの木に併合\n            siz[rx] = siz[rx] + siz[ry];\n            if (rank[rx] == rank[ry])\n                rank[rx]++;\n        }\n    }\n    //要素xが属する木と要素yが属する木が同じならtrueを返す\n    bool same(long long x, long long y)\n    {\n        return root(x) == root(y);\n    }\n    //要素xが属する木の頂点数を返す\n    long long size(long long x)\n    {\n        return siz[root(x)];\n    }\n};\nstruct kruskal_edge\n{\n    long long u;\n    long long v;\n    double cost;\n};\n//辺のコストの大小を比較\nbool kruskal_comp(const kruskal_edge &e1, const kruskal_edge &e2)\n{\n    return e1.cost < e2.cost;\n}\nvector<kruskal_edge> kruskal_side;\ndouble kruskal(long long V, long long E) //V:頂点数,E:辺数\n{\n    sort(kruskal_side.begin(), kruskal_side.end(), kruskal_comp); //辺のコストが小さい順にソート\n    union_find kruskal_tree(V);\n    double kruskal_res = 0;\n    for (long long i = 0; i < E; i++)\n    {\n        kruskal_edge ks = kruskal_side[i];\n        if (!kruskal_tree.same(ks.u, ks.v))\n        {\n            kruskal_tree.unite(ks.u, ks.v);\n            kruskal_res += ks.cost;\n        }\n    }\n    return kruskal_res;\n}\nint main()\n{\n    cout << fixed << setprecision(3);\n    while (true)\n    {\n        long long n;\n        cin >> n;\n        kruskal_side.resize(n * (n - 1) / 2);\n        if (n == 0)\n            break;\n        vector<double> x(n);\n        vector<double> y(n);\n        vector<double> z(n);\n        vector<double> r(n);\n        for (long long i = 0; i < n; i++)\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        long long now = 0;\n        for (long long i = 0; i < n; i++)\n        {\n            for (long long j = i + 1; j < n; j++)\n            {\n                kruskal_side[now].u = i;\n                kruskal_side[now].v = j;\n                double X = x[i] - x[j], Y = y[i] - y[j], Z = z[i] - z[j], R = r[i] + r[j];\n                kruskal_side[now].cost = max(0.0, (sqrt(X * X + Y * Y + Z * Z) - R));\n                now++;\n            }\n        }\n        cout << kruskal(n, n * (n - 1) / 2) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nstruct edge {\n\tint from, to;\n\tld cost;\n\tedge() {}\n\tedge(int from, int to, ld cost) : from(from), to(to), cost(cost) {}\n};\n\nbool operator<(const edge& l, const edge& r){\n\treturn l.cost < r.cost;\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tvector<int> rank;\n\tint root(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = root(data[a]);\n\t}\npublic:\n\tUnionFind(int n) : data(n, -1), rank(n, 1) {}\n\tbool Find(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tvoid Union(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] < rank[b]) {\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t}\n\t\telse {\n\t\t\tdata[b] += data[a];\n\t\t\tdata[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint Size(int a) {\n\t\treturn -data[root(a)];\n\t}\n\tint Rank(int a) {\n\t\treturn rank[root(a)];\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(3);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<ld> x(n), y(n), z(n), r(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\t}\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tld dx = x[j] - x[i], dy = y[j] - y[i], dz = z[j] - z[i];\n\t\t\t\tes.emplace_back(i, j, max((ld)0, sqrtl(dx * dx + dy * dy + dz * dz) - r[i] - r[j]));\n\t\t\t}\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tld res = 0;\n\t\tUnionFind uf(n);\n\t\tfor (auto e : es) {\n\t\t\tif (uf.Find(e.from, e.to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += e.cost;\n\t\t\tuf.Union(e.from, e.to);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//32\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n\n#define S(X) ((X)*(X))\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[100],y[100],z[100],r[100];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>z[i]>>r[i];\n    }\n    double d[100][100];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\td[i][j]=max(0.,sqrt(S(x[i]-x[j])+S(y[i]-y[j])+S(z[i]-z[j]))-r[i]-r[j]);\n      }\n    }\n    bool u[100]={};\n    double s=0;\n    double e[100];\n    fill(e,e+100,1<<30);\n    e[0]=0;\n    for(int i=0;i<n;i++){\n      int x;\n      double m=1<<30;\n      for(int j=0;j<n;j++){\n\tif(!u[j]&&m>e[j]){\n\t  m=e[j];\n\t  x=j;\n\t}\n      }\n      u[x]=true;\n      s+=e[x];\n      for(int j=0;j<n;j++){\n\tif(!u[j]&&e[j]>d[x][j]){\n\t  e[j]=d[x][j];\n\t}\n      }\n    }\n    cout<<fixed<<setprecision(3)<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\n\nstruct Info{\n\tdouble x,y,z,r;\n};\n\nstruct Data{\n\tData(int arg_to,double arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to;\n\tdouble cost;\n};\n\ndouble calc(Info left,Info right){\n\treturn sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y)+(left.z-right.z)*(left.z-right.z));\n}\n\nint main(){\n\n\tInfo info[100];\n\tvector<Data> V[100];\n\tvector<int> Group;\n\tbool check[100];\n\tdouble ans,dist,tmp_min;\n\tint count,min_index,index;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tV[i].clear();\n\t\t\tcheck[i] = false;\n\t\t}\n\t\tGroup.clear();\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%lf %lf %lf %lf\",&info[i].x,&info[i].y,&info[i].z,&info[i].r);\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tdist = calc(info[i],info[k]);\n\t\t\t\tif(dist <= info[i].r+info[k].r){\n\t\t\t\t\tV[i].push_back(Data(k,0.0));\n\t\t\t\t\tV[k].push_back(Data(i,0.0));\n\t\t\t\t}else{\n\t\t\t\t\tdist -= (info[i].r+info[k].r);\n\t\t\t\t\tV[i].push_back(Data(k,dist));\n\t\t\t\t\tV[k].push_back(Data(i,dist));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0.0;\n\n\t\tcount = 1;\n\n\t\tGroup.push_back(0);\n\t\tcheck[0] = true;\n\n\t\twhile(count < N){\n\n\t\t\ttmp_min = DBL_MAX;\n\n\t\t\tfor(int i = 0; i < Group.size(); i++){\n\t\t\t\tindex = Group[i];\n\t\t\t\tfor(int k = 0; k < V[index].size(); k++){\n\t\t\t\t\tif(check[V[index][k].to] == false && tmp_min > V[index][k].cost){\n\t\t\t\t\t\tmin_index = V[index][k].to;\n\t\t\t\t\t\ttmp_min = V[index][k].cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += tmp_min;\n\t\t\tcheck[min_index] = true;\n\t\t\tGroup.push_back(min_index);\n\t\t\tcount++;\n\t\t}\n\n\t\tprintf(\"%.3lf\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_V = 100;\nconst double INF = 100000000;\n\nclass Cell{\npublic:\n  double x, y, z, r;\n  Cell(double x = 0.0, double y = 0.0, double z = 0.0, double r = 0.0)\n    : x(x), y(y), z(z), r(r) {}\n  double dist(Cell p){\n    return sqrt((x-p.x) * (x-p.x) + (y-p.y) * (y-p.y) + (z-p.z) * (z-p.z));\n  }\n};\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;\nCell data[MAX_V];\n\n\ndouble prim(){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  double res = 0;\n  while(1){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u=0;u<V;u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nvoid makeEdge(){\n  for(int i=0;i<V;i++) cost[i][i] = 0.0;\n  for(int i=0;i<V;i++){\n    for(int j=i+1;j<V;j++){\n      double dist = data[i].dist(data[j]) - data[i].r - data[j].r;\n      if(dist < 0.0) dist = 0.0;\n      cost[i][j] = cost[j][i] = dist;\n    }\n  }\n}\n\nmain(){\n  while(cin >> V && V){\n    for(int i=0;i<V;i++){\n      cin >> data[i].x >> data[i].y >> data[i].z >> data[i].r;\n    }\n    makeEdge();\n    printf(\"%.3f\\n\", prim());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<0)x=0;\n\t\t\tcout<<x<<endl;\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m;m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\ndouble x[100],y[100],z[100],r[100];\nvector<pair<double,pa>> ve;\n\ndouble bi(double r){\n\treturn r*r;\n}\ndouble dis(int i,int j){\n\tdouble d=sqrt(bi(x[i]-x[j])+bi(y[i]-y[j])+bi(z[i]-z[j]));\n\tdouble r1=abs(r[i]-r[j]);\n\tdouble r2=r[i]+r[j];\n\tif(r2<d) return d-r2;\n\tif(r1<d) return 0;\n\t//return r1-d;\n\treturn 0;\n}\n\nvoid solve(){\n\tint n;\n\tcin>>n;\n\tif(n==0) exit(0);\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\tve.clear();\n\tshoki(110);\n\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t//\tcout<<i<<\" \"<<j<<\" \"<<dis(i,j)<<endl;\n\t\t\t\tve.pb({dis(i,j),{i,j}});\n\t}\n\tsort(ve.begin(),ve.end());\n\tdouble ans=0;\n\tfor(auto v:ve){\n\t\tif(same(v.second.first,v.second.second))continue;\n\t\tunite(v.second.first,v.second.second);\n\t\tans+=v.first;\n\t}\n\tprintf(\"%.3lf\\n\",ans);\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n \twhile(1)solve();\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nstruct Cell {\n\tdouble x, y, z, r;\n};\n\nstruct Edge {\n\tint to;\n\tdouble distance;\n\tbool operator <(const Edge &a) const {\n\t\treturn distance > a.distance;\n\t}\n};\n\nCell cells[101];\nbool visited[101];\ndouble distances[101][101];\n\nint main() {\n\tint n;\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cells[i].x >> cells[i].y >> cells[i].z >> cells[i].r;\n\t\t\tvisited[i] = false;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdistances[i][j] = distances[j][i]\n\t\t\t\t\t= max(0.0,\n\t\t\t\t\t\tsqrt(pow(cells[i].x - cells[j].x, 2) + pow(cells[i].y - cells[j].y, 2)\n\t\t\t\t\t\t+ pow(cells[i].z - cells[j].z, 2))\n\t\t\t\t\t\t- cells[i].r - cells[j].r\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<Edge> pq;\n\t\tint current_vertex = 0;\n\t\tdouble length = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tvisited[current_vertex] = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif(!visited[j]) {\n\t\t\t\t\tEdge e;\n\t\t\t\t\te.to = j;\n\t\t\t\t\te.distance = distances[i][j];\n\t\t\t\t\tpq.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()) {\n\t\t\t\tEdge e = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(!visited[e.to]) {\n\t\t\t\t\tcurrent_vertex = e.to;\n\t\t\t\t\tlength += e.distance;\n\t\t\t\t\t//cout << \"goto:\" << e.to << \", dist:\" << e.distance << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%1.3f\\n\", length);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef pair<double, int> P;\n\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\nvector<P> edge[101];\n\ndouble sq(double x)\n{\n    return x * x;\n}\n\ndouble dis(int i, int j)\n{\n    double d = sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n    return max(0.0, d - r[i] - r[j]);\n}\n\nint main()\n{\n    int n;\n    double res;\n\n    while(cin >> n && n)\n    {\n        res = 0.0;\n        for (int i = 0; i < n; ++i) {\n            edge[i].clear();\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n            for (int j = 0; j < i; ++j) {\n                double d = dis(i, j);\n                edge[i].push_back(P(d, j));\n                edge[j].push_back(P(d, i));\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> h;\n        fill_n(used, n, false);\n        h.push(P(0.0, 0));\n        for (int i = 0; i < n; ++i) {\n            P p = h.top(); h.pop();\n            int v = p.second;\n            res += p.first;\n            used[v] = true;\n            for (size_t j = 0; j < edge[v].size(); ++j)\n                if (! used[edge[v][j].second])\n                    h.push(edge[v][j]);\n        }\n        cout << fixed << setprecision(3) << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to; double cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint V;\nvector<vector<edge>> es;\nbool used[10000];\n\npair<double, vector<edge>> prim() \n{\n\tmemset(used, false, sizeof(used));\n\tvector<edge> res;\n\tdouble sum = 0;\n\n\tpriority_queue<edge, vector<edge>, greater<edge>> que;\n\tque.push(edge{ -1, 0, 0 });\n\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tif (used[e.to]) continue;\n\t\tif (e.from >= 0) res.push_back(e);\n\t\tsum += e.cost;\n\t\tused[e.to] = true;\n\t\tfor (edge i : es[e.to])\n\t\t{\n\t\t\tif (!used[i.to]) que.push(i);\n\t\t}\n\t}\n\treturn pair<double, vector<edge>>(sum, res);\n}\n\nstruct cell{ double x, y, z, r; };\n\nint main()\n{\n\twhile (cin >> V, V)\n\t{\n\t\tes.clear();\n\t\tes.resize(V);\n\t\tvector<cell> cells;\n\t\tREP(i, V)\n\t\t{\n\t\t\tdouble x, y, z, r;\n\t\t\tcin >> x >> y >> z >> r;\n\t\t\tcells.push_back(cell{ x, y, z, r });\n\t\t}\n\t\tREP(i, V)REP(j, V)\n\t\t{\n\t\t\tcell c1 = cells[i], c2 = cells[j];\n\t\t\tdouble d = sqrt(pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2) + pow(c1.z - c2.z, 2));\n\t\t\td -= c1.r + c2.r;\n\t\t\tif (d <= 0) d = 0;\n\t\t\tes[i].push_back(edge{ i, j, d });\n\t\t}\n\t\tcout << D10 << prim().first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct edge {\n  int p, q;\n  double d;\n  bool operator<(const edge &e) const { return d < e.d; }\n};\n\nint N;\ndouble X[100], Y[100], Z[100], R[100];\n\ndouble dist(int i, int j) {\n  double dx = X[i] - X[j];\n  double dy = Y[i] - Y[j];\n  double dz = Z[i] - Z[j];\n  return max(sqrt(dx * dx + dy * dy + dz * dz) - R[i] - R[j], 0.0);\n}\n\nint find(int *a, int i) { return a[i] == i ? i : (a[i] = find(a, a[i])); }\nvoid unite(int *a, int i, int j) { if(find(a, i) != find(a, j)) a[find(a, i)] = find(a, j); }\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> Z[i] >> R[i];\n\n    vector<edge> e;\n    REP(i, 0, N) REP(j, i + 1, N) e.push_back((edge) { i, j, dist(i, j) });\n    sort(e.begin(), e.end());\n\n    double ans = 0.0;\n    int g[100];\n    REP(i, 0, N) g[i] = i;\n    REP(i, 0, e.size()) if(find(g, e[i].p) != find(g, e[i].q)) {\n      ans += e[i].d;\n      unite(g, e[i].p, e[i].q);\n    }\n    printf(\"%.3lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <float.h>\n#include <math.h>\n#include <stdio.h>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntypedef struct {\n  float x,y,z,r;\n} Cell;\n\nint main(void)\n{\n  while (1) {\n    int n,i;\n    Cell v[100];\n    int vlen=0;\n    float G [100][100];\n    for (int i=0;i<100;++i)\n      for(int j=0;j<100;++j)\n\tG[i][j]=FLT_MAX;\n     \n    scanf(\"%d\",&n);\n    if( n==0 )\n      break;\n   \n    for(i=0;i<n;++i){ \n      float x,y,z,r;\n      scanf(\"%f %f %f %f\",&x,&y,&z,&r);\n      for(int j=0; j<vlen; ++j){\n\tfloat dx = x - v[j].x;\n\tfloat dy = y - v[j].y;\n\tfloat dz = z - v[j].z;\n\tfloat d = sqrt(dx*dx + dy*dy + dz*dz) - (v[j].r + r);\n\tif (d<=0){\n\t  G[i][j] = 0.0;\n\t  G[j][i] = 0.0;\n\t} else {\n\t  G[i][j] = d;\n\t  G[j][i] = d;\n\t}\t\n      }\n\n      Cell const c = { x, y, z, r };\n      v[vlen] = c;\n      ++vlen;\n    }\n    float sum = 0.0;\n    float d[100];\n    bool visited[100];\n    std::fill( d, d+100, FLT_MAX );\n    std::fill( visited, visited+100, false );\n\n    //initialize\n    int u = 0;\n    d[0] = 0;\n\n    for( int i=0; i<n; ++i ) {\n      float tmp = FLT_MAX;\n      for( int j=0; j<n; ++j ) {\n\tif ( !visited[j] && d[j] < tmp ) {\n\t  tmp = d[j];\n\t  u = j;\n\t}\n      }\n      sum += d[u];\n      visited[u] = true;\n\n      for(int j=0; j<n; ++j ) {\n\tif ( !visited[j] && G[u][j] < d[j] ) {\n\t  d[j] = G[u][j];\n\t}\n      }\n    }\n    printf( \"%.3lf\\n\", sum );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <cmath>\n#include <numeric>\n#include <iomanip>\n\nusing namespace std;\nint par[100000];\nint height[100000];\nint card[100000];\nvoid init(int n){\n  for(int i = 0; i < n; i++){\n    par[i] = i;\n    height[i] = 0;\n    card[i] = 1;\n  }\n}\n\nint root(int x){\n  if(x == par[x]){\n    return x;\n  } else {\n    par[x] = root(par[x]);\n    return par[x];\n  }\n}\n\nbool same(int x, int y){\n  return root(x) == root(y);\n}\n\nvoid unite(int x, int y){\n  //rankの値はrootだけが正しく持っている\n  x = root(x);\n  y = root(y);\n  if(x == y){\n    return;\n  }\n  if(height[x] > height[y]){\n    par[y] = x;\n    card[x] += card[y];\n  } else {\n    par[x] = y;\n    card[y] += card[x];\n    if(height[x] == height[y]){\n      height[x] ++;\n    }\n  }\n}\n\ndouble x[100];\ndouble y[100];\ndouble z[100];\ndouble r[100];\npair <double, pair<int, int> > edges[100000];\n\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2){\n  return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));\n}\nint main(void){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){\n      break;\n    }\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n\n    init(n);\n    int edge_no = 0;\n    for(int i = 0; i < n - 1; i++){\n      for(int j = i + 1; j < n; j++){\n        double cur_dst = dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j];\n        if(cur_dst > 0){\n          edges[edge_no] = make_pair(cur_dst, make_pair(i, j));\n          edge_no++;\n        } else {\n          if(!same(i, j)){\n            unite(i, j);\n          }\n        }\n      }\n    }\n\n    sort(edges, edges + edge_no);\n    double ans = 0;\n    for(int i = 0; i < edge_no; i++){\n      if(!same(edges[i].second.first, edges[i].second.second)){\n        ans += edges[i].first;\n        unite(edges[i].second.first, edges[i].second.second);\n      }\n    }\n    cout << setprecision(3) << fixed << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define SQ(x) ((x) * (x))\n\nusing namespace std;\n\nint par[128];\n\nint find(int x)\n{\n    return (par[x] >= 0 ? par[x] = find(par[x]) : x);\n}\n\nvoid merge(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (-par[x] < -par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n\nbool same(int x, int y)\n{\n\treturn (find(x) == find(y));\n}\n\nint main()\n{\n\tint n;\n\n\twhile (scanf(\"%d\", &n) && n){\n\t\tdouble x[128], y[128], z[128], r[128];\n\n\t\tvector<pair<double, pair<int, int> > > edges;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &z[i], &r[i]);\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tedges.push_back(make_pair(max(0.0, sqrt(SQ(x[i] - x[j]) + SQ(y[i] - y[j]) + SQ(z[i] - z[j])) - r[i] - r[j]), make_pair(i, j)));\n\t\t\t}\n\t\t}\n\n\t\tsort(edges.begin(), edges.end());\n\n\t\tmemset(par, -1, sizeof(par));\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < edges.size(); i++){\n\t\t\tif (!same(edges[i].second.first, edges[i].second.second)){\n\t\t\t\tans += edges[i].first;\n\t\t\t\tmerge(edges[i].second.first, edges[i].second.second);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\nint n;double ans=0;scanf(\"%d\",&n);double xi,yi,zi,ri,xj,yj,zj,rj;double x,y,z,r;\nvector<tuple<double,double,double,double>> sta(101);vector<vector<double>> dis(101,vector<double>(101,0));vector<bool> check(101,false);\npriority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>> que;\nwhile(n!=0)\n{\nans=0;\nfor(int i=0;i<n;i++)check[i]=false;\nfor(int i=0;i<n;i++)\n{\nscanf(\"%lf %lf %lf %lf\",&x,&y,&z,&r);\nsta[i]=make_tuple(x,y,z,r);\n}\nfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++)\n{\nxi=get<0>(sta[i]);yi=get<1>(sta[i]);zi=get<2>(sta[i]);ri=get<3>(sta[i]);xj=get<0>(sta[j]);yj=get<1>(sta[j]);zj=get<2>(sta[j]);rj=get<3>(sta[j]);\ndis[i][j]=pow((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj)+(zi-zj)*(zi-zj),0.5)-ri-rj;dis[j][i]=dis[i][j];\n}\nque.push(make_pair(0,0));\nwhile(!que.empty())\n{\npair<double,int> p=que.top();que.pop();\nif(check[p.second])continue;\ncheck[p.second]=true;if(p.first>0)ans+=p.first;\nfor(int i=0;i<n;i++){if(i==p.second)continue;que.push(make_pair(dis[p.second][i],i));}\n}\nprintf(\"%0.3f\\n\",ans);\nscanf(\"%d\",&n);\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int MAX_N = 100;\nstruct Station {\n\tdouble x, y, z, r;\n};\n\nint n;\nStation stations[MAX_N + 1];\nbool used[MAX_N];\n\ndouble getdist(int A, int B) {\n\tconst Station& a = stations[A];\n\tconst Station& b = stations[B];\n\tdouble dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;\n\tdouble d = sqrt(dx * dx + dy * dy + dz * dz);\n\treturn max(d - (a.r + b.r), 0.);\n}\n\ndouble prim() {\n\ttypedef pair<double, int> Node;\n\t\n\tdouble result = 0;\n\tpriority_queue<Node, vector<Node>, greater<Node> > que;\n\tfill(used, used + n, false);\n\tque.push(make_pair(0., 0));\n\twhile (!que.empty()) {\n\t\tNode current = que.top();\n\t\tque.pop();\n\t\tdouble dist = current.first;\n\t\tint pos = current.second;\n\t\tif (used[pos]) continue;\n\t\tused[pos] = true;\n\t\tresult += dist;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == pos || used[i]) continue;\n\t\t\tque.push(make_pair(getdist(pos, i), i));\n\t\t}\n\t}\n\treturn result;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> stations[i].x >> stations[i].y >> stations[i].z >> stations[i].r;\n\t\t}\n\t\tprintf(\"%.3lf\\n\", prim());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nstruct Edge {\n  int to;\n  double cost;\n  Edge() {}\n  Edge(int to, double cost) : to(to), cost(cost) {}\n};\n\nconst int MAX_N = 101;\nint N;\ndouble X[MAX_N], Y[MAX_N], Z[MAX_N], R[MAX_N];\nvector<Edge> E[MAX_N];\n\ndouble abs(double x, double y, double z) {\n  return sqrt(x*x+y*y+z*z);\n}\n\nvoid makeE() {\n  for(int i = 0; i < MAX_N; ++i) E[i].clear();\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      double cost = max(0.0,\n\t\t\tabs(X[i]-X[j],Y[i]-Y[j],Z[i]-Z[j]) - (R[i]+R[j]));\n      E[i].push_back(Edge(j,cost)); \n    }\n  }\n}\n  \ndouble prim() {\n  priority_queue<pair<double,int> > que;\n  bool vis[MAX_N];\n  fill(vis,vis+MAX_N,false);\n  que.push(make_pair(0.0,0));\n  double sum = 0;\n  while(!que.empty()) {\n    double cost = que.top().first;\n    int p = que.top().second;\n    que.pop();\n    if(vis[p]) continue;\n    vis[p] = true;\n    sum += -cost;\n    for(int i = 0; i < E[p].size(); ++i) {\n      Edge &e = E[p][i];\n      if(vis[e.to]) continue;\n      que.push(make_pair(-e.cost,e.to));\n    }\n  }\n  return sum;\n}\n\ndouble solve() {\n  makeE();\n  return prim();\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      scanf(\"%lf%lf%lf%lf\",&X[i],&Y[i],&Z[i],&R[i]);\n    }\n    printf(\"%.3f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <float.h>\n#include <math.h>\n#include <stdio.h>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntypedef struct {\n  float x,y,z,r;\n} Cell;\n\nint main(void)\n{\n  while (1) {\n    int n,i;\n    Cell v[100];\n    int vlen=0;\n    float G [100][100];\n    for (int i=0;i<100;++i)\n      for(int j=0;j<100;++j)\n\tG[i][j]=FLT_MAX;\n     \n    scanf(\"%d\",&n);\n    if( n==0 )\n      break;\n   \n    for(i=0;i<n;++i){ \n      float x,y,z,r;\n      scanf(\"%f %f %f %f\",&x,&y,&z,&r);\n      for(int j=0; j<vlen; ++j){\n\tfloat dx = x - v[j].x;\n\tfloat dy = y - v[j].y;\n\tfloat dz = z - v[j].z;\n\tfloat d = sqrt(dx*dx + dy*dy + dz*dz) - (v[j].r + r);\n\tif (d<=0){\n\t  G[i][j] = 0.0;\n\t  G[j][i] = 0.0;\n\t} else {\n\t  G[i][j] = d;\n\t  G[j][i] = d;\n\t}\t\n      }\n\n      Cell const c = { x, y, z, r };\n      v[vlen] = c;\n      ++vlen;\n    }\n    float sum = 0.0;\n    float d[100];\n    bool visited[100];\n    std::fill( d, d+100, FLT_MAX );\n    std::fill( visited, visited+100, false );\n\n    //initialize\n    int u = 0;\n    d[0] = 0;\n\n    for( int i=0; i<n; ++i ) {\n      float tmp = FLT_MAX;\n      for( int j=0; j<n; ++j ) {\n\tif ( !visited[j] && d[j] < tmp ) {\n\t  tmp = d[j];\n\t  u = j;\n\t}\n      }\n      sum += d[u];\n      visited[u] = true;\n\n      for(int j=0; j<n; ++j ) {\n\tif ( !visited[j] && G[u][j] < d[j] ) {\n\t  d[j] = G[u][j];\n\t}\n      }\n    }\n    printf( \"%.3lf\\n\", sum );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to;\n    T cost;\n\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n    explicit operator int() const {return to;}\n};\n\nclass UnionFind {\n    vector<int> uni;\n    int n;\npublic:\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n};\n\ntemplate< typename T >\nT kruskal(vector<edge<T>> &G, int V)\n{\n    sort(begin(G), end(G), [](const edge<T> &a, const edge<T> &b) { return (a.cost < b.cost); });\n    UnionFind uf(V);\n    T ret = 0;\n    for(auto &e : G) {\n        if(uf.unite(e.from, e.to)) ret += e.cost;\n    }\n    return ret;\n}\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z -= a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<pair<Point3, double>> v(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> v[i].first.x >> v[i].first.y >> v[i].first.z >> v[i].second;\n        }\n        vector<edge<double>> G;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                G.emplace_back(i, j, max(0.0, abs(v[i].first-v[j].first)-v[i].second-v[j].second));\n            }\n        }\n        printf(\"%.3f\\n\", kruskal(G, n));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// i, j の距離を求める\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = 0;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // ２つのセル間の距離を算出\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Target更新\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break; // 終了判定\n\n      visited[t] = 1;\n      res += d[t];\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    \n    printf(\"%lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nusing usize = ::std::size_t;\n//using u64 = ::std::int_least64_t;\nusing u64 = double;\nstatic constexpr u64 Inf = ::std::numeric_limits<u64>::max() / 2;\n\nstruct edge\n{\n    int v;\n    u64 weight;\n    edge (int v = 0, u64 weight = 0): v(v), weight(weight) {}\n    bool operator<(const edge &e) const { return weight > e.weight; }\n};\nconst int MAXV = 10010;\nvector<vector<edge>> edges;\nu64 distToTree[MAXV];\nint n, parent[MAXV], intree[MAXV];\n\nu64 prim(int u)\n{\n    u64 minSumOfWeight = 0;\n\n    for (int i = 1; i <= n; i++)\n        parent[i] = -1, intree[i] = 0, distToTree[i] = Inf;\n\n    priority_queue<edge> q;\n    q.push(edge(u, 0));\n\n    while (!q.empty()) {\n        edge e1 = q.top();\n        q.pop();\n        if (intree[e1.v]) continue;\n        intree[e1.v] = 1, minSumOfWeight += e1.weight;\n        for (auto e2 : edges[e1.v])\n            if (!intree[e2.v] && distToTree[e2.v] > e2.weight) {\n                distToTree[e2.v] = e2.weight;\n                parent[e2.v] = e1.v;\n                q.push(edge(e2.v, e2.weight));\n            }\n    }\n\n    return minSumOfWeight;\n}\n\nstruct circle {\n    u64 x, y, z, r;\n    circle operator-(const circle &c) const {return circle{x - c.x, y - c.y, z - c.z, r + c.r};}\n} cells[MAXV];\n\nint main(int argc, char *argv[])\n{\n    \n \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cout.setf(ios::fixed);\n    cout.precision(3);\n    while (cin >> n, n != 0) {\n        for (int i = 1; i <= n; i++) {\n            cin >> cells[i].x >> cells[i].y >> cells[i].z >> cells[i].r;\n        }\n        edges.resize(n + 1);\n        for (int u = 1; u <= n; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                circle delta = cells[u] - cells[v];\n                u64 dcent = pow(delta.x, 2) + pow(delta.y, 2) + pow(delta.z, 2);\n                u64 distance = sqrt(dcent) - delta.r;\n                distance = distance > 0.0001 ? distance : 0.000;\n                edges[u].push_back(edge{v, distance});\n                edges[v].push_back(edge{u, distance});\n            }\n        }\n    cout  << prim(1) << endl;\n    edges.clear();\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int rank[MAX_N];\n  int s[MAX_N];\n  bool used[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y; s[y] = s[x] + s[y];\n    } else {\n      par[y] = x; s[x] = s[x] + s[y];\n      if( rank[x] == rank[y] ) rank[x]++;\n    }\n  }\n  int size(int x) { return s[find(x)];}\n  bool same(int x, int y) { return find(x) == find(y);}\n  int group(int n) {\n    REP(i, n) used[find(i)] = true;\n    int ret = 0;\n    REP(i, n) if(used[i]) ret++;\n    return ret;\n  }\n};\nUnionFind uf;\n\ndouble x[105], y[105], z[105], r[105];\nvector<pair<double, PII>> e;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n    e.clear();\n    int m = 0;\n    REP(i, n) FOR(j, i+1, n) {\n      double d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j])) - r[i] - r[j];\n      if(d < 0) d = 0;\n      e.PB({d, {i, j}});\n      m++;\n    }\n    sort(ALL(e));\n\n    double ret = 0;\n    REP(i, m) {\n      if(!uf.same(e[i].second.first, e[i].second.second)) {\n        ret += e[i].first;\n        uf.unite(e[i].second.first, e[i].second.second);\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nclass DisjointSet{\n  public:\n    vector<int> rank, p;\n\n    DisjointSet(){}\n    DisjointSet(int size){\n        rank.resize(size, 0);\n        p.resize(size, 0);\n        for(int i = 0; i < size; i++) makeSet(i);\n    }\n\n    void makeSet(int x){\n        p[x] = x;\n        rank[x] = 0;\n    }\n\n    bool same(int x, int y){\n        return findSet(x) == findSet(y);\n    }\n    \n    void unite(int x, int y){\n        link(findSet(x), findSet(y));\n    }\n\n    void link(int x, int y){\n        if(rank[x] > rank[y]){\n            p[y] = x;\n        }else{\n            p[x] = y;\n            if(rank[x] == rank[y]){\n                rank[y]++;\n            }\n        }\n    }\n\n    int findSet(int x){\n        if(x != p[x]){\n            // path compression\n            p[x] = findSet(p[x]);\n        }\n        return p[x];\n    }\n};\n\n#define N 100\ndouble x[N], y[N], z[N], r[N];\n\nstruct Edge{\n    int from, to;\n    double dist;\n    Edge() {}\n    Edge(int f, int t, double d) : from(f), to(t), dist(d) {}\n    bool operator<(const Edge other) const{\n        return dist < other.dist;\n    }\n};\n\ndouble getDist(int i, int j){\n    return sqrt(pow(x[j]-x[i], 2.0) + pow(y[j]-y[i], 2.0) + pow(z[j]-z[i], 2.0));\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n\n        DisjointSet uf(n);\n        vector<Edge> res;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                double d = getDist(i,j);\n                if(d > r[i]+r[j])    res.push_back(Edge(i,j,d-r[i]-r[j]));\n                else                 uf.unite(i,j);\n            }\n        }\n\n        sort(res.begin(), res.end());\n\n        double ans = 0;\n        for(int i = 0; i < res.size(); i++){\n            if(!uf.same(res[i].from, res[i].to)){\n                uf.unite(res[i].from, res[i].to);\n                ans += res[i].dist;\n            }\n        }\n\n        cout << fixed << setprecision(3) << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ndouble x[110];\ndouble y[110];\ndouble z[110];\ndouble r[110];\n\nint par[110];\nvoid init(){for(int i=0;i<110;++i)par[i]=i;}\nint find(int x){return (par[x]==x)?x:find(par[x]);}\nvoid unite(int a,int b){a=find(a),b=find(b),par[b]=a;}\nbool same(int a,int b){return find(a)==find(b);}\n\ninline double dist(int a,int b){\n\tdouble d=0;\n\td+=(x[a]-x[b])*(x[a]-x[b]);\n\td+=(y[a]-y[b])*(y[a]-y[b]);\n\td+=(z[a]-z[b])*(z[a]-z[b]);\n\treturn max(0.0,sqrt(d)-r[a]-r[b]);\n}\n\ntypedef tuple<double,int,int> state;\n\nint main(void){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\trep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tinit();\n\t\tdouble ans=0.0;\n\t\tvector<state> edge;\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i>=j)\n\t\t\t\tcontinue;\n\t\t\tdouble d=dist(i,j);\n\t\t\tedge.pb(make_tuple(d,i,j));\n\t\t}\n\t\tsort(edge.begin(),edge.end());\n\t\trep(i,edge.size()){\n\t\t\tdouble d;\n\t\t\tint a,b;\n\t\t\ttie(d,a,b)=edge[i];\n\t\t\tif(same(a,b))\n\t\t\t\tcontinue;\n\t\t\tans+=d;\n\t\t\tunite(a,b);\n\t\t}\n\t\tcout.precision(3);\n\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<0)x=0;\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m;m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n      visited[t] = 1;\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = -1;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j) continue;\n\n\tmap[i][j] = compute(i, j);\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      res += d[t];\n      //if (p[t] != -1) res += map[t][p[t]];\n      //printf(\"res: %.3lf\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    printf(\"%.3lf\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nstruct UF{\n\tvector<int> par;\n\tint n;\n\tUF(int size){\n\t\tn = size;\n\t\tpar = vector<int>(n);\n\t\trep(i, n) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tpar[find(x)] = find(y);\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main(){\n\tauto sq = [](double x){return x*x; };\n\n\tcout.setf(ios::fixed);\n\tcout.precision(3);\n\n\tint n;\n\twhile (cin >> n, n){\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n\t\tvector<tuple<double, int, int>> edge;\n\t\trep(i, n) rep(j, i){\n\t\t\tdouble len = sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n\t\t\tlen -= r[i] + r[j];\n\t\t\tlen = max(len, 0.);\n\t\t\tedge.push_back(MT(len, i, j));\n\t\t}\n\t\tsort(ALL(edge));\n\n\t\tUF uf(n);\n\n\t\tdouble ans = 0;\n\t\tfor (auto e : edge){\n\t\t\tdouble cost;\n\t\t\tint s, t;\n\t\t\ttie(cost, s, t) = e;\n\t\t\tif (uf.same(s, t)) continue;\n\t\t\tuf.unite(s, t);\n\t\t\tans += cost;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst double EPS = 1e-10;\n\nstruct P {\n    double x, y, z;\n    P(){}\n    P(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n    const P operator+ (const P& p) {\n        return P(this->x + p.x, this->y + p.y , this->z + p.z);\n    }\n    const P operator- (const P &p) {\n        return P(this->x - p.x, this->y - p.y , this->z - p.z);\n    }\n    void print() {\n        printf(\"%.1f %.1f %.1f\\n\", x, y, z);\n    }\n};\n\nstruct C {\n    P c;\n    double r;\n    C(){}\n    C(P _c, double _r) : c(_c), r(_r) {}\n    C(double _x, double _y, double _z, double _r) : C(P(_x, _y, _z), _r) {}\n};\n\ndouble distancePP(P p, P q) {\n    return sqrt((p.x - q.x) * (p.x - q.x)\n            + (p.y - q.y) * (p.y - q.y)\n            + (p.z - q.z) * (p.z - q.z));\n}\n\ndouble distanceCC(C c1, C c2) {\n    return max(0., distancePP(c1.c, c2.c) - c1.r - c2.r);\n}\n\nC readC() {\n    double x, y, z, r;\n    cin >> x >> y >> z >> r;\n    return C(P(x, y, z), r);\n}\n\nclass UnionFind {\nprivate:\n    int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) {\n        n = _n;\n        uni.clear();\n        uni.resize(n, -1);\n    }\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\ntemplate <typename T>\nstruct edge {\n    int from, to;\n    T cost;\n    edge(){}\n    edge(int _from, int _to, T _cost) : from(_from), to(_to), cost(_cost) {}\n    bool operator< (const edge& e) const {\n        return cost == e.cost ? (from == e.from ? to < e.to : from < e.from) : cost < e.cost;\n    }\n};\n\ntemplate <typename T>\nclass Kruskal {\nprivate:\n    int n;\n    vector<edge<T>> edges;\n    UnionFind uf;\npublic:\n    Kruskal(int _n) : n(_n), uf(UnionFind(n)) {}\n    void addEdge(int _from, int _to, T _cost) {\n        edges.emplace_back(_from, _to, _cost);\n    }\n    T calc() {\n        sort(all(edges));\n        T res = 0;\n        for (auto &e : edges) {\n            if (!uf.same(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n        return res;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<C> circles;\n        rep(i, n) {\n            circles.emplace_back(readC());\n        }\n\n        Kruskal<double> kr(n);\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                kr.addEdge(i, j, distanceCC(circles[i], circles[j]));\n            }\n        }\n        printf(\"%.3f\\n\", kr.calc());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n\n  UnionFind(int n) : par(n), rank(n, 1) {\n    for(int i=0; i<n; ++i) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) swap(x, y);\n    par[y] = x;\n    rank[x] += rank[y];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n};\n\ntypedef double Cost;\n\nstruct edge{\n    int src, dst; Cost cost;\n    edge(int s, int t, Cost c) : src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost < rhs.cost;}\n};\n\nCost kruskal(int V, vector<edge> &edges) {\n    UnionFind uf(V);\n    sort(edges.begin(), edges.end());\n    Cost ans = 0;\n    for(auto e : edges) {\n        if(!uf.same(e.src, e.dst)) {\n            uf.unite(e.src, e.dst);\n            ans += e.cost;\n        }\n    }\n    return ans;\n}\n\nint main(void) {\n    int n;\n    while(cin >> n && n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        vector<edge> edges;\n        REP(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(i, n)  {\n            REP(j, n) {\n                if(i == j) continue;\n                double c = sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j];\n                edges.push_back(edge(i, j, max(0.0, c)));\n            }\n        }\n        printf(\"%.3f\\n\", kruskal(n, edges));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127\n*/\n\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int,int>;\n\nstruct UnionFind{\n    vector<int> parent;\n    vector<int> rank;\n    UnionFind(int n):rank(n+1,0),parent(n+1){\n        rep(i,n+1) parent[i]=i;\n    }\n\n    int find(int x){\n        if (parent[x] == x) return x;\n        else return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x==y) return;\n        else if(rank[x]<rank[y]) parent[x]=y;\n        else{\n            parent[y]=x;\n            if (rank[x]==rank[y]){\n                rank[x]+=1;\n            }\n        }\n    }\n};\n\nint main(){\n    vector<double> ans;\n    while(1){\n    int n;\n    cin >> n;\n    if(n==0) break;\n\n    vector<double> x,y,z,r;\n    vector<pair<double,P>> edge;\n    rep(i,n){\n        ld xx,yy,zz,rr;\n        cin >> xx >> yy >> zz >>rr;\n        x.push_back(xx);\n        y.push_back(yy);\n        z.push_back(zz);\n        r.push_back(rr);\n    }\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1; j<n; ++j){\n            ld dist;\n            dist = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n            dist = sqrt(dist);\n            dist = dist-r[i]-r[j];\n            if(dist<=0.000) uf.unite(i,j);\n            else{\n                pair<double,P> p;\n                p.first = dist;\n                p.second.first = i;\n                p.second.second = j;\n                edge.push_back(p);\n            }\n        }\n    }\n    sort(edge.begin(),edge.end());\n\n    double res = 0.000;\n    rep(i,edge.size()){\n        int p,q;\n        p = edge[i].second.first; q = edge[i].second.second;\n        //cout << \"edge \" << i << \" \"<<p<<\":\"<<q<<\" \";\n        //printf(\"%.3f\\n\",edge[i].first);\n        if(uf.find(p)!=uf.find(q)){\n            res += edge[i].first;\n            uf.unite(p,q);\n        }\n    }\n\n    ans.push_back(res);\n    }\n    for(auto a:ans) printf(\"%.3f\\n\",a);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst double INF = 1000000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\t//if(i==j)\n\t\t\t\t//\tcontinue;\n\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\t//break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\t\t//if(cost[i][j]<0)\n\t\t\t\t\t//\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.3f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n;\nconst int maxn = 105;\nint pre[maxn];\nstruct side\n{\n    int v1;\n    int v2;\n    double len;\n    side(int vv1 = 0, int vv2 = 0, double ll = 0) :v1(vv1), v2(vv2), len(ll)\n    {\n    }\n    friend bool operator <(const side&a, const side&b)\n    {\n        return a.len > b.len;\n    }\n};\nvector<side>minHeap;\nint Find(int x)\n{\n    int r = x;\n    while (r != pre[r])\n    {\n        r = pre[r];\n    }\n    int c = x, p;\n    while (c != r)\n    {\n        p = pre[c];\n        pre[c] = r;\n        c = p;\n    }\n    return r;\n}\nvoid Join(int x, int y)\n{\n    int f1 = Find(x), f2 = Find(y);\n    if (f1 != f2) pre[f1] = f2;\n}\ndouble Kruskal()\n{\n    side tmp;\n    int cnt = 1;\n    for (int i = 0; i <= n; i++)pre[i] = i;\n    double ans = 0;\n    while (cnt < n)\n    {\n        pop_heap(minHeap.begin(), minHeap.end());\n        tmp = minHeap.back();\n        minHeap.pop_back();\n        int u = Find(tmp.v1);\n        int v = Find(tmp.v2);\n        if (u != v)\n        {\n            Join(tmp.v1, tmp.v2);\n            ans += tmp.len;\n            cnt++;\n        }\n    }\n    return ans;\n}\nstruct node\n{\n    double x;\n    double y;\n    double z;\n    double r;\n}points[maxn];\nint main()\n{\n    while (~scanf(\"%d\", &n))\n    {\n        if (n == 0)break;\n        minHeap.clear();\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%lf%lf%lf%lf\", &points[i].x, &points[i].y, &points[i].z,&points[i].r);\n        }\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                double len = sqrt((points[i].x - points[j].x)*(points[i].x - points[j].x) + (points[i].y - points[j].y)*(points[i].y - points[j].y) + (points[i].z - points[j].z)*(points[i].z - points[j].z))-points[i].r-points[j].r;\n                if (len < 0) len = 0;\n                minHeap.push_back(side(i, j, len));\n            }\n        }\n        make_heap(minHeap.begin(), minHeap.end());\n        double ans = Kruskal();\n        printf(\"%.3lf\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point3D {\n\tdouble x, y, z;\n\n\tPoint3D() : x(0), y(0), z(0) {}\n\n\tPoint3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\tPoint3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }\n\n\tPoint3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }\n\n\tPoint3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }\n\n\tPoint3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }\n\n\tbool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point3D& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\treturn os;\n}\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }\n\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n\tPoint3D a, b;\n\n\tLine() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n\n\tLine(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \", \" << l.a.z <<  \")-(\" << l.b.x << \",\" << l.b.y << \", \" << l.b.z <<  \")\";\n\treturn os;\n}\n\nPoint3D project(Line l, Point3D p) {\n\tPoint3D base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nstruct Sphere {\n\tPoint3D p;\n\tdouble r;\n\n\tSphere() : p(Point3D(0, 0, 0)), r(0.0) {}\n\n\tSphere(Point3D p, double r) : p(p), r(r) {}\n};\n\nostream& operator << (ostream& os, const Sphere& s) {\n\tos << \"(\" << s.p.z << \", \" << s.p.y << \", \" << s.p.z << \" :\" << s.r << \")\";\n\treturn os;\n}\n\ndouble distanceSphSph(Sphere s1, Sphere s2) {\n\tPoint3D p = s2.p - s1.p;\n\tdouble dist = abs(p) - s1.r - s2.r;\n\treturn max(0.0, dist);\n}\n\nstruct UnionFind {\n\tvector<int> par,rank;\n\tint N;\n\n\tUnionFind(int n) {\n\t\tN = n;\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\n\t\trep(i,n) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint size() {\n\t\tint cnt = 0;\n\t\trep(i,N) if(find(i) == i) cnt++;\n\t\treturn cnt;\n\t}\n};\n\nstruct edge {\n\tint from,to;\n\tdouble cost;\n\n\tedge(int t, int c) : to(t),cost(c) {}\n\tedge(int f, int t, double c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\ndouble kruskal(int n, vector<edge> v) {\n\tsort(v.begin(),v.end());\n\tUnionFind uf(n);\n\n\tdouble ret = 0;\n\trep(i, v.size()) {\n\t\tedge e = v[i];\n\t\tif(!uf.same(e.from,e.to)) {\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tret += e.cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n && n) {\n\t\tvector<Sphere> s(n);\n\t\trep(i, n) cin >> s[i].p.x >> s[i].p.y >> s[i].p.z >> s[i].r;\n\n\t\tvector<edge> v;\n\t\trep(i, n) {\n\t\t\tREP(j, i+1, n) {\n\t\t\t\tdouble dist = distanceSphSph(s[i], s[j]);\n\t\t\t\tv.push_back(edge(i, j, dist));\n\t\t\t}\n\t\t}\n\n\t\tcout << fixed;\n\t\tcout.precision(20);\n\t\tcout << kruskal(n, v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma comment (linker, \"/STACK:526000000\")\n#define  _CRT_SECURE_NO_WARNINGS\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\nint union_tree[1000];\nint union_find(int a) {\n\tif (union_tree[a] == a) return a;\n\treturn union_tree[a] = union_find(union_tree[a]);\n}\nint union_merge(int a, int b) {\n\ta = union_find(a);\n\tb = union_find(b);\n\tif (a == b) return 0;\n\tunion_tree[a] = b;\n\treturn 1;\n}\n\nvoid solve() {\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return;\n\t\tREP(i, n) {\n\t\t\tunion_tree[i] = i;\n\t\t}\n\t\tvector<tuple<long double, long double, long double, long double>> inputs;\n\t\tREP(i, n) {\n\t\t\tlong double a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tinputs.push_back(make_tuple(a, b, c, d));\n\t\t}\n\t\tvector<tuple<long double, int, int>> next;\n\t\tREP(i, n) {\n\t\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\t\tlong double cost = 0;\n\t\t\t\tcost += pow(get<0>(inputs[i]) - get<0>(inputs[q]),2.0);\n\t\t\t\tcost += pow(get<1>(inputs[i]) - get<1>(inputs[q]), 2.0);\n\t\t\t\tcost += pow(get<2>(inputs[i]) - get<2>(inputs[q]), 2.0);\n\t\t\t\tcost = (long double)sqrt(cost);\n\t\t\t\tcost -= get<3>(inputs[i]) + get<3>(inputs[q]);\n\t\t\t\tcost = max(cost, 0.0L);\n\t\t\t\tnext.push_back(make_tuple(cost, i, q));\n\t\t\t}\n\t\t}\n\t\tsort(ALL(next));\n\t\tlong double ans = 0.0;\n\t\tREP(i, next.size()) {\n\t\t\tans += get<0>(next[i]) * (long double)union_merge(get<1>(next[i]), get<2>(next[i]));\n\t\t}\n\t\tcout << fixed << setprecision(3);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to;\n\t\tdouble cost;\n\t};\n\tvector<edge>G;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,double c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tdouble krk(){\n\t\tdouble sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tdouble in[110][4];\n\t\trep(i,n)rep(j,4)cin>>in[i][j];\n\t\tdouble dis[110][110];\n\t\trep(i,n)rep(j,n)if(i!=j)\n\t\t\tdis[i][j]=max<double>(0,sqrt((in[i][0]-in[j][0])*(in[i][0]-in[j][0])+(in[i][1]-in[j][1])*(in[i][1]-in[j][1])+(in[i][2]-in[j][2])*(in[i][2]-in[j][2]))-in[i][3]-in[j][3]);\n\t\tKRK krk(n);\n\t\trep(i,n)loop(j,i+1,n){\n\t\t\tkrk.add_edge(i,j,dis[i][j]);\n\t\t\tkrk.add_edge(j,i,dis[j][i]);\n\t\t}\n\t\tprintf(\"%.3f\\n\",krk.krk());\n\t}\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint n;\ndouble x[101], y[101], z[101], r[101], res;\nstruct Edge { int u, v; double cost; } tmp;\nvector<Edge> edge;\n\nbool comp(const Edge &e1, const Edge &e2)\n{\n    return e1.cost < e2.cost;\n}\n\ndouble sq(double x) { return x * x; }\ndouble dis(int i, int j)\n{\n    return max(0.0, sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j])) - r[i] - r[j]);\n}\n\nclass UnionFind\n{\nprivate:\n\tint par[101];\n\tint rank[101];\n\npublic:\n\tvoid Init(int n)\n\t{\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tpar[i] = i, rank[i] = 0;\n\t}\n\tint Find(int x)\n\t{\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = Find(par[x]);\n\t}\n\tvoid Unite(int x, int y)\n\t{\n\t\tx = Find(x); y = Find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\telse par[y] = x;\n\t\tif(rank[x] == rank[y]) ++rank[x];\n\t}\n\tbool Same(int x, int y)\n\t{\n\t\treturn Find(x) == Find(y);\n\t}\n} uft;\n\nint main()\n{\n    while(cin >> n && n)\n    {\n\t\tres = 0.0;\n\t\tuft.Init(n);\n        edge.clear();\n        for(int i = 0; i < n; ++i)\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        for(int i = 0; i < n; ++i)\n        {\n            for(int j = i + 1; j < n; ++j)\n            {\n                tmp.u = i, tmp.v = j;\n                tmp.cost = dis(i, j);\n                edge.push_back(tmp);\n            }\n        }\n\t\tsort(edge.begin(), edge.end(), comp);\n\t\tfor(int i = 0, c = 0; c < n - 1; ++i)\n\t\t{\n\t\t\ttmp = edge[i];\n\t\t\tif(!uft.Same(tmp.u, tmp.v))\n\t\t\t{\n\t\t\t\tuft.Unite(tmp.u, tmp.v);\n\t\t\t\tres += tmp.cost;\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct P{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\n\nconst double inf = 999999;\n\ndouble calc(double s, double t)\n{\n\treturn (s-t)*(s-t);\n}\n\ndouble func(P s, P t)\n{\n\tdouble r = s.r + t.r;\n\tdouble d = sqrt(calc(s.x, t.x) + calc(s.y, t.y) + calc(s.z, t.z));\n\t\n\treturn ((r >= d)? 0.0: (d-r));\n}\n\ndouble prim(double a[101][101], int n)\n{\n\tdouble cost[101], r = 0.0;\n\tbool vis[101];\n\tfill(cost, cost+n, inf);\n\tfill(vis, vis+n, true);\n\tcost[0] = 0.0;\n\t\n\twhile(1){\n\t\tint v = -1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(vis[i] && (v == -1 || cost[i] < cost[v])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tvis[v] = false;\n\t\tr += cost[v];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcost[i] = min(cost[i], a[v][i]);\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint main()\n{\n\tint n;\n\tP pt[101];\n\tdouble a[101][101];\n\twhile(cin>>n && n){\n\t\tfill(&a[0][0], &a[n][n], inf);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> pt[i].x >> pt[i].y >> pt[i].z >> pt[i].r;\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\ta[i][j] = a[j][i] = func(pt[i], pt[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.3f\\n\", prim(a, n));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nstruct Cell {\n\tdouble x, y, z, r;\n};\n\nstruct Edge {\n\tint to;\n\tdouble distance;\n\tbool operator <(const Edge &a) const {\n\t\treturn distance > a.distance;\n\t}\n};\n\nCell cells[101];\nbool visited[101];\ndouble distances[101][101];\n\nint main() {\n\tint n;\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cells[i].x >> cells[i].y >> cells[i].z >> cells[i].r;\n\t\t\tvisited[i] = false;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdistances[i][j] = distances[j][i]\n\t\t\t\t\t= max(0.0,\n\t\t\t\t\t\tsqrt(pow(cells[i].x - cells[j].x, 2) + pow(cells[i].y - cells[j].y, 2)\n\t\t\t\t\t\t+ pow(cells[i].z - cells[j].z, 2))\n\t\t\t\t\t\t- cells[i].r - cells[j].r\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<Edge> pq;\n\t\tint current_vertex = 0;\n\t\tdouble length = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tvisited[current_vertex] = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif(!visited[j]) {\n\t\t\t\t\tEdge e;\n\t\t\t\t\te.to = j;\n\t\t\t\t\te.distance = distances[i][j];\n\t\t\t\t\tpq.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()) {\n\t\t\t\tEdge e = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(!visited[e.to]) {\n\t\t\t\t\tcurrent_vertex = e.to;\n\t\t\t\t\tlength += e.distance;\n\t\t\t\t\t//cout << \"goto:\" << e.to << \", dist:\" << e.distance << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%1.3lf\\n\", length);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\nstruct Elem {\n    int to;\n    double cost;\n};\n\nbool operator >(const Elem& x, const Elem& y) {\n    return tie(x.cost, x.to) > tie(y.cost, y.to);\n}\n\nint main()\n{\n    int n;\n    while (cin >> n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        loop (n, i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        vector<vector<double>> dist(n, vector<double>(n));\n        loop (n, i) loop (n, j) {\n            double d = pow(\n                    pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2),\n                    0.5\n                    );\n            dist[i][j] = max(0.0, d - r[i] - r[j]);\n        }\n\n        priority_queue<Elem, vector<Elem>, greater<Elem>> Q;\n        vector<int> vis(n);\n        Q.push({ 0, 0 });\n        double ans = 0;\n        while (Q.size()) {\n            Elem e = Q.top(); Q.pop();\n            if (vis[e.to]) continue;\n            vis[e.to] = 1;\n            ans += e.cost;\n            loop (n, i) if (i != e.to && !vis[i]) {\n                Q.push({ i, dist[e.to][i] });\n            }\n        }\n        cout << setprecision(8) << fixed << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Station {\n\tdouble x, y, z, r;\n};\nconst int MAX_N = 100;\ntypedef pair<double, int> Node;\nint n;\nStation stations[MAX_N + 1];\nbool used[MAX_N];\n\ndouble getdist(int A, int B) {\n\tconst Station& a = stations[A];\n\tconst Station& b = stations[B];\n\tdouble dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;\n\tdouble d = sqrt(dx * dx + dy * dy + dz * dz);\n\treturn max(d - (a.r + b.r), 0.);\n}\n\ndouble prim() {\n\tfill(used, used + n, false);\n\tdouble result = 0;\n\tpriority_queue<Node, vector<Node>, greater<Node> > que;\n\tque.push(make_pair(0., 0));\n\twhile (!que.empty()) {\n\t\tNode current = que.top();\n\t\tque.pop();\n\t\tdouble dist = current.first;\n\t\tint pos = current.second;\n\t\tif (used[pos]) continue;\n\t\tused[pos] = true;\n\t\tresult += dist;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == pos) continue;\n\t\t\tque.push(make_pair(getdist(pos, i), i));\n\t\t}\n\t}\n\treturn result;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> stations[i].x >> stations[i].y >> stations[i].z >> stations[i].r;\n\t\t}\n\t\tprintf(\"%.3lf\\n\", prim());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tuf.unite(i, j);\n\t\t\t\t\t++c;\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && n!=c) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t++c;\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n};\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tvector<pos3> cic(n);\n\t\tvector<pair<double, pii>> dis;\n\t\tREP(i, n)\n\t\t\tcin >> cic[i].x >> cic[i].y >> cic[i].z >> cic[i].r;\n\t\tREP(i,n-1)\n\t\t\tFOR(j, i + 1, n) {\n\t\t\tdouble d = sqrt((cic[i].x - cic[j].x)*(cic[i].x - cic[j].x) +\n\t\t\t\t(cic[i].y - cic[j].y)*(cic[i].y - cic[j].y) +\n\t\t\t\t(cic[i].z - cic[j].z)*(cic[i].z - cic[j].z))-cic[i].r-cic[j].r;\n\t\t\tdis.push_back({ d,{i,j}});\n\t\t}\n\t\tSORT(dis);\n\t\tUnionFind uf(n);\n\t\tdouble ans = 0.0;\n\t\tREP(i, dis.size()) {\n\t\t\tif (uf.find(dis[i].second.first) == uf.find(dis[i].second.second))\n\t\t\t\tcontinue;\n\t\t\tuf.unite(dis[i].second.first, dis[i].second.second);\n\t\t\tans += max(0.0,dis[i].first);\n\t\t\tint cnt = 0;\n\t\t\tREP(j, n) {\n\t\t\t\tif (uf.find(0) == uf.find(j))\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt == n)break;\n\t\t}\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j;\n\tdouble x,y,z;\n\tfor(;cin>>n,n;){\n\t\tvector<tuple<double,double,double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z,v.push_back(make_tuple(x,y,z));\n\t\tfor(m=i=0;i<n;i++)for(j=i+1,j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=fabs(get<k>(v[i])-get<k>(v[j]));\n\t\t\ta[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,0)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\tif(rank[a]==rank[b])rank[a]++;\n\t\t}\n\t\treturn true;\n\t}\n};\nmain()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tdouble x[100],y[100],z[100],r[100];\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>r[i];\n\t\tUF uf(n);\n\t\tvector<pair<double,pair<int,int> > >e;\n\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++)\n\t\t{\n\t\t\te.push_back(make_pair(\n\t\t\t\tmax(0.0,hypot(hypot(x[i]-x[j],y[i]-y[j]),z[i]-z[j])-r[i]-r[j]),\n\t\t\t\tmake_pair(i,j)\n\t\t\t));\n\t\t}\n\t\tsort(e.begin(),e.end());\n\t\tdouble ans=0;\n\t\tfor(int i=0;i<e.size();i++)\n\t\t{\n\t\t\tif(uf.unite(e[i].second.first,e[i].second.second))\n\t\t\t{\n\t\t\t\tans+=e[i].first;\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(3)<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\n\n\n// ============union_find_tree===============\nll MAX_N = 100;\nvector<ll> par(MAX_N);//MAX_N == num of node\nvector<ll> tree_rank(MAX_N);\n\nvoid init(ll n)\n{\n  for (ll i = 0; i < n; ++i)\n  {\n    par.at(i) = i;\n    tree_rank.at(i) = 0;\n  }\n}\n\nll find(ll x)\n{\n  if (par.at(x) == x)\n  {\n    return x;\n  }\n  else\n  {\n    return par.at(x) = find(par.at(x));\n  }\n}\n\nvoid unite(ll x, ll y)\n{\n  x = find(x);\n  y = find(y);\n  if (x == y)\n  {\n    return;\n  }\n  if (tree_rank.at(x) < tree_rank.at(y))\n  {\n    par.at(x) = y;\n  }\n  else\n  {\n    par.at(y) = x;\n    if (tree_rank.at(x) == tree_rank.at(y))\n    {\n      tree_rank.at(x)++;\n    }\n  }\n}\n\nbool same(ll x, ll y)\n{\n  return find(x) == find(y);\n}\n// =======================================\n\n// ==============kruskal==================\n\nstruct edge{ll u, v; double cost;}; // 辺u, v をつなぐコストが cost\nbool comp(const edge& e1, const edge& e2)\n{\n  return e1.cost < e2.cost;\n}\nconst ll MAX_E = 100 * (99) / 2;\nedge es[MAX_E];\nll V, E; // V 頂点、E 辺　の数\n\ndouble kruskal()\n{\n  sort(es, es + E, comp);\n  init(V);\n  double ans = 0;\n  for (ll i = 0; i < E; ++i)\n  {\n    edge e = es[i];\n    if (!same(e.u, e.v))\n    {\n      unite(e.u, e.v);\n      ans += e.cost;\n    }\n  }\n  return ans;\n}\n\n\n// =======================================\n\ndouble calc(tuple<double, double, double, double> a, tuple<double, double, double, double> b)\n{\n  double dist = sqrt(pow(get<0>(a) - get<0>(b), 2) + pow(get<1>(a) - get<1>(b), 2) + pow(get<2>(a) - get<2>(b), 2)) - get<3>(a) - get<3>(b);\n  return max(dist, 0.0);\n}\n\nint main()\n{\n  while (true)\n  {\n\n    ll N;\n    cin >> N;\n    if (N == 0)\n    {\n      break;\n    }\n    V = N;\n    E = N * (N - 1) / 2;\n    vector<tuple<double, double, double, double>> station(N);\n    double x, y, z, r;\n    for (ll i = 0; i < N; ++i)\n    {\n      cin >> x >> y >> z >> r;\n      station.at(i) = make_tuple(x, y, z, r);\n    }\n    ll cnt = 0;\n    for (ll i = 0; i < N - 1; ++i)\n    {\n      for (ll j = i + 1; j < N; ++j)\n      {\n        es[cnt] = {i, j, calc(station.at(i), station.at(j))};\n        cnt += 1;\n      }\n    }\n    cout << fixed << setprecision(3) << kruskal() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ1127\n#include <bits/stdc++.h>\n#define endl \"\\n\"\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define e_b emplace_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ipair;\ntypedef pair<ll,ll> lpair;\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v) //vectorの中身を見る\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\nvoid map_p(map<int,int>& d){cout<<\"map: \";for(auto a : d){cout<<\"{\"<<a.first<<\":\"<<a.second<<\"}\";}cout<<endl;} //mapの中身を見る\nvoid set_p(set<int>& d){cout<<\"set: \";for(int a : d){cout<<a<<\" \";}cout<<endl;} //setの中身を見る\n\nstruct za{double x,y,z,r;};\nstruct edge{double x,y,cost;};\nstruct unionfind{\n    vector<int> par;\n    void init(int n){\n        par.assign(n,-1);\n    }\n    int find(int x){\n        if(par[x]<=-1) return x;\n        par[x]=find(par[x]);\n        return par[x];\n    }\n    int size(int x){\n        return -1*par[find(x)];\n    }\n    void unite(int x,int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(size(x)<size(y)) swap(x,y);\n        par[x]+=par[y];\n        par[y]=x;\n    }\n    bool same_set(int x,int y){\n        return find(x)==find(y);\n    }\n};\nbool comp(edge a,edge b){\n    return a.cost<b.cost;\n}\ndouble sq(double a){\n    return a*a;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(3);\n\n    while(true){\n        int n;\n        cin>>n;\n        if(n==0) break;\n        vector<za> ten(n);\n        rep(i,n){\n            za now;\n            cin>>now.x>>now.y>>now.z>>now.r;\n            ten[i]=now;\n        }\n        unionfind uf;\n        uf.init(n);\n        vector<edge> hen;\n        for(int i=0;i<=n-2;i++){\n            for(int j=i+1;j<=n-1;j++){\n                double center_dis=sqrt(sq(ten[i].x-ten[j].x)+sq(ten[i].y-ten[j].y)+sq(ten[i].z-ten[j].z));\n                if(center_dis<=ten[i].r+ten[j].r){\n                    uf.unite(i,j);\n                }else{\n                    edge aa;\n                    aa.x=i,aa.y=j,aa.cost=center_dis-(ten[i].r+ten[j].r);\n                    hen.e_b(aa);\n                }\n            }\n        }\n        sort(all(hen),comp);\n        double total=0;\n        rep(i,sz(hen)){\n            edge cur=hen[i];\n            if(!uf.same_set(cur.x,cur.y)){\n                uf.unite(cur.x,cur.y);\n                total+=cur.cost;\n            }\n        }\n        cout<<total<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double INF = 10000.0;\nconst int MAX_V = 1000;\n\nint n;\nstruct cell{ double x,y,z,r; };\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v, double cost_){\n\tcost[u][v] = cost[v][u] = cost_;\n}\n\ndouble prim(){\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0.0;\n\t\n\twhile( true ){\n\t\tint v = -1;\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tif( !used[u] && (v == -1 || mincost[u] < mincost[v] ) )\n\t\t\t\tv = u;\n\t\t}\n\t\t\n\t\tif( v == -1 ) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tmincost[u] = min( mincost[u] , cost[v][u] );\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble D(cell c1, cell c2){\n\tdouble dx = c1.x - c2.x;\n\tdouble dy = c1.y - c2.y;\n\tdouble dz = c1.z - c2.z;\n\tdouble d = sqrt( dx * dx + dy * dy + dz * dz ) - c1.r - c2.r;\n\tif( d < 0.0 ) \n\t\td = 0.0;\n\treturn d;\n}\n\nint main(){\n\twhile( scanf(\"%d\", &n ) , n ){\n\t\tvector<cell> v;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x,y,z,r;\n\t\t\tcell c;\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x, &y, &z, &r);\n\t\t\tc.x = x;\n\t\t\tc.y = y;\n\t\t\tc.z = z;\n\t\t\tc.r = r;\n\t\t\tv.push_back( c );\n\t\t}\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tdouble d = D( v[i] , v[j] );\n\t\t\t\tadd_edge( i , j , d );\n\t\t\t}\n\t\t}\n\t\tdouble ans = prim();\n\t\tprintf(\"%.3f\\n\", ans );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\n#define N 10000\nvector<int> par(N);\nvector<int> ranks(N);\n\nvoid init(int n)\n{\n  int i;\n  rep(i,n)\n  {\n    par[i]=i;\n    ranks[i]=0;\n  }\n}\n\nint find(int x)\n{\n  if(par[x]==x)return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(ranks[x]<ranks[y])par[x]=y;\n  else\n  {\n    par[y]=x;\n    if(ranks[x]==ranks[y])ranks[x]++;\n  }\n}\n\nbool same(int x, int y)\n{\n  return find(x) == find(y);\n}\n\ndouble dist(double x1,double x2,double y1,double y2,double z1,double z2)\n{\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2));\n}\n\nint main()\n{\n  int n;cin>>n;\n  while(n!=0)\n  {\n    vector<double> x(n);\n    vector<double> y(n);\n    vector<double> z(n);\n    vector<double> r(n);\n    int i,j;\n    rep(i,n)cin>>x[i]>>y[i]>>z[i]>>r[i];\n    vector<int> a(n*n);\n    vector<int> b(n*n);\n    vector<double> cost(n*n);\n    rep(i,n)rep(j,n)\n    {\n      a[i*n+j]=i;\n      b[i*n+j]=j;\n      double dis=dist(x[i],x[j],y[i],y[j],z[i],z[j]);\n      if(dis<=r[i]+r[j])cost[i*n+j]=0.0;\n      else cost[i*n+j]=dis-(r[i]+r[j]);\n    }\n    init(n);\n    vector<pair<double,int>> p(n*n);\n    rep(i,n*n)p[i]=make_pair(cost[i],i);\n    sort(all(p));\n    double ans=0.0;\n    rep(i,n*n)\n    {\n      int ind=p[i].second;\n      if(!same(a[ind],b[ind]))\n      {\n        unite(a[ind],b[ind]);\n        ans+=p[i].first;\n      }\n    }\n    cout<<fixed<<setprecision(3)<<ans<<endl;\n    cin>>n;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst int INF = 1<<29;\n\ndouble prim(){\n  double ret = 0;\n  bool used[100]={};\n  double dist[100];\n  for(int i=0;i<n;++i) dist[i]=INF;\n  dist[0]=0;\n  while(true){\n    int id = -1;\n    double mindst = INF;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dist[i]){\n\tmindst = dist[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id] = true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dist[i]=min(dist[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;cin>>a;return a;}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=INF;\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n\n    cout << fixed << setprecision(10) << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define SQ(x) ((x)*(x))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\ndouble cost[128][128];\ndouble mincost[128];\nbool used[128];\n\ndouble prim(){\n  rep(i, n){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  double res = 0;\n\n  while(true){\n    int v = -1;\n    rep(u, n){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]))  v = u;\n    }\n\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n\n\n    rep(u, n)\n      mincost[u] = min(mincost[u], cost[v][u]);\n  }\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d\", &n) && n){\n    double x[128], y[128], z[128], r[128];\n    rep(i, n){\n      scanf(\"%lf%lf%lf%lf\", x+i, y+i, z+i, r+i);\n    }\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n\n    rep(i, n) REP(j, i+1, n){\n      double dis = sqrt(SQ(x[i]-x[j])+SQ(y[i]-y[j])+SQ(z[i]-z[j]));\n      dis -= r[i] + r[j];\n      dis = max(dis, 0.0);\n      cost[i][j] = cost[j][i] = dis;\n    }\n\n    printf(\"%.3lf\\n\", prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble mp[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmp[i][j] = MX;\n      }\n      p[i] = -1;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j){\n\t  mp[i][j] = 0;\n\t} else {\n\t  mp[i][j] = compute(i, j);\n\t}\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      res += d[t];\n      //if (p[t] != -1) res += mp[t][p[t]];\n      //printf(\"res: %.3f\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(mp[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = mp[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    printf(\"%.3f\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = double;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass UnionFind {\n  vector<int> tree, rank, setSize;\n\npublic:\n  UnionFind(const int &n) : tree(n), rank(n), setSize(n, 1) { iota(all(tree), 0); }\n\n  int root(const int &x) { return tree[x] == x ? x : tree[x] = root(tree[x]); }\n\n  bool same(const int &a, const int &b) { return root(a) == root(b); }\n\n  bool unite(int a, int b) {\n    a = root(a), b = root(b);\n    if (a == b) return false;\n    if (rank[a] < rank[b]) swap(a, b);\n    tree[b] = a;\n    setSize[a] += setSize[b];\n    if (rank[a] == rank[b]) rank[a]++;\n    return true;\n  }\n\n  int setSizeOf(const int &x) { return setSize[root(x)]; }\n\n  int size() { return tree.size(); }\n};\n\npair<Weight, Edges> kruskal(const Graph &g) {\n  UnionFind uf(g.size());\n  Edges es;\n  for (auto &adj : g) {\n    for (auto &e : adj) es.emplace_back(e);\n  }\n  sort(es.begin(), es.end(), [](const Edge &e, const Edge &f) { return e.weight < f.weight; });\n  Weight total = 0;\n  Edges tree;\n  for (auto &e : es) {\n    if (uf.unite(e.src, e.dst)) tree.push_back(e), total += e.weight;\n  }\n  return {total, tree};\n}\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<double> x(n), y(n), z(n), r(n);\n    rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n    Graph g(n);\n    rep(i, n) loop(j, i + 1, n) {\n      double dx = abs(x[i] - x[j]), dy = abs(y[i] - y[j]), dz = abs(z[i] - z[j]);\n      double d = max(0.0, sqrt(dx * dx + dy * dy + dz * dz) - r[i] - r[j]);\n      g.addEdge(i, j, d);\n    }\n    cout << prec(3) << kruskal(g).first << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\ntypedef vector<double> vd;\nconst int INF = INT_MAX/2-1;\n\nstruct state {\n\tint p;\n\tdouble c;\n\tstate(int p, double c) : p(p), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn c>o.c;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<vd> cell(n, vd(4));\n\t\tREP(i, n) {\n\t\t\tcin >> cell[i][0] >> cell[i][1] >> cell[i][2] >> cell[i][3];\n\t\t}\n\t\t\n\t\tvector<vd> dist(n, vd(n, INF));\n\t\tREP(i, n) {\n\t\t\tFOR(j, i+1, n-1) {\n\t\t\t\tdouble d2 = 0;\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\td2 += (cell[i][k]-cell[j][k])*(cell[i][k]-cell[j][k]);\n\t\t\t\t}\n\t\t\t\tdouble d = sqrt(d2)-cell[i][3]-cell[j][3];\n\t\t\t\tif(d < EPS) {\n\t\t\t\t\tdist[i][j] = dist[j][i] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = dist[j][i] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi used(n, 0);\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0,  0));\n\t\tdouble ans = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif(used[st.p]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tused[st.p] = true;\n\t\t\tans += st.c;\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(dist[st.p][i] != INF && st.p != i) {\n\t\t\t\t\tQ.push(state(i, dist[st.p][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntemplate<typename T>\nclass UnionFind {\n    int size_;\n    std::vector<T> par;\n    std::vector<T> rank;\n    public:\n    UnionFind(int size_) : size_(size_) {\n        par.resize(size_);\n        rank.resize(size_);\n        for(int i=0; i<size_; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    T find(T x) {\n        return par[x] == x ? x : par[x] = find(par[x]);\n    }\n    void unite(T x,T y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]) {\n            par[x] = y;\n        }\n        else {\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(T x,T y) {\n        return find(x) == find(y);\n    }\n};\nint n;\nstruct Sphere {\n    double x,y,z,r;\n};\nstruct Edge {\n    int from;\n    int to;\n    double cost;\n\n    bool operator<(const Edge &rth) const {\n        return cost < rth.cost;\n    }\n};\ndouble pow2(double x) {\n    return x*x;\n}\ndouble dist(Sphere s1, Sphere s2) {\n    double t;\n    t=pow2(s1.x-s2.x);\n    t+=pow2(s1.y-s2.y);\n    t+=pow2(s1.z-s2.z);\n    t=sqrt(t);\n\n    t=t-s1.r-s2.r;\n\n    if(t<0) t=0;\n    return t;\n}\nvoid solve() {\n    UnionFind<int> uf(102);\n    vector<Edge> edges;\n    Sphere sphere[102];\n    rep(i,n) {\n        double x,y,z,r;\n        cin>>x>>y>>z>>r;\n        sphere[i]={x,y,z,r};\n    }\n    rep(i,n) rep(j,n) if(i!=j) {\n        double d=dist(sphere[i],sphere[j]);\n        edges.push_back({i,j,d});\n    }\n\n    sort(all(edges));\n    double ans=0;\n\n    rep(i,edges.size()) {\n        Edge e = edges[i];\n        if(!uf.same(e.from,e.to)) {\n            ans+=e.cost;\n            uf.unite(e.from,e.to);\n        }\n    }\n\n    printf(\"%.10f\\n\",ans);\n}\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define MAX_V 100\n#define MAX_E 10000\nint V,E,par[MAX_V],rnk[MAX_V];\nstruct Colony{\n  double x,y,z,r;\n  Colony(){}\n  Colony(double x,double y,double z,double r) : x(x),y(y),z(z),r(r) {}\n};\nstruct Edge{\n  int u,v;\n  double dist;\n  Edge(){}\n  Edge(int u,int v,double dist) : u(u),v(v),dist(dist) {}\n};\nbool comp(const Edge &e1,const Edge &e2){\n  return e1.dist < e2.dist;\n}\n \nEdge es[MAX_E];\n \nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n \nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n \n  if(x == y) return;\n \n  if(rnk[x] < rnk[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rnk[x] == rnk[y]){\n      rnk[x]++;\n    }\n  }\n}\n \nbool same(int x,int y){\n  return find(x) == find(y);\n}\n \ndouble kruskal(){\n  sort(es,es+E,comp);\n  init();\n  double res = 0.0;\n  for(int i = 0 ; i < E ; i++){\n    Edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res += e.dist;\n    }\n  }\n  return res;\n}\n \ndouble getDist(const Colony &c1,const Colony &c2){\n  return sqrt(pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2)+pow(c1.z-c2.z,2))-c1.r-c2.r;\n}\n \nint main(){\n  while(cin >> V,V){\n    E = 0;\n    double x,y,z,r;\n    Colony C[MAX_V];\n    for(int i = 0 ; i < V ; i++){\n      cin >> x >> y >> z >> r;\n      C[i] = Colony(x,y,z,r);\n    }\n     \n    for(int i = 0 ; i < V ; i++){\n      for(int j = i+1 ; j < V ; j++){\n        double dist = getDist(C[i],C[j]);\n        es[E++] = Edge(i,j,max(dist,0.0));\n      }\n    }\n    printf(\"%.3f\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0; i<n; i++)\ntypedef long long ll;\ntypedef long long unsigned int llu;\nll MOD = 1000000007;\nll INF = 1000000009;\n\n\nclass UnionFind{\n    vector<int> par;\n    int all = 0;\n    vector<int> siz;\n    int treenum;\n\n    public:UnionFind(int N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par.emplace_back(i);\n        for(int i = 0; i < N; i++) siz.emplace_back(1);\n        all = N;\n        treenum = N;\n    }\n\n    public:int root(int x){\n        if(par[x]==x) return x;\n        else{\n            par[x]=root(par[x]);\n            return par[x];\n        }\n    }\n\n    public:bool same(int x, int y){\n        return root(x)==root(y);\n    }\n\n    public:void unite(int x, int y){\n        if(same(x,y)) return;\n        else{\n            int rx=root(x);\n            int ry=root(y);\n            par[ry]=rx;\n            siz[rx]=siz[rx]+siz[ry];\n            siz[ry]=siz[rx];\n            treenum--;\n            return;\n        }\n    }\n\n    public:int size(int x){\n        siz[x]=siz[root(x)];\n        return siz[x];\n    }\n\n    public:void sizall(){\n        rep(i,all){\n            siz[i] = siz[root(i)];\n        }\n    }\n\n    public:int treenumber(){\n        return treenum;\n    }\n\n    public:void add(){\n        par.emplace_back(all);\n        siz.emplace_back(1);\n        all++;\n        treenum++;\n    }\n\n    public:void del(int x){\n        //xを木から外して単一ノードの木に分離する\n        //子の検索にO(n)かける. UF木の弱点なので使用は推奨されない\n        //根であれば繋ぎ直し、素集合としてみなさない.\n        bool isroot=false;\n        //あるノードの根であるかどうか.\n        rep(i,all){\n            if(root(i)==x) isroot=true;\n        }\n        if(!isroot){\n            rep(i,all){\n                if(par[i]==x){\n                    par[i]=par[x];\n                }\n            }\n            par[x]=x;\n            return;\n        }\n\n        if(isroot){\n            sizall();\n            if(size(x)==1) return;\n            rep(i,all){\n                if(par[i]==x){\n                    treenum++;\n                    par[i]=i;\n                }\n            }\n            return;\n        }\n\n    }\n\n};\n\n\n\ndouble dist[110][110];\nvector<double> a;\n\nvoid solve(){\n\n    /*\n    int v,e,k;\n    cin >> v >> e >> k;\n    vector<tuple<int,int,int>> t;\n    rep(i,e){\n        int x,y,z;\n        cin >> x >> y >> z;\n        x--;\n        y--;\n        t.emplace_back(make_tuple(z,x,y));\n    }\n    */\n\n    while(true){\n\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<tuple<double, double, double, double>> x;\n        rep(i,n){\n            double p,q,r,s;\n            cin >> p >> q >> r >> s;\n            x.emplace_back(make_tuple(p,q,r,s));\n        }\n        rep(i,n){\n            rep(j,n){\n                if(i==j) {\n                    dist[i][j]=0;\n                    continue;\n                }\n                double x1,y1,z1,x2,y2,z2, r1,r2;\n                x1=get<0>(x[i]);\n                y1=get<1>(x[i]);\n                z1=get<2>(x[i]);\n                r1=get<3>(x[i]);\n                x2=get<0>(x[j]);\n                y2=get<1>(x[j]);\n                z2=get<2>(x[j]);\n                r2=get<3>(x[j]);\n                double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2));\n                if(d<r1+r2) dist[i][j]=0;\n                else dist[i][j]=d-r1-r2;\n            }\n        }\n\n        vector<tuple<double,int,int>> t;\n\n        rep(i,n){\n            rep(j,n){\n                if(i>=j) continue;\n                t.emplace_back(make_tuple(dist[i][j],i,j));\n            }\n        }\n\n    \n\n    sort(t.begin(), t.end());\n    UnionFind uf(n);\n    int pointer=0;\n    double ans = 0;\n    while(uf.treenumber()>1){\n        double d = get<0>(t[pointer]);\n        double x = get<1>(t[pointer]);\n        double y = get<2>(t[pointer]);\n        if(!uf.same(x,y)){\n            ans += d;\n            uf.unite(x,y);\n        }\n        pointer++;\n    }\n    a.emplace_back(ans);\n\n\n\n    }\n\n    for(auto e:a){\n        cout << fixed;\n        cout << setprecision(3) << e << endl;\n    }\n\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\ntypedef pair<double,int> pdi;\n\nconst double EPS = 1e-9;\n\nstruct Cell{\n    vector<double> pos;\n    double r;\n    Cell(vector<double> p,double rr) : pos(p),r(rr) {};\n};\ndouble pow2(double a){\n    return a*a;\n}\n\ndouble dist(Cell a,Cell b){\n    double d2=0;\n    for(int i=0;i<3;i++){\n        d2 += pow2(a.pos[i]-b.pos[i]);\n    }\n    double d = sqrt(d2);\n    if(d <= a.r+b.r){\n        return 0;\n    }else{\n        return d-(a.r+b.r);\n    }\n}\n\nint main(){\n    cout << fixed << setprecision(3);\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<Cell> cells;\n        for(int i=0;i<n;i++){\n            vector<double> pos(3);\n            for(int j=0;j<3;j++) cin >> pos[j];\n            double r;\n            cin >> r;\n            cells.push_back(Cell(pos,r));\n        }\n\n        vector<vector<double> > dists(n,vector<double>(n));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dists[i][j] = dist(cells[i],cells[j]);\n            }\n        }\n\n        vector<char> used(n,false);\n        priority_queue<pdi,vector<pdi>,greater<pdi> > que;\n        que.push(make_pair(0,0));\n        double ret = 0;\n        while(not que.empty()){\n            double cost = que.top().first;\n            int where = que.top().second;\n            que.pop();\n            if(used[where]) continue;\n            used[where] = true;\n            ret += cost;\n            for(int i=0;i<n;i++){\n                que.push(make_pair(dists[where][i],i));\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define ALL(a) (a).begin(), (a).end()\n\ntemplate <class T>\ninline bool chmin(T &a, T b){\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b){\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, int>;\nusing DoP = pair<double, double>;\nusing edge = struct { int to; double cost;}; // edge x = {to, cost}\n\nconst int di[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int INF = 1<<29;\nconst ll INF64 = 1ll << 45;\nconst int mod = 1000000007;\n\nstruct Sieve\n{\n  int n;\n  vector<int> f, primes;\n  Sieve(int n = 1) : n(n), f(n + 1)\n  {\n    f[0] = f[1] = -1;\n    for (ll i = 2; i <= n; ++i)\n    {\n      if (f[i])\n        continue;\n      primes.push_back(i);\n      f[i] = i;\n      for (ll j = i * i; j <= n; j += i)\n      {\n        if (!f[j])\n          f[j] = i;\n      }\n    }\n  }\n  bool isPrime(int x) { return f[x] == x; }\n  vector<int> factorList(int x)\n  {\n    vector<int> res;\n    while (x != 1)\n    {\n      res.push_back(f[x]);\n      x /= f[x];\n    }\n    return res;\n  }\n  vector<P> factor(int x)\n  {\n    vector<int> fl = factorList(x);\n    if (fl.size() == 0)\n      return {};\n    vector<P> res(1, P(fl[0], 0));\n    for (int p : fl)\n    {\n      if (res.back().first == p)\n      {\n        res.back().second++;\n      }\n      else\n      {\n        res.emplace_back(p, 1);\n      }\n    }\n    return res;\n  }\n};\nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> siz;\n  UnionFind(int N) : par(N), siz(N, 1) {for (int i = 0; i < N; i++) par[i] = i;}\n  \n  void init(int N) {\n    siz.assign(N, 1);\n    par.resize(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n  }\n\n  int root(int x) {\n    while(par[x] != x) {x = par[x] = par[par[x]];}\n    return x;\n  }\n\n  bool unite(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if(x == y) return false;\n\n    if(siz[x] < siz[y]) swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n\n  }\n\n  bool isSame(int x, int y) {return root(x) == root(y); }\n\n  int size(int x) { return siz[root(x)]; }\n};\nstruct mint\n{\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint operator-() const { return mint(-x); }\n  mint &operator+=(const mint a)\n  {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a)\n  {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a)\n  {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const\n  {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const\n  {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const\n  {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const\n  {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const\n  {\n    return pow(mod - 2);\n  }\n  mint &operator/=(const mint a)\n  {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const\n  {\n    mint res(*this);\n    return res /= a;\n  }\n};\n// h(n, r) = c(n+r-1, r)\nstruct combination\n{\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1)\n  {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k)\n  {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nint main(){\n  auto dist = [&](tuple<double, double, double, double> a, tuple<double, double, double, double> b) {\n    double len = pow(get<0>(a)-get<0>(b), 2) + pow(get<1>(a)-get<1>(b), 2) + pow(get<2>(a)-get<2>(b), 2);\n    len = sqrt(len);\n    return max(0.0, len-(get<3>(a)+get<3>(b)));\n  };\n  vector<tuple<double, double, double, double>> cell(100);\n  vector<double> res;\n\n  while(true) {\n    int n; cin >> n;\n    if(n == 0) break;\n    rep(i, n) {\n      double x, y, z, r; cin >> x >> y >> z >> r;\n      cell[i] = make_tuple(x, y, z, r);\n    }\n    vector<vector<edge>> e(n);\n    for(int i = 0; i < n; ++i) for(int j = i+1; j < n; ++j) {\n      auto cost = dist(cell[i], cell[j]);\n      edge x = {j, cost};\n      edge y = {i, cost};\n      e[i].push_back(x);\n      e[j].push_back(y);\n    }\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    vector<bool> used(n, false);\n\n    pq.push(P(0.0, 0));\n    double ans = 0.0;\n\n    while(true) {\n      if(pq.empty()) break;\n      auto p = pq.top(); pq.pop();\n      if(used[p.second]) continue;\n      ans += p.first;\n      int u = p.second;\n      used[u] = true;\n      for(auto x : e[u]) if(!used[x.to]) pq.push(make_pair(x.cost, x.to));\n    }\n    res.push_back(ans);\n  }\n  for(auto x : res) printf(\"%0.3f\\n\", x);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<string>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<iomanip>\n#include<cctype>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep2(i,a,b) for (int (i)=a;(i)<(b);(i)++)\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nconst int inf = 1001001000;\n\nvoid print(vector<vector<int>> a){\n\tfor (int i=0;i<a.size();i++){\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<int> a){\n    int n = a.size();\n    for (int j=0;j<n;j++) {\n        if (j != n-1) cout << a[j] << \" \";\n        else cout << a[j] << endl;\n    }\n}\n//UnionFind木のテンプレ.parentには根のindexが入っている.\n//根には連結成分のサイズが入っている.nはノード数.\nclass UnionFind{\npublic:\n\tvector<int> parent;\n\tUnionFind(){}\n\tUnionFind(int n){\n\t\tthis->parent = vector<int>(n,-1);\n\t}\n\tint root(int x){\n\t\tif (this->parent[x] < 0) return x;\n\t\tthis->parent[x] = root(this->parent[x]);\n\t\treturn this->parent[x];\n\t}\n\tint unite(int x, int y){\n\t\tint rx = this->root(x);\n\t\tint ry = this->root(y);\n\t\tif (rx == ry) return false;\n\t\tif (this->parent[rx] > this->parent[ry]) swap(rx, ry);\n\t\tthis->parent[rx] += this->parent[ry];\n\t\tthis->parent[ry] = rx;\n\t\treturn true;\n\t}\n\tint same(int x, int y){\n\t\tint rx = this->root(x);\n\t\tint ry = this->root(y);\n\t\treturn rx == ry;\n\t}\n\tint size(int x){\n\t\treturn -this->parent[this->root(x)];\n\t}\n};\n\n\n//クラスカル法.UnionFindが必要.最小全域木の重みの総和を返す.\n//nはノード数.queは(weight,from,to)の順に格納された順序付き待ち行列.\n// int v, e; cin >> v >> e;\n// \tpriority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> que;\n// \tfor (int i = 0; i < e; i++){\n// \t\tint s, t, w; cin >> s >> t >> w;\n// \t\tque.push({w,s,t});\n// \t}\nint kruskal(int n, priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> que){\n\tUnionFind uf(n);\n\tint weight = 0;\n\twhile(!que.empty()){\n\t\tvector<int> now = que.top();\n\t\tque.pop();\n\t\tif (!uf.same(now[1],now[2])){\n\t\t\tuf.unite(now[1],now[2]);\n\t\t\tweight += now[0];\n\t\t}\n\t}\n\treturn weight;\n}\ndouble kruskal(int n, priority_queue<tuple<double,int,int>,vector<tuple<double,int,int>>,greater<tuple<double,int,int>>> que){\n\tUnionFind uf(n);\n\tdouble weight = 0;\n\twhile(!que.empty()){\n\t\ttuple<double, int, int> now = que.top();\n\t\tque.pop();\n\t\tif (!uf.same(get<1>(now),get<2>(now))){\n\t\t\tuf.unite(get<1>(now), get<2>(now));\n\t\t\tweight += get<0>(now);\n\t\t}\n\t}\n\treturn weight;\n}\ndouble dist(vector<double> a,vector<double> b){\n\treturn sqrt(pow((a[0] - b[0]), 2) + pow((a[1] - b[1]), 2) + pow((a[2] - b[2]), 2));\n}\n\nint main(){\n\tcout << fixed;\n\twhile (true)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tvector<vector<double>> cells(n, vector<double>(4, 0));\n\t\trep(i, n){\n\t\t\tcin >> cells[i][0] >> cells[i][1] >> cells[i][2] >> cells[i][3];\n\t\t}\n\t\tpriority_queue<tuple<double,int,int>,vector<tuple<double,int,int>>,greater<tuple<double,int,int>>> que;\n\t\t\n\t\trep(i,n-1){\n\t\t\trep2(j,i+1,n){\n\t\t\t\tdouble w = dist(cells[i], cells[j]) - cells[i][3] - cells[j][3];\n\t\t\t\tque.push(tuple<double, int, int>(w > 0 ? w : 0, i, j));\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(3) << kruskal(n, que) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Dis{\n  public:\n  vector<ll> rank,p;\n  \n  Dis(int s){\n    rank.resize(s,0);\n    p.resize(s,0);\n    rep(i,s) makeSet(i);\n  }\n  \n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n  \n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n  \n  void unite(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  \n  void link(int x,int y){\n    if(rank[x]>rank[y]) p[y]=x;\n    else{\n      p[x]=y;\n      if(rank[x]==rank[y]) rank[y]++;\n    }\n  }\n  \n  int findSet(int x){\n    if(x != p[x]) p[x]=findSet(p[x]);\n    return p[x];\n  }\n};\n  \nclass Edge{\n  public: int source,target;\n          double cost;\n  Edge(int source=0, int target=0, double cost=0):\n  source(source),target(target),cost(cost){}\n  bool operator < (const Edge &e) const{\n    return cost<e.cost;\n  }\n};\n  \ndouble kruskal(int N,vector<Edge> edges){\n  double totalCost=0;\n  sort(ALL(edges));\n  \n  Dis dset=Dis(N+1);\n  \n  int source,target;\n  rep(i,edges.size()){\n    Edge e=edges[i];\n    if(!dset.same(e.source,e.target)){\n      totalCost+=e.cost;\n      dset.unite(e.source,e.target);\n    }\n  }\n  return totalCost;\n} \n\nint main() {\n  int n;\n  while(cin>>n){\n    if(n==0) return 0;\n    \n    vector<double> x(n),y(n),z(n),r(n);\n    rep(i,n) cin>>x[i]>>y[i]>>z[i]>>r[i];\n  \n    vector<Edge> edges;\n    rep(i,n){\n      rep(j,n){\n        if(j<=i) continue;\n        edges.push_back(Edge(i,j,max(0.0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+\n                                     (z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j])));\n      }\n    }\n  \n    cout<<fixed<<setprecision(3)<<kruskal(n,edges)<<endl;\n    \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nstruct P{\n  double x,y,z,r;\n  P(double x,double y,double z,double r):x(x),y(y),z(z),r(r){}\n};\n\ndouble G[101][101];\ndouble dist(const P& a,const P& b){\n  double dx=a.x-b.x;\n  double dy=a.y-b.y;\n  double dz=a.z-b.z;\n  double d = sqrt(dx*dx+dy*dy+dz*dz);\n  return max(0.0,d-a.r-b.r);\n}\nint n;\nconst double INF = 1000000000;\n\ndouble prim(){\n  double ret = 0;\n  double dst[150];\n  bool used[150];\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;++i) dst[i]=INF;\n  dst[0]=0;\n  while(true){\n    double mindst = INF;\n    int id = -1;\n    for(int i=0;i<n;++i){\n      if(!used[i] && mindst > dst[i]){\n\tmindst = dst[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id]=true;\n    ret+=mindst;\n    for(int i=0;i<n;++i)\n      dst[i]=min(dst[i],G[id][i]);\n  }\n  return ret;\n}\n\ndouble input(){double a;cin>>a;return a;}\n\nint main(){\n  while(cin>>n,n){\n    memset(G,0,sizeof(G));\n    vector<P> cell;\n    for(int i=0;i<n;++i)\n      cell.push_back(P(input(),input(),input(),input()));\n    for(int i=0;i<n;++i)\n      for(int j=i+1;j<n;++j)\n\tG[i][j]=G[j][i]=dist(cell[i],cell[j]);\n    cout << fixed << setprecision(3) << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define pow2(x) ((x)*(x))\n#define N 100\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint root(int x) {\n\t\tif(x==parent[x]) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool issame(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tint unite(int x, int y) {\n\t\tif(root(x)==root(y)) return root(x);\n\t\tif(root(x)<root(y)) {\n\t\t\tparent[root(x)] = parent[root(y)];\n\t\t}else {\n\t\t\tparent[root(y)] = parent[root(x)];\n\t\t}\n\t\treturn root(y);\n\t}\n\tbool check(int n) {\n\t\tint p = parent[0];\n\t\tfor(int i=1; i<n; ++i) {\n\t\t\tif(p!=root(i)) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator<(const Edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n\t\tbool operator>(const Edge& e) const {\n\t\treturn cost > e.cost;\n\t}\n};\n\nint main() {\n\tint n, c;\n\tUnionFind uf;\n\tdouble x[N], y[N], z[N], r[N], ans;\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > q;\n\twhile(cin >> n && n) {\n\t\twhile(!q.empty()) q.pop();\n\t\tuf.init(n); ans = 0.0; c = 0;\n\t\tfor(int i=0; i<n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=i+1; j<n; ++j) {\n\t\t\t\tdouble rr = pow2(x[j]-x[i]) + pow2(y[j]-y[i]) + pow2(z[j]-z[i]);\n\t\t\t\tif(rr <= pow2(r[j]+r[i])) {\n\t\t\t\t\tuf.unite(i, j);\n\t\t\t\t\t++c;\n\t\t\t\t}else {\n\t\t\t\t\tq.push((Edge){i, j, sqrt(rr)-r[i]-r[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty() && !uf.check(n)) {\n\t\t\tEdge e = q.top(); q.pop();\n\t\t\tif(!uf.issame(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t++c;\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%.5f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nstruct Cell {\n\tdouble x, y, z, r;\n};\n\nstruct Edge {\n\tint to;\n\tdouble distance;\n\tbool operator <(const Edge &a) const {\n\t\treturn distance > a.distance;\n\t}\n};\n\nCell cells[101];\nbool visited[101];\ndouble distances[101][101];\n\nint main() {\n\tint n;\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cells[i].x >> cells[i].y >> cells[i].z >> cells[i].r;\n\t\t\tvisited[i] = false;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdistances[i][j] = distances[j][i]\n\t\t\t\t\t= max(0.0,\n\t\t\t\t\t\tsqrt(pow(cells[i].x - cells[j].x, 2) + pow(cells[i].y - cells[j].y, 2)\n\t\t\t\t\t\t+ pow(cells[i].z - cells[j].z, 2))\n\t\t\t\t\t\t- cells[i].r - cells[j].r\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<Edge> pq;\n\t\tint current_vertex = 0;\n\t\tdouble length = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tvisited[current_vertex] = true;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif(!visited[j]) {\n\t\t\t\t\tEdge e;\n\t\t\t\t\te.to = j;\n\t\t\t\t\te.distance = distances[current_vertex][j];\n\t\t\t\t\tpq.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()) {\n\t\t\t\tEdge e = pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(!visited[e.to]) {\n\t\t\t\t\tcurrent_vertex = e.to;\n\t\t\t\t\tlength += e.distance;\n\t\t\t\t\t//cout << \"goto:\" << e.to << \", dist:\" << e.distance << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\", length);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\ndouble calc(double a, double b) { return (a - b) * (a - b); }\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(3);\n    int n;\n    while(cin >> n, n)\n    {\n        vector<double> x(n), y(n), z(n), r(n);\n        for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> z[i] >> r[i];\n        double ans = 0.0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        bool used[n] = {};\n        que.push(P(0, 0));\n        while(que.size())\n        {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(used[v]) continue;\n            ans += p.first;\n            used[v] = true;\n            for(int u = 0; u < n; u++)\n            {\n                if(used[u]) continue;\n                double dist = sqrt(calc(x[v], x[u]) + calc(y[v], y[u]) + calc(z[v], z[u])) - (r[v] + r[u]);\n                que.push(P(max(dist, 0.0), u));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOTCONNECTED 0 // WHITE\n#define CANDIDATE 1 // GRAY\n#define CONNECTED 2 // BLACK\nusing namespace std;\ndouble getDistance(vector<double>, vector<double>);\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<vector<double> > cells;\n    for(int i = 0; i < n; ++i) {\n      double y, x, z, r;\n      cin >> x >> y >> z >> r;\n      cells.push_back(vector<double>({x, y, z, r}));\n    }\n    vector<double> minWeights(n, INT_MAX); // d\n    minWeights[0] = 0;\n    vector<int> states(n, NOTCONNECTED); // color\n    vector<int> parents(n, -1); // p\n    while(true) {\n      int minv = INT_MAX;\n      int u = -1;\n      for(int i = 0; i < n; ++i) {\n        if(minv > minWeights[i] && states[i] == NOTCONNECTED) {\n          u = i;\n          minv = minWeights[i];\n        }\n      }\n      if(u == -1) break;\n      states[u] = CONNECTED;\n      for(int v = 0; v < n; ++v) {\n        if(states[v] == NOTCONNECTED && minWeights[v] > getDistance(cells[u], cells[v])) {\n          minWeights[v] = getDistance(cells[u], cells[v]);\n          parents[v] = u;\n          // states[v] = CANDIDATE;\n        }\n      }\n    }\n    double ans = 0;\n    for(int i = 0; i < n; ++i) {\n      if(parents[i] != -1) ans += getDistance(cells[i], cells[parents[i]]);\n    }\n    printf(\"%.3f\", ans);\n    cout << endl;\n  }\n  return 0;\n}\n\ndouble getDistance(vector<double> a, vector<double> b) {\n  double dx = abs(a[0] - b[0]);\n  double dy = abs(a[1] - b[1]);\n  double dz = abs(a[2] - b[2]);\n  double ans = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - a[3] - b[3];\n  return ans < 0 ? 0 : ans;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Building a Space Station\n//Level: 2\n//Category: グラフ,Graph,最小全域木,MST\n//Note:\n\n/**\n * 球体と球体を最短距離で結ぶには、中心同士を結ぶような線分で結べばよい。\n * 交差している球の間にはコスト0の辺があるものとして、最小全域木を求めればよい。\n *\n * オーダーは O(N^2 log N)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct DisjointSet/*{{{*/\n{\n  vector<int> parent;\n\n  int root(int x)\n  {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      parent[x] = root(parent[x]);\n      return parent[x];\n    }\n  }\n\n  explicit DisjointSet(int n) : parent(n, -1) {}\n\n  bool unite(int x, int y)\n  {\n    const int a = root(x);\n    const int b = root(y);\n    if (a != b) {\n      if (parent[a] < parent[b]) {\n        parent[a] += parent[b];\n        parent[b] = a;\n      } else {\n        parent[b] += parent[a];\n        parent[a] = b;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool find(int x, int y) { return root(x) == root(y); }\n  int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nstruct Sphere {\n    double x, y, z, r;\n\n    double distance(const Sphere &s) const {\n        const double dx = x - s.x;\n        const double dy = y - s.y;\n        const double dz = z - s.z;\n        const double d = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - r - s.r;\n        return d < 0 ? 0 : d;\n    }\n};\n\nstruct Edge {\n    int a, b;\n    double cost;\n\n    Edge(int a, int b, double c) : a(a), b(b), cost(c) {}\n\n    bool operator <(const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nbool solve() {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    vector<Sphere> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> nodes[i].x >> nodes[i].y >> nodes[i].z >> nodes[i].r;\n    }\n\n    vector<Edge> edges;\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < i; ++j) {\n            edges.emplace_back(i, j, nodes[i].distance(nodes[j]));\n        }\n    }\n    sort(begin(edges), end(edges));\n\n    DisjointSet ds(N);\n    double ans = 0;\n    for (auto &e : edges) {\n        if(ds.unite(e.a, e.b)) {\n            ans += e.cost;\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\n\n#define max_n 100\n#define max_e (max_n * max_n)\n\ndouble c[max_n][4];\n\ndouble d(int a, int b){\n    double x = c[a][0] - c[b][0];\n    double y = c[a][1] - c[b][1];\n    double z = c[a][2] - c[b][2];\n    double ret = sqrt(x*x + y*y + z*z);\n    ret = ret - c[a][3] - c[b][3];\n    return ret;\n}\n\n\n\n\n\nclass UnionFind{\n\nprivate:\n    vector<int> rank,p;\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n    }\n\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        for(int i = 0; i < size; i++){\n          makeSet(i);\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n      link(find(x), find(y));\n    }\n\n    int find(int x){\n      if(x != p[x]) p[x] = find(p[x]);\n      return p[x];\n    }\n\nprivate:\n    void link(int x, int y){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n      }else{\n        p[x] = y;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\n\n\n\nstruct edge{\n     int u, v;\n     double cost;\n };\n\nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\nedge es[max_e];\nint v,e;\n\ndouble kruskal(){\n    sort(es, es+e, comp);\n    UnionFind uf = UnionFind(v);\n    double ret = 0;\n    int i;\n    rep(i,e){\n        edge ee = es[i];\n        if(!uf.same(ee.u, ee.v)){\n            uf.unite(ee.u, ee.v);\n            if(ee.cost > EPS)ret += ee.cost;\n        }\n    }\n    return ret;\n}\n\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        v = n;\n        e = 0;\n\n        rep(i,n)rep(j,4) cin >> c[i][j];\n        double ans = 0;\n        rep(i,n)rep(j,i){\n            edge ee;\n            ee.u = i;\n            ee.v = j;\n            ee.cost = d(i,j);\n            es[e] = ee;\n            e++;\n        }\n\n        cout << shosu(5) << kruskal() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nint UF[100];\npair<double,pair<int,int> > e[10000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);\n\tb=FIND(b);\n\tif(a==b)return;\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n}\ndouble x[100],y[100],z[100],r[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tUF[i]=-1;\n\t\t\tscanf(\"%lf%lf%lf%lf\",x+i,y+i,z+i,r+i);\n\t\t}\n\t\tint now=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\te[now++]=make_pair(max(0.0,-r[i]-r[j]+sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))),make_pair(i,j));\n\t\t\t}\n\t\t}\n\t\tstd::sort(e,e+now);\n\t\tdouble ret=0;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tif(FIND(e[i].second.first)!=FIND(e[i].second.second)){\n\t\t\t\tUNION(e[i].second.first,e[i].second.second);\n\t\t\t\tret+=e[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-9\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n// start up //\nvoid solve();\nint main() { solve(); return 0; }\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x=0, double y=0, double z=0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x+_.x, y+_.y, z+_.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_,y*_,z*_); }\n\tP3 operator /(double _) const { return P3(x/_,y/_,z/_); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; }\n\tP3 cross(const P3 &_) const { return P3(y*_.z-z*_.y, z*_.x-x*_.z, x*_.y-y*_.x); }\n\tdouble sqlength() const { return x*x+y*y+z*z; }\n\tdouble length() const { return sqrt(sqlength()); }\n\tP3 direction() const { return *this / length(); }\n};\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x,y,z), r(r) { }\n};\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from, int to, double cost) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator > (const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\t\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j,N) if (parent[j] == -1) q.push(Path(i,j,costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i,n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i,n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i,n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss; \n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n/// template end ///\n\nvoid solve()\n{\n\tREP (testcase, INF)\n\t{\n\t\t// よみこみ\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\t\tvector<Sphere> spheres;\n\t\tREP(i,N) { READ(double, x,y,z,r); spheres.push_back(Sphere(x,y,z,r)); }\n\n\t\t// cost[i][j] = 球i - 球j 間に廊下を作った時のコスト表\n\t\tvevector<double> costTable(N, N);\n\t\tREP(i,N) REP(j,N)\n\t\t{\n\t\t\tSphere &si = spheres[i], &sj = spheres[j];\n\t\t\tcostTable[i][j] = max((si.c - sj.c).length() - (si.r + sj.r), 0.0);\n\t\t}\n\n\t\t// 最少全域木\n\t\tdouble totalCost = prim(costTable).first;\n\t\tprintf(\"%.3f\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n#define SIZE 105\n#define INF 1000000005\n//#define INF 1e18\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long double ll;\ntypedef pair <int,int> P;\n\ntypedef tuple <ll,int,int> T;\nstruct edge{int to;ll cost;};\nvector<edge> G[SIZE],M[SIZE];\nbool used[SIZE];\n\n//0_indexed\nll prim(){\n  priority_queue<T,vector<T>,greater<T>> que;\n  fill(used,used+SIZE,false);\n  rep(i,0,SIZE) M[i].clear();\n  ll res = 0;\n  que.push(T(0,0,0));\n  while(!que.empty()){\n    T t = que.top();que.pop();\n    ll l = get<0>(t);\n    int v = get<1>(t);\n    int from = get<2>(t);\n    if(used[v])continue;\n    res += l;\n    used[v] = true;\n    M[v].push_back((edge){from,l});\n    M[from].push_back((edge){v,l});\n    for(edge u : G[v]){\n      if(!used[u.to])que.push(T(u.cost,u.to,v));\n    }\n  }\n  return res;\n}\n\nvoid add_edge(int a,int b,ll c){\n  G[a].push_back((edge){b,c});\n  G[b].push_back((edge){a,c});\n}\n\nint n;\nll x[SIZE],y[SIZE],z[SIZE],r[SIZE];\nint solve(){\n  rep(i,0,SIZE) G[i].clear();\n  cin >> n;\n  if(n==0)return 1;\n  rep(i,0,n){\n    cin >> x[i] >> y[i] >> z[i] >> r[i];\n  }\n  rep(i,0,n) rep(j,i+1,n){\n    ll D = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);\n    if(D <= pow((r[i]+r[j]),2))D=0.0l;\n    else{\n      D = sqrt(D);\n      D -= r[i]+r[j];\n    }\n    add_edge(i,j,D);\n  }\n\n  cout << prim() << endl;\n\n  return 0;\n}\n\nint main(){\n  cout << setprecision(3) << fixed;\n  while(solve()==0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOTCONNECTED 0 // WHITE\n#define CANDIDATE 1 // GRAY\n#define CONNECTED 2 // BLACK\nusing namespace std;\ndouble getDistance(vector<double>, vector<double>);\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<vector<double> > cells;\n    for(int i = 0; i < n; ++i) {\n      double y, x, z, r;\n      cin >> x >> y >> z >> r;\n      cells.push_back(vector<double>({x, y, z, r}));\n    }\n    vector<double> minWeights(n, DBL_MAX); // d\n    minWeights[0] = 0;\n    vector<int> states(n, NOTCONNECTED); // color\n    vector<int> parents(n, -1); // p\n    while(true) {\n      int minv = INT_MAX;\n      int u = -1;\n      for(int i = 0; i < n; ++i) {\n        if(minWeights[i] != DBL_MAX && minv > minWeights[i] && states[i] == NOTCONNECTED) {\n          u = i;\n          minv = minWeights[i];\n        }\n      }\n      if(u == -1) break;\n      states[u] = CONNECTED;\n      for(int v = 0; v < n; ++v) {\n        if(states[v] == NOTCONNECTED && minWeights[v] > getDistance(cells[u], cells[v])) {\n          minWeights[v] = getDistance(cells[u], cells[v]);\n          parents[v] = u;\n          // states[v] = CANDIDATE;\n        }\n      }\n    }\n    double ans = 0;\n    for(int i = 0; i < n; ++i) {\n      if(parents[i] != -1) ans += getDistance(cells[i], cells[parents[i]]);\n    }\n    printf(\"%.3f\", ans);\n    cout << endl;\n  }\n  return 0;\n}\n\ndouble getDistance(vector<double> a, vector<double> b) {\n  double dx = abs(a[0] - b[0]);\n  double dy = abs(a[1] - b[1]);\n  double dz = abs(a[2] - b[2]);\n  double ans = sqrt(pow(dx, 2) + pow(dy, 2) + pow(dz, 2)) - a[3] - b[3];\n  return ans < 0 ? 0.0 : ans;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1127\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint c[100][100];\n\nstruct P{\n    double x,y,z,r;\n    double abs(){\n        return sqrt(x*x+y*y+z*z);\n    }\n};\n\nP operator - (P a,P b){\n    a.x -= b.x;\n    a.y -= b.y;\n    a.z -= b.z;\n    return a;\n}\n\n\n\nint uf[1000];\nint get(int x){\n    return uf[x] = (uf[x]==x?x:get(uf[x]));\n}\nint unite(int x,int y){ uf[get(x)] = get(y); }\n\ndouble calc(P a,P b){\n    return max((a-b).abs()-a.r-b.r,0.);\n    \n}\nint main(){\n    int n;\n    while(cin >> n && n){\n        for(int i = 0 ; i < 1000 ; i++) uf[i] = i;\n        vector<P> pts(n);\n        for(int i = 0 ; i < n ; i++){\n            cin >> pts[i].x >> pts[i].y >> pts[i].z >> pts[i].r;\n        }\n        double ans = 0;\n        vector< pair<double,pair<int,int> > > e;\n        for(int i = 0 ; i < n ; i++){\n            for(int j = 0 ; j < n ; j++){\n                double dist = calc(pts[i],pts[j]);\n                e.push_back(make_pair(dist,make_pair(i,j)));\n            }\n        }\n        sort(e.begin(),e.end());\n        for(int i = 0 ; i < e.size() ; i++){\n            if( get(e[i].second.first) != get(e[i].second.second)){\n                ans += e[i].first;\n                unite(e[i].second.first,e[i].second.second);\n            }\n        }\n        printf(\"%.10lf%c\",ans,10);\n    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j);\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define COST_MAX 1000000.0\nusing namespace std;\n\nstruct Cell{\n  double x, y, z, r;\n};\n\nint main(void) {\n  int n;\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n\n    Cell c[n];\n    for(int i = 0; i < n; i++){\n      cin >> c[i].x >> c[i].y >> c[i].z >> c[i].r;\n    }\n\n    bool visited[n];\n    double cost[n];\n    for(int i = 0; i < n; i++) {\n      visited[i] = false;\n      cost[i] = COST_MAX;\n    }\n    cost[0] = 0.0;\n    while(1) {\n      double min = COST_MAX;\n      int p;\n      for(int i = 0; i < n; i++) {\n\tif(!visited[i] && cost[i] < min) {\n\t  min = cost[i];\n\t  p = i;\n\t}\n      }\n      if(min == COST_MAX) break;\n\n      visited[p] = true;\n      for(int i = 0; i < n; i++) {\n\tif(i == p || visited[i]) continue;\n\tdouble dist = sqrt(pow(c[p].x-c[i].x, 2)+pow(c[p].y-c[i].y, 2)\n\t\t\t   +pow(c[p].z-c[i].z, 2))-(c[p].r+c[i].r);\n\tif(dist < cost[i]) {\n\t  cost[i] = dist;\n\t}\n      }\n    }\n    double ans = 0.0;\n    for(int i = 0; i < n; i++) {\n      if(cost[i] > 0.0) {\n\tans += cost[i];\n      }\n    }\n    printf(\"%.3f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n,q;\n\tdouble x,y,z,r;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",&x,&y,&z,&r),v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j),q++;\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m&&q<n-1;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first,q++;\n\t\tprintf(\"%.3f\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\nclass UnionFindTree{\n\nprivate:\n  // indexツづ個青板づ個親ツノツーツド\n  vector<int> par;\n  // indexツづーツ債ェツづつキツづゥツ姪伉づ個δ可δ督ク\n  vector<int> rank;\n  // ツ姪伉づ個催妥・ツ値\n  int treeSize;\n  \npublic:\n  UnionFindTree(int initTreeSize = 1000){\n     // ツ暗クツ青板づ与ツつヲツづァツづェツつスツ値ツづーツ催妥・ツ格ツ納ツ青板づつキツづゥUnionFindTreeツづ個催ャツ青ャ\n    treeSize = initTreeSize;\n    init();\n  }\n  \n  \n  void init(){\n    \n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n    }\n    \n  }\n\n  // ツ与ツつヲツづァツづェツつスツ青板つェツ格ツ納ツつウツづェツづつ「ツづゥツ姪伉づ個δ仰ーツトツづーツ探ツ催オ\n  int find(int x){\n    \n    if(par[x] == x){\n      return x;\n    }\n    else{\n      return par[x] = find(par[x]);\n    }\n    \n  }\n  \n  void unite(int x,int y){\n    \n    x = find(x);\n    y = find(y);\n    \n    if(x == y)\n      return;\n    \n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x]){\n\trank[x]++;\n      }\n    }\n    \n  }\n  \n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n};\nclass Circle{\npublic:\n\tdouble x,y,z,r;\n\tCircle(){}\n\tCircle(double x_,double y_,double z_,double r_){\n\t\tx=x_;\n\t\ty=y_;\n\t\tz=z_;\n\t\tr=r_;\n\t}\n};\n\nconst int MAX_V = 200;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst int INF = 10000000;\n\ndouble prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\twhile(1){\n\t\tint v = -1;\n\t\t// Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\tif(v == -1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tV=n;\n\t\tvector<Circle> vc;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle c;\n\t\t\tcin>>c.x>>c.y>>c.z>>c.r;\n\t\t\tvc.push_back(c);\n\t\t}\n\t\tUnionFindTree uft(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble dist=(vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z);\n\t\t\t\t// ツ重ツづ按づづつ「ツづゥ\n\t\t\t\tif(EQ(dist,(vc[i].r+vc[j].r)*(vc[i].r+vc[j].r))||(dist<(vc[i].r+vc[j].r)*(vc[i].r+vc[j].r))){\n\t\t\t\t\tuft.unite(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ重ツづ按づづつ「ツづゥツづÍRXg0Ìm[hð£ÁÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(uft.same(i,j)){\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble dist=sqrt((vc[i].x-vc[j].x)*(vc[i].x-vc[j].x)\n\t\t\t\t\t\t+(vc[i].y-vc[j].y)*(vc[i].y-vc[j].y)\n\t\t\t\t\t\t+(vc[i].z-vc[j].z)*(vc[i].z-vc[j].z));\n\t\t\t\t\tcost[i][j]=dist-(vc[i].r+vc[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res=prim();\n\t\tprintf(\"%.5f\\n\",res);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//using Graph = vector<vector<edge>>;\nusing dou =long double;\nstring yes=\"yes\";\nstring Yes=\"Yes\";\nstring YES=\"YES\";\nstring no=\"no\";\nstring No=\"No\";\nstring NO=\"NO\";\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n#define rep(i, n)         for(int i = 0; i < (int)(n); i++)\n#define brep(n)           for(int bit=0;bit<(1<<n);bit++)\n#define erep(i,container) for (auto i : container)\n#define irep(i, n)        for(int i = n-1; i >= (int)0; i--)\n#define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++)\n#define reprep(i,j,h,w) rep(i,h)rep(j,w)\n#define all(x) (x).begin(),(x).end()\n#define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i];\n#define pb push_back\n#define pf push_front\n#define query int qq;std::cin >> qq;rep(qqq,qq)\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define itn int\n#define mp make_pair\n#define sum(a) accumulate(all(a),0ll)\n#define keta fixed<<setprecision\n#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a)));\n#define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) ));\n#define case std::cout <<\"Case #\" <<qqq+1<<\": \"\n#define RES(a,i,j) a.resize(i);rep(ii,i)a[ii].resize(j); \n#define as assign\n#define ffor for(;;)\n#define ppri(a,b) std::cout << a<<\" \"<<b << std::endl\n#define pppri(a,b,c) std::cout << a<<\" \"<<b <<\" \"<< c<<std::endl\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n#define ssum(a) accumulate(a,0ll) \n#define gre(n) greater<n>()\n\ntypedef long long ll;\ntypedef pair<dou,int> P;\ntypedef pair<ll,ll> PL;\n//typedef long long T;\nconst int INF = 1000000000;\nconst ll INF64 = 922337203685477580ll;\nconst ll MOD = 1000000007ll;\nconst dou pi=3.141592653589793;\n//メモ\n//二次元配列のresizeのしかた\n\n//vv.resize(n);\n//for(size_t i=0; i<n; i++){\n// vv[i].resize(n);\n//}\n\n//メモ\n//負の辺を持つ最短経路問題では到達不可経路でも初期化値より小さくなりうるので注意しよう！\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\nstruct edge{\n    int from,to;\n    dou dist;\n    edge(int from,int to,dou dist):\n     from(from),to(to),dist(dist){}\n};\nstruct Edge{\n    int to;\n    dou dist;\n    Edge(int to,dou dist):\n     to(to),dist(dist){}\n};\nstd::vector<vector<Edge>> ki;\nstd::vector<edge> g;\nstd::vector<int> dum;\ndou ans;\nvoid Kruscal(int v,int e){\n    ans=0;\n    UnionFind u(v);\n    priority_queue<P,std::vector<P>,greater<P>> q;\n    rep(i,e){\n        q.push(mp(g[i].dist,i));\n    }\n    rep(i,e){\n        int p=q.top().se;\n        if(!u.same(g[p].from,g[p].to)){\n            u.unite(g[p].from,g[p].to);\n            ki[g[p].from].pb(Edge(g[p].to,g[p].dist));\n            ki[g[p].to].pb(Edge(g[p].from,g[p].dist));\n            dum.pb(g[p].dist);\n            ans+=g[p].dist;\n        }\n        q.pop();\n    }\n}\ndouble ww(double a,double b){\n    return (a-b)*(a-b);\n}\ndouble www(double a,double b,double c,double d,double e,double f,double dd,double ddd){\n    return max(0.0,sqrt(ww(a,d)+ww(b,e)+ww(c,f))-(dd+ddd));\n}\nint main(){\n    ffor{\n        itn n;\n        std::cin >> n;\n        if(n==0)break;\n        ki.resize(n);\n        std::vector<dou> x(n),y(n),z(n),d(n);\n        rep(i,n)std::cin >> x[i]>>y[i]>>z[i]>>d[i];\n        reprep(i,j,n,n){\n            g.pb(edge(i,j,www(x[i],y[i],z[i],x[j],y[j],z[j],d[i],d[j])));\n        }\n        Kruscal(n,g.size());\n        std::cout <<keta(3)<< ans << std::endl;\n        g.clear();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\t\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\t\n\tinline bool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn false;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\n\t\treturn true;\n\t}\n};\ntypedef double weight;\n\nstruct edge {\n\tint u, v;\n\tweight cost;\n\tedge(int u, int v, weight c):u(u), v(v), cost(c){}\n\n\tbool operator< (const edge& o) const {\n\t\treturn cost < o.cost;\n\t}\n};\n\nint n;\nvector<edge> es;\n\nweight kruskal() {\n\tsort(es.begin(), es.end());\n\tunion_find uf(n);\n\n\tweight res = 0;\n\tfor(int i = 0; i < (int)es.size(); ++i)\n\t\tif(uf.unite(es[i].u, es[i].v))\n\t\t\tres += es[i].cost;\n\n\treturn res;\n}\n\ninline weight dist(weight x1, weight y1, weight z1, weight x2, weight y2, weight z2) {\n\tconst weight dx = x1 - x2, dy = y1 - y2, dz = z1 - z2;\n\treturn sqrtl(dx * dx + dy * dy + dz * dz);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tvector<weight> x(n), y(n), z(n), r(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tscanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &z[i], &r[i]);\n\n\t\tes.clear();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tconst weight cost = max<weight>(0.0, dist(x[i], y[i], z[i], x[j], y[j], z[j]) - r[i] - r[j]);\n\t\t\t\tes.push_back(edge(i, j, cost));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.3lf\\n\", kruskal());\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_E = 200*100;\nconst int MAX_N = 200;\n\nstruct UnionFind\n{\n  int par[MAX_N];\n  int rank[MAX_N];\n\n  void init(int n){\n    for(int i = 0; i < n; ++i){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++; \n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\nstruct Edge {\n  int u, w;\n  double cost;\n};\nbool comp(const Edge &e1, const Edge &e2)\n{\n  return e1.cost < e2.cost;\n}\n\nEdge es[MAX_E]; \nint v, e; \n\nint main()\n{\n  for(;;){\n    int n;\n    scanf(\"%d\",&n);\n    if(n==0)return 0;\n    double data[n][4];\n    e = n*(n-1)/2;\n    v = n;\n    \n    UnionFind uf;\n    uf.init(n*(n-1)/2);\n\n    for(int i=0;i<n;i++){\n      cin >> data[i][0] >> data[i][1] >> data[i][2] >> data[i][3];\n    }\n\n    int count=0;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tEdge et;\n\tet.u=i;\n\tet.w=j;\n\tdouble length = sqrt(((data[i][0]-data[j][0])*(data[i][0]-data[j][0]))+((data[i][1]-data[j][1])*(data[i][1]-data[j][1]))+((data[i][2]-data[j][2])*(data[i][2]-data[j][2])))-data[i][3]-data[j][3];\n\tif(length<0.0){\n\t  uf.unite(i,j);\n\t  length=0.0;\n\t}\n\tet.cost=length;\n\tes[count++]=et;\n      }\n    }\n    \n    //printf(\"A:%d %d\\n\",count,e);\n\n    sort(es,es+e,comp);\n    double ans = 0.0;\n\n    for(int i = 0; i < e; ++i){\n      Edge et = es[i];\n      //printf(\"B:%f\\n\",et.cost);\n      if(!uf.same(et.u, et.w)){\n\tuf.unite(et.u, et.w); \n\tans += et.cost; \n      }\n    }\n    \n    printf(\"%.3f\\n\",ans);\n\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nstruct UF{\n\tvector<int> par;\n\tint n;\n\tUF(int size){\n\t\tn = size;\n\t\tpar = vector<int>(n);\n\t\trep(i, n) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tpar[find(x)] = find(y);\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main(){\n\tauto sq = [](double x){return x*x; };\n\n\tcout.setf(ios::fixed);\n\tcout.precision(3);\n\n\tint n;\n\twhile (cin >> n){\n\t\tvector<double> x(n), y(n), z(n), r(n);\n\t\trep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i];\n\n\t\tvector<tuple<double, int, int>> edge;\n\t\trep(i, n) rep(j, i){\n\t\t\tdouble len = sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n\t\t\tlen -= r[i] + r[j];\n\t\t\tlen = max(len, 0.);\n\t\t\tedge.push_back(MT(len, i, j));\n\t\t}\n\t\tsort(ALL(edge));\n\n\t\tUF uf(n);\n\n\t\tdouble ans = 0;\n\t\tfor (auto e : edge){\n\t\t\tdouble cost;\n\t\t\tint s, t;\n\t\t\ttie(cost, s, t) = e;\n\t\t\tif (uf.same(s, t)) continue;\n\t\t\tuf.unite(s, t);\n\t\t\tans += cost;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n \n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n \nll n;\nstruct tup{\n\tdouble x,y,z;\n\ttup(){}\n\ttup(double _x,double _y,double _z):x(_x),y(_y),z(_z){}\n};\n\ndouble dis(tup a,tup b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\tdouble z = a.z - b.z;\n\treturn sqrt(x*x + y*y + z*z);\n}\n\nstruct edge{ \n\tll to;\n\tdouble cost; \n\tedge(ll _to,double _cost):to(_to),cost(_cost){};\n};\n\nvector<edge> G[110];\ndouble mincost[110];\nbool used[110];\n\ndouble prim(){\n\tdouble res = 0.0;\n\trep(i,110){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\ttypedef pair<double,ll> PD;\n\tpriority_queue<PD, vector<PD>, greater<PD>> que;\n\tque.push(PD(0.0, 0));\n\n\twhile (que.size()){\n\t\tPD p = que.top(); \n\t\tque.pop();\n\t\tdouble cost = p.first;\n\t\tll v = p.second;\n\t\tif (used[v])continue;\n\t\tused[v] = 1;\n\t\tmincost[v] = cost;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\tque.push(PD(e.cost, e.to));\n\t\t}\n\t}\n\trep(i,n)res += mincost[i];\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n && n){\n\t\trep(i,n)G[i].clear();\n\t\tvector<tup> v(n);\n\t\tvector<double> r(n);\n\t\trep(i,n)cin >> v[i].x >> v[i].y >> v[i].z >> r[i];\n\t\trep(i,n){\n\t\t\tFOR(j,i+1,n){\n\t\t\t\tdouble dd = max(dis(v[i],v[j]) - r[i] - r[j],0.0);\n\t\t\t\tG[i].push_back(edge(j,dd));\n\t\t\t\tG[j].push_back(edge(i,dd));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\",prim());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1127\n#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double real;\nconst int NMAX = 200;\nconst real INF = 1e9;\nint n;\nreal x[NMAX],y[NMAX],z[NMAX], r[NMAX];\nreal mincost[NMAX];\nreal d[NMAX][NMAX];\nbool used[NMAX];\n\nreal sq(real x) {return x*x;}\n\nreal distance(int i, int j) {\n  real d2 = sq(x[i]-x[j])+sq(y[i]-y[j])+sq(z[i]-z[j]);\n  if (d2 > sq(r[i] + r[j])) {\n    return sqrt(d2) - r[i] - r[j];\n  } else {\n    return 0;\n  }\n}\n\nvoid init() {\n  REP(i, n) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  REP(i,n) REP(j,n) {\n    d[i][j] = INF;\n  }\n\n  REP(i, n + 10) {\n    x[i] = y[i] = z[i] = 0;\n  }\n}\n\nreal solve() {\n  REP(i,n) REP(j,n) {\n    d[i][j] = distance(i, j);\n  }\n\n  mincost[0] = 0;\n  real res = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < n; u++) {\n      if (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if (v == -1) break;\n\n    used[v] = true;\n    res += mincost[v];\n\n    for (int u = 0; u < n; u++) {\n      mincost[u] = min(mincost[u], d[v][u]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (cin >> n and n) {\n    init();\n    REP(i, n) {\n      cin >> x[i] >> y[i] >> z[i] >> r[i];\n    }\n    printf(\"%.3Lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst double EPS = 1e-8;\n\ntemplate<typename T> T chmax(T& a, const T& b){return a = (a > b ? a : b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = (a < b ? a : b);}\n\nstruct UF{ //O(loga(n))\n    int n;\n    int m;\n    vi d, r;\n    UF(int n) : n(n), m(n), d(n, -1), r(n, 0){};\n    int root(int i){\n        if(d[i] < 0) return i;\n        return d[i] = root(d[i]);\n    }\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return false;\n\n        if(r[x] < r[y]) swap(x, y);\n        else if(r[x] == r[y]) r[x]++;\n        d[x] += d[y];\n        d[y] = x;\n        --m;\n        return true;\n    }\n    int size(int i){\n        return -d[root(i)];\n    }\n    int size() {\n        return m;\n    }\n};\n\nusing D = double;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    if(n == 0) exit(0);\n    using Point = tuple<D, D, D>;\n    using Sphere = tuple<Point, D>;\n    auto calcDist = [&](const Point& a, const Point& b){\n        D x1, y1, z1; tie(x1, y1, z1) = a; \n        D x2, y2, z2; tie(x2, y2, z2) = b;\n        return (D)sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)); \n    };\n    auto calcDist2 = [&](const Sphere& a, const Sphere& b){\n        Point p1, p2;\n        D r1, r2;\n        tie(p1, r1) = a;\n        tie(p2, r2) = b;\n        return max((D)0, calcDist(p1, p2) - r1 - r2);\n    };\n    vector<Sphere> s(n);\n    rep(i, n) {\n        D x, y, z, r;\n        cin >> x >> y >> z >> r;\n        auto p = tie(x, y, z);\n        s[i] = tie(p, r);\n    }\n    using E = tuple<D, int, int>;\n    vector<E> es;\n    rep(i, n) rep(j, i) {\n        auto d = calcDist2(s[i], s[j]);\n        es.emplace_back(d, i, j);\n    }\n    sort(all(es));\n    UF uf(n);\n    D ans = 0;\n    for(auto&& e: es) {\n        int x, y;\n        D d;\n        tie(d, x, y) = e;\n        if(uf.same(x, y)) continue;\n        ans += d;\n        uf.unite(x, y);\n        // cout << \" \" << x << \" \" << y << \" \" << d << endl;\n    }\n    cout << ans << '\\n';\n\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(3);\n    while(1) solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100];\nint n,m,MX=(1<<20),a,b,c,t,mn,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\n// distance i, j\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt( (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) + (z[i] - z[j])*(z[i] - z[j]) ) - (r[i] + r[j]);\n\n  if (ret < 0) ret = 0;\n\n  return ret;\n}\n\nint main() {\n  double res = 0;\n\n  while(1) {\n    cin >> n;\n    if (n == 0) break;\n\n    for(int i=0; i < n; i++) {\n      cin >> x[i]; cin >> y[i]; cin >> z[i]; cin >> r[i];\n    }\n\n    // init p, d, visited, map, res\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tmap[i][j] = MX;\n      }\n      p[i] = -1;\n      d[i] = MX;\n      visited[i] = 0;\n    }\n    res = 0;\n\n    // distance between 2 cells\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tif (i == j){\n\t  map[i][j] = 0;\n\t} else {\n\t  map[i][j] = compute(i, j);\n\t}\n      }\n    }\n    \n    d[0] = 0;\n    t = 0;\n    while(1){\n      mn = MX;\n      // Renew target\n      for (int i = 0; i < n; i++) {\n\tif (d[i] < mn && visited[i] == 0) {\n\t  mn = d[i];\n\t  t  = i;\n\t}\n      }\n\n      if ( mn == MX ) break;\n\n      visited[t] = 1;\n      res += d[t];\n      //if (p[t] != -1) res += map[t][p[t]];\n      //printf(\"res: %.3f\\n\", res);\n\n      //\n      for(int v = 0; v < n; v++){\n\tif(map[t][v] < d[v] && visited[v] == 0){\n\t  d[v] = map[t][v];\n\t  p[v] = t;\n\t}\n      }\n    }\n    printf(\"%.3f\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j);\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m++].second=m;\n\t\t}\n\t\tsort(node,node+m);\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=node[i].first;\n\t\tcout<<fixed<<setprecision(3)<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#define MAX_CELL 100\n#define INF 1000000\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1127: Building a Space Station\n// 2017.9.19 bal4u@uu\n// 2017.11.23\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define R 10\nlong long x[101], y[101], z[101], r[101];\nchar f[101];\n\nchar buf[100], *p;\n\nlong long dbl2int()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tif (*p == '.') p++;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n << R;\n}\n\nlong long dist(long long dx, long long dy, long long dz)\n{\n\treturn (long long)sqrt((double)(dx*dx + dy*dy + dz*dz));\n}\n\nint main()\n{\n    int i, j, n, cnt, nx;\n\tlong long ans, min, d;\n\n    while (fgets(buf, 10, stdin) && *buf != '0') {\n\t\tn = atoi(buf);\n\t\tmemset(f, 0, n);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tx[i] = dbl2int(), p++, y[i] = dbl2int(), p++, z[i] = dbl2int(), p++, r[i] = dbl2int();\n\t\t}\n        ans = 0, f[1] = 1, cnt = 1;\n        while (cnt < n) {\n            for (nx = -1, min = 1LL<<60, i = 0; i < n; i++) {\n                if (f[i] == 0) continue;\n                for (j = 0; j < n; j++) {\n                    if (f[j]) continue;\n\t\t\t\t\td = dist(x[i]-x[j], y[i]-y[j], z[i]-z[j]) - (r[i]+r[j]);\n\t\t\t\t\tif (nx < 0 || d < min) min = d, nx = j;\n                }\n            }\n            f[nx] = 1, cnt++; if (min > 0) ans += min;\n        }\n\t\tans = (ans+512) >> R;\n        printf(\"%lld.%03lld\\n\", ans/1000, ans%1000);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\n// typedef struct {\n// \tint parent, rank;\n// } Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\n// Node node[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint uniteSame( int x, int y ) {\n\tint xSet = find( x ), ySet = find( y );\n\n\tif ( xSet == ySet )\n\t\treturn 0;\n\n\tnode[ ySet ] = xSet;\n\n\treturn 1;\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ )\n\t\tnode[ i ] = i;\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( uniteSame( edge[ i ].from, edge[ i ].to ) )\n\t\t\tsum += edge[ i ].weight;\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint parent[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\nint find( int x ) {\n\tif ( parent[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn parent[ x ] = find( parent[ x ] );\n}\n\nvoid unite( int x, int y ) {\n\tparent[ find( y ) ] = find( x );\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ )\n\t\tparent[ i ] = i;\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( find( edge[ i ].from ) != find( edge[ i ].to ) ) {\n\t\t\tunite( edge[ i ].from, edge[ i ].to );\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( hypot( hypot( coord[ i ].x - coord[ j ].x, coord[ i ].y - coord[ j ].y ), coord[ i ].z - coord[ j ].z ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, cnt ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define UNION_FIND_MAX 100\n\nint uf_table[UNION_FIND_MAX];\n\nvoid uf_init(void) {\n\tint i;\n\tfor(i=0;i<UNION_FIND_MAX;i++)uf_table[i]=0;\n}\n\nvoid uf_merge(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\tif(a!=b)uf_table[a]=b+1;\n}\n\nint uf_issame(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\treturn a==b;\n}\n\ntypedef struct {\n\tint from,to;\n\tdouble cost;\n} edge_t;\n\ntypedef struct {\n\tdouble x,y,z,r;\n} node_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst edge_t* a=(const edge_t*)x;\n\tconst edge_t* b=(const edge_t*)y;\n\tif((a->cost)>(b->cost))return 1;\n\tif((a->cost)<(b->cost))return -1;\n\treturn 0;\n}\n\nint n;\nnode_t node[100];\nedge_t edge[10000];\n\nint main(void) {\n\tint i,j,p,c;\n\tdouble result;\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf%lf\",\n\t\t\t&node[i].x,&node[i].y,&node[i].z,&node[i].r);\n\t\tp=0;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\tedge[p].from=i;\n\t\t\t\tedge[p].to=j;\n\t\t\t\tedge[p].cost=sqrt(\n\t\t\t\t\t(node[i].x-node[j].x)*(node[i].x-node[j].x)+\n\t\t\t\t\t(node[i].y-node[j].y)*(node[i].y-node[j].y)+\n\t\t\t\t\t(node[i].z-node[j].z)*(node[i].z-node[j].z)\n\t\t\t\t)-node[i].r-node[j].r;\n\t\t\t\tif(edge[p].cost<=0)edge[p].cost=0;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tqsort(edge,p,sizeof(edge_t),qsort_comp);\n\t\tc=1;\n\t\tresult=0;\n\t\tuf_init();\n\t\tfor(i=0;i<p && c<n;i++) {\n\t\t\tif(!uf_issame(edge[i].from,edge[i].to)) {\n\t\t\t\tc++;\n\t\t\t\tresult+=edge[i].cost;\n\t\t\t\tuf_merge(edge[i].from,edge[i].to);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  //  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "//kruskal tree\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,j,k,m,n;\n\tdouble x,y,z,r;\n\tfor(;cin>>n,n;){\n\t\tvector<vector<double> >v;\n\t\tfor(i=0;i<n;i++)cin>>x>>y>>z>>r,v.push_back({x,y,z,r});\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(m=i=0;i<n;i++)for(j=i+1;j<n;j++){\n\t\t\tfor(x=k=0;k<3;k++)x+=(v[i][k]-v[j][k])*(v[i][k]-v[j][k]);\n\t\t\tx=sqrt(x)-v[i][3]-v[j][3];\n\t\t\tif(x<=0)unite(i,j);\n\t\t\telse a[m]=i,b[m]=j,node[m].first=x,node[m].second=m++;\n\t\t}\n\t\tsort(node,node+m);\n\n\t\tfor(x=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))x+=std::max(.0,node[i].first);\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#define MAX_CELL 100\n#define INF 1000000\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "/**********************\n*@Name:\n*\n*@Author: Nervending\n*@Describtion:\n*@DateTime: 2017-10-16 19:48:25\n***********************/\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\nconst int maxn=1e2+10;\nconst int maxm=1e4+1000;\nint root[maxn];\nstruct node {\n\tint from,to;\n\tdouble cost;\n}e[maxm];\nbool cmp (node &a,node &b){\n\treturn a.cost<b.cost;\n}\nint find (int a){\n\tif(root[a]==a)return a;\n\telse return root[a]=find(root[a]);\n}\n#define same(a,b) (find(a)==find(b))\nvoid unite(int a,int b){\n\ta=find(a);\n\tb=find(b);\n\troot[a]=b;\n}\ndouble x[maxn],y[maxn],z[maxn],r[maxn];\nint n,m,nume;\ndouble ans;\nvoid init(){\n\tmemset(e,0,sizeof e);\n\tfor(int i=0;i<maxn;i++){\n\t\troot[i]=i;\n\t}\n\tans=0;\n\tnume=0;\n}\nvoid kruskal(){\n\tfor(int i=0;i<nume;i++){\n\t\tint a=e[i].from,b=e[i].to;\n\t\tif(!same(a,b)){\n\t\t\tunite(a,b);\n\t\t\tans+=e[i].cost;\n\t\t}\n\t}\n}\ndouble dst(int a,int b){\n\tdouble dx=(x[a]-x[b]);\n\tdouble dy=(y[a]-y[b]);\n\tdouble dz=(z[a]-z[b]);\n\tdouble d=sqrt(dx*dx+dy*dy+dz*dz);\n\tdouble dr=r[a]+r[b];\n\tif(d>=dr)return d-dr;\n\telse return -1;\n}\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\twhile(~scanf(\"%d\",&n)&&n){\n\t\tinit();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x[i],&y[i],&z[i],&r[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdouble cost=dst(i,j);\n\t\t\t\tif(cost>0){\n\t\t\t\t\tnode t={i,j,cost};\n\t\t\t\t\te[nume++]=t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnode t={i,j,0};\n\t\t\t\t\te[nume++]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(e,e+nume,cmp);\n\t\tkruskal();\n\t\tprintf(\"%.3lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint parent, rank;\n} Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nNode node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ].parent == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ].parent = find( node[ x ].parent );\n}\n\nvoid unite( int x, int y ) {\n\tint xRoot = find( x ), yRoot = find( y );\n\n\tif ( node[ xRoot ].rank < node[ yRoot ].rank )\n\t\tnode[ xRoot ].parent = yRoot;\n\telse {\n\t\tnode[ yRoot ].parent = xRoot;\n\t\tif ( node[ xRoot ].rank == node[ yRoot ].rank )\n\t\t\tnode[ xRoot ].rank++;\n\t}\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ ) {\n\t\tnode[ i ].parent = i;\n\t\tnode[ i ].rank = 0;\n\t}\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( find( edge[ i ].from ) != find( edge[ i ].to ) ) {\n\t\t\tunite( edge[ i ].from, edge[ i ].to );\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tnode[ i ] = i;\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tnode[ set2 ] = set1;\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ndouble cost[101][101];\ndouble mincost[101];\nbool used[101];\ndouble x[101], y[101], z[101], r[101];\ndouble INF = numeric_limits<double>::max();\nint main(void){\n    int n;\n    while(cin >> n && n) {\n        rep(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        rep(i, n) rep(j, n) {\n            cost[i][j] = max(sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j], 0.0);\n        }\n        // prim\n        rep(i, n) {\n            mincost[i] = INF;\n            used[i] = false;\n        }\n        mincost[0] = 0;\n        double res = 0;\n\n        while(true) {\n            int v = -1;\n            rep(u, n) {\n                if(!used[u] && (v==-1 || mincost[u] < mincost[v])) v = u;\n            }\n            if(v == -1) break;\n            used[v] = true;\n            res += mincost[v];\n\n            rep(u, n) {\n                mincost[u] = min(mincost[u], cost[v][u]);\n            }\n        }\n        printf(\"%.3lf\\n\", res);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n\n  UnionFind(int n) : par(n), rank(n, 1) {\n    for(int i=0; i<n; ++i) par[i] = i;\n  }\n\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) swap(x, y);\n    par[y] = x;\n    rank[x] += rank[y];\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n};\n\ntypedef double Cost;\n\nstruct edge{\n    int src, dst; Cost cost;\n    edge(int s, int t, Cost c) : src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost < rhs.cost;}\n};\n\nCost kruskal(int V, vector<edge> &edges) {\n    UnionFind uf(V);\n    sort(edges.begin(), edges.end());\n    Cost ans = 0;\n    for(auto e : edges) {\n        if(!uf.same(e.src, e.dst)) {\n            uf.unite(e.src, e.dst);\n            ans += e.cost;\n        }\n    }\n    return ans;\n}\n\nint main(void) {\n    int n;\n    while(cin >> n && n) {\n        vector<double> x(n), y(n), z(n), r(n);\n        vector<edge> edges;\n        REP(i, n) {\n            cin >> x[i] >> y[i] >> z[i] >> r[i];\n        }\n        REP(i, n)  {\n            REP(j, n) {\n                if(i == j) continue;\n                double c = sqrt(pow(x[i]-x[j], 2.0) + pow(y[i]-y[j], 2.0) + pow(z[i]-z[j], 2.0)) - r[i] - r[j];\n                edges.push_back(edge(i, j, max(0.0, c)));\n            }\n        }\n        printf(\"%.3f\\n\", kruskal(n, edges));\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n#include <math.h> // sqrt\n\n#define BUF_SIZE 50\n\nint get_int(void) {\n  int num;\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return 0;\n  sscanf(line, \"%d\", &num);\n#else\n#error\n#endif\n  return num;\n}\n\nint get_double4(double *a1, double *a2, double *a3, double *a4) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%lf %lf %lf %lf\", a1, a2, a3, a4);\n#else\n#error\n#endif\n  return 0;\n}\n\nstruct point3d {\n    double x;\n    double y;\n    double z;\n};\n\nstruct cell {\n    struct point3d center;\n    double radius;\n};\n\n#define CELLS_MAX 100\n#define EDGES_MAX (CELLS_MAX*(CELLS_MAX-1))\n#define SET_MAX 10000\n\nstruct edge {\n    int idx1;\n    int idx2;\n    double dist;\n};\n\ndouble get_dist(struct point3d *p1, struct point3d *p2) {\n    struct point3d diff = {\n        p1->x - p2->x,\n        p1->y - p2->y,\n        p1->z - p2->z\n    };\n    return sqrt(diff.x*diff.x + diff.y*diff.y + diff.z*diff.z);\n}\n\nint asc(const void *a1, const void *a2) {\n    struct edge *e1 = (struct edge*)a1;\n    struct edge *e2 = (struct edge*)a2;\n    if(e1->dist > e2->dist) return 1;\n    if(e1->dist == e2->dist) return 0;\n    if(e1->dist < e2->dist) return -1;\n    return 0;\n}\n\nstruct ufind {\n    int parent;\n    int depth;\n};\n\nstruct ufind *create_union_find() {\n    static struct ufind ufind[CELLS_MAX];\n    int i;\n    // initialization\n    for(i = 0; i < CELLS_MAX; i++) {\n        ufind[i].parent = i;\n        ufind[i].depth = 1;\n    }\n    return ufind;\n\n}\n\nint get_root(struct ufind *ufind, int idx) {\n    struct ufind *v = &ufind[idx];\n    int base = idx;\n    while(base != v->parent) {\n        base = v->parent;\n        v = &ufind[base];\n    }\n    return base;\n}\n\nint is_same(struct ufind *ufind, int v1, int v2) {\n    return get_root(ufind, v1) == get_root(ufind, v2);\n}\n\nvoid _connect(struct ufind *ufind, int v1, int v2) {\n    int b1 = get_root(ufind, v1);\n    int b2 = get_root(ufind, v2);\n    struct ufind *root1 = &ufind[b1];\n    struct ufind *root2 = &ufind[b2];\n    if(root1->depth >= root2->depth) {\n        if(root1->depth == root2->depth) root1->depth++;\n        root2->depth = root1->depth;\n        root2->parent = b1;\n    } else {\n        root1->depth = root2->depth;\n        root1->parent = b2;\n    }\n    return;\n}\n\nint main(void) {\n    static double ans[SET_MAX] = {0};\n    int ans_idx = 0;\n    static struct cell cells[CELLS_MAX];\n    static struct edge edges[EDGES_MAX];\n    int eidx = 0;\n    int i, j;\n    while(1) {\n        // initialziation\n        memset(cells, 0, sizeof(struct cell)*CELLS_MAX);\n        memset(edges, 0, sizeof(struct edge)*EDGES_MAX);\n        eidx = 0;\n\n        int cs = get_int();\n        if(!cs) break;\n        for(i = 0; i < cs; i++) {\n            get_double4(\n                &cells[i].center.x,\n                &cells[i].center.y,\n                &cells[i].center.z,\n                &cells[i].radius\n            );\n        }\n        for(i = 0; i < cs; i++) {\n            for(j = i+1; j < cs; j++) {\n                double dist = get_dist(&cells[i].center, &cells[j].center) - cells[i].radius - cells[j].radius;\n                // 2 cells can be touching each other or overlapping.\n                struct edge e = {i, j, dist <= 0 ? 0 : dist};\n#ifdef DEBUG\n                printf(\"(%d, %d) -> %lf\\n\", i, j, dist);\n#endif\n                edges[eidx++] = e;\n            }\n        }\n        qsort(edges, eidx, sizeof(struct edge), asc);\n        struct ufind *ufind = create_union_find();\n\n        double res = 0;\n        int cnt = 0;\n        // Kruskal algorithm\n        for(i = 0; i < eidx; i++) {\n            int v1 = edges[i].idx1;\n            int v2 = edges[i].idx2;\n            if(!is_same(ufind, v1, v2)) {\n                _connect(ufind, v1, v2);\n                res += edges[i].dist;\n                cnt++;\n            }\n            // If it gets tree, finish\n            if(cnt == cs-1) break;\n        }\n        ans[ans_idx++] = res;\n    }\n\n    // presentation part\n    for(i = 0; i < ans_idx; i++) {\n        printf(\"%.3lf\\n\", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#define MAX_CELL 100\n#define INF 1000000\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\ndouble square(double x)\n{\n  return x * x;\n}\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(square(cells[a].x - cells[b].x) + square(cells[a].y - cells[b].y) + square(cells[a].z - cells[b].z));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n}\n\nint main(void)\n{\n  int n, j, i;\n\n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint parent[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\nint find( int x ) {\n\tif ( parent[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn parent[ x ] = find( parent[ x ] );\n}\n\nvoid union( int x, int y ) {\n\tparent[ find( y ) ] = find( x );\n}\n\nint kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ )\n\t\tparent[ i ] = i;\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( find( edge[ i ].from ) != find( edge[ i ].to ) ) {\n\t\t\tunion( edge[ i ].from, edge[ i ].to );\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( hypot( hypot( coord[ i ].x - coord[ j ].x, coord[ i ].y - coord[ j ].y ), coord[ i ].z - coord[ j ].z ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, cnt ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nvoid unite( int x, int y ) {\n\tnode[ find( y ) ] = find( x );\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ )\n\t\tnode[ i ] = i;\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( find( edge[ i ].from ) != find( edge[ i ].to ) ) {\n\t\t\tunite( edge[ i ].from, edge[ i ].to );\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint parent, rank;\n} Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nNode node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ].parent == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ].parent = find( node[ x ].parent );\n}\n\nint uniteSame( int x, int y ) {\n\tint xSet = find( x ), ySet = find( y );\n\n\tif ( xSet == ySet )\n\t\treturn 0;\n\n\tif ( node[ xSet ].rank < node[ ySet ].rank )\n\t\tnode[ xSet ].parent = ySet;\n\telse {\n\t\tnode[ ySet ].parent = xSet;\n\t\tif ( node[ xSet ].rank == node[ ySet ].rank )\n\t\t\tnode[ xSet ].rank++;\n\t}\n\n\treturn 1;\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ ) {\n\t\tnode[ i ].parent = i;\n\t\tnode[ i ].rank = 0;\n\t}\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( uniteSame( edge[ i ].from, edge[ i ].to ) )\n\t\t\tsum += edge[ i ].weight;\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tnode[ i ] = i;\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tnode[ set2 ] = set1;\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define INF 1e+10\n\nint n;\ndouble x[100],y[100],z[100],r[100];\ndouble dist[100][100];\n\ndouble max(double a,double b){\n\treturn a<b?b:a;\n}\ndouble min(double a,double b){\n\treturn a<b?a:b;\n}\ndouble square(double x){\n\treturn x*x;\n}\ndouble distance(int a,int b){\n\tdouble d = sqrt(square(x[a]-x[b])+square(y[a]-y[b])+square(z[a]-z[b]));\n\treturn max(0.0 ,d-r[a]-r[b]);\n}\ndouble prime(){\n\tint i,cur=0,count=1;\n\tint used[100];\n\tdouble res=0,mind[100], mi;\n\tfor(i=0;i<n;i++)mind[i]=INF;\n\tfor(i=0;i<n;i++)used[i]=0;\n\tused[cur]=1;\n\twhile(count<n){\n\t\tfor(i=0;i<n;i++)mind[i] = min(mind[i], dist[cur][i]);\n\t\tmi = INF;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(!used[i] && mind[i]<mi){\n\t\t\t\tmi = mind[i];\n\t\t\t\tcur = i;\n\t\t\t}\n\t\t}\n\t\tres += mi;\n\t\tused[cur] = 1;\n\t\tcount++;\n\t}\n\treturn res;\n} \nint main(){\n\tint i,j;\n\twhile(scanf(\"%d\",&n)==1&&n){\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%lf %lf %lf %lf\",x+i,y+i,z+i,r+i);\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++)dist[i][j]=dist[j][i]=distance(i,j);\n\t\t}\n\t\tprintf(\"%.3f\\n\",prime());\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint parent, rank;\n} Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nNode node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ].parent == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ].parent = find( node[ x ].parent );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ ) {\n\t\t\tnode[ i ].parent = i;\n\t\t\tnode[ i ].rank = 0;\n\t\t}\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tif ( node[ set1 ].rank < node[ set2 ].rank )\n\t\t\t\t\tnode[ set1 ].parent = set2;\n\t\t\t\telse {\n\t\t\t\t\tnode[ set2 ].parent = set1;\n\t\t\t\t\tif ( node[ set1 ].rank == node[ set2 ].rank )\n\t\t\t\t\t\tnode[ set1 ].rank++;\n\t\t\t\t}\n\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#define MAX_CELL 100\n#define INF 1000000\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    return 0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n}\n\nint main(void)\n{\n  int n, j, i;\n\n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3f\\n\", prim(n));\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint parent, rank;\n} Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nNode node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ].parent == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ].parent = find( node[ x ].parent );\n}\n\nvoid unite( int x, int y ) {\n\tint xRoot = find( x ), yRoot = find( y );\n\n\tif ( node[ xRoot ].rank < node[ yRoot ].rank )\n\t\tnode[ xRoot ].parent = yRoot;\n\telse {\n\t\tnode[ yRoot ].parent = xRoot;\n\t\tif ( node[ xRoot ].rank == node[ yRoot ].rank )\n\t\t\tnode[ xRoot ].rank++;\n\t}\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ ) {\n\t\tnode[ i ].parent = i;\n\t\tnode[ i ].rank = 0;\n\t}\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( find( edge[ i ].from ) != find( edge[ i ].to ) ) {\n\t\t\tunite( edge[ i ].from, edge[ i ].to );\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MM\t100000000.0\nint main(void)\n{\n\tint n,i,j,k;\n\tdouble x[100],y[100],z[100],r[100];\n\tdouble a[100][100],rr;\n\tint flg[100],mink;\n\tdouble leng,min;\n\t\n\twhile(1)\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\tbreak;\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\tscanf(\"%lf %lf %lf %lf\",&x[i],&y[i],&z[i],&r[i]);\n\t\t}\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\tfor(j=0;j<n;j++)\t{\n\t\t\t\trr=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\trr=rr-r[i]-r[j];\n\t\t\t\tif(rr<0)\trr=0.0;\n\t\t\t\ta[i][j]=rr;\n\t\t\t}\n\t\t\tflg[i]=0;\n\t\t}\n\t\t\n\t\tleng=0.0;\n\t\tflg[0]=1;\n\t\tfor(i=0;i<n-1;i++)\t{\n\t\t\tmin=MM;\n\t\t\tfor(j=0;j<n;j++)\t{\n\t\t\t\tif(flg[j]==1)\t{\n\t\t\t\t\tfor(k=0;k<n;k++)\t{\n\t\t\t\t\t\tif(flg[k]==0 && min>a[j][k])\t{\n\t\t\t\t\t\t\tmin=a[j][k];\n\t\t\t\t\t\t\tmink=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tflg[mink]=1;\n//\t\t\tprintf(\"min=%lf mink=%d\\n\",min,mink);\n\t\t\tleng+=min;\n\t\t}\n\t\tprintf(\"%.3lf\\n\",leng);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nvoid unite( int x, int y ) {\n\tnode[ find( y ) ] = find( x );\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ )\n\t\tnode[ i ] = i;\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ )\n\t\tif ( find( edge[ i ].from ) != find( edge[ i ].to ) ) {\n\t\t\tunite( edge[ i ].from, edge[ i ].to );\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( hypot( hypot( coord[ i ].x - coord[ j ].x, coord[ i ].y - coord[ j ].y ), coord[ i ].z - coord[ j ].z ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tnode[ i ] = i;\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tnode[ set2 ] = set1;\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#define MAX_CELL 100\n#define INF 1000000\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n}\n\nint main(void)\n{\n  int n, j, i;\n\n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3f\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\ntypedef struct st{int s,t;double d;}st;\nint N,U[100],i,j,k;\ndouble P[100][4],R;\nst D[110];\nint s(const void *a,const void *b)\n{\n\treturn ((st*)a)->d-((st*)b)->d>0;\n}\nint pa(int n){return U[n]!=n?pa(U[n]):n;};\nint eq(int a,int b){return pa(a)==pa(b);}\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%lf%lf%lf%lf\",&P[i][0],&P[i][1],&P[i][2],&P[i][3]);\n\t\tfor(i=k=0;i<N-1;i++)\n\t\t\tfor(j=i+1;j<N;j++)\n\t\t\t{\n\t\t\t\tdouble *p=P[i],*q=P[j],d;\n\t\t\t\td=sqrt((p[0]-q[0])*(p[0]-q[0])+(p[1]-q[1])*(p[1]-q[1])+(p[2]-q[2])*(p[2]-q[2]));\n\t\t\t\td=d<p[3]+q[3]?0:d-p[3]-q[3];\n\t\t\t\tD[k].s=i;\n\t\t\t\tD[k].t=j;\n\t\t\t\tD[k].d=d;\n\t\t\t\tk++;\n\t\t\t}\n\t\tqsort(D,k,sizeof(st),s);\n\t\tfor(i=0;i<N;i++)U[i]=i;\n\t\tfor(i=R=0;i<k;i++)\n\t\t{\n\t\t\tif(!eq(D[i].s,D[i].t))\n\t\t\t{\n\t\t\t\tU[pa(D[i].s)]=pa(D[i].t);\n\t\t\t\tR+=D[i].d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tnode[ i ] = i;\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; n && i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tnode[ set2 ] = set1;\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\n// typedef struct {\n// \tint parent, rank;\n// } Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\n// Node node[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\ndouble kruskal( int v, int e ) {\n\tint i;\n\tdouble sum;\n\n\tqsort( edge, e, sizeof(Edge), &compare );\n\n\tfor ( i = 0; i < v; i++ )\n\t\tnode[ i ] = i;\n\n\tsum = 0.0;\n\tfor ( i = 0; i < e; i++ ) {\n\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\t\tif ( set1 != set2 ) {\n\t\t\tnode[ set2 ] = set1;\n\t\t\tsum += edge[ i ].weight;\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint main( void ) {\n\tint i, j;\n\tint n, cnt;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tprintf( \"%.3f\\n\", kruskal( n, n * ( n - 1 ) / 2 ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\ntypedef struct st{int s,t;double d;}st;\nint N,U[100],i,j,k;\ndouble P[100][4],R;\nst D[10005];\nint s(const void *a,const void *b){return ((st*)a)->d-((st*)b)->d>0;}\nint pa(int n){return U[n]!=n?pa(U[n]):n;};\nint eq(int a,int b){return pa(a)==pa(b);}\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%lf%lf%lf%lf\",&P[i][0],&P[i][1],&P[i][2],&P[i][3]);\n\t\tfor(i=k=0;i<N-1;i++)\n\t\t\tfor(j=i+1;j<N;j++)\n\t\t\t{\n\t\t\t\tdouble *p=P[i],*q=P[j],d;\n\t\t\t\td=sqrt((p[0]-q[0])*(p[0]-q[0])+(p[1]-q[1])*(p[1]-q[1])+(p[2]-q[2])*(p[2]-q[2]));\n\t\t\t\td=d<p[3]+q[3]?0:d-p[3]-q[3];\n\t\t\t\tD[k].s=i;\n\t\t\t\tD[k].t=j;\n\t\t\t\tD[k].d=d;\n\t\t\t\tk++;\n\t\t\t}\n\t\tqsort(D,k,sizeof(st),s);\n\t\tfor(i=0;i<N;i++)U[i]=i;\n\t\tfor(i=R=0;i<k;i++)\n\t\t{\n\t\t\tif(!eq(D[i].s,D[i].t))\n\t\t\t{\n\t\t\t\tU[pa(D[i].s)]=pa(D[i].t);\n\t\t\t\tR+=D[i].d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\ntypedef struct st{int s,t;double d;}st;\nint N,U[100],i,j,k;\ndouble P[100][4],R;\nst D[10005];\nint s(const void *a,const void *b)\n{\n\treturn ((st*)a)->d-((st*)b)->d>0;\n}\nint pa(int n){return U[n]!=n?pa(U[n]):n;};\nint eq(int a,int b){return pa(a)==pa(b);}\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%lf%lf%lf%lf\",&P[i][0],&P[i][1],&P[i][2],&P[i][3]);\n\t\tfor(i=k=0;i<N-1;i++)\n\t\t\tfor(j=i+1;j<N;j++)\n\t\t\t{\n\t\t\t\tdouble *p=P[i],*q=P[j],d;\n\t\t\t\td=sqrt((p[0]-q[0])*(p[0]-q[0])+(p[1]-q[1])*(p[1]-q[1])+(p[2]-q[2])*(p[2]-q[2]));\n\t\t\t\td=d<p[3]+q[3]?0:d-p[3]-q[3];\n\t\t\t\tD[k].s=i;\n\t\t\t\tD[k].t=j;\n\t\t\t\tD[k].d=d;\n\t\t\t\tk++;\n\t\t\t}\n\t\tqsort(D,k,sizeof(st),s);\n\t\tfor(i=0;i<N;i++)U[i]=i;\n\t\tfor(i=R=0;i<k;i++)\n\t\t{\n\t\t\tif(!eq(D[i].s,D[i].t))\n\t\t\t{\n\t\t\t\tU[pa(D[i].s)]=pa(D[i].t);\n\t\t\t\tR+=D[i].d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lf\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tdouble x = coord[ i ].x - coord[ j ].x, y = coord[ i ].y - coord[ j ].y, z = coord[ i ].z - coord[ j ].z;\n\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( x * x + y * y + z * z ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tnode[ i ] = i;\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tnode[ set2 ] = set1;\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1127: Building a Space Station\n// 2017.9.19 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-7\n#define INF 1e7\ntypedef struct { double x, y, z, r; char f; } PP;\nPP pp[105];\n\nint main()\n{\n    int i, j, n, cnt, nx;\n\tdouble ans, min, d;\n\tPP  *p, *q;\n\n    while (scanf(\"%d\", &n) && n) {\n\t\tfor (i = 0; i < n; i++) \n\t\t\tscanf(\"%lf%lf%lf%lf\", &pp[i].x, &pp[i].y, &pp[i].z, &pp[i].r), pp[i].f = 0;\n        ans = 0, pp[0].f = 1, cnt = 1;\n        while (cnt < n) {\n            for (nx = -1, min = INF, p = pp, i = 0; i < n; i++, p++) {\n                if (p->f == 0) continue;\n                for (q = pp, j = 0; j < n; j++, q++) {\n                    if (q->f) continue;\n                    d = sqrt((p->x-q->x)*(p->x-q->x) + (p->y-q->y)*(p->y-q->y) +\n\t\t\t\t\t\t(p->z-q->z)*(p->z-q->z)) - (p->r+q->r);\n\t\t\t\t\tif (nx < 0 || d + EPS < min) min = d, nx = j;\n                }\n            }\n            pp[nx].f = 1, cnt++; if (min > EPS) ans += min;\n        }\n        printf(\"%.3lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nint node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ] == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ] = find( node[ x ] );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( hypot( hypot( coord[ i ].x - coord[ j ].x, coord[ i ].y - coord[ j ].y ), coord[ i ].z - coord[ j ].z ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tnode[ i ] = i;\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tnode[ set2 ] = set1;\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x, y, z, r;\n} Coord;\n\ntypedef struct {\n\tint parent, rank;\n} Node;\n\ntypedef struct {\n\tint from, to;\n\tdouble weight;\n} Edge;\n\nCoord coord[ 100 ];\nNode node[ 100 ];\nEdge edge[ 4950 ];\n\nint compare( const void *a, const void *b ) {\n\tdouble at = (*(Edge *)a).weight, bt = (*(Edge *)b).weight;\n\n\tif ( at < bt )\n\t\treturn -1;\n\tif ( at > bt )\n\t\treturn 1;\n\treturn 0;\n}\n\nint find( int x ) {\n\tif ( node[ x ].parent == x )\n\t\treturn x;\n\telse\n\t\treturn node[ x ].parent = find( node[ x ].parent );\n}\n\nint main( void ) {\n\tint i, j;\n\tint n;\n\n\twhile ( scanf( \"%d\", &n ), n ) {\n\t\tint cnt;\n\t\tdouble sum;\n\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tscanf( \"%lf %lf %lf %lf\", &coord[ i ].x, &coord[ i ].y, &coord[ i ].z, &coord[ i ].r );\n\n\t\tcnt = 0;\n\t\tfor ( i = 0; i < n; i++ )\n\t\t\tfor ( j = i + 1; j < n; j++ ) {\n\t\t\t\tedge[ cnt ].from = i;\n\t\t\t\tedge[ cnt ].to = j;\n\t\t\t\tedge[ cnt ].weight = fmax( sqrt( ( coord[ i ].x - coord[ j ].x ) * ( coord[ i ].x - coord[ j ].x ) + ( coord[ i ].y - coord[ j ].y ) * ( coord[ i ].y - coord[ j ].y ) + ( coord[ i ].z - coord[ j ].z ) * ( coord[ i ].z - coord[ j ].z ) ) - coord[ i ].r - coord[ j ].r, 0.0 );\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tqsort( edge, cnt, sizeof(Edge), &compare );\n\n\t\tfor ( i = 0; i < n; i++ ) {\n\t\t\tnode[ i ].parent = i;\n\t\t\tnode[ i ].rank = 0;\n\t\t}\n\n\t\tsum = 0.0;\n\t\tfor ( i = 0; n && i < cnt; i++ ) {\n\t\t\tint set1 = find( edge[ i ].from ), set2 = find( edge[ i ].to );\n\n\t\t\tif ( set1 != set2 ) {\n\t\t\t\tif ( node[ set1 ].rank < node[ set2 ].rank )\n\t\t\t\t\tnode[ set1 ].parent = set2;\n\t\t\t\telse {\n\t\t\t\t\tnode[ set2 ].parent = set1;\n\t\t\t\t\tif ( node[ set1 ].rank == node[ set2 ].rank )\n\t\t\t\t\t\tnode[ set1 ].rank++;\n\t\t\t\t}\n\n\t\t\t\tsum += edge[ i ].weight;\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.3f\\n\", sum );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1127\n   Building a Space Station\n*/\n\n#include<stdio.h>\n#include<math.h>\n#include<limits.h>\n#define MAX_CELL 100\n#define INF INT_MAX\n\ntypedef struct cell\n{\n  double x, y, z, r;\n}cell;\n\ncell cells[MAX_CELL];\ndouble cost[MAX_CELL][MAX_CELL];\ndouble mincost[MAX_CELL];\nint used[MAX_CELL];\n\n\n\n\ndouble calc_cost(int a, int b)\n{\n  double dis = sqrt(pow(cells[a].x - cells[b].x, 2.0) + pow(cells[a].y - cells[b].y, 2.0) + pow(cells[a].z - cells[b].z, 2.0));\n  double r_dis = dis - (cells[a].r + cells[b].r);\n  \n  if(r_dis > 0)\n    return r_dis;\n  else\n    0.0;\n}\n\nvoid make_edge(int n)\n{\n  int i, j;\n\n  for(i = 0; i < n; i++)\n    for(j = 0; j < n; j++)\n      cost[i][j] = calc_cost(i, j);\n}\n\ndouble min(double a, double b)\n{\n  if(a < b)\n    return a;\n  else\n    return b;\n}\n\ndouble prim(int n)\n{\n  int i;\n  double res = 0.0;\n  for(i = 0; i < n; i++)\n    {\n      mincost[i] = INF;\n      used[i] = 0;\n    }\n\n  mincost[0] = 0;\n\n  while(1)\n    {\n      int v = -1, u;\n      for(u = 0; u < n; u++)\n\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t  v = u;\n       \n      if (v == -1) break;\n      used[v] = 1;\n      res += mincost[v];\n      for(u = 0; u < n; u++)\n\tmincost[u] = min(mincost[u], cost[v][u]);\n    }\n  return res;\n\n}\n\nint main(void)\n{\n  int n, j, i;\n  \n  while(scanf(\"%d\", &n), n != 0)\n    {\n      for(i = 0; i < n; i++)\n\tscanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n\n      make_edge(n);\n\n      printf(\"%.3lf\\n\", prim(n));\n    }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdouble[][] stations = new double[n][4];\n\t\t\tfor (int i = 0; i < stations.length; i++) {\n\t\t\t\tstations[i][0] = sc.nextDouble();\n\t\t\t\tstations[i][1] = sc.nextDouble();\n\t\t\t\tstations[i][2] = sc.nextDouble();\n\t\t\t\tstations[i][3] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tPriorityQueue<Edge> edges = new PriorityQueue<Edge>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble x1 = stations[i][0];\n\t\t\t\t\tdouble x2 = stations[j][0];\n\t\t\t\t\tdouble y1 = stations[i][1];\n\t\t\t\t\tdouble y2 = stations[j][1];\n\t\t\t\t\tdouble z1 = stations[i][2];\n\t\t\t\t\tdouble z2 = stations[j][2];\n\t\t\t\t\tdouble r1 = stations[i][3];\n\t\t\t\t\tdouble r2 = stations[j][3];\n\n\t\t\t\t\tdouble dist = Math.sqrt(Math.pow((x1 - x2), 2)\n\t\t\t\t\t\t\t+ Math.pow((y1 - y2), 2) + Math.pow((z1 - z2), 2))\n\t\t\t\t\t\t\t- r1 - r2;\n\t\t\t\t\tdist = Math.max(dist, 0);\n\t\t\t\t\tedges.add(new Edge(dist, i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tdouble cost = 0;\n\t\t\twhile (!edges.isEmpty()) {\n\t\t\t\tEdge e = edges.poll();\n\t\t\t\tif (!uf.same(e.from, e.to)) {\n\t\t\t\t\tcost += e.weight;\n\t\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(cost);\n\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tint[] par;\n\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpar[i] = i;\n\t}\n\n\tpublic int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tpublic Boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tpublic void unite(int x, int y) {\n\t\tif (find(x) == find(y))\n\t\t\treturn;\n\t\tpar[find(x)] = find(y);\n\t}\n}\n\nclass Edge implements Comparable<Edge> {\n\tdouble weight;\n\tint from, to;\n\n\tEdge(double w, int f, int t) {\n\t\tthis.weight = w;\n\t\tthis.from = f;\n\t\tthis.to = t;\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge edge) {\n\t\t// 昇順\n\t\tif (this.weight > edge.weight) {\n\t\t\treturn 1;\n\t\t} else if (this.weight == edge.weight) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run(){\n\t\tlong all = sc.nextLong();\n\t\tlong n = sc.nextLong();\n\t\tlong m = sc.nextLong();\n\t\t\n\t\tlong[] aida = new long[(int) all+1];\n\t\tlong now = 0;\n\t\tlong last;\n\t\tlong first;\n\t\t\n\t\tlong l = sc.nextLong();\n\t\tfirst = l - now -1;\n\t\tnow = l;\n\t\t\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tl = sc.nextLong();\n\t\t\taida[(int)(l - now - 1)]++;\n\t\t\tnow = l;\n\t\t}\n\t\tlast = all - now;\n\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tlong x = sc.nextLong();\n\t\t\tlong y = sc.nextLong();\n\t\t\tlong between = x + y;\n\t\t\tlong sum = n;\n\t\t\t\n\t\t\tlong sumTemp = 0;\n\t\t\tfor(int k = 1; k < between; k++){\n\t\t\t\tif(k > all + 1) break;\n\t\t\t\tlong a = aida[k];\n\t\t\t\tsum += k * a;\n\t\t\t\tsumTemp += a;\n\t\t\t}\n\t\t\tif(n - 1 - sumTemp > 0) sum += (n - 1 - sumTemp) * between;\n\t\t\t\n\t\t\tif((first - x) >= 0) sum += x;\n\t\t\telse sum += first;\n\t\t\tif((last - y) >= 0) sum += y;\n\t\t\telse sum += last;\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] z = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tArrayList<Edge> graph = new ArrayList<Edge>();\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\tdouble dist = Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])+(z[j]-z[i])*(z[j]-z[i])) - r[i] - r[j];\n\t\t\t\t\tif (dist<0) {\n\t\t\t\t\t\tdist = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgraph.add(new Edge(dist,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(graph);\n\t\t\t//System.out.println(graph.toString());\n\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tdouble ans = 0;\n\t\t\tint connected = 1;\n\t\t\tfor(int i=0;i<graph.size();i++) {\n\t\t\t\tEdge e = graph.get(i);\n\t\t\t\tif (!uf.isConnected(e.from, e.to)) {\n\t\t\t\t\tuf.union(e.from, e.to);\n\t\t\t\t\tconnected++;\n\t\t\t\t\tans+=e.cost;\n\t\t\t\t\tif (connected==n) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"%.3f\\n\", ans);\n\t\t}\n\t}\n\n}\nclass Edge implements Comparable<Edge>{\n\tdouble cost;\n\tint from;\n\tint to;\n\tpublic Edge(double cost,int from,int to) {\n\t\tthis.cost = cost;\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\tif (this.cost == o.cost) {\n\t\t\treturn 0;\n\t\t}else if(this.cost > o.cost) {\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\treturn this.cost + \",\" + this.from + \",\" + this.to;\n\t}\n}\n\nclass UnionFind {\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tpublic void union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\ndouble x[100], y[100], z[100], r[100],sum,mn,maxd=99999999.9;\nint n,m,mx=(1<<20),a,b,c,t,hozon;\ndouble map[100][100];\ndouble sumcor;\nint p[100];\ndouble d[100];\nint visited[100];\n\ndouble compute(int i, int j) {\n  double ret;\n\n  ret = sqrt((x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) + (z[i]-z[j]) * (z[i]-z[j]));\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    for(int i=0;i<n;i++) {\n      cin>>x[i]; cin>>y[i]; cin>>z[i]; cin>>r[i];\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tmap[i][j]=maxd;\n      }\n      p[i]=0;\n      d[i]=maxd;\n      visited[i]=0;\n    }\n    \n    for(int i=0; i<n; i++) {\n      for(int j=0; j<n; j++) {\n\tif(i==j) continue;\n\tmap[i][j] = compute(i, j);\n\tmap[i][j]-=(r[i]+r[j]);\n\tif(map[i][j]<0)map[i][j]=0;\n      }\n    }\n\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\t//\tcout<<map[i][j]<<endl;\n      }\n    }\n    \n    sumcor=0.0;\n    d[0]=0.0;\n    while(1){\n      mn=maxd;\n      for(int i=0;i<n;i++){\n\tif(d[i]<mn&&visited[i]==0){\n\t  mn=d[i];\n\t  t=i;\n\t}\n      }\n      if(mn==maxd)break;\n      visited[t]=1;\n      for(int v=0;v<n;v++){\n\tif(map[t][v]<d[v]&&visited[v]==0){\n\t  d[v]=map[t][v];\n\t  p[v]=t;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)if(map[i][p[i]]!=maxd)sumcor+=map[i][p[i]];\n    printf(\"%4.3f\\n\",sumcor);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.*;\n\npublic class Main {\n\tstatic final long MOD=1000000007;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\twhile (true) {\n\t\t\tint V=sc.nextInt();\n\t\t\tif (V==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x=new double[V];\n\t\t\tdouble[] y=new double[V];\n\t\t\tdouble[] z=new double[V];\n\t\t\tdouble[] r=new double[V];\n \t\t\tMinimumSpanningTree minimumSpanningTree=new MinimumSpanningTree(V);\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tx[i]=sc.nextDouble();\n\t\t\t\ty[i]=sc.nextDouble();\n\t\t\t\tz[i]=sc.nextDouble();\n\t\t\t\tr[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < z.length; i++) {\n\t\t\t\tfor (int j = i+1; j < z.length; j++) {\n\t\t\t\t\tminimumSpanningTree.addEdge(i, j, Math.max(getdist(x[i], y[i], z[i], x[j], y[j], z[j], r[i], r[j]),0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tBigDecimal bDecimal=new BigDecimal(minimumSpanningTree.getMiniWeight());\n\t\t\tout.println(bDecimal.setScale(3, RoundingMode.HALF_UP));\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic double getdist(double x1,double y1,double z1,double x2,double y2,double z2,double r1,double r2) {\n\t\treturn Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2, 2)+Math.pow(z1-z2, 2))-r1-r2;\n\t}\n\tstatic class MinimumSpanningTree{\n\t\tpublic PriorityQueue<Pair2> priorityQueue;\n\t\tpublic int V;\n\t\tpublic UnionFindTree unionFindTree;\n\t\tpublic MinimumSpanningTree(int V) {\n\t\t\tpriorityQueue=new PriorityQueue<>();\n\t\t\tthis.V=V;\n\t\t\tunionFindTree=new UnionFindTree(V); \n\t\t}\n\t\tpublic void addEdge(int a,int b,double w) {\n\t\t\tpriorityQueue.offer(new Pair2(a, b, w));\n\t\t}\n\t\tpublic double getMiniWeight() {\n\t\t\tdouble sum=0;\n\t\t\twhile (!priorityQueue.isEmpty()) {\n\t\t\t\tPair2 pair2=priorityQueue.poll();\n\t\t\t\tif (unionFindTree.same(pair2.x, pair2.y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsum+=pair2.z;\n\t\t\t\tunionFindTree.union(pair2.x, pair2.y, 0);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tpublic class UnionFindTree{\n\t    \tint[] par;\n\t    \tint[] rank;\n\t    \tint[] size;\n\t    \tint[] diff_weight;\n\t    \tint arraysize;\n\t    \tpublic UnionFindTree(int n) {\n\t    \t\tthis.par=new int[n];\n\t    \t\tthis.rank=new int[n];\n\t    \t\tthis.size=new int[n];\n\t    \t\tthis.diff_weight=new int[n];\n\t    \t\tarraysize=n;\n\t    \t\tfor (int i = 0; i < arraysize; i++) {\n\t\t\t\t\tset(i);\n\t\t\t\t}\n\t    \t}\n\t    \tpublic void set(int i) {\n\t    \t\tpar[i]=i;\n\t    \t\trank[i]=0;\n\t    \t\tsize[i]=1;\n\t    \t\tdiff_weight[i]=0;\n\t    \t}\n\t    \tpublic void union(int x,int y,int w) {\n\t    \t\tw += weight(x); \n\t    \t\tw -= weight(y);\n\t    \t\tint rootx=find(x);\n\t    \t\tint rooty=find(y);\n\t    \t\tif (rootx==rooty) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t    \t\tif (rank[rootx]>rank[rooty]) {\n\t\t\t\t\tpar[rooty]=rootx;\n\t\t\t\t\tdiff_weight[rooty] = w;\n\t\t\t\t\tsize[rootx]+=size[rooty];\n\t\t\t\t}\n\t    \t\telse if (rank[rootx]<rank[rooty]) {\n\t\t\t\t\tpar[rootx]=rooty;\n\t\t\t\t\tw=-w;\n\t\t\t\t\tdiff_weight[rootx] = w;\n\t\t\t\t\tsize[rooty]+=size[rootx];\n\t\t\t\t}\n\t    \t\telse {\n\t    \t\t\tpar[rooty]=rootx;\n\t    \t\t\tdiff_weight[rooty] = w;\n\t    \t\t\trank[rootx]++;\n\t\t\t\t\tsize[rootx]+=size[rooty];\n\t\t\t\t}\n\t    \t}\n\t    \tpublic int find(int x) {\n\t    \t\tif(par[x] == x) return x;\n\t    \t\tint r = find(par[x]);\n\t    \t\tdiff_weight[x] += diff_weight[par[x]];\n\t    \t\treturn par[x] = r;\n\t    \t}\n\t    \tpublic int weight(int x) {\n\t    \t\tfind(x);\n\t    \t\treturn diff_weight[x];\n\t    \t}\n\t    \tpublic int size(int i) {\n\t            return size[find(i)];\n\t        }\n\t    \tpublic int diff(int x, int y) {\n\t    \t\treturn weight(y) - weight(x);\n\t    \t}\n\t    \tpublic boolean same(int x, int y) {\n\t            return find(x) == find(y);\n\t        }\n\t    }\n\t\tpublic class Pair2 implements Comparable<Pair2>{\n\t    \tpublic int x;\n\t    \tpublic int y;\n\t    \tpublic double z;\n\t    \tpublic Pair2(int x,int y,double z) {\n\t    \t\tthis.x=x;\n\t    \t\tthis.y=y;\n\t    \t\tthis.z=z;\n\t    \t}\n\t    \t@Override\n\t    \tpublic boolean equals(Object obj) {\n\t    \t\tif(obj instanceof Pair2) {\n\t    \t\t\tPair2 other = (Pair2) obj;\n\t    \t\t\treturn other.x==this.x && other.y==this.y&& other.z==this.z;\n\t    \t\t}\n\t    \t\treturn false;\n\t    \t}//同値の定義\n\t    \t@Override\n\t    \tpublic int hashCode() {\n\t    \t\treturn Objects.hash(this.x,this.y,this.z);\n\t    \t}//これ書かないと正しく動作しない（要　勉強）\n\t    \t@Override\n\t    \tpublic int compareTo( Pair2 p2 ){\n\t    \t\tif (this.z>p2.z) {\n\t    \t\t\treturn 1;\n\t    \t\t}\n\t    \t\telse if (this.z<p2.z) {\n\t    \t\t\treturn -1;\n\t    \t\t}\n\t    \t\telse {\n\t    \t\t\treturn 0;\n\t    \t\t}\n\t    \t}\n\t    }\n\t}\n\t\n\t\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main {\n\tstatic HashMap<String, String[]> groups;\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tCell[] cell = new Cell[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble z = sc.nextDouble();\n\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\tcell[i] = new Cell(x, y, z, r);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Isle> arr = new ArrayList<Isle>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdouble xx = sq(cell[i].x - cell[j].x);\n\t\t\t\t\tdouble yy = sq(cell[i].y - cell[j].y);\n\t\t\t\t\tdouble zz = sq(cell[i].z - cell[j].z);\n\t\t\t\t\t// System.out.println(xx + \" \" + yy + \" \" + zz);\n\t\t\t\t\tdouble dist = Math.sqrt(xx + yy + zz) - Math.abs(cell[i].r + cell[j].r);\n\t\t\t\t\tdist = Math.max(0, dist);\n\t\t\t\t\t// System.out.println(i + \" \" + j + \" \" + dist);\n\t\t\t\t\tIsle isle = new Isle(i, j, dist);\n\t\t\t\t\tarr.add(isle);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(arr, new IsleComp());\n\t\t\t\n\t\t\tint nn = arr.size();\n\t\t\tdouble ans = 0;\n\t\t\tUnionFindTree uft = new UnionFindTree(nn+1);\n\t\t\tfor (int i = 0; i < nn; i++) {\n\t\t\t\tIsle isle = arr.get(i);\n\t\t\t\t// System.out.println(isle);\n\t\t\t\tif(uft.same(isle.x, isle.y)) continue;\n\t\t\t\tans += isle.dist;\n\t\t\t\tuft.unite(isle.x, isle.y);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n}\n\nclass Cell {\n\tdouble x, y, z, r;\n\n\tpublic Cell(double x, double y, double z, double r) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.r = r;\n\t}\n}\n\nclass Isle {\n\tint x, y;\n\tdouble dist;\n\tpublic Isle(int x, int y, double dist) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.dist = dist;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn x + \" \" + y + \" \" + dist;\n\t}\n}\n\nclass IsleComp implements Comparator<Isle> {\n\t@Override\n\tpublic int compare(Isle a, Isle b) {\n\t\tif(a.dist == b.dist){\n\t\t\treturn 0;\n\t\t}else if(a.dist > b.dist){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\n/**\n * UnionFindTree \n * @author yoshikyoto\n */\nclass UnionFindTree {\n\tpublic int[] parent, rank;\n\tpublic int n;\n\tpublic int count;\n\n\t// 初期化\n\tUnionFindTree(int n) {\n\t\tthis.n = n;\n\t\tcount = n;\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\t// 根を求める\n\tint find(int x) {\n\t\tif (parent[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\t// xとyの集合を結合\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) {\n\t\t\treturn;\n\t\t}\n\t\tif (rank[x] < rank[y]) {\n\t\t\tparent[x] = y;\n\t\t\tcount--;\n\t\t} else {\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t// xとyが同じ集合か\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\t\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\t\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\t\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\t\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\t\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\t    \n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Building a Space Station\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tPoint[] points = new Point[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdouble x = scanner.nextDouble();\n\t\t\t\tdouble y = scanner.nextDouble();\n\t\t\t\tdouble z = scanner.nextDouble();\n\t\t\t\tdouble r = scanner.nextDouble();\n\t\t\t\tpoints[i] = new Point(x, y, z, r);\n\t\t\t}\n\t\t\tdouble[][] costs = new double[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tdouble d = points[i].distance(points[j]);\n\t\t\t\t\tcosts[i][j] = d;\n\t\t\t\t}\n\t\t\tboolean[] selected = new boolean[n];\n\t\t\tArrays.fill(selected, false);\n\t\t\tselected[0] = true;\n\t\t\tdouble result = 0;\n\t\t\twhile (!trueAll(selected)) {\n\t\t\t\tdouble cost = Double.MAX_VALUE;\n\t\t\t\tint dst = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (selected[i]) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif (!selected[j] && cost > costs[i][j]) {\n\t\t\t\t\t\t\t\tcost = costs[i][j];\n\t\t\t\t\t\t\t\tdst = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult += cost;\n\t\t\t\tselected[dst] = true;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.3f\", result);\n\t\t\tSystem.out.println();\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic boolean trueAll(boolean[] selected) {\n\t\tboolean result = true;\n\t\tfor (boolean b : selected) {\n\t\t\tresult = result && b;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nclass Point {\n\tdouble x, y, z, r;\n\n\tPoint(double tx, double ty, double tz, double tr) {\n\t\tx = tx;\n\t\ty = ty;\n\t\tz = tz;\n\t\tr = tr;\n\t}\n\n\tpublic double distance(Point anotherPoint) {\n\t\tdouble dx = this.x - anotherPoint.x;\n\t\tdouble dy = this.y - anotherPoint.y;\n\t\tdouble dz = this.z - anotherPoint.z;\n\t\tdouble d2 = Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2);\n\t\tdouble d = Math.sqrt(d2);\n\t\tdouble cost = d - this.r - anotherPoint.r;\n\t\treturn Math.max(cost, 0);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E implements Comparable<E> {\n\t\tdouble v;\n\t\tint a;\n\t\tint b;\n\n\t\tE(double vv, int aa, int bb) {\n\t\t\tv = vv;\n\t\t\ta = aa;\n\t\t\tb = bb;\n\t\t}\n\n\t\tpublic int compareTo(E tar) {\n\t\t\treturn v - tar.v > 0 ? 1 : -1;\n\t\t}\n\t}\n\n\tclass S {\n\t\tdouble x;\n\t\tdouble y;\n\t\tdouble z;\n\t\tdouble r;\n\n\t\tS(double xx, double yy, double zz, double rr) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tz = zz;\n\t\t\tr = rr;\n\t\t}\n\n\t\tdouble dist(S t) {\n\t\t\tdouble xx = x - t.x;\n\t\t\tdouble yy = y - t.y;\n\t\t\tdouble zz = z - t.z;\n\t\t\tdouble dd = xx * xx + yy * yy + zz * zz;\n\t\t\tdouble d = Math.sqrt(dd);\n\n\t\t\tdouble r2 = r + t.r;\n\n\t\t\tif (r2 < d) {\n\t\t\t\treturn  d-r2;\n\t\t\t}\n\t\t\tif (r > t.r) {\n\t\t\t\tif (d + t.r < r) {\n//\t\t\t\t\treturn r - t.r-d;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tif (d + r < t.r) {\n//\t\t\t\t\treturn t.r - d-r;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdouble d[][] = new double[n][n];\n\t\t\tS[] s = new S[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ts[i] = new S(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i][i] = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble dd = s[i].dist(s[j]);\n\t\t\t\t\td[i][j] = dd;\n\t\t\t\t\td[j][i] = dd;\n\t\t\t\t\tq.add(new E(dd,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(Arrays.deepToString(d));\n\t\t\tint data[] = new int[n];\n\t\t\tint ne = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor (;;) {\n\t\t\t\tE now = q.poll();\n\t\t\t\tif(data[now.a] != 0 && data[now.b] == data[now.a] ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tne++;\n\t\t\t\tif((data[now.a] | data[now.b]) == 0){\n\t\t\t\t\tdata[now.a] = ne;\n\t\t\t\t\tdata[now.b] = ne;\n\t\t\t\t}\n\t\t\t\tif(data[now.a] == 0){\n\t\t\t\t\tdata[now.a] = data[now.b];\n\t\t\t\t}\n\t\t\t\tif(data[now.b] == 0){\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i =0 ; i< n ;i++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i!= now.b && data[i] == data[now.b]){\n\t\t\t\t\t\t\tdata[i]= data[now.a];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}\n\t\t\t\tsum += now.v;\n\t\t\t\tif(ne == n-1){\n//\t\t\t\t\tSystem.out.println(Arrays.toString(data));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = (int)(sum * 1000 + 0.5);\n\t\t\t\n\t\t\tSystem.out.print((res /1000));\n\t\t\tSystem.out.printf(\".%03d\\n\",(res %1000));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main {\n\tstatic HashMap<String, String[]> groups;\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tCell[] cell = new Cell[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble z = sc.nextDouble();\n\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\tcell[i] = new Cell(x, y, z, r);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Isle> arr = new ArrayList<Isle>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdouble xx = sq(cell[i].x - cell[j].x);\n\t\t\t\t\tdouble yy = sq(cell[i].y - cell[j].y);\n\t\t\t\t\tdouble zz = sq(cell[i].z - cell[j].z);\n\t\t\t\t\t// System.out.println(xx + \" \" + yy + \" \" + zz);\n\t\t\t\t\tdouble dist = Math.sqrt(xx + yy + zz) - Math.abs(cell[i].r + cell[j].r);\n\t\t\t\t\tdist = Math.max(0, dist);\n\t\t\t\t\t// System.out.println(i + \" \" + j + \" \" + dist);\n\t\t\t\t\tIsle isle = new Isle(i, j, dist);\n\t\t\t\t\tarr.add(isle);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(arr, new IsleComp());\n\t\t\t\n\t\t\tint nn = arr.size();\n\t\t\tdouble ans = 0;\n\t\t\tUnionFindTree uft = new UnionFindTree(nn+1);\n\t\t\tfor (int i = 0; i < nn; i++) {\n\t\t\t\tIsle isle = arr.get(i);\n\t\t\t\t// System.out.println(isle);\n\t\t\t\tif(uft.same(isle.x, isle.y)) continue;\n\t\t\t\tans += isle.dist;\n\t\t\t\tuft.unite(isle.x, isle.y);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n}\n\nclass Cell {\n\tdouble x, y, z, r;\n\n\tpublic Cell(double x, double y, double z, double r) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.r = r;\n\t}\n}\n\nclass Isle {\n\tint x, y;\n\tdouble dist;\n\tpublic Isle(int x, int y, double dist) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.dist = dist;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn x + \" \" + y + \" \" + dist;\n\t}\n}\n\nclass IsleComp implements Comparator<Isle> {\n\t@Override\n\tpublic int compare(Isle a, Isle b) {\n\t\tif(a.dist > b.dist){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\n/**\n * UnionFindTree \n * @author yoshikyoto\n */\nclass UnionFindTree {\n\tpublic int[] parent, rank;\n\tpublic int n;\n\tpublic int count;\n\n\t// 初期化\n\tUnionFindTree(int n) {\n\t\tthis.n = n;\n\t\tcount = n;\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\t// 根を求める\n\tint find(int x) {\n\t\tif (parent[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\t// xとyの集合を結合\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) {\n\t\t\treturn;\n\t\t}\n\t\tif (rank[x] < rank[y]) {\n\t\t\tparent[x] = y;\n\t\t\tcount--;\n\t\t} else {\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t// xとyが同じ集合か\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\t\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\t\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\t\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\t\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\t\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\t    \n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tdouble xs[];\n\tdouble ys[];\n\tdouble zs[];\n\tdouble rs[];\n\tdouble distance[];\n\tint count;\n\tpublic void calc(int n){\n\t\txs = new double[n];\n\t\tys = new double[n];\n\t\tzs = new double[n];\n\t\trs = new double[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\txs[i] = sc.nextDouble();\n\t\t\tys[i] = sc.nextDouble();\n\t\t\tzs[i] = sc.nextDouble();\n\t\t\trs[i] = sc.nextDouble();\t\t\t\n\t\t}\n\t\t\n\t\tdistance = new double[n];\n\t\tArrays.fill(distance, Double.MAX_VALUE);\n\t\t\n\t\tdouble ans = 0;\n\t\t\n\t\tdistance[0] = -1;\n\t\tcount = 1;\t\n\t\tupdate(0, n);\n\t\t\n\t\twhile(count < n){\n\t\t\tint small = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(distance[k] != -1 && (small == -1 || distance[k] < distance[small])){\n\t\t\t\t\tsmall = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += distance[small];\n\t\t\tdistance[small] = -1;\n\t\t\tcount++;\n\t\t\tupdate(small, n);\n\t\t}\n\t\tSystem.out.printf(\"%.4f\\n\", ans);\n\t}\n\t\n\tpublic void update(int a, int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(distance[i] != -1){\n\t\t\t\tdouble d = dist(a, i);\n\t\t\t\tif(d == 0){\n\t\t\t\t\tdistance[i] = -1;\n\t\t\t\t\tcount++;\n\t\t\t\t\tupdate(i, n);\n\t\t\t\t}\n\t\t\t\telse if(d < distance[i]) distance[i] = d;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double dist(int a, int b){\n\t\tdouble d = Math.sqrt(\n\t\t\t\t  (xs[a]-xs[b]) * (xs[a]-xs[b]) +\n\t\t\t\t  (ys[a]-ys[b]) * (ys[a]-ys[b]) +\n\t\t\t\t  (zs[a]-zs[b]) * (zs[a]-zs[b])\n\t\t\t\t);\n\t\td = d - rs[a] - rs[b];\n\t\tif(d < 0) d = 0;\n\t\treturn d;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    static int n;\n    static double[] x,y,z,r;\n    static double min;\n    static double[][] cost;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tn = sc.nextInt();\n\n\twhile(n!=0){\n\t    x = new double[n];\n\t    y = new double[n]; \n\t    z = new double[n];\n\t    r = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextDouble();\n\t\ty[i] = sc.nextDouble();\n\t\tz[i] = sc.nextDouble();\n\t\tr[i] = sc.nextDouble();\n\t    }\n\n\t    min = Double.MAX_VALUE;\n\t    solve();\n\t    if(min==Double.MAX_VALUE){min=0.000;}\n\t    System.out.printf(\"%1.3f\",min);\n\t    System.out.println();\n\n\t    n = sc.nextInt();\n\t}\n    }\n\n    public static void solve(){\n\tcost = new double[n][n];\n\tfor(int i=0; i<n; i++){\n\t    for(int j=0; j<n; j++){\n\t\tcost[i][j] = getDistance(i,j);\n\t\tif(cost[i][j]<0)cost[i][j]=0.0;\n\t    }\n\t}\n\n\tmin = getMin();\n    }\n\n    public static double getDistance(int i, int j){\n\treturn Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j];\n    }\n\n    public static double getMin(){\n\tdouble[] mincost = new double[n];\n\tboolean[] used = new boolean[n];\n\tfor(int i=0; i<n; i++){\n\t    mincost[i] = 1000000000;\n\t    used[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\n\twhile(true){\n\t    int v = -1;\n\t    for(int i=0; i<n; i++){\n\t\tif(!used[i] && (v==-1 || (mincost[i]<mincost[v]))){v = i;}\n\t    }\n\n\t    if(v==-1)break;\n\t    used[v] = true;\n\t    res += mincost[v];\n\n\t    for(int i=0; i<n; i++){\n\t\tmincost[i] = mincost[i];\n\t\tif(mincost[i]>cost[v][i]){mincost[i]=cost[v][i];}\n\t    }\n\t}\n\treturn res;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main {\n\tstatic HashMap<String, String[]> groups;\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tCell[] cell = new Cell[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble z = sc.nextDouble();\n\t\t\t\tdouble r = sc.nextDouble();\n\t\t\t\tcell[i] = new Cell(x, y, z, r);\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Isle> arr = new ArrayList<Isle>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdouble xx = sq(cell[i].x - cell[j].x);\n\t\t\t\t\tdouble yy = sq(cell[i].y - cell[j].y);\n\t\t\t\t\tdouble zz = sq(cell[i].z - cell[j].z);\n\t\t\t\t\t// System.out.println(xx + \" \" + yy + \" \" + zz);\n\t\t\t\t\tdouble dist = Math.sqrt(xx + yy + zz) - Math.abs(cell[i].r + cell[j].r);\n\t\t\t\t\tdist = Math.max(0, dist);\n\t\t\t\t\t// System.out.println(i + \" \" + j + \" \" + dist);\n\t\t\t\t\tIsle isle = new Isle(i, j, dist);\n\t\t\t\t\tarr.add(isle);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(arr, new IsleComp());\n\t\t\t\n\t\t\tint nn = arr.size();\n\t\t\tdouble ans = 0;\n\t\t\tUnionFindTree uft = new UnionFindTree(nn+1);\n\t\t\tfor (int i = 0; i < nn; i++) {\n\t\t\t\tIsle isle = arr.get(i);\n\t\t\t\t// System.out.println(isle);\n\t\t\t\tif(uft.same(isle.x, isle.y)) continue;\n\t\t\t\tans += isle.dist;\n\t\t\t\tuft.unite(isle.x, isle.y);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.3f\\n\", ans);\n\t\t}\n\t}\n\t\n\tpublic static int sq(int i) {\n\t\treturn i * i;\n\t}\n\n\tpublic static double sq(double d) {\n\t\treturn d * d;\n\t}\n}\n\nclass Cell {\n\tdouble x, y, z, r;\n\n\tpublic Cell(double x, double y, double z, double r) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.r = r;\n\t}\n}\n\nclass Isle {\n\tint x, y;\n\tdouble dist;\n\tpublic Isle(int x, int y, double dist) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.dist = dist;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn x + \" \" + y + \" \" + dist;\n\t}\n}\n\nclass IsleComp implements Comparator<Isle> {\n\t@Override\n\tpublic int compare(Isle a, Isle b) {\n\t\tif(a.dist == b.dist){\n\t\t\treturn 0;\n\t\t}else if(a.dist > b.dist){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\n/**\n * UnionFindTree \n * @author yoshikyoto\n */\nclass UnionFindTree {\n\tpublic int[] parent, rank;\n\tpublic int n;\n\tpublic int count;\n\n\t// 初期化\n\tUnionFindTree(int n) {\n\t\tthis.n = n;\n\t\tcount = n;\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\t// 根を求める\n\tint find(int x) {\n\t\tif (parent[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\t// xとyの集合を結合\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) {\n\t\t\treturn;\n\t\t}\n\t\tif (rank[x] < rank[y]) {\n\t\t\tparent[x] = y;\n\t\t\tcount--;\n\t\t} else {\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t// xとyが同じ集合か\n\tboolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}\n\n/**\n * 複素数\n */\nclass Complex {\n\tstatic Complex I = new Complex(0, 1);\n\t\n\tdouble r = 0.0;\n\tdouble i = 0.0;\n\tComplex(double r, double i) {\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t}\n\t\n\t/**\n\t * 和\n\t */\n\tpublic Complex add(Complex a) {\n\t\treturn new Complex(r * a.r, i + a.i);\n\t}\n\t\n\t/**\n\t * 積\n\t */\n\tpublic Complex mul(Complex a) {\n\t\treturn new Complex(\n\t\t\t\tr * a.r - i * a.i,\n\t\t\t\tr * a.i + i * a.r);\n\t}\n\t\n\tpublic Complex divide(double a) {\n\t\treturn new Complex(r/a, i/a);\n\t}\n\t\n\tpublic Complex inverse() {\n\t\tdouble b = 1 / (r*r + i*i);\n\t\treturn new Complex(r/b, -i/b);\n\t}\n\t    \n\n\t@Override\n\tpublic String toString(){\n\t\treturn r + \"+\" + i + \"i\";\n\t}\n}\n\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyIO {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\tint[] par;\n\n\tclass Ball {\n\t\tdouble x, y, z;\n\t\tdouble r;\n\n\t\tBall(double x, double y, double z, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tdouble len;\n\t\tint x, y;\n\n\t\tEdge(double len, int x, int y) {\n\t\t\tthis.len = len;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (this.len - o.len > 0) return 1;\n\t\t\tif (this.len - o.len < 0) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble dist(Ball a, Ball b) {\n\t\tdouble res = 0;\n\t\tres = Math.hypot(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n\t\tres = Math.hypot(res, Math.abs(a.z - b.z));\n\t\treturn res;\n\t}\n\n\tboolean isTouching(Ball a, Ball b) {\n\t\treturn dist(a, b) < a.r + b.r;\n\t}\n\n\tvoid union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tpar[x] = y;\n\t}\n\n\tboolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn root(par[x]);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBall[] b = new Ball[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tb[i] = new Ball(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\n\t\t\tpar = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\n\t\t\tList<Edge> list = new LinkedList<Edge>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!isTouching(b[i], b[j])) {\n\t\t\t\t\t\tlist.add(new Edge(dist(b[i], b[j]) - b[i].r - b[j].r, i, j));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunion(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble sum = 0;\n\t\t\tCollections.sort(list);\n\t\t\tfor (Edge E: list) {\n\t\t\t\tif (!find(E.x, E.y)) {\n\t\t\t\t\tunion(E.x, E.y);\n\t\t\t\t\tsum += E.len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int n){\n\t\tdouble xs[] = new double[n];\n\t\tdouble ys[] = new double[n];\n\t\tdouble zs[] = new double[n];\n\t\tdouble rs[] = new double[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\txs[i] = sc.nextDouble();\n\t\t\tys[i] = sc.nextDouble();\n\t\t\tzs[i] = sc.nextDouble();\n\t\t\trs[i] = sc.nextDouble();\t\t\t\n\t\t}\n\t\t\n\t\tdouble distance[] = new double[n];\n\t\t\n\t\tdouble ans = 0;\n\t\tint now = 0;\n\t\t\n\t\tdistance[0] = -1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tdouble d = Math.sqrt(\n\t\t\t\t\t\t\t(xs[0]-xs[i]) * (xs[0]-xs[i]) +\n\t\t\t\t\t\t\t(ys[0]-ys[i]) * (ys[0]-ys[i]) +\n\t\t\t\t\t\t\t(zs[0]-zs[i]) * (zs[0]-zs[i])\n\t\t\t\t\t\t  );\n\t\t\td = d - rs[0] - rs[i];\n\t\t\tif(d < 0) d = 0;\n\t\t\tdistance[i] = d;\n\t\t}\n\t\t\n\t\tint count = 1;\n\t\twhile(count < n){\n\t\t\tint small = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(distance[k] != -1 && (small == -1 || distance[k] < distance[small])){\n\t\t\t\t\tsmall = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += distance[small];\n\t\t\tdistance[small] = -1;\n\t\t\t\n\t\t\tfor(int k = 0;k < n; k++){\n\t\t\t\tif(distance[k] != -1){\n\t\t\t\t\tdouble d = Math.sqrt(\n\t\t\t\t\t\t\t  (xs[small]-xs[k]) * (xs[small]-xs[k]) +\n\t\t\t\t\t\t\t  (ys[small]-ys[k]) * (ys[small]-ys[k]) +\n\t\t\t\t\t\t\t  (zs[small]-zs[k]) * (zs[small]-zs[k])\n\t\t\t\t\t\t\t);\n\t\t\t\t\td = d - rs[small] - rs[k];\n\t\t\t\t\tif(d < 0) d = 0;\n\t\t\t\t\tif(d < distance[k]) distance[k] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tSystem.out.printf(\"%.4f\\n\", ans);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile (true) {\n\n\t\t\tint n = Integer.parseInt(br.readLine());\n\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tArrayList<ArrayList<Edge>> edges = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tedges.add(new ArrayList<>());\n\t\t\t}\n\n\t\t\tdouble x[] = new double[n];\n\t\t\tdouble y[] = new double[n];\n\t\t\tdouble z[] = new double[n];\n\t\t\tdouble r[] = new double[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString str[] = br.readLine().split(\" \");\n\t\t\t\tx[i] = Double.parseDouble(str[0]);\n\t\t\t\ty[i] = Double.parseDouble(str[1]);\n\t\t\t\tz[i] = Double.parseDouble(str[2]);\n\t\t\t\tr[i] = Double.parseDouble(str[3]);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble dist = Math.sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])\n\t\t\t\t\t\t\t+ (z[i] - z[j]) * (z[i] - z[j]));\n\n\t\t\t\t\tdist = dist - (r[i] + r[j]);\n\t\t\t\t\tif (dist < 0)\n\t\t\t\t\t\tdist = 0;\n\t\t\t\t\t\n\t\t\t\t\tedges.get(i).add(new Edge(j, dist));\n\t\t\t\t\tedges.get(j).add(new Edge(i, dist));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble sum = prime(edges, n);\n\t\t\tSystem.out.println(String.format(\"%.3f\", sum));\n\t\t}\n\t}\n\n\tstatic double prime(ArrayList<ArrayList<Edge>> edges, int n) {\n\t\tboolean[] done = new boolean[n];\n\n\t\tQueue<Edge> q = new PriorityQueue<Edge>();\n\t\tq.add(new Edge(0, 0));\n\n\t\tdouble totalCost = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tEdge e = q.poll();\n\t\t\tif (done[e.to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdone[e.to] = true;\n\t\t\ttotalCost += e.cost;\n\t\t\tq.addAll(edges.get(e.to));\n\t\t}\n\n\t\treturn totalCost;\n\t}\n}\n\nclass Edge implements Comparable<Edge> {\n\n\tint to;\n\tdouble cost;\n\n\tpublic Edge(int to, double cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge e) {\n\t\tif (this.cost > e.cost)\n\t\t\treturn 1;\n\t\telse if (this.cost < e.cost)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n\n    void solve(){        \n        int N = ni();\n        List<Double> ans = new ArrayList<>();\n\n        while(N != 0){\n            double[] x = new double[N];\n            double[] y = new double[N];\n            double[] z = new double[N];\n            double[] r = new double[N];\n            UnionFind uf = new UnionFind(N);\n            List<Edge> edges = new ArrayList<>();\n            for(int i = 0; i < N; i++){\n                x[i] = scan.nextDouble();\n                y[i] = scan.nextDouble();\n                z[i] = scan.nextDouble();\n                r[i] = scan.nextDouble();\n            }\n            for(int i = 0; i < N - 1; i++){\n                for(int j = i + 1; j < N; j++){\n                    double dist = Math.sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]));\n                    if(r[i] + r[j] >= dist){\n                        uf.unite(i, j);\n                    } else {\n                        Edge edge = new Edge(i, j, dist - r[i] - r[j]);\n                        edges.add(edge);\n                    }\n                }\n            }\n            Collections.sort(edges, new EdgeComparator());\n    \n            double sum = 0.0;\n            for(int i = 0; i < edges.size(); i++){ \n                Edge edge = edges.get(i);\n                if(uf.root(edge.from) == uf.root(edge.to)) continue;\n                sum += edge.cost;\n                uf.unite(edge.from, edge.to);\n            }\n    \n            ans.add(sum);\n            N = ni();\n        }\n        \n        for(double val : ans){\n            System.out.printf(\"%.3f\\n\", val);\n        }\n\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n\n    private FastScanner scan = new FastScanner();\n    private final int MOD = 1_000_000_007;\n    private final int INF = 2147483647;\n    private final long LINF = 9223372036854775807L;\n    private long[] fac;\n    private long[] finv;\n    private long[] inv;\n\n    // Scanner\n    int ni(){ return scan.nextInt();}\n    int[] ni(int n){int[] a = new int[n]; for(int i = 0; i < n; i++){a[i] = ni();} return a;}\n    int[][] ni(int y, int x){int[][] a = new int[y][x];\n        for(int i = 0; i < y; i++){for(int j = 0; j < x; j++){a[i][j] = ni();}} return a;}\n    long nl(){return scan.nextLong();}\n    long[] nl(int n){long[] a = new long[n]; for(int i = 0; i < n; i++){a[i] = nl();} return a;}\n    long[][] nl(int y, int x){long[][] a = new long[y][x];\n        for(int i = 0; i < y; i++){for(int j = 0; j < x; j++){a[i][j] = nl();}} return a;}\n    String ns(){return scan.next();}\n    String[] ns(int n){String[] a = new String[n]; for(int i = 0; i < n; i++){a[i] = ns();} return a;}\n    String[][] ns(int y, int x){String[][] a = new String[y][x];\n        for(int i = 0; i < y; i++){for(int j = 0; j < x; j++){a[i][j] = ns();}} return a;}\n\n    // Mathmatics\n    int max(int a, int b){return Math.max(a, b);}\n    long max(long a, long b){return Math.max(a, b);}\n    double max(double a, double b){return Math.max(a, b);}\n    int max(int[] a){int max = a[0]; for(int value:a){max = max(max,value);} return max;}\n    long max(long[] a){long max = a[0]; for(long value:a){max = max(max,value);} return max;}\n    double max(double[] a){double max = a[0]; for(double value:a){max = max(max,value);} return max;}\n    int min(int a, int b){return Math.min(a, b);}\n    long min(long a, long b){return Math.min(a, b);}\n    double min(double a, double b){return Math.min(a, b);}\n    int min(int[] a){int min = a[0]; for(int value:a){min = min(min,value);} return min;}\n    long min(long[] a){long min = a[0]; for(long value:a){min = min(min,value);} return min;}\n    double min(double[] a){double min = a[0]; for(double value:a){min = min(min,value);} return min;}\n    long sum(int[] a){long sum = 0; for(int value:a){sum += value;} return sum;}\n    long sum(long[] a){long sum = 0; for(long value:a){sum += value;} return sum;}\n    double sum(double[] a){double sum = 0; for(double value:a){sum += value;} return sum;}\n    int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}\n    long gcd(long a, long b){return b == 0 ? a : gcd(b, a % b);}\n    int lcm(int a, int b){return a / gcd(a, b) * b;}\n    long lcm(long a, long b){return a / gcd(a, b) * b;}\n    long fact(int n){ if(n == 0){ return 1; } long a = n; for(long i = n - 1; i >= 2; i--){ a = a % MOD * i; } return a; }\n    long fact(long n){ if(n == 0){ return 1; } long a = n; for(long i = n - 1; i >= 2; i--){ a = a % MOD * i; } return a; }\n    // nPr(int)\n    long npr(int n, int r){\n        long a = 1;\n        for(int i = n; i > n - r; i--){\n            a *= i;\n        }\n        return a;\n    }\n    // nPr(long)\n    long npr(long n, long r){\n        long a = 1;\n        for(long i = n; i > n - r; i--){\n            a *= i;\n        }\n        return a;\n    }\n    // 素数判定(int)\n    boolean checkPrime(int n){\n        for(int i = 2; i * i <= n; i++){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n    // 素数判定(long)\n    boolean checkPrime(long n){\n        for(long i = 2; i * i <= n; i++){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n    // mod pにおける累乗 a^n\n    long modpow(long a, long n, long p){\n        long res = 1;\n        while(n > 0){\n            if((n & 1) == 1){\n                res = res * a % p;\n            }\n            a = a * a % p;\n            n = n >> 1;\n        }\n        return res;\n    }\n    // mod pにおけるaの逆元a^-1\n    long modinv(long a, long p){\n        return modpow(a, p - 2, p);\n    }\n    // fac,finv,invの初期化\n    void comInit(int max){\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n        for(int i = 2; i < max; i++){\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n    // 二項係数nCr\n    long com(int n, int r){\n        if(n < r || (n < 0 || r < 0)){\n            return 0;\n        }\n        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD;\n    }\n    // 二項係数nCr（nが10^9など巨大なとき用）\n    long ncr(long n, long k){\n        long a = 1;\n        long b = 1;\n        for(int i = 1; i <= k; i++){\n            a = a * (n + 1 - i) % MOD;\n            b = b * i % MOD;\n        }\n        \n        return modinv(b, MOD) * a % MOD;\n    }\n\n\n    // Array\n    void sort(int[] a){ Arrays.sort(a);}\n    void sort(long[] a){ Arrays.sort(a);}\n    void sort(double[] a){ Arrays.sort(a);}\n    void sort(String[] a){ Arrays.sort(a);}\n    int[] reverse(int[] a){\n        int[] reversed = new int[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    long[] reverse(long[] a){\n        long[] reversed = new long[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    double[] reverse(double[] a){\n        double[] reversed = new double[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    char[] reverse(char[] a){\n        char[] reversed = new char[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    String[] reverse(String[] a){\n        String[] reversed = new String[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    boolean[] reverse(boolean[] a){\n        boolean[] reversed = new boolean[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    void fill(int[] array, int x) { Arrays.fill(array, x); }\n    void fill(long[] array, long x) { Arrays.fill(array, x); }\n    void fill(double[] array, double x) { Arrays.fill(array, x); }\n    void fill(boolean[] array, boolean x) { Arrays.fill(array, x); }\n    void fill(int[][] array, int x) { for(int a[] : array) { fill(a, x); } }\n    void fill(long[][] array, long x) { for(long a[] : array) { fill(a, x); } }\n    void fill(double[][] array, double x) { for(double a[] : array) { fill(a, x); } }\n    void fill(boolean[][] array, boolean x) { for(boolean a[] : array) { fill(a, x); } }\n    void fill(int[][][] array, int x) { for(int[][] ary : array) { for(int[] a : ary){ fill(a, x); } } }\n    void fill(long[][][] array, long x) { for(long[][] ary : array) { for(long[] a : ary){ fill(a, x); } } }\n\n    // Algorithm\n    // 深さ優先探索\n    /*\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        List<Integer> list;\n    */\n    int minCost = INF;\n    void dfs(HashMap<Integer, List<Integer>> graph, int v, boolean[] seen, int[] cost, PriorityQueue<Integer> queue){\n        seen[v] = true;\n        queue.add(cost[v]);\n        if(!graph.containsKey(v) || graph.get(v).size() == 0) return;\n        List<Integer> todo = graph.get(v);\n        for(int next : todo){\n            if(seen[next]) continue;\n            dfs(graph, next, seen, cost, queue);\n        }\n    }\n    // 幅優先探索\n    /*\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        List<Integer> list;\n    */\n    void bfs(HashMap<Integer, List<Integer>> graph, int v, int[] dist){\n        Queue<Integer> que = new ArrayDeque<>();\n        que.add(v);\n\n        while(que.size() > 0){\n            v = que.poll();\n            if(!graph.containsKey(v)) continue;\n            for(int next : graph.get(v)){\n                if(dist[next] != -1) continue;\n                dist[next] = dist[v] + 1;\n                que.add(next);\n            }\n        }\n    }\n    // ダイクストラ法\n    Node[] dijkstra(HashMap<Integer, List<Integer>> graph, int size, int v, boolean[] flag, int[][] cost){\n        Queue<Node> queue = new PriorityQueue<>(new MyComparator());\n        Node[] nodes = new Node[size];\n        for(int i = 1; i < size; i++){\n            nodes[i] = new Node(i, INF, -1);            // id, dist, pastを指定して初期化\n        }\n        /* for(int key : graph.keySet()){\n            nodes[key] = new Node(key, INF, -1);    // id, dist, pastを指定して初期化\n        } */\n       \n        nodes[v].dist = 0;  // 始点のコストを0に\n        try{\n            queue.add(nodes[v].clone());\n        } catch(CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n\n        while(queue.size() > 0){\n            Node now = queue.poll();        // 未確定の中で最もコストの低いノードを取り出す\n            flag[now.id] = true;                // 確定\n            if(!graph.containsKey(now.id)) continue;\n            for(int next : graph.get(now.id)){      // 辺で繋がっているノードを順にチェック\n                if(flag[next] || nodes[next].dist < nodes[now.id].dist + cost[now.id][next]) continue;\n                nodes[next].dist = nodes[now.id].dist + cost[now.id][next];     // distを更新\n                nodes[next].past = now.id;                                                    // pastを現在のノードに\n                try{\n                    queue.add(nodes[next].clone());\n                } catch (CloneNotSupportedException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        return nodes;\n    }\n    \n    // ソート済みint型配列でkey以上の値の最小indexを返す\n    int lowerBound(int[] a, int key){\n        int ng = -1;\n        int ok = a.length;\n        while(Math.abs(ok - ng) > 1){\n            int mid = (ok + ng) / 2; \n            if(a[mid] >= key){\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n        return ok;\n    }\n    // ソート済みlong型配列でkey以上の値の最小indexを返す\n    int lowerBound(long[] a, long key){\n        int ng = -1;\n        int ok = a.length;\n        while(Math.abs(ok - ng) > 1){\n            int mid = (ok + ng) / 2; \n            if(a[mid] >= key){\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n        return ok;\n    }\n    // 文字列sとtの最長共通部分列の長さを返す\n    int lcs(String s , String t){\n        int[][] dp = new int[s.length() + 1][t.length() + 1];\n\n        for(int i = 0; i < s.length(); i++){\n            for(int j = 0; j < t.length(); j++){\n                if(s.charAt(i) == t.charAt(j)){\n                    dp[i + 1][j + 1] = max(dp[i][j] + 1, dp[i + 1][j + 1]);\n                }\n                dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i + 1][j]);\n                dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j + 1]);\n            }\n        }\n\n        return dp[s.length()][t.length()];\n    }\n\n}\n// ダイクストラ法におけるノード\nclass Node implements Cloneable{\n    int id;             // ノード番号\n    int dist;           // 最低必要コスト\n    int past;           // 直前の頂点\n\n    Node(int id, int dist, int past){\n        this.id = id;\n        this.dist = dist;\n        this.past = past;\n    }\n    @Override\n    protected Node clone() throws CloneNotSupportedException{\n        Node node = (Node)super.clone();\n        return node;\n    }\n    public String toString(){\n        return \"[\" + id + \", \" + dist + \" ,\" + past + \"]\";\n    }\n}\n// ダイクストラ法における重み比較のComparator\nclass MyComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node n1, Node n2){\n        int dist1 = n1.dist;\n        int dist2 = n2.dist;\n        if(dist1 < dist2){\n            return -1;\n        } else if(dist1 > dist2){\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n// 辺の情報を持つクラス\nclass Edge implements Cloneable{\n    int from;       // どの頂点から\n    int to;          //  どの頂点へ\n    double cost;       // 辺の重み\n\n    Edge(int from, int to, double cost){\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    @Override\n    protected Edge clone() throws CloneNotSupportedException{\n        Edge edge = (Edge)super.clone();\n        return edge;\n    }\n    public String toString(){\n        return \"[\" + from + \" to \" + to + \",\" + cost + \"]\";\n    }\n}\n// 辺の重み比較のComparator\nclass EdgeComparator implements Comparator<Edge>{\n    @Override\n    public int compare(Edge e1, Edge e2){\n        double cost1 = e1.cost;\n        double cost2 = e2.cost;\n        if(cost1 < cost2){\n            return -1;\n        } else if(cost1 > cost2){\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n// Union-Find\nclass UnionFind{\n    int[] par;\n    int[] size;\n    UnionFind(int N){\n        par = new int[N];\n        size = new int[N];\n        for(int i = 0; i < N; i++){\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    void init(int N){\n        for(int i = 0; i < N; i++){\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        } else {\n            return par[x] = root(par[x]);\n        }\n    }\n\n    boolean same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(size[x] < size[y]){\n            int tmp = x;\n            x = y;\n            y = tmp;\n        }\n        size[x] += size[y];\n        par[y] = x;\n    }\n\n    int size(int x){\n        return size[root(x)];\n    }\n\n}\n\n// 順列を管理する\nclass Permutation {\n    private int number;\n    private int listSize;\n    private int searched;\n    private int nextIndex;\n    private int[][] permList;\n\n    Permutation(int num) {\n        this.number = num;\n        this.listSize  = this.fact(this.number);\n        this.searched   = 0;\n        this.nextIndex = 0;\n        this.permList  = new int[this.listSize][this.number];\n\n        this.create(0, new int[this.number], new boolean[this.number]);\n    }\n\n    int[] nextPerm() {\n        return permList[this.nextIndex++];\n    }\n\n    boolean isNext() {\n        if(this.nextIndex < this.listSize) {\n            return true;\n        } else {\n            this.nextIndex = 0;\n            return false;\n        }\n    }\n\n    int fact(int n){\n        return n == 0 ? 1 : n * fact(n-1);\n    }\n\n    void create(int num, int[] list, boolean[] flag) {\n        if(num == this.number) {\n            copyArray(list, permList[this.searched]);\n            this.searched++;\n        }\n        for(int i = 0; i < this.number; i++){\n            if(flag[i]) continue;\n            list[num] = i;\n            flag[i] = true;\n            this.create(num+1, list, flag);\n            flag[i] = false;\n\n        }\n    }\n\n    void copyArray(int[] from, int[] to) {\n        for(int i=0; i<from.length; i++) to[i] = from[i];\n    }\n\n    void printNum(int[] nums) {\n        for(int n : nums) System.out.print(n);\n        System.out.println();\n    }\n}\n\n// 標準のScannerより高速に標準入力する\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    static int n;\n    static double[] x,y,z,r;\n    static double[][] dist;\n    static int[] list;\n    static double min;\n    static int needCor;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tn = sc.nextInt();\n\n\twhile(n!=0){\n\t    x = new double[n];\n\t    y = new double[n]; \n\t    z = new double[n];\n\t    r = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextDouble();\n\t\ty[i] = sc.nextDouble();\n\t\tz[i] = sc.nextDouble();\n\t\tr[i] = sc.nextDouble();\n\t    }\n\n\t    min = Double.MAX_VALUE;\n\t    solve();\n\t    if(min==Double.MAX_VALUE){min=0.000;}\n\t    System.out.printf(\"%1.3f\",min);\n\t    System.out.println();\n\n\t    n = sc.nextInt();\n\t}\n    }\n\n    public static void solve(){\n\tdist = new double[n][n];\n\tint link = 0;\n\tlist = new int[n];\n\tint type = 1;\n\tfor(int i=0; i<n; i++){\n\t    for(int j=i+1; j<n; j++){\n\t\tdist[i][j] = getDistance(i,j);\n\t\t//System.out.println(dist[i][j]);\n\t\tif(dist[i][j]<0){\n\t\t    link++;\n\t\t    list[i] = type;\n\t\t    list[j] = type;\n\t\t    type++;\n\t\t}\n\t    }\n\t}\n\n\tneedCor = n-link-1;\n\tint[][] field = new int[n][n];\n\tgetMin(0,field);\n    }\n\n    public static double getDistance(int i, int j){\n\treturn Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j];\n    }\n\n    public static void getMin(int colNum, int[][] field){\n\t//System.out.println(needCor+\" \"+colNum);\n\tif(colNum>needCor){return;}\n\tif(colNum==needCor){\n\t    int[] record = new int[n];\n\t    double[] distRecord = new double[needCor];\n\t    int count = 0;\n\t    for(int i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t    if(field[i][j]==1){\n\t\t\tdistRecord[count] = dist[i][j];\n\t\t\t//System.out.println(distRecord[count]);\n\t\t\tif(distRecord[count]<=0){return;}\n\t\t\tcount++;\n\t\t\trecord[i] = 1;\n\t\t\trecord[j] = 1;\n\t\t\tint linkNum1 = list[i];\n\t\t\tint linkNum2 = list[j];\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t    if(list[k]==linkNum1 || list[k]==linkNum2){record[k] = 1;}\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tif(record[i]==0){return;}\n\t    }\n\t    //System.out.println(Arrays.toString(distRecord));\n\t    double sum = 0;\n\t    for(int j=0; j<needCor; j++){\n\t\tif(distRecord[j]<=0){return;}\n\t\tsum += distRecord[j];\n\t    }\n\t    if(sum<min){min = sum; return;}\n\t    else{return;}\t    \n\t}\n\n\tfor(int i=0; i<n; i++){\n\t    for(int j=i+1; j<n; j++){\n\t\tfield[i][j]  = 1;\n\t\tgetMin(colNum+1, field);\n\t\tfield[i][j] = 0;\n\t    }\n\t}\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tvoid disp(char[][] c){\n\t\tfor(int y=0; y<c[0].length; y++){\n\t\t\tfor(int x=0; x<c.length; x++)\tout.print(c[x][y]);\n\t\t\tout.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1127();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ1127(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tdouble[] xx=new double[N],yy=new double[N],zz=new double[N],rr=new double[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\txx[i]=sc.nextDouble();\tyy[i]=sc.nextDouble();\n\t\t\t\tzz[i]=sc.nextDouble();\trr[i]=sc.nextDouble();\n\t\t\t}\n\t\t\tdouble[][] d=new double[N][N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tif(i==j)\td[i][j]=0;\n\t\t\t\t\tdouble dd=sqrt(pow(xx[i]-xx[j],2)+pow(yy[i]-yy[j],2)+pow(zz[i]-zz[j],2))-rr[i]-rr[j];\n\t\t\t\t\td[i][j]=max(0,dd);\td[j][i]=max(0,dd);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ari-book p.100-101\n\t\t\tdouble[] mincost=new double[N];\n\t\t\tArrays.fill(mincost, (double)INF);\n\t\t\tboolean[] used=new boolean[N];\n\t\t\tmincost[0]=0;\n\t\t\tdouble res=0;\n\t\t\twhile(true){\n\t\t\t\tint v=-1;\n\t\t\t\tfor(int u=0; u<N; u++)\tif(!used[u]&&(v==-1 || mincost[u]<mincost[v]))\tv=u;\n\t\t\t\tif(v==-1)\tbreak;\n\t\t\t\tused[v]=true;\n\t\t\t\tres+=mincost[v];\n\t\t\t\tfor(int u=0; u<N; u++)\tmincost[u]=min(mincost[u],d[v][u]);\n\t\t\t}\n\t\t\tout.printf(\"%.3f\\n\",res);\n\t\t}\n\t}\n\t\n\tvoid AOJ1140(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0,k=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][] kk=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(c[x][y]=='*'){\n\t\t\t\t\t\tkk[x][y]=k;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}else if(c[x][y]=='o'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(c);\n\t\t\tPriorityQueue<C1140> open=new PriorityQueue<C1140>();\n\t\t\tint[][][][] close=new int[W][H][k+1][(1<<k)];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int l=0; l<=k; l++){\n\t\t\t\t\t\tfor(int m=0; m<(1<<k); m++)\tclose[i][j][l][m]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1140(sx,sy,0,k,(1<<k)-1,dcopy(c)));\n\t\t\tclose[sx][sy][k][(1<<k)-1]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1140 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tboolean flag=false;\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i],r=now.r,m=now.m;\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='x')\tcontinue;\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tr--;\n\t\t\t\t\t\tm=now.m^(1<<kk[xx][yy]);\n\t\t\t\t\t}\n\t\t\t\t\tif(close[xx][yy][r][m]<=now.s+1)\tcontinue;\n\t\t\t\t\tif(r==0){\n\t\t\t\t\t\t//out.println(\"ANS:\"+now);\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tnow.c[xx][yy]='.';\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"DL\"+xx+\",\"+yy+\" R\"+r+\" Bit\"+Integer.bitCount(m));\n\t\t\t\t\t\t//disp(now.c);\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C1140(xx,yy,now.s+1,r,m,dcopy(now.c)));\n\t\t\t\t\tclose[xx][yy][r][m]=now.s+1;\n\t\t\t\t\tif(flag)\tnow.c[xx][yy]='*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans>=INF?-1:ans));\n\t\t}\n\t}\n\tclass C1140 implements Comparable<C1140>{\n\t\tint x,y,s,r,m;\n\t\tchar[][] c;\n\t\tC1140(int x,int y,int s,int r,int m,char[][] c){\tthis.x=x; this.y=y; this.s=s; this.r=r; this.m=m; this.c=c;}\n\t\t@Override public int compareTo(C1140 o) {\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\tif(this.r<o.r)\treturn -1;\n\t\t\tif(this.r>o.r)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override public String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\") S:\"+s+\" R:\"+r;\n\t\t}\n\t}\n\tchar[][] dcopy(char[][] c){\n\t\tchar[][] r=new char[c.length][c[0].length];\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tfor(int j=0; j<c[0].length; j++)\tr[i][j]=c[i][j];\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tint INF = 1 << 24;\n\n\tpublic class Point3D{\n\t\tdouble x,y,z;\n\t\tpublic Point3D(double x, double y, double z) {\n\t\t\tthis.x = x;this.y = y;this.z = z;\n\t\t}\n\n\t\tprivate double distance(Point3D p) {\n\t\t\tdouble x = this.x - p.x;\n\t\t\tdouble y = this.y - p.y;\n\t\t\tdouble z = this.z - p.z;\n\t\t\tdouble dissq = x * x + y*y + z*z;\n\t\t\treturn Math.sqrt(dissq);\n\t\t}\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdouble [] rlist = new double[n];\n\t\t\tPoint3D [] plist = new Point3D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\tdouble z = sc.nextDouble();\n\t\t\t\trlist[i] = sc.nextDouble();\n\t\t\t\tplist[i] = new Point3D(x,y,z);\n\t\t\t}\n\n\t\t\tdouble [][] pass = new double[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tdouble distance = plist[i].distance(plist[j]);\n\t\t\t\t\tdouble rDistance = rlist[i] + rlist[j];\n\t\t\t\t\tdouble value = Math.max(0.0, distance - rDistance);\n\t\t\t\t\tpass[i][j] = value;\n\t\t\t\t\tpass[j][i] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble res = mst(pass);\n\t\t\tSystem.out.printf(\"%.3f\\n\",res);\n\t\t}\n\t}\n\n\tprivate double mst(double[][] pass) {\n\t\tint n = pass.length;\n\t\tdouble [] mincost = new double[n];\n\t\tboolean [] isused = new boolean[n];\n\t\tArrays.fill(mincost, INF);\n\n\t\tmincost[0] = 0.0;\n\t\tdouble res = 0.0;\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(! isused[i] &&( v == -1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v == -1) break;\n\t\t\tisused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmincost[i] = Math.min(mincost[i], pass[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\tint[] par;\n\n\tclass Ball {\n\t\tdouble x, y, z;\n\t\tdouble r;\n\n\t\tBall(double x, double y, double z, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tdouble len;\n\t\tint x, y;\n\n\t\tEdge(double len, int x, int y) {\n\t\t\tthis.len = len;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (this.len - o.len > 0) return 1;\n\t\t\tif (this.len - o.len < 0) return -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble dist(Ball a, Ball b) {\n\t\tdouble res = 0;\n\t\tres = Math.hypot(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n\t\tres = Math.hypot(res, Math.abs(a.z - b.z));\n\t\treturn res;\n\t}\n\n\tboolean isTouching(Ball a, Ball b) {\n\t\treturn dist(a, b) < a.r + b.r;\n\t}\n\n\tvoid union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tpar[x] = y;\n\t}\n\n\tboolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn root(par[x]);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBall[] b = new Ball[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tb[i] = new Ball(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\n\t\t\tpar = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\n\t\t\tList<Edge> list = new LinkedList<Edge>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!isTouching(b[i], b[j])) {\n\t\t\t\t\t\tlist.add(new Edge(dist(b[i], b[j]) - b[i].r - b[j].r, i, j));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunion(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble sum = 0;\n\t\t\tCollections.sort(list);\n\t\t\tfor (Edge E: list) {\n\t\t\t\tif (!find(E.x, E.y)) {\n\t\t\t\t\tunion(E.x, E.y);\n\t\t\t\t\tsum += E.len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"%.3f\\n\", sum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tdouble[][] cost = new double[n][n];\n\t\t\tfor(int i=0;i<n;i++) Arrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] z = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tdouble a = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\t\tcost[i][j] = Math.max(0, a-r[i]-r[j]);\n\t\t\t\t\tcost[j][i] = cost[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tlist.add(0);\n\t\t\tdouble sum = 0;\n\t\t\tdouble q;\n\t\t\tint s = 0;\n\t\t\tint p;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tq = Integer.MAX_VALUE;\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tp = list.get(j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(list.contains(k)==false && q>cost[p][k]){\n\t\t\t  \t\t\t\tq = cost[p][k];\n\t\t\t\t\t\t\ts = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.add(s);\n\t\t\t \tsum += q;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.3f\\n\", sum);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E implements Comparable<E> {\n\t\tdouble v;\n\t\tint a;\n\t\tint b;\n\n\t\tE(double vv, int aa, int bb) {\n\t\t\tv = vv;\n\t\t\ta = aa;\n\t\t\tb = bb;\n\t\t}\n\n\t\tpublic int compareTo(E tar) {\n\t\t\treturn v - tar.v > 0 ? 1 : -1;\n\t\t}\n\t}\n\n\tclass S {\n\t\tdouble x;\n\t\tdouble y;\n\t\tdouble z;\n\t\tdouble r;\n\n\t\tS(double xx, double yy, double zz, double rr) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tz = zz;\n\t\t\tr = rr;\n\t\t}\n\n\t\tdouble dist(S t) {\n\t\t\tdouble xx = x - t.x;\n\t\t\tdouble yy = y - t.y;\n\t\t\tdouble zz = z - t.z;\n\t\t\tdouble dd = xx * xx + yy * yy + zz * zz;\n\t\t\tdouble d = Math.sqrt(dd);\n\n\t\t\tdouble r2 = r + t.r;\n\n\t\t\tif (r2 < d) {\n\t\t\t\treturn  d-r2;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[] s = new S[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ts[i] = new S(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble dd = s[i].dist(s[j]);\n\t\t\t\t\tq.add(new E(dd,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint data[] = new int[n];\n\t\t\tint ne = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor (;;) {\n\t\t\t\tE now = q.poll();\n\t\t\t\tif(data[now.a] != 0 && data[now.b] == data[now.a] ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tne++;\n\t\t\t\tif((data[now.a] | data[now.b]) == 0){\n\t\t\t\t\tdata[now.a] = ne;\n\t\t\t\t\tdata[now.b] = ne;\n\t\t\t\t}\n\t\t\t\tif(data[now.a] == 0){\n\t\t\t\t\tdata[now.a] = data[now.b];\n\t\t\t\t}\n\t\t\t\tif(data[now.b] == 0){\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i =0 ; i< n ;i++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i!= now.b && data[i] == data[now.b]){\n\t\t\t\t\t\t\tdata[i]= data[now.a];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}\n\t\t\t\tsum += now.v;\n\t\t\t\tif(ne == n-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = (long)(sum * 1000 + 0.5);\n\t\t\t\n\t\t\tSystem.out.print((res /1000));\n\t\t\tSystem.out.printf(\".%03d\\n\",(res %1000));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(sc.hasNextInt()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] z = new double[n];\n\t\t\tdouble[] r = new double[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tArrayList<ArrayList<Edge>> map = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0;i<n;i++) map.add(new ArrayList<Edge>());\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdouble dist = Math.sqrt( Math.pow(x[j]-x[i],2) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t Math.pow(y[j]-y[i],2) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t Math.pow(z[j]-z[i],2));\n\n\t\t\t\t\tEdge e = new Edge(i,j,0);\n\t\t\t\t\tif(dist > r[i] + r[j]){\n\t\t\t\t\t\te.cost = dist - (r[i] + r[j]);\n\t\t\t\t\t}\n\t\t\t\t\tmap.get(i).add(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"%.3f\\n\",prim(map));\n\t\t}\n\t}\n\n\tprivate static double prim(ArrayList<ArrayList<Edge>> g){\n\t\tPriorityQueue<Edge> open = new PriorityQueue<Edge>();\n\t\tHashSet<Integer> closed = new HashSet<Integer>();\n\t\tdouble total = 0;\n\t\topen.add(new Edge(-1,0,0));\n\t\tArrayList<Edge> ng = new ArrayList<Edge>();\n\n\t\twhile(closed.size() != g.size()){\n\t\t\tEdge st = open.poll();\n\t\t\tif(closed.contains(st.to)) continue;\n\t\t\tclosed.add(st.to);\n\t\t\tng.add(st);\n\t\t\ttotal += st.cost;\n\t\t\tfor(Edge e : g.get(st.to)){\n\t\t\t\tif(!closed.contains(e.to)){\n\t\t\t\t\topen.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn total;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint from,to;\n\tdouble cost;\n\n\tEdge(int from,int to,double cost){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(Edge e){\n\t\tif(cost < e.cost) return -1;\n\t\tif(cost > e.cost) return 1;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tdouble[] x = new double[100];\n\tdouble[] y = new double[100];\n\tdouble[] z = new double[100];\n\tdouble[] r = new double[100];\n\tdouble EPS = 1e-9;\n\t\n\t\n\tdouble dis(int i, int j) {\n\t\treturn sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t}\n\t\n\tboolean connected(int i, int j) {\n\t\treturn dis(i, j)-r[i]-r[j] < EPS;\n\t}\n\t\n\tvoid run() {\n\t\tdouble[][] cost = new double[100][100];\n\t\tdouble INF = Double.MAX_VALUE/2;\n\t\tdouble[] mincost = new double[100];\n\t\tboolean[] used = new boolean[100];\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tArrays.fill(cost[i], INF);\n\t\t\t\tmincost[i] = INF;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\t\tif (connected(i, j)) {\n\t\t\t\t\t\tcost[i][j] = cost[j][i] = 0.0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcost[i][j] = cost[j][i] = dis(i, j) - r[i] - r[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmincost[0] = 0.0;\n\t\t\tdouble res = 0.0;\n\t\t\twhile (true) {\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\t\tif (!used[u] && (v == -1 ||mincost[u] < mincost[v]))\n\t\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (v == -1) break;\n\t\t\t\tused[v] = true;\n\t\t\t\tres += mincost[v];\n\t\t\t\t\n\t\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.printf(\"%.3f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().new P1127().run(); \n\t}\n\tclass P1127{\n\t\tvoid run(){\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\tfor(;;){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\t\n\t\t\t\tPos[] p=new Pos[n];\n\t\t\t\tQueue<Node> q=new PriorityQueue<Node>();\n\t\t\t\tboolean[] visited=new boolean[n];\n\t\t\t\tint nvis=0;\n\t\t\t\tdouble ans=0;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tdouble x,y,z,r;\n\t\t\t\t\tx=sc.nextDouble();\n\t\t\t\t\ty=sc.nextDouble();\n\t\t\t\t\tz=sc.nextDouble();\n\t\t\t\t\tr=sc.nextDouble();\n\t\t\t\t\tp[i]=new Pos(x,y,z,r);\n\t\t\t\t\tvisited[i]=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Prim\n\t\t\t\tNode t=new Node(0,0);\n\t\t\t\tq.offer(t);\n\t\t\t\twhile(nvis<n){\n\t\t\t\t\tt=q.poll();\n\t\t\t\t\tif(visited[t.node])continue;\n\t\t\t\t\tvisited[t.node]=true;\n\t\t\t\t\tnvis++;\n\t\t\t\t\tans+=t.d;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif(!visited[i]){\n\t\t\t\t\t\t\tq.offer(new Node((p[t.node]).dist(p[i]),i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%.3f\",ans);\n\t\t\t}\n\t\t}\n\t}\n\tclass Pos{\n\t\tdouble x,y,z,r;\n\t\tPos(double x_,double y_,double z_,double r_){\n\t\t\tthis.x=x_;\n\t\t\tthis.y=y_;\n\t\t\tthis.z=z_;\n\t\t\tthis.r=r_;\n\t\t}\n\t\tdouble dist(Pos o){\n\t\t\tdouble ret=Math.sqrt((x-o.x)*(x-o.x)+(y-o.y)*(y-o.y)+(z-o.z)*(z-o.z))-(r+o.r);\n\t\t\treturn ret<=0?0:ret;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tdouble d;\n\t\tint node;\n\t\tpublic int compareTo(Node o){\n\t\t\tif(d<o.d)return -1;\n\t\t\tif(d==o.d)return 0;\n\t\t\telse return 1;\n\t\t}\n\t\tNode(double d_,int node_){\n\t\t\tthis.d=d_;\n\t\t\tthis.node=node_;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint n;\n\tdouble[] x, y, z, r;\n\tdouble[][] dist;\n\tdouble ans;\n\tboolean[][] visited;\n\t\n\tfinal double INF = 10000;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tdist = new double[n][n];\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tz = new double[n];\n\t\t\tr = new double[n];\n\t\t\tvisited = new boolean[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < visited.length; i++) {\n\t\t\t\tArrays.fill(visited[i], false);\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\t\tx[i] = in.nextDouble();\n\t\t\t\ty[i] = in.nextDouble();\n\t\t\t\tz[i] = in.nextDouble();\n\t\t\t\tr[i] = in.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\t\tfor (int j = 0; j < dist[i].length; j++) {\n\t\t\t\t\tdist[i][j] = getDistance(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tans = 0;\n\t\t\tfor (int i = 0; i < n * n; i++) {\n\t\t\t\tdouble min = INF;\n\t\t\t\tint x = 0, y = 0;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (visited[j][k]) continue;\n\t\t\t\t\t\tif (min > dist[j][k]) {\n\t\t\t\t\t\t\ty = j; x = k;\n\t\t\t\t\t\t\tmin = dist[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvisited[x][y] = true; visited[y][x] = true;\n\t\t\t\tif (isCircuit(x, y, x)) {\n\t\t\t\t\tvisited[x][y] = false; visited[y][x] = false;\n\t\t\t\t\tdist[y][x] = INF;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tans += min; cnt++;\n\t\t\t\t\tif (cnt == n - 1) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.3f\\n\", ans);\n\t\t}\n\t}\n\t\n\tboolean isCircuit(int x, int last, int start) {\n\t\tif (last == start) return true;\n\t\t\n\t\tif (visited[last][x]) {\n\t\t\tfor (int i = 0; i < visited[last].length; i++) {\n\t\t\t\tif (visited[last][i] && i != x && isCircuit(last, i, start)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tdouble getDistance(int i, int j) {\n\t\tif (i == j) return INF;\n\t\t\n\t\tdouble x2 = (x[i] - x[j]) * (x[i] - x[j]);\n\t\tdouble y2 = (y[i] - y[j]) * (y[i] - y[j]);\n\t\tdouble z2 = (z[i] - z[j]) * (z[i] - z[j]);\n\t\t\n\t\tdouble distance = Math.sqrt(x2 + y2 + z2) - r[i] - r[j];\n\t\t\n\t\treturn (distance > 0) ? distance : 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E implements Comparable<E> {\n\t\tdouble v;\n\t\tint a;\n\t\tint b;\n\n\t\tE(double vv, int aa, int bb) {\n\t\t\tv = vv;\n\t\t\ta = aa;\n\t\t\tb = bb;\n\t\t}\n\n\t\tpublic int compareTo(E tar) {\n\t\t\treturn v - tar.v > 0 ? 1 : -1;\n\t\t}\n\t}\n\n\tclass S {\n\t\tdouble x;\n\t\tdouble y;\n\t\tdouble z;\n\t\tdouble r;\n\n\t\tS(double xx, double yy, double zz, double rr) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tz = zz;\n\t\t\tr = rr;\n\t\t}\n\n\t\tdouble dist(S t) {\n\t\t\tdouble xx = x - t.x;\n\t\t\tdouble yy = y - t.y;\n\t\t\tdouble zz = z - t.z;\n\t\t\tdouble dd = xx * xx + yy * yy + zz * zz;\n\t\t\tdouble d = Math.sqrt(dd);\n\n\t\t\tdouble r2 = r + t.r;\n\n\t\t\tif (r2 < d) {\n\t\t\t\treturn  d-r2;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[] s = new S[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ts[i] = new S(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble dd = s[i].dist(s[j]);\n\t\t\t\t\tq.add(new E(dd,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint data[] = new int[n];\n\t\t\tint ne = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif(q.isEmpty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tE now = q.poll();\n\t\t\t\tif(data[now.a] != 0 && data[now.b] == data[now.a] ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tne++;\n\t\t\t\tif((data[now.a] | data[now.b]) == 0){\n\t\t\t\t\tdata[now.a] = ne;\n\t\t\t\t\tdata[now.b] = ne;\n\t\t\t\t}\n\t\t\t\tif(data[now.a] == 0){\n\t\t\t\t\tdata[now.a] = data[now.b];\n\t\t\t\t}\n\t\t\t\tif(data[now.b] == 0){\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i =0 ; i< n ;i++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i!= now.b && data[i] == data[now.b]){\n\t\t\t\t\t\t\tdata[i]= data[now.a];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}\n\t\t\t\tsum += now.v;\n\t\t\t\tif(ne == n-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = (long)(sum * 1000 + 0.5);\n\t\t\t\n\t\t\tSystem.out.print((res /1000));\n\t\t\tSystem.out.printf(\".%03d\\n\",(res %1000));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int n){\n\t\tdouble xs[] = new double[n];\n\t\tdouble ys[] = new double[n];\n\t\tdouble zs[] = new double[n];\n\t\tdouble rs[] = new double[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\txs[i] = sc.nextDouble();\n\t\t\tys[i] = sc.nextDouble();\n\t\t\tzs[i] = sc.nextDouble();\n\t\t\trs[i] = sc.nextDouble();\t\t\t\n\t\t}\n\t\t\n\t\tdouble distance[] = new double[n];\n\t\t\n\t\tdouble ans = 0;\n\t\tint now = 0;\n\t\t\n\t\tdistance[0] = -1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tdouble d = Math.sqrt(\n\t\t\t\t\t\t\t(xs[0]-xs[i]) * (xs[0]-xs[i]) +\n\t\t\t\t\t\t\t(ys[0]-ys[i]) * (ys[0]-ys[i]) +\n\t\t\t\t\t\t\t(zs[0]-zs[i]) * (zs[0]-zs[i])\n\t\t\t\t\t\t  );\n\t\t\td = d - rs[0] - rs[i];\n\t\t\tif(d < 0) d = 0;\n\t\t\tdistance[i] = d;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint small = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(distance[k] != -1 && (small == -1 || distance[k] < distance[small])){\n\t\t\t\t\tsmall = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += distance[small];\n\t\t\tdistance[small] = -1;\n\t\t\t\n\t\t\tfor(int k = 0;k < n; k++){\n\t\t\t\tif(distance[k] != -1){\n\t\t\t\t\tdouble d = Math.sqrt(\n\t\t\t\t\t\t\t  (xs[small]-xs[k]) * (xs[small]-xs[k]) +\n\t\t\t\t\t\t\t  (ys[small]-ys[k]) * (ys[small]-ys[k]) +\n\t\t\t\t\t\t\t  (zs[small]-zs[k]) * (zs[small]-zs[k])\n\t\t\t\t\t\t\t);\n\t\t\t\t\td = d - rs[small] - rs[k];\n\t\t\t\t\tif(d < 0) d = 0;\n\t\t\t\t\tif(d < distance[k]) distance[k] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.4f\\n\", ans);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,-1,0,1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\n\tpublic static void main(String[] args) {\t\n\t\t//FastScanner sc = new FastScanner();\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCell[] cell = new Cell[n];\n\t\t\tEdge[] edges = new Edge[(n * (n-1)) / 2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tcell[i] = new Cell(sc.nextDouble(),sc.nextDouble(),sc.nextDouble(),sc.nextDouble());\n\t\t\t}\n\t\t\tint idx = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\tdouble distC = dist(cell[i],cell[j]);\n\t\t\t\t\tdouble distF = distC - cell[i].r - cell[j].r;\n\t\t\t\t\tedges[idx++] = new Edge(i,j,Math.max(distF,0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Edge> q = new PriorityQueue<Edge>();\n\t\t\tfor(int i = 0; i < edges.length; i++) {\n\t\t\t\tq.add(edges[i]);\n\t\t\t}\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tdouble cost = 0;\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tEdge e = q.poll();\n\t\t\t\tif(!uf.findSet(e.v1, e.v2)) {\n\t\t\t\t\tuf.unionSet(e.v1, e.v2);\n\t\t\t\t\tcost += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.3f\\n\",cost);\n\t\t\t\n\t\t}\n\t}\n\tstatic class UnionFind {\n\t\tint[] data;\n\t\tUnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tArrays.fill(data, -1);\n\t\t}\n\t\tboolean unionSet(int x, int y) {\n\t\t\tx = root(x); \n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t}\n\t\t\t\tdata[x] += data[y]; \n\t\t\t\tdata[y] = x;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\t\tboolean findSet(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t}\n\t\tint size(int x) {\n\t\t\treturn -data[root(x)];\n\t\t}\n\t}\n\t\n\tstatic double dist(Cell a, Cell b) {\n\t\treturn Math.sqrt((Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2)));\n\t}\n\t\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint v1;\n\t\tint v2;\n\t\tdouble cost;\n\t\tEdge(int a, int b, double c) {\n\t\t\tv1 = a;\n\t\t\tv2 = b;\n\t\t\tcost = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif(o.cost < this.cost) return 1;\n\t\t\telse if(o.cost > this.cost) return -1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\tstatic class Cell {\n\t\tdouble x;\n\t\tdouble y;\n\t\tdouble z;\n\t\tdouble r;\n\t\tCell(double a, double b, double c, double d) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t\tz = c;\n\t\t\tr = d;\n\t\t}\n\t}\n\t\n\n}\n\n\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic double[] x, y, z, r;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tx = new double[N];\n\t\t\ty = new double[N];\n\t\t\tz = new double[N];\n\t\t\tr = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tArrayList<Edge> edges = new ArrayList<Edge>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\t\t edges.add(new Edge(i, j, dist(i, j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(edges);\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tdouble ans = 0;\n\t\t\tfor (Edge e : edges) {\n\t\t\t\tif(uf.find(e.f, e.t)) continue;\n\t\t\t\tans += e.v;\n\t\t\t\tuf.union(e.f, e.t);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.3f\\n\", ans);\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint f, t;\n\t\tdouble v;\n\n\t\tEdge(int f, int t, double v) {\n\t\t\tthis.f = f;\n\t\t\tthis.t = t;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Double.compare(this.v, o.v);\n\t\t}\n\t}\n\n\tstatic double dist(int i, int j) {\n\t\tdouble d = Math.sqrt(sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]));\n\t\treturn Math.max(0, d - r[i] - r[j]);\n\t}\n\n\tstatic double sq(double v) {\n\t\treturn v * v;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tclass UnionFind{\n\t\tint[] pars;\n\t\tUnionFind(int n){\n\t\t\tpars = new int[n];\n\t\t\tfor(int i=0; i<n; i++) pars[i] = i;\n\t\t}\n\t\tint getRoot(int x){\n\t\t\treturn x==pars[x]?x:(pars[x] = getRoot(pars[x]));\n\t\t}\n\t\tboolean isSame(int x, int y){\n\t\t\treturn getRoot(x) == getRoot(y);\n\t\t}\n\t\tvoid merge(int x, int y){\n\t\t\tpars[getRoot(x)] = getRoot(y);\n\t\t}\n\t}\n\n\tdouble sq(double x){ return x*x; }\n\n\tclass Cell{\n\t\tdouble x, y, z, r;\n\t\tCell(double _x, double _y, double _z, double _r){\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.z = _z;\n\t\t\tthis.r = _r;\n\t\t}\n\t\tdouble getDist(Cell a){\n\t\t\treturn sqrt(sq(x-a.x) + sq(y-a.y) + sq(z-a.z));\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tdouble dist;\n\t\tint a, b;\n\t\tEdge(double _d, int _a, int _b){\n\t\t\tthis.dist = _d;\n\t\t\tthis.a = _a;\n\t\t\tthis.b = _b;\n\t\t}\n\t}\n\n\tclass Cmp implements Comparator<Edge>{\n\t\tpublic int compare(Edge e1, Edge e2){\n\t\t\treturn e1.dist>e2.dist?1:e1.dist<e2.dist?-1:0;\n\t\t}\n\t}\n\n\tint N;\n\tCell[] cells;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tcells = new Cell[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tcells[i] = new Cell(in.nextDouble(), in.nextDouble(), in.nextDouble(), in.nextDouble());\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.3f\\n\", solve());\n\t\t}\n\t}\n\n\n\tdouble solve(){\n\t\tdouble ret = 0.0;\n\t\tUnionFind uf = new UnionFind(N);\n\t\tArrayList<Edge> es = new ArrayList<Edge>();\n\t\tfor(int i=0; i<N; i++){\n\t\t\tfor(int j=i+1; j<N; j++){\n\t\t\t\tdouble d = cells[i].getDist(cells[j]) - cells[i].r - cells[j].r;\n\t\t\t\tif(d <= 0) uf.merge(i, j);\n\t\t\t\telse es.add(new Edge(d, i, j));\n\t\t\t}\n\t\t}\n\t\tEdge[] ees = (Edge[])es.toArray(new Edge[0]);\n\t\tsort(ees, new Cmp());\n\t\tfor(int i=0; i<ees.length; i++){\n\t\t\tif(!uf.isSame(ees[i].a, ees[i].b)){\n\t\t\t\tuf.merge(ees[i].a, ees[i].b);\n\t\t\t\tret += ees[i].dist;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E implements Comparable<E> {\n\t\tdouble v;\n\t\tint a;\n\t\tint b;\n\n\t\tE(double vv, int aa, int bb) {\n\t\t\tv = vv;\n\t\t\ta = aa;\n\t\t\tb = bb;\n\t\t}\n\n\t\tpublic int compareTo(E tar) {\n\t\t\treturn v - tar.v > 0 ? 1 : -1;\n\t\t}\n\t}\n\n\tclass S {\n\t\tdouble x;\n\t\tdouble y;\n\t\tdouble z;\n\t\tdouble r;\n\n\t\tS(double xx, double yy, double zz, double rr) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tz = zz;\n\t\t\tr = rr;\n\t\t}\n\n\t\tdouble dist(S t) {\n\t\t\tdouble xx = x - t.x;\n\t\t\tdouble yy = y - t.y;\n\t\t\tdouble zz = z - t.z;\n\t\t\tdouble dd = xx * xx + yy * yy + zz * zz;\n\t\t\tdouble d = Math.sqrt(dd);\n\n\t\t\tdouble r2 = r + t.r;\n\n\t\t\tif (r2 < d) {\n\t\t\t\treturn  d-r2;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[] s = new S[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ts[i] = new S(sc.nextDouble(), sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble dd = s[i].dist(s[j]);\n\t\t\t\t\tq.add(new E(dd,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint data[] = new int[n];\n\t\t\tint ne = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor (;;) {\n\t\t\t\tE now = q.poll();\n\t\t\t\tif(data[now.a] != 0 && data[now.b] == data[now.a] ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tne++;\n\t\t\t\tif((data[now.a] | data[now.b]) == 0){\n\t\t\t\t\tdata[now.a] = ne;\n\t\t\t\t\tdata[now.b] = ne;\n\t\t\t\t}\n\t\t\t\tif(data[now.a] == 0){\n\t\t\t\t\tdata[now.a] = data[now.b];\n\t\t\t\t}\n\t\t\t\tif(data[now.b] == 0){\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i =0 ; i< n ;i++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i!= now.b && data[i] == data[now.b]){\n\t\t\t\t\t\t\tdata[i]= data[now.a];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata[now.b] = data[now.a];\n\t\t\t\t}\n\t\t\t\tsum += now.v;\n\t\t\t\tif(ne == n-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = (long)(sum * 1000 + 0.5);\n\t\t\t\n\t\t\tSystem.out.print((res /1000));\n\t\t\tSystem.out.printf(\".%03d\\n\",(res %1000));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tInputStream in = System.in;\n\tPrintStream out = System.out;\n\n\tpublic void _main(String[] args) {\n\t\tScanner sc = new Scanner(in);\n\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tif(n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] z = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tList<Tuple3<Integer,Integer,Double>> edges = new ArrayList<>();\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\tdouble d = Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) + (z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\t\td -= r[i] + r[j];\n\t\t\t\t\td = Math.max(d, 0);\n\t\t\t\t\tedges.add(new Tuple3<>(i,j,d));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tedges.sort((a,b)->Double.compare(a.cdr.cdr.car, b.cdr.cdr.car));\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(n+1);\n\t\t\tdouble ans = 0;\n\t\t\tfor(Tuple3<Integer,Integer,Double> e : edges) {\n\t\t\t\tint a = e.car;\n\t\t\t\tint b = e.cdr.car;\n\t\t\t\tdouble w = e.cdr.cdr.car;\n\t\t\t\t\n\t\t\t\tif(!uf.same(a, b)) {\n\t\t\t\t\tans += w;\n\t\t\t\t\tuf.unite(a, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(String.format(\"%.3f\", ans));\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main()._main(args);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate String join(String delimiter, int[] a) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tsb.append(a[i]);\n\t\t\tsb.append(delimiter);\n\t\t}\n\t\treturn sb.substring(0, Math.max(sb.length() - delimiter.length(), 0));\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate String join(String delimiter, long[] a) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tsb.append(a[i]);\n\t\t\tsb.append(delimiter);\n\t\t}\n\t\treturn sb.substring(0, Math.max(sb.length() - delimiter.length(), 0));\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int max(int[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tint candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate > arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate long max(long[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tlong candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate > arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int min(int[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tint candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate < arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate long min(long[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tlong candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate < arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int[] nextIntArray(Scanner sc, int n) {\n\t\tint[] result = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = sc.nextInt();\n\t\t}\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate long[] nextLongArray(Scanner sc, int n) {\n\t\tlong[] result = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = sc.nextLong();\n\t\t}\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int[] nextIntArray1origin(Scanner sc, int n) {\n\t\tint[] result = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tresult[i] = sc.nextInt();\n\t\t}\n\t\treturn result;\n\t}\n}\nclass UnionFind {\n\n\tint[] par;\n\n\tpublic UnionFind(int size) {\n\t\tpar = new int[size];\n\t\tArrays.fill(par, -1);\n\t}\n\n\tpublic int root(int x) {\n\t\tif(par[x]<0) {\n\t\t\treturn x;\n\t\t}\n\t\tint z = root(par[x]);\n\t\tpar[x] = z;\n\t\treturn z;\n\t}\n\n\tpublic boolean same(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\n\tpublic void unite(int a, int b) {\n\t\tif(!same(a,b)) {\n\t\t\tint ra = root(a);\n\t\t\tint rb = root(b);\n\n\t\t\tif(par[ra] < par[rb]) {\n\t\t\t\tpar[ra] += par[rb];\n\t\t\t\tpar[rb] = ra;\n\t\t\t}else {\n\t\t\t\tpar[rb] += par[ra];\n\t\t\t\tpar[ra] = rb;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int size(int a) {\n\t\treturn -par[root(a)];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tUnionFind uni = new UnionFind(10);\n\t\tSystem.out.println(Arrays.toString(uni.par));\n\t\tuni.unite(1, 2);\n\t\tSystem.out.println(Arrays.toString(uni.par));\n\t\tuni.unite(3, 4);\n\t\tSystem.out.println(Arrays.toString(uni.par));\n\t\tuni.unite(1, 3);\n\t\tSystem.out.println(Arrays.toString(uni.par));\n\t\tSystem.out.println(uni.size(3));\n\t\tSystem.out.println(Arrays.toString(uni.par));\n\t\tuni.root(1);\n\t\tSystem.out.println(Arrays.toString(uni.par));\n\t}\n\n}\n\nclass Pair<A, B> {\n\tA car;\n\tB cdr;\n\n\tpublic Pair(A _car, B _cdr) {\n\t\tcar = _car;\n\t\tcdr = _cdr;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o == null || !(o instanceof Pair)) {\n\t\t\treturn false;\n\t\t}\n\t\tPair<?, ?> p = (Pair<?, ?>) o;\n\n\t\treturn ((car == null && p.car == null) || (car != null & car.equals(p.car))) &&\n\t\t\t\t((cdr == null && p.cdr == null) || (cdr != null & cdr.equals(p.cdr)));\n\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (car == null ? 0 : car.hashCode()) ^ (cdr == null ? 0 : cdr.hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn asList().toString();\n\t}\n\n\tpublic List<Object> asList() {\n\t\tList<Object> l = new ArrayList<>();\n\t\tl.add(car);\n\t\tif (cdr instanceof Pair) {\n\t\t\tl.addAll(((Pair<?, ?>) cdr).asList());\n\t\t}else {\n\t\t\tl.add(cdr);\n\t\t}\n\t\treturn l;\n\t}\n}\n\nclass Tuple1<A> extends Pair<A, Object> {\n\tpublic Tuple1(A a) {\n\t\tsuper(a, null);\n\t}\n\n\tpublic List<Object> asList(){\n\t\tList<Object> l = new ArrayList<>();\n\t\tl.add(car);\n\t\treturn l;\n\t}\n\n}\n\nclass Tuple2<A, B> extends Pair<A, Tuple1<B>> {\n\tpublic Tuple2(A a, B b) {\n\t\tsuper(a, new Tuple1<B>(b));\n\t}\n}\n\nclass Tuple3<A, B, C> extends Pair<A, Tuple2<B, C>> {\n\tpublic Tuple3(A a, B b, C c) {\n\t\tsuper(a, new Tuple2<B, C>(b, c));\n\t}\n}\n\nclass Tuple4<A, B, C, D> extends Pair<A, Tuple3<B, C, D>> {\n\tpublic Tuple4(A a, B b, C c, D d) {\n\t\tsuper(a, new Tuple3<B, C, D>(b, c, d));\n\t}\n}\n\nclass Tuple5<A, B, C, D, E> extends Pair<A, Tuple4<B, C, D, E>> {\n\tpublic Tuple5(A a, B b, C c, D d, E e) {\n\t\tsuper(a, new Tuple4<B, C, D, E>(b, c, d, e));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Edge implements Comparable<Edge>{\n\t\tdouble cost;\n\t\tint start, end;\n\t\t\n\t\tpublic Edge(double cost, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.cost = cost;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif(this.cost < o.cost){\n\t\t\t\treturn -1;\n\t\t\t}else if(this.cost > o.cost){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\t\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble[] x_pos = new double[n];\n\t\t\tdouble[] y_pos = new double[n];\n\t\t\tdouble[] z_pos = new double[n];\n\t\t\tdouble[] rad = new double[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_pos[i] = sc.nextDouble();\n\t\t\t\ty_pos[i] = sc.nextDouble();\n\t\t\t\tz_pos[i] = sc.nextDouble();\n\t\t\t\trad[i] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tqueue.add(new Edge(Math.max(0, Math.sqrt((x_pos[i] - x_pos[j])*(x_pos[i] - x_pos[j]) + \n\t\t\t\t\t\t\t\t\t\t\t\t\t(y_pos[i] - y_pos[j])*(y_pos[i] - y_pos[j]) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t(z_pos[i] - z_pos[j])*(z_pos[i] - z_pos[j])) - (rad[i] + rad[j])), i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind union = new UnionFind(n);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(count < (n - 1)){\n\t\t\t\tEdge edge = queue.poll();\n\t\t\t\t\n\t\t\t\tif(union.same(edge.start, edge.end)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tunion.unite(edge.start, edge.end);\n\t\t\t\t\tsum += edge.cost;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.3f\\n\", sum);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\n\t\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\twhile(true){\n        \tint vn=sc.nexI();\n        \t\n        \tif(vn==0){\n        \t    break;\n        \t}\n\t\t    \n\t\t    double[][] xyzr = new double[vn][4];\n\t\t    \n    \t   \tfor(int i=0; i<vn; i++){\n\t\t\t    for(int j=0; j<4; j++){\n\t\t\t        xyzr[i][j] = sc.nextDouble();\n\t\t\t    }\n    \t   \t}\n        \t   \t\n    \t\tint[] parent = new int[vn];\n    \t   \tfor(int i=0; i<vn; i++){\n    \t   \t    parent[i]=i;\n    \t   \t}\n\t\t    Queue<Edge> edges = new PriorityQueue<>(new Comparator_Edge());\n\t\t\n\t\t    double dis_tmp=0;\n    \t   \t\n    \t   \tfor(int i=0; i<vn; i++){\n\t\t\t    for(int j=0; j<vn; j++){\n\t\t\t        dis_tmp = 0;\n\t\t\t\t    for(int k=0; k<3; k++){\n\t\t\t\t        dis_tmp += pow2(xyzr[i][k]-xyzr[j][k]);\n\t\t\t\t    }\n\t\t\t\t    dis_tmp = Math.sqrt(dis_tmp);\n\t\t\t\t    dis_tmp -= xyzr[i][3];\n\t\t\t\t    dis_tmp -= xyzr[j][3];\n\t\t\t\t    if(dis_tmp<0){\n\t\t\t\t        unite_uf(parent, i, j);\n\t\t\t\t    }else{\n\t\t\t\t        edges.add(new Edge(i,j,dis_tmp));\n\t\t\t\t    }\n\t\t\t    }\n    \t   \t}\n    \t   \tdouble ans = 0.0;\n    \t   \twhile(edges.size()>0){\n    \t   \t    Edge e = edges.poll();\n    \t   \t    if(!is_same_uf(parent, e.from, e.v2)){\n    \t   \t        unite_uf(parent, e.from, e.v2);\n    \t   \t        ans += e.weight;\n    \t   \t    }\n    \t   \t}\n    \t   \tout.printf(\"%.3f\\n\",ans);\n\t\t}\n\t\tout.flush();\n\t}\n    \n    private static int get_root_uf(int[] parent, int index){\n        if(parent[index] == index) return index;\n        int root = get_root_uf(parent, parent[index]);\n        parent[index] = root;\n        return root;\n    }\n    \n    private static boolean is_same_uf(int[] parent, int x, int y){\n        if(get_root_uf(parent,x) == get_root_uf(parent,y)) return true;\n        else return false;\n    }\n    \n    private static void unite_uf(int[] parent, int receiver, int attacker){\n        parent[get_root_uf(parent,attacker)] = get_root_uf(parent, receiver);\n        return;\n    }\n\n\tprivate static int INF = (int)1e8;\n\tprivate static long INFL = (long)1e17;\n\tprivate static int e97 = (int)1e9 + 7;\n\t\n\t\n\tprivate static int abs(int a){  return (a>=0) ? a: -a;  }\n\tprivate static long abs(long a){    return (a>=0) ? a: -a;  }\n\t\n\tprivate static int min(int a, int b){   return (a>b) ? b : a;   }\n\tprivate static long min(long a, long b){    return (a>b) ? b : a;   }\n\t\n\tprivate static int max(int a, int b){   return (a>b) ? a : b;   }\n\tprivate static long max(long a, long b){    return (a>b) ? a : b;   }\n\t\n\tprivate static int minN(int... ins){\n\t\tint min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] < min) min = ins[i];  }\n\t\treturn min;\n\t}\n\tprivate static int maxN(int... ins){\n\t\tint max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] > max) max = ins[i];  }\n\t\treturn max;\n\t}\n\tprivate static long minN(long... ins){\n\t\tlong min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] < min) min = ins[i];  }\n\t\treturn min;\n\t}\n\tprivate static long maxN(long... ins){\n\t\tlong max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] > max) max = ins[i];  }\n\t\treturn max;\n\t}\n\t\n\tprivate static int minExAd(int[] dt, int ad){\n\t    int min=Integer.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static long minExAd(long[] dt, int ad){\n\t    long min=Long.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static int minExVal(int[] dt, int ex_val){\n\t    int min=Integer.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static long minExVal(long[] dt, long ex_val){\n\t    long min=Long.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\t\n\tprivate static boolean same3(long a, long b, long c){\n    \tif(a!=b) return false;\n    \tif(b!=c) return false;\n    \tif(c!=a) return false;\n    \treturn true;\n\t}\n\tprivate static boolean dif3(long a, long b, long c){\n    \tif(a==b) return false;\n    \tif(b==c) return false;\n    \tif(c==a) return false;\n    \treturn true;\n\t}\n\t\n\tprivate static int factorial(int n) {\n\t\tint ans=1;\n\t\tfor(int i=n; i>0; i--){ ans*=i; }\n\t\treturn ans;\n\t}\n\t\n\tprivate static long gcd(long m, long n) {\n\t\tif(m < n) return gcd(n, m);\n\t\tif(n == 0) return m;\n\t\treturn gcd(n, m % n);\n\t}\n\t\n\tprivate static int pow2(int in){    return in*in;   }\n\tprivate static long pow2(long in){  return in*in;   }\n\tprivate static double pow2(double in){    return in*in;   }\n\t\n\tprivate static int getDigit2(long num){\n\t\tlong cf = 1;\n\t\tint d=0;\n\t\twhile(num >= cf){\n\t\t\td++;\n\t\t\tcf = 1<<d;\n\t\t}\n\t\treturn d; //numはd桁の数で、2^dより小さい\n\t}\n\t\n\tprivate static int getDigit10(long num){\n\t\tlong cf = 1;\n\t\tint d=0;\n\t\twhile(num >= cf){\n\t\t\td++;\n\t\t\tcf*=10;\n\t\t}\n\t\treturn d; //numはd桁の数で、10^dより小さい\n\t}\n\t\n\tprivate static boolean isINF(int in){\n    \tif((in*20)>INF) return true;\n    \telse return false;\n\t}\n\tprivate static boolean isINFL(long in){\n    \tif((in*10000)>INFL) return true;\n    \telse return false;\n\t}\n\t\n\tprivate static long pow10E97(long ob, int soeji){\n\t\tif(soeji==2) return (ob*ob)%e97;\n\t\t\n\t\tint d = getDigit2(soeji);\n\t\tlong[] ob_pow_2pow = new long[d];\n\t\t\n\t\tob_pow_2pow[0] = ob;\n\t\tfor(int i=1; i<d; i++){ ob_pow_2pow[i] = (ob_pow_2pow[i-1]*ob_pow_2pow[i-1])%e97;   }\n\t\t\n\t\tlong ans=1;\n\t\tfor(int i=d-1; i>=0; i--){\n\t\t\tif(soeji >= (1<<i)){\n\t\t\t\tsoeji -= (1<<i);\n\t\t\t\tans = (ans*ob_pow_2pow[i])%e97;\n\t\t\t}\n \t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tprivate static int flag(int pos){   return (1<<pos);    }\n\tprivate static boolean isFlaged(int bit, int pos){\n    \tif((bit&(1<<pos)) > 0) return true;\n    \telse return false;\n\t}\n\tprivate static int deflag(int bit, int pos){    return bit&~(1<<pos);   }\n\t\n\tprivate static void showflag(int bit){\n    \tfor(int i=0; i<getDigit2(bit); i++){\n        \tif(isFlaged(bit,i)) System.out.print(\"O\");\n        \telse System.out.print(\".\");\n    \t}\n\t}\n\t\n\t\n\tprivate static void fill(boolean[] ob, boolean res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t\treturn;\n\t}\n\tprivate static void fill(int[] ob, int res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t\treturn;\n\t}\n\tprivate static void fill(long[] ob, long res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t\treturn;\n\t}\n\tprivate static void fill(char[] ob, char res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t\treturn;\n\t}\n\tprivate static void fill(boolean[][] ob, boolean res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t\treturn;\n\t}\n\tprivate static void fill(int[][] ob, int res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t\treturn;\n\t}\n\tprivate static void fill(long[][] ob, long res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t\treturn;\n\t}\n\tprivate static void fill(char[][] ob, char res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t\treturn;\n\t}\n\tprivate static void fill(int[][][] ob, int res){\n\t\tfor(int i=0; i<ob.length; i++){\n\t\t\tfor(int j=0; j<ob[0].length; j++){\n\t\t\t\tfor(int k=0; k<ob[0][0].length; k++){\n\t\t\t        ob[i][j][k] = res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tprivate static void fill(long[][][][] ob, long res){\n\t\tfor(int i=0; i<ob.length; i++){\n\t\t\tfor(int j=0; j<ob[0].length; j++){\n\t\t\t\tfor(int k=0; k<ob[0][0].length; k++){\n    \t\t\t\tfor(int l=0; l<ob[0][0][0].length; l++){\n    \t\t\t\t    ob[i][j][k][l]=res;\n    \t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t\n\tstatic void show_b2(boolean[][] dt, int lit_x, int lit_y){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt[0].length; i++){\n\t\t\tfor(int j=0; j<dt.length; j++){\n\t\t\t\tif((i==lit_y) && (j==lit_x)) out.print(\"X\");\n\t\t\t\telse if(dt[j][i]) out.print(\"O\");\n\t\t\t\telse out.print(\".\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void show_L2(long[][] dt, String cmnt){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt[0].length; i++){\n\t\t\tfor(int j=0; j<dt.length; j++){\n\t\t\t\tout.print(dt[j][i]+\",\");\n\t\t\t}\n\t\t\tout.println(\"<-\"+cmnt+\":\"+i);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void disp_que(ArrayDeque<Integer> dt){\t\t//上手くいかなかった時用\n\t\tint a=0;\n\t\twhile(dt.size()>0){\n\t\t\ta=dt.removeLast();\n\t\t\tSystem.out.print(a);\n\t\t}\n\t\tSystem.out.println(\"\\n\");\n\t}\n\t\n\t\n\tprivate static void nextPerm(ArrayList<Integer> former){\n\t\tint pivot=-1;\n\t\tint ln = former.size();\n\t\tfor(int i = ln; i>1; i--){\n\t\t\tif(former.get(i-2) < former.get(i-1)){\n\t\t\t\tpivot = i-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pivot==-1){\n    \t\tformer = null;\n    \t\treturn;\n\t\t}\n\t\tint pivot_fig = former.get(pivot);\n\t\t\n\t\tint min_pos=pivot+1;\n\t\tint min=former.get(min_pos);\n\t\tfor(int i=ln-1; i > pivot+1; i--){\n\t\t\tif((former.get(i) < min)&&(former.get(i) > pivot_fig)){\n\t\t\t\tmin_pos=i;\n\t\t\t\tmin=former.get(min_pos);\n\t\t\t}\n\t\t}\n\t\tCollections.swap(former, pivot, min_pos);\n\t\tCollections.sort(former.subList(pivot+1, ln));\n\t\treturn;\n\t}\n    private static ArrayList<boolean[]> combi_enum(int ln, boolean[] former, int now_pos, int rest){\n        ArrayList<boolean[]> ans = new ArrayList<>();\n        boolean[] ans1 = new boolean[former.length+1];\n\t   \tfor(int i=0; i<former.length; i++){\n\t   \t    ans1[i] = former[i];\n\t   \t}\n        if(ln==(now_pos+1)){\n            switch(rest){\n                case 0:\n                    ans1[former.length] = false;\n                    ans.add(ans1);\n                    break;\n                case 1:\n                    ans1[former.length] = true;\n                    ans.add(ans1);\n                    break;\n            }\n        }else{\n            if(rest == 0){\n                ans1[former.length] = false;\n                ans.addAll(combi_enum(ln, ans1, now_pos+1, rest));\n            }else{\n                ans1[former.length] = false;\n                ans.addAll(combi_enum(ln, ans1.clone(), now_pos+1, rest));\n                ans1[former.length] = true;\n                ans.addAll(combi_enum(ln, ans1.clone(), now_pos+1, rest-1));\n            }\n        }\n        return ans;\n    }\n\t\n\tpublic static int biSearch(int[] dt, int target){\n\t\tint left=0, right=dt.length-1;\n\t\tint mid=-1;\n\t\twhile(left<=right){\n\t\t\tmid = (right+left)/2;\n\t\t\tif(dt[mid] == target) return mid;\n\t\t\tif(dt[mid] < target) left=mid+1;\n\t\t\telse right=mid-1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int biSearchMax(long[] dt, long target){\n\t\tint left=-1, right=dt.length;\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt[mid] < target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;//target未満の最大のaddress\n\t}\n\tpublic static int biSearchMaxAL(ArrayList<Integer> dt, long target){\n\t\tint left=-1, right=dt.size();\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt.get(mid) < target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;//target未満の最大のaddress\n\t}\n\t\n\t\n\tprivate static int dfs2(boolean[][] state, int x, int y, int depth){\t\t//薄氷渡り\n\t\tint[] tmpltX = {1,-1,0,0};\n\t\tint[] tmpltY = {0,0,1,-1};\n\t\tint newX = -1, newY = -1;\n\t\t\n\t\tstate[x][y] = false;\n\t\tdepth++;\n\t\t\n\t\tint maxDunder_this_brunch = depth, tmpD=0;\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tnewX = x+tmpltX[i];\n\t\t\tnewY = y+tmpltY[i];\n\t\t\tif((newX >= 0) && (newY >= 0) && (newX < state.length) && (newY < state[0].length) && state[newX][newY]) tmpD = dfs2(state, newX, newY, depth);\n\t\t\tif(tmpD > maxDunder_this_brunch) maxDunder_this_brunch=tmpD;\n\t\t}\n\t\tstate[x][y] = true;\n\t\treturn maxDunder_this_brunch;\n\t}\n\t\n    private static int areaSum(int[][] acum_plus1, int bY_notInclude, int aY_include, int bX_notInclude, int aX_include){\n        int ans = acum_plus1[aY_include+1][aX_include+1];\n        ans -= acum_plus1[aY_include+1][bX_notInclude+1];\n        ans -= acum_plus1[bY_notInclude+1][aX_include+1];\n        ans += acum_plus1[bY_notInclude+1][bX_notInclude+1];\n        return ans;\n    }\n    \n    \n    \n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n        Graph0n(int sz){\n\t   \t    for(int i=0; i<sz; i++){\n\t   \t        Node0n node1 = new Node0n();\n\t   \t        dt.add(node1);\n\t   \t    }\n        }\n        public void add(int vn, int val){\n            dt.get(vn).add(val);\n        }\n        public int get(int vn, int index){\n            return dt.get(vn).get(index);\n        }\n        public ArrayList<Integer> get(int vn){\n            return dt.get(vn).getAll();\n        }\n        public void clear(){\n            for(int i=0; i<dt.size(); i++){\n                dt.get(i).clear();\n            }\n        }\n    }\n    \n    static class Node0n {   //重みなし無向グラフの頂点\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n        public void add(int val){\n            next_vs.add(val);\n        }\n        public int get(int ad){\n            return next_vs.get(ad);\n        }\n        public ArrayList<Integer> getAll(){\n            return next_vs;\n        }\n        public void clear(){\n            next_vs.clear();\n        }\n    }\n\n    static class Edge {\n        int from=-1;\n        int v2;\n        double weight;\n        public Edge(int vn, double w){\n            this.v2 = vn;\n            this.weight = w;\n        }\n        public Edge(int cm, int vn, double w){\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n    static class Edge2 {\n        int v2;\n        long cost1,cost2;\n        public Edge2(int vn, long w1, long w2){\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge>{\n        public int compare(Edge a, Edge b){\n            if(a.weight>b.weight){\n                return 1;\n            }else if(a.weight<b.weight){\n                return -1;\n            }\n            return 0;\n        }\n    }\nstatic class FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nexL() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nexI() {\n\t\tlong nl = nexL();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\t\n\tpublic void ni(long[] array2){\n\t   \tfor(int i=0; i<array2.length; i++){\n\t   \t    array2[i] = nexL();\n\t   \t}\n\t   \treturn;\n\t}\n\tpublic void ni(int[] array2){\n\t   \tfor(int i=0; i<array2.length; i++){\n\t   \t    array2[i] = nexI();\n\t   \t}\n\t   \treturn;\n\t}\n}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    static int n;\n    static double[] x,y,z,r;\n    static double min;\n    static double[][] cost;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tn = sc.nextInt();\n\n\twhile(n!=0){\n\t    x = new double[n];\n\t    y = new double[n]; \n\t    z = new double[n];\n\t    r = new double[n];\n\t    for(int i=0; i<n; i++){\n\t\tx[i] = sc.nextDouble();\n\t\ty[i] = sc.nextDouble();\n\t\tz[i] = sc.nextDouble();\n\t\tr[i] = sc.nextDouble();\n\t    }\n\n\t    min = Double.MAX_VALUE;\n\t    solve();\n\t    if(min==Double.MAX_VALUE){min=0.000;}\n\t    System.out.printf(\"%1.3f\",min);\n\t    System.out.println();\n\n\t    n = sc.nextInt();\n\t}\n    }\n\n    public static void solve(){\n\tcost = new double[n][n];\n\tfor(int i=0; i<n; i++){\n\t    for(int j=i+1; j<n; j++){\n\t\tcost[i][j] = getDistance(i,j);\n\t\tif(cost[i][j]<0)cost[i][j]=0.0;\n\t    }\n\t}\n\n\tmin = getMin();\n    }\n\n    public static double getDistance(int i, int j){\n\treturn Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]))-r[i]-r[j];\n    }\n\n    public static double getMin(){\n\tdouble[] mincost = new double[n];\n\tboolean[] used = new boolean[n];\n\tfor(int i=0; i<n; i++){\n\t    mincost[i] = 1000000000;\n\t    used[i] = false;\n\t}\n\tmincost[0] = 0;\n\tdouble res = 0;\n\n\twhile(true){\n\t    int v = -1;\n\t    for(int i=0; i<n; i++){\n\t\tif(!used[i] && (v==-1 || (mincost[i]<mincost[v]))){v = i;}\n\t    }\n\n\t    if(v==-1)break;\n\t    used[v] = true;\n\t    res += mincost[v];\n\n\t    for(int i=0; i<n; i++){\n\t\tmincost[i] = mincost[i];\n\t\tif(mincost[i]>cost[v][i]){mincost[i]=cost[v][i];}\n\t    }\n\t}\n\treturn res;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tdouble xs[];\n\tdouble ys[];\n\tdouble zs[];\n\tdouble rs[];\n\tdouble distance[];\n\tint count;\n\tpublic void calc(int n){\n\t\txs = new double[n];\n\t\tys = new double[n];\n\t\tzs = new double[n];\n\t\trs = new double[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\txs[i] = sc.nextDouble();\n\t\t\tys[i] = sc.nextDouble();\n\t\t\tzs[i] = sc.nextDouble();\n\t\t\trs[i] = sc.nextDouble();\t\t\t\n\t\t}\n\t\t\n\t\tdistance = new double[n];\n\t\tArrays.fill(distance, Double.MAX_VALUE);\n\t\t\n\t\tdouble ans = 0;\n\t\t\n\t\tdistance[0] = -1;\n\t\tcount = 1;\t\n\t\tupdate(0, n);\n\t\t\n\t\twhile(count < n){\n\t\t\tint small = -1;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(distance[k] != -1 && (small == -1 || distance[k] < distance[small])){\n\t\t\t\t\tsmall = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += distance[small];\n\t\t\tdistance[small] = -1;\n\t\t\tcount++;\n\t\t\tupdate(small, n);\n\t\t}\n\t\tSystem.out.printf(\"%.3f\\n\", ans);\n\t}\n\t\n\tpublic void update(int a, int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(distance[i] != -1){\n\t\t\t\tdouble d = dist(a, i);\n\t\t\t\tif(d == 0){\n\t\t\t\t\tdistance[i] = -1;\n\t\t\t\t\tcount++;\n\t\t\t\t\tupdate(i, n);\n\t\t\t\t}\n\t\t\t\telse if(d < distance[i]) distance[i] = d;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double dist(int a, int b){\n\t\tdouble d = Math.sqrt(\n\t\t\t\t  (xs[a]-xs[b]) * (xs[a]-xs[b]) +\n\t\t\t\t  (ys[a]-ys[b]) * (ys[a]-ys[b]) +\n\t\t\t\t  (zs[a]-zs[b]) * (zs[a]-zs[b])\n\t\t\t\t);\n\t\td = d - rs[a] - rs[b];\n\t\tif(d < 0) d = 0;\n\t\treturn d;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().new P1127().run(); \n\t}\n\tclass P1127{\n\t\tvoid run(){\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\tfor(;;){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\t\n\t\t\t\tPos[] p=new Pos[n];\n\t\t\t\tQueue<Node> q=new PriorityQueue<Node>();\n\t\t\t\tboolean[] visited=new boolean[n];\n\t\t\t\tint nvis=0;\n\t\t\t\tdouble ans=0;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tdouble x,y,z,r;\n\t\t\t\t\tx=sc.nextDouble();\n\t\t\t\t\ty=sc.nextDouble();\n\t\t\t\t\tz=sc.nextDouble();\n\t\t\t\t\tr=sc.nextDouble();\n\t\t\t\t\tp[i]=new Pos(x,y,z,r);\n\t\t\t\t\tvisited[i]=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Prim\n\t\t\t\tNode t=new Node(0,0);\n\t\t\t\tq.offer(t);\n\t\t\t\twhile(nvis<n){\n\t\t\t\t\tt=q.poll();\n\t\t\t\t\tif(visited[t.node])continue;\n\t\t\t\t\tvisited[t.node]=true;\n\t\t\t\t\tnvis++;\n\t\t\t\t\tans+=t.d;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif(!visited[i]){\n\t\t\t\t\t\t\tq.offer(new Node((p[t.node]).dist(p[i]),i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%.3f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n\tclass Pos{\n\t\tdouble x,y,z,r;\n\t\tPos(double x_,double y_,double z_,double r_){\n\t\t\tthis.x=x_;\n\t\t\tthis.y=y_;\n\t\t\tthis.z=z_;\n\t\t\tthis.r=r_;\n\t\t}\n\t\tdouble dist(Pos o){\n\t\t\tdouble ret=Math.sqrt((x-o.x)*(x-o.x)+(y-o.y)*(y-o.y)+(z-o.z)*(z-o.z))-(r+o.r);\n\t\t\treturn ret<=0?0:ret;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tdouble d;\n\t\tint node;\n\t\tpublic int compareTo(Node o){\n\t\t\tif(d<o.d)return -1;\n\t\t\tif(d==o.d)return 0;\n\t\t\telse return 1;\n\t\t}\n\t\tNode(double d_,int node_){\n\t\t\tthis.d=d_;\n\t\t\tthis.node=node_;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] z = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tz[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tArrayList<Edge> graph = new ArrayList<Edge>();\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\tdouble dist = Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])+(z[j]-z[i])*(z[j]-z[i])) - r[i] - r[j];\n\t\t\t\t\tif (dist<0) {\n\t\t\t\t\t\tdist = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgraph.add(new Edge(dist,i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(graph);\n\t\t\t//System.out.println(graph.toString());\n\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tdouble ans = 0;\n\t\t\tint connected = 1;\n\t\t\tfor(int i=0;i<graph.size();i++) {\n\t\t\t\tEdge e = graph.get(i);\n\t\t\t\tif (!uf.isConnected(e.from, e.to)) {\n\t\t\t\t\tuf.union(e.from, e.to);\n\t\t\t\t\tconnected++;\n\t\t\t\t\tans+=e.cost;\n\t\t\t\t\tif (connected==n) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}\nclass Edge implements Comparable<Edge>{\n\tdouble cost;\n\tint from;\n\tint to;\n\tpublic Edge(double cost,int from,int to) {\n\t\tthis.cost = cost;\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\tif (this.cost == o.cost) {\n\t\t\treturn 0;\n\t\t}else if(this.cost > o.cost) {\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\treturn this.cost + \",\" + this.from + \",\" + this.to;\n\t}\n}\n\nclass UnionFind {\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tpublic void union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        while (true) {\n            int n = Integer.parseInt(scan.next());\n            if (n == 0) {\n                scan.close();\n                return;\n            }\n\n            List<Node> nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                double x = Double.parseDouble(scan.next());\n                double y = Double.parseDouble(scan.next());\n                double z = Double.parseDouble(scan.next());\n                double r = Double.parseDouble(scan.next());\n                nodeList.add(new Node(i, x, y, z, r));\n            }\n\n            List<Edge> edgeList = new ArrayList<Edge>();\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    edgeList.add(new Edge(nodeList.get(i), nodeList.get(j)));\n                }\n            }\n            Collections.sort(edgeList);\n\n            double ans = 0;\n            UnionFind uf = new UnionFind(n);\n            for (Edge edge : edgeList) {\n                if (!uf.same(edge.n1.id, edge.n2.id) || edge.dist == 0) {\n                    uf.unite(edge.n1.id, edge.n2.id);\n                    ans += edge.dist;\n                }\n            }\n\n            System.out.println(String.format(\"%.3f\", ans));\n        }\n    }\n\n    static class Node {\n        int id;\n        double x;\n        double y;\n        double z;\n        double r;\n\n        public Node(int id, double x, double y, double z, double r) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.r = r;\n        }\n    }\n\n    static class Edge implements Comparable<Edge> {\n        Node n1;\n        Node n2;\n        double dist;\n\n        public Edge(Node n1, Node n2) {\n            this.n1 = n1;\n            this.n2 = n2;\n\n            double x = (n1.x - n2.x) * (n1.x - n2.x);\n            double y = (n1.y - n2.y) * (n1.y - n2.y);\n            double z = (n1.z - n2.z) * (n1.z - n2.z);\n            double distance = Math.sqrt(x + y + z);\n            dist = distance - n1.r - n2.r;\n            if (dist < 0) {\n                dist = 0;\n            }\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            if (dist < o.dist) {\n                return -1;\n            } else if (dist > o.dist) {\n                return 1;\n            } else if (n1.id != o.n1.id) {\n                return n1.id - o.n1.id;\n            } else {\n                return n2.id - o.n2.id;\n            }\n        }\n    }\n\n    static class UnionFind {\n\n        /** ルートノード */\n        private int[] roots;\n\n        /**\n         * コンストラクタ.\n         *\n         * @param n ノード数\n         */\n        public UnionFind(int n) {\n            roots = new int[n];\n            for (int i = 0; i < n; i++) {\n                roots[i] = i;\n            }\n        }\n\n        /**\n         * 各々のノードが属するグループを結合する.\n         *\n         * @param x\n         * @param y\n         */\n        public void unite(int x, int y) {\n            roots[getRoot(y)] = getRoot(x);\n        }\n\n        /**\n         * 各々のノードが属するグループが同じかどうかを判定する.\n         *\n         * @param x\n         * @param y\n         * @return 同じグループに属するならtrue\n         */\n        public boolean same(int x, int y) {\n            return getRoot(x) == getRoot(y);\n        }\n\n        /**\n         * ルートノードを返す.<br>\n         * 再帰によって経路圧縮を行っている.\n         *\n         * @param x\n         * @return ルートノード\n         */\n        public int getRoot(int x) {\n            int parent = roots[x];\n            if (x != parent) {\n                roots[x] = getRoot(parent);\n            }\n            return roots[x];\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tdouble M=1000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tdouble x[]=new double[n];\n\t\t\tdouble y[]=new double[n];\n\t\t\tdouble z[]=new double[n];\n\t\t\tdouble r[]=new double[n];\n\t\t\tdouble cost[][]=new double[n][n];\n\t\t\tdouble mincost[]=new double[n];//頂点iへの辺の最小コスト\n\t\t\tboolean use[]=new boolean[n];//頂点iが部分全域木に含まれているか\n\t\t\tdouble total=0;//answer\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tArrays.fill(mincost, M);\n\t\t\tArrays.fill(use, false);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tx[i]=in.nextDouble();\n\t\t\t\ty[i]=in.nextDouble();\n\t\t\t\tz[i]=in.nextDouble();\n\t\t\t\tr[i]=in.nextDouble();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble dif=Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));\n\t\t\t\t\tif(dif<=r[i]+r[j])\n\t\t\t\t\t\tcost[i][j]=cost[j][i]=0;\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[i][j]=cost[j][i]=dif-(r[i]+r[j]);\n\t\t\t\t}\n\t\t\tmincost[0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint v=-1;//追加する頂点\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)//追加する頂点を探す\n\t\t\t\t\tif(!use[j]&&(v==-1||mincost[v]>mincost[j]))\n\t\t\t\t\t\tv=j;\n\t\t\t\tif(v==-1) //全ての頂点を選んだ\n\t\t\t\t\tbreak;\n\t\t\t\tif(mincost[v]!=0)\n\t\t\t\t\ttotal+=mincost[v];\n\t\t\t\tuse[v]=true;\n\t\t\t\tfor(int j=0;j<n;j++)//追加した頂点と繋がっている辺を調べ最小コストを更新\n\t\t\t\t{\n\t\t\t\t\tif(!use[j]&&mincost[j]>cost[v][j])\n\t\t\t\t\t\tmincost[j]=cost[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.3f\\n\",total);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Edge implements Comparable<Edge>{\n\t\tdouble cost;\n\t\tint start, end;\n\t\t\n\t\tpublic Edge(double cost, int start, int end) {\n\t\t\tsuper();\n\t\t\tthis.cost = cost;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif(this.cost < o.cost){\n\t\t\t\treturn -1;\n\t\t\t}else if(this.cost > o.cost){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\t\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdouble[] x_pos = new double[n];\n\t\t\tdouble[] y_pos = new double[n];\n\t\t\tdouble[] z_pos = new double[n];\n\t\t\tdouble[] rad = new double[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_pos[i] = sc.nextDouble();\n\t\t\t\ty_pos[i] = sc.nextDouble();\n\t\t\t\tz_pos[i] = sc.nextDouble();\n\t\t\t\trad[i] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Edge> queue = new PriorityQueue<Edge>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tqueue.add(new Edge(Math.max(0, Math.sqrt((x_pos[i] - x_pos[j])*(x_pos[i] - x_pos[j]) + \n\t\t\t\t\t\t\t\t\t\t\t\t\t(y_pos[i] - y_pos[j])*(y_pos[i] - y_pos[j]) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t(z_pos[i] - z_pos[j])*(z_pos[i] - z_pos[j])) - (rad[i] + rad[j])), i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind union = new UnionFind(n);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(count < (n - 1)){\n\t\t\t\tEdge edge = queue.poll();\n\t\t\t\t\n\t\t\t\tif(union.same(edge.start, edge.end)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tunion.unite(edge.start, edge.end);\n\t\t\t\t\tsum += edge.cost;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Building a Space Station\npublic class Main{\n\n\tclass E implements Comparable<E>{\n\t\tint s, t;\n\t\tdouble d;\n\t\tpublic E(int s, int t, double d) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn d-o.d<0?-1:o.d-d<0?1:0;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tUnionFind u = new UnionFind(n);\n\t\t\tdouble[][] p = new double[n][3];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++)p[i][j]=sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tif(u.find(i, j))continue;\n\t\t\t\tdouble d = Math.sqrt(Math.pow(p[i][0]-p[j][0], 2)+Math.pow(p[i][1]-p[j][1], 2)+Math.pow(p[i][2]-p[j][2], 2))-r[i]-r[j];\n\t\t\t\tif(d<1e-6)u.union(i, j);\n\t\t\t\telse q.add(new E(i, j, d));\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile(u.num>1){\n\t\t\t\tE e = q.poll();\n\t\t\t\tif(!u.find(e.s, e.t)){\n\t\t\t\t\tu.union(e.s, e.t);\n\t\t\t\t\tres+=e.d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.3f\\n\", res);\n\t\t}\n\t}\n\t\n\tclass UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\n\t\t// merge the set contains x and the set contains y\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t// decide if x and y belong to the same set\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\t// return size of the set contains x\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\t// return the number of sets\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdouble[][] stations = new double[n][4];\n\t\t\tfor (int i = 0; i < stations.length; i++) {\n\t\t\t\tstations[i][0] = sc.nextDouble();\n\t\t\t\tstations[i][1] = sc.nextDouble();\n\t\t\t\tstations[i][2] = sc.nextDouble();\n\t\t\t\tstations[i][3] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tPriorityQueue<Edge> edges = new PriorityQueue<Edge>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tdouble x1 = stations[i][0];\n\t\t\t\t\tdouble x2 = stations[j][0];\n\t\t\t\t\tdouble y1 = stations[i][1];\n\t\t\t\t\tdouble y2 = stations[j][1];\n\t\t\t\t\tdouble z1 = stations[i][2];\n\t\t\t\t\tdouble z2 = stations[j][2];\n\t\t\t\t\tdouble r1 = stations[i][3];\n\t\t\t\t\tdouble r2 = stations[j][3];\n\n\t\t\t\t\tdouble dist = Math.sqrt(Math.pow((x1 - x2), 2)\n\t\t\t\t\t\t\t+ Math.pow((y1 - y2), 2) + Math.pow((z1 - z2), 2))\n\t\t\t\t\t\t\t- r1 - r2;\n\t\t\t\t\tdist = Math.max(dist, 0);\n\t\t\t\t\tedges.add(new Edge(dist, i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// クラスカル法\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tdouble cost = 0;\n\t\t\twhile (!edges.isEmpty()) {\n\t\t\t\tEdge e = edges.poll();\n\t\t\t\tif (!uf.same(e.from, e.to)) {\n\t\t\t\t\tcost += e.weight;\n\t\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBigDecimal bd = new BigDecimal(String.valueOf(cost));\n\t\t\tSystem.out.println(bd.setScale(3, BigDecimal.ROUND_HALF_UP));\n\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tint[] par;\n\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpar[i] = i;\n\t}\n\n\tpublic int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tpublic Boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tpublic void unite(int x, int y) {\n\t\tif (find(x) == find(y))\n\t\t\treturn;\n\t\tpar[find(x)] = find(y);\n\t}\n}\n\nclass Edge implements Comparable<Edge> {\n\tdouble weight;\n\tint from, to;\n\n\tEdge(double w, int f, int t) {\n\t\tthis.weight = w;\n\t\tthis.from = f;\n\t\tthis.to = t;\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge edge) {\n\t\t// 昇順\n\t\tif (this.weight > edge.weight) {\n\t\t\treturn 1;\n\t\t} else if (this.weight == edge.weight) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ_VOLUME11_1127\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> anss = new List<double>();\n            while (true)\n            {\n                var N = int.Parse(Console.ReadLine());\n                if (N == 0) break;\n\n                Sphere[] spheres = new Sphere[N];\n                for (int i = 0; i < N; i++)\n                {\n                    var xyzr = Console.ReadLine().Split().Select(double.Parse).ToArray();\n\n                    Sphere s = new Sphere();\n                    s.x = xyzr[0];\n                    s.y = xyzr[1];\n                    s.z = xyzr[2];\n                    s.r = xyzr[3];\n                    spheres[i] = s;\n                }\n\n                UnionFind unionFind = new UnionFind(N);\n\n                //エッジ情報の取得\n                List<Edge> edges = new List<Edge>();\n                for (int i = 0; i < N; i++)\n                {\n                    for (int j = 0; j < N; j++)\n                    {\n                        if (i == j) continue;\n                        double xd = spheres[i].x - spheres[j].x;\n                        double yd = spheres[i].y - spheres[j].y;\n                        double zd = spheres[i].z - spheres[j].z;\n\n                        double distance = Math.Pow(xd * xd + yd * yd + zd * zd, 0.5) - spheres[i].r - spheres[j].r;\n                        if (distance < 0.00001) unionFind.Unite(i, j);\n                        else edges.Add(new Edge() { s = i, t = j, cost = distance });\n                    }\n                }\n\n                //昇順にソートが必要\n                edges = edges.OrderBy(x => x.cost).ToList();\n\n\n                double ans = 0;   //最小コスト\n                foreach (var e in edges)\n                {\n                    //結合済みでないなら追加\n                    if (!unionFind.Same(e.s, e.t))\n                    {\n                        unionFind.Unite(e.s, e.t);\n                        ans += e.cost;\n                    }\n                }\n\n                anss.Add(ans);\n            }\n\n            foreach (var a in anss)\n            {\n                Console.WriteLine(\"{0:0.000}\",a);\n            }\n            Console.ReadKey();\n        }\n\n        struct Sphere\n        {\n            public double x;\n            public double y;\n            public double z;\n            public double r;\n        }\n\n        struct Edge\n        {\n            public int s;\n            public int t;\n            public double cost;\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n\n    class UnionFind\n    {\n        int[] par;\n        int[] rank;\n\n        public UnionFind(int n)\n        {\n            init(n);\n        }\n\n        void init(int n)\n        {\n            par = new int[n];\n            rank = new int[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                par[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int Find(int x)\n        {\n            if (par[x] == x)\n            {\n                return x;\n            }\n            else\n            {\n                return par[x] = Find(par[x]);\n            }\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Find(x);\n            y = Find(y);\n            if (x == y) return;\n\n            if (rank[x] < rank[y])\n            {\n                par[x] = y;\n            }\n            else\n            {\n                par[y] = x;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n\n        }\n        public bool Same(int x, int y)\n        {\n            return Find(x) == Find(y);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Math;\n \npublic class Solve{\n    static public int mod = 1000000007;\n    public static void Main(){\n        // 方針\n        //\n        while(true){\n        var n = rint();\n        if(n == 0) break;\n        var xlist = new List<double>();\n        var ylist = new List<double>();\n        var zlist = new List<double>();\n        var rlist = new List<double>();\n        for(int i=0;i<n;i++){\n            var a = stra();\n            xlist.Add(double.Parse(a[0]));\n            ylist.Add(double.Parse(a[1]));\n            zlist.Add(double.Parse(a[2]));\n            rlist.Add(double.Parse(a[3]));\n        }\n        var pq3d = new PriorityQueue3d();\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                double xdis = (xlist[i]-xlist[j]) * (xlist[i]-xlist[j]);\n                double ydis = (ylist[i]-ylist[j]) * (ylist[i]-ylist[j]);\n                double zdis = (zlist[i]-zlist[j]) * (zlist[i]-zlist[j]);\n                double distance = Max(Sqrt(xdis+ydis+zdis) - rlist[i] - rlist[j],0.0);\n                pq3d.Enqueue(distance,i,j);\n            }\n        }\n        \n        var uf = new UnionFind(n);\n        double ans = 0;\n        while(pq3d.Count() > 0){\n            var de = pq3d.Dequeue();\n            //WriteLine(string.Join(\" \",de));\n            \n            double dis = double.Parse(de[0]);\n            int num1 = int.Parse(de[1]);\n            int num2 = int.Parse(de[2]);\n            if(!uf.same(num1,num2)){\n                uf.unite(num1,num2);\n                ans += dis;\n            }\n            \n        }\n        WriteLine(ans.ToString(\"F3\"));\n        }\n\t\n\t\n    }\n    public static void swap(ref int a,ref int b){int temp = a;a= b;b = temp;}\n    static void charswap(ref char a,ref char b){char temp = a;a= b;b = temp;}\n    static int ncr(int n,int r){if(n<r)return 0;r = Min(r,n-r);long nn = 1;for(int i=n-r+1;i<=n;i++){nn = nn*i%mod;}long rr = 1;for(int i=1;i<=r;i++){rr = rr*i%mod;}rr = square((int)rr,mod-2);nn = nn * rr %mod;return (int)nn;}\n    // a^b mod\n    static int square(int a,int b){string binary = Convert.ToString(b,2);int bileng = binary.Length;long a_power = a;long value = 1;for(int i=bileng-1;i>=0;i--){if(binary[i] == '1'){value = value*a_power%mod;}a_power = a_power*a_power%mod;}return (int)value;}\n    static int square2(int a,int b){long output = 1;var list = new List<long>();int sh = 1;long n = a;list.Add(a);while(sh < b){sh *= 2;n = n*n%mod;list.Add(n);}for(int i=list.Count-1;i>=0;i--){if(b > sh){b -= sh;sh /= 2;output = output*list[i]%mod;}}return (int)output;}\n    //各種読取\n    static string rstr(){ return ReadLine(); }\n    static int rint(){ return int.Parse(ReadLine()); }\n    static long rlong(){ return long.Parse(ReadLine()); }\n    static string[] stra(){ return ReadLine().Split(' '); }\n    static char[] chara(){ string[] a=stra();string b=\"\";for(int i=0;i<a.Length;i++){b+=a[i];}return b.ToCharArray();}\n    static int[] inta(){ string[] read_str_array = ReadLine().Split(' '); int[] return_int_array = new int[read_str_array.Length]; for(int countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_int_array[countup_i] = int.Parse(read_str_array[countup_i]); } return return_int_array; }\n    static int[,] inta2(int num_array,int in_array){ int[,] int_array2 = new int[num_array,in_array]; for(int i=0;i<num_array;i++){ int[] temp_array = inta(); for(int j=0;j<in_array;j++){ int_array2[i,j] = temp_array[j]; } } return int_array2; }\n    static long[] longa(){ string[] read_str_array = ReadLine().Split(' '); long[] return_long_array = new long[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_long_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_long_array; }\n    static double[] doublea(){ string[] read_str_array = ReadLine().Split(' '); double[] return_double_array = new double[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_double_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_double_array; }\n    // -----------------------------\n    static long divideup(long divided,long divid){ long temp_divide = divided/divid; if(divided % divid > 0){ temp_divide++; } return temp_divide; }\n    static long GCD(long a,long b){ if(a < b){ long temp = a; a = b; b = temp; } if(a % b == 0){ return b; } else{ long temp = b; b = a%b; a = temp; return GCD(a,b); } }\n    static long LCM(long a,long b){ return a * b / GCD(a,b); }\n    static void WriteArray(int[,] a,int b,int c){for(int i=0;i<b;i++){for(int j=0;j<c;j++){if(j!=0) Write(\" \");Write(a[i,j]);}WriteLine();}}\n}\n\nclass UnionFind{\n    private int[] _unionfind;\n    private int[] _unionfind_size;\n    \n    public UnionFind(int a){\n        _unionfind = new int[a];\n        _unionfind_size = new int[a];\n        for(int i=0;i<a;i++){\n            _unionfind[i] = i;\n            _unionfind_size[i] = 1;\n        }\n    }\n    \n    public int root(int x){\n        if(_unionfind[x] == x) return x;\n        return _unionfind[x] = root(_unionfind[x]);\n    }\n    \n    public void unite(int a,int b){\n        a = root(a);\n        b = root(b);\n        if(a == b) return;\n        if(_unionfind_size[a] < _unionfind_size[b]){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        _unionfind[b] = a;\n        _unionfind_size[a] += _unionfind_size[b];\n    }\n    \n    public bool same(int a,int b){\n        return root(a) == root(b);\n    }\n    \n    public int size(int x){\n        return _unionfind_size[root(x)];\n    }\n}\n\nclass PriorityQueue3d{\n    private List<double> _priorityqueue = new List<double>();\n    private List<int> _accompany_info = new List<int>();\n    private List<int> _accompany_info2 = new List<int>();\n    \n    public void Enqueue(double a,int b,int c){\n        _priorityqueue.Add(a);\n        _accompany_info.Add(b);\n        _accompany_info2.Add(c);\n        int num = _priorityqueue.Count-1;\n        while(true){\n            if(num == 0) break;\n            if(_priorityqueue[(num-1)/2] > _priorityqueue[num]){ //大小逆の時弄るとこ\n                double tempd = _priorityqueue[(num-1)/2];\n                  _priorityqueue[(num-1)/2] = _priorityqueue[num];\n                  _priorityqueue[num] = tempd;\n                int temp = _accompany_info[(num-1)/2];\n                  _accompany_info[(num-1)/2] = _accompany_info[num];\n                  _accompany_info[num] = temp;\n                temp = _accompany_info2[(num-1)/2];\n                  _accompany_info2[(num-1)/2] = _accompany_info2[num];\n                  _accompany_info2[num] = temp;\n                num = (num-1)/2;\n            }else{\n                break;\n            }\n        }\n    }\n    \n    public string[] Dequeue(){\n        var re = new string[]{_priorityqueue[0].ToString(),_accompany_info[0].ToString(),_accompany_info2[0].ToString()};\n        var qcount = _priorityqueue.Count;\n        var tempd = _priorityqueue[0]; _priorityqueue[0] = _priorityqueue[qcount-1]; _priorityqueue[qcount-1] = tempd;\n        var temp = _accompany_info[0]; _accompany_info[0] = _accompany_info[qcount-1]; _accompany_info[qcount-1] = temp;\n        temp = _accompany_info2[0]; _accompany_info2[0] = _accompany_info2[qcount-1]; _accompany_info2[qcount-1] = temp;\n        _priorityqueue.RemoveAt(qcount-1);\n        _accompany_info.RemoveAt(qcount-1);\n        _accompany_info2.RemoveAt(qcount-1);\n        int num = 0;\n        while(true){\n            int swapnum = -1;\n            if((num+1)*2 < _priorityqueue.Count){\n                if(_priorityqueue[num*2+1] < _priorityqueue[(num+1)*2]){ //大小逆の時弄るとこ\n                    swapnum = num*2+1;\n                }else{\n                    swapnum = (num+1)*2;\n                }\n            }else if(num*2+1 < _priorityqueue.Count){\n                swapnum = num*2+1;\n            }\n            if(swapnum == -1) break;\n            if(_priorityqueue[swapnum] < _priorityqueue[num]){ //大小逆の時弄るとこ\n                tempd = _priorityqueue[swapnum];_priorityqueue[swapnum] = _priorityqueue[num];_priorityqueue[num] = tempd;\n                temp = _accompany_info[swapnum];_accompany_info[swapnum] = _accompany_info[num];_accompany_info[num] = temp;\n                temp = _accompany_info2[swapnum];_accompany_info2[swapnum] = _accompany_info2[num];_accompany_info2[num] = temp;\n                num = swapnum;\n            }else{\n                break;\n            }\n        }\n        return re;\n    }\n    \n    public string[] Peek(){\n        var temp = new string[]{_priorityqueue[0].ToString(),_accompany_info[0].ToString(),_accompany_info2[0].ToString()};\n        return temp;\n    }\n    \n    public int Count(){\n        return _priorityqueue.Count;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var answers = new List<double>();\n            while(true)\n            {\n                var n = int.Parse(ReadLine());\n                if (n == 0)\n                {\n                    break;\n                }\n\n                var cells = new double[n][];\n                var corridors = new List<double[]>();\n                var parents = new int[n];\n                for (var i = 0; i < n; i++)\n                {\n                    cells[i] = ReadLine().Split(' ').Select(value => double.Parse(value)).ToArray();\n                    parents[i] = i;\n                }\n\n                MakeCorridors(n, cells, corridors);\n                corridors = corridors.OrderBy(array => array[2]).ToList();\n\n                var totalLength = 0.0;\n                foreach(var corridor in corridors)\n                {\n                    if(GetRoot(parents, (int)corridor[0]) != GetRoot(parents, (int)corridor[1]))\n                    {\n                        totalLength += corridor[2];\n                        Union(parents, (int)corridor[0], (int)corridor[1]);\n                    }\n                }\n\n                answers.Add(totalLength);\n            }\n\n            answers.ForEach(value => WriteLine(\"{0:f3}\", value));\n        }\n\n        private static void MakeCorridors(int n, double[][] cells, List<double[]> corridors)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = i + 1; j < n; j++)\n                {\n                    var xDiff = cells[i][0] - cells[j][0];\n                    var yDiff = cells[i][1] - cells[j][1];\n                    var zDiff = cells[i][2] - cells[j][2];\n                    var length = Sqrt(xDiff * xDiff + yDiff * yDiff + zDiff * zDiff);\n                    length -= cells[i][3] + cells[j][3];\n                    if (length > 0.0)\n                    {\n                        corridors.Add(new double[3] { i, j, length });\n                    }\n                    else\n                    {\n                        corridors.Add(new double[3] { i, j, 0.0 });\n                    }\n                }\n            }\n        }\n\n        private static int GetRoot(int[] parents, int node)\n        {\n            if(parents[node] == node)\n            {\n                return node;\n            }\n            return parents[node] = GetRoot(parents, parents[node]);\n        }\n\n        private static void Union(int[] parents, int x, int y)\n        {\n            x = GetRoot(parents, x);\n            y = GetRoot(parents, y);\n\n            if(x != y)\n            {\n                parents[x] = y;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n\nclass Program\n{\n    #region Reader\n\n    static string ReadStr => Console.ReadLine();\n    static string[] ReadStrs => Console.ReadLine().Split(' ');\n    static int ReadInt => Convert.ToInt32(Console.ReadLine());\n    static int[] ReadInts => Console.ReadLine().Split(' ').Select(s => Convert.ToInt32(s)).ToArray();\n    static long ReadLong => Convert.ToInt64(Console.ReadLine());\n    static long[] ReadLongs => Console.ReadLine().Split(' ').Select(s => Convert.ToInt64(s)).ToArray();\n    static long[,] ReLongMatrix(int r, int c)\n    {\n        var mat = new long[r, c];\n        for (int i = 0; i < r; ++i)\n        {\n            var x = ReadLongs;\n            for (int j = 0; j < c; ++j)\n            {\n                mat[i, j] = x[j];\n            }\n        }\n        return mat;\n    }\n    static Tuple<string, string>[] ReTupleStr(int n)\n    {\n        List<Tuple<string, string>> list = new List<Tuple<string, string>>();\n        for (int i = 0; i < n; ++i)\n        {\n            var ab = ReadStrs;\n            list.Add(new Tuple<string, string>(ab[0], ab[1]));\n        }\n        return list.ToArray();\n    }\n    static Tuple<long, long>[] ReTupleLong(int n)\n    {\n        List<Tuple<long, long>> list = new List<Tuple<long, long>>();\n        for (int i = 0; i < n; ++i)\n        {\n            var ab = ReadLongs;\n            list.Add(new Tuple<long, long>(ab[0], ab[1]));\n        }\n        return list.ToArray();\n    }\n    static Tuple<int, int>[] ReadTupleInt(int n)\n    {\n        List<Tuple<int, int>> list = new List<Tuple<int, int>>();\n        for (int i = 0; i < n; ++i)\n        {\n            var ab = ReadInts;\n            list.Add(new Tuple<int, int>(ab[0], ab[1]));\n        }\n        return list.ToArray();\n    }\n    static Tuple<double, double>[] ReTupleDouble(int n)\n    {\n        List<Tuple<double, double>> list = new List<Tuple<double, double>>();\n        for (int i = 0; i < n; ++i)\n        {\n            var ab = ReadLongs;\n            list.Add(new Tuple<double, double>(ab[0], ab[1]));\n        }\n        return list.ToArray();\n    }\n    static Dictionary<int, HashSet<int>> ReAdjacencyList(int N, int M)\n    {\n        Dictionary<int, HashSet<int>> dict = new Dictionary<int, HashSet<int>>();\n        for (int i = 0; i <= N; ++i)\n        {\n            dict.Add(i, new HashSet<int>());\n        }\n        for (int i = 0; i < M; ++i)\n        {\n            var ab = ReadInts;\n            dict[ab[0]].Add(ab[1]);\n            dict[ab[1]].Add(ab[0]);\n        }\n        return dict;\n    }\n    #endregion\n    static void Swap<T>(ref T a, ref T b)\n    {\n        T temp = a;\n        a = b;\n        b = temp;\n    }\n    static int mod = (int)Pow(10, 9) + 7;\n\n\n    public class UnionFind\n    {\n        public UnionFind(int number)\n        {\n            Data = new List<int>();\n            for (int i = 0; i < number; i++) Data.Add(-1);\n        }\n\n        /// <summary>\n        /// 負なら親(絶対値はサイズ)　正なら子(絶対値は親のID)\n        /// </summary>\n        public List<int> Data { get; }\n\n        public int Find(int node)\n        {\n            //自身が親なら、そのまま返す\n            if (Data[node] < 0) return node;\n\n            //子なら、その親を呼び、さらにその親を探す。再帰的に呼び出しrootを見つけ、全ての子の親をrootにする\n            return Data[node] = Find(Data[node]);\n        }\n\n        public bool Unite(int node1, int node2)\n        {\n            //二つの点の親をさがす\n            node1 = Find(node1);\n            node2 = Find(node2);\n\n            //二つの親が一致しているなら、することはない\n            if (node1 == node2) return false;\n\n            int parent = 0;\n            int newSon = 0;\n\n            //サイズが小さいほうが、大きい方の子になる(親のDataの値は負であることに注意)\n            if (Data[node1] > Data[node2])\n            {\n                parent = node2;\n                newSon = node1;\n            }\n            else\n            {\n                parent = node1;\n                newSon = node2;\n            }\n\n            Data[parent] += Data[newSon];\n            Data[newSon] = parent;\n\n            return true;\n        }\n    }\n\n\n\n\n    static void Main()\n    {\n        List<string> ans = new List<string>();\n        while (true)\n        {\n            int N = ReadInt;\n            if (N == 0) break;\n            UnionFind tree = new UnionFind(N);\n\n            double[][] nodes = new double[N][];\n            List<Root> roots = new List<Root>();\n\n            for (int i = 0; i < N; i++)\n            {\n                nodes[i] = Console.ReadLine().Split(' ').Select(s => double.Parse(s)).ToArray();\n            }\n\n            for (int i = 0; i < N; i++)\n            {\n                for (int j = i + 1; j < N; j++)\n                {\n                    double powerD = Pow(nodes[i][0] - nodes[j][0], 2) + Pow(nodes[i][1] - nodes[j][1], 2) + Pow(nodes[i][2] - nodes[j][2], 2);\n                    roots.Add(new Root(i, j, Max(0, Sqrt(powerD) - (nodes[i][3] + nodes[j][3]))));\n                }\n            }\n\n            roots.Sort((x, y) => (int)((x.cost - y.cost) * 10000));\n\n\n            int count = 0;\n            double cost = 0;\n            for (int i = 0; i < roots.Count; i++)\n            {\n                if (tree.Find(roots[i].a) != tree.Find(roots[i].b))\n                {\n                    tree.Unite(roots[i].a, roots[i].b);\n                    count++;\n                    cost += roots[i].cost;\n                    if (count == N - 1) break;\n                }\n            }\n\n            ans.Add(cost.ToString(\"f3\"));\n        }\n        WriteLine(string.Join(\"\\n\", ans));\n    }\n\n    public class Root\n    {\n        public Root(int a,int b,double cost)\n        {\n            this.a = a;\n            this.b = b;\n            this.cost = cost;\n        }\n\n        public int a;\n        public int b;\n        public double cost;\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Library;\nusing static Library.Input;\n\nnamespace AtCoderTemplate {\n    class ProgramC {\n        private class Unit{\n            public double X {get;set;}\n            public double Y {get;set;}\n            public double Z {get;set;}\n            public double R {get;set;}\n        }\n        \n        private class Edge : IComparable<Edge> {\n            public int From {get;set;}\n            public int To {get;set;}\n            public double Weight {get;set;}\n            public int CompareTo(Edge edge) {\n                if (this.Weight < edge.Weight) return -1;\n                else if (this.Weight == edge.Weight) return 0;\n                else return 1;\n            }\n        }\n\n        static void Main () {\n            while (true)\n            {\n                int n = NextInt;\n                if (n == 0) return;\n\n                var pq = new PriorityQueue<Edge>();\n                var uf = new UnionFind(n);\n                var units = new List<Unit>();\n\n                for (int i = 0; i < n; i++)\n                {\n                    var input = StrArr.Select(double.Parse).ToArray();\n\n                    for (int j = 0; j < units.Count; j++)\n                    {\n                        double tmp = Math.Sqrt((units[j].X - input[0]) * (units[j].X - input[0]) + (units[j].Y - input[1]) * (units[j].Y - input[1]) + (units[j].Z - input[2]) * (units[j].Z - input[2]));\n                        pq.Enqueue(new Edge{From = j, To = i, Weight = tmp - units[j].R - input[3]});\n                    }\n\n                    units.Add(new Unit{X = input[0], Y = input[1], Z = input[2], R = input[3]});\n                }\n\n                double result = 0;\n                while (pq.Any())\n                {\n                    var tmp = pq.Dequeue();\n\n                    if (!uf.Same(tmp.From, tmp.To))\n                    {\n                        uf.Unite(tmp.From, tmp.To);\n                        result += Math.Max(0, tmp.Weight);\n                    }\n                }\n\n                System.Console.WriteLine(result.ToString(\"F3\"));\n            }\n        }\n    }\n\n}\n\nnamespace Library {\n    class Input {\n        static IEnumerator<string> enumerator = new string[] { }.AsEnumerable ().GetEnumerator ();\n\n        public static string Line => Console.ReadLine ();\n\n        public static string[] StrArr => Line.Split (' ');\n\n        public static int NextInt => int.Parse (NextWord ());\n\n        public static long NextLong => long.Parse (NextWord ());\n\n        public static List<int> IntList => StrArr.Select (int.Parse).ToList ();\n\n        public static List<long> LongList => StrArr.Select (long.Parse).ToList ();\n\n        public static IEnumerable<long[]> TakeLine (int N) {\n            return Enumerable.Repeat (0, N).Select (_ => Console.ReadLine ().Split (' ').Select (long.Parse).ToArray ());\n        }\n\n        public static string NextWord () {\n            while (!enumerator.MoveNext ()) {\n                enumerator = StrArr.AsEnumerable ().GetEnumerator ();\n            }\n            return enumerator.Current;\n        }\n    }\n}\n\nnamespace Library {\n    \n    class Modular {\n        public const int mod = 1000000007;\n        public readonly long value;\n        public Modular (long value) { this.value = value; }\n        public static implicit operator Modular (long a) {\n            var m = a % mod;\n            return new Modular ((m < 0) ? m + mod : m);\n        }\n        public static Modular operator + (Modular a, Modular b) {\n            return a.value + b.value;\n        }\n        public static Modular operator - (Modular a, Modular b) {\n            return a.value - b.value;\n        }\n        public static Modular operator * (Modular a, Modular b) {\n            return a.value * b.value;\n        }\n        public static Modular Pow (Modular a, int n) {\n            switch (n) {\n                case 0:\n                    return 1;\n                case 1:\n                    return a;\n                default:\n                    var p = Pow (a, n / 2);\n                    return p * p * Pow (a, n % 2);\n            }\n        }\n        public static Modular operator / (Modular a, Modular b) {\n            return a * Pow (b, mod - 2);\n        }\n        private static readonly List<int> facs = new List<int> { 1 };\n        private static Modular Fac (int n) {\n            for (int i = facs.Count; i <= n; ++i) {\n                facs.Add ((int) (Math.BigMul (facs.Last (), i) % mod));\n            }\n            return facs[n];\n        }\n        public static Modular Ncr (int n, int r) {\n            return (n < r) ? 0 :\n                (n == r) ? 1 :\n                Fac (n) / (Fac (r) * Fac (n - r));\n        }\n        public static explicit operator int (Modular a) {\n            return (int) a.value;\n        }\n    }\n\n}\nnamespace Library {\n    class MyMath {\n        public static long Gcd (long a, long b) {\n            return b == 0 ? a : Gcd (b, a % b);\n        }\n\n        public static long Sqrt (long n) {\n            if (n < 0) return 0;\n            long a = 0, tmp = 0, b = 0;\n            for (int i = 62; i >= 0; i -= 2) {\n                tmp = (b << 1) + 1 <= (n >> i) ? 1 : 0;\n                a = a << 1 | tmp;\n                n -= (((b << 1) + 1) * tmp) << i;\n                b = (b << 1) + tmp + tmp;\n            }\n            return a;\n        }\n\n        public static long Nck (int n, int k) {\n            if (k == 0) return 1;\n            if (n == 0) return 0;\n            return n * Nck (n - 1, k - 1) / k;\n        }\n    }\n}\n\nnamespace Library {\n        public class PriorityQueue<T> {\n\n        readonly List<T> _heap = new List<T> ();\n        readonly Comparison<T> _comparison;\n\n        public PriorityQueue (Comparison<T> comparison) {\n            _comparison = comparison;\n        }\n\n        public PriorityQueue () : this (Comparer<T>.Default.Compare) { }\n\n        public PriorityQueue (IComparer<T> comparer) : this (comparer.Compare) { }\n\n        public void Enqueue (T item) {\n            _heap.Add (item);\n\n            int childID = _heap.Count - 1;\n            int parentID = (childID - 1) / 2;\n\n            while (childID > 0 && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                childID = parentID;\n                parentID = (parentID - 1) / 2;\n            }\n        }\n\n        public T Dequeue () {\n            var first = _heap.First ();\n            _heap[0] = _heap.Last ();\n            _heap.RemoveAt (_heap.Count - 1);\n\n            int parentID = 0;\n            int childID = parentID * 2 + 2;\n            if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n\n            while (childID < _heap.Count && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                parentID = childID;\n                childID = parentID * 2 + 2;\n                if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n            }\n\n            return first;\n        }\n\n        void Swap (int parent, int child) {\n            var tmp = _heap[parent];\n            _heap[parent] = _heap[child];\n            _heap[child] = tmp;\n        }\n\n        public T Peek () { return _heap[0]; }\n        public int Count => _heap.Count;\n        public bool Any () { return _heap.Any (); }\n        public List<T> Data => _heap;\n    }\n}\n\nnamespace Library {\n    \n    public class UnionFind {\n        public int[] Parents { get; set; }\n        public UnionFind (int size) {\n            Parents = Enumerable.Repeat (-1, size).ToArray ();\n        }\n\n        public int Find (int num) {\n            if (Parents[num] < 0) return num;\n\n            Parents[num] = Find (Parents[num]);\n            return Parents[num];\n        }\n\n        public int Size (int num) {\n            return -Parents[Find (num)];\n        }\n\n        public bool Same (int a, int b) {\n            return Find (a) == Find (b);\n        }\n\n        public void Unite (int a, int b) {\n            int x = Find (a), y = Find (b);\n\n            if (Size (x) > Size (y)) {\n                Parents[x] += Parents[y];\n                Parents[y] = x;\n            } else {\n                Parents[y] += Parents[x];\n                Parents[x] = y;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var n;\nvar c = [];\nvar u = [];\nvar f = [];\n\nfunction dist(i, j){\n\tvar s = 0;\n\trep(3, function(k){\n\t\tvar d = c[i][k] - c[j][k];\n\t\ts += d * d;\t\n\t});\n\ts = Math.sqrt(s);\n\treturn Math.max(s - c[i][3] - c[j][3], 0);\n}\n\nfunction main(){\n\twhile(n = scan()){\n\t\trep(n, function(i){\n\t\t\tc[i] = [scan(), scan(), scan(), scan()];\n\t\t});\n\n\t\trep(n, function(i){\n\t\t\tf[i] = Infinity;\n\t\t});\n\n\t\tvar ans = 0;\n\t\tf[0] = 0;\n\t\trep(n, function(){\n\t\t\tvar v = -1;\n\t\t\trep(n, function(i){\n\t\t\t\tif(!u[i] && (v === -1 || f[i] < f[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t});\n\t\t\tans += f[v];\n\t\t\tu[v] = true;\n\t\t\trep(n, function(i){\n\t\t\t\tf[i] = Math.min(dist(v, i), f[i]);\n\t\t\t});\n\t\t});\n\t\tprint(ans);\n\n\t\tu = [];\n\t}\n}\n\nfunction rep(a, b, c, u){\n\tif(c === u){\n\t\tc = b;\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tfor(var i = a; i < b; ++i){\n\t\tif(c(i) === false){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvar input = '';\n\nfunction scan(){\n\treturn +input.pop();\n}\nfunction scan_string(){\n\treturn input.pop();\n} \nfunction print(val){\n\tconsole.log(val);\n}\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk){\n\tinput += chunk;\n});\nprocess.stdin.on('end', function(){\n\tinput = input.trim().split(/\\s+/).reverse();\n\tmain();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function Main(input) {\n    let l = 0;\n    input = input.trim().split(\"\\n\").map(function(x) { return x.split(\" \")});\n    let n = parseInt(input[l][0],10);\n    while(n !== 0){\n        \n        let arr_xyzr = [];\n        for (let i = 0; i < n; i++){\n            arr_xyzr.push(input[l + 1 + i].map(e => parseFloat(e, 10)));\n        }\n\n        // console.log(arr_xyzr);\n\n        // let lVl = parseInt(input[0][0], 10);\n        // let lEl = parseInt(input[0][1], 10);\n\n        let graph = [];\n        for (let i = 0; i < n - 1; i++){\n            let tmp =[];\n            tmp[0] = i;\n            for (let j = i + 1; j < n; j++){\n                tmp[1] = j;\n                tmp[2] = Math.max(0, Math.sqrt(Math.pow((arr_xyzr[j][0] - arr_xyzr[i][0]), 2) + Math.pow((arr_xyzr[j][1] - arr_xyzr[i][1]), 2) + Math.pow((arr_xyzr[j][2] - arr_xyzr[i][2]), 2)) - arr_xyzr[i][3] - arr_xyzr[j][3]);\n                graph.push(tmp.slice());\n            }\n        }\n        graph.sort((a, b) => a[2] - b [2]);\n        // console.log(graph);\n        let uf = new UnionFind(n);\n        let ans = 0;\n        for (let i = 0; i < graph.length; i++){\n            if (uf.find(graph[i][0]) !== uf.find(graph[i][1])) {\n                uf.union(graph[i][0], graph[i][1])\n                ans += graph[i][2];\n            }\n        }\n        console.log(ans.toFixed(3));\n\n        l += n + 1;\n        n = parseInt(input[l][0],10);\n    }\n\n}\n\nfunction UnionFind (n) {\n    this.parents = [];\n    for (let i = 0; i < n; i++) {\n        this.parents.push(-1);\n    }\n}\n\nUnionFind.prototype.find = function (x) {\n    if (this.parents[x] < 0) return x;\n    return this.parents[x] = this.find(this.parents[x]);    \n}\n\nUnionFind.prototype.union = function (x, y) {\n    x = this.find(x);\n    y = this.find(y);\n    if (x === y) return;\n    if (this.parents[x] > this.parents[y]) [x, y] = [y, x];\n    \n    this.parents[x] += this.parents[y];\n    this.parents[y] = x;\n}\n\nUnionFind.prototype.size = function (x) {\n    x = this.find(x);\n    while (x >= 0) {\n        x = this.parents[x];\n    }\n    return x * -1;\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var n;\nvar c = [];\nvar u = [];\nvar f = [];\n\nfunction dist(i, j){\n\tvar s = 0;\n\trep(3, function(k){\n\t\tvar d = c[i][k] - c[j][k];\n\t\ts += d * d;\t\n\t});\n\ts = Math.sqrt(s);\n\treturn Math.max(s - c[i][3] - c[j][3], 0);\n}\n\nfunction main(){\n\twhile(n = scan()){\n\t\trep(n, function(i){\n\t\t\tc[i] = [scan(), scan(), scan(), scan()];\n\t\t});\n\n\t\trep(n, function(i){\n\t\t\tf[i] = Infinity;\n\t\t});\n\n\t\tvar ans = 0;\n\t\tf[0] = 0;\n\t\trep(n, function(){\n\t\t\tvar v = -1;\n\t\t\trep(n, function(i){\n\t\t\t\tif(!u[i] && (v === -1 || f[i] < f[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t});\n\t\t\tans += f[v];\n\t\t\tu[v] = true;\n\t\t\trep(n, function(i){\n\t\t\t\tf[i] = Math.min(dist(v, i), f[i]);\n\t\t\t});\n\t\t});\n\n\t\tans = Math.round(ans * 1000);\n\t\tvar ans1 = Math.floor(ans / 1000);\n\t\tvar ans2 = ans % 1000;\n\t\tprint(ans1 + '.' + ('00' + ans2).slice(-3));\n\n\t\tu = [];\n\t}\n}\n\nfunction rep(a, b, c, u){\n\tif(c === u){\n\t\tc = b;\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tfor(var i = a; i < b; ++i){\n\t\tif(c(i) === false){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvar input = '';\n\nfunction scan(){\n\treturn +input.pop();\n}\nfunction scan_string(){\n\treturn input.pop();\n} \nfunction print(val){\n\tconsole.log(val);\n}\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk){\n\tinput += chunk;\n});\nprocess.stdin.on('end', function(){\n\tinput = input.trim().split(/\\s+/).reverse();\n\tmain();\n});"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\nrequire 'tsort'\ninclude Math\ndef max(a,b);              a > b ? a : b                              end\ndef min(a,b);              a < b ?  a : b                             end\ndef swap(a,b);             a, b = b, a                                end\ndef gif;                   gets.to_i                                  end\ndef gff;                   gets.to_f                                  end\ndef gsf;                   gets.chomp                                 end\ndef gi;                    gets.split.map(&:to_i)                     end\ndef gf;                    gets.split.map(&:to_f)                     end\ndef gs;                    gets.chomp.split.map(&:to_s)               end\ndef gc;                    gets.chomp.split('')                       end\ndef pr(num);               num.prime_division                         end\ndef digit(num);            num.to_s.length                            end\ndef array(s,ini=nil);      Array.new(s){ini}                          end\ndef darray(s1,s2,ini=nil); Array.new(s1){Array.new(s2){ini}}          end\ndef rep(num);              num.times{|i|yield(i)}                     end\ndef repl(st,en,n=1);       st.step(en,n){|i|yield(i)}                 end\nclass UnionFindTree\n\n  class ParArray < Hash\n    def [] key\n      self[key] = key if super(key).nil?\n      super(key)\n    end\n  end\n\n  class SizeArray < Hash\n    def [] key\n      self[key] = 1 if super(key).nil?\n      super(key)\n    end\n  end\n\n  def initialize()\n    @par = ParArray.new\n    @size = SizeArray.new\n  end\n\n  private\n\n  def find(x)\n    return x if x == @par[x]\n    return @par[x] = find(@par[x])\n  end\n\n  public\n\n  def unite(x, y)\n    x = find(x)\n    y = find(y)\n\n    return nil if x == y\n    x, y = y, x if @size[x] < @size[y]\n\n    @par[y] = x\n    @size[x] += @size[y]\n  end\n\n  def same?(x, y)\n    return find(x) == find(y)\n  end\n\n  def size(x)\n    return @size[find(x)]\n  end\n\nend\n\ndef cost l1,l2\n  len = sqrt((l1[0]-l2[0])**2+(l1[1]-l2[1])**2+(l1[2]-l2[2])**2)-l1[3]-l2[3]\n  if len <= 0\n    return 0\n  else\n    return len\n  end\nend\n\nans = []\nloop{\n  n = gif\n  break if n == 0\n  l = []\n  c = []\n  un = UnionFindTree.new\n  rep n do |i|\n   ll = gf\n   rep l.size do |j|\n    c << [cost(l[j],ll),[i,j]]\n  end\n  l << ll\nend\nc.sort!\nsum = 0\np c\nc.each do |cc|\n  unless un.same? cc[1][0],cc[1][1]\n    sum += cc[0]\n    un.unite cc[1][0],cc[1][1]\n  end\nend\nans <<  format(\"%.3f\", sum)\n}\n\nputs ans"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start, setting = {})\n\t\traise \"invalid setting\" if setting.class != Hash\n\t\traise \"invalid setting\" if setting.keys - [:goal, :multi_source, :multi_sink, :max_dist] != []\n\t\t\n\t\tstart = Set[start] if !setting[:multi_source]\n\t\tgoal = setting[:goal]\n\t\tgoal = Set[goal] if goal && !setting[:multi_sink]\n\t\tmax_dist = setting[:max_dist]\n\n\t\th = Heap.new\n\t\treached = Set.new\n\t\tstart.each{|v|\n\t\t\th.add(v, 0)\n\t\t\treached << v\n\t\t}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if setting[:goal] && goal.include?(u)\n\t\t\tbreak if max_dist && key > max_dist\n\t\t\tdist[u] = key\n\t\t\teach_to_node_of(u){|v|\n\t\t\t\td = dist[u] + edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tgoal ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\td = f_dist[u] + edge_length(u, v)\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_from_node_of(u){|v|\n\t\t\t\t\td = b_dist[u] + edge_length(v, u)\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\trequire 'set'\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef del_node(u)\n\t\tu.neighbour.each_value{|e| del_edge(e)}\n\tend\n\n\tdef add_edge(u, v, label = nil)\n\t\te = Edge.new(u, v, label)\n\t\tu.neighbour[v] = e\n\t\tv.neighbour[u] = e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.neighbour.delete(v)\n\t\tv.neighbour.delete(u)\n\t\te\n\tend\n\n\tdef contract(e)\n\t\tu, v = e.from, e.to\n\t\tnew_node = add_node\n\n\t\tu.neighbour.each{|w, f1|\n\t\t\tf2 = v.neighbour[w]\n\t\t\tif f2\n\t\t\t\tf = yield(f1, f2)\n\t\t\t\tadd_edge(new_node, w, f.length)\n\t\t\t\tdel_edge(f2)\n\t\t\telse\n\t\t\t\tadd_edge(new_node, w, f1.length)\n\t\t\tend\n\t\t}\n\t\tv.neighbour.each{|w, f|\n\t\t\tadd_edge(new_node, w, f.length)\n\t\t}\n\t\tdel_node(u)\n\t\tdel_node(v)\n\n\t\tnew_node\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@neighbour = {}\n\t\tend\n\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\t\n\t\tattr_accessor :neighbour\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :label\n\tend\n\n\n\tdef each_to_node_of(u)\n\t\tu.neighbour.each_key{|v|\n\t\t\tyield v\n\t\t}\n\tend\n\talias :each_from_node_of :each_to_node_of\n\n\tdef edge_length(u, v)\n\t\tu.neighbour[v] ? 1 : nil\n\tend\n\nend\n\nclass WeightedGraph < Graph\n\tdef add_edge(u, v, length, label = nil)\n\t\te = Edge.new(u, v, length, label)\n\t\tu.neighbour[v] = e\n\t\tv.neighbour[u] = e\n\t\te\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, length, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@length = length\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :length, :label\n\tend\n\n\tdef edge_length(u, v)\n\t\tu.neighbour[v].length\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\treached = Set.new\n\t\th.add(start, 0)\n\t\treached << start\n\t\tscanned = Set[start]\n\t\tused_edge = {}\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\tif e = used_edge[u]\n\t\t\t\ttree_len += e.length\n\t\t\tend\n\t\t\tscanned << u\n\n\t\t\teach_to_node_of(u){|v|\n\t\t\t\tnext if scanned.include?(v)\n\t\t\t\td = edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\t\tif d < used_edge[v].length\n\t\t\t\t\t\tused_edge[v] = u.neighbour[v]\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\tused_edge[v] = u.neighbour[v]\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nloop {\n\tg = WeightedGraph.new\n\tn = gets.to_i\n\tbreak if n == 0\n\tnodes = []\n\tedges = []\n\tdist = {}\n\t(1..n).each{\n\t\ta = gets.split.map &:to_f\n\t\tx1, y1, z1, r1 = a\n\t\tu = g.add_node(a)\n\t\tnodes.each{|v|\n\t\t\tx2, y2, z2, r2 = v.label\n\t\t\td = Math.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2) - r1 - r2\n\t\t\tif d <= 0\n\t\t\t\tedges << g.add_edge(u, v, d) if d <= 0\n\t\t\telse\n\t\t\t\tdist[Set[u, v]] = d\n\t\t\tend\n\t\t}\n\t\tnodes << u\n\t}\n\n\tcomponents = []\n\n\tuntil nodes.empty?\n\t\tcomponents << g.reachable_from(nodes.pop)\n\t\tnodes -= components[-1].to_a\n\tend\n\n\tnodes = (1..components.size).map{ g.add_node }\n\n\t(0..nodes.size-2).each{|i|\n\t\t(i+1..nodes.size-1).each{|j|\n\t\t\tc1 = components[i]\n\t\t\tc2 = components[j]\n\t\t\tmin = Float::INFINITY\n\t\t\tc1.each{|u|\n\t\t\t\tc2.each{|v|\n\t\t\t\t\td = dist[Set[u, v]] \n\t\t\t\t\tmin = d if d < min\n\t\t\t\t}\n\t\t\t}\n\t\t\tg.add_edge(nodes[i], nodes[j], min)\n\t\t}\n\t}\n\n\tprintf(\"%.3f\\n\", g.prim(nodes[0]))\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start, setting = {})\n\t\traise \"invalid setting\" if setting.class != Hash\n\t\traise \"invalid setting\" if setting.keys - [:goal, :multi_source, :multi_sink, :max_dist] != []\n\t\t\n\t\tstart = Set[start] if !setting[:multi_source]\n\t\tgoal = setting[:goal]\n\t\tgoal = Set[goal] if goal && !setting[:multi_sink]\n\t\tmax_dist = setting[:max_dist]\n\n\t\th = Heap.new\n\t\treached = Set.new\n\t\tstart.each{|v|\n\t\t\th.add(v, 0)\n\t\t\treached << v\n\t\t}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if setting[:goal] && goal.include?(u)\n\t\t\tbreak if max_dist && key > max_dist\n\t\t\tdist[u] = key\n\t\t\teach_to_node_of(u){|v|\n\t\t\t\td = dist[u] + edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tgoal ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\td = f_dist[u] + edge_length(u, v)\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_from_node_of(u){|v|\n\t\t\t\t\td = b_dist[u] + edge_length(v, u)\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\trequire 'set'\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef del_node(u)\n\t\tu.neighbour.each_value{|e| del_edge(e)}\n\tend\n\n\tdef add_edge(u, v, label = nil)\n\t\te = Edge.new(u, v, label)\n\t\tu.neighbour[v] = e\n\t\tv.neighbour[u] = e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.neighbour.delete(v)\n\t\tv.neighbour.delete(u)\n\t\te\n\tend\n\n\tdef contract(e)\n\t\tu, v = e.from, e.to\n\t\tnew_node = add_node\n\n\t\tu.neighbour.each{|w, f1|\n\t\t\tf2 = v.neighbour[w]\n\t\t\tif f2\n\t\t\t\tf = yield(f1, f2)\n\t\t\t\tadd_edge(new_node, w, f.length)\n\t\t\t\tdel_edge(f2)\n\t\t\telse\n\t\t\t\tadd_edge(new_node, w, f1.length)\n\t\t\tend\n\t\t}\n\t\tv.neighbour.each{|w, f|\n\t\t\tadd_edge(new_node, w, f.length)\n\t\t}\n\t\tdel_node(u)\n\t\tdel_node(v)\n\n\t\tnew_node\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@neighbour = {}\n\t\tend\n\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\t\n\t\tattr_accessor :neighbour\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :label\n\tend\n\n\n\tdef each_to_node_of(u)\n\t\tu.neighbour.each_key{|v|\n\t\t\tyield v\n\t\t}\n\tend\n\talias :each_from_node_of :each_to_node_of\n\n\tdef edge_length(u, v)\n\t\tu.neighbour[v] ? 1 : nil\n\tend\n\nend\n\nclass WeightedGraph < Graph\n\tdef add_edge(u, v, length, label = nil)\n\t\te = Edge.new(u, v, length, label)\n\t\tu.neighbour[v] = e\n\t\tv.neighbour[u] = e\n\t\te\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, length, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@length = length\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :length, :label\n\tend\n\n\tdef edge_length(u, v)\n\t\tu.neighbour[v].length\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\treached = Set.new\n\t\th.add(start, 0)\n\t\treached << start\n\t\tscanned = Set[start]\n\t\tused_edge = {}\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\tif e = used_edge[u]\n\t\t\t\ttree_len += e.length\n\t\t\tend\n\t\t\tscanned << u\n\n\t\t\teach_to_node_of(u){|v|\n\t\t\t\tnext if scanned.include?(v)\n\t\t\t\td = edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\t\tif d < used_edge[v].length\n\t\t\t\t\t\tused_edge[v] = u.neighbour[v]\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\tused_edge[v] = u.neighbour[v]\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nloop {\n\tg = WeightedGraph.new\n\tn = gets.to_i\n\tbreak if n == 0\n\tnodes = []\n\tedges = []\n\t(1..n).each{\n\t\ta = gets.split.map &:to_f\n\t\tx1, y1, z1, r1 = a\n\t\tu = g.add_node(a)\n\t\tnodes.each{|v|\n\t\t\tx2, y2, z2, r2 = v.label\n\t\t\td = Math.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2) - r1 - r2\n\t\t\tedges << g.add_edge(u, v, d)\n\t\t}\n\t\tnodes << u\n\t}\n\t\n\t\n\t(0..edges.size-1).each{|i|\n\t\te = edges[i]\n\t\tif e.length <= 0\n\t\t\tnodes -= [e.from, e.to]\n\t\t\tnodes << g.contract(e){|e1, e2|\n\t\t\t\te1.length < e2.length ? e1 : e2\n\t\t\t}\n\t\tend\n\t}\n\n\tprintf(\"%.3f\\n\", g.prim(nodes[0]))\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\nrequire 'tsort'\ninclude Math\ndef max(a,b);              a > b ? a : b                              end\ndef min(a,b);              a < b ?  a : b                             end\ndef swap(a,b);             a, b = b, a                                end\ndef gif;                   gets.to_i                                  end\ndef gff;                   gets.to_f                                  end\ndef gsf;                   gets.chomp                                 end\ndef gi;                    gets.split.map(&:to_i)                     end\ndef gf;                    gets.split.map(&:to_f)                     end\ndef gs;                    gets.chomp.split.map(&:to_s)               end\ndef gc;                    gets.chomp.split('')                       end\ndef pr(num);               num.prime_division                         end\ndef digit(num);            num.to_s.length                            end\ndef array(s,ini=nil);      Array.new(s){ini}                          end\ndef darray(s1,s2,ini=nil); Array.new(s1){Array.new(s2){ini}}          end\ndef rep(num);              num.times{|i|yield(i)}                     end\ndef repl(st,en,n=1);       st.step(en,n){|i|yield(i)}                 end\nclass UnionFindTree\n\n  class ParArray < Hash\n    def [] key\n      self[key] = key if super(key).nil?\n      super(key)\n    end\n  end\n\n  class SizeArray < Hash\n    def [] key\n      self[key] = 1 if super(key).nil?\n      super(key)\n    end\n  end\n\n  def initialize()\n    @par = ParArray.new\n    @size = SizeArray.new\n  end\n\n  private\n\n  def find(x)\n    return x if x == @par[x]\n    return @par[x] = find(@par[x])\n  end\n\n  public\n\n  def unite(x, y)\n    x = find(x)\n    y = find(y)\n\n    return nil if x == y\n    x, y = y, x if @size[x] < @size[y]\n\n    @par[y] = x\n    @size[x] += @size[y]\n  end\n\n  def same?(x, y)\n    return find(x) == find(y)\n  end\n\n  def size(x)\n    return @size[find(x)]\n  end\n\nend\n\ndef cost l1,l2\n  len = sqrt((l1[0]-l2[0])**2+(l1[1]-l2[1])**2+(l1[2]-l2[2])**2)-l1[3]-l2[3]\n  if len <= 0\n    return 0\n  else\n    return len\n  end\nend\n\nans = []\nloop{\n  n = gif\n  break if n == 0\n  l = []\n  c = []\n  un = UnionFindTree.new\n  rep n do |i|\n   ll = gf\n   rep l.size do |j|\n    c << [cost(l[j],ll),[i,j]]\n  end\n  l << ll\nend\nc.sort!\nsum = 0\nc.each do |cc|\n  unless un.same? cc[1][0],cc[1][1]\n    sum += cc[0]\n    un.unite cc[1][0],cc[1][1]\n  end\nend\nans <<  format(\"%.3f\", sum)\n}\n\nputs ans"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef dist(sp0, sp1)\n  dx = sp1[0] - sp0[0]\n  dy = sp1[1] - sp0[1]\n  dz = sp1[2] - sp0[2]\n  rr = sp1[3] + sp0[3]\n  d = Math.sqrt(dx * dx + dy * dy + dz * dz) - rr\n  (d < 0.0) ? 0.0 : d\nend\n\ndef root(i)\n  ri = i\n  while ri != $uft[ri]\n    ri = $uft[ri]\n  end\n  while ri != $uft[i]\n    i0 = $uft[i]\n    $uft[i] = ri\n    i = i0\n  end\n  ri\nend\n\ndef union(i, j)\n  i = root(i)\n  j = root(j)\n  $uft[j] = i\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  sps = n.times.map{gets.split.map(&:to_f)}\n\n  dists = []\n  $uft = (0...n).to_a\n\n  for i in (0...n)\n    spi = sps[i]\n    for j in ((i + 1)...n)\n      spj = sps[j]\n      d = dist(spi, spj)\n      if d == 0.0\n        union(i, j)\n      else\n        dists << [d, i, j]\n      end\n    end\n  end\n\n  dists.sort!\n  #p $uft\n  #p dists\n\n  sumd = 0.0\n\n  for dist in dists\n    d, i, j = dist\n    if root(i) != root(j)\n      sumd += d\n      union(i, j)\n    end\n  end\n\n  puts \"%.3f\" % sumd\nend"
  },
  {
    "language": "OCaml",
    "code": "module ArrayL = ArrayLabels\nmodule ListL = ListLabels\n\nlet dbg = Printf.printf \"[debug]%s\"\n\nlet max_num = 100_000_000_000\n\nlet id = fun x -> x\nlet tuple2 x y = (x,y)\nlet tuple3 x y z = (x,y,z)\nlet tuple4 x y z w = (x,y,z,w)\nlet succ x = x + 1\nlet pred x = x - 1\n\nlet (++) n m =\n  let rec aux i =\n    if i = m then [m]\n    else i :: aux (i+1) in\n  if n > m then [] else aux n\n\nlet (++^) n m = n ++ (m-1)\n\nlet scan fmt f = Scanf.sscanf (read_line ()) fmt f\n\nlet scan_lines n fmt f =\n  List.map (fun _ -> scan fmt f) (0++^n)\n\nlet scan_matrix n m e conv =\n  let arr = Array.make_matrix n m e in\n  Array.iteri (fun i line ->\n      let s = Scanf.Scanning.from_string @@ read_line () in\n      Array.iteri (fun j _ ->\n          arr.(i).(j) <- Scanf.bscanf s \" %s\" conv;\n        ) line) arr; arr\n\nlet between n x m = n <= x && x < m\n\nlet string_to_list s =\n  List.map (String.get s) (0 ++^ String.length s)\n\n\nmodule UnionFind = struct\n  let empty n = Array.init n id\n\n  let root t n =\n    let rec aux c =\n      if c = t.(c) then c\n      else let p = aux t.(c) in t.(c) <- p; p in\n    aux n\n\n  let unite t v0 v1 =\n    let w0 = root t v0 in\n    let w1 = root t v1 in\n    t.(w1) <- w0\n\n  let same t v0 v1 =\n    root t v0 = root t v1\nend\n\n\nlet () =\n  let rec aux () =\n    let n = scan \"%d\" id in\n    if n = 0 then  ()\n    else\n      let ls = Array.of_list @@ scan_lines n \"%f %f %f %f\" tuple4 in\n      let uf = UnionFind.empty n in\n      ListL.map (0 ++^ n) ~f:(fun i ->\n          ListL.map (0 ++^ n) ~f:(fun j ->\n              let (x0, y0, z0, d0) = ls.(i)  in\n              let (x1,y1,z1,d1) = ls.(j) in\n              let d =\n                sqrt ((x0-.x1) *.(x0 -.x1)+. (y0-.y1) *.(y0 -. y1) +. (z0 -. z1)*.(z0 -. z1)) in\n              let diff = max 0.0000001 (d -. (d0+.d1)) in\n              (diff, i, j)))\n      |> List.concat\n      |> List.sort (fun (d0,_,_) (d1,_,_) -> compare d0 d1)\n      |> ListL.fold_left ~init:0.0 ~f:(fun acc (d, i, j)->\n          acc +. if UnionFind.same uf i j then 0.0\n          else\n            (UnionFind.unite uf i j;d))\n      |> Printf.printf \"%.03f\\n\"\n      |> aux\n  in\n  aux ()\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\nimport std.typecons;\nimport std.math;\n\n\nclass UnionFind\n{\n\tint[] data;\n\n\tthis() {\n\t}\n\n\tthis(int x) {\n\t\tdata = new int[](x);\n\t\tdata[] = -1;\n\t}\n\n\tbool unionSet(int x, int y)\n\t{\n\t\tx = root(x); y=root(y);\n\t\tif(x != y)\n\t\t{\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\t\n\tint root(int x)\n\t{\n\t\tif( data[x] < 0 ) return x;\n\t\treturn data[x]=root(data[x]);\n\t}\n};\n\t\n\nalias Tuple!(double, \"x\", double, \"y\", double, \"z\") P3;\nalias Tuple!(P3, \"p\", double, \"r\") Sphere;\nalias Tuple!(int, \"src\", int, \"dst\", double, \"cost\") Edge;\n\nstring[] inputs;\n\ndouble dist(Sphere a, Sphere b)\n{\n\treturn sqrt((a.p.x-b.p.x)^^2 + (a.p.y-b.p.y)^^2 + (a.p.z-b.p.z)^^2) - (a.r+b.r);\n}\n\nbool intersectSS(Sphere a, Sphere b)\n{\n\treturn dist(a,b) < 0;\n}\n\n\n\ndouble solve(int N, Sphere[] stations) {\n\t\n\tint connected = 0;\n\tdouble res = 0;\n\n\tUnionFind uf = new UnionFind(N);\n\tEdge[] edges;\n\n\tforeach(i; 0..N)\n\tforeach(j; i+1..N) {\n\t\tif(intersectSS(stations[i], stations[j])) {\n\t\t\tuf.unionSet(i,j);\n\t\t\tconnected++;\n\t\t}\n\t\telse edges ~= Edge(i,j,dist(stations[i],stations[j]));\n\t}\n\n\tsort!(\"a.cost < b.cost\")(edges);\n\n\tforeach(e; edges) {\n\t\tif(connected >= N-1) break;\n\t\tif(uf.unionSet(e.src, e.dst)) {\n\t\t\tconnected++;\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\treturn res;\n}\n\t\n\nvoid main()\n{\n\t\n\twhile(true)\n\t{\n\t\tinputs = split(chomp(readln));\n\t\tint N = to!int(inputs[0]);\n\t\tif(N==0) break;\n\n\t\tSphere[] stations = new Sphere[](N);\n\t\tforeach(i; 0..N) {\n\t\t\tinputs = split(chomp(readln));\n\t\t\tstations[i] = Sphere(P3(to!double(inputs[0]), to!double(inputs[1]), to!double(inputs[2])), to!double(inputs[3]));\n\t\t}\n\n\t\twritefln(\"%.3f\", solve(N, stations));\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.container;\nimport std.array;\nimport std.math;\n\nstruct Sphere\n{\n  double x;\n  double y;\n  double z;\n  double r;\n}\n\nstruct Edge\n{\n  int left;\n  int right;\n  double len;\n}\n\nclass UnionFind\n{\n  uint[] par;\n  this(int n)\n  {\n    par = new uint[n];\n    foreach (i, ref p; par)\n    {\n      p = cast(uint) i;\n    }\n  }\n\n  uint Find(uint x)\n  {\n    if (par[x] == x)\n    {\n      return x;\n    }\n    else\n    {\n      return par[x] = Find(par[x]);\n    }\n  }\n\n  bool Same(uint x, uint y)\n  {\n    return Find(x) == Find(y);\n  }\n\n  void Union(uint x, uint y)\n  {\n    x = Find(x);\n    y = Find(y);\n    if (x == y)\n    {\n      return;\n    }\n\n    par[x] = y;\n  }\n}\n\ndouble dist(Sphere left, Sphere right)\n{\n  return max(0, ((cast(double)(left.x - right.x).pow(2) + (left.y - right.y)\n      .pow(2) + (left.z - right.z).pow(2)).sqrt - left.r - right.r));\n}\n\nvoid main()\n{\n  for (;;)\n  {\n    int n = readln.chomp.to!int;\n    if (n == 0)\n    {\n      break;\n    }\n    Sphere[] list;\n    foreach (i; 0 .. n)\n    {\n      auto v = readln.chomp.split(\" \").map!(to!double);\n      Sphere s;\n      s.x = v[0];\n      s.y = v[1];\n      s.z = v[2];\n      s.r = v[3];\n      list ~= s;\n    }\n    Edge[] atoms;\n    foreach (i; 0 .. n)\n    {\n      foreach (j; i + 1 .. n)\n      {\n        auto left = list[i];\n        auto right = list[j];\n        Edge edge;\n        edge.left = i;\n        edge.right = j;\n        edge.len = dist(left, right);\n        atoms ~= edge;\n      }\n    }\n    auto uf = new UnionFind(n);\n    double acm = 0;\n    atoms.sort!((a, b) => a.len < b.len);\n    foreach (edge; atoms) {\n      if (uf.Same(edge.left, edge.right)){\n        continue;\n      }\n      uf.Union(edge.left, edge.right);\n      acm += edge.len;\n    }\n    writefln(\"%f\", acm);\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\nimport std.container;\nimport std.array;\nimport std.math;\n\nstruct Sphere\n{\n  double x;\n  double y;\n  double z;\n  double r;\n}\n\nstruct Edge\n{\n  int left;\n  int right;\n  double len;\n}\n\nclass UnionFind\n{\n  uint[] par;\n  this(int n)\n  {\n    par = new uint[n];\n    foreach (i, ref p; par)\n    {\n      p = cast(uint) i;\n    }\n  }\n\n  uint Find(uint x)\n  {\n    if (par[x] == x)\n    {\n      return x;\n    }\n    else\n    {\n      return par[x] = Find(par[x]);\n    }\n  }\n\n  bool Same(uint x, uint y)\n  {\n    return Find(x) == Find(y);\n  }\n\n  void Union(uint x, uint y)\n  {\n    x = Find(x);\n    y = Find(y);\n    if (x == y)\n    {\n      return;\n    }\n\n    par[x] = y;\n  }\n}\n\ndouble dist(Sphere left, Sphere right)\n{\n  return max(0, ((cast(double)(left.x - right.x).pow(2) + (left.y - right.y)\n      .pow(2) + (left.z - right.z).pow(2)).sqrt - left.r - right.r));\n}\n\nvoid main()\n{\n  for (;;)\n  {\n    int n = readln.chomp.to!int;\n    if (n == 0)\n    {\n      break;\n    }\n    Sphere[] list;\n    foreach (i; 0 .. n)\n    {\n      auto v = readln.chomp.split(\" \").map!(to!double);\n      Sphere s;\n      s.x = v[0];\n      s.y = v[1];\n      s.z = v[2];\n      s.r = v[3];\n      list ~= s;\n    }\n    Edge[] atoms;\n    foreach (i; 0 .. n)\n    {\n      foreach (j; i + 1 .. n)\n      {\n        auto left = list[i];\n        auto right = list[j];\n        Edge edge;\n        edge.left = i;\n        edge.right = j;\n        edge.len = dist(left, right);\n        atoms ~= edge;\n      }\n    }\n    auto uf = new UnionFind(n);\n    double acm = 0;\n    atoms.sort!((a, b) => a.len < b.len);\n    foreach (edge; atoms) {\n      if (uf.Same(edge.left, edge.right)){\n        continue;\n      }\n      uf.Union(edge.left, edge.right);\n      acm += edge.len;\n    }\n    writefln(\"%.3f\", acm);\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\nimport std.typecons;\nimport std.math;\n\n\nclass UnionFind\n{\n\tint[] data;\n\n\tthis() {\n\t}\n\n\tthis(int x) {\n\t\tdata = new int[](x);\n\t\tdata[] = -1;\n\t}\n\n\tbool unionSet(int x, int y)\n\t{\n\t\tx = root(x); y=root(y);\n\t\tif(x != y)\n\t\t{\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\t\n\tint root(int x)\n\t{\n\t\tif( data[x] < 0 ) return x;\n\t\treturn data[x]=root(data[x]);\n\t}\n};\n\t\n\nalias Tuple!(double, \"x\", double, \"y\", double, \"z\") P3;\nalias Tuple!(P3, \"p\", double, \"r\") Sphere;\nalias Tuple!(int, \"src\", int, \"dst\", double, \"cost\") Edge;\n\nstring[] inputs;\n\ndouble dist(Sphere a, Sphere b)\n{\n\tdouble res = sqrt((a.p.x-b.p.x)^^2 + (a.p.y-b.p.y)^^2 + (a.p.z-b.p.z)^^2) - (a.r+b.r);\n\tif (res < 0) res = 0;\n\n\treturn res;\n}\n\n\ndouble solve(int N, Sphere[] stations) {\n\t\n\tint connected = 0;\n\tdouble res = 0;\n\n\tUnionFind uf = new UnionFind(N);\n\tEdge[] edges;\n\n\tforeach(i; 0..N)\n\tforeach(j; i+1..N) {\n\t\tedges ~= Edge(i,j,dist(stations[i],stations[j]));\n\t}\n\n\tsort!(\"a.cost < b.cost\")(edges);\n\n\tforeach(e; edges) {\n\t\tif(connected >= N-1) break;\n\t\tif(uf.unionSet(e.src, e.dst)) {\n\t\t\tconnected++;\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\treturn res;\n}\n\t\n\nvoid main()\n{\n\t\n\twhile(true)\n\t{\n\t\tinputs = split(chomp(readln));\n\t\tint N = to!int(inputs[0]);\n\t\tif(N==0) break;\n\n\t\tSphere[] stations = new Sphere[](N);\n\t\tforeach(i; 0..N) {\n\t\t\tinputs = split(chomp(readln));\n\t\t\tstations[i] = Sphere(P3(to!double(inputs[0]), to!double(inputs[1]), to!double(inputs[2])), to!double(inputs[3]));\n\t\t}\n\n\t\twritefln(\"%.3f\", solve(N, stations));\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\nimport std.typecons;\nimport std.math;\n\n\nclass UnionFind\n{\n\tint[] data;\n\n\tthis() {\n\t}\n\n\tthis(int x) {\n\t\tdata = new int[](x);\n\t\tdata[] = -1;\n\t}\n\n\tbool unionSet(int x, int y)\n\t{\n\t\tx = root(x); y=root(y);\n\t\tif(x != y)\n\t\t{\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\t\n\tint root(int x)\n\t{\n\t\tif( data[x] < 0 ) return x;\n\t\treturn data[x]=root(data[x]);\n\t}\n};\n\t\n\nalias Tuple!(double, \"x\", double, \"y\", double, \"z\") P3;\nalias Tuple!(P3, \"p\", double, \"r\") Sphere;\nalias Tuple!(int, \"src\", int, \"dst\", double, \"cost\") Edge;\n\nstring[] inputs;\n\ndouble dist(Sphere a, Sphere b)\n{\n\treturn sqrt((a.p.x-b.p.x)^^2 + (a.p.y-b.p.y)^^2 + (a.p.z-b.p.z)^^2) - (a.r+b.r);\n}\n\nbool intersectSS(Sphere a, Sphere b)\n{\n\treturn dist(a,b) < 0;\n}\n\n\n\ndouble solve(int N, Sphere[] stations) {\n\t\n\tint connected = 0;\n\tdouble res = 0;\n\n\tUnionFind uf = new UnionFind(N);\n\tEdge[] edges;\n\n\tforeach(i; 0..N)\n\tforeach(j; i+1..N) {\n\t\tif(intersectSS(stations[i], stations[j])) {\n\t\t\tuf.unionSet(i,j);\n\t\t\tconnected++;\n\t\t}\n\t\telse edges ~= Edge(i,j,dist(stations[i],stations[j]));\n\t}\n\n\tsort!(\"a.cost < b.cost\")(edges);\n\n\tforeach(e; edges) {\n\t\tif(connected >= N-1) break;\n\t\tif(uf.unionSet(e.src, e.dst)) {\n\t\t\tconnected++;\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\treturn res;\n}\n\t\n\nvoid main()\n{\n\t\n\twhile(true)\n\t{\n\t\tinputs = split(chomp(readln));\n\t\tint N = to!int(inputs[0]);\n\t\tif(N==0) break;\n\n\t\tSphere[] stations = new Sphere[](N);\n\t\tforeach(i; 0..N) {\n\t\t\tinputs = split(chomp(readln));\n\t\t\tstations[i] = Sphere(P3(to!double(inputs[0]), to!double(inputs[1]), to!double(inputs[2])), to!double(inputs[3]));\n\t\t}\n\n\t\twritefln(\"%.10f\", solve(N, stations));\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.range;\nimport std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, std.random, core.bitop;\n\nvoid scan(T...)(ref T args) {\n    auto line = readln.split;\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront;\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\nbool chmin(T, U...)(ref T x, U args) {\n    bool isChanged;\n    foreach (arg; args) if (x > arg) {\n        x = arg;\n        isChanged = true;\n    }\n    return isChanged;\n}\n\nbool chmax(T, U...)(ref T x, U args) {\n    bool isChanged;\n    foreach (arg; args) if (x < arg) {\n        x = arg;\n        isChanged = true;\n    }\n    return isChanged;\n}\n\n\nenum inf = 1_001_001_001;\nenum infl = 1_001_001_001_001_001_001L;\n\n\nstruct UnionFind {\n    int N;\n    int[] parent; // 根は -(連結成分のサイズ) としておく\n    int cc; // 連結成分の個数\n\n    this(int n)\n    in {\n        assert(n > 0);\n    }\n    body {\n        N = n;\n        cc = n;\n        parent = new int[](N);\n        parent[] = -1;\n    }\n\n    int root(int x)\n    in {\n        assert(0 <= x && x < N);\n    }\n    body {\n        if (parent[x] < 0) return x;\n        else return parent[x] = root(parent[x]);\n    }\n\n    int size(int x)\n    in {\n        assert(0 <= x && x < N);\n    }\n    body {\n        return -parent[root(x)];\n    }\n\n    bool same(int x, int y)\n    in {\n        assert(0 <= x && x < N);\n        assert(0 <= y && y < N);\n    }\n    body {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y)\n    in {\n        assert(0 <= x && x < N);\n        assert(0 <= y && y < N);\n    }\n    body {\n        import std.algorithm : swap;\n\n        x = root(x);\n        y = root(y);\n\n        if (x == y) return false;\n        if (size(x) < size(y)) swap(x, y);\n\n        // size(x) >= size(y)\n        parent[x] += parent[y];\n        parent[y] = x;\n        cc--;\n\n        return true;\n    }\n}\n\n\nunittest {\n    auto uf = UnionFind(10);\n\n    uf.merge(0, 8);\n    uf.merge(2, 7);\n    uf.merge(3, 6);\n\n    assert(!uf.same(0, 6));\n    assert(!uf.same(4, 5));\n    assert(uf.same(2, 7));\n    assert(uf.size(8) == 2);\n    assert(uf.size(2) == 2);\n    assert(uf.size(3) == 2);\n    assert(uf.size(4) == 1);\n\n    uf.merge(2, 6);\n    uf.merge(0, 5);\n    uf.merge(0, 9);\n\n    assert(uf.same(8, 9));\n    assert(uf.same(9, 5));\n    assert(uf.same(6, 7));\n    assert(uf.same(7, 3));\n    assert(uf.size(2) == 4);\n    assert(uf.size(6) == 4);\n    assert(uf.size(5) == 4);\n    assert(uf.size(8) == 4);\n    assert(uf.size(9) == 4);\n    assert(uf.size(1) == 1);\n\n    assert(!uf.same(1, 9));\n    assert(!uf.same(5, 7));\n    assert(!uf.same(0, 3));\n    assert(!uf.same(8, 2));\n}\n\nalias Edge = Tuple!(int, \"s\", int, \"t\", double, \"cost\");\n\ndouble kruskal(int N, Edge[] es) {\n    double res = 0;\n    es.sort!\"a.cost < b.cost\"();\n    auto uf = UnionFind(N);\n    while (uf.cc > 1) {\n        auto e = es.front; es.popFront();\n        auto u = e.s, v = e.t, c = e.cost;\n        if (!uf.same(u, v)) {\n            uf.merge(u, v);\n            res += c;\n        }\n    }\n    return res;\n}\n\nvoid main() {\n    while (true) {\n        int N;\n        scan(N);\n        if (N == 0) return;\n        auto x = new double[](N);\n        auto y = new double[](N);\n        auto z = new double[](N);\n        auto r = new double[](N);\n        iota(N).each!(i => scan(x[i], y[i], z[i], r[i]));\n\n        auto es = new Edge[](N * (N - 1) / 2);\n        int idx;\n        foreach (i ; 0 .. N) {\n            foreach (j ; i + 1 .. N) {\n                auto d = hypot(hypot(x[i] - x[j], y[i] - y[j]), z[i] - z[j]);\n                es[idx] = Edge(i, j, max(d - r[i] - r[j], 0));\n                idx++;\n            }\n        }\n        auto ans = kruskal(N, es);\n        writefln(\"%.3f\", ans);\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\n///\nstruct PriorityQueue(alias _fun, T) {\n    import std.functional : binaryFun;\n    import std.algorithm : swap;\n    alias fun = binaryFun!_fun;\n\n    ///\n    this(T[] ts) {\n        foreach (t; ts) enqueue(t);\n    }\n\n    ///\n    PriorityQueue!(_fun, T) enqueue(T e) {\n        if (this.tree.length == 0) this.tree.length = 1;\n        if (this.tree.length == this.n) this.tree.length *= 2;\n        this.tree[this.n] = e;\n        auto i = this.n;\n        this.n += 1;\n        while (i) {\n            auto j = (i-1)/2;\n            if (fun(this.tree[i], this.tree[j])) {\n                swap(this.tree[i], this.tree[j]);\n                i = j;\n            } else break;\n        }\n        return this;\n    }\n\n    alias insertFront = enqueue;\n    alias insert = enqueue;\n\n    ///\n    T dequeue() {\n        auto ret = this.tree[0];\n        this.n -= 1;\n        this.tree[0] = this.tree[this.n];\n        this.tree = this.tree[0..$-1];\n        size_t i;\n        for (;;) {\n            auto l = i*2+1;\n            auto r = i*2+2;\n            if (l >= this.n) break;\n            size_t j;\n            if (r >= this.n) {\n                j = l;\n            } else {\n                j = fun(this.tree[r], this.tree[l]) ? r : l;\n            }\n            if (fun(this.tree[j], this.tree[i])) {\n                swap(this.tree[i], this.tree[j]);\n                i = j;\n            } else break;\n        }\n        return ret;\n    }\n\n    ///\n    @property\n    T front() {\n        return this.tree[0];\n    }\n\n    ///\n    @property\n    bool empty() {\n        return this.n == 0;\n    }\n\n    ///\n    void popFront() {\n        this.dequeue();\n    }\n\n    alias removeFront = popFront;\n\n    ///\n    @property\n    size_t length() {\n        return this.n;\n    }\n\nprivate:\n    size_t n;\n    T[] tree;\n}\n\n///\nPriorityQueue!(fun, T) priority_queue(alias fun, T)(T[] ts = []) {\n    return PriorityQueue!(fun, T)(ts);\n}\n\nstruct UFTree(T)\n{\n    struct Node\n    {\n        T parent;\n        T rank = 1;\n    }\n\n    ///\n    T min_size, max_size;\n\n    ///\n    this(T n)\n    {\n        nodes.length = n;\n        sizes.length = n;\n        foreach (i, ref node; nodes) {\n            node = Node(i.to!T);\n            sizes[i] = 1;\n        }\n\n        min_sizes.length = n + 1;\n        min_sizes[1] = n;\n        min_size = 1;\n        max_size = 1;\n    }\n\n    ///\n    bool unite(T a, T b)\n    {\n        a = root(a);\n        b = root(b);\n\n        if (a == b) return false;\n\n        auto a_size = sizes[a];\n        auto b_size = sizes[b];\n        --min_sizes[a_size];\n        --min_sizes[b_size];\n        ++min_sizes[a_size + b_size];\n        foreach (nxt_size; min(a_size, b_size)..min_sizes.length) if (min_sizes[nxt_size] != 0) {\n            min_size = nxt_size.to!T;\n            break;\n        }\n        max_size = max(max_size, a_size + b_size);\n\n        if (nodes[a].rank < nodes[b].rank) {\n            sizes[a] += sizes[b];\n            nodes[b].parent = a;\n        } else {\n            sizes[b] += sizes[a];\n            nodes[a].parent = b;\n            if (nodes[a].rank == nodes[b].rank) ++nodes[b].rank;\n        }\n\n        return true;\n    }\n\n    ///\n    bool is_same(T a, T b)\n    {\n        return root(a) == root(b);\n    }\n\n    ///\n    T size(T i)\n    {\n        return sizes[root(i)];\n    }\n\nprivate:\n    Node[] nodes;\n    T[] sizes;\n    T[] min_sizes;\n\n    T root(T i)\n    {\n        if (nodes[i].parent == i) return i;\n\n        return nodes[i].parent = root(nodes[i].parent);\n    }\n}\n\n///\nUFTree!T uftree(T)(T n)\n{\n    return UFTree!T(n);\n}\n\nstruct Cell {\n    double x, y, z, r;\n\n    this(double x, double y, double z, double r) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.r = r;\n    }\n\n    double dist(Cell o) {\n        return sqrt((x-o.x)^^2 + (y-o.y)^^2 + (z-o.z)^^2);\n    }\n\n    double corridor(Cell o) {\n        return dist(o) - (r + o.r);\n    }\n}\n\nalias Path = Tuple!(int, \"a\", int, \"b\", double, \"r\");\n\nvoid main()\n{\n    for (;;) {\n        auto N = readln.chomp.to!int;\n        if (N == 0) return;\n\n        Cell[] cs;\n        foreach (_; 0..N) {\n            auto xz = readln.split.to!(double[]);\n            cs ~= Cell(xz[0], xz[1], xz[2], xz[3]);\n        }\n\n        auto pq = priority_queue!(\"a.r < b.r\", Path)();\n\n        foreach (i; 0..N-1) {\n            foreach (j; i+1..N) {\n                pq.enqueue(Path(i, j, max(0, cs[i].corridor(cs[j]))));\n            }\n        }\n\n        auto uft = uftree(N);\n        double r = 0;\n        while (!pq.empty) {\n            auto h = pq.dequeue();\n            if (uft.is_same(h.a, h.b)) continue;\n            uft.unite(h.a, h.b);\n            r += h.r;\n        }\n        writefln(\"%.3f\", r);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "import queue, math\nwhile True:\n    n = int(input())\n    if n == 0: break\n    p = [[float(x) for x in input().split()] for _ in range(n)]\n    g = [i for i in range(n)]\n\n    def root(x):\n        if x == g[x]: return x\n        g[x] = root(g[x])\n        return g[x]\n\n    q = queue.PriorityQueue()\n    cnt_g = n\n    ans = 0.0\n    for i in range(n-1):\n        for j in range(i,n):\n            d = math.sqrt((p[i][0]-p[j][0])**2 + (p[i][1]-p[j][1])**2 + (p[i][2]-p[j][2])**2)\n            if d <= p[i][3] + p[j][3] :\n                if root(i) != root(j):\n                    g[root(i)] = root(j)\n                    cnt_g -= 1\n            else:\n                q.put((d-p[i][3]-p[j][3],i,j))\n\n    while not q.empty():\n        if cnt_g <= 1 : break\n        d, i, j = q.get()\n        if root(i) != root(j):\n            g[root(i)] = root(j)\n            cnt_g-= 1\n            ans += d\n\n    print ('{:.3f}'.format(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e10\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = R(xyzr[i],xyzr[j])\n\t\t\tif l < ans:\n\t\t\t\tans = l\n\t\t\t\ts = [i,j]\n\tans = 0.0\n\tchain = [xyzr.pop(0)] #[xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "import math\n\nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    G=[]\n    for index in range(n):\n        x,y,z,r=map(float,input().split())\n        G.append((x,y,z,r))\n\n    def distance(X,Y):\n        d=(X[0]-Y[0])**2+(X[1]-Y[1])**2+(X[2]-Y[2])**2\n        Max=X[3]+Y[3]\n        if Max**2<d:\n            return math.sqrt(d)-Max    \n        else:\n            return 0\n    \n    D=[[0]*n for _ in range(n)]\n    #隣接行列\n    for index1 in range(n):\n        for index2 in range(index1+1,n):\n            dist=distance(G[index1],G[index2])\n            D[index1][index2]=dist\n            D[index2][index1]=dist\n\n    def prim(n,cost):\n        mincost = [float(\"inf\")]*n\n        used = [False] * n\n        mincost[0] = 0\n        res = 0\n\n        while True:\n            v = -1\n            for i in range(n):\n                if (not used[i]) and (v == -1 or mincost[i] < mincost[v]):\n                    v = i\n            if v == -1:\n                break\n            used[v] = True\n            res += mincost[v]\n            for i in range(n):\n                mincost[i] = min(mincost[i],cost[v][i])\n        return res\n    \n\n    ans=prim(n,D)\n    print('{:.3f}'.format(ans))\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        \n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    def same(self, x, y):\n        if self.find(x) == self.find(y):\n            return True\n        else:\n            return False\n\n\ndef kruskal(n, edges):\n    uf = UnionFind(n)\n    edges.sort()\n    res = 0\n    for c, s, t in edges:\n        if not uf.same(s, t):\n            res += c\n            uf.unite(s, t)\n    return res\n\nwhile True:\n    n = int(input())\n    if n == 0: break\n\n    x = [0] * n\n    y = [0] * n\n    z = [0] * n\n    r = [0] * n\n    for i in range(n):\n        x[i], y[i], z[i], r[i] = map(float, input().split())\n    \n    edges = []\n    for i in range(n):\n        for j in range(n):\n            if i == j: continue\n            c = max(((x[i]-x[j])**2 + (y[i]-y[j])**2 + (z[i]-z[j])**2)**(1/2) - (r[i]+r[j]), 0)\n            edges.append((c, i, j))\n    \n    print(\"{:.3f}\".format(kruskal(n, edges)))\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 0.0\n\tchain = [xyzr.pop(0)]\n\twhile xyzr:\n\t\tpipe = 1e12\n\t\tfor i in range(len(xyzr)):\n\t\t\tx,y,z,r = xyzr[i]\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tx1,y1,z1,r1 = chain[j]\n\t\t\t\tl = max(0,((x-x1)**2 + (y-y1)**2 + (z-z1)**2)**0.5 - r - r1)\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "while True:\n    N = int(input())\n    if not N:\n        break\n    X = [False if i else True for i in range(N)]\n    ans = 0\n\n    V = [list(map(float, input().split())) for i in range(N)]\n    dp = [[0 for i in range(N)] for j in range(N)]\n\n    # とりあえずすべての変の距離を測る\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                dp[i][j] = float('inf')\n            else:\n                tmp = ((V[i][0] - V[j][0]) ** 2 + (V[i][1] - V[j][1]) ** 2 + (V[i][2] - V[j][2]) ** 2) ** 0.5\n                dp[i][j] = max(0, tmp - V[i][3] - V[j][3])\n\n    # おそらくプリム法\n    for loop in range(N - 1):\n        tmpmin = float('inf')\n        for i in range(N):\n            for j in range(N):\n                if X[i] and not X[j]:\n                    if dp[i][j] < tmpmin:\n                        tmpmin = dp[i][j]\n                        tmp = j\n        ans += tmpmin\n        X[tmp] = True\n\n    print('{0:.3f}'.format(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\nimport heapq\nfrom collections import deque\nimport decimal\n\n# sys.setrecursionlimit(100001)\nINF = sys.maxsize\n\n\n# ===CODE===\ndef main():\n    class UnionFind():\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * n\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n\n            if x == y:\n                return\n\n            if self.parents[x] > self.parents[y]:\n                x, y = y, x\n\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n) if self.find(i) == root]\n\n        def roots(self):\n            return [i for i, x in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    def calc_dist(x1, y1, z1, r1, x2, y2, z2, r2):\n        tmp = ((float(x1) - float(x2)) ** 2 + (float(y1) - float(y2)) ** 2 + (float(z1) - float(z2)) ** 2) ** (1 / 2)\n        tmp = max(0, tmp - float(r1) - float(r2))\n        return tmp\n\n    while True:\n        n = int(input())\n        if n == 0:\n            exit(0)\n        tree = UnionFind(n)\n\n        data = [input().split() for i in range(n)]\n\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((calc_dist(data[i][0], data[i][1], data[i][2], data[i][3], data[j][0], data[j][1],\n                                        data[j][2], data[j][3]), i, j))\n\n        edges.sort()\n\n        ans = 0\n        for d, s, t in edges:\n            if not tree.same(s, t):\n                tree.union(s, t)\n                ans += d\n\n        print(\"{:.3f}\".format(ans))\n\n\n# ===main===\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "inf = 1 << 28\ndef calc(xyzr1,xyzr2):\n    x1,y1,z1,r1 = xyzr1\n    x2,y2,z2,r2 = xyzr2\n    d = ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5\n    return max(0, d-r1-r2)\n    \nwhile 1:\n    n = int(raw_input())\n    if n == 0: break\n    xyzr = [map(float,raw_input().split()) for i in xrange(n)]\n    \n    cost = [[0]*n for i in xrange(n)]\n    for i in xrange(n):\n        for j in xrange(n):\n            cost[i][j] = cost[j][i] = calc(xyzr[i],xyzr[j])\n    \n    mincost = [inf]*n\n    used = [False]*n\n    mincost[0] = 0\n    ans = 0\n    while 1:\n        v = -1\n        for u in xrange(n):\n            if not used[u] and (v == -1 or mincost[u] < mincost[v]): v = u\n        if v == -1: break\n        used[v] = True\n        ans += mincost[v]\n        for u in xrange(n):\n            mincost[u] = min(mincost[u], cost[v][u])\n    \n    print \"%.6f\"%ans\n    \n    "
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e10\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = R(xyzr[i],xyzr[j])\n\t\t\tif l < ans:\n\t\t\t\tans = l\n\t\t\t\ts = [i,j]\n\tchain = [xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tif n == 1:\n\t\tprint 0.0\n\t\tcontinue\n\tans = 1e10\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tL = R(xyzr[i],xyzr[j])\n\t\t\tif L < ans:\n\t\t\t\tans = L\n\t\t\t\ts = [i,j]\n\tchain = [xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tL = R(xyzr[i],chain[j])\n\t\t\t\tif L < pipe:\n\t\t\t\t\tpipe = L\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "import queue\nimport math\n\n\ndef root(node):\n    if nodes[node] == node:\n        return node\n    nodes[node] = root(nodes[node])\n    return nodes[node]\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n\n    cells = [list(map(float, input().split())) for _ in range(n)]\n\n    nodes = [i for i in range(n)]\n\n    q = queue.PriorityQueue()\n    cost = 0\n    count = n\n    for i in range(n - 1):\n        for j in range(i, n):\n            d = math.sqrt((cells[i][0] - cells[j][0])**2 + (cells[i][1] - cells[j][1])**2 + (cells[i][2] - cells[j][2])**2)\n            if d <= cells[i][3] + cells[j][3]:\n                if root(i) != root(j):\n                    nodes[root(i)] = root(j)\n                    count += 1\n            else:\n                q.put((d - cells[i][3] - cells[j][3], i, j))\n    while not q.empty():\n        if count <= 1:\n            break\n        d, i, j = q.get()\n        if root(i) != root(j):\n            nodes[root(i)] = root(j)\n            count -= 1\n            cost += d\n    print('{:.3f}'.format(cost))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\n \nsys.setrecursionlimit(10 ** 7)\n \nfrom collections import defaultdict\n \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\n# list(map(int, input().split()))\nclass UnionFind(object):\n    def __init__(self, n = 1):\n        self.link = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.link[x] == x:\n            return x\n\n        # re-connect union find to make the height of tree lower\n        # you can use while, but recursion makes it easier to reconnect\n        self.link[x] = self.find(self.link[x])\n        return self.link[x]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.link[y] = x\n        self.size[x] += self.size[y]\n    \n    def get_size(self, x):\n        x = self.find(x)\n        return self.size[x]\n\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    cells = [0] * N\n    for i in range(N):\n        x, y, z, r = map(float, input().split())\n        cells[i] = (x, y, z, r)\n    \n    edges = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1, z1, r1 = cells[i]\n            x2, y2, z2, r2 = cells[j]\n            d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2)\n            if d <= r1 + r2:\n                d = 0\n            else:\n                d = d - r1 - r2\n            edges.append((d, i, j))\n\n    edges = sorted(edges)\n\n    u = UnionFind(N)\n    ans = 0\n    for e in edges:\n        d, a, b = e\n        if u.is_same(a, b):\n            continue\n        u.unite(a, b)\n        ans += d\n    print('{:.3f}'.format(ans))\n            \n\n"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127\nfrom math import sqrt\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nclass UnionFind:\n    def __init__(self, n):\n        # 初期状態は全要素が根なので、親は自分自身\n        self.par = [i for i in range(n+1)]\n        # 集団の要素数(size)を格納する(初期は全て1)\n        self.size = [1] * (n+1)\n    \n    # 根を検索する関数\n    def find(self, x):\n        # 根までたどったらその番号を返す\n        if self.par[x] == x:\n            return x\n        # 根でないなら親の要素で再検索\n        else:\n            # 検索過程で親を書き換える(圧縮経路)\n            self.par[x] = self.find(self.par[x])\n            return self.find(self.par[x])\n  \n    # 結合(unite)する関数\n    def unite(self, x, y):\n        # 根を探す\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        # サイズを比較し、小さい方を大きい方に繋げる\n        if self.size[x] < self.size[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n           \n    # 同じグループに属するかを判定する関数\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    # 要素が属する木のサイズを返す関数\n    def get_size(self, x):\n        return self.size[self.find(x)]\n    \n    # グループ数を返す関数\n    def group_sum(self):\n        c = 0\n        for i in range(len(self.par)):\n            if self.find(i) == i:\n                c += 1\n        return c\n    \n\ndef Kruskal(V, Edges):\n    \"\"\"\n    E: E[i] = (from, to, weight)として辺を格納したリスト\n    \"\"\"\n    # 重みでソートする\n    Edges.sort(key=lambda x: x[2])\n\n    uf = UnionFind(V)\n    weight = 0\n    for s, t, w in Edges:\n    \t# s, tが連結なら閉路を作ってしまう。\n    \tif uf.is_same(s, t):\n        \t    continue\n    \t# s, tを繋げても閉路にならないとき\n    \telse:\n        \tweight += w\n        \tuf.unite(s, t)\n\n    return weight\n\n\ndef main():\n    ans = []\n    #with open(\"AOJ\\\\in.txt\", \"r\") as f:\n\n    while True:\n        n = int(readline())\n        if n == 0:\n            break\n            \n        xyzr = [tuple(map(float, readline().split()))for _ in range(n)]\n        E = []\n        for i in range(n-1):\n            x_i, y_i, z_i, r_i = xyzr[i]\n            for j in range(i+1,n):\n                x_j, y_j, z_j, r_j = xyzr[j]\n                d = sqrt((x_i - x_j)**2 + (y_i - y_j)**2 + (z_i - z_j)**2)\n                length = max(d - (r_i + r_j), 0.0)\n                E.append((i, j, length))\n\n        # クラスカル法\n        weight = Kruskal(n, E)\n        ans.append(weight)\n\n    print(\"\\n\".join(\"{:.3f}\".format(i) for i in ans))\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e10\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = R(xyzr[i],xyzr[j])\n\t\t\tif l < ans:\n\t\t\t\tans = l\n\t\t\t\ts = [i,j]\n\tchain = [xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 0\n\tchain = [xyzr.pop(0)]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tx,y,z,r = xyzr[i]\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tx1,y1,z1,r1 = chain[j]\n\t\t\t\tl = max(0,((x-x1)**2 + (y-y1)**2 + (z-z1)**2)**0.5 - r - r1)\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "import heapq\nimport math\n\ndef dist(xyzr0, xyzr1):\n    vec = [xyzr0[i] - xyzr1[i] for i in range(3)]\n    d = math.sqrt(sum([elem*elem for elem in vec]))\n    return max(0, d - xyzr0[3] - xyzr1[3])\n\ndef mst(n, dists):\n    in_tree = [False] * n\n    start = 0\n    in_tree[start] = True\n    q = [(dists[start][to], start, to) for to in range(n)]\n    heapq.heapify(q)\n    ans = 0\n    cnt = 0\n    while q and cnt < n-1:\n        dist, fr, to = heapq.heappop(q)\n        if in_tree[to]:\n            continue\n        in_tree[to] = True\n        ans += dist\n        cnt += 1\n        for to_ in range(n):\n            heapq.heappush(q, (dists[to][to_], to, to_))\n    return ans\n\ndef solve(n):\n    XYZR = []\n    for _ in range(n):\n        XYZR.append(list(map(float, input().split())))\n    dists = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            dists[i][j] = dist(XYZR[i], XYZR[j])\n    ans = mst(n, dists)\n    print('%.3f' % ans)\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n\n"
  },
  {
    "language": "Python",
    "code": "class DisjointSets:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.siz = [1]*n\n\n    def root(self,x):\n        if x != self.parent[x]: \n            self.parent[x] = self.root(self.parent[x])\n        return self.parent[x]\n\n    def same(self,x,y): \n        return self.root(x) == self.root(y)\n\n    def unite(self,x,y): \n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.siz[x] < self.siz[y]:\n            x,y = y,x\n        self.parent[y] = x\n        self.siz[x] += self.siz[y]\n\n    def size(self,x):\n        return self.siz[self.root(x)]\n\ndef length(a,b):\n    x1,y1,z1,r1 = cell[a]\n    x2,y2,z2,r2 = cell[b]\n    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5-r1-r2\n\nwhile True:\n    n = int(input())\n    if not n: break\n    cell = [[float(i) for i in input().split()] for _ in range(n)]\n    corri = []\n    ds = DisjointSets(n)\n    for i in range(n):\n        for j in range(i+1,n):\n            l = length(i,j)\n            if l <= 0: ds.unite(i,j)\n            else: corri.append((l,i,j))\n    corri.sort(key = lambda x:x[0])\n    sumlen = 0\n    for l,a,b in corri:\n        if ds.same(a,b): continue\n        sumlen += l\n        ds.unite(a,b)\n    print(f\"{sumlen:.3f}\")\n"
  },
  {
    "language": "Python",
    "code": "def R(xyrz,xyrz1):\n\tx, y, z, r  = xyrz\n\tx1,y1,z1,r1 = xyrz1\n\treturn max(0,((x-x1)**2 + (y-y1)**2 + (z-z1)**2)**0.5 - r - r1)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e12\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = R(xyzr[i],xyzr[j])\n\t\t\tif l < ans:\n\t\t\t\tans = l\n\t\t\t\ts = [i,j]\n\tchain = [xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e12\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "from decimal import *\n\nclass UnionFind():\n    # 初めは全ての頂点が別々の木の根\n    def __init__(self, n):  # n要素で初期化\n        self.parent = list(range(n)) # 親\n        self.rank = [0] * n   # 木の深さ\n        self._nsets = n  # 集合の数\n\n    def root_of(self, x):\n        children = [x]\n        while self.parent[x] != x:\n            x = self.parent[x]\n            children.append(x)\n\n        for ch in children:\n            self.parent[ch] = x\n        return x\n\n    # xとyの属する集合を併合\n    def union(self, x, y):\n        rx = self.root_of(x)\n        ry = self.root_of(y)\n        if rx == ry:\n            return\n        if self.rank[rx] < self.rank[ry]: # ランクの小さい木から大きい木の根に辺を張る\n            self.parent[rx] = ry  # rxをryの子とする\n        else:\n            self.parent[ry] = rx\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n        self._nsets -= 1\n\n    # 同じ集合に属するかどうか\n    def same(self, x, y):\n        return self.root_of(x) == self.root_of(y)\n\n    # 集合の数\n    def get_nsets(self):\n        return self._nsets\n\nwhile True:\n    N = int(input())\n    if N == 0: break\n    x = [None] * N;  y = [None] * N;  z = [None] * N\n    r = [None] * N\n    for i in range(N):\n        x[i], y[i], z[i], r[i] = [Decimal(a) for a in input().split()]\n\n    E = []\n    uf = UnionFind(N)\n    for i in range(N):\n        for j in range(i + 1, N):\n            dsq = pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) + pow(z[i] - z[j], 2)\n            rsq = pow(r[i] + r[j], 2)\n            if dsq <= rsq:\n                uf.union(i, j)\n            else:\n                E.append((dsq.sqrt() - r[i] - r[j], (i, j)))\n\n    E.sort()\n    ans = Decimal('0')\n    for d, (i, j) in E:\n        if uf.get_nsets() == 1:  break\n        if uf.same(i, j): continue\n        uf.union(i, j)\n        ans += d\n\n    ans = ans.quantize(Decimal('0.001'), rounding = ROUND_HALF_UP)\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "inf = 1 << 28\ndef calc(xyzr1,xyzr2):\n    x1,y1,z1,r1 = xyzr1\n    x2,y2,z2,r2 = xyzr2\n    d = ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5\n    return max(0, d-r1-r2)\n    \nwhile 1:\n    n = int(raw_input())\n    if n == 0: break\n    xyzr = [map(float,raw_input().split()) for i in xrange(n)]\n    \n    cost = [[0]*n for i in xrange(n)]\n    for i in xrange(n):\n        for j in xrange(n):\n            cost[i][j] = cost[j][i] = calc(xyzr[i],xyzr[j])\n    \n    mincost = [inf]*n\n    used = [False]*n\n    mincost[0] = 0\n    ans = 0\n    while 1:\n        v = -1\n        for u in xrange(n):\n            if not used[u] and (v == -1 or mincost[u] < mincost[v]): v = u\n        if v == -1: break\n        used[v] = True\n        ans += mincost[v]\n        for u in xrange(n):\n            mincost[u] = min(mincost[u], cost[v][u])\n    \n    print \"%.3f\"%ans\n    \n    "
  },
  {
    "language": "Python",
    "code": "import sys, itertools\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**10\nMOD = 1000000007\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef kruskal(es, V):\n    es.sort(key=lambda x:x[2])\n    uf = UnionFind(V)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.union(e[0], e[1])\n            res += e[2]\n    return res\n\ndef resolve():\n    while True:\n        n = I()\n        if n==0:\n            break\n        else:\n            xyzr = [LF() for _ in range(n)]\n\n            edge = []\n            for i, j in itertools.combinations(range(n), 2):\n                corridor_length = max(sum([(k-m)**2 for k, m in zip(xyzr[i][:3], xyzr[j][:3])])**0.5-(xyzr[i][3]+xyzr[j][3]), 0)\n                edge.append([i, j, corridor_length])\n            # print(n, edge)\n            mst_cost = kruskal(edge, n)\n            print(f'{mst_cost:.03f}')\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "from decimal import Decimal, getcontext\nfrom itertools import combinations\nfrom heapq import *\n\n\ngetcontext().prec = 30\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return True\n\nwhile True:\n    N = int(input())\n    if N ==0:\n        exit()\n\n    tree = UnionFind(N)\n\n    pos = dict()\n    for i in range(N):\n        pos[i] = tuple(map(Decimal, input().split()))\n\n    data = []\n\n    for a,b in combinations(range(N), 2):\n        x1,x2,x3,xr = pos[a]\n        y1,y2,y3,yr = pos[b]\n        cost = max(((x1-y1)**2 + (x2-y2)**2 + (x3-y3)**2).sqrt() -xr -yr, 0)\n        data.append((a, b, cost))\n\n    res = 0\n    data.sort(key=lambda x: x[2])\n\n    for a, b, cost in data:\n        if tree.union(a,b):\n            res += cost\n    print(\"{:.03f}\".format(res))\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\nfrom itertools import permutations\nfrom math import sqrt\nimport heapq\nwhile 1:\n    N = int(input())\n    if N==0:\n        break\n    uf = UnionFind(N)\n    Vs = [list(map(float, input().split())) for _ in range(N)]\n    lis = [i for i in range(N)]\n    Edges = []\n    for a, b in permutations(lis, 2):\n        x1, y1, z1, r1 = Vs[a]\n        x2, y2, z2, r2 = Vs[b]\n        d = max(0, sqrt((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)-r1-r2)\n        Edges.append((d, a, b))\n    heapq.heapify(Edges)\n    ans = 0\n    while Edges:\n        d, a, b = heapq.heappop(Edges)\n        if not uf.same(a, b):\n            ans += d\n            uf.union(a, b)\n    print('{:.3f}'.format(ans))\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/problems/1127\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [i for i in range(n)]\n\n    def root(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.root(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return False\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[y] = x\n        return True\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n\ndef distance(x1, y1, z1, x2, y2, z2):\n    dxx = (x1 - x2) ** 2\n    dyy = (y1 - y2) ** 2\n    dzz = (z1 - z2) ** 2\n    return (dxx + dyy + dzz) ** (1/2)\n\n\ndef solve(n, rows):\n    # (start, end, corridors_length)\n    edges = []\n    for i in range(len(rows)):\n        for j in range(i + 1, len(rows)):\n            x1, y1, z1, r1 = rows[i]\n            x2, y2, z2, r2 = rows[j]\n            d = distance(x1, y1, z1, x2, y2, z2)\n            # print(i, j, d)\n            if d > r1 + r2:\n                edges.append((i, j, d-r1-r2))\n            else:\n                edges.append((i, j, 0))\n\n    edges.sort(key=lambda x: x[2])\n    # print(edges)\n\n    result = 0\n    uf = UnionFind(n)\n    for edge in edges:\n        s, t, d = edge\n        unioned = uf.union(s, t)\n        if unioned:\n            result += d\n\n    print('{:.3f}'.format(result))\n\n\nif __name__ == \"__main__\":\n    while(True):\n        n = int(input())\n        if n == 0:\n            break\n        rows = [list(map(float, input().split())) for _ in range(n)]\n        solve(n, rows)\n\n"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e10\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = R(xyzr[i],xyzr[j])\n\t\t\tif l < ans:\n\t\t\t\tans = l\n\t\t\t\ts = i\n\tchain = [xyzr.pop(s)]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127\n# クラスカル or プリム法\n\nimport math\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        # 各要素の親要素の番号を格納するリスト\n        # 根がルートの時は、グループの要素数を格納　最初は全て根で要素数1\n        self.parents = [-1] * n\n\n    # 再帰 groupの根を返す\n    # 経路圧縮あり\n    def find(self, x):\n        # 0より小さい場合は根\n        if self.parents[x] < 0:\n            # indexを返す\n            return x\n        else:\n            # 根になるまで親を辿る\n            # 経路圧縮 根のindexが全ての親に再帰的につく\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # groupを併合\n    def union(self, x, y):\n        # 根を探す\n        x = self.find(x)\n        y = self.find(y)\n\n        # 最初から統合されている\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        # 根のグループ数を追加 xの方グループの要素数が多い前提なので多い方に寄せる\n        self.parents[x] += self.parents[y]\n        # 親(根)のindexを入れる\n        self.parents[y] = x\n\n    # xのgroupのサイズ\n    def size(self, x):\n        return - self.parents[self.find(x)]\n\n    # 根が同じか判定\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # ルートが同じ要素を返す\n    def members(self, x):\n        root = self.find(x)\n        # 根が同じ要素\n        return [i for i, in range(self.n) if self.find(i) == root]\n\n    # 全ての根の要素を返す\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    # グループの数を数える 遅い\n    def group_count(self):\n        return len(self.roots())\n\n    # {root: [要素]}\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nwhile True:\n    n = int(input())\n    uf = UnionFind(n)\n    if n == 0:\n        break\n    cell = []\n    for _ in range(n):\n        x, y, z, r = map(float, input().split())\n        cell.append((x, y, z, r))\n\n    edge = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dis = math.sqrt(\n                (cell[i][0] - cell[j][0]) ** 2 + (cell[i][1] - cell[j][1]) ** 2 + (cell[i][2] - cell[j][2]) ** 2)\n            #print(dis)\n            if dis < (cell[i][3] + cell[j][3]):\n                uf.union(i, j)\n            else:\n                edge.append((dis - (cell[i][3] + cell[j][3]), i, j))\n    edge.sort()\n    ans = 0\n    num = n\n    for c, a, b in edge:\n        # 同じグループでなかったら統合\n        if not uf.same(a, b):\n            uf.union(a, b)\n            ans += c\n            num -= 1\n            # グループ数は開催する都市の数になったら終了\n            if num == 1:\n                break\n    print('{:.3f}'.format(ans))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nimport math\nfrom itertools import combinations\n\n\nclass UnionFind:\n    from collections import deque\n\n    def __init__(self, v):\n        self.v = v\n        self._tree = list(range(v + 1))\n\n    def _root(self, a):\n        queue = self.deque()\n        while self._tree[a] != a:\n            queue.append(a)\n            a = self._tree[a]\n        while queue:\n            index = queue.popleft()\n            self._tree[index] = a\n        return a\n\n    def union(self, a, b):\n        root_a = self._root(a)\n        root_b = self._root(b)\n        self._tree[root_b] = root_a\n\n    def find(self, a, b):\n        return self._root(a) == self._root(b)\n\n\nwhile True:\n    N = int(input())\n\n    if N == 0:\n        break\n\n    V = [tuple(map(float, input().split(' '))) for _ in range(N)]\n    E = []\n    for i, j in combinations(range(N), r=2):\n        xi, yi, zi, ri = V[i]\n        xj, yj, zj, rj = V[j]\n        d = math.sqrt((xi - xj) ** 2 + (yi - yj) ** 2 + (zi - zj) ** 2)\n        c = max(0.0, d - ri - rj)\n        heapq.heappush(E, (c, i, j))\n\n    uf = UnionFind(N)\n    cost = 0.0\n    while E:\n        c, i, j = heapq.heappop(E)\n        if not uf.find(i, j):\n            uf.union(i, j)\n            cost += c\n\n    print('{:.3f}'.format(cost))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport string\nimport fractions\nimport random\nfrom operator import itemgetter\nimport itertools\nfrom collections import deque\nimport copy\nimport heapq\nimport bisect\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\n\ndef minimum_spanning_tree(n, info):\n    \"\"\"\n    頂点の数:nと辺の情報i:infoから最小全域木([[辺の始点の頂点,辺の終点の頂点, 重み], ...])を返す。\n    info:[[辺の始点の頂点,辺の終点の頂点, 重み], ...](bellman_ford()の入力形式)\n    \"\"\"\n    ans = []\n    info.sort(key=itemgetter(2))\n\n    class UnionFind:\n        def __init__(self, n):\n            self.n = n\n            self.parents = [-1] * n\n\n        def find(self, x):\n            if self.parents[x] < 0:\n                return x\n            else:\n                self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n\n            if x == y:\n                return\n\n            if self.parents[x] > self.parents[y]:\n                x, y = y, x\n\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n        def size(self, x):\n            return -self.parents[self.find(x)]\n\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def members(self, x):\n            root = self.find(x)\n            return [i for i in range(self.n) if self.find(i) == root]\n\n        def roots(self):\n            return [i for i, x in enumerate(self.parents) if x < 0]\n\n        def group_count(self):\n            return len(self.roots())\n\n        def all_group_members(self):\n            return {r: self.members(r) for r in self.roots()}\n\n        def __str__(self):\n            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    uf = UnionFind(n)\n    for i in info:\n        if not uf.same(i[0], i[1]):\n            ans.append(i)\n            uf.union(i[0], i[1])\n    return ans\n\n\ndef digit_print(num, digit):  # digitは小数何桁まで表示するか。 >= 0\n    if digit == 0:\n        if type(num) is int:\n            return num\n        else:\n            num = str(num)\n            return num[:num.index(\".\")]\n    else:\n        if type(num) is int:\n            return str(num) + \".\" + \"0\" * digit\n        else:\n            num = str(num) + \"0\" * digit\n            return num[:num.index(\".\") + digit + 1]\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    x_y_z_r_num = [list(map(float, input().split())) + [i] for i in range(n)]\n    info = []\n    for i in itertools.combinations(x_y_z_r_num, 2):\n        dis = math.sqrt(sum((px - qx) ** 2.0 for px, qx in zip(i[0][:3], i[1][:3])))\n        if i[0][3] + i[1][3] >= dis:\n            info.append([i[0][4], i[1][4], 0.00])\n        else:\n            info.append([i[0][4], i[1][4], dis - i[0][3] - i[1][3]])\n    print(digit_print(round(sum(i[2] for i in minimum_spanning_tree(n, info)), 3), 3))\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        a = [LF() for _ in range(n)]\n        e = []\n        for i in range(n):\n            for j in range(i+1,n):\n                k = sum([(a[i][_]-a[j][_])**2 for _ in range(3)]) ** 0.5\n                t = a[i][3] + a[j][3]\n                e.append((k-t,i,j))\n        e.sort()\n        uf = UnionFind(n)\n        r = 0\n        for k,i,j in e:\n            if uf.union(i,j):\n                if k > 0:\n                    r += k\n\n        rr.append('{:0.3f}'.format(r))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "ii = lambda : int(input())\nmi = lambda : map(int,input().split())\nli = lambda : list(map(int,input().split()))\nlis = lambda x : int(x.replace('.',''))\nli2 = lambda : list(map(lis,input().split()))\n\n# かぶっているか判定\n# 最短判定\n\nimport math\n\nclass UnionFind:\n    def __init__(self,n):\n        self.n = n\n        self.d = [-1] * n\n\n    def find(self, x):\n        if(self.d[x] < 0):\n            return x\n        self.d[x] = self.find(self.d[x])\n        return self.d[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if(x == y):\n            return False\n        if(self.d[x] > self.d[y]):\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self,x):\n        return -self.d[self.find(x)]\n\ndef judgeContact(a,b):\n    # k = (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2 - (a[3] + b[3]) ** 2\n    k = math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2) - (a[3] + b[3]) \n    if k <= 0:\n        return -1\n    else:\n        return k\n\ndef calc(n):\n    ps = []\n    uf = UnionFind(n)\n    d = []\n    cnt = 0\n    ans = 0\n\n    for i in range(n):\n        p = li2()\n        \n        # かぶり判定\n        for k,j in enumerate(ps):\n            v = judgeContact(p,j) \n            if v == -1:\n                # d.append([0,i,k])\n                if uf.same(i,k) == False:\n                    uf.union(i,k)\n                    cnt += 1\n            else:\n                d.append([v,i,k])\n        ps.append(p)\n\n    d.sort()\n    for i in d:\n        if cnt == n-1:\n            break\n\n        if uf.same(i[1],i[2]):\n            continue\n        \n        uf.union(i[1],i[2])\n        # print('union',i[1],i[2],cnt,i[0])\n        cnt += 1\n        ans += i[0]\n\n    \n    print(\"{:.3f}\".format(ans/1000))\n\n\nwhile 1:\n    n = ii()\n    if n == 0:\n        break\n    \n    calc(n)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def root(x):\n        if par[x] == x:\n            return x\n        par[x] = root(par[x])\n        return par[x]\n\n    def unite(x,y):\n        x = root(x)\n        y = root(y)\n        if x == y:\n            return\n        if rank[x] < rank[y]:\n            par[x] = y\n        else:\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n    def D2(i,j):\n        x1,y1,z1,r = p[i]\n        x2,y2,z2,r = p[j]\n        return (x1-x2)**2+(y1-y2)**2+(z1-z2)**2\n\n    while 1:\n        n = I()\n        if n == 0:\n            return\n        p = [list(map(float, input().split())) for i in range(n)]\n        d2 = [[D2(i,j) for j in range(i)] for i in range(n)]\n        par = [i for i in range(n)]\n        rank = [0]*n\n        v = []\n        for i in range(n):\n            x,y,z,r1 = p[i]\n            for j in range(i):\n                x,y,z,r2 = p[j]\n                d = r1+r2\n                d2ij = d2[i][j]\n                if d2ij > d**2:\n                    v.append((d2ij**0.5-d,i,j))\n                else:\n                    unite(i,j)\n        v.sort()\n        ans = 0.0\n        for c,a,b in v:\n            if root(a) != root(b):\n                ans += c\n                unite(a,b)\n        print(\"{:.3f}\".format(round(ans,3)))\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "# 66\n\nfrom decimal import *\nimport heapq\n\nclass UnionFind:\n    def __init__(self, n):\n        self.rank = [1] * n\n        self.par = [int(x) for x in range(n)]\n        \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def unite(self, x, y):\n        p_x = self.find(x)\n        p_y = self.find(y)\n        if p_x == p_y:\n            return False\n        if self.rank[p_x] < self.rank[p_y]:\n            self.par[p_x] = p_y\n            self.rank[p_x] += 1\n        else:\n            self.par[p_y] = p_x\n            self.rank[p_y] += 1\n        return True\n    \n    def same(self, x, y):\n        p_x = self.find(x)\n        p_y = self.find(y)\n        if p_x == p_y:\n            return True\n        else:\n            return False\n    \nwhile True:\n    N = int(input())\n    if N == 0:\n        exit(0)\n    C_L = [[int(Decimal(x) * (10**3)) for x in input().split()] for y in range(N)]\n    \n    UF = UnionFind(N)\n    hq = []\n    for i in range(N):\n        i_x, i_y, i_z, i_r = C_L[i]\n        for j in range(i+1,N):\n            j_x, j_y, j_z, j_r = C_L[j]\n            _d = ((i_x - j_x)**2 + (i_y - j_y)**2 + (i_z - j_z)**2) ** (0.5) - i_r - j_r\n            hq.append([_d, i, j])\n#     print(hq)\n#     print(\"HOGE\")\n    ans = 0\n    heapq.heapify(hq)\n    while len(hq) > 0:\n        _d, _i, _j = heapq.heappop(hq)\n        if UF.same(_i, _j):\n            continue\n        ans += max(_d, 0)\n        UF.unite(_i, _j)\n    print(\"{:.3f}\".format(ans / (10**3)))\n\n\n"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n#\tans = 1e10\n#\tfor i in range(n):\n#\t\tfor j in range(i+1,n):\n#\t\t\tl = R(xyzr[i],xyzr[j])\n#\t\t\tif l < ans:\n#\t\t\t\tans = l\n#\t\t\t\ts = [i,j]\n\tans = 0.0\n\tchain = [xyzr.pop(0)] #[xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127\n\nfrom decimal import Decimal, getcontext\nfrom itertools import combinations\nfrom heapq import *\n\n\ngetcontext().prec = 30\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return True\n\nwhile True:\n    N = int(input())\n    if N ==0:\n        exit()\n\n    tree = UnionFind(N)\n\n    pos = dict()\n    for i in range(N):\n        pos[i] = tuple(map(Decimal, input().split()))\n\n    data = []\n\n    for a,b in combinations(range(N), 2):\n        x1,x2,x3,xr = pos[a]\n        y1,y2,y3,yr = pos[b]\n        cost = max(((x1-y1)**2 + (x2-y2)**2 + (x3-y3)**2).sqrt() -xr -yr, 0)\n        data.append((a, b, cost))\n\n    res = 0\n    data.sort(key=lambda x: x[2])\n\n    for a, b, cost in data:\n        if tree.union(a,b):\n            res += cost\n    print(\"{:.03f}\".format(res))\n"
  },
  {
    "language": "Python",
    "code": "def R(xyrz,xyrz1):\n\tx, y, z, r  = xyrz\n\tx1,y1,z1,r1 = xyrz1\n\treturn max(0,((x-x1)**2 + (y-y1)**2 + (z-z1)**2)**0.5 - r - r1)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tml = 1e12\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = R(xyzr[i],xyzr[j])\n\t\t\tif l < ml:\n\t\t\t\tml = l\n\t\t\t\ts = i\n\tans = 0.0\n\tchain = [xyzr.pop(s)]\n\twhile xyzr:\n\t\tpipe = 1e12\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\nclass UF():\n  def __init__(self, N):\n    self.parents = [-1] * (N+1)\n\n  def find(self, n):\n    if self.parents[n] < 0:\n      return n\n    else:\n      self.parents[n] = self.find(self.parents[n])\n      return self.parents[n]\n\n  def union(self, u,v):\n    p1,p2 = self.find(u),self.find(v)\n    if p1 == p2: return\n\n    if p1 > p2:\n      p1,p2 = p2,p1\n    self.parents[p1] += self.parents[p2]\n    self.parents[p2] = p1\n\n  def same(self, u, v):\n    return self.find(u) == self.find(v)\n\nans = []\nwhile True:\n  # sphere-shaped\n  n = int(input())\n  if n==0: exit()\n  C = []\n  # for _ in range(n):\n    # C.append(list(map(float,input().split())))\n  C = [[float(i) for i in input().split()] for _ in range(n)]\n\n  uf = UF(n)\n  edges = []\n  for i in range(n):\n    for j in range(i+1, n):\n      x1,y1,z1,r1 = C[i]\n      x2,y2,z2,r2 = C[j]\n      d = ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5-r1-r2\n      if d <= 0:\n        uf.union(i,j)\n      else:\n        edges.append((d,i,j))\n  edges.sort(key=lambda x: x[0])\n\n  res = 0\n  for d,u,v in edges:\n    if not uf.same(u,v):\n      uf.union(u,v)\n      res += d\n\n  print(f\"{res:.3f}\")\n"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127&lang=en\n\nfrom math import sqrt\nfrom heapq import heappush, heappop\nfrom collections import defaultdict\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1] * n\n    \n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return False\n        else:\n            if self.par[x] > self.par[y]:\n                x, y = y, x\n            self.par[x] += self.par[y]\n            self.par[y] = x\n            return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.par[self.find(x)]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.par) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n\n    X, Y, Z, R = [], [], [], []\n    for _ in range(N):\n        xi, yi, zi, ri = map(float, input().split())\n        X.append(xi)\n        Y.append(yi)\n        Z.append(zi)\n        R.append(ri)\n\n    # グラフ構造を作成？\n    # 短いやつをつなげていって，森じゃなくなったらOKかな？\n    uf = UnionFind(N)\n    cost = 0.0\n    edges = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            dx = X[i] - X[j]\n            dy = Y[i] - Y[j]\n            dz = Z[i] - Z[j]\n            dij = sqrt(dx * dx + dy * dy + dz * dz) - R[i] - R[j]\n            heappush(edges, (dij, i, j))\n\n    # Kruskal\n    while len(edges) > 0:\n        (w, u, v) = heappop(edges)\n        if uf.unite(u, v):\n            if w > 0:\n                cost += w\n    print(\"{:.3f}\".format(cost))\n\n"
  },
  {
    "language": "Python",
    "code": "from math import *\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 0.0\n\tchain = [xyzr.pop(0)]\n\twhile xyzr:\n\t\tpipe = 1e12\n\t\tfor i in range(len(xyzr)):\n\t\t\tx,y,z,r = xyzr[i]\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tx1,y1,z1,r1 = chain[j]\n\t\t\t\tl = max(0,sqrt((x-x1)**2 + (y-y1)**2 + (z-z1)**2) - r - r1)\n\t\t\t\tif l <= pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nimport heapq\n# -*- coding: utf-8 *-\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    \"\"\"\n    sizeによる実装\n    \"\"\"\n\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for _ in range(N)]\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.size[px] < self.size[py]:\n            self.parent[px] = py\n            self.size[py] += self.size[px]\n        else:\n            self.parent[py] = px\n            self.size[px] += self.size[py]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef calc_dist(s1, s2):\n    dist = sqrt(sum([abs(a-b)**2 for a, b in zip(s1[:-1], s2[:-1])]))\n    return max(dist-s1[3] - s2[3], 0)\n\n\ndef solve():\n    N = int(input())\n    if N == 0:\n        exit()\n    spheres = [list(map(float, input().split())) for _ in range(N)]\n    dists = []\n    Un = UnionFind(N)\n    for i in range(N):\n        for j in range(i+1, N):\n            tmp = calc_dist(spheres[i], spheres[j])\n            #dists.append([tmp, i, j])\n            heapq.heappush(dists, [tmp, i, j])\n\n    cost = 0\n    #dists = sorted(dists, key=lambda x: x[0])\n    for k in range(len(dists)):\n        dist, i, j = heapq.heappop(dists)\n        if Un.same(i, j):\n            continue\n        else:\n            Un.union(i, j)\n            cost += dist\n    print(\"{:.3f}\".format(cost))\n\n\nwhile True:\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nimport math\ndef set_heapq(que, edge, used, v, add_dist=0):\n    '''\n    確定地点vからつながる辺を全てqueに設定し、返却する\n\n    Parameters\n    que : heapque(touple or list)\n        辺を管理するキュー (距離、次の行き先)のtopuleまたはlistにて管理\n    edge : list\n        全ての辺を格納する二次元のリスト edge[0]にてノード0から伸びる辺であることを表し、\n        edge[0] → [距離、次の行き先] を表すlistが格納されている\n    v : int\n        グラフ上のノード ダイクストラでは確定したノードがvにあたる\n    add_dist : int\n        確定した地点に足し合わせる距離 スタート地点以外では何かしらの値が追加されることになる\n\n    Returns\n    que : heapque(touple or list)\n        引数queにvからつながる辺を追加したキュー\n    '''\n    for a,b in edge[v]:\n        if used[b]:\n            heapq.heappush(que,(a+add_dist,b))\n    return que\n\ndef prim_heap(edge, n):\n    '''\n    プリム法で最小全域木を求める\n\n    Parameters\n    edge : list\n        全ての辺を格納する二次元のリスト edge[0]にてノード0から伸びる辺であることを表し、\n        edge[0] → [距離、次の行き先] を表すlistが格納されている\n    \n    Returns\n    res : int\n        最小全域木の全ての辺のコストの総和\n    '''\n    used = [True] * n #True:不使用\n    edgelist = []\n    edgelist = set_heapq(edgelist, edge, used, 0)\n    used[0] = False\n    res = 0\n    while len(edgelist) != 0:\n        minedge = heapq.heappop(edgelist)\n        if not used[minedge[1]]:\n            continue\n        v = minedge[1]\n        used[v] = False\n        edgelist = set_heapq(edgelist, edge, used, v)\n        res += minedge[0]\n    return res\n\ndef write_file(s):\n    with open(\"tmp.txt\", \"a\") as f:\n        f.write(s+\"\\n\")\n\nwhile True:\n    N = int(input())\n    if N == 0: break\n    xyzr = [list(map(float, input().split())) for _ in range(N)]\n    edge = [[] for _ in range(N)]\n    # 全ての組み合わせを列挙して、距離を求める\n    for i in range(N):\n        for j in range(i+1,N):\n            x1,y1,z1,r1 = xyzr[i]\n            x2,y2,z2,r2 = xyzr[j]\n            dist = math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z1-z2)**2)\n            dist = max(0, dist-r1-r2)\n            edge[i].append((dist, j))\n            edge[j].append((dist, i))\n    ans = prim_heap(edge, N)\n    ans = ('{:0.3f}'.format(ans))\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def R(xyrz,xyrz1):\n\tx, y, z, r  = xyrz\n\tx1,y1,z1,r1 = xyrz1\n\treturn max(0,((x-x1)**2 + (y-y1)**2 + (z-z1)**2)**0.5 - r - r1)\n\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e12\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tl = 1#R(xyzr[i],xyzr[j])\n\t\t\tif l < ans:\n\t\t\t\tans = l\n\t\t\t\ts = [i,j]\n\tchain = [xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e12\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tl = 1#R(xyzr[i],chain[j])\n\t\t\t\tif l < pipe:\n\t\t\t\t\tpipe = l\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tif n == 1:\n\t\tprint 0.0\n\t\tcontinue\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tans = 1e10\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tL = R(xyzr[i],xyzr[j])\n\t\t\tif L < ans:\n\t\t\t\tans = L\n\t\t\t\ts = [i,j]\n\tchain = [xyzr.pop(s[1]),xyzr.pop(s[0])]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tL = R(xyzr[i],chain[j])\n\t\t\t\tif L < pipe:\n\t\t\t\t\tpipe = L\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 併合\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか判定\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n      \n      \n\nT = True\nwhile T:\n  n = int(input())\n  if n == 0:\n    quit()\n    \n  data = UnionFind(n + 1)\n  x = [0] * n\n  for i in range(n):\n    x[i] = list(map(float, input().split()))\n  p = int(n * (n - 1) / 2)\n  kumi = [0] * p\n  q = 0\n  for i in range(n):\n    one = x[i]\n    for j in range(i + 1, n):\n      two = x[j]\n      L1 = (one[0] - two[0]) ** 2 + (one[1] - two[1]) ** 2 + (one[2] - two[2]) ** 2\n      L2 = L1 ** (1 / 2) - (one[3] + two[3])\n      L2 = max(L2, 0)\n      kumi[q] = [i, j, L2]\n      q += 1\n  kumi = sorted(kumi, key = lambda x:x[2])\n  ans = 0\n  for i in range(p):\n    x, y, z = kumi[i][0], kumi[i][1], kumi[i][2]\n    if not data.same_check(x, y):\n      data.union(x, y)\n      ans += z\n  print('{:.3f}'.format(ans))\n    \n    \n    \n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "def R(xyzr1,xyzr2):\n\tx1,y1,z1,r1 = xyzr1\n\tx2,y2,z2,r2 = xyzr2\n\treturn max(0,((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5 - r1 - r2)\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\txyzr = [map(float,raw_input().split()) for i in range(n)]\n\tl = 1e10\n\ts = 0\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tL = R(xyzr[i],xyzr[j])\n\t\t\tif L < l:\n\t\t\t\tl = L\n\t\t\t\ts = i\n\tans = 0.0\n\tchain = [xyzr.pop(s)]\n\twhile xyzr:\n\t\tpipe = 1e10\n\t\tfor i in range(len(xyzr)):\n\t\t\tfor j in range(len(chain)):\n\t\t\t\tL = R(xyzr[i],chain[j])\n\t\t\t\tif L < pipe:\n\t\t\t\t\tpipe = L\n\t\t\t\t\tp = i\n\t\tans += pipe\n\t\tchain.append(xyzr.pop(p))\n\tprint ans"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[y] = x\n\nwhile 1:\n    N = int(input())\n    if N == 0:\n        exit()\n    q = []\n    ans = 0\n    S = UnionFind(N)\n    x = [None] * N\n    y = [None] * N\n    z = [None] * N\n    r = [None] * N\n\n    for i in range(N):\n        x[i], y[i], z[i], r[i] = map(float, input().split())\n\n    for i in range(N):\n        for j in range(i+1, N):\n            d = (x[i]-x[j])**2 + (y[i]-y[j])**2 + (z[i]-z[j])**2\n            d = d**0.5 - r[i] - r[j]\n            heappush(q, (max(0,d), i, j))\n    # クラスカル法\n    while len(q) > 0:\n        d, a, b = heappop(q)\n        if S.find(a) != S.find(b):\n            ans += d\n            S.union(a, b)\n    print('{:.3f}'.format(ans))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        super().__init__()\n        self.par = [i for i in range(n + 1)]\n        self.rank = [0 for i in range(n + 1)]\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            return self.root(self.par[x])\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            elif self.rank[x] > self.rank[y]:\n                self.par[y] = x\n            else:\n                self.par[x] = y\n                self.rank[y] += 1\n\n\ndef distance(cell1, cell2):\n    c_dis = 0\n    for i in range(3):\n        c_dis += (cell1[i] - cell2[i])**2\n    c_dis = c_dis**(1 / 2) - (cell1[3] + cell2[3])\n    return c_dis if c_dis > 0 else 0\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    union = UnionFind(n)\n    cell_list = [list(map(float, input().split())) for i in range(n)]\n    distance_list = []\n    for i, b_cell in enumerate(cell_list):\n        for j, cell in enumerate(cell_list[i + 1:]):\n            distance_list.append([distance(b_cell, cell), i, i + 1 + j])\n\n    distance_list.sort()\n    total_dis = 0\n    for dis in distance_list:\n        if not union.is_same(dis[1], dis[2]):\n            union.unite(dis[1], dis[2])\n            total_dis += dis[0]\n\n    print(format(total_dis, \".3f\"))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\nfrom heapq import heappop, heappush\n\ndef find(x):\n    if x == pair_lst[x]:\n        return x\n    else:\n        tmp = find(pair_lst[x])\n        pair_lst[x] = tmp\n        return tmp\nx=[]\ny=[]\nz=[]\nr=[]\ndef kr():\n    que=[]\n    for i in range(n-1):\n        for j in range(i+1,n):\n            wi=((x[i]-x[j])**2+(y[i]-y[j])**2+(z[i]-z[j])**2)**0.5\n            wi=max(0,wi-r[i]-r[j])        \n            heappush(que,(wi,i,j))\n    length_sum = 0\n    while que:\n        w, s, t = heappop(que)\n        root_s = find(s)\n        root_t = find(t)\n        if root_s != root_t:\n            pair_lst[root_s] = root_t\n            length_sum += w\n    return length_sum\n\nwhile True:\n    n=int(input())\n    x=[0.0]*n\n    y=[0.0]*n\n    z=[0.0]*n\n    r=[0.0]*n\n    pair_lst = [i for i in range(n)]\n    \n    if n==0:\n        sys.exit()\n    for i in range(n):\n        x[i],y[i],z[i],r[i]=map(float,input().split())\n    print(\"{:.3f}\".format(kr()))\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n\nuse std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cmp::*;\n\nstruct Scanner<I: Iterator<Item = char>> {\n    iter: std::iter::Peekable<I>,\n}\n\nmacro_rules! exit {\n    () => {{\n        exit!(0)\n    }};\n    ($code:expr) => {{\n        if cfg!(local) {\n            writeln!(std::io::stderr(), \"===== Terminated =====\")\n                .expect(\"failed printing to stderr\");\n        }\n        std::process::exit($code);\n    }}\n}\n\nimpl<I: Iterator<Item = char>> Scanner<I> {\n    pub fn new(iter: I) -> Scanner<I> {\n        Scanner {\n            iter: iter.peekable(),\n        }\n    }\n\n    pub fn safe_get_token(&mut self) -> Option<String> {\n        let token = self.iter\n            .by_ref()\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        if token.is_empty() {\n            None\n        } else {\n            Some(token)\n        }\n    }\n\n    pub fn token(&mut self) -> String {\n        self.safe_get_token().unwrap_or_else(|| exit!())\n    }\n\n    pub fn get<T: FromStr>(&mut self) -> T {\n        self.token().parse::<T>().unwrap_or_else(|_| exit!())\n    }\n\n    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.get()).collect()\n    }\n\n    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n\n    pub fn char(&mut self) -> char {\n        self.iter.next().unwrap_or_else(|| exit!())\n    }\n\n    pub fn chars(&mut self) -> Vec<char> {\n        self.get::<String>().chars().collect()\n    }\n\n    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {\n        (0..row).map(|_| self.chars()).collect()\n    }\n\n    pub fn line(&mut self) -> String {\n        if self.peek().is_some() {\n            self.iter\n                .by_ref()\n                .take_while(|&c| !(c == '\\n' || c == '\\r'))\n                .collect::<String>()\n        } else {\n            exit!();\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<&char> {\n        self.iter.peek()\n    }\n}\n\nuse std::cmp::Ordering;\n\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[derive(PartialEq)]\nstruct MinFloat(f64);\n\nimpl Eq for MinFloat {}\n\nimpl PartialOrd for MinFloat {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl Ord for MinFloat {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.0.partial_cmp(&self.0).unwrap()\n    }\n}\n\nuse std::mem::swap;\n\nstruct UnionFind {\n    parents: Vec<i64>,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> UnionFind {\n        UnionFind { parents: vec![-1; n] }\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut px = self.root(x);\n        let mut py = self.root(y);\n        if px == py {\n            return;\n        }\n        if self.parents[x] < self.parents[y] {\n            swap(&mut px, &mut py);\n        }\n        self.parents[px] += self.parents[py];\n        self.parents[py] = px as i64;\n    }\n    fn root(&mut self, x: usize) -> usize {\n        let px = self.parents[x];\n        if px < 0 {\n            return x;\n        }\n        self.parents[x] = self.root(px as usize) as i64;\n        self.parents[x] as usize\n    }\n    fn same(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n    fn size(&mut self, x: usize) -> usize {\n        let px = self.root(x);\n        -self.parents[px as usize] as usize\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));\n    loop {\n        let N: usize = sc.get();\n        if N == 0 {\n            break;\n        }\n        let mut cell = Vec::new();\n        for _ in 0..N {\n            let x: f64 = sc.get();\n            let y: f64 = sc.get();\n            let z: f64 = sc.get();\n            let r: f64 = sc.get();\n            cell.push((x, y, z, r))\n        }\n        let mut bh = BinaryHeap::new();\n        for i in 0..N-1 {\n            for j in i+1..N {\n                let (x1, y1, z1, r1) = cell[i];\n                let (x2, y2, z2, r2) = cell[j];\n                let d = ((x2 - x1).powf(2.) + (y2 - y1).powf(2.) + (z2 - z1).powf(2.)).sqrt(); \n                bh.push((min(MinFloat(0.), MinFloat(d - (r1 + r2))), i, j));\n            }\n        }\n        let mut ans = 0.;\n        let mut uf = UnionFind::new(N);\n        while let Some((MinFloat(dist), i, j)) = bh.pop() {\n            if !uf.same(i, j) {\n                uf.unite(i, j);\n                ans += dist;\n            }\n        }\n        println!(\"{:.3}\", ans);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split(' ').map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Point {\n    x: f64, y: f64, z: f64\n}\nimpl Point {\n    fn distance(&self, other: &Point) -> f64 {\n        let dx = self.x - other.x;\n        let dy = self.y - other.y;\n        let dz = self.z - other.z;\n        (dx * dx + dy * dy + dz * dz).sqrt()\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Circle {\n    center: Point, radius: f64\n}\nimpl Circle {\n    fn corridor_length(&self, other: &Circle) -> f64 {\n        let len = self.center.distance(&other.center) - self.radius - other.radius;\n        if len > 0f64 {\n            len\n        }else {\n            0f64\n        }\n    }\n}\n#[derive(Clone, Debug)]\nstruct UnionFind {\n    vec: Vec<i32>\n}\nimpl UnionFind {\n    fn new(size: usize) -> UnionFind {\n        UnionFind{vec: vec![-1; size]}\n    }\n    fn find(&mut self, a: usize) -> usize {\n        if self.vec[a] < 0 {\n            a\n        }else {\n            let parent = self.vec[a] as usize;\n            let root = self.find(parent);\n            self.vec[a] = root as i32;\n            root\n        }\n    }\n    fn same(&mut self, a: usize, b: usize) -> bool {\n        self.find(a) == self.find(b)\n    }\n    fn unite(&mut self, mut a: usize, mut b: usize) {\n        a = self.find(a);\n        b = self.find(b);\n        if a != b {\n            if self.vec[a] < self.vec[b] {\n                self.vec[a] += self.vec[b];\n                self.vec[b] = a as i32;\n            }else {\n                self.vec[b] += self.vec[a];\n                self.vec[a] = b as i32;\n            }\n        }\n    }\n}\n\nfn main() {\n    loop {\n        read!(n: usize);\n        if n == 0 {break;}\n        read_map!(balls: [{\n            read!(x: f64, y: f64, z: f64, r: f64);\n            Circle{center: Point{x: x, y: y, z: z}, radius: r}\n        }; n]);\n        let mut uft = UnionFind::new(n);\n        let mut edges = Vec::new();\n        for i in 0 .. n {\n            for j in 0 .. i {\n                let len = balls[i].corridor_length(&balls[j]);\n                if len == 0f64 {\n                    uft.unite(i, j);\n                }else {\n                    edges.push((i, j, len));\n                }\n            }\n        }\n        edges.sort_by(|a, b| a.2.partial_cmp(&b.2).unwrap());\n        let mut result = 0f64;\n        for (i, j, len) in edges {\n            if !uft.same(i, j) {\n                result += len;\n                uft.unite(i, j);\n            }\n        }\n        println!(\"{:.*}\", 3, result);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::*;\nuse std::io::Read;\nuse std::collections::{BTreeMap, BinaryHeap};\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[derive(PartialEq, PartialOrd, Copy, Clone)]\npub struct Total<T>(pub T);\n\nimpl<T: PartialEq> Eq for Total<T> {}\n\nimpl<T: PartialOrd> Ord for Total<T> {\n    fn cmp(&self, other: &Total<T>) -> Ordering {\n        self.0.partial_cmp(&other.0).unwrap()\n    }\n}\n\nfn prim<T: Ord + Copy>(g: &[BTreeMap<usize, T>]) -> Vec<(usize, usize, T)> {\n    let nv = g.len();\n    let v = 0;\n    let mut vis = vec![false; nv];\n    vis[v] = true;\n    let mut h = g[v].iter().map(|(&t, &w)| Reverse((w, v, t))).collect::<BinaryHeap<_>>();\n    let mut e = Vec::new();\n    while let Some(Reverse((w, s, t))) = h.pop() {\n        if vis[s] && !vis[t] {\n            e.push((s, t, w));\n            vis[t] = true;\n            for (&u, &w) in g[t].iter() {\n                if !vis[u] {\n                    h.push(Reverse((w, t, u)));\n                }\n            }\n        }\n    }\n    e\n}\n\ntype Sphere = (f64, f64, f64, f64);\n\nfn corridor_cost(s1: &Sphere, s2: &Sphere) -> f64 {\n    let dx = s1.0 - s2.0;\n    let dy = s1.1 - s2.1;\n    let dz = s1.2 - s2.2;\n    let dist = (dx * dx + dy * dy + dz * dz).sqrt();\n    (dist - (s1.3 + s2.3)).max(0.0)\n}\n\nfn solve(n: usize, s: &[Sphere]) -> f64 {\n    let mut g = vec![BTreeMap::new(); n];\n    for i in 0..n {\n        for j in 0..i {\n            let c = corridor_cost(&s[j], &s[i]);\n            g[j].insert(i, Total(c));\n            g[i].insert(j, Total(c));\n        }\n    }\n    let e = prim(&g);\n    e.iter().map(|&(_, _, c)| c.0).sum::<f64>()\n}\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).unwrap();\n    let mut iter = buf.split_whitespace();\n    loop {\n        let n: usize = iter.next().unwrap().parse().unwrap();\n        if n == 0 {\n            break;\n        }\n        let s = (0..n)\n            .map(|_| {\n                let x: f64 = iter.next().unwrap().parse().unwrap();\n                let y: f64 = iter.next().unwrap().parse().unwrap();\n                let z: f64 = iter.next().unwrap().parse().unwrap();\n                let r: f64 = iter.next().unwrap().parse().unwrap();\n                (x, y, z, r)\n            })\n            .collect::<Vec<_>>();\n        let w = solve(n, &s);\n        println!(\"{:.3}\", w);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    loop {\n        let n = read::<usize>();\n        if n == 0 {\n            return;\n        }\n        let mut cells = vec![];\n        for i in 0..n {\n            let v = read_vec::<f64>();\n            let (x, y, z, r) = (v[0], v[1], v[2], v[3]);\n            cells.push((x, y, z, r));\n        }\n        let mut edges = vec![];\n        for i in 0..n {\n            let (x1, y1, z1, r1) = cells[i];\n            for j in i + 1..n {\n                let (x2, y2, z2, r2) = cells[j];\n                let dist =\n                    ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2)).sqrt();\n                if dist <= r1 + r2 {\n                    edges.push(Edge {\n                        from: i,\n                        to: j,\n                        cost: 0.0,\n                    });\n                } else {\n                    edges.push(Edge {\n                        from: i,\n                        to: j,\n                        cost: dist - r1 - r2,\n                    });\n                }\n            }\n        }\n        println!(\"{:.3}\", kruskal(&edges, n));\n    }\n}\n\nconst INF: f64 = 100000000.0;\n\nuse std::cmp::Ordering;\n\n#[derive(Debug, Clone)]\nstruct Edge {\n    from: usize,\n    to: usize,\n    cost: f64,\n}\n\nimpl PartialEq for Edge {\n    fn eq(&self, other: &Edge) -> bool {\n        self.cost == other.cost\n    }\n}\n\nimpl Eq for Edge {}\n\nimpl Ord for Edge {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.cost.partial_cmp(&other.cost).unwrap()\n    }\n}\n\nimpl PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Edge) -> Option<Ordering> {\n        Some(self.cost.partial_cmp(&other.cost).unwrap())\n    }\n}\n\nstruct UnionFindTree {\n    parent_or_size: Vec<isize>,\n}\n\nimpl UnionFindTree {\n    fn new(size: usize) -> UnionFindTree {\n        UnionFindTree {\n            parent_or_size: vec![-1; size],\n        }\n    }\n\n    fn find(&self, index: usize) -> usize {\n        let mut index = index;\n        while self.parent_or_size[index] >= 0 {\n            index = self.parent_or_size[index] as usize;\n        }\n        index\n    }\n\n    fn same(&self, x: usize, y: usize) -> bool {\n        self.find(x) == self.find(y)\n    }\n\n    fn unite(&mut self, index0: usize, index1: usize) -> bool {\n        let a = self.find(index0);\n        let b = self.find(index1);\n        if a == b {\n            false\n        } else {\n            if self.parent_or_size[a] < self.parent_or_size[b] {\n                self.parent_or_size[a] += self.parent_or_size[b];\n                self.parent_or_size[b] = a as isize;\n            } else {\n                self.parent_or_size[b] += self.parent_or_size[a];\n                self.parent_or_size[a] = b as isize;\n            }\n            true\n        }\n    }\n}\n\nfn kruskal(edges: &Vec<Edge>, num_apexes: usize) -> f64 {\n    let mut edges = edges.clone();\n    let mut res = 0.0;\n    edges.sort();\n    let mut unf = UnionFindTree::new(num_apexes);\n    for e in edges {\n        if !unf.same(e.to, e.from) {\n            unf.unite(e.to, e.from);\n            res += e.cost;\n        }\n    }\n    res\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n"
  }
]