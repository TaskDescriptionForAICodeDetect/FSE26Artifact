[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x, y, z, r;\n} Cell;\n\ndouble distance(Cell a, Cell b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    double dz = a.z - b.z;\n    return sqrt(dx*dx + dy*dy + dz*dz);\n}\n\ndouble min_corridor_length(Cell cells[], int n) {\n    double total = 0.0;\n    int *visited = (int *)calloc(n, sizeof(int));\n    double *min_dist = (double *)malloc(n * sizeof(double));\n    \n    for (int i = 0; i < n; i++) {\n        min_dist[i] = INFINITY;\n    }\n    min_dist[0] = 0.0;\n    \n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] && (u == -1 || min_dist[j] < min_dist[u])) {\n                u = j;\n            }\n        }\n        \n        if (min_dist[u] == INFINITY) {\n            break;\n        }\n        \n        visited[u] = 1;\n        total += min_dist[u];\n        \n        for (int v = 0; v < n; v++) {\n            if (!visited[v]) {\n                double d = distance(cells[u], cells[v]) - cells[u].r - cells[v].r;\n                if (d < 0) d = 0;\n                if (d < min_dist[v]) {\n                    min_dist[v] = d;\n                }\n            }\n        }\n    }\n    \n    free(visited);\n    free(min_dist);\n    return total;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Cell *cells = (Cell *)malloc(n * sizeof(Cell));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n    }\n    \n    double result = min_corridor_length(cells, n);\n    printf(\"%.3lf\\n\", result);\n    \n    free(cells);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass SpaceStationCorridor {\n    static class Cell {\n        double x, y, z, radius;\n        \n        Cell(double x, double y, double z, double radius) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.radius = radius;\n        }\n    }\n    \n    static class Edge implements Comparable<Edge> {\n        int src, dest;\n        double weight;\n        \n        Edge(int src, int dest, double weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Double.compare(this.weight, other.weight);\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    static double distance(Cell c1, Cell c2) {\n        double dx = c1.x - c2.x;\n        double dy = c1.y - c2.y;\n        double dz = c1.z - c2.z;\n        \n        double centerDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);\n        return Math.max(0, centerDistance - c1.radius - c2.radius);\n    }\n    \n    static double minimumCorridorLength(List<Cell> cells) {\n        int n = cells.size();\n        List<Edge> edges = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dist = distance(cells.get(i), cells.get(j));\n                edges.add(new Edge(i, j, dist));\n            }\n        }\n        \n        Collections.sort(edges);\n        \n        UnionFind uf = new UnionFind(n);\n        double totalLength = 0;\n        \n        for (Edge edge : edges) {\n            if (uf.find(edge.src) != uf.find(edge.dest)) {\n                uf.union(edge.src, edge.dest);\n                totalLength += edge.weight;\n            }\n        }\n        \n        return totalLength;\n    }\n    \n    public static void main(String[] args) {\n        List<Cell> cells = new ArrayList<>();\n        cells.add(new Cell(0, 0, 0, 5));\n        cells.add(new Cell(10, 0, 0, 3));\n        cells.add(new Cell(5, 5, 5, 4));\n        \n        double result = minimumCorridorLength(cells);\n        System.out.printf(\"Minimum Corridor Length: %.2f%n\", result);\n    }\n}",
    "timestamp": "2025-08-05 19:05:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y, z;\n    Point(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}\n};\n\ndouble distance(const Point& a, const Point& b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    double dz = a.z - b.z;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\ndouble computeMinDistance(const Point& p1, double r1, const Point& p2, double r2) {\n    double d = distance(p1, p2);\n    if (d <= r1 + r2) {\n        return 0.0;\n    } else {\n        return d - r1 - r2;\n    }\n}\n\ndouble primMST(const vector<vector<double>>& graph) {\n    int n = graph.size();\n    vector<double> key(n, numeric_limits<double>::max());\n    vector<bool> inMST(n, false);\n    key[0] = 0;\n    double total = 0.0;\n\n    for (int count = 0; count < n; ++count) {\n        int u = -1;\n        for (int i = 0; i < n; ++i) {\n            if (!inMST[i] && (u == -1 || key[i] < key[u])) {\n                u = i;\n            }\n        }\n        inMST[u] = true;\n        total += key[u];\n\n        for (int v = 0; v < n; ++v) {\n            if (graph[u][v] < key[v] && !inMST[v]) {\n                key[v] = graph[u][v];\n            }\n        }\n    }\n    return total;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> centers(n);\n    vector<double> radii(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> centers[i].x >> centers[i].y >> centers[i].z >> radii[i];\n    }\n\n    vector<vector<double>> graph(n, vector<double>(n, 0.0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dist = computeMinDistance(centers[i], radii[i], centers[j], radii[j]);\n            graph[i][j] = dist;\n            graph[j][i] = dist;\n        }\n    }\n\n    double totalLength = primMST(graph);\n    cout.precision(10);\n    cout << fixed << totalLength << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y, z, radius;\n} Cell;\n\ndouble distance_between_cells(Cell *c1, Cell *c2) {\n    double dx = c1->x - c2->x;\n    double dy = c1->y - c2->y;\n    double dz = c1->z - c2->z;\n    double center_distance = sqrt(dx*dx + dy*dy + dz*dz);\n    double corridor_length = center_distance - c1->radius - c2->radius;\n    return corridor_length > 0 ? corridor_length : 0;\n}\n\ndouble prim_mst(Cell *cells, int n) {\n    double total_corridor_length = 0;\n    int *connected = calloc(n, sizeof(int));\n    double *min_distance = malloc(n * sizeof(double));\n    \n    for (int i = 0; i < n; i++) {\n        min_distance[i] = DBL_MAX;\n    }\n    \n    connected[0] = 1;\n    min_distance[0] = 0;\n    \n    for (int count = 1; count < n; count++) {\n        double min_dist = DBL_MAX;\n        int min_index = -1;\n        \n        for (int v = 0; v < n; v++) {\n            if (!connected[v]) {\n                double curr_min_dist = DBL_MAX;\n                for (int u = 0; u < n; u++) {\n                    if (connected[u]) {\n                        double dist = distance_between_cells(&cells[u], &cells[v]);\n                        curr_min_dist = fmin(curr_min_dist, dist);\n                    }\n                }\n                \n                if (curr_min_dist < min_dist) {\n                    min_dist = curr_min_dist;\n                    min_index = v;\n                }\n            }\n        }\n        \n        connected[min_index] = 1;\n        total_corridor_length += min_dist;\n    }\n    \n    free(connected);\n    free(min_distance);\n    \n    return total_corridor_length;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Cell *cells = malloc(n * sizeof(Cell));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].radius);\n    }\n    \n    double result = prim_mst(cells, n);\n    printf(\"%.2f\\n\", result);\n    \n    free(cells);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n#include <queue>\n\nusing namespace std;\n\nstruct Cell {\n    double x, y, z, radius;\n};\n\ndouble distance(const Cell& a, const Cell& b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    double dz = a.z - b.z;\n    return sqrt(dx*dx + dy*dy + dz*dz);\n}\n\ndouble calculateCost(const Cell& a, const Cell& b) {\n    double dist = distance(a, b);\n    double minDist = max(0.0, dist - a.radius - b.radius);\n    return minDist;\n}\n\ndouble minimumCorridor(vector<Cell>& cells) {\n    int n = cells.size();\n    vector<vector<double>> graph(n, vector<double>(n, numeric_limits<double>::max()));\n    \n    for (int i = 0; i < n; i++) {\n        graph[i][i] = 0;\n        for (int j = i + 1; j < n; j++) {\n            graph[i][j] = graph[j][i] = calculateCost(cells[i], cells[j]);\n        }\n    }\n    \n    vector<bool> visited(n, false);\n    vector<double> minCost(n, numeric_limits<double>::max());\n    minCost[0] = 0;\n    \n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    pq.push({0, 0});\n    \n    double totalCost = 0;\n    \n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        \n        if (visited[u]) continue;\n        visited[u] = true;\n        totalCost += minCost[u];\n        \n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] < minCost[v]) {\n                minCost[v] = graph[u][v];\n                pq.push({minCost[v], v});\n            }\n        }\n    }\n    \n    return totalCost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Cell> cells(n);\n    for (int i = 0; i < n; i++) {\n        cin >> cells[i].x >> cells[i].y >> cells[i].z >> cells[i].radius;\n    }\n    \n    cout << fixed << setprecision(2) << minimumCorridor(cells) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Cell {\n    double x, y, z, r;\n\n    Cell(double x, double y, double z, double r) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.r = r;\n    }\n}\n\npublic class SpaceStationCorridors {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Cell[] cells = new Cell[n];\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            double z = scanner.nextDouble();\n            double r = scanner.nextDouble();\n            cells[i] = new Cell(x, y, z, r);\n        }\n\n        double[][] graph = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    graph[i][j] = 0;\n                } else {\n                    double dx = cells[i].x - cells[j].x;\n                    double dy = cells[i].y - cells[j].y;\n                    double dz = cells[i].z - cells[j].z;\n                    double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    double corridor = Math.max(0, distance - cells[i].r - cells[j].r);\n                    graph[i][j] = corridor;\n                }\n            }\n        }\n\n        double totalLength = primMST(graph, n);\n        System.out.printf(\"%.3f\\n\", totalLength);\n    }\n\n    private static double primMST(double[][] graph, int n) {\n        double[] key = new double[n];\n        boolean[] mstSet = new boolean[n];\n        Arrays.fill(key, Double.MAX_VALUE);\n        key[0] = 0;\n        double total = 0;\n\n        for (int count = 0; count < n; count++) {\n            int u = -1;\n            for (int i = 0; i < n; i++) {\n                if (!mstSet[i] && (u == -1 || key[i] < key[u])) {\n                    u = i;\n                }\n            }\n            mstSet[u] = true;\n            total += key[u];\n\n            for (int v = 0; v < n; v++) {\n                if (!mstSet[v] && graph[u][v] < key[v]) {\n                    key[v] = graph[u][v];\n                }\n            }\n        }\n        return total;\n    }\n}",
    "timestamp": "2025-08-05 19:06:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\nclass Cell:\n    def __init__(self, x, y, z, radius):\n        self.x = x\n        self.y = y\n        self.z = z\n        self.radius = radius\n\ndef distance(cell1, cell2):\n    return math.sqrt((cell1.x - cell2.x) ** 2 + (cell1.y - cell2.y) ** 2 + (cell1.z - cell2.z) ** 2)\n\ndef corridor_length(cell1, cell2):\n    d = distance(cell1, cell2)\n    r1 = cell1.radius\n    r2 = cell2.radius\n    return d - r1 - r2 if d > r1 + r2 else 0\n\ndef compute_total_length(cells):\n    n = len(cells)\n    total_length = 0\n    covered = set()\n    distances = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = corridor_length(cells[i], cells[j])\n            distances.append((dist, i, j))\n\n    distances.sort()\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootY] = rootX\n            return True\n        return False\n    \n    parent = [i for i in range(n)]\n    \n    for dist, i, j in distances:\n        if union(i, j):\n            total_length += dist\n\n    return total_length\n\n# Example Usage:\ncells_info = [\n    (0, 0, 0, 1),\n    (3, 0, 0, 1),\n    (0, 4, 0, 1),\n    (0, 0, 5, 1)\n]\n\ncells = [Cell(x, y, z, r) for x, y, z, r in cells_info]\nprint(compute_total_length(cells))",
    "timestamp": "2025-08-13 02:27:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class SpaceStationCorridors {\n    static class Sphere {\n        double x, y, z, r;\n\n        Sphere(double x, double y, double z, double r) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.r = r;\n        }\n\n        double distanceTo(Sphere other) {\n            double dx = this.x - other.x;\n            double dy = this.y - other.y;\n            double dz = this.z - other.z;\n            return Math.max(0, Point2D.distance(dx, dy, dz) - (this.r + other.r));\n        }\n    }\n\n    static class Edge implements Comparable<Edge> {\n        int u, v;\n        double length;\n\n        Edge(int u, int v, double length) {\n            this.u = u;\n            this.v = v;\n            this.length = length;\n        }\n\n        @Override\n        public int compareTo(Edge other) {\n            return Double.compare(this.length, other.length);\n        }\n    }\n\n    public static double findShortestCorridorLength(List<Sphere> spheres) {\n        int n = spheres.size();\n        PriorityQueue<Edge> edges = new PriorityQueue<>();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double dist = spheres.get(i).distanceTo(spheres.get(j));\n                edges.add(new Edge(i, j, dist));\n            }\n        }\n\n        UnionFind uf = new UnionFind(n);\n        double totalLength = 0;\n\n        while (!edges.isEmpty()) {\n            Edge edge = edges.poll();\n            if (uf.find(edge.u) != uf.find(edge.v)) {\n                uf.union(edge.u, edge.v);\n                totalLength += edge.length;\n            }\n        }\n\n        return totalLength;\n    }\n\n    public static void main(String[] args) {\n        List<Sphere> spheres = Arrays.asList(\n            new Sphere(0, 0, 0, 1),\n            new Sphere(2, 0, 0, 1),\n            new Sphere(1, 1, 1, 1)\n        );\n        \n        double result = findShortestCorridorLength(spheres);\n        System.out.println(\"Shortest corridor length: \" + result);\n    }\n    \n    static class UnionFind {\n        private int[] parent, rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]); // Path compression\n            }\n            return parent[u];\n        }\n\n        public void union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU != rootV) {\n                if (rank[rootU] > rank[rootV]) {\n                    parent[rootV] = rootU;\n                } else if (rank[rootU] < rank[rootV]) {\n                    parent[rootU] = rootV;\n                } else {\n                    parent[rootV] = rootU;\n                    rank[rootU]++;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 02:27:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y, z, r;\n} Cell;\n\ntypedef struct {\n    int u, v;\n    double length;\n} Edge;\n\nint compareEdges(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    if (edgeA->length < edgeB->length) return -1;\n    if (edgeA->length > edgeB->length) return 1;\n    return 0;\n}\n\nint findParent(int node, int *parent) {\n    if (parent[node] != node) {\n        parent[node] = findParent(parent[node], parent);\n    }\n    return parent[node];\n}\n\nvoid unionNodes(int a, int b, int *parent, int *rank) {\n    int rootA = findParent(a, parent);\n    int rootB = findParent(b, parent);\n    if (rootA != rootB) {\n        if (rank[rootA] > rank[rootB]) {\n            parent[rootB] = rootA;\n        } else if (rank[rootA] < rank[rootB]) {\n            parent[rootA] = rootB;\n        } else {\n            parent[rootB] = rootA;\n            rank[rootA]++;\n        }\n    }\n}\n\ndouble calculateDistance(Cell a, Cell b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    double dz = a.z - b.z;\n    return fmax(0.0, sqrt(dx * dx + dy * dy + dz * dz) - a.r - b.r);\n}\n\ndouble minimumCorridorLength(Cell *cells, int n) {\n    int edgesCount = n * (n - 1) / 2;\n    Edge *edges = malloc(sizeof(Edge) * edgesCount);\n    int index = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            edges[index].u = i;\n            edges[index].v = j;\n            edges[index].length = calculateDistance(cells[i], cells[j]);\n            index++;\n        }\n    }\n\n    qsort(edges, edgesCount, sizeof(Edge), compareEdges);\n\n    int *parent = malloc(n * sizeof(int));\n    int *rank = malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    double totalLength = 0.0;\n    int count = 0;\n    for (int i = 0; i < edgesCount && count < n - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        if (findParent(u, parent) != findParent(v, parent)) {\n            unionNodes(u, v, parent, rank);\n            totalLength += edges[i].length;\n            count++;\n        }\n    }\n\n    free(edges);\n    free(parent);\n    free(rank);\n    return totalLength;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Cell *cells = malloc(n * sizeof(Cell));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf %lf\", &cells[i].x, &cells[i].y, &cells[i].z, &cells[i].r);\n    }\n\n    printf(\"%.6lf\\n\", minimumCorridorLength(cells, n));\n    free(cells);\n    return 0;\n}",
    "timestamp": "2025-08-13 02:28:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef distance_between_spheres(sphere1, sphere2):\n    x1, y1, z1, r1 = sphere1\n    x2, y2, z2, r2 = sphere2\n    center_distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)\n    \n    if center_distance <= r1 + r2:\n        return 0\n    else:\n        return center_distance - r1 - r2\n\ndef kruskal_mst(spheres):\n    n = len(spheres)\n    edges = []\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            dist = distance_between_spheres(spheres[i], spheres[j])\n            edges.append((dist, i, j))\n    \n    edges.sort()\n    \n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        parent[find(x)] = find(y)\n    \n    total_length = 0\n    for dist, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            total_length += dist\n    \n    return total_length\n\ndef main():\n    n = int(input())\n    spheres = []\n    \n    for _ in range(n):\n        x, y, z, r = map(float, input().split())\n        spheres.append((x, y, z, r))\n    \n    print(f\"{kruskal_mst(spheres):.2f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:28:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n\ndef find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef minimal_corridor_length(cells):\n    n = len(cells)\n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1, z1, r1 = cells[i]\n            x2, y2, z2, r2 = cells[j]\n            d = distance((x1, y1, z1), (x2, y2, z2))\n            corridor = max(0, d - r1 - r2)\n            edges.append((corridor, i, j))\n    \n    edges.sort()\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    total_length = 0.0\n    \n    for edge in edges:\n        corridor, u, v = edge\n        uroot = find(parent, u)\n        vroot = find(parent, v)\n        if uroot != vroot:\n            total_length += corridor\n            union(parent, rank, uroot, vroot)\n    \n    return total_length",
    "timestamp": "2025-08-13 02:28:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstruct Sphere {\n    double x, y, z, r;\n};\n\ndouble distance(const Sphere &a, const Sphere &b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    double dz = a.z - b.z;\n    return std::sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nstruct Edge {\n    int u, v;\n    double weight;\n};\n\nclass DisjointSet {\npublic:\n    DisjointSet(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n\n    int find(int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    }\n\n    bool unionSets(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU == rootV)\n            return false;\n        if (rank[rootU] > rank[rootV])\n            parent[rootV] = rootU;\n        else if (rank[rootU] < rank[rootV])\n            parent[rootU] = rootV;\n        else {\n            parent[rootV] = rootU;\n            ++rank[rootU];\n        }\n        return true;\n    }\n\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank;\n};\n\ndouble minimumCorridorLength(std::vector<Sphere> &spheres) {\n    int n = spheres.size();\n    std::vector<Edge> edges;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double d = std::max(0.0, distance(spheres[i], spheres[j]) - (spheres[i].r + spheres[j].r));\n            edges.push_back({i, j, d});\n        }\n    }\n\n    std::sort(edges.begin(), edges.end(), [](const Edge &a, const Edge &b) {\n        return a.weight < b.weight;\n    });\n\n    DisjointSet ds(n);\n    double totalLength = 0.0;\n\n    for (const auto &edge : edges) {\n        if (ds.unionSets(edge.u, edge.v)) {\n            totalLength += edge.weight;\n        }\n    }\n    \n    return totalLength;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Sphere> spheres(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> spheres[i].x >> spheres[i].y >> spheres[i].z >> spheres[i].r;\n    }\n\n    std::cout.precision(10);\n    std::cout << minimumCorridorLength(spheres) << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:07"
  }
]