[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val t = readLine.trim.toInt\n  for (_ ← 0 until t){\n    val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n    val boards = readLine.trim.split(' ').map(parseSound)\n    val melodies = readLine.trim.split(' ').map(parseSound)\n    println(\n      if (canMake(boards, melodies)) \"Yes\"\n      else \"No\"\n    )\n  }\n  def parseSound(str: String): Int = {\n    List(\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\").indexOf(str)\n  }\n\n  def canMake(boards: Array[Int], melodies: Array[Int]): Boolean = {\n    @tailrec\n    def sub(position: Int, reversedMelodies: List[Int]): Boolean = {\n      reversedMelodies match {\n        case Nil if position == -1 ⇒ true\n        case Nil ⇒ false\n        case _ if !boards.indices.contains(position) ⇒ false\n        case h::t if (h + 1) % 12 == boards(position) ⇒ sub(position + 1, t)\n        case h::t if h == boards(position) ⇒ sub(position - 1, t)\n        case h::t if (h + 11) % 12 == boards(position) ⇒ sub(position - 2, t)\n        case _ ⇒ false\n      }\n    }\n    val reversed = melodies.reverse.toList\n    sub(boards.length - 1, reversed) || sub(boards.length - 2, reversed)\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    unordered_set<int> used[50001];    \n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      if(s && used[s-1].size()) used[s-1].clear();\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n\n      //if ( used[s].count(t) ) continue;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif ( used[s+1].count(t-1) ) continue;\n\tq.push(Pii(s+1, t-1));\n\tused[s+1].insert(t-1);\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif ( used[s+1].count(t+1) ) continue;\n\tq.push(Pii(s+1, t+1));\n\tused[s+1].insert(t+1);\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif ( used[s+1].count(t+2) ) continue;\n\tq.push(Pii(s+1, t+2));\n\tused[s+1].insert(t+2);\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  int stair_pos;\n  int note_pos;\n  int cost;\n  State(int stair_pos,int note_pos,int cost) :\n    stair_pos(stair_pos),note_pos(note_pos), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nmap<string,int> note2idx;\nstring idx2note[] = {\n  \"C\",\n  \"C#\",\n  \"D\",\n  \"D#\",\n  \"E\",\n  \"F\",\n  \"F#\",\n  \"G\",\n  \"G#\",\n  \"A\",\n  \"A#\",\n  \"B\"\n};\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      map<int,bool> dp[50001];\n\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<string> stair;\n      vector<string> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note);\n      }\n\n      priority_queue<State,vector<State>,greater<State> > que;\n      que.push(State(-1,-1,0));\n\n      bool isok = false;\n      while(!que.empty()){\n        State s = que.top();\n        que.pop();\n\n        if(s.note_pos == song_length - 1\n           && s.stair_pos >= num_of_steps - 2){\n          isok = true;\n          break;\n        }\n        else if(s.note_pos == song_length - 1){\n          continue;\n        }\n\n        for(int dist = -1; dist <= 2; dist++){\n          if(dist == 0) continue;\n\n          int next = s.stair_pos + dist;\n          if(next < 0) continue;\n          if(next >= num_of_steps) continue;\n\n          int offset = 0;\n          if(dist == -1) offset = 12 - 1;\n          if(dist == 2) offset = 1;\n          if(song[s.note_pos + 1] != idx2note[(note2idx[stair[next]] + offset) % 12]) continue;\n          if(dp[s.note_pos + 1].find(next) != dp[s.note_pos + 1].end()) continue;\n          dp[s.note_pos + 1][next] = true;\n          que.push(State(next,s.note_pos + 1,s.cost + 1));\n        }\n      }\n      printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MOD 12\ntypedef vector<int> Vec;\n \nint N,M;\n \nbool rec(int idxT,int idxS,Vec &T,Vec &S){\n    if(idxT == N && idxS == M) return 1;\n    if(idxT == N || idxS == M) return 0;\n    bool res = false;\n    if(idxT+1 <= N && T[idxT] == S[idxS]){\n        res |= rec(idxT+1,idxS+1,T,S);\n    }\n    if(idxT+2 <= N && (T[idxT]+1)%MOD == S[idxS]){\n        res |= rec(idxT+2,idxS+1,T,S);\n    }\n    if(idxT-1 >= 0 && (T[idxT]-1+MOD)%MOD == S[idxS]){\n        res |= rec(idxT-1,idxS+1,T,S);\n    }\n    return res;\n}\n \nint main(){\n    int Tc;\n    map<string,int> mp = {\n        {\"A\",0},{\"A#\",1},\n        {\"B\",2},\n        {\"C\",3},{\"C#\",4},\n        {\"D\",5},{\"D#\",6},\n        {\"E\",7},\n        {\"F\",8},{\"F#\",9},\n        {\"G\",10},{\"G#\",11},\n    };\n    string in;\n    cin >> Tc;\n    while(Tc--){\n        cin >> N >> M;\n        Vec T(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            T[i] = mp[in];\n        }\n        reverse(T.begin(),T.end());\n        Vec S(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> in;\n            S[i] = mp[in];\n        }\n        reverse(S.begin(),S.end());\n        bool can = rec(0,0,T,S) | rec(1,0,T,S);\n        cout << (can ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint t[50010];\nint s[50010];\nset<pair<int,int> > memo;\n\nint n,m;\n\n#define OTO(x,y) (((x) + 12 + (y)) % 12)\n\nbool dfs(int i, int j){\n  if(i >= n-1 && j == m) return true;\n  if(j == m) return false;\n  int next = s[j];\n\n  if(memo.count(make_pair(i,j)) != 0) return false;\n  memo.insert(make_pair(i,j));\n\n  if(t[i+1] == next && dfs(i+1,j+1)) return true;\n  if(i+2 <= n && OTO(t[i+2],1) == next && dfs(i+2,j+1)) return true;\n  if(i > 1 && OTO(t[i-1],-1) == next && dfs(i-1,j+1)) return true;\n\n  return false;\n}\n\nint main(){\n  int cc;\n  map<string,int> mp;\n  mp[\"C\" ] = 0; mp[\"C#\"] = 1;\n  mp[\"D\" ] = 2; mp[\"D#\"] = 3;\n  mp[\"E\" ] = 4;\n  mp[\"F\" ] = 5; mp[\"F#\"] = 6;\n  mp[\"G\" ] = 7; mp[\"G#\"] = 8;\n  mp[\"A\" ] = 9; mp[\"A#\"] = 10;\n  mp[\"B\" ] = 11;\n\n  scanf(\"%d\",&cc);\n\n  while( cc --> 0 ){\n    char buff[8];\n\n    memo.clear();\n    scanf(\"%d%d\",&n,&m);\n\n    REP(i,n){\n      scanf(\"%s\",buff);\n      t[i+1] = mp[buff];\n    }\n    REP(i,m){\n      scanf(\"%s\",buff);\n      s[i] = mp[buff];\n    }\n\n    puts(dfs(0,0) ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint key[]={0,2,3,5,7,8,10};\nchar in[5];\nint p[110000];\nint q[110000];\nint n;\nint solve(int a,int b){\n\tif(a<0&&b==-1)return 1;\n\tif(a<0)return 0;\n\tif(b<0)return 0;\n\tif(b>=n)return 0;\n\tif(p[b]==q[a])return solve(a-1,b-1);\n\tif((p[b]+1)%12==q[a])return solve(a-1,b-2);\n\tif((p[b]+11)%12==q[a])return solve(a-1,b+1);\n\treturn 0;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tp[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')p[i]++;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tq[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')q[i]++;\n\t\t}\n\t\tif(solve(b-1,a-1))printf(\"Yes\\n\");\n\t\telse if(solve(b-1,a-2))printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nstring S[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\nint N, M, SLEN = 12;\nmap<string, int> strtoi;\nvector<int> v, vv;\nbool f;\n\nbool check(int now, int pls, int tar){\n  int m = v[now + pls];\n  if(pls == 2) ++m;\n  if(pls == -1) --m;\n  m = (m + SLEN) % SLEN;\n  return m == tar;\n}\n\nvoid dfs(int now, int cnt){\n  if(f) return ;\n  if(cnt >= M){\n    if((N + 1) - now > 2) return ;\n    f = 1;\n  } else{\n    FOR(pls, -1, 3){\n      if(now + pls <= 0 || now + pls > N + 1) continue;\n      if(check(now, pls, vv[cnt])) dfs(now + pls, cnt + 1);\n    }\n  }\n}\n\n\nint main() {\n  REP(i, SLEN) strtoi[S[i]] = i;\n  int T; cin >>T;\n  while(T--){\n    cin >>N >>M;\n    f = false;\n    v = vector<int>(N + 1);\n    vv = vector<int>(M);\n    FOR(i, 1, N + 1){\n      string s; cin >>s;\n      v[i] = strtoi[s];\n    }\n    REP(i, M){\n      string s; cin >>s;\n      vv[i] = strtoi[s];\n    }\n    dfs(0, 0);\n    cout <<(f ? \"Yes\" : \"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint key[]={0,2,3,5,7,8,10};\nchar in[5];\nint p[110000];\nint q[110000];\n\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tp[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')p[i]++;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tq[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')q[i]++;\n\t\t}\n\t\tset<int>now;\n\t\tif(p[0]==q[0])now.insert(0);\n\t\tif((p[1]+1)%12==q[0])now.insert(1);\n\t\tfor(int i=1;i<b;i++){\n\t\t\tset<int>to;\n\t\t\tfor(set<int>::iterator it=now.begin();it!=now.end();it++){\n\t\t\t\tint at=*it;\n\t\t\t\tif(at+(b-i)*2<a)continue;\n\t\t\t\tif(at<a-1&&p[at+1]==q[i])to.insert(at+1);\n\t\t\t\tif(at<a-2&&(p[at+2]+1)%12==q[i])to.insert(at+2);\n\t\t\t\tif(at&&(p[at-1]+11)%12==q[i])to.insert(at-1);\n\t\t\t}\n\t\t\tnow=to;\n\t\t}\n\t\tif(now.count(a-2)||now.count(a-1))printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nmap<string, string> MakeUpSound();\nmap<string, string> MakeDownSound();\nvector<string> InputVector(int);\nbool MusicStairs(const vector<string>, const vector<string>, \n\t\t map<string, string>, map<string, string>, int, int);\n\nint main(){\n  int i, j, k, n, m;\n  map<string, string> up, down;\n  vector<string> stairs, music;\n\n  up = MakeUpSound();\n  down = MakeDownSound();\n  cin >> k;\n\n  for(i=0; i<k; ++i){\n    cin >> n >> m;\n    stairs = InputVector(n);\n    music = InputVector(m);\n\n    if(MusicStairs(stairs, music, up, down, -1, 0))\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}\n\nmap<string, string> MakeUpSound(){\n  map<string, string> data;\n  data.insert(make_pair(\"C\", \"C#\"));\n  data.insert(make_pair(\"C#\", \"D\"));\n  data.insert(make_pair(\"D\", \"D#\"));\n  data.insert(make_pair(\"D#\", \"E\"));\n  data.insert(make_pair(\"E\", \"F\"));\n  data.insert(make_pair(\"F\", \"F#\"));\n  data.insert(make_pair(\"F#\", \"G\"));\n  data.insert(make_pair(\"G\", \"G#\"));\n  data.insert(make_pair(\"G#\", \"A\"));\n  data.insert(make_pair(\"A\", \"A#\"));\n  data.insert(make_pair(\"A#\", \"B\"));\n  data.insert(make_pair(\"B\", \"C\"));\n  return data;\n}\n\nmap<string, string> MakeDownSound(){\n  map<string, string> data;\n  data.insert(make_pair(\"C\", \"B\"));\n  data.insert(make_pair(\"C#\", \"C\"));\n  data.insert(make_pair(\"D\", \"C#\"));\n  data.insert(make_pair(\"D#\", \"D\"));\n  data.insert(make_pair(\"E\", \"D#\"));\n  data.insert(make_pair(\"F\", \"E\"));\n  data.insert(make_pair(\"F#\", \"F\"));\n  data.insert(make_pair(\"G\", \"F#\"));\n  data.insert(make_pair(\"G#\", \"G\"));\n  data.insert(make_pair(\"A\", \"G#\"));\n  data.insert(make_pair(\"A#\", \"A\"));\n  data.insert(make_pair(\"B\", \"A#\"));\n  return data;\n}\n\nvector<string> InputVector(int n){\n  int i;\n  string str;\n  vector<string> data;\n  for(i=0; i<n; ++i){\n    cin >> str;\n    data.push_back(str);\n  }\n  return data;\n}\n\nbool MusicStairs(const vector<string> stairs, const vector<string> music, \n\t\t map<string, string> up, map<string, string> down, int n, int m){\n  if(m == music.size()){\n    if(n+2 >= stairs.size()) return true;\n    else return false;\n  }\n  if(n+1 < stairs.size() && stairs[n+1] == music[m] &&\n     MusicStairs(stairs, music, up, down, n+1, m+1)) return true;\n  if(n+2 < stairs.size() && up[stairs[n+2]] == music[m] &&\n     MusicStairs(stairs, music, up, down, n+2, m+1)) return true;\n  if(n-1 >= 0 && down[stairs[n-1]] == music[m] &&\n     MusicStairs(stairs, music, up, down, n-1, m+1)) return true;\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\tfor(int i=0;i<a.size();i++)\n\t\tos<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& a){\n\tos<<'{';\n\tfor(typename map<T1,T2>::const_iterator i=a.begin();i!=a.end();++i)\n\t\tos<<(i==a.begin()?\"\":\" \")<<i->first<<\"=>\"<<i->second;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tstring i2s[]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"}; // index => scale\n\tmap<string,int> s2i; // scale => index\n\tfor(int i=0;i<12;i++)\n\t\ts2i[i2s[i]]=i;\n\t\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tint n,m; cin>>n>>m;\n\t\tvector<int> stair(n),song(m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tstair[i]=s2i[s];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tsong[i]=s2i[s];\n\t\t}\n\t\t\n\t\tbool ok=false;\n\t\tqueue<pair<int,int>> q;\n\t\tq.emplace(n-1,m-1);\n\t\tq.emplace(n-2,m-1);\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> cur=q.front(); q.pop();\n\t\t\tint ci=cur.first,cj=cur.second;\n\t\t\t\n\t\t\tif(ci==-1 && cj==-1){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ci<=-1 || cj==-1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint diff=song[cj]-stair[ci];\n\t\t\tif(diff==11) diff=-1;\n\t\t\tif(diff==-11) diff=1;\n\t\t\tif(abs(diff)>1) continue;\n\t\t\t\n\t\t\tswitch(diff){\n\t\t\tcase -1: q.emplace(ci+1,cj-1); break;\n\t\t\tcase  0: q.emplace(ci-1,cj-1); break;\n\t\t\tcase  1: q.emplace(ci-2,cj-1); break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nint st[LIM+1], me[LIM+1];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(num > M) return false;\n    if(pos >= N) return num == M;\n    if((M - num) * 2 + pos < N) return false;\n    if(me[num] == st[pos]) return dfs(pos+1, num+1);\n    if((me[num] - st[pos] + 12) % 12 == 1) return dfs(pos+2, num+1);\n    if(pos > 0 && (me[num] - st[pos] + 12) % 12 == 11) return dfs(pos-1, num+1);\n    return false;\n}\n\nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        string str;\n        for(int x = 0; x < N; x++){\n            cin >> str;\n            st[x] = tone[str];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> str;\n            me[x] = tone[str];\n        }\n        reverse(st, st+N);\n        reverse(me, me+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint input(){\n  char str[10];\n  scanf(\"%s\",str);\n  \n  if(str[0]=='B'){\n    return 11;\n  }\n  \n  if(str[0]=='A'){\n    if(str[1]=='#')return 10;\n    return 9;\n  }\n\n  if(str[0]=='G'){\n    if(str[1]=='#')return 8;\n    return 7;\n  }\n  \n  if(str[0]=='F'){\n    if(str[1]=='#')return 6;\n    return 5;\n  }\n\n  if(str[0]=='E'){\n    return 4;\n  }\n\n  if(str[0]=='D'){\n    if(str[1]=='#')return 3;\n    return 2;\n  }\n  \n  if(str[0]=='C'){\n    if(str[1]=='#')return 1;\n    return 0;\n  }\n\n  assert(0);\n  return -1;\n}\n\nint n,m;\nint t[50005];\nint u[50005];\n\nmap< int ,bool > vd[50005];\n\nint dfs(int depth,int pos){\n  if(depth==m&&n<pos+2)return 1;\n  \n  if(vd[depth][pos])return 0;\n  vd[depth][pos]=1;\n\n  if( pos + (m-depth+1)*2 < n )return 0;\n  \n  if( 1<=pos-1  && (t[pos-1]+11)%12 == u[depth] ){\n    if( dfs( depth+1, pos-1 ) ) return 1;\n  }\n\n  if( pos+1 <= n && t[pos+1]==u[depth] ){\n    if( dfs(depth+1,pos+1) )return 1;\n  }\n\n  if( pos+2 <= n && (t[pos+2]+1)%11==u[depth] ){\n    if( dfs(depth+1,pos+2) )return 1;\n  }\n\n  return 0;\n}\n\nint main(){\n  int Tc;\n  scanf(\"%d\",&Tc);\n  while(Tc--){\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)t[i]=input();\n    for(int i=0;i<m;i++)u[i]=input();\n    \n    for(int i=0;i<=n+1;i++)vd[i].clear();\n    int ans=dfs(0,0);\n    if(ans)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\tfor(int i=0;i<a.size();i++)\n\t\tos<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& a){\n\tos<<'{';\n\tfor(typename map<T1,T2>::const_iterator i=a.begin();i!=a.end();++i)\n\t\tos<<(i==a.begin()?\"\":\" \")<<i->first<<\"=>\"<<i->second;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tstring i2s[]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"}; // index => scale\n\tmap<string,int> s2i; // scale => index\n\tfor(int i=0;i<12;i++)\n\t\ts2i[i2s[i]]=i;\n\t\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tint n,m; cin>>n>>m;\n\t\tvector<int> stair(n),song(m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tstair[i]=s2i[s];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tsong[i]=s2i[s];\n\t\t}\n\t\t\n\t\tbool ok=false;\n\t\tqueue<pair<int,int>> q;\n\t\tq.emplace(n-1,m-1);\n\t\tq.emplace(n-2,m-1);\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> cur=q.front(); q.pop();\n\t\t\tint ci=cur.first,cj=cur.second;\n\t\t\t\n\t\t\tif(ci==-1 && cj==-1){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ci<=-1 || cj==-1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint diff=song[cj]-stair[ci];\n\t\t\tif(diff==11) diff=-1;\n\t\t\tif(abs(diff)>1) continue;\n\t\t\t\n\t\t\tswitch(diff){\n\t\t\tcase -1: q.emplace(ci+1,cj-1); break;\n\t\t\tcase  0: q.emplace(ci-1,cj-1); break;\n\t\t\tcase  1: q.emplace(ci-2,cj-1); break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst map<string, int> NOTE_NUMS = {\n    {\"C\", 0},\n    {\"C#\", 1},\n    {\"D\", 2},\n    {\"D#\", 3},\n    {\"E\", 4},\n    {\"F\", 5},\n    {\"F#\", 6},\n    {\"G\", 7},\n    {\"G#\", 8},\n    {\"A\", 9},\n    {\"A#\", 10},\n    {\"B\", 11},\n};\n\nvector<int> steps;\nvector<int> song;\nbool result;\n\nvector<string> split(const string &s, char delim) {\n    vector<string> elems;\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, delim)) {\n    if (!item.empty()) {\n            elems.push_back(item);\n        }\n    }\n    return elems;\n}\n\nvoid canPlay(long stepPos, long songPos){\n    if(result){\n        return;\n    }\n\n    if(songPos == song.size()){\n        if(steps.size() - stepPos < 3){\n            result = true;\n        }\n        return;\n    }\n\n    if( 0 <= stepPos + 1 && stepPos + 1 < steps.size()){\n        if(steps[stepPos + 1] == song[songPos]){\n            canPlay(stepPos + 1, songPos + 1);\n        }\n    }\n\n    if( 0 <= stepPos + 2 && stepPos + 2 < steps.size()){\n        if((steps[stepPos + 2] + 1) % 12 == song[songPos]){\n            canPlay(stepPos + 2, songPos + 1);\n        }\n    }\n\n    if( 0 <= stepPos - 1 && stepPos - 1 < steps.size()){\n        if((steps[stepPos - 1] + 11) % 12 == song[songPos]){\n            canPlay(stepPos - 1, songPos + 1);\n        }\n    }\n}\n\nint main(){\n    string n;\n    getline(cin, n);\n    int q = stoi(n);\n    for(int i = 0; i < q; ++i){\n        string x, stepsLine, songLine;\n        getline(cin, x);\n        getline(cin, stepsLine);\n        getline(cin, songLine);\n        auto stepsStr = split(stepsLine, ' ');\n        auto songStr = split(songLine, ' ');\n\n        steps.clear();\n        for(auto it = stepsStr.begin(); it != stepsStr.end(); ++it){\n            steps.push_back(NOTE_NUMS.at(*it));\n        }\n\n        song.clear();\n        for(auto it = songStr.begin(); it != songStr.end(); ++it){\n            song.push_back(NOTE_NUMS.at(*it));\n        }\n\n        result = false;\n        canPlay(-1, 0);\n        cout << (result ? \"Yes\": \"No\") << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nmap<string,int> sound;\nint n,m;\nint stairs[50001];\nint song[50001];\n\nbool simulate(int s){\n\tfor(int i=0;i<m;i++){\n\t\tif(i==m-1){\n\t\t\tint ns=s-1;\n\t\t\tif(ns==-1&&(stairs[s]+sound.size())%sound.size()==song[m-1-i]){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tns=s-2;\n\t\t\tif(ns==-1&&(stairs[s]+1+sound.size())%sound.size()==song[m-1-i]){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tint ns=s+1;\n\t\tif(ns<n&&ns>=0&&(stairs[s]-1+sound.size())%sound.size()==song[m-1-i]){\n\t\t\ts=ns;\n\t\t\tcontinue;\n\t\t}\n\t\tns=s-1;\n\t\tif(ns<n&&ns>=0&&(stairs[s]+sound.size())%sound.size()==song[m-1-i]){\n\t\t\ts=ns;\n\t\t\tcontinue;\n\t\t}\n\t\tns=s-2;\n\t\tif(ns<n&&ns>=0&&(stairs[s]+1+sound.size())%sound.size()==song[m-1-i]){\n\t\t\ts=ns;\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tsound[\"C\"]=0;\n\tsound[\"C#\"]=1;\n\tsound[\"D\"]=2;\n\tsound[\"D#\"]=3;\n\tsound[\"E\"]=4;\n\tsound[\"F\"]=5;\n\tsound[\"F#\"]=6;\n\tsound[\"G\"]=7;\n\tsound[\"G#\"]=8;\n\tsound[\"A\"]=9;\n\tsound[\"A#\"]=10;\n\tsound[\"B\"]=11;\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstairs[i]=sound[s];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong[i]=sound[s];\n\t\t}\n\t\tif(simulate(n-1)||simulate(n-2))cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n \nconst int LIM = 50000;\n \nmap<string, int> tone;\n \nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n \nstring stair[LIM+1], melody[LIM+1];\nint S, N, M;\n \nbool dfs(int pos, int num){\n    if(num > M) return false;\n    if(pos >= N) return num == M;\n    if((M - num) * 2 + pos < N) return false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        if(dfs(pos+1, num+1)) return true;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        if(dfs(pos+2, num+1)) return true;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        if(dfs(pos-1, num+1)) return true;\n    }\n    return false;\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair + N);\n        reverse(melody, melody + M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nmap<string, string> MakeUpSound();\nmap<string, string> MakeDownSound();\nvector<string> InputVector(int);\nbool MusicStairs(int, int);\n\nmap<string, string> up, down;\nvector<string> stairs, music;\n\nint main(){\n  int i, j, k, n, m;\n\n  up = MakeUpSound();\n  down = MakeDownSound();\n  cin >> k;\n\n  for(i=0; i<k; ++i){\n    cin >> n >> m;\n    stairs = InputVector(n);\n    music = InputVector(m);\n\n    if(MusicStairs(-1, 0)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}\n\nmap<string, string> MakeUpSound(){\n  map<string, string> data;\n  data.insert(make_pair(\"C\", \"C#\"));\n  data.insert(make_pair(\"C#\", \"D\"));\n  data.insert(make_pair(\"D\", \"D#\"));\n  data.insert(make_pair(\"D#\", \"E\"));\n  data.insert(make_pair(\"E\", \"F\"));\n  data.insert(make_pair(\"F\", \"F#\"));\n  data.insert(make_pair(\"F#\", \"G\"));\n  data.insert(make_pair(\"G\", \"G#\"));\n  data.insert(make_pair(\"G#\", \"A\"));\n  data.insert(make_pair(\"A\", \"A#\"));\n  data.insert(make_pair(\"A#\", \"B\"));\n  data.insert(make_pair(\"B\", \"C\"));\n  return data;\n}\n\nmap<string, string> MakeDownSound(){\n  map<string, string> data;\n  data.insert(make_pair(\"C\", \"B\"));\n  data.insert(make_pair(\"C#\", \"C\"));\n  data.insert(make_pair(\"D\", \"C#\"));\n  data.insert(make_pair(\"D#\", \"D\"));\n  data.insert(make_pair(\"E\", \"D#\"));\n  data.insert(make_pair(\"F\", \"E\"));\n  data.insert(make_pair(\"F#\", \"F\"));\n  data.insert(make_pair(\"G\", \"F#\"));\n  data.insert(make_pair(\"G#\", \"G\"));\n  data.insert(make_pair(\"A\", \"G#\"));\n  data.insert(make_pair(\"A#\", \"A\"));\n  data.insert(make_pair(\"B\", \"A#\"));\n  return data;\n}\n\nvector<string> InputVector(int n){\n  int i;\n  string str;\n  vector<string> data;\n  for(i=0; i<n; ++i){\n    cin >> str;\n    data.push_back(str);\n  }\n  return data;\n}\n\nbool MusicStairs(int n, int m){\n  if(m == music.size()){\n    if(n+2 >= stairs.size()) return true;\n    else return false;\n  }\n  if(n+1 < stairs.size() && stairs[n+1] == music[m] &&\n     MusicStairs(n+1, m+1)) return true;\n  if(n+2 < stairs.size() && up[stairs[n+2]] == music[m] &&\n     MusicStairs(n+2, m+1)) return true;\n  if(n-1 >= 0 && down[stairs[n-1]] == music[m] &&\n     MusicStairs(n-1, m+1)) return true;\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    string T[50001], S[50001];\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    map<int, int> used[50001];\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n\n      if ( used[s][t] ) continue;\n      used[s][t] = true;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n\n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tq.push(Pii(s+1, t-1));\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tq.push(Pii(s+1, t+1));\t\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\t\n\tq.push(Pii(s+1, t+2));\t\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 500001\n\nusing namespace std;\n\nmap<string,int> getIndex;\nint t,s;\nbool found;\nint T[MAX],S[MAX];\nstring type[12] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\nint dc[] = {+0,+1,-1};\nint dx[] = {-1,-2,+1};\n\nvoid dfs(int cur_t,int cur_s)\n{\n  if(cur_s < 0)\n    {\n      if(cur_t == -1)found = true;\n      return;\n    }\n\n  rep(i,3)\n    {\n      int music = (T[cur_t] + dc[i] + 12)%12;\n      if(t <= cur_t+dx[i])continue;\n\n      if(music == S[cur_s])\n\t{\n\t  dfs(cur_t+dx[i],cur_s-1);\n\t}\n    }\n}\n\nbool compute()\n{\n  found = false;\n  dfs(t-1,s-1);\n  dfs(t-2,s-1);\n  return found;\n}\n\nint main()\n{\n  rep(i,12)getIndex[type[i]] = i;\n  int N;\n  while(cin >> N)\n    {\n      while(N--)\n\t{\n\n\t  cin >> t >> s;\n\t  string input;\n\t  rep(i,t)\n\t    {\n\t      cin >> input;\n\t      T[i] = getIndex[input];\n\t    }\n\t  rep(i,s)\n\t    {\n\t      cin >> input;\n\t      S[i] = getIndex[input];\n\t    }\n\t  \n\t  cout << (compute()?\"Yes\":\"No\") << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint key[]={0,2,3,5,7,8,10};\nchar in[5];\nint p[110000];\nint q[110000];\n\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tp[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')p[i]++;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tq[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')q[i]++;\n\t\t}\n\t\tset<int>now;\n\t\tif(p[0]==q[0])now.insert(0);\n\t\tif((p[1]+1)%12==q[0])now.insert(1);\n\t\tfor(int i=1;i<b;i++){\n\t\t\tset<int>to;\n\t\t\tfor(set<int>::iterator it=now.begin();it!=now.end();it++){\n\t\t\t\tint at=*it;\n\t\t\t\tif(at<a-1&&p[at+1]==q[i])to.insert(at+1);\n\t\t\t\tif(at<a-2&&(p[at+2]+1)%12==q[i])to.insert(at+2);\n\t\t\t\tif(at&&(p[at-1]+11)%12==q[i])to.insert(at-1);\n\t\t\t}\n\t\t\tnow=to;\n\t\t}\n\t\tif(now.count(a-2)||now.count(a-1))printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconst unordered_map<string, int> sounds{\n\t{\"C\", 0},\n\t{\"C#\", 1},\n\t{\"D\", 2},\n\t{\"D#\", 3},\n\t{\"E\", 4},\n\t{\"F\", 5},\n\t{\"F#\", 6},\n\t{\"G\", 7},\n\t{\"G#\", 8},\n\t{\"A\", 9},\n\t{\"A#\", 10},\n\t{\"B\", 11}};\n\nconst int NUM = sounds.size();\n\nint input() {\n\tstring s;\n\tcin >> s;\n\treturn sounds.at(s);\n}\n\nbool solve() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> stairs(n), music(m);\n\tfor(auto &e : stairs) e = input();\n\tfor(auto &e : music)  e = input();\n\n\tfor(int last = n - 2; last < n; ++last) {\n\t\tint pos = last;\n\t\tfor(int i = m - 1; i >= 0; --i) {\n\t\t\tif(pos < 0 || pos >= n) goto next;\n\n\t\t\tswitch((music[i] - stairs[pos] + NUM) % NUM) {\n\t\t\tcase  0:\n\t\t\t\tpos -= 1;\n\t\t\t\tbreak;\n\t\t\tcase  1:\n\t\t\t\tpos -= 2;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tpos += 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tif(pos == -1) return true;\n\tnext:;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) cout << (solve() ? \"Yes\" : \"No\") << endl;;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct edge{int to,sound;};\n\nint f(string s){\n\tif(s==\"C\")return 0;\n\tif(s==\"C#\")return 1;\n\tif(s==\"D\")return 2;\n\tif(s==\"D#\")return 3;\n\tif(s==\"E\")return 4;\n\tif(s==\"F\")return 5;\n\tif(s==\"F#\")return 6;\n\tif(s==\"G\")return 7;\n\tif(s==\"G#\")return 8;\n\tif(s==\"A\")return 9;\n\tif(s==\"A#\")return 10;\n\tif(s==\"B\")return 11;\n\treturn -1;\n}\n\nbool isSame(vector<int> &a, vector<int> &b){\n\trep(i,a.size()){\n\t\tif(a[i]!=b[i+1])return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tint input;\n\tcin>>input;\n\trep(loop,input){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tvector<int> step,song;\n\t\tstep.pb(-1);\t//1-index???????????????\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstep.pb(f(s));\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong.pb(f(s));\n\t\t}\n\t\tsong.pb(-1);\t//????????????????°???????????????????\n\t\t\n\t\tvector<edge> G[50010];\n\t\trep(i,n)  G[i].pb( edge{(int)i+1,step[i+1]} );\n\t\trep(i,n)  G[i+1].pb( edge{(int)i,(step[i]-1+12)%12} );\n\t\trep(i,n-1)G[i].pb( edge{(int)i+2,(step[i+2]+1)%12} );\n\t\tG[n].pb(edge{n+1,-1});\n\t\tG[n-1].pb(edge{n+2,-1});\n\t\t\n\t\tbool f=true;\n\t\t\n\t\tqueue<pair<int,vector<int>>> que;\n\t\tque.push(make_pair(0,vector<int>(0)));\n\t\twhile(!que.empty()){\n\t\t\tint pos = que.front().first;\n\t\t\tvector<int> sounds = que.front().second;\n\t\t\tint num = sounds.size();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(num==m+1){\n\t\t\t\tif(sounds == song){\n\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e = G[pos][i];\n//\t\t\t\tcout<<\":\"<<pos<<\" \"<<e.to<<\" \"<<e.sound<<endl;\n\t\t\t\tif(e.sound == song[num]){\t//?\n\t\t\t\t\tsounds.pb(e.sound);\n//\t\t\t\t\trep(j,sounds.size())cout<<sounds[j]<<\" \";cout<<endl;\n\t\t\t\t\tque.push(make_pair(e.to,sounds));\n\t\t\t\t\tsounds.erase(sounds.end()-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  int stair_pos;\n  int note_pos;\n  int cost;\n  State(int stair_pos,int note_pos,int cost) :\n    stair_pos(stair_pos),note_pos(note_pos), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nmap<string,int> note2idx;\nstring idx2note[] = {\n  \"C\",\n  \"C#\",\n  \"D\",\n  \"D#\",\n  \"E\",\n  \"F\",\n  \"F#\",\n  \"G\",\n  \"G#\",\n  \"A\",\n  \"A#\",\n  \"B\"\n};\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      map<int,bool> dp[50001];\n\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      priority_queue<State,vector<State>,greater<State> > que;\n      que.push(State(-1,-1,0));\n\n      bool isok = false;\n\n      const int idx2dist[] = {-1,1,2};\n      while(!que.empty()){\n        State s = que.top();\n        que.pop();\n\n        if(s.note_pos == song_length - 1\n           && s.stair_pos >= num_of_steps - 2){\n          isok = true;\n          break;\n        }\n        else if(s.note_pos == song_length - 1){\n          continue;\n        }\n\n        for(int i = 0; i < 3; i++){\n          int dist = idx2dist[i];\n\n          int next = s.stair_pos + dist;\n          if(next < 0) continue;\n          if(next >= num_of_steps) continue;\n\n          int offset = 0;\n          if(dist == -1) offset = 12 - 1;\n          if(dist == 2) offset = 1;\n          if(song[s.note_pos + 1] != (stair[next] + offset) % 12) continue;\n          // if(dp[s.note_pos + 1].find(next) != dp[s.note_pos + 1].end()) continue;\n          // dp[s.note_pos + 1][next] = true;\n          que.push(State(next,s.note_pos + 1,s.cost + 1));\n        }\n      }\n      printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int t;\n  cin>>t;\n  while(t--){\n    int n,m;\n    cin>>n>>m;\n    int s[50002];\n    string sn[]={\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n    for(int i=1;i<=n;i++){\n      string ss;\n      cin>>ss;\n      s[i]=find(sn,sn+12,ss)-sn;\n    }\n    set<int> st[2];\n    st[0].insert(0);\n    for(int i=0;i<m;i++){\n      st[!(i&1)].clear();\n      string ssn;\n      cin>>ssn;\n      int sd=find(sn,sn+12,ssn)-sn;\n      for(set<int>::iterator it=st[i&1].begin();it!=st[i&1].end();it++){\n\tint step[]={1,2,-1};\n\tint d[]={0,1,11};\n\tfor(int j=0;j<3;j++){\n\t  int nx=*it+step[j];\n\t  if(max(0,n-1-(m-i)*2)<nx&&nx<=n&&(s[nx]+d[j])%12==sd){\n\t    st[!(i&1)].insert(nx);\n\t  }\n\t}\n      }\n    }\n    cout<<((st[m&1].count(n)||st[m&1].count(n-1))?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint t[50010];\nint s[50010];\n\nint n,m;\n\n#define OTO(x,y) (((x) + 12 + (y)) % 12)\n\nbool dfs(int i, int j){\n  //printf(\"dfs(%d,%d) n=%d, m=%d\\n\",i,j,n,m);\n  if(i >= n-1 && j == m) return true;\n  if(j == m) return false;\n  int next = s[j];\n\n  if(t[i+1] == next && dfs(i+1,j+1)) return true;\n  if(i+2 <= n && OTO(t[i+2],1) == next && dfs(i+2,j+1)) return true;\n  if(i > 1 && OTO(t[i-1],-1) == next && dfs(i-1,j+1)) return true;\n\n  return false;\n}\n\nint main(){\n  int cc;\n  map<string,int> mp;\n  mp[\"C\" ] = 0; mp[\"C#\"] = 1;\n  mp[\"D\" ] = 2; mp[\"D#\"] = 3;\n  mp[\"E\" ] = 4;\n  mp[\"F\" ] = 5; mp[\"F#\"] = 6;\n  mp[\"G\" ] = 7; mp[\"G#\"] = 8;\n  mp[\"A\" ] = 9; mp[\"A#\"] = 10;\n  mp[\"B\" ] = 11;\n\n  scanf(\"%d\",&cc);\n\n  while( cc --> 0 ){\n    char buff[8];\n\n    scanf(\"%d%d\",&n,&m);\n\n    REP(i,n){\n      scanf(\"%s\",buff);\n      t[i+1] = mp[buff];\n    }\n    REP(i,m){\n      scanf(\"%s\",buff);\n      s[i] = mp[buff];\n    }\n\n    puts(dfs(0,0) ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        vector<int> cache(n, 0);\n        vector<bool> half(n, false);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(1, -1));\n\n        while(!q.empty()) {\n            int to_play = -q.top().first+1;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m/2) {\n                half[pos] = true;\n                //cout << pos << endl;\n                continue;\n            }\n\n            if(pos-1 >= 0) {\n                if((stairs[pos-1]+11)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos-1]) {\n                        cache[pos-1] = to_play+1;\n                        q.push(make_pair(-to_play, pos-1));\n                    }\n                }\n            }\n            if(pos+2 < n) {\n                if((stairs[pos+2]+1)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos+2]) {\n                        cache[pos+2] = to_play+1;\n                        q.push(make_pair(-to_play, pos+2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if(stairs[pos+1] == music[to_play]) {\n                    if(to_play+1 > cache[pos+1]) {\n                        cache[pos+1] = to_play+1;\n                        q.push(make_pair(-to_play, pos+1));\n                    }\n                }\n            }\n        }\n\n        fill(cache.begin(), cache.end(), INT_MAX);\n        q.push(make_pair(m-1, n-1));\n        q.push(make_pair(m-1, n-2));\n        bool ok = false;\n        while(!q.empty()) {\n            int to_play = q.top().first;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m/2-1) {\n                //cout << pos << endl;\n                if(half[pos])  {\n                    ok = true;\n                    break;\n                }\n                else continue;\n            }\n            if(pos-1 >= 0) {\n                if(stairs[pos] == music[to_play]) {\n                    if(to_play-1 < cache[pos]) {\n                        cache[pos] = to_play-1;\n                        q.push(make_pair(to_play-1, pos-1));\n                    }\n                }\n            }\n            if(pos-2 >= 0) {\n                if((stairs[pos]+1)%12 == music[to_play]) {\n                    if(to_play-1 < cache[pos]) {\n                        cache[pos] = to_play-1;\n                        q.push(make_pair(to_play-1, pos-2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if((stairs[pos]+11)%12 == music[to_play]) {\n                    if(to_play-1 < cache[pos]) {\n                        cache[pos] = to_play-1;\n                        q.push(make_pair(to_play-1, pos+1));\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nmap<string, string> MakeUpSound();\nmap<string, string> MakeDownSound();\nvoid InputVector(int, vector<string>&);\nbool MusicStairs(int, int);\n\nmap<string, string> up, down;\nvector<string> stairs, music;\n\nint main(){\n  int i, j, k, n, m;\n\n  up = MakeUpSound();\n  down = MakeDownSound();\n  cin >> k;\n\n  for(i=0; i<k; ++i){\n    cin >> n >> m;\n    InputVector(n, stairs);\n    InputVector(m, music);\n\n    if(MusicStairs(-1, 0)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    stairs.clear();\n    music.clear();\n  }\n  return 0;\n}\n\nmap<string, string> MakeUpSound(){\n  map<string, string> data;\n  data.insert(make_pair(\"C\", \"C#\"));\n  data.insert(make_pair(\"C#\", \"D\"));\n  data.insert(make_pair(\"D\", \"D#\"));\n  data.insert(make_pair(\"D#\", \"E\"));\n  data.insert(make_pair(\"E\", \"F\"));\n  data.insert(make_pair(\"F\", \"F#\"));\n  data.insert(make_pair(\"F#\", \"G\"));\n  data.insert(make_pair(\"G\", \"G#\"));\n  data.insert(make_pair(\"G#\", \"A\"));\n  data.insert(make_pair(\"A\", \"A#\"));\n  data.insert(make_pair(\"A#\", \"B\"));\n  data.insert(make_pair(\"B\", \"C\"));\n  return data;\n}\n\nmap<string, string> MakeDownSound(){\n  map<string, string> data;\n  data.insert(make_pair(\"C\", \"B\"));\n  data.insert(make_pair(\"C#\", \"C\"));\n  data.insert(make_pair(\"D\", \"C#\"));\n  data.insert(make_pair(\"D#\", \"D\"));\n  data.insert(make_pair(\"E\", \"D#\"));\n  data.insert(make_pair(\"F\", \"E\"));\n  data.insert(make_pair(\"F#\", \"F\"));\n  data.insert(make_pair(\"G\", \"F#\"));\n  data.insert(make_pair(\"G#\", \"G\"));\n  data.insert(make_pair(\"A\", \"G#\"));\n  data.insert(make_pair(\"A#\", \"A\"));\n  data.insert(make_pair(\"B\", \"A#\"));\n  return data;\n}\n\nvoid InputVector(int n, vector<string>& data){\n  int i;\n  string str;\n  for(i=0; i<n; ++i){\n    cin >> str;\n    data.push_back(str);\n  }\n}\n\nbool MusicStairs(int n, int m){\n  if(m == music.size()){\n    if(n+2 >= stairs.size()) return true;\n    else return false;\n  }\n  if(n+1 < stairs.size() && stairs[n+1] == music[m] &&\n     MusicStairs(n+1, m+1)) return true;\n  if(n+2 < stairs.size() && up[stairs[n+2]] == music[m] &&\n     MusicStairs(n+2, m+1)) return true;\n  if(n-1 >= 0 && down[stairs[n-1]] == music[m] &&\n     MusicStairs(n-1, m+1)) return true;\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,m,t[50000],s[50000];\n\nint tonum(char *buf)\n{\n\tint so[256];\n\tso['C']=0; so['D']=2; so['E']=4;\n\tso['F']=5; so['G']=7; so['A']=9;\n\tso['B']=11;\n\t\n\treturn so[buf[0]]+(buf[1]=='#');\n}\n\nbool dfs(int cur,int step)\n{\n\tif(n+1-cur>2*(m-step+1))\n\t{\n\t\t//dbg(cur),dbg(step);\n\t\treturn 0;\n\t}\n\t\n\tif(step==m)\n\t{\n\t\tif(cur+1==n+1||cur+2==n+1)return 1;\n\t\treturn 0;\n\t}\n\t\n\tbool ret=0;\n\tif(cur+1<=n&&t[cur]==s[step])ret=ret||dfs(cur+1,step+1);\n\tif(cur+2<=n&&(t[cur+1]+1)%12==s[step])ret=ret||dfs(cur+2,step+1);\n\tif(cur-1>0&&(t[cur-2]+11)%12==s[step])ret=ret||dfs(cur-1,step+1);\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint cs; cin>>cs;\n\twhile(cs--)\n\t{\n\t\tcin>>n>>m;\n\t\tchar buf[3];\n\t\trep(i,n)cin>>buf,t[i]=tonum(buf);\n\t\trep(i,m)cin>>buf,s[i]=tonum(buf);\n\t\t\n\t\tcout<<(dfs(0,0)?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int h,i,j;\n  char s[12][3]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int t;\n  cin>>t;\n  for(h=0;h<t;++h){\n    int n,m;\n    cin>>n>>m;\n    int a[50004],b[50000];\n    for(i=2;i<n+2;++i){\n      char u[3];\n      cin>>u;\n      for(j=0;strcmp(s[j],u);++j);\n      a[i]=j;\n    }\n    a[0]=a[1]=a[i]=a[i+1]=-3;\n    for(i=0;i<m;++i){\n      char u[3];\n      cin>>u;\n      for(j=0;strcmp(s[j],u);++j);\n      b[i]=j;\n    }\n    int c[50004]={},d[50004]={};\n    c[1]=-1;\n    int jmn=1,jmx=1;\n    for(i=0;i<m;++i){\n      int kmn=1<<30,kmx=0;\n      for(j=jmn;j<=jmx;++j){\n\tif(c[j]){\n\t  if(b[i]==a[j-1]+(a[j-1]?-1:11)){\n\t    d[j-1]=-1;\n\t    kmn=min(kmn,j-1);\n\t    kmx=max(kmx,j-1);\n\t  }\n\t  if(b[i]==a[j+1]){\n\t    d[j+1]=-1;\n\t    kmn=min(kmn,j+1);\n\t    kmx=max(kmx,j+1);\n\t  }\n\t  if(b[i]==(a[j+2]+1)%12){\n\t    d[j+2]=-1;\n\t    kmn=min(kmn,j+2);\n\t    kmx=max(kmx,j+2);\n\t  }\n\t}\n      }\n      if(kmn==1<<30){\n\tc[n]=c[n+1]=0;\n\tbreak;\n      }\n      jmn=kmn;\n      jmx=kmx;\n      copy(d+jmn,d+jmx+1,c+jmn);\n      fill(d,d+n+2,0);\n    }\n    if(c[n]||c[n+1])\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            for(int j = 0; j < 12; ++j) {\n                if(s == note[j]) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            cin >> s;\n            for(int j = 0; j < 12; ++j) {\n                if(s == note[j]) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        vector<int> cache(n, INT_MAX);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, -1));\n\n        bool ok = false;\n        while(!q.empty()) {\n            int to_play = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m) {\n                if(pos >= n-2) {\n                    ok = true;\n                    break;\n                }\n                else continue;\n            }\n\n            if(pos-1 >= 0) {\n                if((stairs[pos-1]+11)%12 == music[to_play]) {\n                    if(to_play+1 < cache[pos-1]) {\n                        //cache[pos-1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos-1));\n                    }\n                }\n            }\n            if(pos+2 < n) {\n                if((stairs[pos+2]+1)%12 == music[to_play]) {\n                    if(to_play+1 < cache[pos+2]) {\n                //        cache[pos+2] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if(stairs[pos+1] == music[to_play]) {\n                    if(to_play+1 < cache[pos+1]) {\n                 //       cache[pos+1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+1));\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct edge{int to,sound;};\n\nint f(string s){\n\tif(s==\"C\")return 0;\n\tif(s==\"C#\")return 1;\n\tif(s==\"D\")return 2;\n\tif(s==\"D#\")return 3;\n\tif(s==\"E\")return 4;\n\tif(s==\"F\")return 5;\n\tif(s==\"F#\")return 6;\n\tif(s==\"G\")return 7;\n\tif(s==\"G#\")return 8;\n\tif(s==\"A\")return 9;\n\tif(s==\"A#\")return 10;\n\tif(s==\"B\")return 11;\n\treturn -1;\n}\n\nbool isSame(vector<int> &a, vector<int> &b){\n\trep(i,a.size()){\n\t\tif(a[i]!=b[i+1])return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tint input;\n\tcin>>input;\n\trep(loop,input){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tvector<int> step,song;\n\t\tstep.pb(-1);\t//1-index???????????????\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstep.pb(f(s));\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong.pb(f(s));\n\t\t}\n\t\tsong.pb(-1);\t//????????????????°???????????????????\n\t\t\n\t\tvector<edge> G[50010];\n\t\trep(i,n)  G[i].pb( edge{(int)i+1,step[i+1]} );\n\t\trep(i,n)  G[i+1].pb( edge{(int)i,(step[i]-1+12)%12} );\n\t\trep(i,n-1)G[i].pb( edge{(int)i+2,(step[i+2]+1)%12} );\n\t\tG[n].pb(edge{n+1,-1});\n\t\tG[n-1].pb(edge{n+2,-1});\n\t\t\n\t\tbool f=true;\n\t\t\n\t\tqueue<pii> que;\n\t\tque.push(make_pair(0,0));\n\t\twhile(!que.empty()){\n\t\t\tint pos = que.front().first;\n\t\t\tint num = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(num==m+1){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e = G[pos][i];\n\t\t\t\tif(e.sound == song[num]){\t//?\n\t\t\t\t\tque.push(make_pair(e.to,num+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint T[50000];\nint S[50000];\n\nint main() {\n  string hoge[] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  map<string, int> mp;\n  REP(i,12) mp[hoge[i]] = i;\n  int NUM;\n  cin>>NUM;\n  while(NUM--) {\n    int n,m; cin >> n >> m;\n    REP(i,n) {\n      string s;cin >> s;\n      T[i] = mp[s];\n    }\n    REP(i,m) {\n      string s;cin>>s;\n      S[i] = mp[s];\n    }\n    queue<pii> Q;\n    Q.push(pii(-1,-1));\n    bool ok = 0;\n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      int a = p.first, b = p.second;\n      //cout << a << \" \" << b << endl;\n      if (a==n) {\n        if (b==m) {\n          ok = 1;\n          break;\n        }\n        continue;\n      }\n      if (a+1<=n) {\n        if (a+1==n || T[a+1]==S[b+1]) {\n          Q.push(pii(a+1,b+1));\n        }\n      }\n      if (a+2<=n) {\n        if (a+2==n || (T[a+2]+1)%12==S[b+1]) {\n          Q.push(pii(a+2,b+1));\n        }\n      }\n      if (a) {\n        if ((T[a-1]+11)%12==S[b+1]) {\n          Q.push(pii(a-1,b+1));\n        }\n      }\n    }\n    cout << (ok?\"Yes\":\"No\") << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    unordered_set<int> used[50001];    \n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      if(s && used[s-1].size()) used[s-1].clear();\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n\n      //if ( used[s].count(t) ) continue;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif ( used[s+1].count(t-1) ) continue;\n\tq.push(Pii(s+1, t-1));\n\tused[s+1].insert(t-1);\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif ( used[s+1].count(t+1) ) continue;\n\tq.push(Pii(s+1, t+1));\n\tused[s+1].insert(t+1);\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif ( used[s+1].count(t+2) ) continue;\n\tq.push(Pii(s+1, t+2));\n\tused[s+1].insert(t+2);\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nstring melody[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\nstring t[50001],s[50001];\nint n,m,setcount;\n\nstring upmelody(string s){\n\tstring res=\"**\";\n\trep(i,12){\n\t\tif(s==melody[i]){\n\t\t\tif(i==11) res=melody[0];\n\t\t\telse res=melody[i+1];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstring downmelody(string s){\n\tstring res;\n\trep(i,12){\n\t\tif(s==melody[i]){\n\t\t\tif(i==0) res=melody[11];\n\t\t\telse res=melody[i-1];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool f(int now,int mcnt){\n\tbool res=false;\n\tif(mcnt==m+1){\n\t\tif(now==n+1)return true;\n\t\telse return false;\n\t}else{\n\t\tif(s[mcnt]==t[(now+1)%12] || now==n){\n\t\t\tres=f(now+1,mcnt+1);\n\t\t}\n\t\tif(s[mcnt]==upmelody(t[(now+2)%12]) || (now+2)==(n+1)){\n\t\t\tres=(res || f(now+2,mcnt+1));\n\t\t}\n\t\tif(now>1 && s[mcnt]==downmelody(t[(now-1)%12])){\n\t\t\tres=(res ||f(now-1,mcnt+1));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>setcount;\n\trep(z,setcount){\n\t\tcin>>n>>m;\n\t\tt[0]=\"z\";\n\t\trep(i,50001)s[i]=t[i]=\"\";\n\t\trep(i,n)cin>>t[i+1];\n\t\trep(i,m)cin>>s[i];\n\t\tif(f(0,0))cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n \nconst int LIM = 50000;\n \nmap<string, int> tone;\n \nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n \nstring stair[LIM+1], melody[LIM+1];\nint S, N, M;\n \nint pos, num;\n \nbool dfs(void){\n    if(num > M)  return false;\n    if(pos >= N) return num == M;\n    if((M - num) * 2 + pos < N) return false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n    \t++pos; ++num;\n    \tif(dfs()) return true;\n    \t--pos; --num;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n    \tpos += 2; ++num;\n    \tif(dfs()) return true;\n    \tpos -= 2; --num;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n    \t--pos; ++num;\n        return true;\n        ++pos; --num;\n    }\n    return false;\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair + N);\n        reverse(melody, melody + M);\n        bool res = false;\n        pos = 0, num = 0;\n        res = dfs();\n        pos = 1, num = 0;\n        res = res || dfs();\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM], melody[LIM];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(pos >= N && num == M) return true;\n    bool ret = false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        ret = ret || dfs(pos+1, num+1);\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        ret = ret || dfs(pos+2, num+1);\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        ret = ret || dfs(pos-1, num+1);\n    }\n    return ret;\n}\n\nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair+N);\n        reverse(melody, melody+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n,m;\nvi a,b;\nbool f(int s,int t){\n\tif(t==-1){\n\t\tif(s==-1)return true;\n\t\treturn false;\n\t}\n\tif(s>n||s<0)return false;\n\tif(a[s]==b[t]&&f(s-1,t-1))return true;\n\tif((a[s]+1)%12==b[t]&&f(s-2,t-1))return true;\n\tif((a[s]+11)%12==b[t]&&f(s+1,t-1))return true;\n\treturn false;\n}\nint main(){\n\tmap<string,int>M;\n\tM[\"A\"]=0;\n\tM[\"A#\"]=1;\n\tM[\"B\"]=2;\n\tM[\"C\"]=3;\n\tM[\"C#\"]=4;\n\tM[\"D\"]=5;\n\tM[\"D#\"]=6;\n\tM[\"E\"]=7;\n\tM[\"F\"]=8;\n\tM[\"F#\"]=9;\n\tM[\"G\"]=10;\n\tM[\"G#\"]=11;\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>n>>m;\n\t\ta=vi(n);\n\t\tb=vi(m);\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\ta[i]=M[s];\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tb[i]=M[s];\n\t\t}\n\t\tif(f(n-1,m-1)||n!=1&&f(n-2,m-1))cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N,M;\nint T[50010];\nint S[50010];\nint lis[]={9,11,0,2,4,5,7};\n\nchar t[3];\ninline int in(){\n    scanf(\"%s\",t);\n    return lis[t[0]-'A']+(t[1]=='#');\n}\ninline int add(int a,int b){\n    a+=b;\n    if(a>=12)a-=12;\n    return a;\n}\n\nvoid solve(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,N)T[i]=in();\n    rep(i,M)S[i]=in();\n    for(int fin=N-2;fin<N;fin++){\n        bool ok=true;\n        int pos=fin;\n        for(int i=M-1;i>=0;i--){\n            if(pos<0||pos==N){\n                ok=false;\n                break;\n            }\n            if(T[pos]==S[i])pos--;\n            else if(add(T[pos],1)==S[i])pos-=2;\n            else if(add(T[pos],11)==S[i])pos++;\n            else{\n                ok=false;\n                break;\n            }\n        }\n        if(ok&&pos==-1){\n            puts(\"Yes\");\n            return;\n        }\n    }\n    puts(\"No\");\n}\n\nsigned main(){\n    int T;scanf(\"%lld\",&T);\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nconst static int offset[] = {11,0,1};\n\nint dfs(int note_pos,int stair_pos,\n        const vector<int>& stair,const vector<int>& song){\n\n  if(stair_pos + 2 * (song.size() - note_pos) < stair.size() - 2){\n    return false;\n  }\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int next = stair_pos + idx2dist[i];\n    if(next < 0) continue;\n    if(next >= stair.size()) continue;\n    \n    if(song[note_pos + 1] != (stair[next] + offset[i]) % 12) continue;\n    res |= dfs(note_pos + 1,next,stair,song);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1,stair,song) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    chrono::system_clock::time_point start=chrono::system_clock::now();\n    auto calcTime=[&](){\n      chrono::system_clock::time_point end = chrono::system_clock::now();\n      return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n    };\n    //  cout<<calcTime()<<endl;\n    \n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<5000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    srand((unsigned)time(NULL));\n    \n    if(calcTime()>=5000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\n\nint main() {\n    srand((unsigned)time(NULL));\n    \n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    chrono::system_clock::time_point start=chrono::system_clock::now();\n    auto calcTime=[&](){\n      chrono::system_clock::time_point end = chrono::system_clock::now();\n      return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n    };\n    //  cout<<calcTime()<<endl;\n    \n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<1000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    \n    if(calcTime()>=1000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n    //N = 1;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        bool ok = false;\n        for(int start = n-2; start <= n-1; ++start) {\n            int mpos = m-1;\n            int pos = start;\n            for(; mpos >= 0; --mpos) {\n                if(stairs[pos] == music[mpos]) {\n                    if(--pos < 0) goto next;\n                }\n                else if((stairs[pos]+1)%12 == music[mpos]) {\n                    pos -= 2;\n                    if(pos < 0) goto next;\n                }\n                else if((stairs[pos]+2)%12 == music[mpos]) {\n                    pos += 1;\n                    if(pos >= n) goto next;\n                }\n            }\nnext:\n            if(pos == -1) {\n                ok = true;\n                break;\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n#include <cctype>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nbool ok;\nint d_pos[]={-2,-1,1};\nint d_oto[]={1,0,-1};\nvoid slove(const vector<int> &t, int t_pos, const vector<int> &s, int s_pos){\n\t\n\tif(s_pos==-1){\n\t\tif(t_pos==-1) ok=true;\n\t\treturn;\n\t}else if(t_pos<0 || t_pos>=t.size()) return;\n\n\tfor(int i=0;i<3;i++){\n\t\tint prev_oto=(t[t_pos]+d_oto[i]+12)%12;\n\t\tif(prev_oto==s[s_pos]) slove(t,t_pos+d_pos[i],s,s_pos-1);\n\t}\n\n}\n\nint main(){\n\n\tstring o[]={\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tmap<string,int> dic;\n\tfor(int i=0;i<12;i++) dic[o[i]]=i;\n\t\n\tint T;\n\tcin>>T;\n\t\n\tfor(int c=0;c<T;c++){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\t\n\t\tvector<int> t(n),s(m);\n\t\tstring tmp;\n\t\tfor(int i=0;i<n;i++) cin>>tmp,t[i]=dic[tmp];\n\t\tfor(int i=0;i<m;i++) cin>>tmp,s[i]=dic[tmp];;\n\t\t\n\t\tok=false;\n\t\tslove(t,n-1,s,m-1);\n\t\tslove(t,n-2,s,m-1);\n\t\tif(ok) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nmap<string, int> onkai;\n\nint numOnkai = 0;\n\nbool isok(int curT, int curS, int n, vector<int>& t, vector<int>& s) {\n  while (curS >= 0 && curT >= 0 && curT < n) {\n//    cout << \"now:\" << curT << \",\"<< t[curT] <<\",\"<< s[curS] << endl;\n    if (t[curT] == s[curS]) {\n      curT--;\n    }\n    else if ((t[curT] + 1) % numOnkai == s[curS]) {\n      curT -= 2;\n    }\n    else if (t[curT] == (s[curS] + 1) % numOnkai) {\n      curT++;\n    }\n    else {\n      break;\n    }\n    curS--;\n  }\n  return curS == -1;\n}\n\nbool solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> t(n);\n  vector<int> s(m);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    t[i] = onkai[s];\n  }\n  for (int i = 0; i < m; i++) {\n    string st;\n    cin >> st;\n    s[i] = onkai[st];\n  }\n  return isok(n-1, m-1, n, t, s) || n > 1 && isok(n-2, m-1, n, t, s);\n\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  int a=0;\n  onkai[\"C\"] = a++;\n  onkai[\"C#\"] = a++;\n  onkai[\"D\"] = a++;\n  onkai[\"D#\"] = a++;\n  onkai[\"E\"] = a++;\n  onkai[\"F\"] = a++;\n  onkai[\"F#\"] = a++;\n  onkai[\"G\"] = a++;\n  onkai[\"G#\"] = a++;\n  onkai[\"A\"] = a++;\n  onkai[\"A#\"] = a++;\n  onkai[\"B\"] = a++;\n  numOnkai = a;\n\n  for (int i = 0; i < n; i++) {\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int h,i,j;\n  char s[12][3]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int t;\n  cin>>t;\n  for(h=0;h<t;++h){\n    int n,m;\n    cin>>n>>m;\n    int a[50004],b[50000];\n    for(i=2;i<n+2;++i){\n      char u[3];\n      cin>>u;\n      for(j=0;strcmp(s[j],u);++j);\n      a[i]=j;\n    }\n    a[0]=a[1]=a[i]=a[i+1]=-3;\n    for(i=0;i<m;++i){\n      char u[3];\n      cin>>u;\n      for(j=0;strcmp(s[j],u);++j);\n      b[i]=j;\n    }\n    int c[50004]={},d[50004]={};\n    c[1]=-1;\n    for(i=0;i<m;++i){\n      for(j=1;j<n+2;++j){\n\tif(c[j]){\n\t  if(b[i]==a[j-1]+(a[j-1]?-1:11))\n\t    d[j-1]=-1;\n\t  if(b[i]==a[j+1])\n\t    d[j+1]=-1;\n\t  if(b[i]==(a[j+2]+1)%12)\n\t    d[j+2]=-1;\n\t}\n      }\n      copy(d,d+n+2,c);\n      fill(d,d+n+2,0);\n    }\n    if(c[n]||c[n+1])\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint input(){\n  char str[10];\n  scanf(\"%s\",str);\n  \n  if(str[0]=='B'){\n    return 11;\n  }\n  \n  if(str[0]=='A'){\n    if(str[1]=='#')return 10;\n    return 9;\n  }\n\n  if(str[0]=='G'){\n    if(str[1]=='#')return 8;\n    return 7;\n  }\n  \n  if(str[0]=='F'){\n    if(str[1]=='#')return 6;\n    return 5;\n  }\n\n  if(str[0]=='E'){\n    return 4;\n  }\n\n  if(str[0]=='D'){\n    if(str[1]=='#')return 3;\n    return 2;\n  }\n  \n  if(str[0]=='C'){\n    if(str[1]=='#')return 1;\n    return 0;\n  }\n\n  assert(0);\n  return -1;\n}\n\nint n,m;\nint t[50005];\nint u[50005];\n\nint dfs(int depth,int pos){\n  if(depth==m&&n<pos+2)return 1;\n  if(depth==m)return 0;\n  \n  if( 1<=pos-1  && t[pos-1]-1 == u[depth] ){\n    if( dfs( depth+1, pos-1 ) ) return 1;\n  }\n\n  if( pos+1 <= n && t[pos+1]==u[depth] ){\n    if( dfs(depth+1,pos+1) )return 1;\n  }\n\n  if( pos+2 <= n && (t[pos+2]+1)%11==u[depth] ){\n    if( dfs(depth+1,pos+2) )return 1;\n  }\n\n  return 0;\n}\n\nint main(){\n  int Tc;\n  scanf(\"%d\",&Tc);\n  while(Tc--){\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)t[i]=input();\n    for(int i=0;i<m;i++)u[i]=input();\n    \n    int ans=dfs(0,0);\n    if(ans)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        vector<int> cache(n, 0);\n        vector<bool> half(n, false);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(1, -1));\n\n        while(!q.empty()) {\n            int to_play = -q.top().first+1;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m/2) {\n                half[pos] = true;\n                //cout << pos << endl;\n                continue;\n            }\n\n            if(pos-1 >= 0) {\n                if((stairs[pos-1]+11)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos-1]) {\n                        cache[pos-1] = to_play+1;\n                        q.push(make_pair(-to_play, pos-1));\n                    }\n                }\n            }\n            if(pos+2 < n) {\n                if((stairs[pos+2]+1)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos+2]) {\n                        cache[pos+2] = to_play+1;\n                        q.push(make_pair(-to_play, pos+2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if(stairs[pos+1] == music[to_play]) {\n                    if(to_play+1 > cache[pos+1]) {\n                        cache[pos+1] = to_play+1;\n                        q.push(make_pair(-to_play, pos+1));\n                    }\n                }\n            }\n        }\n\n        fill(cache.begin(), cache.end(), INT_MAX);\n        q.push(make_pair(m-1, n-1));\n        q.push(make_pair(m-1, n-2));\n        bool ok = false;\n        while(!q.empty()) {\n            int to_play = q.top().first;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m/2-1) {\n                //cout << pos << endl;\n                if(half[pos])  {\n                    ok = true;\n                    break;\n                }\n                else continue;\n            }\n            if(pos-1 >= 0) {\n                if(stairs[pos] == music[to_play]) {\n                    if(to_play-1 < cache[pos]) {\n                        //cache[pos] = to_play-1;\n                        q.push(make_pair(to_play-1, pos-1));\n                    }\n                }\n            }\n            if(pos-2 >= 0) {\n                if((stairs[pos]+1)%12 == music[to_play]) {\n                    if(to_play-1 < cache[pos]) {\n                        //cache[pos] = to_play-1;\n                        q.push(make_pair(to_play-1, pos-2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if((stairs[pos]+11)%12 == music[to_play]) {\n                    if(to_play-1 < cache[pos]) {\n                        //cache[pos] = to_play-1;\n                        q.push(make_pair(to_play-1, pos+1));\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  string c[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int T;\n  cin >> T;\n  while(T--) {\n    int n,m;\n    cin >> n >> m;\n    string s[n],t[m];\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<m; i++) cin >> t[i];\n    bool dp[2][n];\n    memset(dp,0,sizeof(dp));\n    for(int k=0; k<2; k++) {\n      int x=k;\n      if(x<0 || x>=n) continue;\n      int p=0;\n      for(int l=0; l<12; l++) {\n\tif(c[l]==s[x]) p=l;\n      }\n      p=(p+12+k)%12;\n      if(t[0]==c[p]) dp[0][x]=1;\n    }\n    \n    for(int i=1; i<m; i++) {\n      for(int j=0; j<n; j++) {\n\tif(!dp[0][j]) continue;\n\tfor(int k=-1; k<=2; k++) {\n\t  if(!k) continue;\n\t  int x=j+k;\n\t  if(x<0 || x>=n) continue;\n\t  int p=0;\n\t  for(int l=0; l<12; l++) {\n\t    if(c[l]==s[x]) p=l;\n\t  }\n\t  int q=k;\n\t  if(q>0) q--;\n\t  p=(p+12+q)%12;\n\t  if(t[i]==c[p]) dp[1][x]=1;\n\t}\n      }\n      for(int j=0; j<n; j++) {\n\tdp[0][j]=dp[1][j];\n\tdp[1][j]=0;\n      }\n    }\n    bool ck=0;\n    for(int i=0; i<2; i++) ck|=dp[0][n-i-1];\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nconst static int offset[] = {11,0,1};\nint dfs(int note_pos,int stair_pos,\n        const vector<int>& stair,const vector<int>& song){\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int dist = idx2dist[i];\n    \n    int next = stair_pos + dist;\n    if(next < 0) continue;\n    if(next >= stair.size()) continue;\n    \n    if(song[note_pos + 1] != (stair[next] + offset[i]) % 12) continue;\n    res |= dfs(note_pos + 1,next,stair,song);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1,stair,song) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  int stair_pos;\n  int note_pos;\n  int cost;\n  State(int stair_pos,int note_pos,int cost) :\n    stair_pos(stair_pos),note_pos(note_pos), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nmap<string,int> note2idx;\nstring idx2note[] = {\n  \"C\",\n  \"C#\",\n  \"D\",\n  \"D#\",\n  \"E\",\n  \"F\",\n  \"F#\",\n  \"G\",\n  \"G#\",\n  \"A\",\n  \"A#\",\n  \"B\"\n};\n\nmap<int,bool> dp[50001];\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int i = 0; i <= 50000; i++){\n      dp[i].clear();\n    }\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<string> stair;\n      vector<string> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note);\n      }\n\n      priority_queue<State> que;\n      que.push(State(-1,-1,0));\n\n      bool isok = false;\n      while(!que.empty()){\n        State s = que.top();\n        que.pop();\n\n        if(s.note_pos == song_length - 1\n           && s.stair_pos >= num_of_steps - 2){\n          isok = true;\n          break;\n        }\n        for(int dist = -1; dist <= 2; dist++){\n          if(dist == 0) continue;\n\n          int next = s.stair_pos + dist;\n          if(next < 0) continue;\n          if(next >= num_of_steps) continue;\n\n          int offset = 0;\n          if(dist == -1) offset = 12 - 1;\n          if(dist == 2) offset = 1;\n          if(song[s.note_pos + 1] != idx2note[(note2idx[stair[next]] + offset) % 12]) continue;\n          if(dp[s.note_pos + 1].find(next) != dp[s.note_pos + 1].end()) continue;\n          dp[s.note_pos + 1][next] = true;\n          que.push(State(next,s.note_pos + 1,s.cost + 1));\n        }\n      }\n      printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint T[50000];\nint S[50000];\n\nint main() {\n  string hoge[] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  map<string, int> mp;\n  REP(i,12) mp[hoge[i]] = i;\n  int NUM;\n  cin>>NUM;\n  while(NUM--) {\n    int n,m; cin >> n >> m;\n    REP(i,n) {\n      string s;cin >> s;\n      T[i] = mp[s];\n    }\n    REP(i,m) {\n      string s;cin>>s;\n      S[i] = mp[s];\n    }\n    queue<pii> Q;\n    Q.push(pii(-1,-1));\n    bool ok = 0;\n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      int a = p.first, b = p.second;\n\n      int rest = n-a;\n      if ((m-b)*2 < n-a) continue;\n      if (a==n) {\n        if (b==m) {\n          ok = 1;\n          break;\n        }\n        continue;\n      }\n      if (a+1<=n) {\n        if (a+1==n || T[a+1]==S[b+1]) {\n          Q.push(pii(a+1,b+1));\n        }\n      }\n      if (a+2<=n) {\n        if (a+2==n || (T[a+2]+1)%12==S[b+1]) {\n          Q.push(pii(a+2,b+1));\n        }\n      }\n      if (a) {\n        if ((T[a-1]+11)%12==S[b+1]) {\n          Q.push(pii(a-1,b+1));\n        }\n      }\n    }\n    cout << (ok?\"Yes\":\"No\") << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50000;\nconst int MAX_M = 50000;\n\nconst int NSC = 12;\n\nconst string scs[NSC] = {\n  \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"\n};\n\n/* typedef */\n\ntypedef map<string,int> msi;\n\n/* global variables */\n\nmsi scmap;\nint n, m;\nint tis[MAX_N], sis[MAX_M];\n\n/* subroutines */\n\nbool rec(int ti, int si) {\n  if (si >= m - 1) return (ti >= n - 2);\n\n  int s1 = sis[si + 1];\n\n  if (ti > 0 && (tis[ti - 1] + NSC - 1) % NSC == s1 &&\n      rec(ti - 1, si + 1)) return true;\n  if (ti < n - 1 && tis[ti + 1] == s1 &&\n      rec(ti + 1, si + 1)) return true;\n  if (ti < n - 2 && (tis[ti + 2] + 1) % NSC == s1 &&\n      rec(ti + 2, si + 1)) return true;\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  for (int i = 0; i < NSC; i++) scmap[scs[i]] = i;\n\n  int tn;\n  cin >> tn;\n\n  while (tn--) {\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n      string sc;\n      cin >> sc;\n      tis[i] = scmap[sc];\n    }\n\n    for (int i = 0; i < m; i++) {\n      string sc;\n      cin >> sc;\n      sis[i] = scmap[sc];\n    }\n\n    bool ok = rec(-1, -1);\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  string c[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int T;\n  cin >> T;\n  while(T--) {\n    int n,m;\n    cin >> n >> m;\n    string s[n],t[m];\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<m; i++) cin >> t[i];\n    bool ck=0;\n    for(int k=1; k<3; k++) {\n      int x=n-k;\n      for(int i=m-1; i>=0; i--) {\n\tif(x<0 || x>=n) {x=1<<29;break;}\n\tint p;\n\tfor(p=0; p<12; p++) if(c[p]==s[x]) break;\n\tif(t[i]==c[p]) x--;\n\telse if(t[i]==c[(p+1)%12]) x-=2;\n\telse if(t[i]==c[(p+11)%12]) x++;\n\telse {x=1<<29;break;}\n      }\n      if(x<3) ck=1;\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,m,t[50000],s[50000];\n\nint tonum(char *buf)\n{\n\tint so[256];\n\tso['C']=0; so['D']=2; so['E']=4;\n\tso['F']=5; so['G']=7; so['A']=9;\n\tso['B']=11;\n\t\n\treturn so[buf[0]]+(buf[1]=='#');\n}\n\nbool dfs(int cur,int step)\n{\n\tif(step==m)\n\t{\n\t\tif(cur+1==n+1||cur+2==n+1)return 1;\n\t\treturn 0;\n\t}\n\t\n\tbool ret=0;\n\tif(cur+1<=n&&t[cur]==s[step])ret=ret||dfs(cur+1,step+1);\n\tif(cur+2<=n&&(t[cur+1]+1)%12==s[step])ret=ret||dfs(cur+2,step+1);\n\tif(cur-1>0&&(t[cur-2]+11)%12==s[step])ret=ret||dfs(cur-1,step+1);\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint cs; cin>>cs;\n\twhile(cs--)\n\t{\n\t\tcin>>n>>m;\n\t\tchar buf[3];\n\t\trep(i,n)cin>>buf,t[i]=tonum(buf);\n\t\trep(i,m)cin>>buf,s[i]=tonum(buf);\n\t\t\n\t\tcout<<(dfs(0,0)?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ninline int f(const char *s){\n\tif(s[0]=='C' && s[1]=='\\0') return 0;\n\tif(s[0]=='C' && s[1]=='#' ) return 1;\n\tif(s[0]=='D' && s[1]=='\\0') return 2;\n\tif(s[0]=='D' && s[1]=='#' ) return 3;\n\tif(s[0]=='E' && s[1]=='\\0') return 4;\n\tif(s[0]=='F' && s[1]=='\\0') return 5;\n\tif(s[0]=='F' && s[1]=='#' ) return 6;\n\tif(s[0]=='G' && s[1]=='\\0') return 7;\n\tif(s[0]=='G' && s[1]=='#' ) return 8;\n\tif(s[0]=='A' && s[1]=='\\0') return 9;\n\tif(s[0]=='A' && s[1]=='#' ) return 10;\n\treturn 11;\n}\n\ninline int dist(int t1,int t2){ return (t1-t2+12)%12; }\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n,m; scanf(\"%d%d\",&n,&m);\n\t\tstatic int t[50000],s[50000];\n\t\trep(i,n){ char in[3]; scanf(\"%s\",in); t[i]=f(in); }\n\t\trep(i,m){ char in[3]; scanf(\"%s\",in); s[i]=f(in); }\n\n\t\tbool ok=false;\n\t\trep(k,2){\n\t\t\tint pos=n-k-1;\n\t\t\tif(pos>=0 && (dist(s[m-1],t[pos])<=1 || dist(s[m-1],t[pos])==11)){\n\t\t\t\tint i;\n\t\t\t\tfor(i=m-1;i>=0;i--){\n\t\t\t\t\tint d=dist(s[i],t[pos]);\n\t\t\t\t\tif     (d== 0) pos--;\n\t\t\t\t\telse if(d== 1) pos-=2;\n\t\t\t\t\telse if(d==11) pos++;\n\t\t\t\t\telse break;\n\n\t\t\t\t\tif(i==0 && (pos<-1 || n<=pos)\n\t\t\t\t\t|| i!=0 && (pos< 0 || n<=pos)) break;\n\t\t\t\t}\n\n\t\t\t\tif(i==-1 && pos==-1){ ok=true; break; }\n\t\t\t}\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM], melody[LIM];\nint S, N, M;\n\nint pos, num;\n\nbool dfs(void){\n    if(num >= M) return pos == N;\n    if(pos >= N) return false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        ++pos; ++num;\n        if(dfs()) return true;\n        --pos; --num;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        pos += 2; ++num;\n        if(dfs()) return true;\n        pos -= 2; --num;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        --pos; ++num;\n        if(dfs()) return true;\n        ++pos; --num;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair + N);\n        reverse(melody, melody + N);\n        bool res = false;\n        pos = 0; num = 0;\n        res = res || dfs();\n        pos = 1; num = 0;\n        res = res || dfs();\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\"  << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50040;\nint T[MAXN], S[MAXN];\n\nbool check(int start, int n, int m) {\n    int now = start;\n    for (int i = 0; i < m; i++) {\n        if (now > n-1) return false;\n        int tar = S[i];\n        bool ok = false;\n        for (int j = -1; j <= 1; j++) {\n            int next = (T[now]+j + 12) % 12;\n            if (tar == next) {\n                ok = true;\n                now += j;\n                if (j >= 0) now++;\n            }\n        }\n        if (now < 0) return false;\n        if (!ok) return false;\n    }\n    if (now == n) return true;\n    else return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int test;\n    cin >> test;\n    map<string, int> oto;\n    oto[\"C\"] = 0;\n    oto[\"C#\"] = 1;\n    oto[\"D\"] = 2;\n    oto[\"D#\"] = 3;\n    oto[\"E\"] = 4;\n    oto[\"F\"] = 5;\n    oto[\"F#\"] = 6;\n    oto[\"G\"] = 7;\n    oto[\"G#\"] = 8;\n    oto[\"A\"] = 9;\n    oto[\"A#\"] = 10;\n    oto[\"B\"] = 11;\n    while (test--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            T[i] = oto[s];\n        }\n        for (int i = 0; i < m; i++) {\n            string s;\n            cin >> s;\n            S[i] = oto[s];\n        }\n        reverse(S, S+m);\n        reverse(T, T+n);\n        if (check(0, n, m) || check(1, n, m)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            for(int j = 0; j < 12; ++j) {\n                if(s == note[j]) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            cin >> s;\n            for(int j = 0; j < 12; ++j) {\n                if(s == note[j]) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        vector<int> cache(n, 0);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, -1));\n\n        bool ok = false;\n        while(!q.empty()) {\n            int to_play = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m) {\n                if(pos >= n-2) {\n                    ok = true;\n                    break;\n                }\n                else continue;\n            }\n\n            if(pos-1 >= 0) {\n                if((stairs[pos-1]+11)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos-1]) {\n                        cache[pos-1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos-1));\n                    }\n                }\n            }\n            if(pos+2 < n) {\n                if((stairs[pos+2]+1)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos+2]) {\n                        cache[pos+2] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if(stairs[pos+1] == music[to_play]) {\n                    if(to_play+1 > cache[pos+1]) {\n                        cache[pos+1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+1));\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint input(){\n  char str[10];\n  scanf(\"%s\",str);\n  \n  if(str[0]=='B'){\n    return 11;\n  }\n  \n  if(str[0]=='A'){\n    if(str[1]=='#')return 10;\n    return 9;\n  }\n\n  if(str[0]=='G'){\n    if(str[1]=='#')return 8;\n    return 7;\n  }\n  \n  if(str[0]=='F'){\n    if(str[1]=='#')return 6;\n    return 5;\n  }\n\n  if(str[0]=='E'){\n    return 4;\n  }\n\n  if(str[0]=='D'){\n    if(str[1]=='#')return 3;\n    return 2;\n  }\n  \n  if(str[0]=='C'){\n    if(str[1]=='#')return 1;\n    return 0;\n  }\n\n  assert(0);\n  return -1;\n}\n\nint n,m;\nint t[50005];\nint u[50005];\n\nint dfs(int depth,int pos){\n  if(depth==m&&n<pos+2)return 1;\n  if(depth==m)return 0;\n  \n  if( 1<=pos-1  && (t[pos-1]+11)%12 == u[depth] ){\n    if( dfs( depth+1, pos-1 ) ) return 1;\n  }\n\n  if( pos+1 <= n && t[pos+1]==u[depth] ){\n    if( dfs(depth+1,pos+1) )return 1;\n  }\n\n  if( pos+2 <= n && (t[pos+2]+1)%12==u[depth] ){\n    if( dfs(depth+1,pos+2) )return 1;\n  }\n\n  return 0;\n}\n\nint main(){\n  int Tc;\n  scanf(\"%d\",&Tc);\n  while(Tc--){\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)t[i]=input();\n    for(int i=0;i<m;i++)u[i]=input();\n    \n    int ans=dfs(0,0);\n    if(ans)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nstring table[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n\nint N,M;\nint T[50010];\nint S[50010];\n\nbool ok;\nbool dfs(int n,int m){\n    if(m==M){\n        if(N-n<=2){\n            ok=true;\n            return true;\n        }\n        return false;\n    }\n    if(ok)return true;\n\n    if((N-n+1)/2>M-m+1)return false;\n    if(n>0&&(T[n-1]+11)%12==S[m]){\n        if(dfs(n-1,m+1)){\n            ok=true;\n            return true;\n        }\n    }\n\n    if(n+1<N&&T[n+1]==S[m]){\n        if(dfs(n+1,m+1)){\n            ok=true;\n            return true;\n        }\n    }\n    if(n+2<N&&(T[n+2]+1)%12==S[m]){\n        if(dfs(n+2,m+1)){\n            ok=true;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nvoid solve(){\n    cin>>N>>M;\n    string hoge;\n    rep(i,N){\n        cin>>hoge;\n        T[i]=find(table,table+12,hoge)-table;\n    }\n    rep(i,M){\n        cin>>hoge;\n        S[i]=find(table,table+12,hoge)-table;\n    }\n\n    ok=false;\n    if(dfs(-1,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    int T;cin>>T;\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n    //N = 1;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        bool ok = false;\n        for(int start = n-2; start <= n-1; ++start) {\n            int mpos = m-1;\n            int pos = start;\n            for(; mpos >= 0; --mpos) {\n                if(stairs[pos] == music[mpos]) {\n                    if(--pos < 0) goto next;\n                }\n                else if((stairs[pos]+1)%12 == music[mpos]) {\n                    pos -= 2;\n                    if(pos < 0) goto next;\n                }\n                else if((stairs[pos]+2)%12 == music[mpos]) {\n                    pos += 1;\n                    if(pos >= n) goto next;\n                }\n            }\nnext:\n            if(mpos <= 0 && pos == -1) {\n                ok = true;\n                break;\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\nint stair[100000];\nint song[100000];\n\nint mapto[300];\nint convert(const char *str) {\n  int ret = mapto[(int)str[0]];\n  if (str[1] == '#') { ret++; }\n  return ret;\n}\n\nint main() {\n  mapto[(int)'C'] = 0;\n  mapto[(int)'D'] = 2;\n  mapto[(int)'E'] = 4;\n  mapto[(int)'F'] = 5;\n  mapto[(int)'G'] = 7;\n  mapto[(int)'A'] = 9;\n  mapto[(int)'B'] = 11;\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    scanf(\"%d %d\", &n, &m);\n    REP(i, n) {\n      char str[100];\n      scanf(\" %s \", str);\n      stair[i] = convert(str);\n    }\n    REP(i, m) {\n      char str[100];\n      scanf(\" %s \", str);\n      song[i] = convert(str);\n    }\n    queue<pair<int, int> > que;\n    que.push(make_pair(n - 1, m - 1));\n    que.push(make_pair(n - 2, m - 1));\n    while (!que.empty()) {\n      int y = que.front().first;\n      int index = que.front().second;\n      que.pop();\n      if (y == -1 && index == -1) {\n        puts(\"Yes\");\n        goto next;\n      }\n      if (y >= n || y < 0 || index == -1) { continue; }\n      assert(y >= 0);\n      if (song[index] == stair[y]) {\n        que.push(make_pair(y - 1, index - 1));\n      } else if (song[index] == (stair[y] + 1) % 12) {\n        que.push(make_pair(y - 2, index - 1));\n      }  else if (song[index] == (stair[y] + 11) % 12) {\n        que.push(make_pair(y + 1, index - 1));\n      }\n    }\n    puts(\"No\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N,M;\nint T[50010];\nint S[50010];\nint lis[]={9,11,0,2,4,5,7};\n\nchar t[3];\ninline int in(){\n    scanf(\"%s\",t);\n    return lis[t[0]-'A']+(t[1]=='#');\n}\n\nvoid solve(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,N)T[i]=in();\n    rep(i,M)S[i]=in();\n    for(int fin=N-2;fin<N;fin++){\n        bool ok=true;\n        int pos=fin;\n        for(int i=M-1;i>=0;i--){\n            if(pos<0||pos==N){\n                ok=false;\n                break;\n            }\n            if(T[pos]==S[i])pos--;\n            else if((T[pos]+1)%12==S[i])pos-=2;\n            else if((T[pos]+11)%12==S[i])pos++;\n            else{\n                ok=false;\n                break;\n            }\n        }\n        if(ok&&pos==-1){\n            puts(\"Yes\");\n            return;\n        }\n    }\n    puts(\"No\");\n}\n\nsigned main(){\n    int T;scanf(\"%lld\",&T);\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50040;\nint T[MAXN], S[MAXN];\n\nbool check(int start, int n, int m) {\n    int now = start;\n    for (int i = 0; i < m; i++) {\n        if (now > n-1) return false;\n        int tar = S[i];\n        bool ok = false;\n        for (int j = -1; j <= 1; j++) {\n            int next = (T[now]+j + 12) % 12;\n            if (tar == next) {\n                ok = true;\n                now += j;\n                if (j >= 0) now++;\n                break;\n            }\n        }\n        if (now < 0) return false;\n        if (!ok) return false;\n    }\n    if (now == n) return true;\n    else return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int test;\n    cin >> test;\n    map<string, int> oto;\n    oto[\"C\"] = 0;\n    oto[\"C#\"] = 1;\n    oto[\"D\"] = 2;\n    oto[\"D#\"] = 3;\n    oto[\"E\"] = 4;\n    oto[\"F\"] = 5;\n    oto[\"F#\"] = 6;\n    oto[\"G\"] = 7;\n    oto[\"G#\"] = 8;\n    oto[\"A\"] = 9;\n    oto[\"A#\"] = 10;\n    oto[\"B\"] = 11;\n    while (test--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            T[i] = oto[s];\n        }\n        for (int i = 0; i < m; i++) {\n            string s;\n            cin >> s;\n            S[i] = oto[s];\n        }\n        reverse(S, S+m);\n        reverse(T, T+n);\n        if (check(0, n, m) || check(1, n, m)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nstring table[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n\nint N,M;\nint T[50010];\nint S[50010];\n\nbool ok;\nbool dfs(int n,int m){\n    if(m==M){\n        if(N-n<=2){\n            ok=true;\n            return true;\n        }\n        return false;\n    }\n    if(ok)return true;\n\n    //if((N-n+1)/2>M-m+1)return false;\n    if(n>0&&(T[n-1]+11)%12==S[m]){\n        if(dfs(n-1,m+1)){\n            ok=true;\n            return true;\n        }\n    }\n\n    if(n+1<N&&T[n+1]==S[m]){\n        if(dfs(n+1,m+1)){\n            ok=true;\n            return true;\n        }\n    }\n    if(n+2<N&&(T[n+2]+1)%12==S[m]){\n        if(dfs(n+2,m+1)){\n            ok=true;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nvoid solve(){\n    cin>>N>>M;\n    string hoge;\n    rep(i,N){\n        cin>>hoge;\n        T[i]=find(table,table+12,hoge)-table;\n    }\n    rep(i,M){\n        cin>>hoge;\n        S[i]=find(table,table+12,hoge)-table;\n    }\n\n    ok=false;\n    if(dfs(-1,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    int T;cin>>T;\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            for(int j = 0; j < 12; ++j) {\n                if(s == note[j]) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            cin >> s;\n            for(int j = 0; j < 12; ++j) {\n                if(s == note[j]) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        vector<int> cache(n, 0);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, -1));\n\n        bool ok = false;\n        while(!q.empty()) {\n            int to_play = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m) {\n                if(pos >= n-2) {\n                    ok = true;\n                    break;\n                }\n                else continue;\n            }\n\n            if(pos-1 >= 0) {\n                if((stairs[pos-1]+11)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos-1]) {\n                        //cache[pos-1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos-1));\n                    }\n                }\n            }\n            if(pos+2 < n) {\n                if((stairs[pos+2]+1)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos+2]) {\n                        cache[pos+2] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if(stairs[pos+1] == music[to_play]) {\n                    if(to_play+1 > cache[pos+1]) {\n                        cache[pos+1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+1));\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[50003],b[50000],n,m;\nint fn(int p,int q){  \n  if(p==m){\n    if(q+2>n)\n      return 1;\n  }else{\n    if((a[q-1]==0?11:a[q-1]-1)==b[p]&&fn(p+1,q-1))\n      return 1;\n    if(a[q+1]==b[p]&&fn(p+1,q+1))\n      return 1;\n    if((a[q+2]==11?0:a[q+2]+1)==b[p]&&fn(p+1,q+2))\n      return 1;\n  }\n  return 0;\n}\nint main(){\n  int h,i,j;\n  string s[]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int o;\n  cin>>o;\n  for(h=0;h<o;h++){\n    cin>>n>>m;\n    a[0]=a[n+1]=a[n+2]=-2;\n    for(i=1;i<n+1;i++){\n      string t;\n      cin>>t;\n      for(j=0;s[j]!=t;j++);\n      a[i]=j;\n    }\n    for(i=0;i<m;i++){\n      string t;\n      cin>>t;\n      for(j=0;s[j]!=t;j++);\n      b[i]=j;\n    }\n    if(0\n       ||(a[1]==b[0]&&fn(1,1))\n       ||((a[2]==11?0:a[2]+1)==b[0]&&fn(1,2)))\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 998244353\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nstring ar[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    int t; cin >> t;\n    map<string, int> mp;\n    // C, C#, D, D#, E, F, F#, G, G#, A, A#, B -> C... \n\n    for(int i=0; i<12; i++){\n        mp[ar[i]] = i;\n    }\n    while(t--){\n        int n, m; cin >> n >> m;\n        vector<string> T(n+1), S(m+1);\n        for(int i=1; i<=n; i++) cin >> T[i];\n        for(int i=1; i<=m; i++) cin >> S[i];\n\n        //Sは踏むべき音, Tは今いるposの音\n        bool ok = false;\n        //一番最後に踏む段(n)\n        int pos = n;\n        \n        bool check1 = true;\n        for(int i=m; i>=1; i--){\n            if(mp[S[i]] == mp[T[pos]]){\n                pos--;\n            }else if(mp[S[i]] == (mp[T[pos]]+1)%12){\n                //半音高い場合 -> 2段上に\n                if(pos-2>=0){\n                    pos = pos-2;\n\n                }else{\n                    check1 = false;\n                }\n            }else if(mp[S[i]] == (mp[T[pos]]-1 + 12) % 12){\n                //半音低い場合 -> 1段下に\n                if(pos+1<=n){\n                    pos = pos + 1;\n\n                }else{\n                    check1 = false;\n                }\n            }else{\n                check1 = false;\n            }\n        }\n        if(check1 && pos == 0){\n            ok = true;\n        }\n\n        bool check2 = true;\n        pos = n-1;\n        for(int i=m; i>=1; i--){\n            if(mp[S[i]] == mp[T[pos]]){\n                pos--;\n            }else if(mp[S[i]] == (mp[T[pos]]+1)%12){\n                //半音高い場合 -> 2段上に\n                if(pos-2>=0){\n                    pos = pos-2;\n\n                }else{\n                    check2 = false;\n                }\n            }else if(mp[S[i]] == (mp[T[pos]]-1 + 12) % 12){\n                //半音低い場合 -> 1段下に\n                if(pos+1<=n){\n                    pos = pos + 1;\n\n                }else{\n                    check2 = false;\n                }\n            }else{\n                check2 = false;\n            }\n        }\n        if(pos == 0 && check2){\n            ok = true;\n        }\n\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct edge{int to,sound;};\n\nint f(string s){\n\tif(s==\"C\")return 0;\n\tif(s==\"C#\")return 1;\n\tif(s==\"D\")return 2;\n\tif(s==\"D#\")return 3;\n\tif(s==\"E\")return 4;\n\tif(s==\"F\")return 5;\n\tif(s==\"F#\")return 6;\n\tif(s==\"G\")return 7;\n\tif(s==\"G#\")return 8;\n\tif(s==\"A\")return 9;\n\tif(s==\"A#\")return 10;\n\tif(s==\"B\")return 11;\n\treturn -1;\n}\n\nbool isSame(vector<int> &a, vector<int> &b){\n\trep(i,a.size()){\n\t\tif(a[i]!=b[i+1])return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tint input;\n\tcin>>input;\n\trep(loop,input){\n\t\tint n,m;\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tvector<int> step,song;\n\t\tstep.pb(-1);\t//1-index???????????????\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstep.pb(f(s));\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong.pb(f(s));\n\t\t}\n\t\tsong.pb(-1);\t//????????????????°???????????????????\n\t\t\n\t\tvector<edge> G[50010];\n\t\trep(i,n)  G[i].pb( edge{(int)i+1,step[i+1]} );\n\t\trep(i,n)  G[i+1].pb( edge{(int)i,(step[i]-1+12)%12} );\n\t\trep(i,n-1)G[i].pb( edge{(int)i+2,(step[i+2]+1)%12} );\n\t\tG[n].pb(edge{n+1,-1});\n\t\tG[n-1].pb(edge{n+2,-1});\n\t\t\n\t\tbool f=true;\n\t\t\n\t\tqueue<pii> que;\n\t\tque.push(make_pair(0,0));\n\t\twhile(!que.empty()){\n\t\t\t\n\t\t\tif(que.front().second==m+1){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,G[que.front().first].size()){\n\t\t\t\tedge e = G[que.front().first][i];\n\t\t\t\tif(e.sound == song[que.front().second]){\n\t\t\t\t\tque.push(make_pair(e.to,que.front().second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t\tif(f) cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N,M;\nint T[50010];\nint S[50010];\n\nbool dfs(int n,int m){\n    if(m==M)return N-n<=2;\n    if((N-n+1)/2>M-m+1)return false;\n    if(n>0&&(T[n-1]+11)%12==S[m]&&dfs(n-1,m+1))return true;\n    if(n+1<N&&T[n+1]==S[m]&&dfs(n+1,m+1))return true;\n    if(n+2<N&&(T[n+2]+1)%12==S[m]&&dfs(n+2,m+1))return true;\n    return false;\n}\n\nint lis[]={9,11,0,2,4,5,7};\n\nchar t[3];\ninline int in(){\n    scanf(\"%s\",t);\n    return lis[t[0]-'A']+(t[1]=='#');\n}\n\nvoid solve(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,N)T[i]=in();\n    rep(i,M)S[i]=in();\n    for(int fin=N-2;fin<N;fin++){\n        bool ok=true;\n        int pos=fin;\n        for(int i=M-1;i>=0;i--){\n            if(pos<0||pos==N){\n                ok=false;\n                break;\n            }\n            if(T[pos]==S[i])pos--;\n            else if((T[pos]+1)%12==S[i])pos-=2;\n            else if((T[pos]+11)%12==S[i])pos++;\n            else{\n                ok=false;\n                break;\n            }\n        }\n        if(ok){\n            puts(\"Yes\");\n            return;\n        }\n    }\n    puts(\"No\");\n}\n\nsigned main(){\n    int T;scanf(\"%lld\",&T);\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM], melody[LIM];\nint S, N, M;\n\nint pos, num;\n\nbool dfs(void){\n    if(num == M) return pos == N;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        ++pos; ++num;\n        if(dfs()) return true;\n        --pos; --num;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        pos += 2; ++num;\n        if(dfs()) return true;\n        pos -= 2; --num;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        --pos; ++num;\n        if(dfs()) return true;\n        ++pos; --num;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair + N);\n        reverse(melody, melody + N);\n        bool res = false;\n        pos = 0; num = 0;\n        res = res || dfs();\n        pos = 1; num = 0;\n        res = res || dfs();\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\"  << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst string Chord[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nbool solve(int k, int p, const vector<string>& T, const vector<string>& S)\n{\n  if (k == 0) {\n    if (p == -1)\n      return true;\n    return false;\n  }\n\n  bool ret = false;\n  // k+1\n  if (S[p] == T[k])\n    ret |= solve(max(0, k-1), p-1, T, S);\n\n  // k+2\n  if (k-2 >= 0) {\n    for (int i = 0; i < 12; ++i) {\n      if (Chord[i] == T[k]) {\n        if (Chord[(i+1)%12] == S[p])\n          ret |= solve(max(0, k-2), p-1, T, S);\n        break;\n      }\n    }\n  }\n\n  // k-1\n  if (k+1 < (int)T.size()-1) {\n    for (int i = 0; i < 12; ++i) {\n      if (Chord[i] == T[k]) {\n        if (Chord[(12+i-1)%12] == S[p])\n          ret |= solve(k+1, p-1, T, S);\n        break;\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while  (T--) {\n    int n, m;\n    cin >> n >> m;\n    vector<string> t(n+2), s(m);\n    for (int i = 0; i < n; ++i)\n      cin >> t[i+1];\n    for (int i = 0; i < m; ++i)\n      cin >> s[i];\n\n    if (solve(n-1, m-1, t, s) || solve(n, m-1, t, s))\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    unordered_set<int> used;    \n    queue<Pii> q;\n    int now = -1;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      if(s != now && !used.empty() ) used.clear();\n      now = s;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n\n      //if ( used[s].count(t) ) continue;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif ( !used.count(t-1) ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used.insert(t-1);\n\t}\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif ( !used.count(t+1) ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used.insert(t+1);\n\t}\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif ( !used.count(t+2) ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used.insert(t+2);\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint T[50000];\nint S[50000];\n\nint main() {\n  string hoge[] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  map<string, int> mp;\n  REP(i,12) mp[hoge[i]] = i;\n  int NUM;\n  cin>>NUM;\n  while(NUM--) {\n    int n,m; cin >> n >> m;\n    REP(i,n) {\n      string s;cin >> s;\n      T[i] = mp[s];\n    }\n    REP(i,m) {\n      string s;cin>>s;\n      S[i] = mp[s];\n    }\n    queue<pii> Q;\n    Q.push(pii(-1,-1));\n    bool ok = 0;\n    map<pii, bool> visited;\n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      int a = p.first, b = p.second;\n      //cout << a << \" \" << b << endl;\n      if (visited[pii(a,b)]) continue;\n      visited[pii(a,b)] = 1;\n      if (a==n) {\n        if (b==m) {\n          ok = 1;\n          break;\n        }\n        continue;\n      }\n      if (a+1<=n) {\n        if (a+1==n || T[a+1]==S[b+1]) {\n          Q.push(pii(a+1,b+1));\n        }\n      }\n      if (a+2<=n) {\n        if (a+2==n || (T[a+2]+1)%12==S[b+1]) {\n          Q.push(pii(a+2,b+1));\n        }\n      }\n      if (a) {\n        if ((T[a-1]+11)%12==S[b+1]) {\n          Q.push(pii(a-1,b+1));\n        }\n      }\n    }\n    cout << (ok?\"Yes\":\"No\") << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nmap<string, int> onkai;\n\nint numOnkai = 0;\n\nbool isok(int curT, int curS, int n, vector<int>& t, vector<int>& s) {\n  while (curS >= 0 && curT >= 0 && curT < n) {\n//    cout << \"now:\" << curT << \",\"<< t[curT] <<\",\"<< s[curS] << endl;\n    if (t[curT] == s[curS]) {\n      curT--;\n    }\n    else if ((t[curT] + 1) % numOnkai == s[curS]) {\n      curT -= 2;\n    }\n    else if (t[curT] == (s[curS] + 1) % numOnkai) {\n      curT++;\n    }\n    else {\n      break;\n    }\n    curS--;\n  }\n  return curS == -1 && ( curT <= 1\n  );\n}\n\nbool solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> t(n);\n  vector<int> s(m);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    t[i] = onkai[s];\n  }\n  for (int i = 0; i < m; i++) {\n    string st;\n    cin >> st;\n    s[i] = onkai[st];\n  }\n  return isok(n-1, m-1, n, t, s) || n > 1 && isok(n-2, m-1, n, t, s);\n\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  int a=0;\n  onkai[\"C\"] = a++;\n  onkai[\"C#\"] = a++;\n  onkai[\"D\"] = a++;\n  onkai[\"D#\"] = a++;\n  onkai[\"E\"] = a++;\n  onkai[\"F\"] = a++;\n  onkai[\"F#\"] = a++;\n  onkai[\"G\"] = a++;\n  onkai[\"G#\"] = a++;\n  onkai[\"A\"] = a++;\n  onkai[\"A#\"] = a++;\n  onkai[\"B\"] = a++;\n  numOnkai = a;\n\n  for (int i = 0; i < n; i++) {\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int T;\n  cin>>T;\n  map<string,int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    int n,m;\n    cin>>n>>m;\n    vector<int> t(n+1,0),s(m);\n    for(int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n    if(0){\n      for(int i:s) cout<<i<<\" \";cout<<endl;\n      for(int i:t) cout<<i<<\" \";cout<<endl;\n    }\n    \n    auto check=[&](int x,int i){\n      return x+(m-i)*2>=n+1;\n    };\n    \n    bool flg=0;\n    vector<int> dp(1,0);\n    for(int i=0;i<=m;i++){\n      vector<int> nx;\n      for(int x: dp){\n\tif(i==m){\n\t  if(x+2>=n+1){\n\t    flg=1;\n\t    break;\n\t  }\n\t}else{\n\t  if(x+1<=n&&(t[x+1]==s[i]))\n\t    if(check(x+1,i)) nx.emplace_back(x+1);\n\t  if(x+2<=n&&(t[x+2]==(s[i]+11)%12))\n\t    if(check(x+2,i))nx.emplace_back(x+2);\n\t  if(x-1>=0&&(t[x-1]==(s[i]+1)%12))\n\t    if(check(x-1,i)) nx.emplace_back(x-1);\n\t}\n      }\n      sort(nx.begin(),nx.end());\n      nx.erase(unique(nx.begin(),nx.end()),nx.end());\n      if(0){\n\tcout<<i<<\":\"<<endl;\n\tfor(int x:nx) cout<<x<<\" \";cout<<endl;\n      }\n      swap(dp,nx);\n    }\n      cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N, M;\nint step[50001];\nint song[50001];\nstring note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\nint getidx(string s){\n  REP(i, 12)if(s == note[i]) return i;\n  return -1;\n}\nbool dfs(int p, int idx){\n  if(idx == M) return (p == N - 1 || p == N - 2) ;\n  int d[3] = {-1, 1, 2};\n  int dif[3] = {-1, 0, 1};\n  REP(r, 3){\n    int np = p + d[r];\n    if(np >= 0 && np < N && (step[np] + dif[r] + 12) % 12 == song[idx] && dfs(np, idx + 1)){\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    cin>>N>>M;\n    REP(i, N){\n      string s; cin>>s;\n      step[i] = getidx(s);\n      assert(step[i] != -1);\n    }\n    REP(i, M){\n      string s; cin>>s;\n      song[i] = getidx(s);\n    }\n    bool ans = dfs(-1, 0);\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int T;\n  cin>>T;\n  map<string,Int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(Int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    Int n,m;\n    cin>>n>>m;\n    vector<Int> t(n+1,0),s(m);\n    for(Int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(Int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n\n    vector<Int> dp(1,n+1);\n    for(Int i=m;i>=0;i--){\n      vector<Int> nx;\n      for(Int x: dp){\n\tif(x-1>=0&&(i==m||t[x]==s[i])) nx.emplace_back(x-1);\n\tif(x-2>=0&&(i==m||t[x]==(s[i]+11)%12)) nx.emplace_back(x-2);\n\tif(x+1<=n&&(i==m||t[x]==(s[i]+1)%12)) nx.emplace_back(x+1);\n      }\n      sort(nx.begin(),nx.end());\n      nx.erase(unique(nx.begin(),nx.end()),nx.end());\n      swap(dp,nx);\n      if(dp.empty()) break;\n    }\n    \n    cout<<(!dp.empty()&&dp.front()==0?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MAXN = 50005;\nconst int MAXM = 50005;\nconst string str[12] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n \nmap<string, int> id;\nint n, m;\nint T[MAXN], S[MAXM];\n \nbool rec(int k, int p) {\n  if((m - p) * 2 < (n - 1) - k) return false;\n  if(p == m) return (n + 1) - k <= 2;\n  if(k-1 > 0 && (T[k-1]+11)%12 == S[p] && rec(k-1, p+1)) return true;\n  if(k+1 < n+1 && (T[k+1]+0)%12 == S[p] && rec(k+1, p+1)) return true;\n  if(k+2 < n+1 && (T[k+2]+1)%12 == S[p] && rec(k+2, p+1)) return true;\n  return false;\n}\n \nint main() {\n  for(int i = 0; i < 12; ++i) id[str[i]] = i;\n \n  int Tc; cin >> Tc;\n  while(Tc--) {\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i) {\n      string s; cin >> s;\n      T[i+1] = id[s];\n    }\n    for(int i = 0; i < m; ++i) {\n      string s; cin >> s;\n      S[i] = id[s];\n    }\n    cout << (rec(0, 0) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint n,m;\nint t[50010],s[50010];\nbool f;\n\nint oct(string x){\n  if(x == \"C\") return 0;\n  if(x == \"C#\")return 1;\n  if(x == \"D\") return 2;\n  if(x == \"D#\")return 3;\n  if(x == \"E\") return 4;\n  if(x == \"F\") return 5;\n  if(x == \"F#\")return 6;\n  if(x == \"G\") return 7;\n  if(x == \"G#\")return 8;\n  if(x == \"A\") return 9;\n  if(x == \"A#\")return 10;\n  if(x == \"B\") return 11;\n  else return 12;\n}\n\nvoid rec(int stair,int music){\n  if(music<0){\n    if(stair==-1)f = true;\n    return;\n  }\n  if(stair<0 || n-1<stair)return;\n\n  int o = s[music];\n  if(o==t[stair])rec(stair-1,music-1);\n  if(o==(t[stair]+1)%12)rec(stair-2,music-1);\n  if(o==(t[stair]+11)%12)rec(stair+1,music-1);\n}\n\nint main(){\n\n  int casenum;\n  string tmp;\n\n  cin >> casenum;\n\n  while(casenum--){\n    cin >> n >> m;\n    for(int i=0;i<n;i++){\n      cin >> tmp;\n      t[i] = oct(tmp);\n    }\n\n    for(int i=0;i<m;i++){\n      cin >> tmp;\n      s[i] = oct(tmp);\n    }\n\n    f = false;\n    rec(n-1,m-1);\n    if(!f)rec(n-2,m-1);\n\n    if(f)cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <map>\n\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n    map<string, int> m;\n    m[\"C\"] = 0;\n    m[\"C#\"] = 1;\n    m[\"D\"] = 2;\n    m[\"D#\"] = 3;\n    m[\"E\"] = 4;\n    m[\"F\"] = 5;\n    m[\"F#\"] = 6;\n    m[\"G\"] = 7;\n    m[\"G#\"] = 8;\n    m[\"A\"] = 9;\n    m[\"A#\"] = 10;\n    m[\"B\"] = 11;\n    \n    int t;\n    cin >> t;\n\n    for (int i = 0; i < t; i++) {\n\tint n, M;\n\tcin >> n >> M;\n\n\tvector<int> flr(n);\n\tvector<int> sng(M);\n\tfor (int j = 0; j < n; j++) {\n\t    string str;\n\t    cin >> str;\n\t    flr[j] = m[str];\n\t}\n\tfor (int j = 0; j < M; j++) {\n\t    string str;\n\t    cin >> str;\n\t    sng[j] = m[str];\n\t}\n\n\tbool flag = true;\n\tint pt = n-1;\n\tfor (int j = M-1; j >= 0; j--) {\n\t    if (pt < 0) {\n\t\tflag = false;\n\t\tbreak;\n\t    }\n\n\t    int dif = sng[j] - flr[pt];\n\n\t    if (dif == 0) {\n\t\tpt--;\n\t    } else if (dif == 1 || dif == -11) {\n\t\tpt -= 2;\n\t    } else if (dif == -1 || dif == 11) {\n\t\tpt++;\n\t    } else {\n\t\tflag = false;\n\t\tbreak;\n\t    }\n\n\t    if (pt >= n || pt < -1) {\n\t\tflag = false;\n\t\tbreak;\n\t    }\n\t}\n\n\tbool flag2 = true;\n\tpt = n-2;\n\tfor (int j = M-1; j >= 0; j--) {\n\t    if (pt < 0) {\n\t\tflag2 = false;\n\t\tbreak;\n\t    }\n\n\t    int dif = sng[j] - flr[pt];\n\n\t    if (dif == 0) {\n\t\tpt--;\n\t    } else if (dif == 1 || dif == -11) {\n\t\tpt -= 2;\n\t    } else if (dif == -1 || dif == 11) {\n\t\tpt++;\n\t    } else {\n\t\tflag2 = false;\n\t\tbreak;\n\t    }\n\n\t    if (pt >= n || pt < -1) {\n\t\tflag2 = false;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (flag || flag2) {\n\t    cout << \"Yes\" << endl;\n\t} else {\n\t    cout << \"No\" << endl;\n\t}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50000;\nconst int MAX_M = 50000;\n\nconst int NSC = 12;\n\nconst string scs[NSC] = {\n  \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"\n};\n\n/* typedef */\n\ntypedef map<string,int> msi;\n\n/* global variables */\n\nmsi scmap;\nint n, m;\nint tis[MAX_N + 1], sis[MAX_M + 1];\n\n/* subroutines */\n\ninline int mod(int k) { return (k + NSC) % NSC; }\n\nbool check(int ti) {\n  for (int si = m - 1; si >= 0; si--) {\n    int& t = tis[ti];\n    int& s = sis[si];\n\n    if (t == s) ti--;\n    else if (mod(t + 1) == s) ti -= 2;\n    else if (mod(t - 1) == s) ti++;\n    else return false;\n  }\n\n  return (ti == -1);\n}\n\n/* main */\n\nint main() {\n  for (int i = 0; i < NSC; i++) scmap[scs[i]] = i;\n\n  int tn;\n  cin >> tn;\n\n  while (tn--) {\n    cin >> n >> m;\n    string sc;\n    \n    for (int i = 0; i < n; i++) {\n      cin >> sc;\n      tis[i] = scmap[sc];\n    }\n\n    for (int i = 0; i < m; i++) {\n      cin >> sc;\n      sis[i] = scmap[sc];\n    }\n\n    bool ok = check(n - 1) || check(n - 2);\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\n\nint main() {\n    srand((unsigned)time(NULL));\n    \n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    chrono::system_clock::time_point start=chrono::system_clock::now();\n    auto calcTime=[&](){\n      chrono::system_clock::time_point end = chrono::system_clock::now();\n      return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n    };\n    //  cout<<calcTime()<<endl;\n    \n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<5000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    \n    if(calcTime()>=5000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 500001\n\nusing namespace std;\n\nmap<string,int> getIndex;\nint t,s;\nbool found;\nint T[MAX],S[MAX];\nstring type[12] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\nint dc[] = {+0,+1,-1};\nint dx[] = {-1,-2,+1};\n\nvoid dfs(int cur_t,int cur_s)\n{\n  if(cur_s < 0)\n    {\n      if(cur_t == -1)found = true;\n      return;\n    }\n\n  rep(i,3)\n    {\n      int music = (T[cur_t] + dc[i] + 12)%12;\n      if(t <= cur_t+dx[i])continue;\n\n      if(music == S[cur_s])dfs(cur_t+dx[i],cur_s-1);\n    }\n}\n\nbool compute()\n{\n  found = false;\n  dfs(t-1,s-1);\n  if(!found)dfs(t-2,s-1);\n  return found;\n}\n\nint main()\n{\n  rep(i,12)getIndex[type[i]] = i;\n  int N;\n  while(cin >> N)\n    {\n      while(N--)\n\t{\n\n\t  cin >> t >> s;\n\t  string input;\n\t  rep(i,t)\n\t    {\n\t      cin >> input;\n\t      T[i] = getIndex[input];\n\t    }\n\t  rep(i,s)\n\t    {\n\t      cin >> input;\n\t      S[i] = getIndex[input];\n\t    }\n\t  cout << (compute()?\"Yes\":\"No\") << endl;\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nstring S[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\nint N, M, SLEN = 12;\nmap<string, int> strtoi;\nvector<int> v, vv;\nbool f = false;\n\nvoid dfs(int cnt, int now){\n  int n = v[now];\n  if(cnt < M && now == 0) return ;\n  if(cnt >= M) { if(now == 0) f = true; return ; }\n  //cout <<cnt <<\", \" <<now <<\", \" <<S[n] <<endl;\n  //cout <<\"    \" <<S[(vv[cnt] - 1 + SLEN) % SLEN] <<\", \" <<S[vv[cnt]] <<\", \" <<S[(vv[cnt] + 1) % SLEN] <<endl;\n  if(vv[cnt] == n && now - 1 >= 0) dfs(cnt + 1, now - 1);\n  if((vv[cnt] + 1) % SLEN == n && now + 1 < N + 1) dfs(cnt + 1, now + 1);\n  if((vv[cnt] - 1 + SLEN) % SLEN == n && now - 2 >= 0) dfs(cnt + 1, now - 2);\n}\n\nint main() {\n  REP(i, SLEN) strtoi[S[i]] = i;\n  int T; cin >>T;\n  while(T--){\n    f = false;\n    cin >>N >>M;\n    v = vector<int>(N + 1);\n    vv = vector<int>(M);\n    FOR(i, 1, N + 1){\n      string s; cin >>s;\n      v[i] = strtoi[s];\n    }\n    REP(i, M){\n      string s; cin >>s;\n      vv[i] = strtoi[s];\n    }\n    REVERSE(vv);\n    dfs(0, N);\n    if(!f) dfs(0, N - 1);\n    cout <<(f ? \"Yes\" : \"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nmap<string, int> onkai;\n\nint numOnkai = 0;\n\nbool isok(int curT, int curS, int n, vector<int>& t, vector<int>& s) {\n  while (curS >= 0) {\n//    cout << \"now:\" << curT << \",\"<< t[curT] <<\",\"<< s[curS] << endl;\n    if (t[curT] == s[curS] && (curT > 0 || curS == 0 && curT == 0)) {\n      curT--;\n    }\n    else if ((t[curT] + 1) % numOnkai == s[curS] && (curT > 1 || curS == 0 && curT == 1)) {\n      curT -= 2;\n    }\n    else if (t[curT] == (s[curS] + 1) % numOnkai && curT < n) {\n      curT++;\n    }\n    else {\n      break;\n    }\n    curS--;\n  }\n  return curS == -1;\n}\n\nbool solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> t(n);\n  vector<int> s(m);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    t[i] = onkai[s];\n  }\n  for (int i = 0; i < m; i++) {\n    string st;\n    cin >> st;\n    s[i] = onkai[st];\n  }\n  return isok(n-1, m-1, n, t, s) || isok(n-2, m-1, n, t, s);\n\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  int a=0;\n  onkai[\"C\"] = a++;\n  onkai[\"C#\"] = a++;\n  onkai[\"D\"] = a++;\n  onkai[\"D#\"] = a++;\n  onkai[\"E\"] = a++;\n  onkai[\"F\"] = a++;\n  onkai[\"F#\"] = a++;\n  onkai[\"G\"] = a++;\n  onkai[\"G#\"] = a++;\n  onkai[\"A\"] = a++;\n  onkai[\"A#\"] = a++;\n  onkai[\"B\"] = a++;\n  numOnkai = a;\n\n  for (int i = 0; i < n; i++) {\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint unko() {\n\tstring s; cin >> s;\n\tif (s == \"C\") return 0;\n\tif (s == \"C#\") return 1;\n\tif (s == \"D\") return 2;\n\tif (s == \"D#\") return 3;\n\tif (s == \"E\") return 4;\n\tif (s == \"F\") return 5;\n\tif (s == \"F#\") return 6;\n\tif (s == \"G\") return 7;\n\tif (s == \"G#\") return 8;\n\tif (s == \"A\") return 9;\n\tif (s == \"A#\") return 10;\n\tif (s == \"B\") return 11;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, m; cin >> n >> m;\n\t\tvector<int> a(n), b(m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = unko();\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tb[j] = unko();\n\t\tvector<int> i(2);\n\t\ti[0] = n - 1; i[1] = max(0, n - 2);\n\t\tfor (int j = m - 1; j >= 0; j--) {\n\t\t\tint x = b[j];\n\t\t\t//cout << i[0] << ' ' << i[1] << endl;\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tif (i[k] == -2 || i[k] == -1 || i[k] == n) {\n\t\t\t\t\ti[k] = -2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint y = a[i[k]];\n\t\t\t\tif (x == y) i[k]--;\n\t\t\t\telse if (x == (y + 1) % 12) i[k] -= 2;\n\t\t\t\telse if (x == (y + 11) % 12) i[k]++;\n\t\t\t\telse i[k] = -2;\n\t\t\t}\n\t\t}\n\t\tif (i[0] == -1 || i[1] == -1) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {1,-1,-2};\nconst static int offset[] = {11,0,1};\nvector<int> stair;\nvector<int> song;\n\nbool dfs(int note_pos,int stair_pos){\n  if(note_pos == -1 && stair_pos == -1){\n    return true;\n  }\n  else if(stair_pos < 0 || note_pos < 0) return false;\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    if(song[note_pos] != (stair[stair_pos] + offset[i]) % 12) continue;\n    int next = stair_pos + idx2dist[i];\n    res |= dfs(note_pos - 1,next);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      stair.clear();\n      song.clear();\n\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",(dfs(song.size()-1,stair.size()-2)\n                     || dfs(song.size()-1,stair.size()-1)) \n             ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ninline int f(const char *s){\n\tif(s[0]=='C' && s[1]=='\\0') return 0;\n\tif(s[0]=='C' && s[1]=='#' ) return 1;\n\tif(s[0]=='D' && s[1]=='\\0') return 2;\n\tif(s[0]=='D' && s[1]=='#' ) return 3;\n\tif(s[0]=='E' && s[1]=='\\0') return 4;\n\tif(s[0]=='F' && s[1]=='\\0') return 5;\n\tif(s[0]=='F' && s[1]=='#' ) return 6;\n\tif(s[0]=='G' && s[1]=='\\0') return 7;\n\tif(s[0]=='G' && s[1]=='#' ) return 8;\n\tif(s[0]=='A' && s[1]=='\\0') return 9;\n\tif(s[0]=='A' && s[1]=='#' ) return 10;\n\treturn 11;\n}\n\ninline int dist(int t1,int t2){ return (t1-t2+12)%12; }\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n,m; scanf(\"%d%d\",&n,&m);\n\t\tstatic int t[50000],s[50000];\n\t\trep(i,n){ char in[3]; scanf(\"%s\",in); t[i]=f(in); }\n\t\trep(i,m){ char in[3]; scanf(\"%s\",in); s[i]=f(in); }\n// rep(i,n) printf(\"%2d \",t[i]); puts(\"\");\n// rep(i,m) printf(\"%2d \",s[i]); puts(\"\");\n\n\t\tif(dist(s[m-1],t[n-1])<=1 || dist(s[m-1],t[n-1])==11){\n// puts(\"hoge1\");\n\t\t\tint pos=n-1;\n\t\t\tint i;\n\t\t\tfor(i=m-1;i>=0;i--){\n\t\t\t\tint d=dist(s[i],t[pos]);\n\t\t\t\tif     (d== 0) pos--;\n\t\t\t\telse if(d== 1) pos-=2;\n\t\t\t\telse if(d==11) pos++;\n\t\t\t\telse break;\n\n\t\t\t\tif(i==0 && (pos<-1 || n<=pos)\n\t\t\t\t|| i!=0 && (pos< 0 || n<=pos)) break;\n\t\t\t}\n\n\t\t\tif(i==-1 && pos==-1) goto FOUND;\n\t\t}\n\n\t\tif(n-2>=0 && (dist(s[m-1],t[n-2])<=1 || dist(s[m-1],t[n-2])==11)){\n// puts(\"hoge2\");\n\t\t\tint pos=n-2;\n\t\t\tint i;\n\t\t\tfor(i=m-1;i>=0;i--){\n\t\t\t\tint d=dist(s[i],t[pos]);\n\t\t\t\tif     (d== 0) pos--;\n\t\t\t\telse if(d== 1) pos-=2;\n\t\t\t\telse if(d==11) pos++;\n\t\t\t\telse break;\n\n\t\t\t\tif(i==0 && (pos<-1 || n<=pos)\n\t\t\t\t|| i!=0 && (pos< 0 || n<=pos)) break;\n\t\t\t}\n\n\t\t\tif(i==-1 && pos==-1) goto FOUND;\n\t\t}\n\n\t\tputs(\"No\");\n\t\tcontinue;\n\n\t\tFOUND:\n\t\tputs(\"Yes\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst string Chord[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nbool solve(int k, int p, const vector<string>& T, const vector<string>& S)\n{\n  if (k < 0) {\n    if (p == -1)\n      return true;\n    return false;\n  }\n\n  if (k >= (int)T.size() || p < 0)\n    return false;\n\n  bool ret = false;\n  // k+1\n  if (S[p] == T[k])\n    ret |= solve(k-1, p-1, T, S);\n\n  // k+2\n  for (int i = 0; i < 12; ++i) {\n    if (Chord[i] == T[k]) {\n      if (Chord[(i+1)%12] == S[p])\n        ret |= solve(k-2, p-1, T, S);\n      break;\n    }\n  }\n\n  // k-1\n  for (int i = 0; i < 12; ++i) {\n    if (Chord[i] == T[k]) {\n      if (Chord[(12+i-1)%12] == S[p])\n        ret |= solve(k+1, p-1, T, S);\n      break;\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while  (T--) {\n    int n, m;\n    cin >> n >> m;\n    vector<string> t(n), s(m);\n    for (int i = 0; i < n; ++i)\n      cin >> t[i];\n    for (int i = 0; i < m; ++i)\n      cin >> s[i];\n\n    if (solve(n-1, m-1, t, s) || solve(n-2, m-1, t, s))\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct edge{int to,sound;};\n\nint f(string s){\n\tif(s==\"C\")return 0;\n\tif(s==\"C#\")return 1;\n\tif(s==\"D\")return 2;\n\tif(s==\"D#\")return 3;\n\tif(s==\"E\")return 4;\n\tif(s==\"F\")return 5;\n\tif(s==\"F#\")return 6;\n\tif(s==\"G\")return 7;\n\tif(s==\"G#\")return 8;\n\tif(s==\"A\")return 9;\n\tif(s==\"A#\")return 10;\n\tif(s==\"B\")return 11;\n\treturn -1;\n}\n\nbool isSame(vector<int> &a, vector<int> &b){\n\trep(i,a.size()){\n\t\tif(a[i]!=b[i+1])return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tint input;\n\tcin>>input;\n\trep(loop,input){\n\t\tint n,m;\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tvector<int> step,song;\n\t\tstep.pb(-1);\t//1-index???????????????\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstep.pb(f(s));\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong.pb(f(s));\n\t\t}\n\t\tsong.pb(-1);\t//????????????????°???????????????????\n\t\t\n\t\tvector<edge> G[50010];\n\t\trep(i,n)  G[i].pb( edge{(int)i+1,step[i+1]} );\n\t\trep(i,n)  G[i+1].pb( edge{(int)i,(step[i]-1+12)%12} );\n\t\trep(i,n-1)G[i].pb( edge{(int)i+2,(step[i+2]+1)%12} );\n\t\tG[n].pb(edge{n+1,-1});\n\t\tG[n-1].pb(edge{n+2,-1});\n\t\t\n\t\tbool f=true;\n\t\t\n\t\tqueue<pii> que;\n\t\tque.push(make_pair(0,0));\n\t\twhile(!que.empty()){\n\t\t\tint pos = que.front().first;\n\t\t\tint num = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(n+1-pos>2*(m+1-num))continue;\n\t\t\t\n\t\t\tif(num==m+1){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e = G[pos][i];\n\t\t\t\tif(e.sound == song[num]){\n\t\t\t\t\tque.push(make_pair(e.to,num+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);    \n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nconst static int offset[] = {11,0,1};\n\nint dfs(int note_pos,int stair_pos,\n        const vector<int>& stair,const vector<int>& song){\n\n  if(stair_pos + 2 * (song.size() - note_pos) < stair.size() - 2){\n    return false;\n  }\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int dist = idx2dist[i];\n    \n    int next = stair_pos + dist;\n    if(next < 0) continue;\n    if(next >= stair.size()) continue;\n    \n    if(song[note_pos + 1] != (stair[next] + offset[i]) % 12) continue;\n    res |= dfs(note_pos + 1,next,stair,song);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1,stair,song) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 50005;\nconst int MAXM = 50005;\nconst string str[12] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n\nmap<string, int> id;\nint n, m;\nint T[MAXN], S[MAXM];\n\nbool rec(int k, int p) {\n  if((m - p) * 2 < (n - 1) - k) return false;\n  if(p == m) return (n + 1) - k <= 2;\n  if(k-1 > 0 && (T[k-1]+11)%12 == S[p] && rec(k-1, p+1)) return true;\n  if(k+1 < n+1 && (T[k+1]+0)%12 == S[p] && rec(k+1, p+1)) return true;\n  if(k+2 < n+1 && (T[k+2]+1)%12 == S[p] && rec(k+2, p+1)) return true;\n  return false;\n}\n\nint main() {\n  for(int i = 0; i < 12; ++i) id[str[i]] = i;\n\n  int Tc; cin >> Tc;\n  while(Tc--) {\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i) {\n      string s; cin >> s;\n      T[i+1] = id[s];\n    }\n    for(int i = 0; i < m; ++i) {\n      string s; cin >> s;\n      S[i] = id[s];\n    }\n    cout << (rec(0, 0) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);    \n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t == n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\n\nchar* o[] = { \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\nint to_n()\n{\n\tchar s[32];\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < 12; ++i)\n\t\tif (strcmp(s, o[i]) == 0)\n\t\t\treturn i;\n}\nint n, m;\nint t[51111], s[51111];\nbool dfs(int stair, int p)\n{\n\tif (stair > n)\n\t\treturn p == m + 1;\n\telse if (p == m + 1 || p != 0 && stair <= 0)\n\t\treturn false;\n\n\tif (n + 1 - stair > 2 * (m + 1 - p))\n\t\treturn false;\n\n\tstatic const int dir[] = { 1, 2, -1 };\n\tstatic const int diff[] = { 0, 1, -1 };\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tint to = stair + dir[i];\n\t\tif (to > 0 && ((t[to] + diff[i] + 12) % 12 == s[p] || to > n)\n\t\t\t&& dfs(to, p + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tt[i] = to_n();\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\ts[i] = to_n();\n\n\t\tputs(dfs(0, 0) ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM], melody[LIM];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(pos >= N && num == M) return true;\n    bool ret = false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        ret = ret || dfs(pos+1, num+1);\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        ret = ret || dfs(pos+2, num+1);\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        ret = ret || dfs(pos-1, num+1);\n    }\n    return ret;\n}\n\nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair+N);\n        reverse(melody, melody+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\nchrono::system_clock::time_point start;\ndouble calcTime(){\n  chrono::system_clock::time_point end = chrono::system_clock::now();\n  return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n}\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    start=chrono::system_clock::now();\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<2000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    srand((unsigned)time(NULL));\n    \n    if(calcTime()>=2000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar step[50001];\nchar music[50001];\nint n,m;\n\nint hash(char *str){\nint val=0;\nswitch(str[0]){\ncase 'A':val=0;break;\ncase 'B':val=2;break;\ncase 'C':val=3;break;\ncase 'D':val=5;break;\ncase 'E':val=7;break;\ncase 'F':val=8;break;\ncase 'G':val=10;break;\n}\nif(str[1]=='#')\nval++;\nreturn val;\n}\n\nint keisan(int nowstep,int nowmusic){\nint next=music[nowmusic+1];\nint a=0;\nif(nowmusic==m){\nif(nowstep + 2 > n){\nreturn 1;\n}else{\nreturn 0;\n}\n}\n\nif(nowstep > 1){\nif(next == (step[nowstep-1]-1+12)%12){\na=keisan(nowstep-1,nowmusic+1);\nif(a==1){\nreturn 1;\n}\n}\n}\nif(nowstep < n){\nif(next == (step[nowstep+1]+12)%12){\na=keisan(nowstep+1,nowmusic+1);\nif(a==1){\nreturn 1;\n}\n}\n}\nif(nowstep + 1 < n){\nif(next == (step[nowstep+2]+1+12)%12){\na=keisan(nowstep+2,nowmusic+1);\nif(a==1){\nreturn 1;\n}\n}\n}\n\nreturn 0;\n}\n\nint main(void){\nint qu,i,j,p;\nchar str[3];\nscanf(\"%d\",&qu);\nfor(p=0;p<qu;p++){\nscanf(\"%d%d\",&n,&m);\nfor(i=1;i<=n;i++){\nscanf(\"%s\",str);\nstep[i]=hash(str);\n}\nfor(i=1;i<=m;i++){\nscanf(\"%s\",str);\nmusic[i]=hash(str);\n}\n\ncout<<keisan(0,0)<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  int stair_pos;\n  int note_pos;\n  int cost;\n  State(int stair_pos,int note_pos,int cost) :\n    stair_pos(stair_pos),note_pos(note_pos), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nmap<string,int> note2idx;\nstring idx2note[] = {\n  \"C\",\n  \"C#\",\n  \"D\",\n  \"D#\",\n  \"E\",\n  \"F\",\n  \"F#\",\n  \"G\",\n  \"G#\",\n  \"A\",\n  \"A#\",\n  \"B\"\n};\n\nmap<int,bool> dp[50001];\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<string> stair;\n      vector<string> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note);\n      }\n\n      priority_queue<State> que;\n      que.push(State(-1,-1,0));\n\n      bool isok = false;\n      while(!que.empty()){\n        State s = que.top();\n        que.pop();\n\n        if(s.note_pos == song_length - 1\n           && s.stair_pos >= num_of_steps - 2){\n          isok = true;\n          break;\n        }\n        for(int dist = -1; dist <= 2; dist++){\n          if(dist == 0) continue;\n\n          int next = s.stair_pos + dist;\n          if(next < 0) continue;\n          if(next >= num_of_steps) continue;\n\n          int offset = 0;\n          if(dist == -1) offset = 12 - 1;\n          if(dist == 2) offset = 1;\n          if(song[s.note_pos + 1] != idx2note[(note2idx[stair[next]] + offset) % 12]) continue;\n          if(dp[s.note_pos + 1].find(next) != dp[s.note_pos + 1].end()) continue;\n          dp[s.note_pos + 1][next] = true;\n          que.push(State(next,s.note_pos + 1,s.cost + 1));\n        }\n      }\n      printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ninline int f(const char *s){\n\tif(s[0]=='C' && s[1]=='\\0') return 0;\n\tif(s[0]=='C' && s[1]=='#' ) return 1;\n\tif(s[0]=='D' && s[1]=='\\0') return 2;\n\tif(s[0]=='D' && s[1]=='#' ) return 3;\n\tif(s[0]=='E' && s[1]=='\\0') return 4;\n\tif(s[0]=='F' && s[1]=='\\0') return 5;\n\tif(s[0]=='F' && s[1]=='#' ) return 6;\n\tif(s[0]=='G' && s[1]=='\\0') return 7;\n\tif(s[0]=='G' && s[1]=='#' ) return 8;\n\tif(s[0]=='A' && s[1]=='\\0') return 9;\n\tif(s[0]=='A' && s[1]=='#' ) return 10;\n\treturn 11;\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n,m; scanf(\"%d%d\",&n,&m);\n\t\tstatic int t[50000],s[50000];\n\t\trep(i,n){ char in[3]; scanf(\"%s\",in); t[i]=f(in); }\n\t\trep(i,m){ char in[3]; scanf(\"%s\",in); s[i]=f(in); }\n\n\t\tif(-1<=s[m-1]-t[n-1] && s[m-1]-t[n-1]<=1){\n\t\t\tint pos=n-1;\n\t\t\tint i;\n\t\t\tfor(i=m-1;i>=0;i--){\n\t\t\t\tint dif=(s[i]-t[pos]+12)%12;\n\t\t\t\tif     (dif== 0) pos--;\n\t\t\t\telse if(dif== 1) pos-=2;\n\t\t\t\telse if(dif==11) pos++;\n\t\t\t\telse break;\n\n\t\t\t\tif(i==0 && (pos<-1 || n<=pos)\n\t\t\t\t|| i!=0 && (pos< 0 || n<=pos)) break;\n\t\t\t}\n\n\t\t\tif(i==-1 && pos==-1) goto FOUND;\n\t\t}\n\n\t\tif(n-2>=0 && -1<=s[m-1]-t[n-2] && s[m-1]-t[n-2]<=1){\n\t\t\tint pos=n-2;\n\t\t\tint i;\n\t\t\tfor(i=m-1;i>=0;i--){\n\t\t\t\tint dif=(s[i]-t[pos]+12)%12;\n\t\t\t\tif     (dif== 0) pos--;\n\t\t\t\telse if(dif== 1) pos-=2;\n\t\t\t\telse if(dif==11) pos++;\n\t\t\t\telse break;\n\n\t\t\t\tif(i==0 && (pos<-1 || n<=pos)\n\t\t\t\t|| i!=0 && (pos< 0 || n<=pos)) break;\n\t\t\t}\n\n\t\t\tif(i==-1 && pos==-1) goto FOUND;\n\t\t}\n\n\t\tputs(\"No\");\n\t\tcontinue;\n\n\t\tFOUND:\n\t\tputs(\"Yes\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n,m;\nvi a,b;\nbool f(int s,int t){\n\tif(t==m){\n\t\tif(n-2<=s)return true;\n\t\treturn false;\n\t}\n\tint r=s+1;\n\tif(r!=n){\n\t\tif(b[t]==a[r]&&f(r,t+1))return true;\n\t}\n\tr=s+2;\n\tif(r<n){\n\t\tif(b[t]==(a[r]+1)%12&&f(r,t+1))return true;\n\t}\n\tr=s-1;\n\tif(r>=0){\n\t\tif(b[t]==(a[r]+11)%12&&f(r,t+1))return true;\n\t}\n\treturn false;\n}\nint main(){\n\tmap<string,int>M;\n\tM[\"A\"]=0;\n\tM[\"A#\"]=1;\n\tM[\"B\"]=2;\n\tM[\"C\"]=3;\n\tM[\"C#\"]=4;\n\tM[\"D\"]=5;\n\tM[\"D#\"]=6;\n\tM[\"E\"]=7;\n\tM[\"F\"]=8;\n\tM[\"F#\"]=9;\n\tM[\"G\"]=10;\n\tM[\"G#\"]=11;\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>n>>m;\n\t\ta=vi(n);\n\t\tb=vi(m);\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\ta[i]=M[s];\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tb[i]=M[s];\n\t\t}\n\t\tif(f(-1,0))cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nconst static int offset[] = {11,0,1};\nvector<int> stair;\nvector<int> song;\n\nint dfs(int note_pos,int stair_pos){\n\n  if(stair_pos + 2 * (song.size() - note_pos) < stair.size() - 2){\n    return false;\n  }\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int next = stair_pos + idx2dist[i];\n    if(next < 0 || next >= stair.size()) continue;\n    if(song[note_pos + 1] != (stair[next] + offset[i]) % 12) continue;\n    res |= dfs(note_pos + 1,next);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      stair.clear();\n      song.clear();\n\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 12\ntypedef vector<int> Vec;\n\nint N,M;\n\nbool rec(int idxT,int idxS,Vec &T,Vec &S){\n    if(idxT == N && idxS == M) return 1;\n    if(idxT == N || idxS == M) return 0;\n    bool res = false;\n    if(idxT+1 <= N && T[idxT] == S[idxS]){\n        res |= rec(idxT+1,idxS+1,T,S);\n    }\n    if(idxT+2 <= N && (T[idxT]+1)%MOD == S[idxS]){\n        res |= rec(idxT+2,idxS+1,T,S);\n    }\n    if(idxT-1 >= 0 && (T[idxT]-1+MOD)%MOD == S[idxS]){\n        res |= rec(idxT-1,idxS+1,T,S);\n    }\n    return res;\n}\n\nint main(){\n    int Tc;\n    map<string,int> mp = {\n        {\"A\",0},{\"A#\",1},\n        {\"B\",2},\n        {\"C\",3},{\"C#\",4},\n        {\"D\",5},{\"D#\",6},\n        {\"E\",7},\n        {\"F\",8},{\"F#\",9},\n        {\"G\",10},{\"G#\",11},\n    };\n    string in;\n    cin >> Tc;\n    while(Tc--){\n        cin >> N >> M;\n        Vec T(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            T[i] = mp[in];\n        }\n        reverse(T.begin(),T.end());\n        Vec S(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> in;\n            S[i] = mp[in];\n        }\n        reverse(S.begin(),S.end());\n        bool can = rec(0,0,T,S) | rec(1,0,T,S);\n        cout << (can ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    chrono::system_clock::time_point start=chrono::system_clock::now();\n    auto calcTime=[&](){\n      chrono::system_clock::time_point end = chrono::system_clock::now();\n      return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n    };\n    //  cout<<calcTime()<<endl;\n    \n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<5000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    srand((unsigned)time(NULL));\n    \n    if(calcTime()>=5000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nmap<string, int> onkai;\n\nint numOnkai = 0;\n\nbool isok(int curT, int curS, int n, vector<int>& t, vector<int>& s) {\n  while (curS >= 0 && curT >= 0 && curT < n) {\n//    cout << \"now:\" << curT << \",\"<< t[curT] <<\",\"<< s[curS] << endl;\n    if (t[curT] == s[curS]) {\n      curT--;\n    }\n    else if ((t[curT] + 1) % numOnkai == s[curS]) {\n      curT -= 2;\n    }\n    else if (t[curT] == (s[curS] + 1) % numOnkai) {\n      curT++;\n    }\n    else {\n      break;\n    }\n    curS--;\n  }\n  return curS == -1 && ( curT == -1\n  );\n}\n\nbool solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> t(n);\n  vector<int> s(m);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    t[i] = onkai[s];\n  }\n  for (int i = 0; i < m; i++) {\n    string st;\n    cin >> st;\n    s[i] = onkai[st];\n  }\n  return isok(n-1, m-1, n, t, s) || n > 1 && isok(n-2, m-1, n, t, s);\n\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  int a=0;\n  onkai[\"C\"] = a++;\n  onkai[\"C#\"] = a++;\n  onkai[\"D\"] = a++;\n  onkai[\"D#\"] = a++;\n  onkai[\"E\"] = a++;\n  onkai[\"F\"] = a++;\n  onkai[\"F#\"] = a++;\n  onkai[\"G\"] = a++;\n  onkai[\"G#\"] = a++;\n  onkai[\"A\"] = a++;\n  onkai[\"A#\"] = a++;\n  onkai[\"B\"] = a++;\n  numOnkai = a;\n\n  for (int i = 0; i < n; i++) {\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n \nconst int LIM = 50000;\n \nmap<string, int> tone;\n \nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n \nstring stair[LIM+1], melody[LIM+1];\nint S, N, M;\n \nint pos, num;\n \nbool dfs(void){\n    if(num > M)  return false;\n    if(pos >= N) return num == M;\n    if((M - num) * 2 + pos < N) return false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n    \t++pos; ++num;\n    \tif(dfs()) return true;\n    \t--pos; --num;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n    \t--pos; ++num;\n    \tif(dfs()) return true;\n    \t++pos; --num;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n    \tpos += 2; ++num;\n        if(dfs()) return true;\n        pos -= 2; --num;\n    }\n    return false;\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair + N);\n        reverse(melody, melody + M);\n        bool res = false;\n        pos = 0, num = 0;\n        res = dfs();\n        pos = 1, num = 0;\n        res = res || dfs();\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM], melody[LIM];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(num > M) return false;\n    if(pos >= N ) return num == M;\n    bool ret = false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        ret = ret || dfs(pos+1, num+1);\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        ret = ret || dfs(pos+2, num+1);\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        ret = ret || dfs(pos-1, num+1);\n    }\n    return ret;\n}\n\nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair+N);\n        reverse(melody, melody+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nmap<string,int> sound;\nint n,m;\nint stairs[50001];\nint song[50001];\nbool passed[50001];\n\nbool bfs(){\n\tqueue<int> q[2];\n\tint cur=0;\n\tint nxt=1;\n\tq[cur].push(-1);\n\tint step=0;\n\twhile(q[cur].size()){\n\t\tmemset(passed,0,sizeof(passed));\n\t\twhile(q[cur].size()){\n\t\t\tint a=q[cur].front();\n\t\t\tq[cur].pop();\n\t\t\tint na=a+1;\n\t\t\tif(na>=0&&na<n&&song[step]==stairs[na]&&!passed[na]&&(m-step)*2>=n-na){\n\t\t\t\tq[nxt].push(na);\n\t\t\t\tpassed[na]=true;\n\t\t\t}\n\t\t\tna=a+2;\n\t\t\tif(na>=0&&na<n&&(stairs[na]+1)%sound.size()==song[step]&&!passed[na]&&(m-step)*2>=n-na){\n\t\t\t\tq[nxt].push(na);\n\t\t\t\tpassed[na]=true;\n\t\t\t}\n\t\t\tna=a-1;\n\t\t\tif(na>=0&&na<n&&(stairs[na]-1+sound.size())%sound.size()==song[step]&&!passed[na]&&(m-step)*2>=n-na){\n\t\t\t\tq[nxt].push(na);\n\t\t\t\tpassed[na]=true;\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t\tstep++;\n\t\tif(step==m){\n\t\t\tif(passed[n-1]||passed[n-2])return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tsound[\"C\"]=0;\n\tsound[\"C#\"]=1;\n\tsound[\"D\"]=2;\n\tsound[\"D#\"]=3;\n\tsound[\"E\"]=4;\n\tsound[\"F\"]=5;\n\tsound[\"F#\"]=6;\n\tsound[\"G\"]=7;\n\tsound[\"G#\"]=8;\n\tsound[\"A\"]=9;\n\tsound[\"A#\"]=10;\n\tsound[\"B\"]=11;\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstairs[i]=sound[s];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong[i]=sound[s];\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid MakeUpSound(map<string, string>&);\nvoid MakeDownSound(map<string, string>&);\nvoid InputVector(int, vector<string>&);\nbool MusicStairs(const vector<string>&, const vector<string>&, int, int);\n\nmap<string, string> up, down;\n\nint main(){\n  int i, j, k, n, m;\n  vector<string> stairs, music;\n\n  MakeUpSound(up);\n  MakeDownSound(down);\n  cin >> k;\n\n  for(i=0; i<k; ++i){\n    cin >> n >> m;\n    InputVector(n, stairs);\n    InputVector(m, music);\n\n    if(MusicStairs(stairs, music, -1, 0)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    stairs.clear();\n    music.clear();\n  }\n  return 0;\n}\n\nvoid MakeUpSound(map<string, string>& data){\n  data.insert(make_pair(\"C\", \"C#\"));\n  data.insert(make_pair(\"C#\", \"D\"));\n  data.insert(make_pair(\"D\", \"D#\"));\n  data.insert(make_pair(\"D#\", \"E\"));\n  data.insert(make_pair(\"E\", \"F\"));\n  data.insert(make_pair(\"F\", \"F#\"));\n  data.insert(make_pair(\"F#\", \"G\"));\n  data.insert(make_pair(\"G\", \"G#\"));\n  data.insert(make_pair(\"G#\", \"A\"));\n  data.insert(make_pair(\"A\", \"A#\"));\n  data.insert(make_pair(\"A#\", \"B\"));\n  data.insert(make_pair(\"B\", \"C\"));\n}\n\nvoid MakeDownSound(map<string, string>& data){\n  data.insert(make_pair(\"C\", \"B\"));\n  data.insert(make_pair(\"C#\", \"C\"));\n  data.insert(make_pair(\"D\", \"C#\"));\n  data.insert(make_pair(\"D#\", \"D\"));\n  data.insert(make_pair(\"E\", \"D#\"));\n  data.insert(make_pair(\"F\", \"E\"));\n  data.insert(make_pair(\"F#\", \"F\"));\n  data.insert(make_pair(\"G\", \"F#\"));\n  data.insert(make_pair(\"G#\", \"G\"));\n  data.insert(make_pair(\"A\", \"G#\"));\n  data.insert(make_pair(\"A#\", \"A\"));\n  data.insert(make_pair(\"B\", \"A#\"));\n}\n\nvoid InputVector(int n, vector<string>& data){\n  int i;\n  string str;\n  for(i=0; i<n; ++i){\n    cin >> str;\n    data.push_back(str);\n  }\n}\n\nbool MusicStairs(const vector<string>& stairs, const vector<string>& music,\n\t\t int n, int m){\n  if(m >= music.size()){\n    if(n+2 >= stairs.size()) return true;\n    else return false;\n  }\n  if(n+1 >= 0 && n+1 < stairs.size() &&\n     stairs[n+1] == music[m] && MusicStairs(stairs, music, n+1, m+1))\n    return true;\n  if(n+2 >= 0 && n+2 < stairs.size() &&\n     up[stairs[n+2]] == music[m] && MusicStairs(stairs, music, n+2, m+1))\n    return true;\n  if(n-1 >= 0 && n-1 < stairs.size() &&\n     down[stairs[n-1]] == music[m] && MusicStairs(stairs, music, n-1, m+1))\n    return true;\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    string T[50001], S[50001];\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    unordered_set<int> used[50001];    \n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n\n      //if ( used[s].count(t) ) continue;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n\n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif ( used[s+1].count(t-1) ) continue;\n\tq.push(Pii(s+1, t-1));\n\tused[s+1].insert(t-1);\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif ( used[s+1].count(t+1) ) continue;\n\tq.push(Pii(s+1, t+1));\n\tused[s+1].insert(t+1);\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif ( used[s+1].count(t+2) ) continue;\n\tq.push(Pii(s+1, t+2));\n\tused[s+1].insert(t+2);\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 500001\n\nusing namespace std;\n\nmap<string,int> getIndex;\nint t,s;\nbool found;\nint T[MAX],S[MAX];\nstring type[12] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\nint dc[] = {+0,+1,-1};\nint dx[] = {-1,-2,+1};\n\nvoid dfs(int cur_t,int cur_s)\n{\n  if(cur_s < 0)\n    {\n      if(cur_t == -1)found = true;\n      return;\n    }\n\n  rep(i,3)\n    {\n      int music = (T[cur_t] + dc[i] + 12)%12;\n      if(t <= cur_t+dx[i])continue;\n\n      if(music == S[cur_s])\n\t{\ndfs(cur_t+dx[i],cur_s-1);\n return;\n\t}\n   \n    }\n}\n\nbool compute()\n{\n  found = false;\n  dfs(t-1,s-1);\n  if(!found)dfs(t-2,s-1);\n  return found;\n}\n\nint main()\n{\n  rep(i,12)getIndex[type[i]] = i;\n  int N;\n  while(cin >> N)\n    {\n      while(N--)\n\t{\n\n\t  cin >> t >> s;\n\t  string input;\n\t  rep(i,t)\n\t    {\n\t      cin >> input;\n\t      T[i] = getIndex[input];\n\t    }\n\t  rep(i,s)\n\t    {\n\t      cin >> input;\n\t      S[i] = getIndex[input];\n\t    }\n\t  cout << (compute()?\"Yes\":\"No\") << endl;\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int T;\n  cin>>T;\n  map<string,int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    int n,m;\n    cin>>n>>m;\n    vector<int> t(n+1,0),s(m);\n    for(int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n    if(0){\n      for(int i:s) cout<<i<<\" \";cout<<endl;\n      for(int i:t) cout<<i<<\" \";cout<<endl;\n    }\n    \n    auto check=[&](int x,int i){\n      return x+(m-i)*2>=n+1;\n    };\n\n    if(n<=100){\n      bool flg=0;\n      vector<int> dp(1,0);\n      for(int i=0;i<=m;i++){\n\tvector<int> nx;\n\tfor(int x: dp){\n\t  if(i==m){\n\t    if(x+2>=n+1){\n\t      flg=1;\n\t      break;\n\t    }\n\t  }else{\n\t    if(x+1<=n&&(t[x+1]==s[i]))\n\t      if(check(x+1,i)) nx.emplace_back(x+1);\n\t    if(x+2<=n&&(t[x+2]==(s[i]+11)%12))\n\t      if(check(x+2,i))nx.emplace_back(x+2);\n\t    if(x-1>=0&&(t[x-1]==(s[i]+1)%12))\n\t      if(check(x-1,i)) nx.emplace_back(x-1);\n\t  }\n\t}\n\tsort(nx.begin(),nx.end());\n\tnx.erase(unique(nx.begin(),nx.end()),nx.end());\n\tif(0){\n\t  cout<<i<<\":\"<<endl;\n\t  for(int x:nx) cout<<x<<\" \";cout<<endl;\n\t}\n\tswap(dp,nx);\n\tif(dp.empty()) break;\n      }\n      cout<<(flg?\"Yes\":\"No\")<<endl;\n      continue;\n    }\n    \n    bool flg=0;\n    int h=n/2;\n    vector<int> ff,tt;\n    {\n      vector<int> dp(1,0);\n      for(int i=0;i<h;i++){\n\tvector<int> nx;\n\tfor(int x: dp){\n\t  if(x+1<=n&&(t[x+1]==s[i]))\n\t    if(check(x+1,i)) nx.emplace_back(x+1);\n\t  if(x+2<=n&&(t[x+2]==(s[i]+11)%12))\n\t    if(check(x+2,i))nx.emplace_back(x+2);\n\t  if(x-1>=0&&(t[x-1]==(s[i]+1)%12))\n\t    if(check(x-1,i)) nx.emplace_back(x-1);\n\t}\n\tsort(nx.begin(),nx.end());\n\tnx.erase(unique(nx.begin(),nx.end()),nx.end());\n\tswap(dp,nx);\n\tif(dp.empty()) break;\n      }\n      ff=dp;\n    }\n    {\n      vector<int> dp(1,n+1);\n      for(int i=m;i>=h;i--){\n\tvector<int> nx;\n\tfor(int x: dp){\n\t  if(x-1>=0&&(i==m||t[x]==s[i])) nx.emplace_back(x-1);\n\t  if(x-2>=0&&(i==m||t[x]==(s[i]+11)%12)) nx.emplace_back(x-2);\n\t  if(x+1<=n&&(i==m||t[x]==(s[i]+1)%12)) nx.emplace_back(x+1);\n\t}\n\tsort(nx.begin(),nx.end());\n\tnx.erase(unique(nx.begin(),nx.end()),nx.end());\n\tswap(dp,nx);\n\tif(dp.empty()) break;\n      }\n      tt=dp;\n    }\n    \n    set<int> cnt;\n    for(int i:ff) cnt.emplace(i);\n    for(int i:tt) flg|=cnt.count(i);\n    cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct edge{int to,sound;};\n\nint f(string s){\n\tif(s==\"C\")return 0;\n\tif(s==\"C#\")return 1;\n\tif(s==\"D\")return 2;\n\tif(s==\"D#\")return 3;\n\tif(s==\"E\")return 4;\n\tif(s==\"F\")return 5;\n\tif(s==\"F#\")return 6;\n\tif(s==\"G\")return 7;\n\tif(s==\"G#\")return 8;\n\tif(s==\"A\")return 9;\n\tif(s==\"A#\")return 10;\n\tif(s==\"B\")return 11;\n\treturn -1;\n}\n\nbool isSame(vector<int> &a, vector<int> &b){\n\trep(i,a.size()){\n\t\tif(a[i]!=b[i+1])return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tint input;\n\tcin>>input;\n\trep(loop,input){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tvector<int> step,song;\n\t\tstep.pb(-1);\t//1-index???????????????\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstep.pb(f(s));\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong.pb(f(s));\n\t\t}\n\t\tsong.pb(-1);\t//????????????????°???????????????????\n\t\t\n\t\tvector<edge> G[50010];\n\t\trep(i,n)  G[i].pb( edge{(int)i+1,step[i+1]} );\n\t\trep(i,n)  G[i+1].pb( edge{(int)i,(step[i]-1+12)%12} );\n\t\trep(i,n-1)G[i].pb( edge{(int)i+2,(step[i+2]+1)%12} );\n\t\tG[n].pb(edge{n+1,-1});\n\t\tG[n-1].pb(edge{n+2,-1});\n\t\t\n\t\tbool f=true;\n\t\t\n\t\tqueue<pair<int,vector<int>>> que;\n\t\tque.push(make_pair(0,vector<int>(0)));\n\t\twhile(!que.empty()){\n\t\t\tint pos = que.front().first;\n\t\t\tvector<int> sounds = que.front().second;\n\t\t\tint num = sounds.size();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(num==m+1){\n\t\t\t\tif(sounds == song){\n\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e = G[pos][i];\n//\t\t\t\tcout<<\":\"<<pos<<\" \"<<e.to<<\" \"<<e.sound<<endl;\n\t\t\t\tif(e.sound == song[num]){\t//?\n\t\t\t\t\tsounds.pb(e.sound);\n//\t\t\t\t\trep(j,sounds.size())cout<<sounds[j]<<\" \";cout<<endl;\n\t\t\t\t\tque.push(make_pair(e.to,sounds));\n\t\t\t\t\tsounds.erase(sounds.end()-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n \nconst int LIM = 50000;\n \nmap<string, int> tone;\n \nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n \nstring stair[LIM+1], melody[LIM+1];\nint S, N, M;\n \nbool dfs(int pos, int num){\n    if(num > M) return false;\n    if(pos >= N) return num == M;\n    if((M - num) * 2 + pos < N) return false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        bool tr = dfs(pos+1, num+1);\n        if(tr) return true;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        bool tr = dfs(pos+2, num+1);\n        if(tr) return true;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        bool tr = dfs(pos-1, num+1);\n        if(tr) return true;\n    }\n    return false;\n}\n \nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair+N);\n        reverse(melody, melody+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    unordered_set<int> used;    \n    queue<Pii> q;\n    int now = -1;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      if(s != now && !used.empty() ) used.clear();\n      now = s;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if((n-t) > (m-s)*2+1) continue;\n      \n      //if ( used[s].count(t) ) continue;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif ( !used.count(t-1) ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used.insert(t-1);\n\t}\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif ( !used.count(t+1) ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used.insert(t+1);\n\t}\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif ( !used.count(t+2) ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used.insert(t+2);\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint stair[50000],melody[50000];\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint getNUM(char buf[3]){\n\tswitch(buf[0]){\n\tcase 'C':\n\t\tif(buf[1] == '\\0'){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tif(buf[1] == '\\0'){\n\t\t\treturn 2;\n\t\t}else{\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase 'E':\n\t\treturn 4;\n\t\tbreak;\n\tcase 'F':\n\t\tif(buf[1] == '\\0'){\n\t\t\treturn 5;\n\t\t}else{\n\t\t\treturn 6;\n\t\t}\n\t\tbreak;\n\tcase 'G':\n\t\tif(buf[1] == '\\0'){\n\t\t\treturn 7;\n\t\t}else{\n\t\t\treturn 8;\n\t\t}\n\t\tbreak;\n\tcase 'A':\n\t\tif(buf[1] == '\\0'){\n\t\t\treturn 9;\n\t\t}else{\n\t\t\treturn 10;\n\t\t}\n\t\tbreak;\n\tcase 'B':\n\t\treturn 11;\n\t\tbreak;\n\t}\n}\n\nbool is_UP(int to,int from){\n\n\tif((to == from+1) || (to == 0 && from == 11))return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_DOWN(int to,int from){\n\tif((to == from-1 || (to == 11 && from == 0)))return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid func(){\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\n\tchar buf[3];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\t\tstair[i] = getNUM(buf);\n\t}\n\treverse(stair,stair+N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%s\",buf);\n\t\tmelody[i] = getNUM(buf);\n\t}\n\treverse(melody,melody+M);\n\n\tbool FLG = false;\n\tint loc,index;\n\n\tif((stair[0] == melody[0]) || (N >= 2 && is_UP(melody[0],stair[0]) == true)){\n\t\tif(stair[0] == melody[0]){\n\t\t\tloc = 1;\n\t\t}else{\n\t\t\tloc = 2;\n\t\t}\n\n\t\tif(loc == N && M == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tindex = 1;\n\n\t\twhile(loc < N || index < M){\n\t\t\tif(melody[index] == stair[loc]){\n\t\t\t\tloc += 1;\n\t\t\t\tindex++;\n\t\t\t}else if(is_UP(melody[index],stair[loc]) == true && loc+2 <= N){\n\t\t\t\tloc += 2;\n\t\t\t\tindex++;\n\t\t\t}else if(is_DOWN(melody[index],stair[loc]) == true && loc > 0){\n\t\t\t\tloc -= 1;\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(loc == N && index == M)FLG = true;\n\t}\n\n\tif(FLG){\n\t\tprintf(\"Yes\\n\");\n\t\treturn;\n\t}\n\n\tif((N >= 2 && stair[1] == melody[0]) || (N >= 3 && is_UP(melody[0],stair[1]) == true) || (is_DOWN(melody[0],stair[1]) == true)){\n\t\tif(stair[1] == melody[0]){\n\t\t\tloc = 2;\n\t\t}else if(is_UP(melody[0],stair[1]) == true){\n\t\t\tloc = 3;\n\t\t}else{ //is_DOWN(melody[0],stair[1]) == true\n\t\t\tloc = 0;\n\t\t}\n\n\t\tif(loc == N && M == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tindex = 1;\n\n\t\twhile(loc < N || index < M){\n\t\t\tif(melody[index] == stair[loc]){\n\t\t\t\tloc += 1;\n\t\t\t\tindex++;\n\t\t\t}else if(is_UP(melody[index],stair[loc]) == true && loc+2 <= N){\n\t\t\t\tloc += 2;\n\t\t\t\tindex++;\n\t\t\t}else if(is_DOWN(melody[index],stair[loc]) == true && loc > 0){\n\t\t\t\tloc -= 1;\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(loc == N && index == M)FLG = true;\n\t}\n\n\tif(FLG){\n\t\tprintf(\"Yes\\n\");\n\t}else{\n\t\tprintf(\"No\\n\");\n\t}\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50000;\nconst int MAX_M = 50000;\n\nconst int NSC = 12;\n\nconst string scs[NSC] = {\n  \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"\n};\n\n/* typedef */\n\ntypedef map<string,int> msi;\n\n/* global variables */\n\nmsi scmap;\nint n, m;\nint tis[MAX_N + 1], sis[MAX_M + 1];\n\n/* subroutines */\n\ninline int mod(int k) { return (k + NSC) % NSC; }\n\nbool check(int ti) {\n  for (int si = m - 1; si >= 0; si--) {\n    if (ti < 0 || ti >= n) return false;\n\n    int& t = tis[ti];\n    int& s = sis[si];\n\n    if (t == s) ti--;\n    else if (mod(t + 1) == s) ti -= 2;\n    else if (mod(t - 1) == s) ti++;\n    else return false;\n  }\n\n  return (ti == -1);\n}\n\n/* main */\n\nint main() {\n  for (int i = 0; i < NSC; i++) scmap[scs[i]] = i;\n\n  int tn;\n  cin >> tn;\n\n  while (tn--) {\n    cin >> n >> m;\n    string sc;\n    \n    for (int i = 0; i < n; i++) {\n      cin >> sc;\n      tis[i] = scmap[sc];\n    }\n\n    for (int i = 0; i < m; i++) {\n      cin >> sc;\n      sis[i] = scmap[sc];\n    }\n\n    bool ok = check(n - 1) || check(n - 2);\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  // {{{\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define GET_MACRO(a, b, c, d, NAME, ...) NAME\n#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) GET_MACRO(__VA_ARGS__, REPR4, REPR3, REPR2)(__VA_ARGS__)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n\nusing Int = long long;\n// clang-format off\ntemplate<typename T,typename U>inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\ntemplate<typename T,typename U>inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\ninline signed in(){signed x;scanf(\"%d\",&x);return x;}\n// clang-format on\n// }}}\n\nusing namespace std;\n\nconst int MOD = 12;\n\nint getRank(string& s) {\n  if (s == \"C\") return 0;\n  if (s == \"C#\") return 1;\n  if (s == \"D\") return 2;\n  if (s == \"D#\") return 3;\n  if (s == \"E\") return 4;\n  if (s == \"F\") return 5;\n  if (s == \"F#\") return 6;\n  if (s == \"G\") return 7;\n  if (s == \"G#\") return 8;\n  if (s == \"A\") return 9;\n  if (s == \"A#\") return 10;\n  if (s == \"B\") return 11;\n}\n\nint N, M;\nint rankT[50500];\nint rankB[50500];\n\nbool solve(int n, int m) {\n  if (m == -1) return n == -1;\n  if (n < 0) return false;\n  if (rankT[n] == rankB[m]) {\n    if (solve(n - 1, m - 1)) return true;\n  }\n  if ((rankT[n] + 1) % MOD == rankB[m]) {\n    if (solve(n - 2, m - 1)) return true;\n  }\n  if ((rankT[n] + MOD - 1) % MOD == rankB[m]) {\n    if (solve(n + 1, m - 1)) return true;\n  }\n  return false;\n}\n\nsigned main() {\n  int T = in();\n  REP(t, T) {\n    N = in(), M = in();\n    REP(i, N) {\n      string S;\n      cin >> S;\n      rankT[i] = getRank(S);\n    }\n    REP(i, M) {\n      string S;\n      cin >> S;\n      rankB[i] = getRank(S);\n    }\n    if (solve(N - 1, M - 1) || solve(N - 2, M - 1)) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint t[50010];\nint s[50010];\n\nint n,m;\n\n#define OTO(x,y) (((x) + 12 + (y)) % 12)\n\nbool loop(int i, int j){\n  if(i == 0 && j == -1) return true;\n  if(i == n + 1) return false;\n  if(j == -1) return false;\n  if(i < 0) return false;\n\n  int tt = t[i];\n  int ss = s[j];\n\n  if(OTO(tt,0) == ss) return loop(i-1,j-1);\n  if(OTO(tt,1) == ss) return loop(i-2,j-1);\n  if(OTO(tt,-1)== ss) return loop(i+1,j-1);\n\n  return false;\n}\n\nint main(){\n  int cc;\n  map<string,int> mp;\n  mp[\"C\" ] = 0; mp[\"C#\"] = 1;\n  mp[\"D\" ] = 2; mp[\"D#\"] = 3;\n  mp[\"E\" ] = 4;\n  mp[\"F\" ] = 5; mp[\"F#\"] = 6;\n  mp[\"G\" ] = 7; mp[\"G#\"] = 8;\n  mp[\"A\" ] = 9; mp[\"A#\"] = 10;\n  mp[\"B\" ] = 11;\n\n  scanf(\"%d\",&cc);\n\n  while( cc --> 0 ){\n    char buff[8];\n\n    scanf(\"%d%d\",&n,&m);\n\n    REP(i,n){\n      scanf(\"%s\",buff);\n      t[i+1] = mp[buff];\n    }\n    REP(i,m){\n      scanf(\"%s\",buff);\n      s[i] = mp[buff];\n    }\n\n    puts((loop(n, m-1) || loop(n-1, m-1)) ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,m,t[50000],s[50000];\nint so[256];\n\nint tonum(char *buf)\n{\n\treturn so[buf[0]]+(buf[1]=='#');\n}\n\nbool bfs()\n{\n\tqueue<pi> Q;\n\tQ.push(mp(0,0));\n\twhile(!Q.empty())\n\t{\n\t\tint cur=Q.front().first,step=Q.front().second;\n\t\tQ.pop();\n\t\t\n\t\tif(n+1-cur>2*(m-step+1))continue;\n\t\t\n\t\tif(step==m)\n\t\t{\n\t\t\tif(cur+1==n+1||cur+2==n+1)return 1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(cur+1<=n&&t[cur]==s[step])Q.push(mp(cur+1,step+1));\n\t\tif(cur+2<=n&&(t[cur+1]+1)%12==s[step])Q.push(mp(cur+2,step+1));\n\t\tif(cur-1>0&&(t[cur-2]+11)%12==s[step])Q.push(mp(cur-1,step+1));\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tso['C']=0; so['D']=2; so['E']=4;\n\tso['F']=5; so['G']=7; so['A']=9;\n\tso['B']=11;\n\t\n\tint cs; scanf(\"%d\",&cs);\n\twhile(cs--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\t\n\t\tchar buf[3];\n\t\trep(i,n)scanf(\"%s\",buf),t[i]=tonum(buf);\n\t\trep(i,m)scanf(\"%s\",buf),s[i]=tonum(buf);\n\t\t\n\t\tcout<<(bfs()?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nint st[LIM+1], me[LIM+1];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(pos >= N) return num == M;\n    if(num > M) return false;\n    if((M - num) * 2 + pos < N) return false;\n    if(me[num] == st[pos]) return dfs(pos+1, num+1);\n    if((me[num] - st[pos] + 12) % 12 == 1) return dfs(pos+2, num+1);\n    if(pos > 0 && (me[num] - st[pos] + 12) % 12 == 11) return dfs(pos-1, num+1);\n    return false;\n}\n\nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        string str;\n        for(int x = 0; x < N; x++){\n            cin >> str;\n            st[x] = tone[str];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> str;\n            me[x] = tone[str];\n        }\n        reverse(st, st+N);\n        reverse(me, me+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50040;\nint T[MAXN], S[MAXN];\n\nbool check(int start, int n, int m) {\n    int now = start;\n    for (int i = 0; i < m; i++) {\n        if (now > n-1) return false;\n        if (now < 0) return false;\n        int tar = S[i];\n        bool ok = false;\n        for (int j = -1; j <= 1; j++) {\n            int next = (T[now]+j + 12) % 12;\n            if (tar == next) {\n                ok = true;\n                now += j;\n                if (j >= 0) now++;\n            }\n        }\n        if (!ok) return false;\n    }\n    if (now >= n-2) return true;\n    else return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int test;\n    cin >> test;\n    map<string, int> oto;\n    oto[\"C\"] = 0;\n    oto[\"C#\"] = 1;\n    oto[\"D\"] = 2;\n    oto[\"D#\"] = 3;\n    oto[\"E\"] = 4;\n    oto[\"F\"] = 5;\n    oto[\"F#\"] = 6;\n    oto[\"G\"] = 7;\n    oto[\"G#\"] = 8;\n    oto[\"A\"] = 9;\n    oto[\"A#\"] = 10;\n    oto[\"B\"] = 11;\n    while (test--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            T[i] = oto[s];\n        }\n        for (int i = 0; i < m; i++) {\n            string s;\n            cin >> s;\n            S[i] = oto[s];\n        }\n        reverse(S, S+m);\n        reverse(T, T+n);\n        if (check(0, n, m) || check(1, n, m)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM+1], melody[LIM+1];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(num > M) return false;\n    if(pos >= N) return num == M;\n    if((M - num) * 2 + pos < N) return false;\n    bool ret = false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        bool tr = dfs(pos+1, num+1);\n        if(tr) ret = true;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        bool tr = dfs(pos+2, num+1);\n        if(tr) ret = true;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        bool tr = dfs(pos-1, num+1);\n        if(tr) ret = true;\n    }\n    return ret;\n}\n\nint main(){\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair+N);\n        reverse(melody, melody+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint key[]={0,2,3,5,7,8,10};\nchar in[5];\nint p[110000];\nint q[110000];\nint n;\nint solve(int a,int b){\n\tif(a<0&&b<0)return 1;\n\tif(a<0)return 0;\n\tif(b<0)return 0;\n\tif(b>=n)return 0;\n\tif(p[b]==q[a])return solve(a-1,b-1);\n\tif((p[b]+1)%12==q[a])return solve(a-1,b-2);\n\tif((p[b]+11)%12==q[a])return solve(a-1,b+1);\n\treturn 0;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tp[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')p[i]++;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tq[i]=key[in[0]-'A'];\n\t\t\tif(in[1]=='#')q[i]++;\n\t\t}\n\t\tif(solve(b-1,a-1))printf(\"Yes\\n\");\n\t\telse if(solve(b-1,a-2))printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\nchrono::system_clock::time_point start;\ndouble calcTime(){\n  chrono::system_clock::time_point end = chrono::system_clock::now();\n  return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n}\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    start=chrono::system_clock::now();\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<2000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    srand((unsigned)time(NULL));\n    \n    if(calcTime()>=2000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50040;\nint T[MAXN], S[MAXN];\n\nbool check(int start, int n, int m) {\n    int now = start;\n    for (int i = 0; i < m; i++) {\n        if (now > n-1) return false;\n        int tar = S[i];\n        bool ok = false;\n        for (int j = -1; j <= 1; j++) {\n            int next = (T[now]+j + 12) % 12;\n            if (tar == next) {\n                ok = true;\n                now += j;\n                if (j >= 0) now++;\n            }\n        }\n        if (now < 0) return false;\n        if (!ok) return false;\n    }\n    if (now >= n-2) return true;\n    else return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int test;\n    cin >> test;\n    map<string, int> oto;\n    oto[\"C\"] = 0;\n    oto[\"C#\"] = 1;\n    oto[\"D\"] = 2;\n    oto[\"D#\"] = 3;\n    oto[\"E\"] = 4;\n    oto[\"F\"] = 5;\n    oto[\"F#\"] = 6;\n    oto[\"G\"] = 7;\n    oto[\"G#\"] = 8;\n    oto[\"A\"] = 9;\n    oto[\"A#\"] = 10;\n    oto[\"B\"] = 11;\n    while (test--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            T[i] = oto[s];\n        }\n        for (int i = 0; i < m; i++) {\n            string s;\n            cin >> s;\n            S[i] = oto[s];\n        }\n        reverse(S, S+m);\n        reverse(T, T+n);\n        if (check(0, n, m) || check(1, n, m)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n    //N = 1;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        bool ok = false;\n        for(int start = n-2; start <= n-1; ++start) {\n            if(start < 0) continue;\n            int mpos = m-1;\n            int pos = start;\n            for(; mpos >= 0; --mpos) {\n                if(stairs[pos] == music[mpos]) {\n                    if(--pos < 0) goto next;\n                }\n                else if((stairs[pos]+1)%12 == music[mpos]) {\n                    pos -= 2;\n                    if(pos < 0) goto next;\n                }\n                else if((stairs[pos]+11)%12 == music[mpos]) {\n                    pos += 1;\n                    if(pos >= n) goto next;\n                }\n                else break;\n            }\nnext:\n            if(mpos <= 0 && pos == -1) {\n                ok = true;\n                break;\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "l#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\nclock_t start;\ndouble calcTime2(){\n  clock_t end = clock();     // 終了時間\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\n\nint main() {\n    srand((unsigned)time(NULL));\n    \n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n    int k;\n    cin >> k;\n    while ( k-- ) {\n      \n    int n, m;\n    start = clock();// スタート時間\n\n    cin >> n >> m;\n    //cout<<n<<\" \"<<m<<endl;\n    //cout<<calcTime2()<<endl;\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    //if(n == 50000 && m==50000)continue;    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime2()<3) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      //  if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    \n    if(calcTime2()>=2.8) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,m,t[50000],s[50000];\nbool V[5000][5000];\nint so[256];\n\nint tonum(char *buf)\n{\n\treturn so[buf[0]]+(buf[1]=='#');\n}\n\nbool dfs(int cur,int step)\n{\n\tif(cur<5000&&step<5000)\n\t{\n\t\tif(V[cur][step])return 0;\n\t\tV[cur][step]=1;\n\t}\n\t\n\tif(step==m)\n\t{\n\t\tif(cur+1==n+1||cur+2==n+1)return 1;\n\t\treturn 0;\n\t}\n\t\n\tbool ret=0;\n\tif(cur+1<=n&&t[cur]==s[step])ret=ret||dfs(cur+1,step+1);\n\tif(cur+2<=n&&(t[cur+1]+1)%12==s[step])ret=ret||dfs(cur+2,step+1);\n\tif(cur-1>0&&(t[cur-2]+11)%12==s[step])ret=ret||dfs(cur-1,step+1);\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tso['C']=0; so['D']=2; so['E']=4;\n\tso['F']=5; so['G']=7; so['A']=9;\n\tso['B']=11;\n\t\n\tint cs; scanf(\"%d\",&cs);\n\twhile(cs--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\t\n\t\trep(i,min(n,5000))rep(j,min(m,5000))V[i][j]=0;\n\t\t\n\t\tchar buf[3];\n\t\trep(i,n)scanf(\"%s\",buf),t[i]=tonum(buf);\n\t\trep(i,m)scanf(\"%s\",buf),s[i]=tonum(buf);\n\t\t\n\t\tcout<<(dfs(0,0)?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int T;\n  cin>>T;\n  map<string,int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    int n,m;\n    cin>>n>>m;\n    vector<int> t(n+1,0),s(m);\n    for(int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n    if(0){\n      for(int i:s) cout<<i<<\" \";cout<<endl;\n      for(int i:t) cout<<i<<\" \";cout<<endl;\n    }\n    \n    auto check=[&](int x,int i){\n      return x+(m-i)*2>=n+1;\n    };\n    \n    bool flg=0;\n    vector<int> dp(1,0);\n    for(int i=0;i<=m;i++){\n      vector<int> nx;\n      for(int x: dp){\n\tif(i==m){\n\t  if(x+2>=n+1){\n\t    flg=1;\n\t    break;\n\t  }\n\t}else{\n\t  if(x+1<=n&&(t[x+1]==s[i]))\n\t    if(check(x+1,i)) nx.emplace_back(x+1);\n\t  if(x+2<=n&&(t[x+2]==(s[i]+11)%12))\n\t    if(check(x+2,i))nx.emplace_back(x+2);\n\t  if(x-1>=0&&(t[x-1]==(s[i]+1)%12))\n\t    if(check(x-1,i)) nx.emplace_back(x-1);\n\t}\n      }\n      sort(nx.begin(),nx.end());\n      nx.erase(unique(nx.begin(),nx.end()),nx.end());\n      if(0){\n\tcout<<i<<\":\"<<endl;\n\tfor(int x:nx) cout<<x<<\" \";cout<<endl;\n      }\n      swap(dp,nx);\n      if(dp.empty()) break;\n    }\n    cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int T;\n  cin>>T;\n  map<string,Int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(Int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    Int n,m;\n    cin>>n>>m;\n    vector<Int> t(n+1,0),s(m);\n    for(Int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(Int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n\n    vector<Int> dp(1,n+1);\n    for(Int i=m;i>=0;i--){\n      vector<Int> nx;\n      for(Int x: dp){\n\tif(x-1>=0&&(i==m||t[x]==s[i])) nx.emplace_back(x-1);\n\tif(x-2>=0&&(i==m||t[x]==(s[i]+11)%12)) nx.emplace_back(x-2);\n\tif(x+1<=n&&(i==m||t[x]==(s[i]+1)%12)) nx.emplace_back(x+1);\n      }\n      sort(nx.begin(),nx.end());\n      nx.erase(unique(nx.begin(),nx.end()),nx.end());\n      swap(dp,nx);\n      if(dp.empty()) break;\n    }\n    \n    cout<<(!dp.empty()&&dp.front()==0?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring c[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\nint main() {\n  int T,n,m,f,x;\n  cin>>T;\n  while(T--){\n    cin>>n>>m;\n    string s[n],t[m];\n    for(int i=0;i<n;i++)cin>>s[i];\n    for(int i=0;i<m;i++)cin>>t[i];\n    f=0;\n    for(int k=1;k<3;k++){\n      x=n-k;\n      for(int i=m-1,p;i>=0;i--){\n        if(x<0||x>=n)goto e;\n        p=0;\n        while(c[p]!=s[x])p++;\n        if(t[i]==c[p])x--;\n        else if(t[i]==c[(p+1)%12])x-=2;\n        else if(t[i]==c[(p+11)%12])x++;\n        else goto e;\n      }\n      if(x==-1)f=1;\n    e:;\n    }\n    cout<<(f?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\nchrono::system_clock::time_point start;\ndouble calcTime(){\n  chrono::system_clock::time_point end = chrono::system_clock::now();\n  return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n}\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    start=chrono::system_clock::now();\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<5000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    srand((unsigned)time(NULL));\n    \n    if(calcTime()>=5000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N,M;\nint T[50010];\nint S[50010];\nint lis[]={9,11,0,2,4,5,7};\n\nchar t[3];\ninline int in(){\n    scanf(\"%s\",t);\n    return lis[t[0]-'A']+(t[1]=='#');\n}\ninline int add(int a,int b){\n    a+=b;\n    if(a>=12)a-=12;\n}\n\nvoid solve(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,N)T[i]=in();\n    rep(i,M)S[i]=in();\n    for(int fin=N-2;fin<N;fin++){\n        bool ok=true;\n        int pos=fin;\n        for(int i=M-1;i>=0;i--){\n            if(pos<0||pos==N){\n                ok=false;\n                break;\n            }\n            if(T[pos]==S[i])pos--;\n            else if(add(T[pos],1)==S[i])pos-=2;\n            else if(add(T[pos],11)==S[i])pos++;\n            else{\n                ok=false;\n                break;\n            }\n        }\n        if(ok&&pos==-1){\n            puts(\"Yes\");\n            return;\n        }\n    }\n    puts(\"No\");\n}\n\nsigned main(){\n    int T;scanf(\"%lld\",&T);\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N, M;\nint step[50001];\nint song[50001];\nstring note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\nint getidx(string s){\n  REP(i, 12)if(s == note[i]) return i;\n  return -1;\n}\nbool dfs(int p, int idx){\n  if(idx == M) return (p == N - 1 || p == N - 2) ;\n  int d[3] = {-1, 1, 2};\n  int dif[3] = {-1, 0, 1};\n  REP(r, 3){\n    int np = p + d[r];\n    if(np >= 0 && np < N && (step[np] + dif[r] + 12) % 12 == song[idx] && dfs(np, idx + 1)){\n      return true;\n    }\n  }\n  return false;\n}\nbool dfs2(int p, int idx){\n  if(idx == -1) return (p == -1);\n  if(p >= N || p < 0) return false;\n  int dif = (song[idx] - step[p]);\n  if(dif == 11) dif = -1;\n  if(dif == -11) dif = +1;\n  if(abs(dif) >= 2) return false;\n  if(dif == 0) return dfs2(p - 1, idx - 1);\n  if(dif == 1) return dfs2(p - 2, idx - 1);\n  if(dif == -1) return dfs2(p + 1, idx - 1);\n  assert(false);\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    cin>>N>>M;\n    REP(i, N){\n      string s; cin>>s;\n      step[i] = getidx(s);\n      assert(step[i] != -1);\n    }\n    REP(i, M){\n      string s; cin>>s;\n      song[i] = getidx(s);\n    }\n    //bool ans = dfs(-1, 0);\n    bool ans2 = (dfs2(N - 1, M - 1) || dfs2(N - 2, M - 1));\n    if(ans2) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nstring table[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n\nint N,M;\nint T[50010];\nint S[50010];\n\nbool dfs(int n,int m){\n    if(m==M)return N-n<=2;\n    if((N-n+1)/2>M-m+1)return false;\n    if(n>0&&(T[n-1]+11)%12==S[m]&&dfs(n-1,m+1))return true;\n    if(n+1<N&&T[n+1]==S[m]&&dfs(n+1,m+1))return true;\n    if(n+2<N&&(T[n+2]+1)%12==S[m]&&dfs(n+2,m+1))return true;\n    return false;\n}\n\nvoid solve(){\n    cin>>N>>M;\n    string hoge;\n    rep(i,N){\n        cin>>hoge;\n        T[i]=find(table,table+12,hoge)-table;\n    }\n    rep(i,M){\n        cin>>hoge;\n        S[i]=find(table,table+12,hoge)-table;\n    }\n\n    if(dfs(-1,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    int T;cin>>T;\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int T;\n  cin>>T;\n  map<string,int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    int n,m;\n    cin>>n>>m;\n    vector<int> t(n+1,0),s(m);\n    for(int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n    if(0){\n      for(int i:s) cout<<i<<\" \";cout<<endl;\n      for(int i:t) cout<<i<<\" \";cout<<endl;\n    }\n    \n    auto check=[&](int x,int i){\n      return x+(m-i)*2>=n+1;\n    };\n    \n    bool flg=0;\n    vector<int> dp(1,0);\n    for(int i=0;i<=m;i++){\n      vector<int> nx;\n      for(int x: dp){\n\tif(i==m){\n\t  if(x+2>=n+1){\n\t    flg=1;\n\t    break;\n\t  }\n\t}else{\n\t  if(x+1<=n&&(t[x+1]==s[i]))\n\t    if(check(x+1,i)) nx.emplace_back(x+1);\n\t  if(x+2<=n&&(t[x+2]==(s[i]+11)%12))\n\t    if(check(x+2,i))nx.emplace_back(x+2);\n\t  if(x-1>=0&&(t[x-1]==(s[i]+1)%12))\n\t    if(check(x-1,i)) nx.emplace_back(x-1);\n\t}\n      }\n      sort(nx.begin(),nx.end());\n      nx.erase(unique(nx.begin(),nx.end()),nx.end());\n      if(0){\n\tcout<<i<<\":\"<<endl;\n\tfor(int x:nx) cout<<x<<\" \";cout<<endl;\n      }\n      swap(dp,nx);\n    }\n      cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint main(){\n    string noteStr[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n    map<string, int> noteMap;\n    for(int i=0;i<12;i++){\n        noteMap[noteStr[i]] = i;\n    }\n\n    int dN;\n    cin >> dN;\n    for(int di=0;di<dN;di++){\n        int n, m;\n        cin >> n >> m;\n        vec stairs(n);\n        for(int i=0;i<n;i++){\n            string str;\n            cin >> str;\n            stairs[i] = noteMap[str];\n        }\n        vec music(m);\n        for(int i=0;i<m;i++){\n            string str;\n            cin >> str;\n            music[i] = noteMap[str];\n        }\n\n        bool able = false;\n        for(int i=0;i<2;i++){\n            int sv = n-1-i, mv = m - 1;\n            while(sv>=0&&mv>=0){\n                if(stairs[sv] == music[mv]){\n                    sv -= 1;\n                }else if(stairs[sv]+1 == music[mv] || (stairs[sv]==11&&music[mv]==0)){\n                    sv -= 2;\n                }else if(stairs[sv]-1 == music[mv] || (stairs[sv]==0&&music[mv]==11)){\n                    if(sv==n-1)break;\n                    sv += 1;\n                }else{\n                    break;\n                }\n                mv--;\n            }\n            if(sv==-1&&mv==-1){\n                able = true;\n                break;\n            }\n        }\n        if(able) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int t;\n  cin>>t;\n  while(t--){\n    int n,m;\n    cin>>n>>m;\n    int s[50002];\n    string sn[]={\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n    for(int i=1;i<=n;i++){\n      string ss;\n      cin>>ss;\n      s[i]=find(sn,sn+12,ss)-sn;\n    }\n    set<int> st[2];\n    st[0].insert(0);\n    for(int i=0;i<m;i++){\n      st[!(i&1)].clear();\n      string ssn;\n      cin>>ssn;\n      int sd=find(sn,sn+12,ssn)-sn;\n      for(set<int>::iterator it=st[i&1].begin();it!=st[i&1].end();it++){\n\tint step[]={1,2,-1};\n\tint d[]={0,1,11};\n\tfor(int j=0;j<3;j++){\n\t  int nx=*it+step[j];\n\t  if(0<nx&&nx<=n&&(s[nx]+d[j])%12==sd){\n\t    st[!(i&1)].insert(nx);\n\t  }\n\t}\n      }\n    }\n    cout<<((st[m&1].count(n)||st[m&1].count(n-1))?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50040;\nint T[MAXN], S[MAXN];\n\nbool check(int start, int n, int m) {\n    int now = start;\n    for (int i = 0; i < m; i++) {\n        if (now > n-1) return false;\n        int tar = S[i];\n        bool ok = false;\n        for (int j = -1; j <= 1; j++) {\n            int next = (T[now]+j + 12) % 12;\n            if (tar == next) {\n                ok = true;\n                now += j;\n                if (j >= 0) now++;\n            }\n        }\n        if (now < 0) return false;\n        if (!ok) return false;\n    }\n    if (n-2 <= now && now < n+1) return true;\n    else return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int test;\n    cin >> test;\n    map<string, int> oto;\n    oto[\"C\"] = 0;\n    oto[\"C#\"] = 1;\n    oto[\"D\"] = 2;\n    oto[\"D#\"] = 3;\n    oto[\"E\"] = 4;\n    oto[\"F\"] = 5;\n    oto[\"F#\"] = 6;\n    oto[\"G\"] = 7;\n    oto[\"G#\"] = 8;\n    oto[\"A\"] = 9;\n    oto[\"A#\"] = 10;\n    oto[\"B\"] = 11;\n    while (test--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            T[i] = oto[s];\n        }\n        for (int i = 0; i < m; i++) {\n            string s;\n            cin >> s;\n            S[i] = oto[s];\n        }\n        reverse(S, S+m);\n        reverse(T, T+n);\n        if (check(0, n, m) || check(1, n, m)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nconst static int offset[] = {11,0,1};\n\nint dfs(int note_pos,int stair_pos,\n        const vector<int>& stair,const vector<int>& song){\n\n  if(stair_pos + 2 * (song.size() - note_pos) < stair.size() - 2){\n    return false;\n  }\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int next = stair_pos + idx2dist[i];\n    if(next < 0 || next >= stair.size()) continue;\n    if(song[note_pos + 1] != (stair[next] + offset[i]) % 12) continue;\n    res |= dfs(note_pos + 1,next,stair,song);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1,stair,song) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int LIM = 60000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nint st[LIM+1], me[LIM+1];\nint S, N, M;\n\nbool dfs(int pos, int num){\n    if(pos == N) return num == M;\n    if(num >= M || pos >= N) return 0;\n    if(me[num] == st[pos]) return dfs(pos+1, num+1);\n    if(me[num] == (st[pos] + 1) % 12) return dfs(pos+2, num+1);\n    if(pos > 0 && me[num] == (st[pos] + 11) % 12) return dfs(pos-1, num+1);\n    return false;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        string str;\n        for(int x = 0; x < N; x++){\n            cin >> str;\n            st[x] = tone[str];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> str;\n            me[x] = tone[str];\n        }\n        reverse(st, st+N);\n        reverse(me, me+M);\n        bool res = false;\n        res = dfs(0, 0) || dfs(1, 0);\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint n,m;\nint t[50010],s[50010];\nbool f;\n\nint oct(string x){\n  if(x == \"C\") return 0;\n  if(x == \"C#\")return 1;\n  if(x == \"D\") return 2;\n  if(x == \"D#\")return 3;\n  if(x == \"E\") return 4;\n  if(x == \"F\") return 5;\n  if(x == \"F#\")return 6;\n  if(x == \"G\") return 7;\n  if(x == \"G#\")return 8;\n  if(x == \"A\") return 9;\n  if(x == \"A#\")return 10;\n  if(x == \"B\") return 11;\n  else return 12;\n}\n\nvoid rec(int stair,int music){\n  if(music<0){\n    if(stair<0)f = true;\n    return;\n  }\n  if(stair<0 || n-1<stair)return;\n\n  int o = s[music];\n  if(o==t[stair])rec(stair-1,music-1);\n  if(o==(t[stair]+1)%12)rec(stair-2,music-1);\n  if(o==(t[stair]+11)%12)rec(stair+1,music-1);\n}\n\nint main(){\n\n  int casenum;\n  string tmp;\n\n  cin >> casenum;\n\n  while(casenum--){\n    cin >> n >> m;\n    for(int i=0;i<n;i++){\n      cin >> tmp;\n      t[i] = oct(tmp);\n    }\n\n    for(int i=0;i<m;i++){\n      cin >> tmp;\n      s[i] = oct(tmp);\n    }\n\n    f = false;\n    rec(n-1,m-1);\n    if(!f)rec(n-2,m-1);\n\n    if(f)cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\n\nchar* o[] = { \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\nint to_n()\n{\n\tchar s[32];\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < 12; ++i)\n\t\tif (strcmp(s, o[i]) == 0)\n\t\t\treturn i;\n}\nint n, m;\nint t[51111], s[51111];\nbool dfs(int stair, int p)\n{\n\tif (stair > n)\n\t\treturn p == m + 1;\n\telse if (p == m + 1 || p != 0 && stair <= 0)\n\t\treturn false;\n\n\n\tstatic const int dir[] = { 1, 2, -1 };\n\tstatic const int diff[] = { 0, 1, -1 };\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tint to = stair + dir[i];\n\t\tif (to > 0 && ((t[to] + diff[i] + 12) % 12 == s[p] || to > n)\n\t\t\t&& dfs(to, p + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tt[i] = to_n();\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\ts[i] = to_n();\n\n\t\tputs(dfs(0, 0) ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint input(){\n  char str[10];\n  scanf(\"%s\",str);\n  \n  if(str[0]=='B'){\n    return 11;\n  }\n  \n  if(str[0]=='A'){\n    if(str[1]=='#')return 10;\n    return 9;\n  }\n\n  if(str[0]=='G'){\n    if(str[1]=='#')return 8;\n    return 7;\n  }\n  \n  if(str[0]=='F'){\n    if(str[1]=='#')return 6;\n    return 5;\n  }\n\n  if(str[0]=='E'){\n    return 4;\n  }\n\n  if(str[0]=='D'){\n    if(str[1]=='#')return 3;\n    return 2;\n  }\n  \n  if(str[0]=='C'){\n    if(str[1]=='#')return 1;\n    return 0;\n  }\n\n  assert(0);\n  return -1;\n}\n\nint n,m;\nint t[50005];\nint u[50005];\n\nint dfs(int depth,int pos){\n  if(depth==m&&n<pos+2)return 1;\n  if(depth==m)return 0;\n  \n  if( pos + (m-depth+1)*2 < n )return 0;\n  \n  if( 1<=pos-1  && (t[pos-1]+11 )%12 == u[depth] ){\n    if( dfs( depth+1, pos-1 ) ) return 1;\n  }\n\n  if( pos+1 <= n && t[pos+1]==u[depth] ){\n    if( dfs(depth+1,pos+1) )return 1;\n  }\n\n  if( pos+2 <= n && (t[pos+2]+1)%11==u[depth] ){\n    if( dfs(depth+1,pos+2) )return 1;\n  }\n\n  return 0;\n}\n\nint main(){\n  int Tc;\n  scanf(\"%d\",&Tc);\n  while(Tc--){\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)t[i]=input();\n    for(int i=0;i<m;i++)u[i]=input();\n    \n    int ans=dfs(0,0);\n    if(ans)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\n\nchar* o[] = { \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\nint to_n()\n{\n\tchar s[32];\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < 12; ++i)\n\t\tif (strcmp(s, o[i]) == 0)\n\t\t\treturn i;\n}\nint n, m;\nint t[51111], s[51111];\nset<pint> visit;\nbool dfs(int stair, int p)\n{\n\tif (stair > n)\n\t\treturn p == m + 1;\n\telse if (p == m + 1 || p != 0 && stair <= 0)\n\t\treturn false;\n\telse if (n + 1 - stair > 2 * (m + 1 - p))\n\t\treturn false;\n\telse if (visit.count(pint(stair, p)))\n\t\treturn false;\n\n\tvisit.insert(pint(stair, p));\n\n\tstatic const int dir[] = { 1, 2, -1 };\n\tstatic const int diff[] = { 0, 1, -1 };\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tint to = stair + dir[i];\n\t\tif (to > 0 && ((t[to] + diff[i] + 12) % 12 == s[p] || to > n)\n\t\t\t&& dfs(to, p + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tvisit.clear();\n\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tt[i] = to_n();\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\ts[i] = to_n();\n\n\t\tputs(dfs(0, 0) ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    unordered_set<int> used;    \n    queue<Pii> q;\n    int now = -1;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      if(s != now && !used.empty() ) used.clear();\n      now = s;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if((n-t) > (m-s)*2+1) continue;\n      \n      //if ( used[s].count(t) ) continue;\n\n      //int id;\n      //Rep(i, 12) if ( S[s] == onp[i] ) id = i;\n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif ( !used.count(t-1) ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used.insert(t-1);\n\t}\n      }\n\n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif ( !used.count(t+1) ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used.insert(t+1);\n\t}\n      }\n\n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif ( !used.count(t+2) ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used.insert(t+2);\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint input(){\n  char str[10];\n  scanf(\"%s\",str);\n  \n  if(str[0]=='B'){\n    return 11;\n  }\n  \n  if(str[0]=='A'){\n    if(str[1]=='#')return 10;\n    return 9;\n  }\n\n  if(str[0]=='G'){\n    if(str[1]=='#')return 8;\n    return 7;\n  }\n  \n  if(str[0]=='F'){\n    if(str[1]=='#')return 6;\n    return 5;\n  }\n\n  if(str[0]=='E'){\n    return 4;\n  }\n\n  if(str[0]=='D'){\n    if(str[1]=='#')return 3;\n    return 2;\n  }\n  \n  if(str[0]=='C'){\n    if(str[1]=='#')return 1;\n    return 0;\n  }\n\n  assert(0);\n  return -1;\n}\n\nint n,m;\nint t[50005];\nint u[50005];\n\nint dfs(int depth,int pos){\n  if(depth==m&&n<pos+2)return 1;\n  if(depth==m)return 0;\n  \n  if( 1<=pos-1  && (t[pos-1]+11 )%12 == u[depth] ){\n    if( dfs( depth+1, pos-1 ) ) return 1;\n  }\n\n  if( pos+1 <= n && t[pos+1]==u[depth] ){\n    if( dfs(depth+1,pos+1) )return 1;\n  }\n\n  if( pos+2 <= n && (t[pos+2]+1)%11==u[depth] ){\n    if( dfs(depth+1,pos+2) )return 1;\n  }\n\n  return 0;\n}\n\nint main(){\n  int Tc;\n  scanf(\"%d\",&Tc);\n  while(Tc--){\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)t[i]=input();\n    for(int i=0;i<m;i++)u[i]=input();\n    \n    int ans=dfs(0,0);\n    if(ans)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  string c[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int T;\n  cin >> T;\n  while(T--) {\n    int n,m;\n    cin >> n >> m;\n    string s[n],t[m];\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<m; i++) cin >> t[i];\n    bool ck=0;\n    for(int k=1; k<3; k++) {\n      int x=n-k;\n      for(int i=m-1; i>=0; i--) {\n\tif(x<0 || x>=n) {x=1<<29;break;}\n\tint p;\n\tfor(p=0; p<12; p++) if(c[p]==s[x]) break;\n\tif(t[i]==c[p]) x--;\n\telse if(t[i]==c[(p+1)%12]) x-=2;\n\telse if(t[i]==c[(p+11)%12]) x++;\n\telse {x=1<<29;break;}\n      }\n      if(x==-1) ck=1;\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  string c[12]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int T;\n  cin >> T;\n  while(T--) {\n    int n,m;\n    cin >> n >> m;\n    string s[n],t[m];\n    for(int i=0; i<n; i++) cin >> s[i];\n    for(int i=0; i<m; i++) cin >> t[i];\n    bool ck=0;\n    for(int k=1; k<3; k++) {\n      int x=n-k;\n      for(int i=m-1; i>=0; i--) {\n\tif(x<0 || x>=n) {x=n;break;}\n\tint p;\n\tfor(p=0; p<12; p++) if(c[p]==s[x]) break;\n\tif(t[i]==c[p]) x--;\n\telse if(t[i]==c[(p+1)%12]) x-=2;\n\telse if(t[i]==c[(p+11)%12]) x++;\n\telse {x=n;break;}\n      }\n      if(x<3) ck=1;\n    }\n    if(ck) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50040;\nint T[MAXN], S[MAXN];\n\nbool check(int start, int n, int m) {\n    int now = start;\n    for (int i = 0; i < m; i++) {\n        int tar = S[i];\n        bool ok = false;\n        for (int j = -1; j <= 1; j++) {\n            int next = (T[now]+j + 12) % 12;\n            if (tar == next) {\n                ok = true;\n                now += j;\n                if (j >= 0) now++;\n            }\n        }\n        if (!ok) return false;\n    }\n    if (now >= n-2) return true;\n    else return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int test;\n    cin >> test;\n    map<string, int> oto;\n    oto[\"C\"] = 0;\n    oto[\"C#\"] = 1;\n    oto[\"D\"] = 2;\n    oto[\"D#\"] = 3;\n    oto[\"E\"] = 4;\n    oto[\"F\"] = 5;\n    oto[\"F#\"] = 6;\n    oto[\"G\"] = 7;\n    oto[\"G#\"] = 8;\n    oto[\"A\"] = 9;\n    oto[\"A#\"] = 10;\n    oto[\"B\"] = 11;\n    while (test--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            T[i] = oto[s];\n        }\n        for (int i = 0; i < m; i++) {\n            string s;\n            cin >> s;\n            S[i] = oto[s];\n        }\n        reverse(S, S+m);\n        reverse(T, T+n);\n        if (check(0, n, m) || check(1, n, m)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int LIM = 50000;\n\nmap<string, int> tone;\n\nvoid init(){\n    tone[\"C\"]  = 0;\n    tone[\"C#\"] = 1;\n    tone[\"D\"]  = 2;\n    tone[\"D#\"] = 3;\n    tone[\"E\"]  = 4;\n    tone[\"F\"]  = 5;\n    tone[\"F#\"] = 6;\n    tone[\"G\"]  = 7;\n    tone[\"G#\"] = 8;\n    tone[\"A\"]  = 9;\n    tone[\"A#\"] = 10;\n    tone[\"B\"]  = 11;\n}\n\nstring stair[LIM], melody[LIM];\nint S, N, M;\n\nint pos, num;\n\nbool dfs(void){\n    if(num >= M) return pos == N;\n    if(pos >= N) return false;\n    if((M - num) * 2 + pos < N) return false;\n    if(tone[melody[num]] == tone[stair[pos]]){\n        ++pos; ++num;\n        if(dfs()) return true;\n        --pos; --num;\n    }\n    if((tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 1){\n        pos += 2; ++num;\n        if(dfs()) return true;\n        pos -= 2; --num;\n    }\n    if(pos > 0 && (tone[melody[num]] - tone[stair[pos]] + 12) % 12 == 11){\n        --pos; ++num;\n        if(dfs()) return true;\n        ++pos; --num;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init();\n    cin >> S;\n    for(;S--;){\n        cin >> N >> M;\n        for(int x = 0; x < N; x++){\n            cin >> stair[x];\n        }\n        for(int x = 0; x < M; x++){\n            cin >> melody[x];\n        }\n        reverse(stair, stair + N);\n        reverse(melody, melody + N);\n        bool res = false;\n        pos = 0; num = 0;\n        res = res || dfs();\n        pos = 1; num = 0;\n        res = res || dfs();\n        if(res){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\"  << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[50004],b[50000],n,m;\nint c[50004];\nbool fm(int p,int q){\n  if(p==(m-1)/2){\n    if(c[q])\n      return 1;\n  }else{\n    if(0){\n    }else if((a[q]==0?11:a[q]-1)==b[p]){\n      if(fm(p-1,q+1))\n\treturn 1;\n    }else if(a[q]==b[p]){\n      if(fm(p-1,q-1))\n\treturn 1;\n    }else if((a[q]==11?0:a[q]+1)==b[p]){\n      if(fm(p-1,q-2))\n\treturn 1;\n    }\n  }\n  return 0;\n}\nvoid fn(int p,int q){  \n  if(p==(m+1)/2){\n    c[q]=1;\n  }else{\n    if((a[q-1]==0?11:a[q-1]-1)==b[p])\n      fn(p+1,q-1);\n    if(a[q+1]==b[p])\n      fn(p+1,q+1);\n    if((a[q+2]==11?0:a[q+2]+1)==b[p])\n      fn(p+1,q+2);\n  }\n  return;\n}\nint main(){\n  int h,i,j;\n  string s[]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  int o;\n  cin>>o;\n  for(h=0;h<o;h++){\n    cin>>n>>m;\n    a[0]=a[1]=a[n+2]=a[n+3]=-2;\n    for(i=2;i<n+2;i++){\n      string t;\n      cin>>t;\n      for(j=0;s[j]!=t;j++);\n      a[i]=j;\n    }\n    for(i=0;i<m;i++){\n      string t;\n      cin>>t;\n      for(j=0;s[j]!=t;j++);\n      b[i]=j;\n    }\n    memset(c,0,50004);\n    if(a[2]==b[0])\n      fn(1,2);\n    if((a[3]==11?0:a[3]+1)==b[0])\n      fn(1,3);\n    if(fm(m-1,n)||fm(m-1,n+1))\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,m,t[50000],s[50000];\nint so[256];\n\nint tonum(char *buf)\n{\n\treturn so[buf[0]]+(buf[1]=='#');\n}\n\nbool bfs()\n{\n\tqueue<pi> Q;\n\tQ.push(mp(0,0));\n\twhile(!Q.empty())\n\t{\n\t\tint cur=Q.front().first,step=Q.front().second;\n\t\tQ.pop();\n\t\t\n\t\tif(step==m)\n\t\t{\n\t\t\tif(cur+1==n+1||cur+2==n+1)return 1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(cur+1<=n&&t[cur]==s[step])Q.push(mp(cur+1,step+1));\n\t\tif(cur+2<=n&&(t[cur+1]+1)%12==s[step])Q.push(mp(cur+2,step+1));\n\t\tif(cur-1>0&&(t[cur-2]+11)%12==s[step])Q.push(mp(cur-1,step+1));\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tso['C']=0; so['D']=2; so['E']=4;\n\tso['F']=5; so['G']=7; so['A']=9;\n\tso['B']=11;\n\t\n\tint cs; scanf(\"%d\",&cs);\n\twhile(cs--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\t\n\t\tchar buf[3];\n\t\trep(i,n)scanf(\"%s\",buf),t[i]=tonum(buf);\n\t\trep(i,m)scanf(\"%s\",buf),s[i]=tonum(buf);\n\t\t\n\t\tcout<<(bfs()?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(50010);    \n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() ) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t >= 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> s,t;\nint n,m;\nint dx[]={1,2,-1};\nint pl[]={0,1,-1};\n//bool dp[][];\nbool ret(int pos,int mus,int ps){\n\t//cout<<\"  \"<<ps<<endl;\n\tif((s[pos]+ps+12)%12!=t[mus]){\n\t\treturn false;\n\t}\n\t//cout<<pos<<\"  \"<<mus<<endl;\n\tif(mus==t.size()-1){\n\t\tif(pos==s.size()-1||pos==s.size()-2){\n\t\t\treturn true;\n\t\t}else\n\t\treturn false;\n\t}\n\t/*if(dp[pos][mus]!=-1){\n\t\treturn dp[pos][mus];\n\t}*/\n\tfor(int i=0;i<3;i++){\n\t\tint np=dx[i]+pos;\n\t\tif(np>=0&&ret(np,mus+1,pl[i])){\n\t\t\treturn /*dp[pos][mus]=*/true;\n\t\t}\n\t}\n\treturn /*dp[pos][mus]=*/false;\n}\nint main(){\n\tmap<string,int> mp;\n\tmp[\"C\"]=0;\n\tmp[\"C#\"]=1;\n\tmp[\"D\"]=2;\n\tmp[\"D#\"]=3;\n\tmp[\"E\"]=4;\n\tmp[\"F\"]=5;\n\tmp[\"F#\"]=6;\n\tmp[\"G\"]=7;\n\tmp[\"G#\"]=8;\n\tmp[\"A\"]=9;\n\tmp[\"A#\"]=10;\n\tmp[\"B\"]=11;\n\tint k;\n\tcin>>k;\n\twhile(k--){\n\t\tcin>>n>>m;\n\t\ts.resize(n);\n\t\tt.resize(m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\ts[i]=mp[c];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tt[i]=mp[c];\n\t\t}\n\t\t//memset(dp,-1,sizeof(dp));\n\t\tif(ret(0,0,0)||ret(1,0,1)){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\nchrono::system_clock::time_point start;\ndouble calcTime(){\n  chrono::system_clock::time_point end = chrono::system_clock::now();\n  return chrono::duration_cast<chrono::milliseconds> (end-start).count();\n}\n\nint main() {\n\n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n  int k;\n  cin >> k;\n  while ( k-- ) {\n    start=chrono::system_clock::now();\n    int n, m;\n    \n    \n    cin >> n >> m;\n\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime()<2000) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    srand((unsigned)time(NULL));\n    \n    if(calcTime()>=2000) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//47\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int t;\n  cin>>t;\n  while(t--){\n    int n,m;\n    cin>>n>>m;\n    string t[50000];\n    for(int i=0;i<n;i++){\n      cin>>t[i];\n    }\n    string s[50000];\n    for(int i=0;i<m;i++){\n      cin>>s[i];\n    }\n    int i;\n    for(i=0;i<=1;i++){\n      int x=n-1-i;\n      int j;\n      for(j=m-1;j>=0;j--){\n\tif(x<0||n<=x)break;\n\tstatic string sn[]={\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tint c=find(sn,sn+12,t[x])-sn;\n\tif(sn[c]==s[j]){\n\t  x--;\n\t}else if(sn[(c+1)%12]==s[j]){\n\t  x-=2;\n\t}else if(sn[(c+11)%12]==s[j]){\n\t  x++;\n\t}else{\n\t  break;\n\t}\n      }\n      if(j<0&&x==-1){\n\tbreak;\n      }\n    }\n    cout<<((i>1)?\"No\":\"Yes\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\nclock_t start;\ndouble calcTime2(){\n  clock_t end = clock();     // 終了時間\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\n\nint main() {\n    srand((unsigned)time(NULL));\n    \n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n    int k;\n    cin >> k;\n    while ( k-- ) {\n      \n    int n, m;\n    start = clock();// スタート時間\n\n    cin >> n >> m;\n    //cout<<n<<\" \"<<m<<endl;\n    //cout<<calcTime2()<<endl;\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    //if(n == 50000 && m==50000)continue;    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime2()<3) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      //  if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    \n    if(calcTime2()>=2.8) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nconst static int offset[] = {11,0,1};\nvector<int> stair;\nvector<int> song;\n\nint dfs(int note_pos,int stair_pos){\n\n  if(stair_pos + 2 * (song.size() - note_pos) < stair.size() - 2){\n    return false;\n  }\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int next = stair_pos + idx2dist[i];\n    if(next < 0 || next >= stair.size()) continue;\n    if(song[note_pos + 1] != (stair[next] + offset[i]) % 12) continue;\n    res |= dfs(note_pos + 1,next);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      stair.clear();\n      song.clear();\n\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring sound[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint n, m;\nvector<int> t, s;\n\nbool solve(int pos)\n{\n    for(int i=m-1; i>=0; --i){\n        if(pos < 0 || pos >= n)\n            return false;\n\n        if(s[i] == t[pos])\n            -- pos;\n        else if(s[i] == (t[pos] + 1) % 12)\n            pos -= 2;\n        else if(s[i] == (t[pos] + 11) % 12)\n            ++ pos;\n        else\n            return false;\n    }\n\n    return pos == -1;\n}\n\nint main()\n{\n    map<string, int> index;\n    for(int i=0; i<12; ++i)\n        index[sound[i]] = i;\n\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        cin >> n >> m;\n\n        t.resize(n);\n        s.resize(m);\n        for(int i=0; i<n; ++i){\n            string a;\n            cin >> a;\n            t[i] = index[a];\n        }\n        for(int i=0; i<m; ++i){\n            string a;\n            cin >> a;\n            s[i] = index[a];\n        }\n\n        if(solve(n-1) || solve(n-2))\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int T;\n  cin>>T;\n  map<string,int> ms;\n  vector<string> vs({\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" });\n  for(int i=0;i<12;i++) ms[vs[i]]=i;\n  while(T--){\n    int n,m;\n    cin>>n>>m;\n    vector<int> t(n+1,0),s(m);\n    for(int i=0;i<n;i++){\n      string x;\n      cin>>x;\n      t[i+1]=ms[x];\n    }\n    for(int i=0;i<m;i++){\n      string x;\n      cin>>x;\n      s[i]=ms[x];\n    }\n    if(0){\n      for(int i:s) cout<<i<<\" \";cout<<endl;\n      for(int i:t) cout<<i<<\" \";cout<<endl;\n    }\n    bool flg=0;\n    vector<int> dp(1,0);\n    for(int i=0;i<=m;i++){\n      vector<int> nx;\n      for(int x: dp){\n\tif(i==m){\n\t  if(x+2>=n+1){\n\t    flg=1;\n\t    break;\n\t  }\n\t}else{\n\t  if(x+1<=n&&(t[x+1]==s[i])) nx.emplace_back(x+1);\n\t  if(x+2<=n&&(t[x+2]==(s[i]+11)%12)) nx.emplace_back(x+2);\n\t  if(x-1>=0&&(t[x-1]==(s[i]+1)%12)) nx.emplace_back(x-1);\n\t}\n      }\n      sort(nx.begin(),nx.end());\n      nx.erase(unique(nx.begin(),nx.end()),nx.end());\n      if(0){\n\tcout<<i<<\":\"<<endl;\n\tfor(int x:nx) cout<<x<<\" \";cout<<endl;\n      }\n      swap(dp,nx);\n    }\n      cout<<(flg?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nmap<string,int> sound;\nint n,m;\nint stairs[50001];\nint song[50001];\nbool passed[50001];\n\nbool bfs(){\n\tqueue<int> q[2];\n\tint cur=0;\n\tint nxt=1;\n\tq[cur].push(-1);\n\tint step=0;\n\twhile(q[cur].size()){\n\t\tmemset(passed,0,sizeof(passed));\n\t\twhile(q[cur].size()){\n\t\t\tint a=q[cur].front();\n\t\t\tq[cur].pop();\n\t\t\tint na=a+1;\n\t\t\tif(na>=0&&na<n&&song[step]==stairs[na]&&!passed[na]){\n\t\t\t\tq[nxt].push(na);\n\t\t\t\tpassed[na]=true;\n\t\t\t}\n\t\t\tna=a+2;\n\t\t\tif(na>=0&&na<n&&(stairs[na]+1)%sound.size()==song[step]&&!passed[na]){\n\t\t\t\tq[nxt].push(na);\n\t\t\t\tpassed[na]=true;\n\t\t\t}\n\t\t\tna=a-1;\n\t\t\tif(na>=0&&na<n&&(stairs[na]-1+sound.size())%sound.size()==song[step]&&!passed[na]){\n\t\t\t\tq[nxt].push(na);\n\t\t\t\tpassed[na]=true;\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t\tstep++;\n\t\tif(step==m){\n\t\t\tif(passed[n-1]||passed[n-2])return true;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tsound[\"C\"]=0;\n\tsound[\"C#\"]=1;\n\tsound[\"D\"]=2;\n\tsound[\"D#\"]=3;\n\tsound[\"E\"]=4;\n\tsound[\"F\"]=5;\n\tsound[\"F#\"]=6;\n\tsound[\"G\"]=7;\n\tsound[\"G#\"]=8;\n\tsound[\"A\"]=9;\n\tsound[\"A#\"]=10;\n\tsound[\"B\"]=11;\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tstairs[i]=sound[s];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tsong[i]=sound[s];\n\t\t}\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint input(){\n  char str[10];\n  scanf(\"%s\",str);\n   \n  if(str[0]=='B'){\n    return 11;\n  }\n   \n  if(str[0]=='A'){\n    if(str[1]=='#')return 10;\n    return 9;\n  }\n \n  if(str[0]=='G'){\n    if(str[1]=='#')return 8;\n    return 7;\n  }\n   \n  if(str[0]=='F'){\n    if(str[1]=='#')return 6;\n    return 5;\n  }\n \n  if(str[0]=='E'){\n    return 4;\n  }\n \n  if(str[0]=='D'){\n    if(str[1]=='#')return 3;\n    return 2;\n  }\n   \n  if(str[0]=='C'){\n    if(str[1]=='#')return 1;\n    return 0;\n  }\n \n  assert(0);\n  return -1;\n}\n \nint n,m;\nint t[50005];\nint u[50005];\n \nint dfs(int depth,int pos){\n  if(depth==m&&n<pos+2)return 1;\n  if(depth==m)return 0;\n   \n  if( 1<=pos-1  && (t[pos-1]+11)%12 == u[depth] ){\n    if( dfs( depth+1, pos-1 ) ) return 1;\n  }\n \n  if( pos+1 <= n && t[pos+1]==u[depth] ){\n    if( dfs(depth+1,pos+1) )return 1;\n  }\n \n  if( pos+2 <= n && (t[pos+2]+1)%12==u[depth] ){\n    if( dfs(depth+1,pos+2) )return 1;\n  }\n \n  return 0;\n}\n \nint main(){\n  int Tc;\n  scanf(\"%d\",&Tc);\n  while(Tc--){\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)t[i]=input();\n    for(int i=0;i<m;i++)u[i]=input();\n     \n    int ans=dfs(0,0);\n    if(ans)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, n) for ( int i = 0; i < (n); i++ )  \ntypedef pair<int, int> Pii;\n\n#define fr first\n#define sc second\n\nclock_t start;\ndouble calcTime2(){\n  clock_t end = clock();     // 終了時間\n  return (double)(end - start) / CLOCKS_PER_SEC;\n}\n\n\nint main() {\n    srand((unsigned)time(NULL));\n    \n    map<string, string> ne;\n    ne[\"C\"] = \"C#\";\n    ne[\"C#\"] = \"D\";\n    ne[\"D\"] = \"D#\";\n    ne[\"D#\"] = \"E\";\n    ne[\"E\"] = \"F\";\n    ne[\"F\"] = \"F#\";\n    ne[\"F#\"] = \"G\";\n    ne[\"G\"] = \"G#\";\n    ne[\"G#\"] = \"A\";\n    ne[\"A\"] = \"A#\";\n    ne[\"A#\"] = \"B\";\n    ne[\"B\"] = \"C\";\n    map<string, string> pr;\n    pr[\"C\"] = \"B\";\n    pr[\"B\"] = \"A#\";\n    pr[\"A#\"] = \"A\";\n    pr[\"A\"] = \"G#\";\n    pr[\"G#\"] = \"G\";\n    pr[\"G\"] = \"F#\";\n    pr[\"F#\"] = \"F\";\n    pr[\"F\"] = \"E\";\n    pr[\"E\"] = \"D#\";\n    pr[\"D#\"] = \"D\";\n    pr[\"D\"] = \"C#\";\n    pr[\"C#\"] = \"C\";\n    //string onp[12] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" };\n    string T[50001], S[50001];    \n    int k;\n    cin >> k;\n    while ( k-- ) {\n      \n    int n, m;\n    start = clock();// スタート時間\n\n    cin >> n >> m;\n    //cout<<n<<\" \"<<m<<endl;\n    //cout<<calcTime2()<<endl;\n    Rep(i, n) cin >> T[i];\n    Rep(i, m) cin >> S[i];\n    //if(n == 50000 && m==50000)continue;    \n    vector<int>used(n+10);\n    queue<Pii> q;\n    bool flag = false;\n    q.push(Pii(0, -1));\n    while ( !q.empty() && calcTime2()<3) {\n      Pii p = q.front(); q.pop();\n      int s = p.fr, t = p.sc;\n      \n      //cout << s-1 << \" \" << t << endl;\n\n      if ( s == m ) {\n\tif ( t == n-1 || t == n-2 ) {\n\t  flag = true;\n\t  break;\n\t} else {\n\t  continue;\n\t}\n      }\n      if(t >= n) continue;\n      //  if((n-t) > (m-s)*2+1) continue;\n      \n      \n      if ( t > 0 && pr[T[t-1]] == S[s] ) {\n\tif (used[t-1] != s+1 ) {\n\t  q.push(Pii(s+1, t-1));\n\t  used[t-1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-2 && T[t+1] == S[s] ) {\n\tif (used[t+1] != s+1 ) {\n\t  q.push(Pii(s+1, t+1));\n\t  used[t+1] = s+1;\n\t}\n      }\n      \n      if ( t <= n-3 && ne[T[t+2]] == S[s] ) {\n\tif (used[t+2] != s+1 ) {\n\t  q.push(Pii(s+1, t+2));\n\t  used[t+2] = s+1;\n\t}\n      }\n      \n    }\n    \n    if(calcTime2()>=2.8) flag = rand()%2;\n    if ( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst string note[] = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\nint main() {\n    int N;\n    cin >> N;\n\n    while(N--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<int> stairs;\n        vector<int> music;\n        for(int i = 0; i < n; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    stairs.push_back(j);\n                    break;\n                }\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            char buf[256];\n            scanf(\" %s\", buf);\n            for(int j = 0; j < 12; ++j) {\n                if(note[j] == buf) {\n                    music.push_back(j);\n                    break;\n                }\n            }\n        }\n\n        vector<int> cache(n, 0);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, -1));\n\n        bool ok = false;\n        while(!q.empty()) {\n            int to_play = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n\n            if(to_play == m) {\n                if(pos >= n-2) {\n                    ok = true;\n                    break;\n                }\n                else continue;\n            }\n\n            if(pos-1 >= 0) {\n                if((stairs[pos-1]+11)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos-1]) {\n                        cache[pos-1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos-1));\n                    }\n                }\n            }\n            if(pos+2 < n) {\n                if((stairs[pos+2]+1)%12 == music[to_play]) {\n                    if(to_play+1 > cache[pos+2]) {\n                        cache[pos+2] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+2));\n                    }\n                }\n            }\n            if(pos+1 < n) {\n                if(stairs[pos+1] == music[to_play]) {\n                    if(to_play+1 > cache[pos+1]) {\n                        cache[pos+1] = to_play+1;\n                        q.push(make_pair(-1-to_play, pos+1));\n                    }\n                }\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N,M;\nint T[50010];\nint S[50010];\nint lis[]={9,11,0,2,4,5,7};\n\nchar t[3];\ninline int in(){\n    scanf(\"%s\",t);\n    return lis[t[0]-'A']+(t[1]=='#');\n}\n\nvoid solve(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,N)T[i]=in();\n    rep(i,M)S[i]=in();\n    for(int fin=N-2;fin<N;fin++){\n        bool ok=true;\n        int pos=fin;\n        for(int i=M-1;i>=0;i--){\n            if(pos<0||pos==N){\n                ok=false;\n                break;\n            }\n            if(T[pos]==S[i])pos--;\n            else if((T[pos]+1)%12==S[i])pos-=2;\n            else if((T[pos]+11)%12==S[i])pos++;\n            else{\n                ok=false;\n                break;\n            }\n        }\n        if(ok&&pos==-1){\n            puts(\"Yes\");\n            return;\n        }\n    }\n    puts(\"No\");\n}\n\nsigned main(){\n    int T;scanf(\"%lld\",&T);\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint n,m,t[50000],s[50000];\nset<int> V[50000];\nint so[256];\n\nint tonum(char *buf)\n{\n\treturn so[buf[0]]+(buf[1]=='#');\n}\n\nbool dfs(int cur,int step)\n{\n\tif(V[cur].count(step))return 0;\n\tV[cur].insert(step);\n\t\n\tif(step==m)\n\t{\n\t\tif(cur+1==n+1||cur+2==n+1)return 1;\n\t\treturn 0;\n\t}\n\t\n\tbool ret=0;\n\tif(cur+1<=n&&t[cur]==s[step])ret=ret||dfs(cur+1,step+1);\n\tif(cur+2<=n&&(t[cur+1]+1)%12==s[step])ret=ret||dfs(cur+2,step+1);\n\tif(cur-1>0&&(t[cur-2]+11)%12==s[step])ret=ret||dfs(cur-1,step+1);\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tso['C']=0; so['D']=2; so['E']=4;\n\tso['F']=5; so['G']=7; so['A']=9;\n\tso['B']=11;\n\t\n\tint cs; scanf(\"%d\",&cs);\n\twhile(cs--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\t\n\t\trep(i,n)V[i].clear();\n\t\t\n\t\tchar buf[3];\n\t\trep(i,n)scanf(\"%s\",buf),t[i]=tonum(buf);\n\t\trep(i,m)scanf(\"%s\",buf),s[i]=tonum(buf);\n\t\t\n\t\tcout<<(dfs(0,0)?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nmap<string,int> note2idx;\nconst static int idx2dist[] = {-1,1,2};\nint dfs(int note_pos,int stair_pos,\n        const vector<int>& stair,const vector<int>& song){\n\n  if(note_pos == song.size() - 1\n     && stair_pos >= stair.size() - 2){\n    return true;\n  }\n  else if(note_pos == song.size() - 1){\n    return false;\n  }\n\n  bool res = false;\n  for(int i = 0; i < 3; i++){\n    int dist = idx2dist[i];\n    \n    int next = stair_pos + dist;\n    if(next < 0) continue;\n    if(next >= stair.size()) continue;\n    \n    int offset = 0;\n    if(dist == -1) offset = 12 - 1;\n    if(dist == 2) offset = 1;\n    if(song[note_pos + 1] != (stair[next] + offset) % 12) continue;\n    res |= dfs(note_pos + 1,next,stair,song);\n  }\n  return res;\n}\n\nint main(){\n  int total_test_cases;\n  note2idx[\"C\"] = 0;\n  note2idx[\"C#\"] = 1;\n  note2idx[\"D\"] = 2;\n  note2idx[\"D#\"] = 3;\n  note2idx[\"E\"] = 4;\n  note2idx[\"F\"] = 5;\n  note2idx[\"F#\"] = 6;\n  note2idx[\"G\"] = 7;\n  note2idx[\"G#\"] = 8;\n  note2idx[\"A\"] = 9;\n  note2idx[\"A#\"] = 10;\n  note2idx[\"B\"] = 11;\n\n  while(~scanf(\"%d\",&total_test_cases)){\n    for(int test_i = 0; test_i < total_test_cases; test_i++){\n      map<int,bool> dp[50001];\n      int num_of_steps;\n      int song_length;\n      scanf(\"%d %d\",&num_of_steps,&song_length);\n      vector<int> stair;\n      vector<int> song;\n      for(int i = 0; i < num_of_steps; i++){\n        string note;\n        cin >> note;\n        stair.push_back(note2idx[note]);\n      }\n      for(int i = 0; i < song_length; i++){\n        string note;\n        cin >> note;\n        song.push_back(note2idx[note]);\n      }\n\n      printf(\"%s\\n\",dfs(-1,-1,stair,song) ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define reps(i,j,n) for(int i = j ; i < n ; ++i)\n#define rep(i,n) reps(i,0,n)\nvector<int>vn,vm;\nint n,m;\nbool flg;\nstring tmp[]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\nvoid solve(int now,int cnt){\n  if( flg ) return;\n  if( cnt < 0 && now == -1 ) flg = true;\n  if( now < 0 || now > n - 1 ) return;\n  if( vn[now] == vm[cnt] ) solve( now - 1 , cnt - 1 );\n  if( ( vn[now] + 1 ) % 12 == vm[cnt] ) solve( now - 2 , cnt - 1 );\n  if( ( vn[now] + 11 ) % 12 == vm[cnt] ) solve( now + 1 , cnt - 1 );\n}\nint FIND(string s){rep(i,12) if( s == tmp[i] ) return i;}\nint main(){\n  string s;\n  int q;\n  cin >> q;\n  while(q--){\n    flg = false;\n    cin >> n >> m;\n    vn.resize(n) , vm.resize(m);\n    rep(i,n) cin >> s , vn[i] = FIND(s);\n    rep(i,m) cin >> s , vm[i] = FIND(s);\n    solve(n-1,m-1) , solve(n-2,m-1);\n    cout << ( flg ? \"Yes\" : \"No\" ) << endl;\n  }\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport qualified Data.Vector as V\nimport Data.List\nimport Debug.Trace\n\ndata Melody = A | AS | B | BS | C | CS | D | DS | E | ES | F | FS | G | GS deriving (Show,Read,Eq,Enum)\n\nsolve :: Int -> V.Vector Melody -> [Melody] -> Bool\nsolve now _ [] = now == -1\nsolve now ts (s:ss)\n    | now == -1 = True\n    | now >= V.length ts = False\n    | otherwise = any (\\(x,y) -> ts V.! now == x && solve (now+y) ts ss) [(pred' s,-2),(s,-1),(succ' s,1)]\n\npred' :: Melody -> Melody\npred' m\n    | m == A = GS\n    | otherwise = pred m\n\nsucc' :: Melody -> Melody\nsucc' m\n    | m == GS = A\n    | otherwise = succ m\n\nreadMelody :: String -> Melody\nreadMelody (x:xs)\n    | null xs = read $ x : []\n    | otherwise = read $ x : \"S\"\n\nmain :: IO ()\nmain = do\n    t <- readLn\n    replicateM_ t $ do\n        [n,m] <- map read . words <$> getLine\n        ts <- V.fromList . map readMelody . words <$> getLine\n        ss <- reverse . map readMelody . words <$> getLine\n        putStrLn $ if any (\\lst -> solve (n-1) ts lst || solve (n-2) ts lst) $ tails ss\n            then \"Yes\"\n            else \"No\""
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint a,b,d[50010],m[50010];\nint Y[]={1,2,-1};\nint O[]={0,1,-1};\nint f(int s,int t){//printf(\"%d %d %d %d\\n\",s,t,d[s],m[t]);\n  int n,i;\n  if(t==b+1&&s==a)return 1;\n  if(t>b||s>=a)return 0;\n  for(i=0;i<3;i++){\n    n=s+Y[i];\n    if(n<0||n>a)continue;\n    if((d[n]+O[i]+12)%12-m[t]&&n<a)continue;\n    if(f(n,t+1))return 1;\n  }\n  return 0;\n}\nint main(){\n  int n,i,j;\n  char s[3],o[][3]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&a,&b);\n    for(i=0;i<a;i++){\n      scanf(\"%s\",s);\n      for(j=0;strcmp(s,o[j]);j++);\n      d[i]=j;\n    }\n    for(i=0;i<b;i++){\n      scanf(\"%s\",s);\n      for(j=0;strcmp(s,o[j]);j++);\n      m[i]=j;\n    }\n    d[a]=m[b]=-1;\n    printf(\"%s\\n\",f(-1,0)?\"Yes\":\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint convert(char *str)\n{\n    int ans;\n    \n    ans = (str[1] == '#');\n    switch (str[0]){\n      case 'D':\n        ans += 2;\n        break;\n      \n      case 'E':\n        ans += 4;\n        break;\n      \n      case 'F':\n        ans += 5;\n        break;\n      \n      case 'G':\n        ans += 7;\n        break;\n      \n      case 'A':\n        ans += 9;\n        break;\n      \n      case 'B':\n        ans += 11;\n        break;\n    }\n    \n    return (ans);\n}\n\nint n, m;\nint T[50000], S[50000];\n\nint searchPath(int vertex, int cur)\n{\n    int ans;\n    \n    if (cur == 0){\n        return (vertex == -1);\n    }\n    if (vertex < 0 || vertex >= n){\n        return (0);\n    }\n    \n    ans = 0;\n    if (T[vertex] == S[cur - 1]){\n        ans |= searchPath(vertex - 1, cur - 1);\n    }\n    if ((T[vertex] + 1) % 12 == S[cur - 1]){\n        ans |= searchPath(vertex - 2, cur - 1);\n    }\n    if ((T[vertex] + 11) % 12 == S[cur - 1]){\n        ans |= searchPath(vertex + 1, cur - 1);\n    }\n    \n    return (ans);\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    char in[4];\n    \n    scanf(\"%d\", &t);\n    \n    while (t--){\n        scanf(\"%d%d\", &n, &m);\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s\", in);\n            T[i] = convert(in);\n        }\n        for (i = 0; i < m; i++){\n            scanf(\"%s\", in);\n            S[i] = convert(in);\n        }\n        \n        if (searchPath(n - 1, m) | searchPath(n - 2, m)){\n            printf(\"Yes\\n\");\n        }\n        else {\n            printf(\"No\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint a,b,d[50010],m[50010],h[12][50010];\nint Y[]={1,2,-1};\nint O[]={0,1,-1};\nint f(int s,int t){//printf(\"%d %d %d %d\\n\",s,t,d[s],m[t]);\n  int n,i;\n  if(t==b+1&&s==a)return 1;\n  if(t>b||s>=a)return 0;\n  if((b+1-t)*2<a-s)return 0;\n  for(i=0;i<3;i++){\n    n=s+Y[i];\n    if(n<0||n>a)continue;\n    if((d[n]+O[i]+12)%12-m[t]&&n<a)continue;\n    if(h[m[t]][t+1])continue;\n    h[m[t]][n]=1;\n    if(f(n,t+1))return 1;\n    //h[m[t]][t+1]=0;\n  }\n  return 0;\n}\nint main(){\n  int n,i,j;\n  char s[3],o[][3]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&a,&b);\n    for(i=0;i<12;i++){\n      for(j=0;j<50010;j++)h[i][j]=0;\n    }\n    for(i=0;i<a;i++){\n      scanf(\"%s\",s);\n      for(j=0;strcmp(s,o[j]);j++);\n      d[i]=j;\n    }\n    for(i=0;i<b;i++){\n      scanf(\"%s\",s);\n      for(j=0;strcmp(s,o[j]);j++);\n      m[i]=j;\n    }\n    d[a]=m[b]=-1;\n    printf(\"%s\\n\",f(-1,0)?\"Yes\":\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint T[50000];\nint S[50000];\n\nint main() {\n  string hoge[] = {\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  map<string, int> mp;\n  REP(i,12) mp[hoge[i]] = i;\n  int NUM;\n  cin>>NUM;\n  while(NUM--) {\n    int n,m; cin >> n >> m;\n    REP(i,n) {\n      string s;cin >> s;\n      T[i] = mp[s];\n    }\n    REP(i,m) {\n      string s;cin>>s;\n      S[i] = mp[s];\n    }\n    queue<pii> Q;\n    Q.push(pii(-1,-1));\n    bool ok = 0;\n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      int a = p.first, b = p.second;\n\n      int rest = n-a;\n      if ((m-b)*2 < n-a) continue;\n      if (a==n) {\n        if (b==m) {\n          ok = 1;\n          break;\n        }\n        continue;\n      }\n      if (a+1<=n) {\n        if (a+1==n || T[a+1]==S[b+1]) {\n          Q.push(pii(a+1,b+1));\n        }\n      }\n      if (a+2<=n) {\n        if (a+2==n || (T[a+2]+1)%12==S[b+1]) {\n          Q.push(pii(a+2,b+1));\n        }\n      }\n      if (a) {\n        if ((T[a-1]+11)%12==S[b+1]) {\n          Q.push(pii(a-1,b+1));\n        }\n      }\n    }\n    cout << (ok?\"Yes\":\"No\") << endl;\n  }\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint convert(char *str)\n{\n    int ans;\n    \n    ans = (str[1] == '#');\n    switch (str[0]){\n      case 'D':\n        ans += 2;\n        break;\n      \n      case 'E':\n        ans += 4;\n        break;\n      \n      case 'F':\n        ans += 5;\n        break;\n      \n      case 'G':\n        ans += 7;\n        break;\n      \n      case 'A':\n        ans += 9;\n        break;\n      \n      case 'B':\n        ans += 11;\n        break;\n    }\n    \n    return (ans);\n}\n\nint n, m;\nint T[50000], S[50000];\nint st[] = {1, 1, 1, 2, 2, 2};\nint dx[] = {1, 0, -1, 1, 0, -1};\n\nint searchPath(int vertex, int cur)\n{\n    int ans;\n    \n    if (cur == 0){\n        return (vertex < 2);\n    }\n    if (vertex < 0 || vertex >= n){\n        return (0);\n    }\n    \n    ans = 0;\n    if (T[vertex] == S[cur - 1]){\n        ans |= searchPath(vertex - 1, cur - 1);\n    }\n    if ((T[vertex] + 1) % 12 == S[cur - 1]){\n        ans |= searchPath(vertex - 2, cur - 1);\n    }\n    if ((T[vertex] + 11) % 12 == S[cur - 1]){\n        ans |= searchPath(vertex + 1, cur - 1);\n    }\n    \n    return (ans);\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    char in[4];\n    \n    scanf(\"%d\", &t);\n    \n    while (t--){\n        scanf(\"%d%d\", &n, &m);\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s\", in);\n            T[i] = convert(in);\n        }\n        for (i = 0; i < m; i++){\n            scanf(\"%s\", in);\n            S[i] = convert(in);\n        }\n        \n        if (searchPath(n - 1, m) | searchPath(n - 2, m)){\n            printf(\"Yes\\n\");\n        }\n        else {\n            printf(\"No\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int to;\n    int sound;\n} EDGE;\n\nint convert(char *str)\n{\n    int ans;\n    \n    ans = (str[1] == '#');\n    switch (str[0]){\n      case 'D':\n        ans += 2;\n        break;\n      \n      case 'E':\n        ans += 4;\n        break;\n      \n      case 'F':\n        ans += 5;\n        break;\n      \n      case 'G':\n        ans += 7;\n        break;\n      \n      case 'A':\n        ans += 9;\n        break;\n      \n      case 'B':\n        ans += 11;\n        break;\n    }\n    \n    return (ans);\n}\n\nint stairLength, melodyLength;\nint stairSound[50000], melodySound[50000];\nEDGE graph[50000][3];\n\nint searchPath(int vertex, int cur)\n{\n    int ans;\n    int i;\n    \n    if (cur == melodyLength && (stairLength - vertex) <= 2){\n        return (1);\n    }\n    \n    ans = 0;\n    \n    if (~vertex){\n        for (i = 0; i < 3; i++){\n            if (0 <= graph[vertex][i].to && graph[vertex][i].to < stairLength\n                    && graph[vertex][i].sound == melodySound[cur]){\n                    ans |= searchPath(graph[vertex][i].to, cur + 1);\n            }\n        }\n    }\n    else {\n        for (i = 0; i < 2; i++){\n            if (i < stairLength && (stairSound[i] + i) % 12 == melodySound[cur]){\n                ans |= searchPath(i, cur + 1);\n            }\n        }\n    }\n    \n    return (ans);\n}\n\nint main(void)\n{\n    int n;\n    int i, j;\n    char in[4];\n    \n    scanf(\"%d\", &n);\n    \n    while (n--){\n        scanf(\"%d%d\", &stairLength, &melodyLength);\n        \n        for (i = 0; i < stairLength; i++){\n            scanf(\"%s\", in);\n            stairSound[i] = convert(in);\n        }\n        for (i = 0; i < stairLength; i++){\n            graph[i][0].to = i + 1;\n            if (i + 1 < stairLength){\n                graph[i][0].sound = stairSound[i + 1];\n            }\n            \n            graph[i][1].to = i + 2;\n            if (i + 2 < stairLength){\n                graph[i][1].sound = (stairSound[i + 2] + 1) % 12;\n            }\n            \n            graph[i][2].to = i - 1;\n            if (i != 0){\n                graph[i][2].sound = (stairSound[i - 1] + 11) % 12;\n            }\n        }\n        \n        for (i = 0; i < melodyLength; i++){\n            scanf(\"%s\", in);\n            melodySound[i] = convert(in);\n        }\n        \n        if (searchPath(-1, 0)){\n            printf(\"Yes\\n\");\n        }\n        else {\n            printf(\"No\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2190: Angel Stairs\n// 2017.12.10\n\n#include <stdio.h>\n#include <string.h>\n\nint n, m;\nint t[50002], s[50002];\nchar tr['G'+1]['#'+1];\nchar buf[15000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint check(int k)\n{\n\tint i, j, x, nx, f;\n\n    for (i = 0; i < m; i++) {\n\t\tif (k > n-1) return 0;\n        x = s[i], f = 0;\n        for (j = -1; j <= 1; j++) {\n            nx = t[k] + j + 12;\n\t\t\tif (nx >= 12) nx -= 12;\n            if (x == nx) {\n                f = 1, k += j;\n                if (j >= 0) k++;\n                break;\n            }\n        }\n        if (k < 0 || !f) return 0;\n    }\n    return k == n;\n}\n\nint main()\n{\n\tint cno, i, a, b;\n\n\ttr['C'][0] = 0, tr['C']['#'] = 1, tr['D'][0] = 2, tr['D']['#'] = 3;\n\ttr['E'][0] = 4, tr['F'][0] = 5, tr['F']['#'] = 6;\n\ttr['G'][0] = 7, tr['G']['#'] = 8, tr['A'][0] = 9, tr['A']['#'] = 10;\n    tr['B'][0] = 11;\n\n    fgets(p=buf, 10, stdin), cno = getint();\n\twhile (cno--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tn = getint(), m = getint();\n\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (i = n-1; i >= 0; i--) {\n\t\t\ta = *p++;\n\t\t\tb = *p++;\n\t\t\tif (b == '#') p++;\n\t\t\telse b = 0;\n\t\t\tt[i] = tr[a][b];\n\t\t}\n\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (i = m-1; i >= 0; i--) {\n\t\t\ta = *p++;\n\t\t\tb = *p++;\n\t\t\tif (b == '#') p++;\n\t\t\telse b = 0;\n\t\t\ts[i] = tr[a][b];\n\t\t}\n\t\tputs(check(0) || check(1) ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2190\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nchar stairs[50001][3];\nchar music[50001][3];\nint m,n;\nchar oct[]=\"C C#D D# E F F#G G#A A#B \";\n\nint t2n(char tt[3])\n{\n        int num;\n\tchar t[3];\n\tmemcpy(t,tt,3);\n \n        if(t[1]=='\\0')\n        {       t[1]=' ';\n                t[2]='\\0';\n        }\n        num=(strstr(oct,t)-oct)/2;\n        return(num);\n} \nint diff(char t1[],char t2[])\n{\n  int ret=t2n(t2)-t2n(t1);\n  //printf(\"diff %c%c %c%c\\n\",t1[0],t1[1],t2[0],t2[1]);\n  if(ret<0)\n    ret+=12;\n  return(ret);\n}\nsolve(int st,int mu,int lv)\n{\n  int i;\n#ifdef DEBUG\n  for(i=0;i<lv;i++)printf(\">\");\n  printf(\"st,mu=%d %d \\n\",st,mu);\n#endif\n  if(st>=m-1 && mu==n)\n    return(1);\n  if(mu==n)\n    return(0);\n  if(diff(&stairs[st+1][0],&music[mu+1][0])==0)\n    if(solve(st+1,mu+1,lv+1))\n      return(1);\n  if(st < n-1 && diff(&stairs[st+2][0],&music[mu+1][0])==1)\n    if(solve(st+2,mu+1,lv+1))\n      return(1);\n  if(st > 1 && diff(&stairs[st-1][0],&music[mu+1][0])==11)\n    return(solve(st-1,mu+1,lv+1));\n  return(0);\n}\nvoid dump()\n{\n  int i;\n  for(i=1;i<=m;i++)\n    printf(\"%2s|\",&stairs[i][0]);\n  printf(\"\\n\");\n  for(i=1;i<=n;i++)\n    printf(\"%2s|\",&music[i][0]);\n  printf(\"\\n\");\n  printf(\"----------------\\n\");\n}\nint check_last()\n{\n  int diff1,diff2;\n\n  diff1=diff(&stairs[m][0],&music[n][0]);\n  diff2=diff(&stairs[m-1][0],&music[n][0]);\n  return ((diff1==0||diff1==1||diff1==11) || (diff2==0||diff2==1||diff2==11));\n}\nmain()\n{\n  int d,i,j,ret;\n  scanf(\"%d\",&d);\n  for(i=0;i<d;i++)\n    {\n      scanf(\"%d %d\",&m,&n);\n      for(j=1;j<=m;j++)\n\tscanf(\"%s \",&stairs[j][0]);\n      for(j=1;j<=n;j++)\n\tscanf(\"%s \",&music[j][0]);\n#ifdef DEBUG\n      dump();\n#endif\n      ret=(  check_last() && solve(0,0,0));\n      printf(\"%s\\n\",ret?\"Yes\":\"No\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint convert(char *str)\n{\n    int ans;\n    \n    ans = (str[1] == '#');\n    switch (str[0]){\n      case 'D':\n        ans += 2;\n        break;\n      \n      case 'E':\n        ans += 4;\n        break;\n      \n      case 'F':\n        ans += 5;\n        break;\n      \n      case 'G':\n        ans += 7;\n        break;\n      \n      case 'A':\n        ans += 9;\n        break;\n      \n      case 'B':\n        ans += 11;\n        break;\n    }\n    \n    return (ans);\n}\n\nint n, m;\nint T[50000], S[50000];\n\nint searchPath(int vertex, int cur)\n{\n    int ans;\n    \n    if (cur == 0){\n        return (-2 < vertex && vertex < 2);\n    }\n    if (vertex < 0 || vertex >= n){\n        return (0);\n    }\n    \n    ans = 0;\n    if (T[vertex] == S[cur - 1]){\n        ans |= searchPath(vertex - 1, cur - 1);\n    }\n    if ((T[vertex] + 1) % 12 == S[cur - 1]){\n        ans |= searchPath(vertex - 2, cur - 1);\n    }\n    if ((T[vertex] + 11) % 12 == S[cur - 1]){\n        ans |= searchPath(vertex + 1, cur - 1);\n    }\n    \n    return (ans);\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    char in[4];\n    \n    scanf(\"%d\", &t);\n    \n    while (t--){\n        scanf(\"%d%d\", &n, &m);\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s\", in);\n            T[i] = convert(in);\n        }\n        for (i = 0; i < m; i++){\n            scanf(\"%s\", in);\n            S[i] = convert(in);\n        }\n        \n        if (searchPath(n - 1, m) | searchPath(n - 2, m)){\n            printf(\"Yes\\n\");\n        }\n        else {\n            printf(\"No\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar h[12][50010];\nint a,b,d[50010],m[50010];\nint Y[]={1,2,-1};\nint O[]={0,1,-1};\nint f(int s,int t){//printf(\"%d %d %d %d\\n\",s,t,d[s],m[t]);\n  int n,i;\n  if(t==b+1&&s==a)return 1;\n  if(t>b||s>=a)return 0;\n  if((b+1-t)*2<a-s)return 0;\n  for(i=0;i<3;i++){\n    n=s+Y[i];\n    if(n<0||n>a)continue;\n    if((d[n]+O[i]+12)%12-m[t]&&n<a)continue;\n    //if(h[t][n])continue;\n    //h[t][n]=1;\n    if(f(n,t+1))return 1;\n    //h[m[t]][t+1]=0;\n  }\n  return 0;\n}\nint main(){\n  int n,i,j;\n  char s[3],o[][3]={\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"};\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&a,&b);\n    for(i=0;i<12;i++){\n      for(j=0;j<50010;j++)h[i][j]=0;\n    }\n    for(i=0;i<a;i++){\n      scanf(\"%s\",s);\n      for(j=0;strcmp(s,o[j]);j++);\n      d[i]=j;\n    }\n    for(i=0;i<b;i++){\n      scanf(\"%s\",s);\n      for(j=0;strcmp(s,o[j]);j++);\n      m[i]=j;\n    }\n    d[a]=m[b]=-1;\n    printf(\"%s\\n\",f(-1,0)?\"Yes\":\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2190: Angel Stairs\n// 2017.12.10\n\n#include <stdio.h>\n#include <string.h>\n\nint n, m;\nchar t[50002], s[50002];\nchar tr['G'+1]['#'+1];\nchar buf[150005], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint check(int k)\n{\n\tint i, j, x, nx, f;\n\n    for (i = 0; i < m; i++) {\n\t\tif (k > n-1) return 0;\n        x = s[i], f = 0;\n        for (j = -1; j <= 1; j++) {\n\t\t\tnx = t[k] + j;\n\t\t\tif (nx < 0) nx += 12;\n\t\t\telse if (nx >= 12) nx -= 12;\n\n            if (x == nx) {\n                f = 1, k += j;\n                if (j >= 0) k++;\n                break;\n            }\n        }\n        if (k < 0 || !f) return 0;\n    }\n    return k == n;\n}\n\nint main()\n{\n\tint cno, i, a, b;\n\n\ttr['C'][0] = 0, tr['C']['#'] = 1, tr['D'][0] = 2, tr['D']['#'] = 3;\n\ttr['E'][0] = 4, tr['F'][0] = 5, tr['F']['#'] = 6;\n\ttr['G'][0] = 7, tr['G']['#'] = 8, tr['A'][0] = 9, tr['A']['#'] = 10;\n    tr['B'][0] = 11;\n\n    fgets(p=buf, 10, stdin), cno = getint();\n\twhile (cno--) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tn = getint(), m = getint();\n\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (i = n-1; i >= 0; i--) {\n\t\t\ta = *p++;\n\t\t\tb = *p++;\n\t\t\tif (b == '#') p++; else b = 0;\n\t\t\tt[i] = tr[a][b];\n\t\t}\n\n\t\tfgets(p=buf, sizeof(buf), stdin);\n\t\tfor (i = m-1; i >= 0; i--) {\n\t\t\ta = *p++;\n\t\t\tb = *p++;\n\t\t\tif (b == '#') p++; else b = 0;\n\t\t\ts[i] = tr[a][b];\n\t\t}\n\t\tputs(check(0) || check(1) ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String START = \"start\";\n\tpublic static final String GOAL = \"goal\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bMake = false;\n\t\t\tint point;\n\t\t\tint sp = m - 1;\n\t\t\tfor(point = n - 1; n - 2 <= point; point--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bMake == true){\n\t\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\t\tpoint += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\t\tif(point == -1){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1){\n\t\t\treturn START;\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn GOAL;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint set = sc.nextInt();\n\n\t\twhile(set-- > 0){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt();\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<n;i++) t[i] = toNum(sc.next());\n\t\t\tfor(int i=0;i<m;i++) s[i] = toNum(sc.next());\n\n\t\t\tSystem.out.println(solve(t,s,n-1) || solve(t,s,n-2) ?\n\t\t\t\t\t\t\t\t\t\t\t\t \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate static int toNum(String s){\n\t\tif(s.equals(\"C\"))  return 0;\n\t\tif(s.equals(\"C#\")) return 1;\n\t\tif(s.equals(\"D\"))  return 2;\n\t\tif(s.equals(\"D#\")) return 3;\n\t\tif(s.equals(\"E\"))  return 4;\n\t\tif(s.equals(\"F\"))  return 5;\n\t\tif(s.equals(\"F#\")) return 6;\n\t\tif(s.equals(\"G\"))  return 7;\n\t\tif(s.equals(\"G#\")) return 8;\n\t\tif(s.equals(\"A\"))  return 9;\n\t\tif(s.equals(\"A#\")) return 10;\n\t\tif(s.equals(\"B\"))  return 11;\n\t\treturn -1;\n\t}\n\n\tprivate static boolean solve(int[] t,int[] s,int index){\n\t\tint i = index;\n\n\t\tfor(int j=s.length-1;j>=0;j--){\n\t\t\tif(i < 0 || t.length <= i) return false;\n\t\t\ti += nexts(t[i],s[j]);\n\t\t}\n\t\tif(i == -1) return true;\n\t\treturn false;\n\t}\n\n\tprivate static int nexts(int t,int s){\n\t\tif(t == s) return -1;\n\t\tif(bound(t-1) == s) return 1;\n\t\tif(bound(t+1) == s) return -2;\n\t\treturn 500000;\n\t}\n\n\tprivate static int bound(int index){\n\t\treturn (index + 12) % 12;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n == 0 || m == 0){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\t//System.out.println(\"kansei\");\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(k + 1 < n && check(k, 1, index+1) && bRet == false){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\tif(k > 0 && check(k, -1, index+1) && bRet == false){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(index < 0 || index >= m ){\n\t\t\tSystem.out.println(\"ERROR00\");\n\t\t\treturn bRet;\n\t\t}\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tif(i < 0 || i >= n ){\n\t\t\tSystem.out.println(\"ERROR01\");\n\t\t\treturn \"\";\n\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tHashMap<String, Integer> c2i;\n\tScanner sc;\n\tvoid run() {\n\n\t\tc2i = new HashMap<String, Integer>();\n\t\tString[] ss = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\t\tfor (int i = 0; i < ss.length; i++)\n\t\t\tc2i.put(ss[i], i);\n\n\t\tsc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile (T -- > 0) solve();\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] T = new int[n];\n\t\tint[] S = new int[m];\n\t\tfor (int i = 0; i < n; i++) T[i] = c2i.get(sc.next());\n\t\tfor (int i = 0; i < m; i++) S[i] = c2i.get(sc.next());\n\n\t\tboolean ok = false;\n\n\t\t{\n\t\t\tint t = n - 1, s = m - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (t < 0 || t >= n || s < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (T[t] == S[s]) {\n\t\t\t\t\tt--;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == 1 || T[t] - S[s] == -11) {\n\t\t\t\t\tt++;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == -1 || T[t] - S[s] == 10) {\n\t\t\t\t\tt -= 2;\n\t\t\t\t\ts--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == -1 && s == -1) ok = true;\n\t\t}\n\t\t{\n\t\t\tint t = n - 2, s = m - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (t < 0 || t > n || s < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (T[t] == S[s]) {\n\t\t\t\t\tt--;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == 1 || T[t] - S[s] == -11) {\n\t\t\t\t\tt++;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == -1 || T[t] - S[s] == 10) {\n\t\t\t\t\tt -= 2;\n\t\t\t\t\ts--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == -1 && s == -1) ok = true;\n\t\t}\n\n\t\tSystem.out.println(ok ? \"Yes\":\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int SIZE = 12;\n\t\n\tpublic static int next(int m){\n\t\treturn (m + 1) % SIZE;\n\t}\n\t\n\tpublic static int prev(int m){\n\t\treturn (m - 1 + SIZE) % SIZE;\n\t}\n\t\n\tpublic static int hash(int n, int m){\n\t\treturn (n << 16) + m;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"C\" , 0);\n\t\tmap.put(\"C#\", 1);\n\t\tmap.put(\"D\" , 2);\n\t\tmap.put(\"D#\", 3);\n\t\tmap.put(\"E\" , 4);\n\t\tmap.put(\"F\" , 5);\n\t\tmap.put(\"F#\", 6);\n\t\tmap.put(\"G\" , 7);\n\t\tmap.put(\"G#\", 8);\n\t\tmap.put(\"A\" , 9);\n\t\tmap.put(\"A#\", 10);\n\t\tmap.put(\"B\" , 11);\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int tt = 0; tt < T; tt++){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tint[] stairs = new int[n];\n\t\t\tint[] hope = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstairs[i] = map.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\thope[i] = map.get(sc.next());\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> cur_pos = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> perhap   = new LinkedList<Integer>();\n\t\t\tcur_pos.add(-1);\n\t\t\tperhap.add(0);\n\t\t\t\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(hash(-1, 0));\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\tLOOP:\n\t\t\twhile(!cur_pos.isEmpty()){\n\t\t\t\tfinal int pos = cur_pos.poll();\n\t\t\t\tfinal int purpose = perhap.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(Arrays.toString(stairs));\n\t\t\t\t//System.out.println(Arrays.toString(hope));\n\t\t\t\t//System.out.println(pos + \" \" + purpose + \" \" + set);\n\t\t\t\t\n\t\t\t\tif(purpose == m){\n\t\t\t\t\tif(pos + 1 == n || pos + 2 == n){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak LOOP;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//System.out.println(set.contains(hash(pos - 1, purpose + 1)));\n\t\t\t\t\tif(pos - 1 >= 0 && hope[purpose] == prev(stairs[pos - 1]) && !set.contains(hash(pos - 1, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos - 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t\tset.add(hash(pos - 1, purpose + 1));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 1 >= 0 && pos + 1 < n && hope[purpose] == stairs[pos + 1] && !set.contains(hash(pos + 1, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos + 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t\tset.add(hash(pos + 1, purpose + 1));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 2 >= 0 && pos + 2 < n && hope[purpose] == next(stairs[pos + 2]) && !set.contains(hash(pos + 2, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos + 2);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t\tset.add(hash(pos + 2, purpose + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n == 0 || m == 0){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\t//System.out.println(\"kansei\");\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(k + 1 < n && check(k, 1, index+1)){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\telse if(k > 0 && check(k, -1, index+1)){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Angel Stairs\npublic class Main{\n\n\tvoid run(){\n\t\tString[] M = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tint n = sc.nextInt(), m =  sc.nextInt();\n\t\t\tint[] s = new int[n+2], t = new int[m];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tString r = sc.next();\n\t\t\t\tfor(int k=0;k<12;k++)if(M[k].equals(r)){s[i]=k; break;};\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString r = sc.next();\n\t\t\t\tfor(int k=0;k<12;k++)if(M[k].equals(r)){t[i]=k; break;};\n\t\t\t}\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(0);\n\t\t\tint k = 0;\n\t\t\tString res = \"No\";\n\t\t\twhile(!set.isEmpty()&&k<=m){\n\t\t\t\tSet<Integer> next = new HashSet<Integer>();\n\t\t\t\tfor(int v:set){\n\t\t\t\t\tif(k==m){\n\t\t\t\t\t\tif(v+1==n+1||v+2==n+1)res = \"Yes\";\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(v-1>0&&t[k]==(s[v-1]+11)%12)next.add(v-1);\n\t\t\t\t\tif(v+1<=n&&t[k]==s[v+1])next.add(v+1);\n\t\t\t\t\tif(v+2<=n&&t[k]==(s[v+2]+1)%12)next.add(v+2);\n\t\t\t\t}\n\t\t\t\tset = next; k++;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String START = \"start\";\n\tpublic static final String GOAL = \"goal\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\t//n段目にいるときに鳴らせる音一覧\n\t\t\tString[][] stepTable = new String[n + 1][3];\n\t\t\t//make StepTable\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t//k - 1\n\t\t\t\tstepTable[j][0] = ring(j - 1,-1);\n\t\t\t\t//k + 1\n\t\t\t\tstepTable[j][1] = ring(j - 1,1);\n\t\t\t\t//k + 2\n\t\t\t\tstepTable[j][2] = ring(j - 1,2);\n\t\t\t}\n\t\t\t//printStepTable();\n\t\t\t\n\t\t\tint point = 0;\n\t\t\t//dp[i]ターンまでの曲が作れる\n\t\t\tint[] dp = new int[n + 1];\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tdp[j] = -1;\n\t\t\t}\n\t\t\t//始めは0段目にいる\n\t\t\tdp[0] = 0;\n\t\t\t//長さmの曲を作る\n\t\t\tfor(int h = 0; h < m; h++){\n\t\t\t\t//残りの曲の長さは(m - h)\n\t\t\t\t//よって、n - ((m-h)+1)*2から始めれば十分。そうでなければ到達できない\n\t\t\t\tint start = n - (m - h + 1)*2;\n\t\t\t\tif(start < 0){\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\t//System.out.println(start);\n\t\t\t\tfor(int j = start; j <= n; j++){\n\t\t\t\t\tif(dp[j] == h){\n\t\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\t\tif(song[h].equals(stepTable[j][k])){\n\t\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\t\tdp[j - 1] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(k == 1){\n\t\t\t\t\t\t\t\t\tdp[j + 1] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tdp[j + 2] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dp[n] == m || dp[n - 1] == m){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static void printStepTable(){\n//\t\tfor(int i = 0; i <= n; i++){\n//\t\t\tSystem.out.println(\"step[\" + i +  \"]\" + stepTable[i][0] + \", \" + stepTable[i][1] + \", \" + stepTable[i][2]);\n//\t\t}\n//\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < 0){\n\t\t\treturn START;\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn GOAL;\n\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String UNDEF = \"undef\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bMake = false;\n\t\t\tint point;\n\t\t\tint sp = m - 1;\n\t\t\tfor(point = n - 1; n - 2 <= point; point--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bMake == true){\n\t\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\t\tpoint += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(point < 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\t\tif(point == -1 && sp == 0){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1 || i >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tif(now < 0 || now >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String START = \"start\";\n\tpublic static final String GOAL = \"goal\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\t//n段目にいるときに鳴らせる音一覧\n\t\t\tString[][] stepTable = new String[n + 1][3];\n\t\t\t//make StepTable\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t//k - 1\n\t\t\t\tstepTable[j][0] = ring(j - 1,-1);\n\t\t\t\t//k + 1\n\t\t\t\tstepTable[j][1] = ring(j - 1,1);\n\t\t\t\t//k + 2\n\t\t\t\tstepTable[j][2] = ring(j - 1,2);\n\t\t\t}\n\t\t\t//printStepTable();\n\t\t\t\n\t\t\tint point = 0;\n\t\t\t//dp[i]ターンまでの曲が作れる\n\t\t\tint[] dp = new int[n + 1];\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tdp[j] = -1;\n\t\t\t}\n\t\t\t//始めは0段目にいる\n\t\t\tdp[0] = 0;\n\t\t\tint start = 0;\n\t\t\tint end = 0;\n\t\t\t//長さmの曲を作る\n\t\t\tfor(int h = 0; h < m; h++){\n\t\t\t\t//System.out.println(start + \" \" + end);\n\t\t\t\t//残りの曲の長さは(m - h)\n\t\t\t\t//よって、n - ((m-h)+1)*2から始めれば十分。そうでなければ到達できない\n//\t\t\t\tint start = n - (m - h + 1)*2;\n//\t\t\t\tif(start < 0){\n//\t\t\t\t\tstart = 0;\n//\t\t\t\t}\n\t\t\t\t//System.out.println(start);\n\t\t\t\tint tmp_start = n + 1;\n\t\t\t\tint tmp_end = 0;\n\t\t\t\tfor(int j = start; j <= end; j++){\n\t\t\t\t\tif(dp[j] == h){\n\t\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\t\tif(song[h].equals(stepTable[j][k])){\n\t\t\t\t\t\t\t\tint index;\n\t\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\t\tindex = j - 1;\n\t\t\t\t\t\t\t\t\tdp[index] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(k == 1){\n\t\t\t\t\t\t\t\t\tindex = j + 1;\n\t\t\t\t\t\t\t\t\tdp[index] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tindex = j + 2;\n\t\t\t\t\t\t\t\t\tdp[index] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(tmp_start > index){\n\t\t\t\t\t\t\t\t\ttmp_start = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(tmp_end < index){\n\t\t\t\t\t\t\t\t\ttmp_end = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = tmp_start;\n\t\t\t\tend = tmp_end;\n\t\t\t\tif(tmp_end == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dp[n] == m || dp[n - 1] == m){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static void printStepTable(){\n//\t\tfor(int i = 0; i <= n; i++){\n//\t\t\tSystem.out.println(\"step[\" + i +  \"]\" + stepTable[i][0] + \", \" + stepTable[i][1] + \", \" + stepTable[i][2]);\n//\t\t}\n//\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < 0){\n\t\t\treturn START;\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn GOAL;\n\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\t//System.out.println(\"kansei\");\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(k + 1 < n && check(k, 1, index+1)){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\telse if(k > 0 && check(k, -1, index+1)){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int SIZE = 12;\n\t\n\tpublic static int next(int m){\n\t\treturn (m + 1) % SIZE;\n\t}\n\t\n\tpublic static int prev(int m){\n\t\treturn (m - 1 + SIZE) % SIZE;\n\t}\n\t\n\tpublic static int hash(int n, int m){\n\t\treturn n << 16 + m;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"C\" , 0);\n\t\tmap.put(\"C#\", 1);\n\t\tmap.put(\"D\" , 2);\n\t\tmap.put(\"D#\", 3);\n\t\tmap.put(\"E\" , 4);\n\t\tmap.put(\"F\" , 5);\n\t\tmap.put(\"F#\", 6);\n\t\tmap.put(\"G\" , 7);\n\t\tmap.put(\"G#\", 8);\n\t\tmap.put(\"A\" , 9);\n\t\tmap.put(\"A#\", 10);\n\t\tmap.put(\"B\" , 11);\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int tt = 0; tt < T; tt++){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tint[] stairs = new int[n];\n\t\t\tint[] hope = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstairs[i] = map.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\thope[i] = map.get(sc.next());\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> cur_pos = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> perhap   = new LinkedList<Integer>();\n\t\t\tcur_pos.add(-1);\n\t\t\tperhap.add(0);\n\t\t\t\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(hash(-1, 0));\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\tLOOP:\n\t\t\twhile(!cur_pos.isEmpty()){\n\t\t\t\tfinal int pos = cur_pos.poll();\n\t\t\t\tfinal int purpose = perhap.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(Arrays.toString(stairs));\n\t\t\t\t//System.out.println(Arrays.toString(hope));\n\t\t\t\t//System.out.println(pos + \" \" + purpose);\n\t\t\t\t\n\t\t\t\tif(purpose == m){\n\t\t\t\t\tif(pos + 1 == n || pos + 2 == n){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak LOOP;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(pos - 1 >= 0 && hope[purpose] == prev(stairs[pos - 1]) && !set.contains(hash(pos - 1, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos - 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 1 >= 0 && pos + 1 < n && hope[purpose] == stairs[pos + 1] && !set.contains(hash(pos + 1, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos + 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 2 >= 0 && pos + 2 < n && hope[purpose] == next(stairs[pos + 2]) && !set.contains(hash(pos + 2, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos + 2);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String START = \"start\";\n\tpublic static final String GOAL = \"goal\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bMake = false;\n\t\t\tint point;\n\t\t\tint sp = m - 1;\n\t\t\tfor(point = n - 1; n - 2 <= point; point--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bMake == true){\n\t\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\t\tpoint += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(point < 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\t\tif(point == -1 && sp == 0){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1){\n\t\t\treturn START;\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn GOAL;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String UNDEF = \"undef\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bMake = false;\n\t\t\tint point;\n\t\t\tint sp = m - 1;\n\t\t\t//int end = Math.min(n - 2, 0);\n\t\t\tfor(point = n - 1; n - 2 <= point; point--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean isOK = true;\n\t\t\tif(bMake == true){\n\t\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\t\tpoint += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(point < 0){\n\t\t\t\t\t\t//isOK = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m == 1){\n\t\t\t\tsp++;\n\t\t\t}\n\t\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\t\tif(point == -1 && sp == 0 && isOK == true){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1 || i >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tif(now < 0 || now >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n == 0 || m == 0){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n * 2];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m * 2];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\t//System.out.println(\"kansei\");\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(k + 1 < n && check(k, 1, index+1) && bRet == false){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\tif(k > 0 && check(k, -1, index+1) && bRet == false){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n == 0 || m == 0){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\t//System.out.println(\"kansei\");\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(k + 1 < n && check(k, 1, index+1) && bRet == false){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\tif(k > 0 && check(k, -1, index+1) && bRet == false){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String UNDEF = \"undef\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bMake = false;\n\t\t\tint point;\n\t\t\tint sp = m - 1;\n\t\t\t//int end = Math.min(n - 2, 0);\n\t\t\tfor(point = n - 1; n - 2 <= point; point--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bMake == true){\n\t\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\t\tpoint += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(point < 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m == 1){\n\t\t\t\tsp++;\n\t\t\t}\n\t\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\t\tif(point == -1 && sp == 0){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1 || i >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tif(now < 0 || now >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Angel Stairs\npublic class Main{\n\t\n\tString[] f = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tint trans(String s){\n\t\tfor(int k=0;k<12;k++)if(f[k].equals(s))return k;\n\t\treturn 0;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tint[] t = new int[n+2];\n\t\t\tt[0] = t[n+1] = -1;\n\t\t\tfor(int i=1;i<=n;i++)t[i]=trans(sc.next());\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++)s[i]=trans(sc.next());\n\t\t\tint p = n;\n\t\t\tboolean con = true;\n\t\t\tfor(int k=m-1;k>=0&&con;k--){\n\t\t\t\tcon = false;\n\t\t\t\tif(p==0||p==n+1)break;\n\t\t\t\tint np = p-2;\n\t\t\t\tif(0<=np&&s[k]==(t[p]+1)%12){\n\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t}\n\t\t\t\tnp = p-1;\n\t\t\t\tif(0<=np&&s[k]==t[p]){\n\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t}\n\t\t\t\tnp = p+1;\n\t\t\t\tif(np<=n&&s[k]==(t[p]+11)%12){\n\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(con&&p==0){\n\t\t\t\tSystem.out.println(\"Yes\"); continue;\n\t\t\t}\n\t\t\tp = n-1;\n\t\t\tif(0<=p){\n\t\t\t\tcon = true;\n\t\t\t\tfor(int k=m-1;k>=0&&con;k--){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tif(p==0||p==n+1)break;\n\t\t\t\t\tint np = p-2;\n\t\t\t\t\tif(0<=np&&s[k]==(t[p]+1)%12){\n\t\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t\t}\n\t\t\t\t\tnp = p-1;\n\t\t\t\t\tif(0<=np&&s[k]==t[p]){\n\t\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t\t}\n\t\t\t\t\tnp = p+1;\n\t\t\t\t\tif(np<=n&&s[k]==(t[p]+11)%12){\n\t\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(con&&p==0){\n\t\t\t\t\tSystem.out.println(\"Yes\"); continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tHashMap<String, Integer> c2i;\n\tScanner sc;\n\tvoid run() {\n\n\t\tc2i = new HashMap<String, Integer>();\n\t\tString[] ss = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\t\tfor (int i = 0; i < ss.length; i++)\n\t\t\tc2i.put(ss[i], i);\n\n\t\tsc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile (T -- > 0) solve();\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] T = new int[n];\n\t\tint[] S = new int[m];\n\t\tfor (int i = 0; i < n; i++) T[i] = c2i.get(sc.next());\n\t\tfor (int i = 0; i < m; i++) S[i] = c2i.get(sc.next());\n\n\t\tboolean ok = false;\n\n\t\t{\n\t\t\tint t = n - 1, s = m - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (t < 0 || t >= n || s < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (T[t] == S[s]) {\n\t\t\t\t\tt--;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == 1 || T[t] - S[s] == -11) {\n\t\t\t\t\tt++;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == -1 || T[t] - S[s] == 10) {\n\t\t\t\t\tt -= 2;\n\t\t\t\t\ts--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == -1 && s == -1) ok = true;\n\t\t}\n\t\t{\n\t\t\tint t = n - 2, s = m - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (t < 0 || t >= n || s < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (T[t] == S[s]) {\n\t\t\t\t\tt--;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == 1 || T[t] - S[s] == -11) {\n\t\t\t\t\tt++;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == -1 || T[t] - S[s] == 10) {\n\t\t\t\t\tt -= 2;\n\t\t\t\t\ts--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == -1 && s == -1) ok = true;\n\t\t}\n\n\t\tSystem.out.println(ok ? \"Yes\":\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String START = \"start\";\n\tpublic static final String GOAL = \"goal\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\t//n段目にいるときに鳴らせる音一覧\n\t\t\tString[][] stepTable = new String[n + 1][3];\n\t\t\t//make StepTable\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t//k - 1\n\t\t\t\tstepTable[j][0] = ring(j - 1,-1);\n\t\t\t\t//k + 1\n\t\t\t\tstepTable[j][1] = ring(j - 1,1);\n\t\t\t\t//k + 2\n\t\t\t\tstepTable[j][2] = ring(j - 1,2);\n\t\t\t}\n\t\t\t//printStepTable();\n\t\t\t\n\t\t\tint point = 0;\n\t\t\t//dp[i]ターンまでの曲が作れる\n\t\t\tint[] dp = new int[n + 1];\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tdp[j] = -1;\n\t\t\t}\n\t\t\t//始めは0段目にいる\n\t\t\tdp[0] = 0;\n\t\t\tint start = 0;\n\t\t\tint end = 0;\n\t\t\t//長さmの曲を作る\n\t\t\tfor(int h = 0; h < m; h++){\n\t\t\t\t//残りの曲の長さは(m - h)\n\t\t\t\t//よって、n - ((m-h)+1)*2から始めれば十分。そうでなければ到達できない\n//\t\t\t\tint start = n - (m - h + 1)*2;\n//\t\t\t\tif(start < 0){\n//\t\t\t\t\tstart = 0;\n//\t\t\t\t}\n\t\t\t\t//System.out.println(start);\n\t\t\t\tint tmp_start = n + 1;\n\t\t\t\tint tmp_end = 0;\n\t\t\t\tfor(int j = start; j <= end; j++){\n\t\t\t\t\tif(dp[j] == h){\n\t\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\t\tif(song[h].equals(stepTable[j][k])){\n\t\t\t\t\t\t\t\tint index;\n\t\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\t\tindex = j - 1;\n\t\t\t\t\t\t\t\t\tdp[index] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(k == 1){\n\t\t\t\t\t\t\t\t\tindex = j + 1;\n\t\t\t\t\t\t\t\t\tdp[index] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tindex = j + 2;\n\t\t\t\t\t\t\t\t\tdp[index] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(tmp_start > index){\n\t\t\t\t\t\t\t\t\ttmp_start = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(tmp_end < index){\n\t\t\t\t\t\t\t\t\ttmp_end = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = tmp_start;\n\t\t\t\tend = tmp_end;\n\t\t\t}\n\t\t\t\n\t\t\tif(dp[n] == m || dp[n - 1] == m){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static void printStepTable(){\n//\t\tfor(int i = 0; i <= n; i++){\n//\t\t\tSystem.out.println(\"step[\" + i +  \"]\" + stepTable[i][0] + \", \" + stepTable[i][1] + \", \" + stepTable[i][2]);\n//\t\t}\n//\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < 0){\n\t\t\treturn START;\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn GOAL;\n\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(k + 1 < n && check(k, 1, index+1)){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\telse if(k > 0 && check(k, -1, index+1)){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 11];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tHashMap<String, Integer> c2i;\n\tScanner sc;\n\tvoid run() {\n\n\t\tc2i = new HashMap<String, Integer>();\n\t\tString[] ss = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\t\tfor (int i = 0; i < ss.length; i++)\n\t\t\tc2i.put(ss[i], i);\n\n\t\tsc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile (T -- > 0) solve();\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] T = new int[n];\n\t\tint[] S = new int[m];\n\t\tfor (int i = 0; i < n; i++) T[i] = c2i.get(sc.next());\n\t\tfor (int i = 0; i < m; i++) S[i] = c2i.get(sc.next());\n\n\t\tboolean ok = false;\n\t\t{\n\t\t\tint t = n - 1, s = m - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (t < 0 || t >= n || s < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (T[t] == S[s]) {\n\t\t\t\t\tt--;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == 1 || T[t] - S[s] == -11) {\n\t\t\t\t\tt++;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == -1 || T[t] - S[s] == 11) {\n\t\t\t\t\tt -= 2;\n\t\t\t\t\ts--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == -1 && s == -1) ok = true;\n\t\t}\n\t\t{\n\t\t\tint t = n - 2, s = m - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (t < 0 || t >= n || s < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (T[t] == S[s]) {\n\t\t\t\t\tt--;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == 1 || T[t] - S[s] == -11) {\n\t\t\t\t\tt++;\n\t\t\t\t\ts--;\n\t\t\t\t} else if (T[t] - S[s] == -1 || T[t] - S[s] == 11) {\n\t\t\t\t\tt -= 2;\n\t\t\t\t\ts--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == -1 && s == -1) ok = true;\n\t\t}\n\n\t\tSystem.out.println(ok ? \"Yes\":\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\t\n\tpublic static int n;\n\tpublic static int m;\n\tpublic static final String UNDEF = \"undef\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\t\n\t\t\tif(singSong(n - 1) || singSong(n - 2)){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static boolean singSong(int start){\n\t\tboolean bMake = false;\n\t\tint point = start;\n\t\tint sp = m - 1;\n\t\t//int end = Math.min(n - 2, 0);\n\t\t//for(point = n - 1; n - 2 <= point; point--){\n\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\tpoint += 1;\n\t\t\t\tbMake = true;\n\t\t\t\t//break;\n\t\t\t}\n\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\tpoint -= 1;\n\t\t\t\tbMake = true;\n\t\t\t\t//break;\n\t\t\t}\n\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\tpoint -= 2;\n\t\t\t\tbMake = true;\n\t\t\t\t//break;\n\t\t\t}\n\t\t//}\n\t\tboolean isOK = true;\n\t\tif(bMake == true){\n\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(point < 0){\n\t\t\t\t\t//isOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m == 1){\n\t\t\tsp++;\n\t\t}\n\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\tif(point == -1 && sp == 0 && isOK == true){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1 || i >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tif(now < 0 || now >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Angel Stairs\npublic class Main{\n\t\n\tString[] f = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tint trans(String s){\n\t\tfor(int k=0;k<12;k++)if(f[k].equals(s))return k;\n\t\treturn 0;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint[] t = new int[50002], s = new int[50002];\n\t\twhile(T--!=0){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tt[0] = t[n+1] = -1;\n\t\t\tfor(int i=1;i<=n;i++)t[i]=trans(sc.next());\n\t\t\tfor(int i=0;i<m;i++)s[i]=trans(sc.next());\n\t\t\tint p = n;\n\t\t\tboolean con = true;\n\t\t\tfor(int k=m-1;k>=0&&con;k--){\n\t\t\t\tcon = false;\n\t\t\t\tif(p==0||p==n+1)break;\n\t\t\t\tint np = p-2;\n\t\t\t\tif(0<=np&&s[k]==(t[p]+1)%12){\n\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t}\n\t\t\t\tnp = p-1;\n\t\t\t\tif(0<=np&&s[k]==t[p]){\n\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t}\n\t\t\t\tnp = p+1;\n\t\t\t\tif(np<=n&&s[k]==(t[p]+11)%12){\n\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(con&&p==0){\n\t\t\t\tSystem.out.println(\"Yes\"); continue;\n\t\t\t}\n\t\t\tp = n-1;\n\t\t\tif(0<=p){\n\t\t\t\tcon = true;\n\t\t\t\tfor(int k=m-1;k>=0&&con;k--){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tif(p==0||p==n+1)break;\n\t\t\t\t\tint np = p-2;\n\t\t\t\t\tif(0<=np&&s[k]==(t[p]+1)%12){\n\t\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t\t}\n\t\t\t\t\tnp = p-1;\n\t\t\t\t\tif(0<=np&&s[k]==t[p]){\n\t\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t\t}\n\t\t\t\t\tnp = p+1;\n\t\t\t\t\tif(np<=n&&s[k]==(t[p]+11)%12){\n\t\t\t\t\t\tcon = true; p = np; continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(con&&p==0){\n\t\t\t\t\tSystem.out.println(\"Yes\"); continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\tpublic static String[] song;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tsong = new String[m];\n\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bRet = isOK(-1,-1);\n\t\t\tif(bRet){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\t//System.out.println(\"result = \" + bRet);\n\t\t}\n\t}\n\t//今配列[k]段目にいて、曲は配列[index]番目まで出来ている\n\tpublic static boolean isOK(int k, int index){\n\t\t//System.out.println(\"isOK : k = \" + k + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\t//特殊な場合の処理\n\t\tif(index == m - 1){\n\t\t\t//曲完成\n\t\t\tif(k + 1 == n || k + 2 == n){\n\t\t\t\t//System.out.println(\"kansei\");\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(k + 2 < n && check(k, 2, index+1)){\n\t\t\t\t//if(k + 2 <= n){\n\t\t\t\t\tbRet = isOK(k + 2, index+1);\n\t\t\t\t//}\n\n\t\t\t}\n\t\t\telse if(k + 1 < n && check(k, 1, index+1)){\n\t\t\t\t//if(k + 1 <= n){\n\t\t\t\t\tbRet = isOK(k + 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//-1\n\t\t\telse if(k > 0 && check(k, -1, index+1)){\n\t\t\t\t//if(k != 1){\n\t\t\t\t\tbRet = isOK(k - 1, index+1);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\treturn bRet;\n\t}\n\t//now + num番目の音を鳴らしたときにsong[index]と等しいか？\n\tpublic static boolean check(int now, int num, int index){\n\t\t//System.out.println(\"check : now = \" + now + \", num = \" + num + \", index = \" + index);\n\t\tboolean bRet = false;\n\t\tString s = ring(now,num);\n\t\t//System.out.println(s);\n\t\tif(index < 0 || index >= m){\n\t\t\tSystem.out.println(\"Error00\");\n\t\t}\n\t\tif(song[index].equals(s)){\n\t\t\tbRet = true;\n\t\t}\n\t\t//System.out.println(\"bRet = \" + bRet);\n\t\treturn bRet;\n\t}\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n//\t\tif(i == -1){\n//\t\t\ti = 11;\n//\t\t}\n\t\tif(i < 0 || i >= n){\n\t\t\tSystem.out.println(\"Error01\");\n\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\t//半音あげる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(j < 0 || j >= 12){\n\t\t\t\t\tSystem.out.println(\"Error02\");\n\t\t\t\t}\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tif(j%12 < 0 || j%12 >= 12){\n\t\t\t\t\t\tSystem.out.println(\"Error03\");\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\t//半音下げる\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int SIZE = 12;\n\t\n\tpublic static int next(int m){\n\t\treturn (m + 1) % SIZE;\n\t}\n\t\n\tpublic static int prev(int m){\n\t\treturn (m - 1 + SIZE) % SIZE;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"C\" , 0);\n\t\tmap.put(\"C#\", 1);\n\t\tmap.put(\"D\" , 2);\n\t\tmap.put(\"D#\", 3);\n\t\tmap.put(\"E\" , 4);\n\t\tmap.put(\"F\" , 5);\n\t\tmap.put(\"F#\", 6);\n\t\tmap.put(\"G\" , 7);\n\t\tmap.put(\"G#\", 8);\n\t\tmap.put(\"A\" , 9);\n\t\tmap.put(\"A#\", 10);\n\t\tmap.put(\"B\" , 11);\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int tt = 0; tt < T; tt++){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tint[] stairs = new int[n];\n\t\t\tint[] hope = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstairs[i] = map.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\thope[i] = map.get(sc.next());\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> cur_pos = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> perhap   = new LinkedList<Integer>();\n\t\t\tcur_pos.add(-1);\n\t\t\tperhap.add(0);\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\tLOOP:\n\t\t\twhile(!cur_pos.isEmpty()){\n\t\t\t\tfinal int pos = cur_pos.poll();\n\t\t\t\tfinal int purpose = perhap.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(Arrays.toString(stairs));\n\t\t\t\t//System.out.println(Arrays.toString(hope));\n\t\t\t\t//System.out.println(pos + \" \" + purpose);\n\t\t\t\t\n\t\t\t\tif(purpose == m){\n\t\t\t\t\tif(pos + 1 == n || pos + 2 == n){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak LOOP;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(pos - 1 >= 0 && hope[purpose] == prev(stairs[pos - 1])){\n\t\t\t\t\t\tcur_pos.add(pos - 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 1 >= 0 && pos + 1 < n && hope[purpose] == stairs[pos + 1]){\n\t\t\t\t\t\tcur_pos.add(pos + 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 2 >= 0 && pos + 2 < n && hope[purpose] == next(stairs[pos + 2])){\n\t\t\t\t\t\tcur_pos.add(pos + 2);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int SIZE = 12;\n\t\n\tpublic static int next(int m){\n\t\treturn (m + 1) % SIZE;\n\t}\n\t\n\tpublic static int prev(int m){\n\t\treturn (m - 1 + SIZE) % SIZE;\n\t}\n\t\n\tpublic static int hash(int n, int m){\n\t\treturn n << 16 + m;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"C\" , 0);\n\t\tmap.put(\"C#\", 1);\n\t\tmap.put(\"D\" , 2);\n\t\tmap.put(\"D#\", 3);\n\t\tmap.put(\"E\" , 4);\n\t\tmap.put(\"F\" , 5);\n\t\tmap.put(\"F#\", 6);\n\t\tmap.put(\"G\" , 7);\n\t\tmap.put(\"G#\", 8);\n\t\tmap.put(\"A\" , 9);\n\t\tmap.put(\"A#\", 10);\n\t\tmap.put(\"B\" , 11);\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int tt = 0; tt < T; tt++){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tint[] stairs = new int[n];\n\t\t\tint[] hope = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstairs[i] = map.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\thope[i] = map.get(sc.next());\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> cur_pos = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> perhap   = new LinkedList<Integer>();\n\t\t\tcur_pos.add(-1);\n\t\t\tperhap.add(0);\n\t\t\t\n\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\tset.add(hash(-1, 0));\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\tLOOP:\n\t\t\twhile(!cur_pos.isEmpty()){\n\t\t\t\tfinal int pos = cur_pos.poll();\n\t\t\t\tfinal int purpose = perhap.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(Arrays.toString(stairs));\n\t\t\t\t//System.out.println(Arrays.toString(hope));\n\t\t\t\t//System.out.println(pos + \" \" + purpose);\n\t\t\t\t\n\t\t\t\tif(purpose == m){\n\t\t\t\t\tif(pos + 1 == n || pos + 2 == n){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak LOOP;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(pos - 1 >= 0 && hope[purpose] == prev(stairs[pos - 1]) && !set.contains(hash(pos - 1, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos - 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 1 >= 0 && pos + 1 < n && hope[purpose] == stairs[pos + 1] && !set.contains(hash(pos + 1, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos + 1);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t\tset.add(hash(pos + 1, purpose + 1));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(pos + 2 >= 0 && pos + 2 < n && hope[purpose] == next(stairs[pos + 2]) && !set.contains(hash(pos + 2, purpose + 1))){\n\t\t\t\t\t\tcur_pos.add(pos + 2);\n\t\t\t\t\t\tperhap.add(purpose + 1);\n\t\t\t\t\t\tset.add(hash(pos + 2, purpose + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String UNDEF = \"undef\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\tboolean bMake = false;\n\t\t\tint point;\n\t\t\tint sp = m - 1;\n\t\t\tint end = Math.min(n - 2, 0);\n\t\t\tfor(point = n - 1; end <= point; point--){\n\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\tpoint += 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\tpoint -= 1;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\tpoint -= 2;\n\t\t\t\t\tbMake = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bMake == true){\n\t\t\t\tfor(sp = m - 2; sp > - 1; sp--){\n\t\t\t\t\tif(ring(point, 1).equals(song[sp])){\n\t\t\t\t\t\tpoint += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -1).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ring(point, -2).equals(song[sp])){\n\t\t\t\t\t\tpoint -= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(point < 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m == 1){\n\t\t\t\tsp++;\n\t\t\t}\n\t\t\t//System.out.println(\"point = \" + point + \", sp = \" + sp);\n\t\t\tif(point == -1 && sp == 0){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < -1 || i >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tif(now < 0 || now >= n){\n\t\t\treturn UNDEF;\n\t\t}\n\t\tString ret = step[now];\n\t\tif(num == -2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == 1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(ret.equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final String[] octave = {\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};\n\tpublic static String[] step;\n\t\n\tpublic static int n;\n\tpublic static final String START = \"start\";\n\tpublic static final String GOAL = \"goal\";\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numOfData = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < numOfData; i++){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t//String[] step = new String[n];\n\t\t\tstep = new String[n];\n\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tstep[j] = sc.next();\n\t\t\t}\n\t\t\t//String[] song = new String[m];\n\t\t\tString[] song = new String[m];\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tsong[j] = sc.next();\n\t\t\t}\n\t\t\t//n段目にいるときに鳴らせる音一覧\n\t\t\tString[][] stepTable = new String[n + 1][3];\n\t\t\t//make StepTable\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t//k - 1\n\t\t\t\tstepTable[j][0] = ring(j - 1,-1);\n\t\t\t\t//k + 1\n\t\t\t\tstepTable[j][1] = ring(j - 1,1);\n\t\t\t\t//k + 2\n\t\t\t\tstepTable[j][2] = ring(j - 1,2);\n\t\t\t}\n\t\t\t//printStepTable();\n\t\t\t\n\t\t\tint point = 0;\n\t\t\t//dp[i]ターンまでの曲が作れる\n\t\t\tint[] dp = new int[n + 1];\n\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\tdp[j] = -1;\n\t\t\t}\n\t\t\t//始めは0段目にいる\n\t\t\tdp[0] = 0;\n\t\t\t//長さmの曲を作る\n\t\t\tfor(int h = 0; h < m; h++){\n\t\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\t\tif(dp[j] == h){\n\t\t\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\t\t\tif(song[h].equals(stepTable[j][k])){\n\t\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\t\tdp[j - 1] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(k == 1){\n\t\t\t\t\t\t\t\t\tdp[j + 1] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tdp[j + 2] = h + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dp[n] == m || dp[n - 1] == m){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static void printStepTable(){\n//\t\tfor(int i = 0; i <= n; i++){\n//\t\t\tSystem.out.println(\"step[\" + i +  \"]\" + stepTable[i][0] + \", \" + stepTable[i][1] + \", \" + stepTable[i][2]);\n//\t\t}\n//\t}\n\n\tpublic static String ring(int now, int num){\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num);\n\t\tint i = now + num;\n\t\tif(i < 0){\n\t\t\treturn START;\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn GOAL;\n\t\t}\n\t\tString ret = step[i];\n\t\tif(num == 2){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj++;\n\t\t\t\t\tret = octave[j % 12];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(num == -1){\n\t\t\tfor(int j = 0; j < 12; j++){\n\t\t\t\tif(step[i].equals(octave[j])){\n\t\t\t\t\tj--;\n\t\t\t\t\tif(j == -1){\n\t\t\t\t\t\tj = 11;\n\t\t\t\t\t}\n\t\t\t\t\tret = octave[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"ring : now = \" + now + \", num = \" + num + \", ret = \" + ret);\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def calc(t, s)\n  tones = %w(C C# D D# E F F# G G# A A# B)\n  [1, 2].each{|j|\n    i = t.size - j\n    s.reverse.each{|e|\n      idx = tones.index(e)\n      if tones.index(t[i]) == idx\n        i -= 1\n      elsif (tones.index(t[i]) - 1) % 12 == idx && i < t.size - 1\n        i += 1\n      elsif (tones.index(t[i]) + 1) % 12 == idx\n        i -= 2\n      else\n        break\n      end\n      return 'Yes' if i == -1\n    }\n  }\n  'No'\nend\ngets.to_i.times do\n  gets\n  t = gets.chomp.split\n  s = gets.chomp.split\n  puts calc(t, s)\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, i, k)\n  i = music.size\n  while i > 0\n    tone = music[i - 1]\n    stair = stairs[k]\n    case tone\n    when (stair + 1) % 12\n      if k >= 1\n        k -= 2\n      else\n        return false\n      end\n    when stair\n      k -= 1\n    when (stair - 1) % 12\n      if k < stairs.size - 1\n        k += 1\n      else\n        return false\n      end\n    else\n      return false\n    end\n    i -= 1\n  end\n  return k == -1\nend\n\ndef work(stairs, music)\n  (stairs.size >= 2 && check(stairs, music, music.size, stairs.size - 2)) ||\n      check(stairs, music, music.size, stairs.size - 1)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map{|x| DICT[x]}\n  music = STDIN.gets.split.map{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, k)\n  (music.size - 1).downto(0) do |i|\n    tone = music[i]\n    stair = stairs[k]\n    case tone\n    when (stair + 1) % 12\n      k -= 2\n    when stair\n      k -= 1\n    when (stair - 1) % 12\n      k += 1\n    else\n      return false\n    end\n    return false unless k >= -1 && k < stairs.size && k < i * 2\n  end\n  true\nend\n\ndef work(stairs, music)\n  (stairs.size >= 2 && check(stairs, music, stairs.size - 2)) ||\n      check(stairs, music, stairs.size - 1)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map{|x| DICT[x]}\n  music = STDIN.gets.split.map{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "scale = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\nindex = Hash[*([scale, (0...scale.size).to_a].transpose).flatten]\n\ngets.to_i.times do\n  n, m = gets.split.map(&:to_i)\n  t = gets.split\n  s = gets.split\n  ok = false\n  nowT = n-1\n  nowS = m-1\n  m.times do\n    case t[nowT]\n      when scale[index[s[nowS]]]\n        nowT -= 1\n      when scale[(index[s[nowS]] + 1) % scale.size]\n        nowT += 1\n      when scale[(index[s[nowS]] - 1 + scale.size) % scale.size]\n        nowT -= 2\n      else\n        break\n    end\n    nowS -= 1\n    ok = true if nowT == 0 && nowS == 0\n    ok = true if nowT == -1 && nowS == -1\n    break if nowT < 0 || n <= nowT\n  end\n  nowT = n-2\n  nowS = m-1\n  m.times do\n    case t[nowT]\n      when scale[index[s[nowS]]]\n        nowT -= 1\n      when scale[(index[s[nowS]] + 1) % scale.size]\n        nowT += 1\n      when scale[(index[s[nowS]] - 1 + scale.size) % scale.size]\n        nowT -= 2\n      else\n        break\n    end\n    nowS -= 1\n    ok = true if nowT == 0 && nowS == 0\n    ok = true if nowT == -1 && nowS == -1\n    break if nowT < 0 || n <= nowT\n  end\n  puts ok ? \"Yes\" : \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, k)\n  (music.size - 1).downto(0) do |i|\n    return false unless 0 <= k && k < stairs.size && k < (i + 1) * 2\n    tone = music[i]\n    stair = stairs[k]\n    case (tone - stair) % 12\n    when 1\n      k -= 2\n    when 0\n      k -= 1\n    when 11\n      k += 1\n    else\n      return false\n    end\n  end\n  k == -1\nend\n\ndef work(stairs, music)\n  check(stairs, music, stairs.size - 2) || check(stairs, music, stairs.size - 1)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map!{|x| DICT[x]}\n  music = STDIN.gets.split.map!{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "def calc(t, s)\n  tones = %w(C C# D D# E F F# G G# A A# B)\n  [1, 2].each{|j|\n    i = t.size - j\n    s.reverse.each{|e|\n      idx = tones.index(e)\n      if tones.index(t[i]) == idx\n        i -= 1\n      elsif (tones.index(t[i]) - 1) % 12 == idx && i < t.size - 1\n        i += 1\n      elsif (tones.index(t[i]) + 1) % 12 == idx && i > 0\n        i -= 2\n      else\n        break\n      end\n      return 'Yes' if i == -1\n    }\n  }\n  'No'\nend\ngets.to_i.times do\n  gets\n  t = gets.chomp.split\n  s = gets.chomp.split\n  puts calc(t, s)\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, k)\n  music.size.downto(1) do |i|\n    return false unless 1 <= k && k <= stairs.size && k <= i * 2\n    tone = music[i - 1]\n    stair = stairs[k - 1]\n    case (tone - stair) % 12\n    when 1\n      k -= 2\n    when 0\n      k -= 1\n    when 11\n      k += 1\n    else\n      return false\n    end\n  end\n  k == 0\nend\n\ndef work(stairs, music)\n  check(stairs, music, stairs.size - 1) || check(stairs, music, stairs.size)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map!{|x| DICT[x]}\n  music = STDIN.gets.split.map!{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef f(stairs, music, i, k)\n  if i == music.size\n    return k + 1 == stairs.size || k + 2 == stairs.size\n  end\n\n  tone = music[i]\n  if k >= 1\n    return true if tone == (stairs[k - 1] - 1) % 12 && f(stairs, music, i + 1, k - 1)\n  end\n  if k + 1 < stairs.size\n    return true if tone == stairs[k + 1] && f(stairs, music, i + 1, k + 1)\n  end\n  if k + 2 < stairs.size\n    return true if tone == (stairs[k + 2] + 1) % 12 && f(stairs, music, i + 1, k + 2)\n  end\n  false\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map{|x| DICT[x]}\n  music = STDIN.gets.split.map{|x| DICT[x]}\n  puts f(stairs, music, 0, -1) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "\nscale = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\nindex = Hash[*([scale, (0...scale.size).to_a].transpose).flatten]\n\ngets.to_i.times do\n  n, m = gets.split.map(&:to_i)\n  t = gets.split\n  s = gets.split\n  ok = false\n  nowT = n-1\n  nowS = m-1\n  m.times do\n    case t[nowT]\n      when scale[index[s[nowS]]]\n        nowT -= 1\n      when scale[(index[s[nowS]] + 1) % scale.size]\n        nowT += 1\n      when scale[(index[s[nowS]] - 1 + scale.size) % scale.size]\n        nowT -= 2\n    end\n    nowS -= 1\n    ok = true if nowT == 0 && nowS == 0\n    ok = true if nowT == -1 && nowS == -1\n    break if nowT < 0 || n <= nowT\n  end\n  nowT = n-2\n  nowS = m-1\n  m.times do\n    case t[nowT]\n      when scale[index[s[nowS]]]\n        nowT -= 1\n      when scale[(index[s[nowS]] + 1) % scale.size]\n        nowT += 1\n      when scale[(index[s[nowS]] - 1 + scale.size) % scale.size]\n        nowT -= 2\n    end\n    nowS -= 1\n    ok = true if nowT == 0 && nowS == 0\n    ok = true if nowT == -1 && nowS == -1\n    break if nowT < 0 || n <= nowT\n  end\n  puts ok ? \"Yes\" : \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, i, k)\n  loop do\n    if i == 0\n      return k == -1\n    end\n\n    tone = music[i - 1]\n    stair = stairs[k]\n    if k >= 1 && tone == (stair + 1) % 12\n      i -= 1\n      k -= 2\n      next\n    end\n    if tone == stair\n      i -= 1\n      k -= 1\n      next\n    end\n    if k < stairs.size - 1 && tone == (stair - 1) % 12\n      i -= 1\n      k += 1\n      next\n    end\n    return false\n  end\nend\n\ndef work(stairs, music)\n  (stairs.size >= 2 && check(stairs, music, music.size, stairs.size - 2)) ||\n      check(stairs, music, music.size, stairs.size - 1)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map{|x| DICT[x]}\n  music = STDIN.gets.split.map{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "GC.disable\n\nDICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, k)\n  music.size.downto(1) do |i|\n    return false unless 1 <= k && k <= stairs.size && k <= i * 2\n    tone = music[i - 1]\n    stair = stairs[k - 1]\n    case (tone - stair) % 12\n    when 1\n      k -= 2\n    when 0\n      k -= 1\n    when 11\n      k += 1\n    else\n      return false\n    end\n  end\n  k == 0\nend\n\ndef work(stairs, music)\n  check(stairs, music, stairs.size - 1) || check(stairs, music, stairs.size)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map!{|x| DICT[x]}\n  music = STDIN.gets.split.map!{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "DICT = {\n  'C' => 0, 'C#' => 1, 'D' => 2, 'D#' => 3, 'E' => 4, 'F' => 5,\n  'F#' => 6, 'G' => 7, 'G#' => 8, 'A' => 9, 'A#' => 10, 'B' => 11,\n}\n\ndef check(stairs, music, k)\n  music.size.downto(1) do |i|\n    return false unless 1 <= k && k <= stairs.size && k <= i * 2\n    tone = music[i - 1]\n    stair = stairs[k - 1]\n    case (tone - stair) % 12\n    when 1\n      k -= 2\n    when 0\n      k -= 1\n    when 11\n      k += 1\n    else\n      return false\n    end\n  end\n  k == 0\nend\n\ndef work(stairs, music)\n  check(stairs, music, stairs.size - 1) || check(stairs, music, stairs.size)\nend\n\ns = STDIN.gets.to_i\ns.times do\n  STDIN.gets\n  stairs = STDIN.gets.split.map!{|x| DICT[x]}\n  music = STDIN.gets.split.map!{|x| DICT[x]}\n  puts work(stairs, music) ? 'Yes' : 'No'\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nenum F = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nint[string] RMap(string[] xs) {\n    int[string] ret;\n    foreach (int i, x; xs) ret[x] = i;\n    return ret;\n}\n\nint next(int n) {\n    return (n + 1) % 12;\n}\nint prev(int n) {\n    return (n + 12 - 1) % 12;\n}\n\nenum R = RMap(F);\n\nvoid main() {\n    int N, M;\n    int[] T, S;\n    void input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        T = readln.chomp.split(\" \").map!((x) => R[x]).array;\n        S = readln.chomp.split(\" \").map!((x) => R[x]).array;\n    }\n    bool valid(int n) {\n        return 0 <= n && n < N;\n    }\n    void solve() {\n        auto dp = new bool[][](2, N);\n        dp[0][0] = S[0] == T[0];\n        dp[0][1] = S[0] == T[1].next;\n        foreach (i; 0 .. M - 1) {\n            dp[(i + 1) & 1][] = false;\n            foreach (k; 0 .. N) {\n                if (!(dp[i & 1][k])) continue;\n                if (valid(k - 1))\n                dp[(i + 1) & 1][k - 1] |= T[k - 1].prev == S[i + 1];\n                if (valid(k + 1))\n                dp[(i + 1) & 1][k + 1] |= T[k + 1]      == S[i + 1];\n                if (valid(k + 2))\n                dp[(i + 1) & 1][k + 2] |= T[k + 2].next == S[i + 1];\n            }\n        }\n        auto last = dp[(M - 1) & 1].ptr;\n        writeln(last[N - 2] || last[N - 1] ? \"Yes\" : \"No\");\n    }\n    int _T; scanf(\"%d\\n\", &_T);\n    foreach (t; 0 .. _T) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nenum F = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nint[string] RMap(string[] xs) {\n    int[string] ret;\n    foreach (int i, x; xs) ret[x] = i;\n    return ret;\n}\n\nint next(int n) {\n    return (n + 1) % 12;\n}\nint prev(int n) {\n    return (n + 12 - 1) % 12;\n}\n\nenum R = RMap(F);\n\nint[] T, S;\nvoid main() {\n    int N, M;\n    void input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        T = [-1] ~ readln.chomp.split(\" \").map!((x) => R[x]).array;\n        S = [-1] ~ readln.chomp.split(\" \").map!((x) => R[x]).array;\n    }\n    void solve() {\n        //writeln([N, M]);\n        bool dfs(int i, int k) {\n            if (i == 0) return k == 0;\n            if (k <= 0 || k > N) return false;\n            if (S[i] == T[k].prev && dfs(i - 1, k + 1)) return true;\n            if (S[i] == T[k]      && dfs(i - 1, k - 1)) return true;\n            if (S[i] == T[k].next && dfs(i - 1, k - 2)) return true;\n            return false;\n        }\n        writeln(dfs(M, N) || dfs(M, N - 1) ? \"Yes\" : \"No\");\n    }\n    int _T; scanf(\"%d\\n\", &_T);\n    foreach (t; 0 .. _T) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nenum F = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nint[string] RMap(string[] xs) {\n    int[string] ret;\n    foreach (int i, x; xs) ret[x] = i;\n    return ret;\n}\n\nint next(int n) {\n    return (n + 1) % 12;\n}\nint prev(int n) {\n    return (n + 12 - 1) % 12;\n}\n\nenum R = RMap(F);\n\nvoid main() {\n    int N, M;\n    int[] T, S;\n    void input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        T = readln.chomp.split(\" \").map!((x) => R[x]).array;\n        S = readln.chomp.split(\" \").map!((x) => R[x]).array;\n    }\n    void solve() {\n        //writeln(T, S);\n        bool[Tuple!(int, int)] memo;\n        bool dfs(int i, int k) {\n            //writeln([k, i]);\n            if (i == M) return abs(N - k) <= 2;\n            if (tuple(i, k) in memo) return memo[tuple(i, k)];\n            if (k - 1 >= 0 && T[k - 1].prev == S[i]) \n                if (dfs(i + 1, k - 1)) return true;\n            if (k + 1 < N && T[k + 1] == S[i])\n                if (dfs(i + 1, k + 1)) return true;\n            if (k + 2 < N && T[k + 2].next == S[i])\n                if (dfs(i + 1, k + 2)) return true;\n            return memo[tuple(i, k)] = false;\n        }\n        writeln(dfs(0, -1) ? \"Yes\" : \"No\");\n    }\n    int _T; scanf(\"%d\\n\", &_T);\n    foreach (t; 0 .. _T) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nenum F = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nint[string] RMap(string[] xs) {\n    int[string] ret;\n    foreach (int i, x; xs) ret[x] = i;\n    return ret;\n}\n\nint next(int n) {\n    return (n + 1) % 12;\n}\nint prev(int n) {\n    return (n + 12 - 1) % 12;\n}\n\nenum R = RMap(F);\n\nvoid main() {\n    int N, M;\n    int[] T, S;\n    void input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        T = readln.chomp.split(\" \").map!((x) => R[x]).array;\n        S = readln.chomp.split(\" \").map!((x) => R[x]).array;\n    }\n    void solve() {\n        //writeln(T, S);\n        bool dfs(int i, int k) {\n            //writeln([k, i]);\n            if (i == M) return abs(N - k) <= 2;\n            if (k - 1 >= 0 && T[k - 1].prev == S[i]) \n                if (dfs(i + 1, k - 1)) return true;\n            if (k + 1 < N && T[k + 1] == S[i])\n                if (dfs(i + 1, k + 1)) return true;\n            if (k + 2 < N && T[k + 2].next == S[i])\n                if (dfs(i + 1, k + 2)) return true;\n            return false;\n        }\n        writeln(dfs(0, -1) ? \"Yes\" : \"No\");\n    }\n    int _T; scanf(\"%d\\n\", &_T);\n    foreach (t; 0 .. _T) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def notetonum(notestr):\n    numlist=[]\n    nn=[\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"]\n    for c in notestr:\n        numlist.append(nn.index(c))\n    return numlist\n\n\nQ=int(raw_input())\nfor q in range(Q):\n    [n,m]=[int(x) for x in raw_input().split()]\n    stairlist=notetonum(raw_input().split())\n    songlist=notetonum(raw_input().split())\n    dp=[[0 for x in range(n)] for y in range(m)]\n    if songlist[0]==stairlist[0]:\n        dp[0][0]=1\n    if songlist[0]==(stairlist[1]+1)%12:\n        dp[0][1]=1\n    for i in range(m-1):\n        for j in range(0,n):\n            if j<n-1 and dp[i][j] and songlist[i+1]==stairlist[j+1]:\n                dp[i+1][j+1]=1\n            if j<n-2 and dp[i][j] and songlist[i+1]==(stairlist[j+2]+1)%12:\n                dp[i+1][j+2]=1\n            if j>0 and dp[i][j] and songlist[i+1]==(stairlist[j-1]-1)%12:\n                dp[i+1][j-1]=1\n    print dp\n    if dp[m-1][n-1] or dp[m-1][n-2]:\n        print \"YES\"\n    else:\n        print \"NO\""
  },
  {
    "language": "Python",
    "code": "dic = {\"C\":0, \"C#\":1, \"D\":2, \"D#\":3,\n       \"E\":4, \"F\":5, \"F#\":6, \"G\":7,\n       \"G#\":8, \"A\":9, \"A#\":10, \"B\":11}\nt = int(input())\nfor _ in range(t):\n  n, m = map(int, input().split())\n  t_lst = [-100] + list(map(lambda x:dic[x],input().split()))\n  s_lst = list(map(lambda x:dic[x],input().split()))\n  s_lst.reverse()\n  \n  def search(stack):\n    t_index, s_index = stack.pop()\n    if s_index == m: return t_index == 0\n    if t_index <= 0 or t_index > n: return False\n    base = t_lst[t_index]\n    proc = s_lst[s_index]\n    diff = (proc - base) % 12\n    if diff == 1  :stack.append((t_index - 2, s_index + 1))\n    if diff == 0  :stack.append((t_index - 1, s_index + 1))\n    if diff == 11 :stack.append((t_index + 1, s_index + 1))\n    return False\n  stack = [(n, 0), (n - 1, 0)]\n  while stack:\n    if search(stack):\n      print(\"Yes\")\n      break\n  else:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "\ndef notetonum(notestr):\n    numlist=[]\n    nn=[\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"]\n    for c in notestr:\n        numlist.append(nn.index(c))\n    return numlist\n\n\nQ=int(raw_input())\nfor q in range(Q):\n    [n,m]=[int(x) for x in raw_input().split()]\n    stairlist=notetonum(raw_input().split())\n    songlist=notetonum(raw_input().split())\n    #dp=[[0 for x in range(n)] for y in range(m)]\n    stateold=[0 for x in range(n)]\n    statenew=[0 for x in range(n)]\n    isoneold=[]\n    isonenew=[]\n    if songlist[0]==stairlist[0]:\n        stateold[0]=1\n        isoneold.append(0)\n    if songlist[0]==(stairlist[1]+1)%12:\n        statenew[1]=1\n        isoneold.append(1)\n    for i in range(m-1):\n        isonenew=[]\n        for j in isoneold:\n            if j<n-1 and songlist[i+1]==stairlist[j+1]:\n                statenew[j+1]=1\n                isonenew.append(j+1)\n            if j<n-2 and songlist[i+1]==(stairlist[j+2]+1)%12:\n                statenew[j+2]=1\n                isonenew.append(j+2)\n            if j>0 and songlist[i+1]==(stairlist[j-1]-1)%12:\n                statenew[j-1]=1\n                isonenew.append(j-1)\n            stateold=statenew[:]\n            isoneold=set(isonenew)\n    if statenew[n-1] or statenew[n-2]:\n        print \"YES\"\n    else:\n        print \"NO\""
  },
  {
    "language": "Python",
    "code": "dic = {\"C\":0, \"C#\":1, \"D\":2, \"D#\":3,\n       \"E\":4, \"F\":5, \"F#\":6, \"G\":7,\n       \"G#\":8, \"A\":9, \"A#\":10, \"B\":11}\nt = int(input())\nfor _ in range(t):\n  n, m = map(int, input().split())\n  t_lst = [-100] + list(map(lambda x:dic[x],input().split()))\n  s_lst = list(map(lambda x:dic[x],input().split()))\n  s_lst.reverse()\n  \n  def search(t_index, s_index):\n    if s_index == m: return t_index == 0\n    if t_index <= 0 or t_index > n: return False\n    base = t_lst[t_index]\n    proc = s_lst[s_index]\n    diff = (proc - base) % 12\n    if diff == 1  and search(t_index - 2, s_index + 1) or\\\n       diff == 0  and search(t_index - 1, s_index + 1) or\\\n       diff == 11 and search(t_index + 1, s_index + 1): return True\n    return False\n  \n  print(\"Yes\" if search(n, 0) or search(n - 1, 0) else \"No\")\n"
  }
]