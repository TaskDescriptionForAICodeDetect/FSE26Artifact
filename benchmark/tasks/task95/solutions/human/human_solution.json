[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n\nconst int INF = 1 << 24;\n\nstruct P{\n\tint x, y;\n};\n\ntypedef std::pair<P, int> State;\n\nstd::vector<P> getPointYouCanGo(int x, int y){\n\tif(y % 2 == 0){//even\n\t\t\treturn {{x-1, y-1}, {x-1, y}, {x-1, y+1}, {x, y-1}, {x, y+1}, {x+1, y}};\n\t}else{//odd\n\t\treturn {{x-1, y}, {x, y-1}, {x, y+1}, {x+1, y-1}, {x+1, y}, {x+1, y+1}};\n\t}\n}\n\ntemplate<class T>\nstd::vector<T> filter(const std::vector<T> v, std::function<bool(T)> cond){\n\tstd::vector<T> result;\n\tfor(auto e : v){\n\t\tif(cond(e)){\n\t\t\tresult.push_back(e);\n\t\t}\n\t}\n\treturn result;\n}\n\nint map[3][100][100], m, n;\n\nvoid initializeMap(int index, int default_value){\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tmap[index][i][j] = default_value;\n\t\t}\n\t}\n}\n\nvoid createMap(int x, int y){\n\tstd::queue<State> sv;\n\tmap[0][x][y] = 0;\n\tsv.push(std::make_pair(P{x, y}, 0));\n\t\n\twhile(!sv.empty()){\n\t\tState s = sv.front(); sv.pop();\n\t\tP begin_p = s.first;\n\t\tint count = s.second;\n\n\t\tstd::vector<P> pv = filter<P>(getPointYouCanGo(begin_p.x, begin_p.y), [](P p) -> bool{\n\t\t\t\treturn 0 <= p.x && p.x < m && 0 <= p.y && p.y < n;\n\t\t\t});\n\n\t\tfor(const P p : pv){\n\t\t\tif(map[0][p.x][p.y] == -1){\n\t\t\t\tmap[0][p.x][p.y] = count + 1;\n\t\t\t\tsv.push(std::make_pair(p, count+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update(){\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tmap[1][i][j] = std::min(map[1][i][j], map[0][i][j]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint s, t;\n\n\twhile(std::cin >> m >> n, m){\n\t\tinitializeMap(1, INF);\n\n\t\tstd::cin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\tinitializeMap(0, -1);\n\t\t\tcreateMap(x-1, y-1);\n\t\t\tupdate();\n\t\t}\n\n\t\tint maximumBlocks = 0;\n\t\tstd::cin >> t;\n\t\tfor(int k=0;k<t;k++){\n\t\t\tint x, y, blocks = 0;\n\t\t\tstd::cin >> x >> y;\n\t\t\tinitializeMap(0, -1);\n\t\t\tcreateMap(x-1, y-1);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[0][i][j] < map[1][i][j]){//win\n\t\t\t\t\t\tblocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximumBlocks = std::max(maximumBlocks, blocks);\n\t\t}\n\n\t\tstd::cout << maximumBlocks << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\npublic:\n    int x, y;\n    coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{-1, -1, -1, 0, 1, 0}, {0, -1, 0, 1, 1, 1}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(H, vector<pii>(W, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\nconst int dx[2][6]={{1,-1,-1,0,-1,0},{1,-1,1,0,0,1}};\nconst int dy[2][6]={{0,0,1,1,-1,-1},{0,0,1,1,-1,-1}};\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        int index;\n        P(){}\n        P(int x,int y,int cost,int index):x(x),y(y),cost(cost),index(index){}\n};\n\nclass Data{\n        public:\n        int cost;\n        int index;\n        Data(){}\n        Data(int cost,int index):cost(cost),index(index){}\n};\n\nint main(){\n        int m,n;\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                int s;\n                scanf(\"%d\",&s);\n\n                queue< P > Q;\n                int sx[100];\n                int sy[100];\n                for(int i = 0; i < s; i++){\n                        scanf(\"%d%d\",&sx[i],&sy[i]);\n                }\n\n                int t;\n                scanf(\"%d\",&t);\n                int ans = -11000;\n                for(int q = 0; q < t; q++){\n                        int x,y;\n                        Data vis[128][128];\n                        queue< P > Q;\n\n                        for(int i = 0; i < 120; i++){\n                                for(int j = 0; j < 120; j++){\n                                        vis[i][j] = Data(0,0);\n                                }\n                        }\n                        for(int i = 0; i < s; i++){\n                                Q.push(P(sx[i]-1,sy[i]-1,1,i+1));\n                                vis[sx[i]-1][sy[i]-1]=Data(1,i+1);\n                        }\n                        scanf(\"%d%d\",&x,&y);\n                        Q.push(P(x-1,y-1,1,s+1));\n                        vis[x-1][y-1]=Data(1,s+1);\n                        while( Q.size() ){\n                                P p = Q.front();Q.pop();\n                                if(vis[p.x][p.y].cost==-1)continue;\n                                for(int i = 0; i < 6; i++){\n                                        if(p.x+dx[p.y%2][i] < 0 || p.x+dx[p.y%2][i] > m-1 || p.y+dy[p.y%2][i] < 0 || p.y+dy[p.y%2][i] > n-1)continue;\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost == p.cost+1){\n                                                vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost = -1;\n                                                continue;\n                                        }\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost != 0)continue;\n                                        Q.push(P(p.x+dx[p.y%2][i],p.y+dy[p.y%2][i],p.cost+1,p.index));\n                                        vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]] = Data(p.cost+1,p.index);\n                                }\n\n                        }\n                        int res = 0;\n                        for(int i = 0; i < m; i++){\n                                for(int j = 0; j < n; j++){\n                                        if(vis[i][j].cost == -1)vis[i][j].index = 0;\n                                }\n                        }\n                        for(int i = 0; i < m; i++){\n                                for(int j = 0; j < n; j++){\n                                        //printf(\"%3d\",vis[i][j].index);\n                                        if(vis[i][j].index == s+1 && vis[i][j].cost != -1)res++;\n                                }\n                                //puts(\"\");\n                        }\n                        ans = max(ans,res);\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 100000;\n\nclass Node {\npublic:\n    int y, x, depth;\n    Node(int y, int x, int d) :y(y), x(x), depth(d) {}\n};\n\ntypedef tuple<int, int> Point;\n\nenum {EVEN, ODD};\nenum {Y, X};\nconst int NEXT[2][6][2] = {\n    {\n        {0, -1},\n        {-1, -1},\n        {-1, 0},\n        {0, 1},\n        {1, -1},\n        {1, 0},\n    },\n    {\n        {0, -1},\n        {-1, 0},\n        {-1, 1},\n        {0, 1},\n        {1, 0},\n        {1, 1},\n    },\n};\n\nvoid init(vector<vector<int>>& hex, int y, int x) {\n    int h = hex.size(), w = hex[0].size();\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front();\n        q.pop();\n        if(hex[current.y][current.x] <= current.depth) continue;\n        hex[current.y][current.x] = current.depth;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n}\n\nint bfs(const vector<vector<int>>& hex, int y, int x) {\n    int h = hex.size(), w = hex[0].size();\n    int result = 0;\n    set<Point> visited;\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front();\n        q.pop();\n        if(visited.count(Point(current.y, current.x))) continue;\n        visited.insert(Point(current.y, current.x));\n        if(hex[current.y][current.x] <= current.depth) continue;\n        ++result;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int m, n;\n    int s, t;\n    while(cin >> m >> n, m | n) {\n        vector<vector<int>> hex(n, vector<int>(m, INF));\n        for(cin >> s; s > 0; --s) {\n            int x, y;\n            cin >> x >> y;\n            init(hex, y - 1, x - 1);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            int x, y;\n            cin >> x >> y;\n            answer = max(answer, bfs(hex, y - 1, x - 1));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint dxo[6] = { -1,  0, -1, 1, -1, 0};\nint dxe[6] = { 0,  1, -1, 1, 0, 1};\nint dy[6] = {-1, -1,  0, 0,  1, 1}; \n\nstruct node { int x, y, dist, num; };\n\nconst int INF = 1000000009;\nconst int MAX_N = 101;\nconst int MAX_S = 11;\nint n, m, s, t;\nint cx[MAX_S], cy[MAX_S], tx[MAX_S], ty[MAX_S];\nint field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\nchar used[MAX_N][MAX_N];\n\nint bfs(int x, int y) {\n\trep(j,n) rep(i,m) used[i][j] = 0;\n\n\tint res = 0;\n\tqueue<node> que;\n\tnode md = {x, y, 0, -1};\n\tused[x][y] = 1;\n\tque.push(md);\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\tif(dist[nd.x][nd.y] <= nd.dist) continue;\n\n\t\tused[nd.x][nd.y] = 1;\n\t\tres++;\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n && used[xx][yy] == 0 && dist[xx][yy] > nd.dist + 1) {\n\t\t\t\tnode nnd = {xx, yy, nd.dist+1, -1};\n\t\t\t\tused[xx][yy] = 1;\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\trep(y,n) {\n\t\trep(x,m) {\n\t\t\tfield[x][y] = 0;\n\t\t\tdist[x][y] = INF;\n\t\t}\n\t}\n\n\tqueue<node> que;\n\trep(i,s) {\n\t\tnode nd = { cx[i]-1, cy[i]-1, 0, i+1 };\n\t\tque.push(nd);\n\t}\n\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\tif(dist[nd.x][nd.y] > nd.dist) {\n\t\t\tdist[nd.x][nd.y] = nd.dist;\n\t\t\tfield[nd.x][nd.y] = nd.num;\n\t\t} else if(dist[nd.x][nd.y] == nd.dist && field[nd.x][nd.y] != nd.num && field[nd.x][nd.y] != 0) {\n\t\t\tfield[nd.x][nd.y] = 0;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tnode nnd = { xx, yy, nd.dist+1, nd.num };\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxval = 0;\n\trep(i,t) {\n\t\tint res = bfs(tx[i]-1, ty[i]-1);\n\t\tmaxval = max(res, maxval);\n\t}\n\tprintf(\"%d\\n\", maxval);\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) break;\n\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &s);\n\t\trep(i,s) scanf(\"%d%d\", &cx[i], &cy[i]);\n\n\t\tscanf(\"%d\", &t);\n\t\trep(i,t) scanf(\"%d%d\", &tx[i], &ty[i]);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint id,dist;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdist = arg_dist;\n\t}\n\tint row,col,dist;\n};\n\nint W,H;\nint diff_row_GU[6] = {-1,-1,0,0,1,1},diff_col_GU[6] = {-1,0,-1,1,-1,0};\nint diff_row_KI[6] = {-1,-1,0,0,1,1},diff_col_KI[6] = {0,1,-1,1,0,1};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn true;\n\t}\n}\n\nvoid func(){\n\n\tInfo map[H][W];\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tmap[row][col].dist = BIG_NUM;\n\t\t}\n\t}\n\n\tint num_conv;\n\tscanf(\"%d\",&num_conv);\n\n\tint tmp_col,tmp_row;\n\tint adj_row,adj_col;\n\n\tqueue<Data> Q;\n\n\tfor(int loop = 0; loop < num_conv; loop++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_col--;\n\t\ttmp_row--;\n\n\t\tmap[tmp_row][tmp_col].id = loop;\n\t\tmap[tmp_row][tmp_col].dist = 0;\n\n\t\tQ.push(Data(tmp_row,tmp_col,0));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row%2 == 0){\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_GU[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_GU[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\tmap[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\tmap[adj_row][adj_col].id = loop;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_KI[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_KI[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\tmap[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\tmap[adj_row][adj_col].id = loop;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tInfo work_map[H][W];\n\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tint maximum = 0;\n\n\tfor(int loop = 0; loop < T; loop++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_col--;\n\t\ttmp_row--;\n\n\t\tif(rangeCheck(tmp_row,tmp_col) == false || map[tmp_row][tmp_col].dist == 0)continue;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\twork_map[row][col].id = map[row][col].id;\n\t\t\t\twork_map[row][col].dist = map[row][col].dist;\n\t\t\t}\n\t\t}\n\n\t\twork_map[tmp_row][tmp_col].id = 999;\n\t\twork_map[tmp_row][tmp_col].dist = 0;\n\n\t\tQ.push(Data(tmp_row,tmp_col,0));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row%2 == 0){\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_GU[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_GU[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(work_map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\twork_map[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\twork_map[adj_row][adj_col].id = 999;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_KI[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_KI[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(work_map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\twork_map[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\twork_map[adj_row][adj_col].id = 999;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tint tmp = 0;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(work_map[row][col].id == 999)tmp++;\n\t\t\t}\n\t\t}\n\t\tmaximum = max(maximum,tmp);\n\t}\n\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n\nusing namespace std;\nconst int N = 100;\nconst int INF = 100000000;\ntypedef pair<int, int> P;\n\nclass State{\npublic:\n  int x, y, cost;\n  State(int y, int x, int cost) : y(y), x(x), cost(cost) {}\n  //State(int y = 0, int x = 0, int cost = 0) : y(y), x(x), cost(cost) {}\n};\n\nint w, h, s, t;\nint dist[11][N][N];\nint dy[2][6] = {{-1, -1, 0, 1, 1, 0},{-1, -1, 0, 1, 1, 0}};\nint dx[2][6] = {{-1, 0, 1, 0, -1, -1},{0, 1, 1, 1, 0, -1}};\nvector<P> cs;\n\nvoid print(int p){\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cout << dist[p][i][j] << ' ';\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid bfs(int sy, int sx, int p){\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) dist[p][i][j] = INF;\n  queue<State> que;\n  que.push(State(sy, sx, 0));\n  dist[p][sy][sx] = 0;\n  while(!que.empty()){\n    State u = que.front(); que.pop();\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[u.y%2][i];\n      int nx = u.x + dx[u.y%2][i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(dist[p][ny][nx] != INF) continue;\n      dist[p][ny][nx] = u.cost+1;\n      que.push(State(ny, nx, u.cost+1));\n    }\n   }\n}\n\nint solve(){\n  int res = 0;\n  bfs(cs[s].first, cs[s].second, s);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      bool f = false;\n      int valm = INF, col;\n      for(int k=0;k<=s;k++){\n        if(valm > dist[k][i][j]){\n          f = false;\n          valm = dist[k][i][j];\n          col = k;\n        }else if(valm == dist[k][i][j]) f = true;\n      }\n      if(!f && col == s) res++;\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    cs.clear();\n    int x, y;\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      cs.push_back(P(y-1, x-1));\n    }\n    for(int i=0;i<cs.size();i++) bfs(cs[i].first, cs[i].second, i);\n    //for(int i=0;i<cs.size();i++) print(i);\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      cs.push_back(P(y-1, x-1));\n      ans = max(ans, solve());\n      cs.pop_back();\n    }\n    cout << ans << endl;\n    //return 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n\n#include <numeric>\n#include <algorithm>\n#include <functional>\n\n#include <cctype>\n\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nconst double EPS = 1e-9;\nconst int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nconst int ddx1[] = {0,-1,0,1,1,1};\nconst int ddy1[] = {-1,0,1,1,0,-1};\nconst int ddx0[] = {-1,-1,-1,0,1,0};\nconst int ddy0[] = {-1,0,1,1,0,-1};\n\nint main(){\n    while(true){\n        int m,n,s;\n        cin >> m;\n        if(m==0)break;\n        cin >> n >> s;\n        vector<pair<int,int> > V(s);\n\n        rep(i,s){\n            int x,y;\n            cin >> x >> y;\n            x--;y--;\n            V[i] = mp(x,y);\n        }\n        vector<vector<int> > depth(n,vector<int>(m,10000));\n        //x,y,depth\n        queue<pair<pair<int,int>,int> > Q;\n        rep(i,s){\n            Q.push(mp(V[i],0));\n        }\n        while(!Q.empty()){\n            pair<pair<int,int>,int> p = Q.front();\n            int x = p.first.first;int y = p.first.second;\n            int d = p.second;\n            Q.pop();\n            if(depth[y][x] <= d) continue;\n            depth[y][x] = d;\n            for(int i=0;i<6;i++){\n                int newx,newy;\n                if(y % 2 == 0){\n                    newx = x + ddx0[i];\n                    newy = y + ddy0[i];\n                }else{\n                    newx = x + ddx1[i];\n                    newy = y + ddy1[i];\n                }\n                if(newx == -1 || newy == -1 || newx == m || newy == n){\n                    continue;\n                }\n                Q.push(mp(mp(newx,newy),d+1));\n            }\n        }\n\n        int t;\n        cin >> t;\n        vector<pair<int,int> > Con(t);\n        rep(i,t){\n            int p,q;\n            cin >> p >> q;\n            p--;q--;\n            Con[i] = mp(p,q);\n        }\n        int maxcnt = -1;\n\n/*\n        rep(i,n){\n            rep(j,m){\n                cerr << depth[i][j] << \" \";\n            }\n            cerr << endl;\n        }\n*/\n\n        rep(cont,t){\n            pair<int,int> cc = Con[cont];\n            int cnt = 0;\n            //x,y,depth\n            queue<pair<pair<int,int>,int> > Qc;\n            Qc.push(mp(cc,0));\n            vector<vector<int> > depthc = depth;\n            while(!Qc.empty()){\n                pair<pair<int,int>,int> p = Qc.front();\n                int x = p.first.first;int y = p.first.second;\n                int d = p.second;\n                Qc.pop();\n                if(depthc[y][x] <= d) continue;\n\n                depthc[y][x] = d;\n                cnt++;\n                for(int i=0;i<6;i++){\n                    int newx,newy;\n                    if(y % 2 == 0){\n                        newx = x + ddx0[i];\n                        newy = y + ddy0[i];\n                    }else{\n                        newx = x + ddx1[i];\n                        newy = y + ddy1[i];\n                    }\n\n                    if(newx == -1 || newy == -1 || newx == m || newy == n){\n                        continue;\n                    }\n                    Qc.push(mp(mp(newx,newy),d+1));\n                }\n            }\n            maxcnt = max(maxcnt,cnt);\n        }\n        cout << maxcnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nclass Node {\npublic:\n    int y, x, depth;\n    Node(int y, int x, int d) :y(y), x(x), depth(d) {}\n};\n\ntypedef tuple<int, int> Point;\n\nenum {EVEN, ODD};\nenum {Y, X};\nconst int NEXT[2][6][2] = {\n    {\n        {-1, -1},\n        {-1, 0},\n        {0, -1},\n        {0, 1},\n        {1, -1},\n        {1, 0},\n    },\n    {\n        {-1, 0},\n        {-1, 1},\n        {0, -1},\n        {0, 1},\n        {1, 0},\n        {1, 1},\n    },\n};\n\nint bfs(vector<vector<int>>& field, int y, int x, bool write) {\n    int h = field.size(), w = field[0].size();\n    int result = 0;\n    set<Point> visited;\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front(); q.pop();\n        if(visited.count(Point(current.y, current.x))) continue;\n        visited.insert(Point(current.y, current.x));\n        if(field[current.y][current.x] <= current.depth) continue;\n        if(write) field[current.y][current.x] = current.depth;\n        ++result;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int m, n;\n    int s, t;\n    int x, y;\n    while(cin >> m >> n, m | n) {\n        vector<vector<int>> field(n, vector<int>(m, INF));\n        for(cin >> s; s > 0; --s) {\n            cin >> x >> y;\n            bfs(field, y - 1, x - 1, true);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            cin >> x >> y;\n            answer = max(answer, bfs(field, y - 1, x - 1, false));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v, vector< vector<bool> > &visited){\n  int res = 1;\n  visited[y][x] = 1;\n  v[y][x] = n;\n  int t = y % 2 == 0;\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n    res += count(ny, nx, n + 1, v, visited);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n      res = max(res, count(y, x, 0, v, visited));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int x,int y)\n{\n\n  deque<Pi> deq;\n  deq.push_back(Pi(P(x,y),0));\n  mincost[y][x] = 0;\n  visited[y][x] = true;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      Pi pi = deq.front(); deq.pop_front();\n\n      for(int i=0;i<6;i++)\n\t{\n\t  int nx = pi.first.first + dx[pi.first.second%2][i];\n\t  int ny = pi.first.second + dy[pi.first.second%2][i];\n\n\t  if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\t    continue;\n\n\t  if(mincost[ny][nx] > pi.second + 1)\n\t    {\n\t      if(!visited[ny][nx])\n\t\tcnt++;\n\t      visited[ny][nx] = true;\n\t      mincost[ny][nx] = pi.second + 1;\n\t      deq.push_back(Pi(P(nx,ny),pi.second+1));\n\t    }\n\t}\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n) break;\n      cin >> m;\n      for(int i=0;i<n;i++) \n\tfor(int j=0;j<m;j++)\n\t  mincost[i][j] = (1<<29);  \n     \n      int s,t,mex = 1;\n      scanf(\"%d\",&s);\n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  mincost[y][x] = 0;\n\t  dfs(x,y);\n\t}\n     \n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n\t{   \n\t  int pre_mincost[n][m];\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  p--,q--;\n\t  dfs(p,q);\n\t  \n\t  mex = max(mex,cnt);\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = pre_mincost[j][k];\n\t}\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[2][6] = { {0, -1, -1, -1, 0, 1}, {1, 0, -1, 0, 1, 1} };\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\n\nclass State\n{\npublic:\n  int x, y, c;\n  State(int _x = 0, int _y = 0, int _c = 0)\n    :x(_x), y(_y), c(_c) {}\n};\n\nint main()\n{\n  int m, n;\n  while (cin >> m >> n) {\n    if ((m|n) == 0)\n      break;\n\n    int s;\n    cin >> s;\n    vector<vector<int> > cost(m, vector<int>(n, INF));\n    for (int i = 0; i < s; ++i) {\n      int x, y;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] < st.c)\n\t  continue;\n\n\tcost[st.y][st.x] = st.c;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] < st.c+1)\n\t    continue;\n\t  cost[y][x] = st.c+1;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n    }\n\n    int t;\n    cin >> t;\n    int ans = 0;\n    for (int i = 0; i < t; ++i) {\n      int x, y, cnt = 0;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] <= st.c)\n\t  continue;\n\n\t++cnt;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] <= st.c+1)\n\t    continue;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n      ans = max(ans, cnt);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] != INF) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\t//vector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\trep(i, 110) rep (j, 110) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]/*v[nx][ny] == 1*/) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\t//v[nx][ny] = 1;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint fie[101][101];\nbool fie2[101][101];\nint cox[11],coy[11];\nint m,n,s,sn;\nint ans=0;\nconst int dx1[6]={-1,-1,-1,0,1,0};\nconst int dx0[6]={0,-1,0,1,1,1};\nconst int dy[6]={-1,0,1,-1,0,1};\nconst int INF=100000;\n\nvoid bfs(int x,int y){\n\tqueue<PP> que;\n\tque.push(PP(0,P(x,y)));\n\tfie[x][y]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint v=p.first,kx=p.second.first,ky=p.second.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx0[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>v+1){\n\t\t\t\t\tque.push(PP(v+1,P(fx,fy)));\n\t\t\t\t\tfie[fx][fy]=v+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int x,int y){\n\tmemset(fie2,false,sizeof(fie2));\n\tint res=1;\n\tif(fie[x][y]==0)return 0;\n\tqueue<PP> que;\n\tque.push(PP(0,P(x,y)));\n\tfie2[x][y]=true;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint v=p.first,kx=p.second.first,ky=p.second.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx0[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>v+1 && fie2[fx][fy]==false){\n\t\t\t\t\tque.push(PP(v+1,P(fx,fy)));\n\t\t\t\t\tres++;\n\t\t\t\t\tfie2[fx][fy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfie[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tbfs(x,y);\n\t\t}\n\t\tscanf(\"%d\",&sn);\n\t\tfor(int i=0;i<sn;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tans=max(ans,bfs2(x,y));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint n,m;\nint s,t;\npii ps[101];\n// »ê¼êÌÀW©çêÔß¢RrjÖÌ£\nint dists[101][101];\nconst int INF=1000000000;\npii cand[101];\nbool used[101][101];\nbool noSet[101][101];\n\nconst int dy[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\nconst int dx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}};\n\nint calcDist(pii &p1,pii &p2){\n\n    return 0;\n}\n\nint updateMinDist(int sx,int sy,bool isSearch=true){\n    memset(used,0,sizeof(used));\n    queue<pii> q[2];\n    int cur=0;\n    int nxt=1;\n    int cnt=0;\n    pii sp=pii(sy,sx);\n    used[sy][sx]=true;\n    dists[sy][sx]=0;\n    int res=1;\n    q[cur].push(sp);\n    while(q[cur].size()){\n        while(q[cur].size()){\n            pii p=q[cur].front();q[cur].pop();\n            for(int i=0;i<6;i++){\n                int ny=dy[p.first%2][i]+p.first;\n                int nx=dx[p.first%2][i]+p.second;\n                if(ny>=0&&nx>=0&&ny<n&&nx<m&&!used[ny][nx]){\n                    used[ny][nx]=true;\n                    q[nxt].push(pii(ny,nx));\n                    if(isSearch)\n                        dists[ny][nx]=min(dists[ny][nx],cnt+1);\n                    else{\n                        if(dists[ny][nx]>cnt+1){\n                            res++;\n                        }\n                    }\n                }\n            }\n        }\n        cnt++;\n        swap(cur,nxt);\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>m>>n&&(m|n)){\n        memset(noSet,0,sizeof(noSet));\n        cin>>s;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dists[i][j]=INF;\n        for(int i=0;i<s;i++){\n            cin>>ps[i].second>>ps[i].first;\n            ps[i].second--;\n            ps[i].first--;\n            noSet[ps[i].first][ps[i].second]=true;\n        }\n        for(int k=0;k<s;k++)updateMinDist(ps[k].second,ps[k].first);\n        cin>>t;\n        for(int i=0;i<t;i++){\n            cin>>cand[i].second>>cand[i].first;\n            cand[i].second--;\n            cand[i].first--;\n        }\n        int res=0;\n        for(int i=0;i<t;i++){\n            int cnt=0;\n            //if(used[cand[i].first][cand[i].second])continue;\n            // ¡Ìê©çe_ÜÅÌ£ðvZµAß¢àÌÌÝÌp\n            cnt=updateMinDist(cand[i].second,cand[i].first,false);\n            res=max(res,cnt);\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x-1,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y % 2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[101][101];\nint id_list[101][101];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    min_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(sx,sy,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  int candidate_cost[101][101];\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    candidate_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(sx,sy,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> grid;\n\nconst int INF = 1e9;\nconst int dx[6] = {0,1,1,1,0,-1}, dy[6] = {-1,-1,0,1,1,0};\nint h,w;\n\ngrid bfs(int y, int x){\n  grid res(h,vi(w,INF));\n  res[y][x] = 0;\n  queue<int> q;\n  q.push(y*w+x);\n  \n  while(q.size()){\n    y = q.front()/w; x = q.front()%w; q.pop();\n    int c = res[y][x];\n\n    for(int i=0;i<6;i++){\n      int ny = y+dy[i], nx = x+dx[i] + ((y%2==0 && i%3!=2)?-1:0);\n      if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n      if(res[ny][nx]>c+1){\n\tres[ny][nx] = c+1;\n\tq.push(ny*w+nx);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    grid g(h,vi(w,INF));\n\n    int s;\n    cin >> s;\n    for(int z=0;z<s;z++){\n      int a,b; cin >> a >> b; a--; b--;\n      grid tmp = bfs(b,a);\n\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)g[i][j] = min(g[i][j], tmp[i][j]);\n      }\n    }\n\n    int t, res = 0;\n    cin >> t;\n    for(int z=0;z<t;z++){\n      int a,b; cin >> a >> b; a--; b--;\n      grid tmp = bfs(b,a);\n      int cover = 0;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(g[i][j] > tmp[i][j])cover++;\n\t}\n      }\n      res = max(res, cover);\n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint n,m;\nint s,t;\npii ps[101];\n// »ê¼êÌÀW©çêÔß¢RrjÖÌ£\nint dists[101][101];\nconst int INF=1000000000;\npii cand[101];\nbool used[101][101];\nbool noSet[101][101];\n\nconst int dy[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\nconst int dx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}};\n\nint updateMinDist(int sx,int sy,bool isSearch=true){\n    memset(used,0,sizeof(used));\n    queue<pii> q[2];\n    int cur=0;\n    int nxt=1;\n    int cnt=0;\n    pii sp=pii(sy,sx);\n    used[sp.first][sp.second]=true;\n    int res=0;\n    q[cur].push(sp);\n    while(q[cur].size()){\n        while(q[cur].size()){\n            pii p=q[cur].front();q[cur].pop();\n            if(isSearch)dists[p.first][p.second]=min(dists[p.first][p.second],cnt);\n            else if(dists[p.first][p.second]>cnt)res++;\n            for(int i=0;i<6;i++){\n                int ny=dy[p.first%2][i]+p.first;\n                int nx=dx[p.first%2][i]+p.second;\n                if(ny>=0&&nx>=0&&ny<n&&nx<m&&!used[ny][nx]){\n                    q[nxt].push(pii(ny,nx));\n                    used[ny][nx]=true;\n                }\n            }\n        }\n        cnt++;\n        swap(cur,nxt);\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>m>>n&&(m|n)){\n        memset(noSet,0,sizeof(noSet));\n        cin>>s;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dists[i][j]=INF;\n        for(int i=0;i<s;i++){\n            cin>>ps[i].second>>ps[i].first;\n            ps[i].second--;\n            ps[i].first--;\n            noSet[ps[i].first][ps[i].second]=true;\n        }\n        for(int k=0;k<s;k++)updateMinDist(ps[k].second,ps[k].first);\n        cin>>t;\n        for(int i=0;i<t;i++){\n            cin>>cand[i].second>>cand[i].first;\n            cand[i].second--;\n            cand[i].first--;\n        }\n        int res=0;\n        for(int i=0;i<t;i++){\n            int cnt=0;\n            cnt=updateMinDist(cand[i].second,cand[i].first,false);\n            res=max(res,cnt);\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int di[] = {-1,-1,0,0,1,1};\nconst int dj[] = {0,1,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    if( M.T[now.i][now.j].dist[store] < infty ) continue;\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(di)/sizeof(*di); ++i){\n      int ti = now.i + di[i];\n      int tj = now.j + dj[i];\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n      M.T[now.i][now.j].dist[store] = now.cost;\n\n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int m,n;cin>>m>>n,m;){\n    int s;\n    cin>>s;\n    int g[100][100];\n    fill(g[0],g[100],1<<29);\n    int sh[100][100]={};\n    for(int i=1;i<=s;i++){\n      int x,y;\n      cin>>x>>y;\n      x--;\n      y--;\n      sh[y][x]=i;\n      g[y][x]=0;\n    }\n    int a=0;\n    int t;\n    cin>>t;\n    while(t--){\n      int x,y;\n      cin>>x>>y;\n      x--;\n      y--;\n      int gg[100][100];\n      copy(g[0],g[n],gg[0]);\n      int ss[100][100];\n      copy(sh[0],sh[n],ss[0]);\n      ss[y][x]=-1;\n      gg[y][x]=0;\n      for(int i=0;i<m*n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int k=0;k<m;k++){\n\t    for(int l=0;l<6;l++){\n\t      int dy[]={-1,0,1,1,0,-1};\n\t      int dx[][6]={{0,1,0,-1,-1,-1},{1,1,1,0,-1,0}};\n\t      int ny=j+dy[l];\n\t      int nx=k+dx[j%2][l];\n\t      if(0<=min(nx,ny)&&ny<n&&nx<m){\n\t\tint c=gg[ny][nx]+1;\n\t\tif(c<gg[j][k]){\n\t\t  gg[j][k]=c;\n\t\t  ss[j][k]=ss[ny][nx];\n\t\t}else if(c==gg[j][k]){\n\t\t  if(ss[j][k]!=ss[ny][nx]){\n\t\t    ss[j][k]=0;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      int c=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<m;j++){\n\t  c+=ss[i][j]==-1;\n\t}\n      }\n      a=max(c,a);\n    }\n    cout<<a<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint INF=(1<<24);\nint dy[6]={0,-1,-1,0,1,1};\nint dx[2][6]={\n  {-1,-1,0,1,0,-1},{-1,0,1,1,1,0}\n};\nint W,H,n,m,I;\nint ty[100],tx[100];\nint uy[100],ux[100];\nint v[100][100];\n\nqueue <int> Qy;\nqueue <int> Qx;\nqueue <int> Qcnt;\nqueue <int> Qid;\n\nbool input();\nvoid init(int);\nvoid solve();\nint bfs();\n\nint main(){\n  while(input())solve();\n  return 0;\n}\n\nint bfs(){\n  int y,x,ny,nx,cnt,id,res=0;\n  while(!Qy.empty()){\n    y=Qy.front();Qy.pop();\n    x=Qx.front();Qx.pop();\n    cnt=Qcnt.front();Qcnt.pop();\n    id=Qid.front();Qid.pop();\n\n    if(cnt>=v[y][x])continue;\n    v[y][x]=cnt;\n    if(id==n+I)res++;\n\n    for(int i=0;i<6;i++){\n      ny=y+dy[i];\n      nx=x+dx[y%2][i];\n      if(ny<0||nx<0||ny>=H||nx>=W)continue;\n\t \n      Qy.push(ny);\n      Qx.push(nx);\n      Qcnt.push(cnt+1);\n      Qid.push(id);\n    \n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int ans=0;\n  for(I=0;I<m;I++){\n    init(I);\n    ans=max(ans,bfs());\n  }\n  cout<<ans<<endl;\n}\n\nbool input(){\n  cin>>H>>W;\n  if(H==0&&W==0)return false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>tx[i]>>ty[i];\n  }\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>ux[i]>>uy[i];\n  }\n  return true;\n}\n\nvoid init(int s){\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      v[i][j]=INF;\n    }\n  }\n  while(!Qy.empty()){\n    Qy.pop();\n    Qx.pop();\n    Qcnt.pop();\n    Qid.pop();\n  }\n  \n\n  for(int i=0;i<n;i++){\n    Qy.push(ty[i]);\n    Qx.push(tx[i]);\n    Qcnt.push(0);\n    Qid.push(i);\n  }\n  Qy.push(uy[s]);\n  Qx.push(ux[s]);\n  Qcnt.push(0);\n  Qid.push(n+s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 100000;\n\nclass Node {\npublic:\n    int y, x, depth;\n    Node(int y, int x, int d) :y(y), x(x), depth(d) {}\n};\n\ntypedef tuple<int, int> Point;\n\nenum {EVEN, ODD};\nenum {Y, X};\nconst int NEXT[2][6][2] = {\n    {\n        {0, -1},\n        {-1, -1},\n        {-1, 0},\n        {0, 1},\n        {1, -1},\n        {1, 0},\n    },\n    {\n        {0, -1},\n        {-1, 0},\n        {-1, 1},\n        {0, 1},\n        {1, 0},\n        {1, 1},\n    },\n};\n\nint bfs(vector<vector<int>>& hex, int y, int x, bool write) {\n    int h = hex.size(), w = hex[0].size();\n    int result = 0;\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front();\n        q.pop();\n        if(hex[current.y][current.x] <= current.depth) continue;\n        if(write) hex[current.y][current.x] = current.depth;\n        ++result;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int m, n;\n    int s, t;\n    int x, y;\n    while(cin >> m >> n, m | n) {\n        vector<vector<int>> hex(n, vector<int>(m, INF));\n        for(cin >> s; s > 0; --s) {\n            cin >> x >> y;\n            bfs(hex, y - 1, x - 1, true);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            cin >> x >> y;\n            answer = max(answer, bfs(hex, y - 1, x - 1, false));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\n    public:\n        int x, y;\n        coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{0, -1, 0, 1, 1, 1}, {-1, -1, -1, 0, 1, 0}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(H+1, vector<pii>(W+1, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\n\nint dist(pii a, pii b)\n{\n    int dy = a.first - b.first;\n    int dx = a.second - b.second;\n    if(0 <= dy*dx){\n        dy = abs(dy);\n        dx = abs(dx);\n        return dy + max(0, dx - (dy+1-min(a.first,b.first)%2)/2);\n    }\n    else{\n        dy = abs(dy);\n        dx = abs(dx);\n        return dy + max(0, dx - (dy + min(a.first, b.first)%2)/2);\n    }\n}\n\nint main()\n{\n    int m, n;\n    while(scanf(\"%d%d\", &m, &n), m){\n        int s;\n        scanf(\"%d\", &s);\n        pii conv[10];\n        rep(i, s)\n            scanf(\"%d%d\", &conv[i].second, &conv[i].first);\n\n        int d[101][101];\n        rep(i, n) rep(j, m){\n            d[i+1][j+1] = INF;\n            rep(k, s)\n                d[i+1][j+1] = min(d[i+1][j+1], dist(pii(i+1, j+1), conv[k]));\n        }\n\n        int t, ans = 0;\n        scanf(\"%d\", &t);\n        rep(i, t){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n\n            int cnt = 0;\n            rep(j, n) rep(k, m)\n                cnt += dist(pii(j+1, k+1), pii(y, x)) < d[j+1][k+1];\n            ans = max(ans, cnt);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x-1,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y % 2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[128][128];\nint id_list[128][128];\nint candidate_cost[128][128];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  min_cost[sx][sy] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n  candidate_cost[sx][sy] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n      \n      candidate_cost[dx][dy] = s.cost + 1;\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 100000;\n\nclass Node {\npublic:\n    int y, x, depth;\n    Node(int y, int x, int d) :y(y), x(x), depth(d) {}\n};\n\ntypedef tuple<int, int> Point;\n\nenum {EVEN, ODD};\nenum {Y, X};\nconst int NEXT[2][6][2] = {\n    {\n        {0, -1},\n        {-1, -1},\n        {-1, 0},\n        {0, 1},\n        {1, -1},\n        {1, 0},\n    },\n    {\n        {0, -1},\n        {-1, 0},\n        {-1, 1},\n        {0, 1},\n        {1, 0},\n        {1, 1},\n    },\n};\n\nint bfs(vector<vector<int>>& hex, int y, int x, bool write) {\n    int h = hex.size(), w = hex[0].size();\n    int result = 0;\n    set<Point> visited;\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front();\n        q.pop();\n        if(visited.count(Point(current.y, current.x))) continue;\n        visited.insert(Point(current.y, current.x));\n        if(hex[current.y][current.x] <= current.depth) continue;\n        if(write) hex[current.y][current.x] = current.depth;\n        ++result;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int m, n;\n    int s, t;\n    int x, y;\n    while(cin >> m >> n, m | n) {\n        vector<vector<int>> hex(n, vector<int>(m, INF));\n        for(cin >> s; s > 0; --s) {\n            cin >> x >> y;\n            bfs(hex, y - 1, x - 1, true);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            cin >> x >> y;\n            answer = max(answer, bfs(hex, y - 1, x - 1, false));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 1;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    /*\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n    }\n    */\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h, VI( w, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\n\nint m, n, s;\nint min_cost[100][100];\nint dy[] = { -1, -1, 0, 1, 1, 0};\nint dx[][6] = {{ -1, 0, 1, 0, -1, -1}, { 0, 1, 1, 1, 0, -1}};\n\nbool isover(int y, int x){\n  return y < 0 || y >= n || x < 0 || x >= m;\n}\n\nvoid bfs(queue< Pii >& que){\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] < p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      min_cost[ny][nx] = p.fr + 1;\n    }\n  }\n}\n\nint prebfs(int y, int x){\n  int ret = 1;\n  bool used[100][100] = {{}};\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n\n  if(!min_cost[y][x]) return 0;\n\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    if(used[p.sc.fr][p.sc.sc]++) continue;\n    ret++;\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr %2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] <= p.fr + 1) continue;\n\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  queue< Pii > que;\n\n  while(cin >> m, m){\n    fill_n( *min_cost, 10000, 1 << 30);\n\n    cin >> n >> s;\n\n    for(int i = 0 ; i < s ; i++ ){\n      int x, y;\n      cin >> x >> y;\n      que.push( Pii( 0, Pi( y - 1, x - 1)));\n      min_cost[y - 1][x - 1] = 0;\n    }\n    bfs(que);\n\n    int t, ret = 0;\n    cin >> t;\n    while(t--){\n      int p, q;\n      cin >> p >> q;\n      ret = max( ret,prebfs( q, p));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\nbool f;\n\nvoid dfs(int x,int y)\n{\n\n  deque<P> deq;\n  deq.push_back(P(x,y));\n  mincost[y][x] = 0;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      P p = deq.front(); deq.pop_front();\n\n      for(int i=0;i<6;i++)\n\t{\n\t  int nx = p.first + dx[p.second%2][i];\n\t  int ny = p.second + dy[p.second%2][i];\n\n\t  if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\t    continue;\n\n\t  if(mincost[ny][nx] > mincost[p.second][p.first] + 1)\n\t    {\n\t      if(!visited[ny][nx])\n\t\tcnt++;\n\t      visited[ny][nx] = true;\n\t      mincost[ny][nx] = mincost[p.second][p.first] + 1;\n\t      deq.push_back(P(nx,ny));\n\t    }\n\t}\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n) break;\n      cin >> m;\n      for(int i=0;i<n;i++) \n\tfor(int j=0;j<m;j++)\n\t  mincost[i][j] = (1<<29);  \n      f = true;\n      int s,t,mex = 0;\n      scanf(\"%d\",&s);\n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  mincost[y][x] = 0;\n\t  dfs(x,y);\n\t}\n      f = false;\n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n\t{   \n\t  int pre_mincost[n][m];\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\n\t  cnt = 0,p--,q--;\n\t  mincost[q][p] = 0,visited[q][p] = true;\n\t  \n\t  dfs(p,q);\n\t  \n\t  mex = max(mex,cnt);\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = pre_mincost[j][k];\n\t}\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\npublic:\n    int x, y;\n    coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{-1, -1, -1, 0, 1, 0}, {0, -1, 0, 1, 1, 1}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(100, vector<pii>(100, MP(-1, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n\n            int cnt = 0;\n\n            rep(i, H) rep(j, W) if (mp[i][j].fst == 0) cnt++;\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint H, W, N, M, p[100], q[100], x, y, dist[109][109][11]; vector<pair<int, int>> X[109][109];\nint dy1[6] = { 0,0,-1,-1,1,1 }, dx1[6] = { -1,1,-1,0,-1,0 };\nint dy2[6] = { 0,0,-1,-1,1,1 }, dx2[6] = { -1,1,0,1,0,1 };\n\nint solve() {\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++) { for (int k = 0; k <= N; k++) dist[i][j][k] = (1 << 30); } }\n\tfor (int i = 0; i <= N; i++) {\n\t\tqueue<pair<int, int>>Q;\n\t\tQ.push(make_pair(p[i], q[i])); dist[p[i]][q[i]][i] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint to1 = Q.front().first, to2 = Q.front().second; Q.pop();\n\t\t\tfor (int j = 0; j < X[to1][to2].size(); j++) {\n\t\t\t\tint p1 = X[to1][to2][j].first, p2 = X[to1][to2][j].second;\n\t\t\t\tif (dist[p1][p2][i] > dist[to1][to2][i] + 1) {\n\t\t\t\t\tdist[p1][p2][i] = dist[to1][to2][i] + 1;\n\t\t\t\t\tQ.push(make_pair(p1, p2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (dist[i][j][0] >= dist[i][j][k]) OK = false;\n\t\t\t}\n\t\t\tif (OK == true) ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0) break;\n\t\tfor (int i = 0; i < 109; i++) { for (int j = 0; j < 109; j++) X[i][j].clear(); }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\tint fx = i, fy = j;\n\t\t\t\t\tif (j % 2 == 1) { fx += dx1[k]; fy += dy1[k]; }\n\t\t\t\t\tif (j % 2 == 0) { fx += dx2[k]; fy += dy2[k]; }\n\t\t\t\t\tif (fx <= 0 || fy <= 0 || fx > H || fy > W) continue;\n\t\t\t\t\tX[i][j].push_back(make_pair(fx, fy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor (int i = 1; i <= N; i++) { cin >> p[i] >> q[i]; }\n\t\tint ret = 0;\n\t\tcin >> M;\n\t\tfor (int i = 1; i <= M; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[0] = x; q[0] = y;\n\t\t\tret = max(ret, solve());\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y & 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y & 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\t//vector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\trep(i, w + 1) rep (j, h + 1) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y & 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y & 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]/*v[nx][ny] == 1*/) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\t//v[nx][ny] = 1;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\n\nstruct Data{\n\tint y, x;\n\tbool is_deven;\n\tData(){}\n\tData(int _y, int _x, bool _is_deven){\n\t\ty = _y; x = _x; is_deven = _is_deven;\n\t}\n};\n\nint main(){\n\tint N, M, S, T, X[10], Y[10], P, Q;\n\twhile(cin >> N >> M, N || M){\n\t\tcin >> S;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\n\t\tcin >> T;\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> P >> Q;\n\t\t\tP--; Q--;\n\n\t\t\tqueue<Data> q;\n\t\t\tData q_front;\n\t\t\tbool used[100][100] = {};\n\t\t\tint deven_scope = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < S; j++){\n\t\t\t\tq.push( Data(Y[j], X[j], false) );\n\t\t\t}\n\t\t\tq.push( Data(Q, P, true) );\n\n\t\t\twhile( !q.empty() ){\n\t\t\t\tq_front = q.front(); q.pop();\n\n\t\t\t\tif(used[q_front.y][q_front.x]) continue;\n\t\t\t\tused[q_front.y][q_front.x] = true;\n\n\t\t\t\tif(q_front.is_deven) deven_scope++;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tint ny = q_front.y + dy[j];\n\t\t\t\t\tint nx = q_front.x + dx[q_front.y&1][j];\n\t\t\t\t\t\n\t\t\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\n\t\t\t\t\tq.push( Data(ny, nx, q_front.is_deven) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, deven_scope);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint n,m;\nint s,t;\npii ps[101];\n// »ê¼êÌÀW©çêÔß¢RrjÖÌ£\nint dists[101][101];\nconst int INF=1000000000;\npii cand[101];\nbool used[101][101];\nbool noSet[101][101];\n\nconst int dy[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\nconst int dx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}};\n\nint calcDist(pii &p1,pii &p2){\n\n    return 0;\n}\n\nint updateMinDist(int sx,int sy,bool isSearch=true){\n    memset(used,0,sizeof(used));\n    queue<pii> q[2];\n    int cur=0;\n    int nxt=1;\n    int cnt=0;\n    pii sp=pii(sy,sx);\n    used[sy][sx]=true;\n    dists[sy][sx]=0;\n    int res=1;\n    q[cur].push(sp);\n    while(q[cur].size()){\n        while(q[cur].size()){\n            pii p=q[cur].front();q[cur].pop();\n            for(int i=0;i<6;i++){\n                int ny=dy[p.first%2][i]+p.first;\n                int nx=dx[p.first%2][i]+p.second;\n                if(ny>=0&&nx>=0&&ny<n&&nx<m&&!used[ny][nx]){\n                    used[ny][nx]=true;\n                    q[nxt].push(pii(ny,nx));\n                    if(isSearch)\n                        dists[ny][nx]=min(dists[ny][nx],cnt+1);\n                    else{\n                        if(dists[ny][nx]>cnt+1){\n                            res++;\n                        }\n                    }\n                }\n            }\n        }\n        cnt++;\n        swap(cur,nxt);\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>m>>n&&(m|n)){\n        memset(noSet,0,sizeof(noSet));\n        cin>>s;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dists[i][j]=INF;\n        for(int i=0;i<s;i++){\n            cin>>ps[i].second>>ps[i].first;\n            ps[i].second--;\n            ps[i].first--;\n            noSet[ps[i].first][ps[i].second]=true;\n        }\n        for(int k=0;k<s;k++)updateMinDist(ps[k].second,ps[k].first);\n        cin>>t;\n        for(int i=0;i<t;i++){\n            cin>>cand[i].second>>cand[i].first;\n            cand[i].second--;\n            cand[i].first--;\n        }\n        int res=0;\n        for(int i=0;i<t;i++){\n            int cnt=0;\n            //if(used[cand[i].first][cand[i].second])continue;\n            // ¡Ìê©çe_ÜÅÌ£ðvZµAß¢àÌÌÝÌp\n            cnt=updateMinDist(cand[i].second,cand[i].first,false);\n            res=max(res,cnt);\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 1;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        /*\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n        */\n    }\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h, VI( w, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\nconst int dx[2][6]={{1,-1,-1,0,-1,0},{1,-1,1,0,0,1}};\nconst int dy[2][6]={{0,0,1,1,-1,-1},{0,0,1,1,-1,-1}};\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        int index;\n        P(){}\n        P(int x,int y,int cost,int index):x(x),y(y),cost(cost),index(index){}\n};\n\nclass Data{\n        public:\n        int cost;\n        int index;\n        Data(){}\n        Data(int cost,int index):cost(cost),index(index){}\n};\n\nint main(){\n        int m,n;\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                int s;\n                scanf(\"%d\",&s);\n\n                queue< P > Q;\n                int sx[100];\n                int sy[100];\n                for(int i = 0; i < s; i++){\n                        scanf(\"%d%d\",&sx[i],&sy[i]);\n                }\n\n                int t;\n                scanf(\"%d\",&t);\n                int ans = -11000;\n                for(int q = 0; q < t; q++){\n                        int x,y;\n                        Data vis[128][128];\n                        queue< P > Q;\n\n                        for(int i = 0; i < 120; i++){\n                                for(int j = 0; j < 120; j++){\n                                        vis[i][j] = Data(0,0);\n                                }\n                        }\n                        for(int i = 0; i < s; i++){\n                                Q.push(P(sx[i]-1,sy[i]-1,1,i+1));\n                                vis[sx[i]-1][sy[i]-1]=Data(1,i+1);\n                        }\n                        scanf(\"%d%d\",&x,&y);\n                        Q.push(P(x-1,y-1,1,s+1));\n                        vis[x-1][y-1]=Data(1,s+1);\n                        while( Q.size() ){\n                                P p = Q.front();Q.pop();\n                                if(vis[p.x][p.y].cost==-1)continue;\n                                for(int i = 0; i < 6; i++){\n                                        if(p.x+dx[p.y%2][i] < 0 || p.x+dx[p.y%2][i] > m || p.y+dy[p.y%2][i] < 0 || p.y+dy[p.y%2][i] > n)continue;\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost == p.cost+1){\n                                                vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost = -1;\n                                                continue;\n                                        }\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost != 0)continue;\n                                        Q.push(P(p.x+dx[p.y%2][i],p.y+dy[p.y%2][i],p.cost+1,p.index));\n                                        vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]] = Data(p.cost+1,p.index);\n                                }\n\n                        }\n                        int res = 0;\n                        for(int i = 0; i < m; i++){\n                                for(int j = 0; j < n; j++){\n                                        if(vis[i][j].index == s+1 && vis[i][j].cost != -1)res++;\n                                }\n                        }\n                        ans = max(ans,res);\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef long long int ll;\n\nint n, m;\nint dom[6] = {1, 1, 1, 0, -1, 0};\nint don[6] = {-1, 0, 1, -1, 0, 1};\nint dem[6] = {-1, -1, -1, 0, 1, 0};\nint den[6] = {-1, 0, 1, -1, 0, 1};\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\nint solve(int x,int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\n\nint main()\n{\n    while (cin >> m >> n, (n|m)) {\n        int s, t;\n        vector<vector<int> > g(n, vector<int>(m, 0));\n        vector<vector<bool> > pos(n, vector<bool>(m, false));\n        cin >> s;\n        for (int i = 0; i < s; i++) {\n            int x, y;\n            cin >> x >> y;\n            pos[y-1][x-1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                //cout << \"===\" << i << j << \"===\" << endl;\n                g[i][j] = bfs(i, j, g, pos);\n                //cout << g[i][j];\n            }\n            //cout << endl;\n        }\n        cin >> t;\n        int ans = -INF;\n        for (int i = 0; i < t; i++) {\n            int x, y;\n            cin >> x >> y;\n            ans = max(solve(y-1, x-1, g, pos), ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint solve(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0, dist = 0;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front(); a.pop();\n            x = tmp.first; y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (dist < g[x][y]) {\n                ret++;\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n\t                    int nx = x + don[i];\n    \t                int ny = y + dom[i];\n        \t            if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }\n                \t} else {\n\t                    int nx = x + den[i];\n    \t                int ny = y + dem[i];\n        \t            if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }                \t\t\n                \t}\n                }\n            }\n        }\n        a = b;\n        b = c;\n        dist++;\n    }\n    return ret;\n}\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0;\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front();\n            a.pop();\n            x = tmp.first;\n            y = tmp.second;\n            if (pos[x][y]) {\n                return ret;\n            } else {\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n    \t                int nx = x + don[i];\n        \t            int ny = y + dom[i];\n            \t        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t} else {\n    \t                int nx = x + den[i];\n        \t            int ny = y + dem[i];\n            \t        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t}\n                }\n            }\n        }\n        ret++;\n        a = b;\n        b = c;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint fie[101][101];\nint cox[11],coy[11];\nint conx[11],cony[11];\nint m,n,s,sn;\nint ans=0;\nconst int dx1[6]={-1,-1,-1,0,1,0};\nconst int dx2[6]={0,-1,0,1,1,1};\nconst int dy[6]={-1,0,1,-1,0,1};\nconst int INF=100000;\n\nvoid bfs(int x,int y){\n\tqueue<P> que;\n\tque.push(P(x,y));\n\tfie[x][y]=0;\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tint kx=p.first,ky=p.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>fie[kx][ky]+1){\n\t\t\t\t\tque.push(P(fx,fy));\n\t\t\t\t\tfie[fx][fy]=fie[kx][ky]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int x,int y,int fie2[101][101]){\n\tint res=1;\n\tif(fie2[x][y]==0)return 0;\n\tqueue<P> que;\n\tque.push(P(x,y));\n\tfie2[x][y]=0;\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tint kx=p.first,ky=p.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie2[fx][fy]>fie2[kx][ky]+1){\n\t\t\t\t\tque.push(P(fx,fy));\n\t\t\t\t\tres++;\n\t\t\t\t\tfie2[fx][fy]=fie2[kx][ky]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfie[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%d%d\",&cox[i],&coy[i]);\n\t\t\tbfs(cox[i],coy[i]);\n\t\t}\n\t\tscanf(\"%d\",&sn);\n\t\tfor(int i=0;i<sn;i++){\n\t\t\tscanf(\"%d%d\",&conx[i],&cony[i]);\n\t\t\tans=max(ans,bfs2(conx[i],cony[i],fie));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\ntypedef pair<int,pii>piii;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n///#include<sstream>\n///#include<cstring>\n///#include<stack>\n///#include<complex>\n\nconst int dy[6]={-1,-1,0,0,1,1};\nconst int dx[][6]={{-1,0,-1,1,-1,0},{0,1,-1,1,0,1}};\nconst int INF=1e9;\nint W,H;\nint s,t;\nint x[10],y[10];\nint p[10],q[10];\nint nearest[10000];\nvector<int>G[10000];\nvoid getNearest(){\n    fill_n(nearest,H*W,INF);\n    queue<int>Q;\n    rep(i,s){\n        Q.push(y[i]*W+x[i]);\n        nearest[y[i]*W+x[i]]=0;\n    }\n\n    while(!Q.empty()){\n        int pos=Q.front();Q.pop();\n        rep(i,G[pos].size()){\n            int to=G[pos][i];\n            if(nearest[to]!=INF)continue;\n            nearest[to]=nearest[pos]+1;\n            Q.push(to);\n        }\n    }\n}\n\n\nint solve(int start){\n    int dist[10000];\n    queue<int>Q;\n    Q.push(q[start]*W+p[start]);\n    fill_n(dist,H*W,INF);\n    dist[q[start]*W+p[start]]=0;\n    int ret=0;\n    while(!Q.empty()){\n        int pos=Q.front();Q.pop();\n        rep(i,G[pos].size()){\n            int to=G[pos][i];\n            if(dist[to]!=INF)continue;\n            dist[to]=dist[pos]+1;\n            Q.push(to);\n        }\n    }\n\n    rep(i,H*W)if(nearest[i]>dist[i])ret++;\n\n\n    return ret;\n}\nint main(){\n    while(scanf(\"%d%d\",&W,&H),W||H){\n        scanf(\"%d\",&s);\n        rep(i,s){\n            scanf(\"%d%d\",&x[i],&y[i]);\n            x[i]--;y[i]--;\n        }\n        scanf(\"%d\",&t);\n        rep(i,t){\n            scanf(\"%d%d\",&p[i],&q[i]);\n            p[i]--;q[i]--;\n        }\n        rep(i,10000)G[i].clear();\n\n        rep(i,H)rep(j,W){\n            rep(k,6){\n                int ty=i+dy[k],tx=j+dx[i&1][k];\n                if(ty<0||ty>=H||tx<0||tx>=W)continue;\n                G[i*W+j].pb(ty*W+tx);\n            }\n        }\n        getNearest();\n\n        int ma=0;\n\n        rep(i,t)ma=max(ma,solve(i));\n\n        printf(\"%d\\n\",ma);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint fie[101][101];\nbool fie2[101][101];\nint cox[11],coy[11];\nint conx[11],cony[11];\nint m,n,s,sn;\nint ans=0;\nconst int dx1[6]={-1,-1,-1,0,1,0};\nconst int dx0[6]={0,-1,0,1,1,1};\nconst int dy[6]={-1,0,1,-1,0,1};\nconst int INF=100000;\n\nvoid bfs(int x,int y){\n\tqueue<PP> que;\n\tque.push(PP(0,P(x,y)));\n\tfie[x][y]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint v=p.first,kx=p.second.first,ky=p.second.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx0[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>=v+1){\n\t\t\t\t\tque.push(PP(v+1,P(fx,fy)));\n\t\t\t\t\tfie[fx][fy]=v+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int x,int y){\n\tmemset(fie2,false,sizeof(fie2));\n\tint res=1;\n\tif(fie[x][y]==0)return 0;\n\tqueue<PP> que;\n\tque.push(PP(0,P(x,y)));\n\tfie2[x][y]=true;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint v=p.first,kx=p.second.first,ky=p.second.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx0[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>v+1 && fie2[fx][fy]==false){\n\t\t\t\t\tque.push(PP(v+1,P(fx,fy)));\n\t\t\t\t\tres++;\n\t\t\t\t\tfie2[fx][fy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfie[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%d%d\",&cox[i],&coy[i]);\n\t\t\tbfs(cox[i],coy[i]);\n\t\t}\n\t\tscanf(\"%d\",&sn);\n\t\tfor(int i=0;i<sn;i++){\n\t\t\tscanf(\"%d%d\",&conx[i],&cony[i]);\n\t\t\tans=max(ans,bfs2(conx[i],cony[i]));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint fie[101][101];\nint cox[11],coy[11];\nint conx[11],cony[11];\nint m,n,s,sn;\nint ans=0;\nconst int dx1[6]={-1,-1,-1,0,1,0};\nconst int dx2[6]={0,-1,0,1,1,1};\nconst int dy[6]={-1,0,1,-1,0,1};\nconst int INF=100000;\n\nvoid bfs(int x,int y){\n\tqueue<P> que;\n\tque.push(P(x,y));\n\tfie[x][y]=0;\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tint kx=p.first,ky=p.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>fie[kx][ky]+1){\n\t\t\t\t\tque.push(P(fx,fy));\n\t\t\t\t\tfie[fx][fy]=fie[kx][ky]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int x,int y,int fie2[101][101]){\n\tint res=1;\n\tqueue<P> que;\n\tque.push(P(x,y));\n\tfie2[x][y]=0;\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tint kx=p.first,ky=p.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie2[fx][fy]>fie2[kx][ky]+1){\n\t\t\t\t\tque.push(P(fx,fy));\n\t\t\t\t\tfie2[fx][fy]=fie2[kx][ky]+1;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfie[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%d%d\",&cox[i],&coy[i]);\n\t\t\tbfs(cox[i],coy[i]);\n\t\t}\n\t\tscanf(\"%d\",&sn);\n\t\tfor(int i=0;i<sn;i++){\n\t\t\tscanf(\"%d%d\",&conx[i],&cony[i]);\n\t\t\tans=max(ans,bfs2(conx[i],cony[i],fie));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<30)\n\ntypedef pair<int,int> _P;\ntypedef pair<_P,int> P;\n\nint map[100][100];\nbool vst[100][100];\nint dx1[6]={-1,0,1,0,-1,-1},dy1[6]={-1,-1,0,1,1,0};\nint dx2[6]={0,1,1,1,0,-1},dy2[6]={-1,-1,0,1,1,0};\n\nint main() {\n\tint m,n,s,t;\n\twhile(scanf(\"%d\",&m),m) {\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tmap[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<s;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);x--;y--;\n\t\t\tmemset(vst,false,sizeof(vst));\n\t\t\tmap[x][y]=0;\n\t\t\tvst[x][y]=true;\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(_P(x,y),0));\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tint *dx,*dy;\n\t\t\t\tif((p.first.second+1)%2) dx=dx1,dy=dy1;\n\t\t\t\telse dx=dx2,dy=dy2;\n\t\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\t\tint nx=p.first.first+dx[i],ny=p.first.second+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<m&&0<=ny&&ny<n&&!vst[nx][ny]) {\n\t\t\t\t\t\tvst[nx][ny]=true;\n\t\t\t\t\t\tmap[nx][ny]=min(p.second+1,map[nx][ny]);\n\t\t\t\t\t\tque.push(P(_P(nx,ny),p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&t);\n\t\tint ans=0;\n\t\tfor(int i=0;i<t;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);x--;y--;\n\t\t\tmemset(vst,false,sizeof(vst));\n\t\t\tvst[x][y]=true;\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(_P(x,y),0));\n\t\t\tint count=0;\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tint *dx,*dy;\n\t\t\t\tif(p.second<map[p.first.first][p.first.second]) count++;\n\t\t\t\tif((p.first.second+1)%2) dx=dx1,dy=dy1;\n\t\t\t\telse dx=dx2,dy=dy2;\n\t\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\t\tint nx=p.first.first+dx[i],ny=p.first.second+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<m&&0<=ny&&ny<n&&!vst[nx][ny]) {\n\t\t\t\t\t\tvst[nx][ny]=true;\n\t\t\t\t\t\tque.push(P(_P(nx,ny),p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<count) ans=count;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    V.clear();\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( PII( x, y ) ) == V.end() ) {\n            V.insert( PII( x, y ) );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint INF=(1<<24);\nint dy[6]={0,-1,-1,0,1,1};\nint dx[2][6]={\n  {-1,-1,0,1,0,-1},{-1,0,1,1,1,0}\n};\nint W,H,n,m,I;\nint ty[100],tx[100];\nint uy[100],ux[100];\nint v[100][100];\n\nqueue <int> Qy;\nqueue <int> Qx;\nqueue <int> Qcnt;\nqueue <int> Qid;\n\nbool input();\nvoid init(int);\nvoid solve();\nint bfs();\n\nint main(){\n  while(input())solve();\n  return 0;\n}\n\nint bfs(){\n  int y,x,ny,nx,cnt,id,res=0;\n  while(!Qy.empty()){\n    y=Qy.front();Qy.pop();\n    x=Qx.front();Qx.pop();\n    cnt=Qcnt.front();Qcnt.pop();\n    id=Qid.front();Qid.pop();\n\n\n    if(id==n+I)res++;\n\n    for(int i=0;i<6;i++){\n      ny=y+dy[i];\n      nx=x+dx[y%2][i];\n      if(ny<0||nx<0||ny>=H||nx>=W)continue;\n      if(cnt+1>=v[ny][nx])continue; \n      v[ny][nx]=cnt+1;\n      Qy.push(ny);\n      Qx.push(nx);\n      Qcnt.push(cnt+1);\n      Qid.push(id);\n    \n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int ans=0;\n  for(I=0;I<m;I++){\n    init(I);\n    ans=max(ans,bfs());\n  }\n  cout<<ans<<endl;\n}\n\nbool input(){\n  cin>>W>>H;\n  if(W==0&&H==0)return false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>tx[i]>>ty[i];\n    ty[i]--;\n    tx[i]--;\n  }\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>ux[i]>>uy[i];\n    uy[i]--;\n    ux[i]--;\n  }\n  return true;\n}\n\nvoid init(int s){\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      v[i][j]=INF;\n    }\n  }\n  while(!Qy.empty()){\n    Qy.pop();\n    Qx.pop();\n    Qcnt.pop();\n    Qid.pop();\n  }\n  \n\n  for(int i=0;i<n;i++){\n    Qy.push(ty[i]);\n    Qx.push(tx[i]);\n    Qcnt.push(0);\n    Qid.push(i);\n    v[ty[i]][tx[i]]=0;\n  }\n  Qy.push(uy[s]);\n  Qx.push(ux[s]);\n  Qcnt.push(0);\n  Qid.push(n+s);\n  v[uy[s]][ux[s]]=0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\nconst int dy[2][6]={{1,-1,-1,0,-1,0},{1,-1,1,0,0,1}};\nconst int dx[2][6]={{0,0,1,1,-1,-1},{0,0,1,1,-1,-1}};\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        int index;\n        P(){}\n        P(int x,int y,int cost,int index):x(x),y(y),cost(cost),index(index){}\n};\n\nclass Data{\n        public:\n        int cost;\n        int index;\n        Data(){}\n        Data(int cost,int index):cost(cost),index(index){}\n};\n\nint main(){\n        int m,n;\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                int s;\n                scanf(\"%d\",&s);\n\n                queue< P > Q;\n                int sx[100];\n                int sy[100];\n                for(int i = 0; i < s; i++){\n                        scanf(\"%d%d\",&sx[i],&sy[i]);\n                }\n\n                int t;\n                scanf(\"%d\",&t);\n                int ans = -11000;\n                for(int q = 0; q < t; q++){\n                        int x,y;\n                        Data vis[128][128];\n                        queue< P > Q;\n\n                        for(int i = 0; i < 120; i++){\n                                for(int j = 0; j < 120; j++){\n                                        vis[i][j] = Data(0,0);\n                                }\n                        }\n                        for(int i = 0; i < s; i++){\n                                Q.push(P(sx[i]-1,sy[i]-1,1,i+1));\n                                vis[sx[i]-1][sy[i]-1]=Data(1,i+1);\n                        }\n                        scanf(\"%d%d\",&x,&y);\n                        Q.push(P(x-1,y-1,1,s+1));\n                        vis[x-1][y-1]=Data(1,s+1);\n                        while( Q.size() ){\n                                P p = Q.front();Q.pop();\n                                if(vis[p.x][p.y].cost==-1)continue;\n                                for(int i = 0; i < 6; i++){\n                                        if(p.x+dx[p.y%2][i] < 0 || p.x+dx[p.y%2][i] > m || p.y+dy[p.y%2][i] < 0 || p.y+dy[p.y%2][i] > n)continue;\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost == p.cost+1){\n                                                vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost = -1;\n                                                continue;\n                                        }\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost != 0)continue;\n                                        Q.push(P(p.x+dx[p.y%2][i],p.y+dy[p.y%2][i],p.cost+1,p.index));\n                                        vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]] = Data(p.cost+1,p.index);\n                                }\n\n                        }\n                        int res = 0;\n                        for(int i = 0; i < m; i++){\n                                for(int j = 0; j < n; j++){\n                                        if(vis[i][j].index == s+1 && vis[i][j].cost != -1)res++;\n                                }\n                        }\n                        ans = max(ans,res);\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( node ) == V.end() ) {\n            V.insert( node );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[200][200];\nint grid[200][200];\nint grid2[200][200];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 200; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--y][--x] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tif (g[--q][--p]) continue;\n\t\t\tg[q][p] = 1;\n\t\t\tmaxi = max(maxi, solve());\n\t\t\tg[q][p] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\n\nint M, N, S, T;\nint d[2][100][100]; // ??????, ???????¨??????¨\n\n/////////////////////////////////\nint dx[2][6] = { {0,1,0,-1,-1,-1}, {1,1,1,0,-1,0} };\nint dy[6] = {-1,0,1,1,0,-1};\n\nvoid solve(int y, int x) {\n\tqueue<pii> que;\n\tfill(d[1][0], d[2][0], INF);\n\t\n\td[1][y][x] = 0;\n\tque.push(pii(y, x));\n\t\n\twhile (!que.empty()) {\n\t\tpii now = que.front(); que.pop();\n\t\t\n\t\tint y = now.fi, x = now.se;\n\t\tint c = d[1][y][x];\n\t\t\n\t\tREP(i, 6) {\n\t\t\tint xx = x + dx[y & 1][i], yy = y + dy[i];\n\t\t\tif (!(xx >= 0 && xx < M && yy >= 0 && yy < N)) continue;\n\t\t\tif (d[1][yy][xx] <= c + 1) continue;\n\t\t\td[1][yy][xx] = c + 1;\n\t\t\tque.push(pii(yy, xx));\n\t\t}\n\t\t\n\t}\n}\n\nint main() {\n\n\twhile (cin >> M >> N, M || N) {\n\t\t\n\t\tfill(d[0][0], d[2][0], INF);\n\t\t\n\t\tcin >> S;\n\t\tREP(i, S) {\n\t\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\t\tsolve(y - 1, x - 1);\n\t\t\tREP(j, N) REP(k, M) chmin(d[0][j][k], d[1][j][k]);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tcin >> T;\n\t\tREP(i, T) {\n\t\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\t\tsolve(y - 1, x - 1);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tREP(j, N) REP(k, M) if (d[0][j][k] > d[1][j][k]) cnt++;\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint m,n;\nint s,t;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nconst int INF=10000000;\nint field[101][101];\nint field2[101][101];\nint x[11],y[11];\nint nx[11],ny[11];\nint dx1[6]={0,-1,0,1,1,1};\nint dx2[6]={-1,-1,-1,0,1,0};\nint dy[6]={-1,0,1,-1,0,1};\n\nvoid bfs(int sx,int sy){\n\tqueue<PP> que;\n\tque.push(PP(P(sx,sy),0));\n\tfield[sx][sy]=0;\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field[px][py]>c+1){\n\t\t\t\tfield[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int sx,int sy){\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfield2[i][j]=field[i][j];\n\t\t}\n\t}\n\tqueue<PP> que;\n\tint res=1;\n\tif(field2[sx][sy]==0)return 0;\n\tfield2[sx][sy]=0;\n\tque.push(PP(P(sx,sy),0));\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field2[px][py]>c+1){\n\t\t\t\tres++;\n\t\t\t\tfield2[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint ans=0;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfield[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tbfs(x[i],y[i]);\n\t\t}\n\t\tcin >> t;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> nx[i] >> ny[i];\n\t\t\tans=max(ans,bfs2(nx[i],ny[i]));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nstruct NODE{\n\tint x,y,c,num;\n\tNODE(int x,int y,int c) : x(x) , y(y) , c(c) {}\n\tNODE(int x,int y,int c,int num) : x(x) , y(y) , c(c) , num(num) {}\n};\nint W,H;\n\nint doit(vector<NODE> v){\n\tqueue<NODE> Q;\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tQ.push(NODE(v[i].x,v[i].y,0,i));\n\t}\n\tint cnt[100][100]={};\n\tint ans[100][100];\n\tfor(int i = 0 ; i < 100 ; i++)\n\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\tans[i][j] = 1e9;\n\t\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\tint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,1,0,1,1,1} };\n\tint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,0,-1,0,1,-1} };\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( q.x < 0 || q.y < 0 || q.x >= W || q.y >= H ) continue;\n\t\tif( ans[q.y][q.x] < q.c ) continue;\n\t\tif( ans[q.y][q.x] > 10000) {\n\t\t\tans[q.y][q.x] = q.c;\n\t\t\tcnt[q.y][q.x] = (1<<q.num);\n\t\t}else if( ans[q.y][q.x] == q.c ){\n\t\t\tcnt[q.y][q.x] |= (1<<q.num);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0 ; i < 6 ; i++){\n\t\t\tQ.push(NODE(q.x+dx[q.y%2][i],q.y+dy[q.y%2][i],q.c+1,q.num));\n\t\t}\n\t}\n\tint cntt = 0;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tif( cnt[i][j] == (1<<(v.size()-1)) ){\n\t\t\t\tcntt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cntt;\n\t\n}\nint main(){\n\n\twhile(cin >> W >> H && W){\n\t\tint s,N;\n\t\tcin >> s;\n\t\tvector<NODE> alr;\n\t\tfor(int i = 0 ; i < s ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--,y--;\n\t\t\talr.push_back(NODE(x,y,0));\n\t\t}\n\t\tcin >> N;\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--,y--;\n\t\t\talr.push_back(NODE(x,y,0));\n\t\t\tans = max( ans , doit(alr) );\n\t\t\talr.pop_back();\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] < c + 1) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\t//vector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\trep(i, w + 1) rep (j, h + 1) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]/*v[nx][ny] == 1*/) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\t//v[nx][ny] = 1;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[ny][nx] > cost)\n\t{\n\t  Cost[ny][nx] = cost;\n\t  dfs(nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost || Cost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n      if(!visited[ny][nx])\n\tcnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t  \n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n    \n      for(int i=0;i<10000000;i++);\n      scanf(\"%d\",&s);\n\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[y][x] = 0;\n\t  dfs(x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint m, n, s, t;//?¨????????????¢?¨??????????????????°?¨?????????°\nint dis[100][100];//???????¨?\nconst int vx1[6] = { -1,-1,0,1,0,-1 };//?????????????\\???°??¨???????????¶??°??¨\nconst int vx2[6] = { -1,0,1,1,1,0 };//??????????????¶??°??¨??????????\\???°??¨\nconst int vy[6] = { 0,-1,-1,0,1,1 };\nP store[10], plan[10];\n\nvoid bfs() {\n\tqueue<PP> q;//????????????????????§?¨?????????§?¨?\n\tfor (int i = 0; i < s; i++) {\n\t\tq.push(make_pair(0, make_pair(store[i].first, store[i].second)));\n\t\tdis[store[i].first][store[i].second] = -1;//?????§???????????¨?????????-1??¨??????\n\t}\n\twhile (q.size()) {\n\t\tint ct = q.front().first;\n\t\tP tmp = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= m || fx < 0 || fx >= n)continue;\n\t\t\tif (!dis[fy][fx]) {\n\t\t\t\tdis[fy][fx] = ct + 1;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int a) {\n\tint ans = 1;\n\tqueue<PP> q;\n\tq.push(make_pair(0, plan[a]));\n\tbool islook[100][100] = {};\n\tbool f = false;\n\tfor (int i = 0; i < s; i++) {\n\t\tif (plan[a] == store[i])f = true;\n\t}\n\tif (f)return 0;\n\tislook[q.front().second.first][q.front().second.second] = true;\n\twhile (q.size()) {\n\t\tP tmp = q.front().second;\n\t\tint ct = q.front().first;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= m || fx < 0 || fx >= n)continue;\n\t\t\tif (!islook[fy][fx] && dis[fy][fx] - ct > 1) {\n\t\t\t\tans++;\n\t\t\t\tdis[fy][fx] = true;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> m >> n, m * n) {\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tcin >> store[i].second >> store[i].first;\n\t\t\tstore[i].first--, store[i].second--;\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tcin >> plan[i].second >> plan[i].first;\n\t\t\tplan[i].first--, plan[i].second--;\n\t\t}\n\t\tbfs();//?????????????????????????????¢?????¬???\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tans = max(bfs2(i), ans);//??¨????£???°?????????\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)for (int j = 0; j < m; j++)dis[i][j] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\ntypedef pair<int,pii>piii;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n///#include<sstream>\n///#include<cstring>\n///#include<stack>\n///#include<complex>\n\nconst int dy[6]={-1,-1,0,0,1,1};\nconst int dx[][6]={{-1,0,-1,1,-1,0},{0,1,-1,1,0,1}};\nconst int INF=1e9;\nint W,H;\nint s,t;\nint x[10],y[10];\nint p[10],q[10];\nint nearest[10000];\nvector<int>G[10000];\nvoid getNearest(){\n    fill_n(nearest,H*W,INF);\n    queue<int>Q;\n    rep(i,s){\n        Q.push(y[i]*W+x[i]);\n        nearest[y[i]*W+x[i]]=0;\n    }\n\n    while(!Q.empty()){\n        int pos=Q.front();Q.pop();\n        rep(i,G[pos].size()){\n            int to=G[pos][i];\n            if(nearest[to]!=INF)continue;\n            nearest[to]=nearest[pos]+1;\n            Q.push(to);\n        }\n    }\n}\n\n\nint solve(int start){\n    int dist[10000];\n    queue<int>Q;\n    Q.push(q[start]*W+p[start]);\n    fill_n(dist,H*W,INF);\n    dist[q[start]*W+p[start]]=0;\n    int ret=0;\n    while(!Q.empty()){\n        int pos=Q.front();Q.pop();\n        rep(i,G[pos].size()){\n            int to=G[pos][i];\n            if(dist[to]!=INF)continue;\n            dist[to]=dist[pos]+1;\n            Q.push(to);\n        }\n    }\n\n    rep(i,H*W)if(nearest[i]>dist[i])ret++;\n\n\n    return ret;\n}\nint main(){\n    while(scanf(\"%d%d\",&W,&H),W||H){\n        scanf(\"%d\",&s);\n        rep(i,s){\n            scanf(\"%d%d\",&x[i],&y[i]);\n            x[i]--;y[i]--;\n        }\n        scanf(\"%d\",&t);\n        rep(i,t){\n            scanf(\"%d%d\",&p[i],&q[i]);\n            p[i]--;q[i]--;\n        }\n\n        rep(i,H)rep(j,W){\n            rep(k,6){\n                int ty=i+dy[k],tx=j+dx[i&1][k];\n                if(ty<0||ty>=H||tx<0||tx>=W)continue;\n                G[i*W+j].pb(ty*W+tx);\n            }\n        }\n        getNearest();\n\n        int ma=0;\n\n        rep(i,t)ma=max(ma,solve(i));\n\n        printf(\"%d\\n\",ma);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef long long int ll;\n\nint n, m;\nint dom[6] = {1, 1, 1, 0, -1, 0};\nint don[6] = {-1, 0, 1, -1, 0, 1};\nint dem[6] = {-1, -1, -1, 0, 1, 0};\nint den[6] = {-1, 0, 1, -1, 0, 1};\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\nint solve(int x,int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\n\nint main()\n{\n    while (cin >> n >> m, (n|m)) {\n        int s, t;\n        vector<vector<int> > g(n, vector<int>(m, 0));\n        vector<vector<bool> > pos(n, vector<bool>(m, false));\n        cin >> s;\n        for (int i = 0; i < s; i++) {\n            int x, y;\n            cin >> x >> y;\n            pos[y-1][x-1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                //cout << \"===\" << i << j << \"===\" << endl;\n                g[i][j] = bfs(i, j, g, pos);\n                \n            }\n            //cout << endl;\n        }\n        cin >> t;\n        int ans = -INF;\n        for (int i = 0; i < t; i++) {\n            int x, y;\n            cin >> x >> y;\n            ans = max(solve(y-1, x-1, g, pos), ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint solve(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0, dist = 0;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front(); a.pop();\n            x = tmp.first; y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (dist < g[x][y]) {\n                ret++;\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n\t                    int nx = x + don[i];\n    \t                int ny = y + dom[i];\n        \t            if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }\n                \t} else {\n\t                    int nx = x + den[i];\n    \t                int ny = y + dem[i];\n        \t            if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }                \t\t\n                \t}\n                }\n            }\n        }\n        a = b;\n        b = c;\n        dist++;\n    }\n    return ret;\n}\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0;\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front();\n            a.pop();\n            x = tmp.first;\n            y = tmp.second;\n            if (pos[x][y]) {\n                return ret;\n            } else {\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n    \t                int nx = x + don[i];\n        \t            int ny = y + dom[i];\n            \t        if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t} else {\n    \t                int nx = x + den[i];\n        \t            int ny = y + dem[i];\n            \t        if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t}\n                }\n            }\n        }\n        ret++;\n        a = b;\n        b = c;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\n\n/** Problem0193 : Deven-Eleven **/\nint field[100][100];\nint d[100][100];\nbool vis[100][100];\nconst int dx0[6]={0, 1, 1, 1, 0, -1}, dy0[6]={-1, -1, 0, 1, 1, 0};\nconst int dx1[6]={-1, 0, 1, 0, -1, -1}, dy1[6]={-1, -1, 0, 1, 1, 0};\n\nint main()\n{\n\tint n, m, s, t;\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(field[0], field[0]+100*100, -1);\n\t\tfill(d[0], d[0]+100*100, -1);\n\t\t\n\t\tcin >> s;\n\t\trep(k, s) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfield[x-1][y-1] = k;\n\t\t}\n\t\t\n\t\trep(y, n) {\n\t\t\trep(x, m) {\n\t\t\t\tfill(vis[0], vis[0]+100*100, false);\n\t\t\t\tqueue<P> Q;\n\t\t\t\tqueue<int> dis;\n\t\t\t\tif (field[x][y]>=0) continue;\n\t\t\t\t\n\t\t\t\tQ.push(P(x, y));\n\t\t\t\tdis.push(0);\n\t\t\t\tvis[x][y] = true;\n\t\t\t\t\n\t\t\t\twhile (Q.size()) {\n\t\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\t\tint dd = dis.front(); dis.pop();\n\t\t\t\t\t\n\t\t\t\t\tvis[p.first][p.second]=true;\n\t\t\t\t\tif (field[p.first][p.second]>=0) {\n\t\t\t\t\t\td[x][y] = dd;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trep(i, 6) {\n\t\t\t\t\t\t\tint nx, ny;\n\t\t\t\t\t\t\tif (p.second%2==0) {\n\t\t\t\t\t\t\t\tnx = p.first+dx0[i]; ny = p.second+dy0[i];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnx = p.first+dx1[i]; ny = p.second+dy1[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (0<=nx&&nx<m && 0<=ny&&ny<n && !vis[nx][ny]) {\n\t\t\t\t\t\t\t\t//if (p.first != nx && p.second != ny)\n\t\t\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\t\t\tdis.push(dd+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> t;\n\t\tint ans=0;\n\t\t\n\t\trep(k, t) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfill(vis[0], vis[0]+100*100, false);\n\t\t\tqueue<P> Q;\n\t\t\tqueue<int> dis;\n\t\t\tQ.push(P(x, y));\n\t\t\tdis.push(0);\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\twhile (Q.size()) {\n\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\tint dd = dis.front(); dis.pop();\n\t\t\t\tvis[p.first][p.second] = true;\n\t\t\t\t\n\t\t\t\tif (dd!=0 && dd<d[p.first][p.second])\n\t\t\t\t\tcnt++;\n\t\t\t\t\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tif (p.second%2==0) {\n\t\t\t\t\t\tnx = p.first+dx0[i]; ny = p.second+dy0[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnx = p.first+dx1[i]; ny = p.second+dy1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (0<=nx&&nx<m && 0<=ny&&ny<n && !vis[nx][ny]) {\n\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\tdis.push(dd+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint field[110][110],next[110][110];\nint d[6][2] = {{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1}};\nint dd[6][2] = {{1,0},{0,1},{-1,0},{0,-1},{-1,-1},{-1,1}};\nvoid near(int x, int y, int n);\nint coun(int x, int y, int n);\nint main(){\n  int w,h,n,t;\n  while(cin >>w,w){\n    cin >>h;\n    int shop[10][2],kou[10][2];\n    int ans = 0;\n    cin >>n; for(int i=0; i<n; i++){cin >>shop[i][0]>>shop[i][1];}\n    cin >>t; for(int i=0; i<t; i++){cin >>kou[i][0]>>kou[i][1];}\n    for(int i=0; i<110; i++){for(int j=0; j<110; j++){field[j][i] = -1;}}\n    for(int i=1; i<=h; i++){for(int j=1; j<=w; j++){field[j][i] = 100;}}\n    for(int i=0; i<n; i++){near(shop[i][0],shop[i][1],0);}\n    for(int i=0; i<t; i++){\n      for(int k=0; k<110; k++){for(int j=0; j<110; j++){next[j][k] = field[j][k];}}\n      int r = coun(kou[i][0],kou[i][1],0);\n      if(ans<r){ans = r;}\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}\nvoid near(int x, int y, int n){\n  field[x][y] = n;\n  for(int i=0; i<6; i++){\n    if(y%2 == 0){if(field[x+d[i][0]][y+d[i][1]] > n+1){near(x+d[i][0],y+d[i][1],n+1);}}\n    else{if(field[x+dd[i][0]][y+dd[i][1]] > n+1){near(x+dd[i][0],y+dd[i][1],n+1);}}\n  }\n}\nint coun(int x, int y, int n){\n  int k = 1;\n  next[x][y] = n;\n  for(int i=0; i<6; i++){\n    if(y%2 == 0){if(next[x+d[i][0]][y+d[i][1]] > n+1){k+=coun(x+d[i][0],y+d[i][1],n+1);}}\n    else{if(next[x+dd[i][0]][y+dd[i][1]] > n+1){k+=coun(x+dd[i][0],y+dd[i][1],n+1);}}\n  }\n  return k;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint m, n, s, t;//?¨????????????¢?¨??????????????????°?¨?????????°\nint dis[100][100];//???????¨?\nconst int vx1[6] = { -1,-1,0,1,0,-1 };//?????????????\\???°??¨???????????¶??°??¨\nconst int vx2[6] = { -1,0,1,1,1,0 };//??????????????¶??°??¨??????????\\???°??¨\nconst int vy[6] = { 0,-1,-1,0,1,1 };\nP store[10], plan[10];\n\nvoid bfs() {\n\tqueue<PP> q;//????????????????????§?¨?????????§?¨?\n\tfor (int i = 0; i < s; i++) {\n\t\tq.push(make_pair(0, make_pair(store[i].first, store[i].second)));\n\t\tdis[store[i].first][store[i].second] = -1;//?????§???????????¨?????????-1??¨??????\n\t}\n\twhile (q.size()) {\n\t\tint ct = q.front().first;\n\t\tP tmp = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fx = tmp.first, fy = tmp.second;\n\t\t\tif (fx % 2)fy += vx2[i];\n\t\t\telse fy += vx1[i];\n\t\t\tfx += vy[i];\n\t\t\tif (fx < 0 || fx >= n || fy < 0 || fy >= m)continue;\n\t\t\tif (!dis[fx][fy]) {\n\t\t\t\tdis[fx][fy] = ct + 1;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fx, fy)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int a) {\n\tint ans = 1;\n\tqueue<PP> q;\n\tq.push(make_pair(0, plan[a]));\n\tbool islook[100][100] = {};\n\tislook[q.front().second.first][q.front().second.second] = true;\n\twhile (q.size()) {\n\t\tP tmp = q.front().second;\n\t\tint ct = q.front().first;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fx = tmp.first, fy = tmp.second;\n\t\t\tif (fx % 2)fy += vx2[i];\n\t\t\telse fy += vx1[i];\n\t\t\tfx += vy[i];\n\t\t\tif (fx < 0 || fx >= n || fy < 0 || fy >= m)continue;\n\t\t\tif (!islook[fx][fy] && dis[fx][fy] - ct > 1) {\n\t\t\t\tans++;\n\t\t\t\tdis[fx][fy] = true;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fx, fy)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> m >> n , m * n) {\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tcin >> store[i].second >> store[i].first;\n\t\t\tstore[i].first--, store[i].second--;\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tcin >> plan[i].second >> plan[i].first;\n\t\t\tplan[i].first--, plan[i].second--;\n\t\t}\n\t\tbfs();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tans = max(bfs2(i), ans);\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)for (int j = 0; j < m; j++)dis[i][j] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\n\nstruct Data{\n\tint y, x;\n\tbool is_deven;\n\tData(){}\n\tData(int _y, int _x, bool _is_deven){\n\t\ty = _y; x = _x; is_deven = _is_deven;\n\t}\n};\n\nint main(){\n\tint N, M, S, T, X[10], Y[10], P, Q;\n\twhile(cin >> N >> M, N || M){\n\t\tcin >> S;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\t\tcin >> T;\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> P >> Q;\n\t\t\tP--; Q--;\n\n\t\t\tqueue<Data> q;\n\t\t\tData q_front;\n\t\t\tint deven_scope = 0;\n\t\t\tbool used[100][100] = {};\n\n\t\t\tfor(int i = 0; i < S; i++){\n\t\t\t\tq.push( Data(Y[i], X[i], false) );\n\t\t\t}\n\t\t\tq.push( Data(Q, P, true) );\n\n\t\t\twhile( !q.empty() ){\n\t\t\t\tq_front = q.front(); q.pop();\n\t\t\t\tif(used[q_front.y][q_front.x]) continue;\n\t\t\t\tif(q_front.is_deven) deven_scope++;\n\n\t\t\t\tused[q_front.y][q_front.x] = true;\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\t\tint nx = q_front.x + dx[q_front.y&1][i];\n\t\t\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\t\t\t\t\tq.push( Data(ny, nx, q_front.is_deven) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, deven_scope);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[2][6]={{-1,-1,0,0,1,1},{-1,-1,0,0,1,1}};\nint dy[2][6]={{-1,0,-1,1,-1,0},{1,0,-1,1,1,0}};\nint bfs[110][110];\nint m[110][110];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint c;scanf(\"%d\",&c);\n\t\tqueue<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)bfs[i][j]=-1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&q,&p);\n\t\t\tp--;q--;\n\t\t\tbfs[p][q]=0;\n\t\t\tQ.push(make_pair(p,q));\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tint t=row%2;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(0<=row+dx[t][i]&&row+dx[t][i]<a&&0<=col+dy[t][i]&&col+dy[t][i]<b&&!~bfs[row+dx[t][i]][col+dy[t][i]]){\n\t\t\t\t\tbfs[row+dx[t][i]][col+dy[t][i]]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[t][i],col+dy[t][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tint d;scanf(\"%d\",&d);\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&q,&p);p--;q--;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)m[j][k]=-1;\n\t\t\tm[p][q]=0;\n\t\t\tQ.push(make_pair(p,q));\n\t\t\twhile(Q.size()){\n\t\t\t\tint row=Q.front().first;\n\t\t\t\tint col=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tint t=row%2;\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(0<=row+dx[t][j]&&row+dx[t][j]<a&&0<=col+dy[t][j]&&col+dy[t][j]<b&&!~m[row+dx[t][j]][col+dy[t][j]]){\n\t\t\t\t\t\tm[row+dx[t][j]][col+dy[t][j]]=m[row][col]+1;\n\t\t\t\t\t\tQ.push(make_pair(row+dx[t][j],col+dy[t][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)if(bfs[j][k]>m[j][k])val++;\n\t\t\tret=max(val,ret);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int w,h;\n  while(cin>>w&&w){\n    int n;\n    cin>>h>>n;\n    int sx[20],sy[20];\n    for(i=0;i<n;i++){\n      cin>>sx[i]>>sy[i];\n      sx[i]--;\n      sy[i]--;\n    }\n    int m;\n    cin>>m;\n    for(;i<n+m;i++){\n      cin>>sx[i]>>sy[i];\n      sx[i]--;\n      sy[i]--;\n    }\n    unsigned a[100][100][20];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<n+m;i++){\n      queue<pair<pair<int,int>,int> > b;\n      b.push(make_pair(make_pair(sx[i],sy[i]),0));\n      while(b.empty()==0){\n\tint x,y,z;\n\tx=b.front().first.first;\n\ty=b.front().first.second;\n\tz=b.front().second;\n\tb.pop();\n\tif(0<=x&&x<w&&0<=y&&y<h&&a[x][y][i]>(unsigned)z){\n\t  a[x][y][i]=z;\n\t  b.push(make_pair(make_pair(x-1,y),z+1));\n\t  b.push(make_pair(make_pair(x+1,y),z+1));\n\t  if(y%2){\n\t    b.push(make_pair(make_pair(x+1,y+1),z+1));\n\t    b.push(make_pair(make_pair(x,y+1),z+1));\n\t    b.push(make_pair(make_pair(x+1,y-1),z+1));\n\t    b.push(make_pair(make_pair(x,y-1),z+1));\n\t  }else{\n\t    b.push(make_pair(make_pair(x-1,y+1),z+1));\n\t    b.push(make_pair(make_pair(x,y+1),z+1));\n\t    b.push(make_pair(make_pair(x-1,y-1),z+1));\n\t    b.push(make_pair(make_pair(x,y-1),z+1));\n\t  }\n\t}\n      }\n    }\n    unsigned c[100][100];\n    memset(c,-1,sizeof(c));\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tfor(k=0;k<n;k++)\n\t  c[j][i]=min(c[j][i],a[j][i][k]);\n      }\n    }\n    int mx=0;\n    for(i=n;i<n+m;i++){\n      int ct=0;\n      for(j=0;j<h;j++){\n\tfor(k=0;k<w;k++){\n\t  if(a[k][j][i]<c[k][j])\n\t    ct++;\n\t}\n      }\n      mx=max(mx,ct);\n    }\n    cout<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\npublic:\n    int x, y;\n    coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{-1, -1, -1, 0, 1, 0}, {0, -1, 0, 1, 1, 1}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(100, vector<pii>(100, MP(-1, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y; x--; y--;\n\n            if (mp[y][x].scd == 0) continue;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n\n            int cnt = 0;\n\n            rep(i, H) rep(j, W) if (mp[i][j].fst == 0) cnt++;\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n      if(ok)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(cin >> n >> m,(n || m))\n    {\n   \n\n    \n     \n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef long long int ll;\n\nint n, m;\nint dom[6] = {1, 1, 1, 0, -1, 0};\nint don[6] = {-1, 0, 1, -1, 0, 1};\nint dem[6] = {-1, -1, -1, 0, 1, 0};\nint den[6] = {-1, 0, 1, -1, 0, 1};\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\nint solve(int x,int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\n\nint main()\n{\n    while (cin >> m >> n, (n|m)) {\n        int s, t;\n        vector<vector<int> > g(n, vector<int>(m, 0));\n        vector<vector<bool> > pos(n, vector<bool>(m, false));\n        cin >> s;\n        for (int i = 0; i < s; i++) {\n            int x, y;\n            cin >> x >> y;\n            pos[y-1][x-1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                //cout << \"===\" << i << j << \"===\" << endl;\n                g[i][j] = bfs(i, j, g, pos);\n                //cout << g[i][j];\n            }\n            //cout << endl;\n        }\n        cin >> t;\n        int ans = -INF;\n        for (int i = 0; i < t; i++) {\n            int x, y;\n            cin >> x >> y;\n            ans = max(solve(y-1, x-1, g, pos), ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint solve(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0, dist = 0;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front(); a.pop();\n            x = tmp.first; y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (dist < g[x][y]) {\n                ret++;\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n\t                    int nx = x + don[i];\n    \t                int ny = y + dom[i];\n        \t            if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }\n                \t} else {\n\t                    int nx = x + den[i];\n    \t                int ny = y + dem[i];\n        \t            if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }                \t\t\n                \t}\n                }\n            }\n        }\n        a = b;\n        b = c;\n        dist++;\n    }\n    return ret;\n}\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0;\n    queue<i_i> a, b, c;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front();\n            a.pop();\n            x = tmp.first;\n            y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (pos[x][y]) {\n                return ret;\n            } else {\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n    \t                int nx = x + don[i];\n        \t            int ny = y + dom[i];\n            \t        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t} else {\n    \t                int nx = x + den[i];\n        \t            int ny = y + dem[i];\n            \t        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t}\n                }\n            }\n        }\n        ret++;\n        a = b;\n        b = c;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int dys[] = {-1, -1, 0, 0, 1, 1};\n    int dx_odd[] = {-1, 0, -1, 1, -1, 0};\n    int dx_even[] = {0, 1, -1, 1, 0, 1};\n    int n, m;\n    while(cin >> m >> n, m){\n        vector<vector<int>> v(n+2, vector<int>(m+2, -1));\n        auto ddist = v;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                v[i+1][j+1] = 0;\n                ddist[i+1][j+1] = INF<int>;\n            }\n        }\n        int s;\n        cin >> s;\n        vector<int> ys(s), xs(s);\n        for (int i = 0; i < s; ++i) {\n            cin >> xs[i] >> ys[i];\n        }\n        int ans = 0;\n        int q;\n        cin >> q;\n        for (int i = 0; i < q; ++i) {\n            int xx, yy;\n            cin >> xx >> yy;\n            ys.emplace_back(yy);\n            xs.emplace_back(xx);\n            auto vv = v, dist = ddist;\n            queue<pair<int, int>> Q;\n            for (int j = 0; j < ys.size(); ++j) {\n                Q.emplace(ys[j], xs[j]);\n                vv[ys[j]][xs[j]] = j+1;\n                dist[ys[j]][xs[j]] = 0;\n            }\n            while(!Q.empty()){\n                int y, x; tie(y, x) = Q.front(); Q.pop();\n                for (int k = 0; k < 6; ++k) {\n                    int ya = y + dys[k], xa = x + (y&1 ? dx_odd :dx_even)[k];\n                    if(!~v[ya][xa]) continue;\n                    if(dist[ya][xa] > dist[y][x]+1){\n                        dist[ya][xa] = dist[y][x]+1;\n                        vv[ya][xa] = vv[y][x];\n                        Q.emplace(ya, xa);\n                    }else if(dist[ya][xa] == dist[y][x]+1) {\n                        if(vv[ya][xa] != vv[y][x]){\n                            vv[ya][xa] = -1;\n                        }\n                    }\n                }\n            }\n            int val = 0;\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < m; ++k) {\n                    val += (vv[j+1][k+1] == ys.size());\n                    // cout << vv[j+1][k+1] << \" \";\n                }\n                // puts(\"\");\n            }\n            ans = max(ans, val);\n            ys.pop_back();\n            xs.pop_back();\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dist(int x1,int y1,int x2,int y2)\n{\n\tif(y1>y2){\n\t\tswap(x1,x2);\n\t\tswap(y1,y2);\n\t}\n\t\n\tint dy=y2-y1;\n\tif(y1&1)\n\t\treturn max(max(x2-x1-dy/2,x1-x2-(dy+1)/2),0)+dy;\n\telse\n\t\treturn max(max(x2-x1-(dy+1)/2,x1-x2-dy/2),0)+dy;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h;){\n\t\tint s; cin>>s;\n\t\tvector<int> xs(s),ys(s);\n\t\tfor(int i=0;i<s;i++)\n\t\t\tcin>>xs[i]>>ys[i];\n\t\tint t; cin>>t;\n\t\tint res=0;\n\t\twhile(t--){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tint tmp=0;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tint d=1<<29;\n\t\t\t\t\tfor(int k=0;k<s;k++)\n\t\t\t\t\t\td=min(d,dist(xs[k],ys[k],j,i));\n\t\t\t\t\tif(d>dist(x,y,j,i))\n\t\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(tmp,res);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\n    public:\n        int x, y;\n        coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{0, -1, 0, 1, 1, 1}, {-1, -1, -1, 0, 1, 0}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(H + 1);\n        fill(all(mp), vector<pii>(W + 1, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint n,m;\nint s,t;\npii ps[101];\n// »ê¼êÌÀW©çêÔß¢RrjÖÌ£\nint dists[101][101];\nconst int INF=1000000000;\npii cand[101];\nbool used[101][101];\nbool noSet[101][101];\n\nconst int dy[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\nconst int dx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}};\n\nint updateMinDist(int sx,int sy,bool isSearch=true){\n    memset(used,0,sizeof(used));\n    queue<pii> q[2];\n    int cur=0;\n    int nxt=1;\n    int cnt=0;\n    pii sp=pii(sy,sx);\n    used[sy][sx]=true;\n    dists[sy][sx]=0;\n    int res=1;\n    q[cur].push(sp);\n    while(q[cur].size()){\n        while(q[cur].size()){\n            pii p=q[cur].front();q[cur].pop();\n            for(int i=0;i<6;i++){\n                int ny=dy[p.first%2][i]+p.first;\n                int nx=dx[p.first%2][i]+p.second;\n                if(ny>=0&&nx>=0&&ny<n&&nx<m&&!used[ny][nx]){\n                    used[ny][nx]=true;\n                    q[nxt].push(pii(ny,nx));\n                    if(isSearch)dists[ny][nx]=min(dists[ny][nx],cnt+1);\n                    else if(dists[ny][nx]>cnt+1)res++;\n                }\n            }\n        }\n        cnt++;\n        swap(cur,nxt);\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>m>>n&&(m|n)){\n        memset(noSet,0,sizeof(noSet));\n        cin>>s;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dists[i][j]=INF;\n        for(int i=0;i<s;i++){\n            cin>>ps[i].second>>ps[i].first;\n            ps[i].second--;\n            ps[i].first--;\n            noSet[ps[i].first][ps[i].second]=true;\n        }\n        for(int k=0;k<s;k++)updateMinDist(ps[k].second,ps[k].first);\n        cin>>t;\n        for(int i=0;i<t;i++){\n            cin>>cand[i].second>>cand[i].first;\n            cand[i].second--;\n            cand[i].first--;\n        }\n        int res=0;\n        for(int i=0;i<t;i++){\n            int cnt=0;\n            cnt=updateMinDist(cand[i].second,cand[i].first,false);\n            res=max(res,cnt);\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x-1,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y % 2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[101][101];\nint id_list[101][101];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    min_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  int candidate_cost[101][101];\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    candidate_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint dxo[6] = { -1,  0, -1, 1, -1, 0};\nint dxe[6] = { 0,  1, -1, 1, 0, 1};\nint dy[6] = {-1, -1,  0, 0,  1, 1}; \n\nstruct node { int x, y, dist, num; };\n\nconst int INF = 1000000009;\nconst int MAX_N = 101;\nconst int MAX_S = 11;\nint n, m, s, t;\nint cx[MAX_S], cy[MAX_S], tx[MAX_S], ty[MAX_S];\nint field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\nchar used[MAX_N][MAX_N];\n\nint bfs(int x, int y) {\n\trep(j,n) rep(i,m) used[i][j] = 0;\n\n\tint res = 0;\n\tqueue<node> que;\n\tnode md = {x, y, 0, -1};\n\tque.push(md);\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\tif(dist[nd.x][nd.y] <= nd.dist) continue;\n\n\t\tused[nd.x][nd.y] = 1;\n\t\tres++;\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n && used[xx][yy] == 0) {\n\t\t\t\tnode nnd = {xx, yy, nd.dist+1, -1};\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\trep(y,n) {\n\t\trep(x,m) {\n\t\t\tfield[x][y] = 0;\n\t\t\tdist[x][y] = INF;\n\t\t}\n\t}\n\n\tqueue<node> que;\n\trep(i,s) {\n\t\tnode nd = { cx[i]-1, cy[i]-1, 0, i+1 };\n\t\tfield[cx[i]-1][cy[i]-1] = i+1;\n\t\tdist[cx[i]-1][cy[i]-1] = 0;\n\t\tque.push(nd);\n\t}\n\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tif(dist[xx][yy] > nd.dist + 1) {\n\t\t\t\t\tdist[xx][yy] = nd.dist + 1;\n\t\t\t\t\tfield[xx][yy] = nd.num;\n\t\t\t\t} else if(dist[xx][yy] == nd.dist + 1 && field[xx][yy] != nd.num) {\n\t\t\t\t\tfield[xx][yy] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnode nnd = { xx, yy, nd.dist+1, nd.num };\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxval = 0;\n\trep(i,t) {\n\t\tint res = bfs(tx[i]-1, ty[i]-1);\n\t\tmaxval = max(res, maxval);\n\t}\n\tprintf(\"%d\\n\", maxval);\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) break;\n\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &s);\n\t\trep(i,s) scanf(\"%d%d\", &cx[i], &cy[i]);\n\n\t\tscanf(\"%d\", &t);\n\t\trep(i,t) scanf(\"%d%d\", &tx[i], &ty[i]);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[110][110];\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[ny][nx] > cost)\n\t{\n\t  Cost[ny][nx] = cost;\n\t  dfs(nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost || Cost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n      if(!visited[ny][nx])\n\tcnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t  \n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n    \n      for(int i=0;i<10000000;i++);\n      scanf(\"%d\",&s);\n\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[y][x] = 0;\n\t  dfs(x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n\nusing namespace std;\nconst int N = 100;\nconst int INF = 100000000;\ntypedef pair<int, int> P;\n\nclass State{\npublic:\n  int x, y, cost;\n  State(int y, int x, int cost) : y(y), x(x), cost(cost) {}\n};\n\nint w, h, s, t;\nint dist[11][N][N];\nint dy[2][6] = {{-1, -1, 0, 1, 1, 0},{-1, -1, 0, 1, 1, 0}};\nint dx[2][6] = {{-1, 0, 1, 0, -1, -1},{0, 1, 1, 1, 0, -1}};\nvector<P> cs;\n\nvoid bfs(int sy, int sx, int p){\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) dist[p][i][j] = INF;\n  queue<State> que;\n  que.push(State(sy, sx, 0));\n  dist[p][sy][sx] = 0;\n  while(!que.empty()){\n    State u = que.front(); que.pop();\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[u.y%2][i];\n      int nx = u.x + dx[u.y%2][i];\n      if(ny<0 || ny>=h) continue;\n      if(nx<0 || nx>=w) continue;\n      if(dist[p][ny][nx] != INF) continue;\n      dist[p][ny][nx] = u.cost+1;\n      que.push(State(ny, nx, u.cost+1));\n    }\n   }\n}\n\nint solve(){\n  int res = 0;\n  bfs(cs[s].first, cs[s].second, s);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      bool f = false;\n      int valm = INF, col;\n      for(int k=0;k<=s;k++){\n        if(valm > dist[k][i][j]){\n          f = false;\n          valm = dist[k][i][j];\n          col = k;\n        }else if(valm == dist[k][i][j]) f = true;\n      }\n      if(!f && col == s) res++;\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    cs.clear();\n    int x, y;\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      cs.push_back(P(y-1, x-1));\n    }\n    for(int i=0;i<cs.size();i++) bfs(cs[i].first, cs[i].second, i);\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      cs.push_back(P(y-1, x-1));\n      ans = max(ans, solve());\n      cs.pop_back();\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define ABS(n) (n<0?-(n):(n))\n\n#define INF (1<<20)\nint field[128][128];\n\nint dist(int x1, int y1, int x2, int y2)\n{\n\tx1-=(y1-1)/2;\n\tx2-=(y2-1)/2;\n\n\treturn (ABS(x1-x2)+ABS(y1-y2)+ABS((x1+y1)-(x2+y2)))/2;\n}\n\nint main()\n{\n\tint w,h,n,x0,y0,cnt,ans;\n\twhile(cin >> w, w)\n\t{\n\t\tcin >> h;\n\t\tfor(int y=1; y<=h; y++)\n\t\tfor(int x=1; x<=w; x++)\n\t\t{\n\t\t\tfield[y][x] = INF;\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> x0 >> y0;\n\t\t\tfor(int y=1; y<=h; y++)\n\t\t\tfor(int x=1; x<=w; x++)\n\t\t\t{\n\t\t\t\tfield[y][x] = min(field[y][x],dist(x0,y0,x,y));\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcnt = 0;\n\t\t\tcin >> x0 >> y0;\n\t\t\tfor(int y=1; y<=h; y++)\n\t\t\tfor(int x=1; x<=w; x++)\n\t\t\t{\n\t\t\t\tif(field[y][x]>dist(x0,y0,x,y)) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct st { int x, y, c; };\nint d[100][100], b[100][100], x[11], y[11];\nint dx[][6]{ { 0,-1,0,1,1,1, },{ -1,-1,-1,0,1,0 } };\nint dy[]{ -1,0,1,1,0,-1 };\nint main() {\n\tint m, n, s;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tscanf(\"%d\", &s);\n\t\trep(i, s)scanf(\"%d%d\", &x[i], &y[i]), x[i]--, y[i]--;\n\t\tint t; scanf(\"%d\", &t);\n\t\tint Max = 0;\n\t\trep(i, t) {\n\t\t\tscanf(\"%d%d\", &x[s], &y[s]); x[s]--; y[s]--;\n\t\t\tqueue<st>que;\n\t\t\tmemset(d, -1, sizeof(d));\n\t\t\trep(j, s + 1) {\n\t\t\t\td[x[j]][y[j]] = 0; b[x[j]][y[j]] = j;\n\t\t\t\tque.push({ x[j],y[j],j });\n\t\t\t}\n\t\t\twhile (!que.empty()) {\n\t\t\t\tst p = que.front(); que.pop();\n\t\t\t\trep(j, 6) {\n\t\t\t\t\tint nx = p.x + dx[!(p.y & 1)][j], ny = p.y + dy[j];\n\t\t\t\t\tif (0 <= nx&&nx < m && 0 <= ny&&ny < n) {\n\t\t\t\t\t\tif (d[nx][ny] == -1) {\n\t\t\t\t\t\t\td[nx][ny] = d[p.x][p.y] + 1;\n\t\t\t\t\t\t\tb[nx][ny] = p.c;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (d[nx][ny] == d[p.x][p.y] + 1) {\n\t\t\t\t\t\t\tb[nx][ny] = -1;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\trep(i, m)rep(j, n) {\n\t\t\t\tif (b[i][j] == s)cnt++;\n\t\t\t}\n\t\t\tMax = max(Max, cnt);\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nint getdis(const pair<int, int>l, const pair<int, int>r) {\n\n\tint dy =r.second - l.second;\n\tint dx =r.first - l.first;\n\tif (l.second % 2 == r.second % 2) {\n\t\tassert(abs(dy) % 2 == 0);\n\t\tif (abs(dx) <= abs(dy) / 2)return abs(dy);\n\t\telse {\n\t\t\treturn  abs(dy) + (abs(dx) - abs(dy) / 2);\n\t\t}\n\t}\n\telse if (l.second % 2==0 && r.second % 2 == 1) {\n\t\t{\n\t\t\tint amin = 1e8;\n\t\t\tint y = l.second > r.second ? -1 : 1;\n\t\t\tfor (int x = -1; x <= 0; ++x) {\n\t\t\t\tamin = min(amin, 1 + getdis(make_pair(l.first + x, l.second + y), r));\n\t\t\t}\n\t\t\t\n\t\t\treturn amin;\n\t\t}\n\t}\n\telse {\n\t\t{\n\t\t\tint amin = 1e8;\n\t\t\tint y = l.second > r.second ? -1 : 1;\n\t\t\tfor (int x = 0; x <= 1; ++x) {\n\t\t\t\tamin = min(amin, 1 + getdis(make_pair(l.first + x, l.second + y), r));\n\t\t\t\n\t\t\t}\n\t\t\treturn amin;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W, 100000));\n\t\tint S; cin >> S;\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tint x, y; cin >> x >> y; x--; y--;\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tfield[j][k] = min(field[j][k], getdis(make_pair(x, y), make_pair(k, j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint T; cin >> T;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < T; ++i) {\n\t\t\tint p, q; cin >> p >> q; p--; q--;\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (field[j][k] > getdis(make_pair(p,q), make_pair(k, j)))sum++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,0,0,1,1,1} };\nint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,1,-1,0,1,-1} };\n\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        P(){}\n        P(int x,int y,int cost):x(x),y(y),cost(cost){}\n};\n\nint m,n,s;\nint field[128][128];\nint cp[128][128];\nint res;\n\nvoid bfs(int x,int y,int index){\n        bool vis[128][128]={{0}};\n        queue< P > Q;\n        Q.push(P(x,y,1));\n        field[x][y] = 1;\n        res = 0;\n        while( Q.size() ){\n                P p = Q.front();Q.pop();\n                for(int i = 0; i < 6; i++){\n                        int nx = p.x+dx[p.y%2][i];\n                        int ny = p.y+dy[p.y%2][i];\n                        if(vis[p.x][p.y]++)continue;\n                        if(nx < 0 || nx > m-1 || ny < 0 || ny > n-1)continue;\n                        if(field[nx][ny] > p.cost+1){\n                                field[nx][ny] = p.cost+1;\n                                if(index == s+1){\n                                        res++;\n                                }\n                                Q.push(P(nx,ny,p.cost+1));\n                        }\n                        else if(field[nx][ny] == p.cost+1){\n                                field[nx][ny] = -1;\n                        }\n                }\n        }\n        return ;\n}\nvoid init(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        cp[i][j] = field[i][j];\n                }\n        }\n}\n\nvoid copy(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        field[i][j] = cp[i][j];\n                }\n        }\n}\n\nvoid output(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        printf(\"%3d\",field[i][j]);\n                }\n                puts(\"\");\n        }\n        return ;\n}\nint main(){\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                scanf(\"%d\",&s);\n\n                for(int i = 0; i < 120; i++){\n                        for(int j = 0; j < 120; j++){\n                                field[i][j] = 99;\n                        }\n                }\n\n                for(int i = 0; i < s; i++){\n                        int x,y;\n                        scanf(\"%d%d\",&x,&y);\n                        x--;y--;\n                        //output();\n                        bfs(x,y,i+1);\n                }\n                int t;\n                scanf(\"%d\",&t);\n                init();\n                int ans = -10000;\n                for(int i = 0; i < t; i++){\n                        int x,y;\n                        scanf(\"%d%d\",&x,&y);\n                        x--;y--;\n                        bfs(x,y,s+1);\n                        //output();\n                        ans = max(res,ans);\n                        copy();\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1, -1, 0, 1, 0, -1}, {-1, 0, 1, 1, 1, 0}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n      if(ok)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n    \n     \n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint m,n;\nint s,t;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nconst int INF=10000000;\nint field[101][101];\nint x[11],y[11];\nint nx[11],ny[11];\nint dx1[6]={0,-1,0,1,1,1};\nint dx2[6]={-1,-1,-1,0,1,0};\nint dy[6]={-1,0,1,-1,0,1};\n\nvoid bfs(int sx,int sy){\n\tqueue<PP> que;\n\tque.push(PP(P(sx,sy),0));\n\tfield[sx][sy]=0;\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field[px][py]>c+1){\n\t\t\t\tfield[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int sx,int sy,int field2[101][101]){\n\tqueue<PP> que;\n\tint res=1;\n\tif(field2[sx][sy]==0)return 0;\n\tque.push(PP(P(sx,sy),0));\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field2[px][py]>c+1){\n\t\t\t\tres++;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint ans=0;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfield[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tbfs(x[i],y[i]);\n\t\t}\n\t\tcin >> t;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> nx[i] >> ny[i];\n\t\t\tans=max(ans,bfs2(nx[i],ny[i],field));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nvoid bfs(int sx, int sy, int d[111][111]){\n  const int W = 110;\n  const int H = 110;\n  REP(y, H) REP(x, W) d[y][x] = INF;\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  d[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    if(y % 2 == 1){\n      int dx[6] = {-1, 0, 1, 0, -1, -1};\n      int dy[6] = {-1, -1, 0, 1, 1, 0};\n      REP(r, 6) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && d[ny][nx] > d[y][x] + 1){\n          d[ny][nx] = d[y][x] + 1;\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }else{\n      int dx[6] = {0, 1, 1, 1, 0, -1};\n      int dy[6] = {-1, -1, 0, 1, 1, 0};\n      REP(r, 6) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && d[ny][nx] > d[y][x] + 1){\n          d[ny][nx] = d[y][x] + 1;\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int W, H;\n  while(cin >> W >> H && W){\n    int N;\n    int tx[10], ty[10];\n    cin >> N;\n    REP(i, N) cin >> tx[i] >> ty[i];\n    int dist[11][111][111];\n    REP(i, N){\n      bfs(tx[i], ty[i], dist[i]);\n    }\n    int ans = 0;\n    int M; cin >> M;\n    REP(i, M){\n      int nx, ny; cin >> nx >> ny;\n      bfs(nx, ny, dist[N]);\n      int cnt = 0;\n      REP(y, H)REP(x, W){\n        //printf(\"nx = %d ny = %d x = %d y = %d dist %d\\n\", nx, ny, x + 1, y + 1, dist[N][y + 1][x + 1]);\n        bool ok = true;\n        REP(j, N) if(dist[N][y + 1][x + 1] >= dist[j][y + 1][x + 1]) ok = false;\n        if(ok) cnt++;\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint main() {\n  while (true){\n    int w,h,s,ans=1;\n    vector<int> adx={0,0,1,1,1,-1},ady={-1,1,1,-1,0,0};\n    vector<int> bdx={0,0,-1,-1,-1,1},bdy={-1,1,0,1,-1,0};\n    queue<pair<pair<int,int>,int>> q;\n    pair<pair<int,int>,int> v;\n    cin >> w >> h;\n    if (w==0 && h==0) break;\n    cin >> s;\n    vector<vector<int>> a(w+2,vector<int>(h+2));\n    rep(i,h+2){\n      rep(j,w+2){\n        a.at(j).at(i)=1;\n      }\n    }\n    for (int i=1;i<h+1;i++){\n      for (int j=1;j<w+1;j++){\n        a.at(j).at(i)=0;\n      }\n    }\n    vector<int> e(s),r(s);\n  rep (i,s){\n    cin >> e.at(i) >> r.at(i);\n  }\n  int u;\n  cin >> u;\n  rep(i,u){\n    rep(i,h+2){\n      rep(j,w+2){\n        a.at(j).at(i)=1;\n      }\n    }\n    for (int i=1;i<h+1;i++){\n      for (int j=1;j<w+1;j++){\n        a.at(j).at(i)=0;\n      }\n    }\n      rep (p,s){\n    a.at(e.at(p)).at(r.at(p))=1;\n    v.first.first=e.at(p);v.first.second=r.at(p);\n    v.second=0;\n    q.push(v);\n  }\n    int xx,yy,o=1;\n    cin >> xx >> yy;\n    v.first.first=xx;v.first.second=yy;v.second=1;\n    a.at(xx).at(yy)=1;\n    q.push(v);\n    while (!q.empty()){\n      int x=q.front().first.first,y=q.front().first.second,t=q.front().second;\n      q.pop();\n      for (int j=0;j<6;j++){\n        if (y%2==0){\n        if (a.at(x+adx.at(j)).at(y+ady.at(j))==0) {\n          a.at(x+adx.at(j)).at(y+ady.at(j))=1;\n          v.first.first=x+adx.at(j);v.first.second=y+ady.at(j);v.second=t;\n          q.push(v);\n          if (t==1)  o++;\n        }\n        }\n        if (y%2==1){\n        if (a.at(x+bdx.at(j)).at(y+bdy.at(j))==0) {\n          a.at(x+bdx.at(j)).at(y+bdy.at(j))=1;\n          v.first.first=x+bdx.at(j);v.first.second=y+bdy.at(j);v.second=t;\n          q.push(v);\n          if (t==1) o++;\n        }\n        }\n      }\n    }\n    ans=max(ans,o);\n  }\n  cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n\nconst int INF = 1 << 24;\n\nstruct P{\n\tint x, y;\n};\n\ntypedef std::pair<P, int> State;\n\nstd::vector<P> getPointYouCanGo(int x, int y){\n\tif(y % 2 == 0){//even\n\t\t\treturn {{x-1, y-1}, {x-1, y}, {x-1, y+1}, {x, y-1}, {x, y+1}, {x+1, y}};\n\t}else{//odd\n\t\treturn {{x-1, y}, {x, y-1}, {x, y+1}, {x+1, y-1}, {x+1, y}, {x+1, y+1}};\n\t}\n}\n\ntemplate<class T>\nstd::vector<T> filter(const std::vector<T> v, std::function<bool(T)> cond){\n\tstd::vector<T> result;\n\tfor(auto e : v){\n\t\tif(cond(e)){\n\t\t\tresult.push_back(e);\n\t\t}\n\t}\n\treturn result;\n}\n\nint map[2][100][100], m, n;\n\nvoid initializeMap0(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmap[0][i][j] = -1;\n\t\t}\n\t}\n}\n\nvoid createMap(int x, int y){\n\tstd::queue<State> sv;\n\tmap[0][x][y] = 0;\n\tsv.push(std::make_pair(P{x, y}, 0));\n\t\n\twhile(!sv.empty()){\n\t\tState s = sv.front(); sv.pop();\n\t\tP begin_p = s.first;\n\t\tint count = s.second;\n\n\t\tstd::vector<P> pv = filter<P>(getPointYouCanGo(begin_p.x, begin_p.y), [](P p) -> bool{\n\t\t\t\treturn 0 <= p.x && p.x < n && 0 <= p.y && p.y < m;\n\t\t\t});\n\n\t\tfor(const P p : pv){\n\t\t\tif(map[0][p.x][p.y] == -1){\n\t\t\t\tmap[0][p.x][p.y] = count + 1;\n\t\t\t\tsv.push(std::make_pair(p, count+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid update(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmap[1][i][j] = std::min(map[1][i][j], map[0][i][j]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint s, t;\n\n\twhile(std::cin >> m >> n, m){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tfor(int k=0;k<100;k++){\n\t\t\t\tmap[1][j][k] = INF;\n\t\t\t}\n\t\t}\n\n\t\tstd::cin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\tinitializeMap0();\n\t\t\tcreateMap(x-1, y-1);\n\t\t\tupdate();\n\t\t}\n\n\t\tint maximumBlocks = 0;\n\t\tstd::cin >> t;\n\t\tfor(int k=0;k<t;k++){\n\t\t\tint x, y, blocks = 0;\n\t\t\tstd::cin >> x >> y;\n\t\t\tinitializeMap0();\n\t\t\tcreateMap(x-1, y-1);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tif(map[0][i][j] < map[1][i][j] && map[1][i][j] != 0){//win\n\t\t\t\t\t\tblocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximumBlocks = std::max(maximumBlocks, blocks);\n\t\t}\n\n\t\tstd::cout << maximumBlocks << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint fie[101][101];\nint cox[11],coy[11];\nint conx[11],cony[11];\nint m,n,s,sn;\nint ans=0;\nconst int dx1[6]={-1,-1,-1,0,1,0};\nconst int dx2[6]={0,-1,0,1,1,1};\nconst int dy[6]={-1,0,1,-1,0,1};\nconst int INF=100000;\n\nvoid bfs(int x,int y){\n\tqueue<P> que;\n\tque.push(P(x,y));\n\tfie[x][y]=0;\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tint kx=p.first,ky=p.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>fie[kx][ky]+1){\n\t\t\t\t\tque.push(P(fx,fy));\n\t\t\t\t\tfie[fx][fy]=fie[kx][ky]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int x,int y,int fie2[101][101]){\n\tint res=1;\n\tif(fie2[x][y]==0)return 0;\n\tqueue<P> que;\n\tque.push(P(x,y));\n\tfie2[x][y]=0;\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tint kx=p.first,ky=p.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie2[fx][fy]>fie2[kx][ky]+1){\n\t\t\t\t\tque.push(P(fx,fy));\n\t\t\t\t\tres++;\n\t\t\t\t\tfie2[fx][fy]=fie2[kx][ky]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfie[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%d%d\",&cox[i],&coy[i]);\n\t\t\tbfs(cox[i],coy[i]);\n\t\t}\n\t\tscanf(\"%d\",&sn);\n\t\tfor(int i=0;i<sn;i++){\n\t\t\tscanf(\"%d%d\",&conx[i],&cony[i]);\n\t\t\tans=max(ans,bfs2(conx[i],cony[i],fie));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[2][6] = { {0, -1, -1, -1, 0, 1}, {1, 0, -1, 0, 1, 1} };\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\n\nclass State\n{\npublic:\n  int x, y, c;\n  State(int _x = 0, int _y = 0, int _c = 0)\n    :x(_x), y(_y), c(_c) {}\n};\n\nint main()\n{\n  int m, n;\n  while (cin >> m >> n) {\n    if ((m|n) == 0)\n      break;\n\n    int s;\n    cin >> s;\n    vector<vector<int> > cost(n, vector<int>(m, INF));\n    for (int i = 0; i < s; ++i) {\n      int x, y;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] < st.c)\n\t  continue;\n\n\tcost[st.y][st.x] = st.c;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] < st.c+1)\n\t    continue;\n\t  cost[y][x] = st.c+1;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n    }\n\n    int t;\n    cin >> t;\n    int ans = 0;\n    for (int i = 0; i < t; ++i) {\n      int x, y, cnt = 0;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1));\n      vector<vector<int> > visited(n, vector<int>(m, 0));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] <= st.c || visited[st.y][st.x])\n\t  continue;\n\n\t++cnt;\n\tvisited[st.y][st.x] = 1;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] <= st.c+1 || visited[y][x])\n\t    continue;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n      ans = max(ans, cnt);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define LEN 100\n#define MAX 255\nunsigned char map[LEN+2][LEN+2];\nunsigned char chk[LEN+2][LEN+2];\nunsigned char dis[LEN+2][LEN+2];\nbool now[LEN][LEN];\n\nint m,n;\n\nint edx[6] = { -1, 1, 0, 1, 0, 1 };\nint odx[6] = { -1, 1, -1, 0, -1, 0};\nint dy[6] = { 0, 0, 1, 1, -1, -1};\n\nvoid fill( int y, int x, int d, int p ) {\n\n\tif ( y < 0 || y > n || x < 0 || x > m )\n\t\treturn;\n\n\tif ( chk[y][x] == MAX ) {\n\t\tif ( dis[y][x] > d ) {\n\t\t\tchk[y][x] = p;\n\t\t\tdis[y][x] = d;\n\t\t} \n\t}\n\telse {\n\t\tif ( chk[y][x] == 0 ) {\n\t\t\t//\t\t\tcout << \"Start\" << y << \"\\t\" <<  x << endl;\n\t\t\tchk[y][x] = p;\n\t\t\tdis[y][x] = d;\n\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t} else\n\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t}\n\t\t} else if ( chk[y][x] == p ) {\n\t\t\tif ( dis[y][x] > d ) {\n\t\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tif ( dis[y][x] > d ) {\n\t\t\t\t//\t\t\t\tcout << \"Do\" << y << \"\\t\" <<  x << endl;\n\t\t\t\tchk[y][x] = p;\n\t\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( dis[y][x] == d ) {\n\t\t\t\t//\t\t\t\tcout << \"Here \" << y << \"\\t\" << x << endl;\n\t\t\t\tchk[y][x] = MAX;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint count = 0;\n\nvoid find ( int y, int x, int d ) {\n\n\tif ( y < 0 || y > n || x < 0 || x > m )\n\t\treturn;\n\n\t//\tcout << \"Do\" << y << \"\\t\" <<  x << endl;\n\n\tif ( now[y][x] ) {\n\t\tnow[y][x] = false;\n\t\t//\t\tcout << \"Get\\n\";\n\t\tif ( dis[y][x] > d ) {\n\t\t\tcount++;\n\n\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\tif ( y%2 == 1 )\n\t\t\t\t\tfind( y+dy[i], x+edx[i], d+1 );\n\t\t\t\telse\n\t\t\t\t\tfind( y+dy[i], x+odx[i], d+1 );\n\t\t\t}\n\n\t\t}\n\t}\n}\n\t\n\nint counting ( int y, int x ) {\n\t//\tcout << \"Start\\n\" << endl;\n\tcount = 1;\n\tnow[y][x] = false;\n\n\tmemset ( now, true, (LEN*LEN)*sizeof(bool));\n\n\tfind( y, x, 0 );\n\n\treturn count;\n}\n\nint main () {\n\n\twhile ( true ) {\n\n\t\tcin >> m >> n ;\n\t\tif ( m == 0 ) \n\t\t\tbreak;\n\t\tint s;\n\t\tcin >> s;\n\t\tint xs, ys;\n\n\t\tfor ( int i=0; i<n+2; i++ ) {\n\t\t\tfor ( int j=0; j<m+2; j++ ) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdis[i][j] = MAX;\n\t\t\t\tchk[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<s; i++ ) {\n\t\t\tcin >> xs >> ys;\n\t\t\tmap[ys-1][xs-1] = i+1;\n\t\t\tchk[ys-1][xs-1] = 0;\n\t\t\tfill ( ys-1, xs-1, 0, i+1);\n\t\t}\n\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (char)(map[i][j] + '0');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (int)dis[i][j] << '\\t';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (char)(chk[i][j] + '0');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\t/*\n\t\tfor ( int i=0 ; i<n+2; i++ ) {\n\t\t\tfor ( int j=0; j<m+2; j++ ) {\n\t\t\t\tif ( map[i][j] > 0 ) {\n\t\t\t\t\tfill ( i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint t;\n\t\tcin >> t;\n\t\tint max = 0;\n\t\tint pt, qt;\n\t\tfor ( int i=0; i<t; i++ ) {\n\t\t\tcin >> pt >> qt;\n\t\t\tint temp;\n\t\t\ttemp =  counting ( qt-1, pt-1 );\n\n\t\t\t//\t\t\tcout << \"Cont : \" << temp << endl;\n\t\t\tif ( max < temp ) {\n\t\t\t\tmax = temp;\n\t\t\t}\n\t\t}\n\t\t//\t\tcout << \"Ans: \"<< max << endl;\n\t\tcout << max << endl;\n\t\t\t\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int even_di[] = {-1,-1,0,0,1,1};\nconst int even_dj[] = {0,1,-1,1,0,1};\nconst int odd_di[] = {-1,-1,0,0,1,1};\nconst int odd_dj[] = {-1,0,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  //if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  //if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    // if( M.T[now.i][now.j].dist[store] < infty ) continue;\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(even_di)/sizeof(*even_di); ++i){\n      int ti = now.i + ( now.i%2==0 ? even_di[i] : odd_di[i] );\n      int tj = now.j + ( now.i%2==0 ? even_dj[i] : odd_dj[i] );\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n      // M.T[ti][tj].dist[store] = now.cost+1;\n      \n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n\n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n    \n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\n\nint m, n, s;\nint min_cost[100][100];\nbool used[100][100];\nint dy[] = {-1,0,1,-1,0,1};\nint dx[][6] = {{ -1,-1,-1,0,1,0}, {0,-1,0,1,1,1}};\n\nbool isover(int y, int x){\n  return y < 0 || y >= n || x < 0 || x >= m;\n}\n\nvoid bfs(int y, int x){\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  min_cost[y][x] = 0;\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] <= p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      min_cost[ny][nx] = p.fr + 1;\n    }\n  }\n}\n\nint prebfs(int y, int x){\n  if(!min_cost[y][x]) return 0;\n\n  int ret = 1;\n  fill_n( *used, 10000, false);\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  used[y][x] = true;\n\n\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || used[ny][nx] || min_cost[ny][nx] <= p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      used[ny][nx] = true;\n      ret++;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> m, m){\n    fill_n( *min_cost, 10000, 1 << 30);\n\n    cin >> n >> s;\n\n    for(int i = 0 ; i < s ; i++ ){\n      int x, y;\n      cin >> x >> y;\n      bfs( y - 1, x - 1);\n    }\n\n    int t, ret = 0;\n    cin >> t;\n    while(t--){\n      int p, q;\n      cin >> p >> q;\n      ret = max( ret,prebfs( q - 1, p - 1));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct pos{int x,y,cost;}pos;\n\nint M,N,S,T,m[105][105],m2[105][105],p,q,R,t;\n\nint bfs(int (*m)[105],int x,int y)\n{\n\tint i,c=1,mx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}},my[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\n\tqueue<pos>Q;\n\tm[y][x]=0;\n\tpos tmp={x,y,0};\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.front();Q.pop();\n\t\tint p=tmp.y%2;\n\t\tfor(int i=0;i<6;i++)\n\t\t{\n\t\t\tif(0<=tmp.y+my[p][i]&&tmp.y+my[p][i]<N&&0<=tmp.x+mx[p][i]&&tmp.x+mx[p][i]<M&&m[tmp.y+my[p][i]][tmp.x+mx[p][i]]>tmp.cost+1)\n\t\t\t\t{\n\t\t\t\t\tm[tmp.y+my[p][i]][tmp.x+mx[p][i]]=tmp.cost+1;\n\t\t\t\t\tpos tmp2={tmp.x+mx[p][i],tmp.y+my[p][i],tmp.cost+1};\n\t\t\t\t\tc++;\n\t\t\t\t\tQ.push(tmp2);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tfor(;~scanf(\"%d%d%d\",&M,&N,&S),M;)\n\t{\n\t\tmemset(m,0x7,sizeof(m));\n\t\tfor(int i=0;i<S;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tbfs(m,p-1,q-1);\n\t\t}\n\t\tR=0;\n\t\tscanf(\"%d\",&T);\n\t\tfor(int i=0;i<T;i++)\n\t\t{\n\t\t\tmemcpy(m2,m,sizeof(m));\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tt=bfs(m2,p-1,q-1);\n\t\t\tR=t<R?R:t;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct st { int x, y, c; };\nint d[100][100], b[100][100], x[10], y[10];\nint dx[][6]{ { 0,-1,0,1,1,1, },{-1,-1,-1,0,1,0} };\nint dy[]{ -1,0,1,1,0,-1 };\nint main() {\n\tint m, n, s;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tscanf(\"%d\", &s);\n\t\trep(i, s)scanf(\"%d%d\", &x[i], &y[i]), x[i]--, y[i]--;\n\t\tint t; scanf(\"%d\", &t);\n\t\tint Max = 0;\n\t\trep(i, t) {\n\t\t\tint p, q; scanf(\"%d%d\", &p, &q); p--; q--;\n\t\t\tqueue<st>que;\n\t\t\tmemset(d, -1, sizeof(d));\n\t\t\trep(j, s) {\n\t\t\t\td[x[j]][y[j]] = 0; b[x[j]][y[j]] = j;\n\t\t\t\tque.push({ x[j],y[j],j });\n\t\t\t}\n\t\t\td[p][q] = 0; b[p][q] = s; que.push({ p,q,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tst p = que.front(); que.pop();\n\t\t\t\trep(j, 6) {\n\t\t\t\t\tint nx = p.x + dx[!(p.y & 1)][j], ny = p.y + dy[j];\n\t\t\t\t\tif (0 <= nx&&nx < m && 0 <= ny&&ny < n) {\n\t\t\t\t\t\tif (d[nx][ny] == -1) {\n\t\t\t\t\t\t\td[nx][ny] = d[p.x][p.y] + 1;\n\t\t\t\t\t\t\tb[nx][ny] = p.c;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (d[nx][ny] == d[p.x][p.y] + 1)\n\t\t\t\t\t\t\tb[nx][ny] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\trep(i, m)rep(j, n) {\n\t\t\t\tif (b[i][j] == s)cnt++;\n\t\t\t}\n\t\t\tMax = max(Max, cnt);\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nstruct NODE{\n\tint x,y,c,num;\n\tNODE(int x,int y,int c) : x(x) , y(y) , c(c) {}\n\tNODE(int x,int y,int c,int num) : x(x) , y(y) , c(c) , num(num) {}\n};\nint W,H;\n\nint doit(vector<NODE> v){\n\tqueue<NODE> Q;\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tQ.push(NODE(v[i].x,v[i].y,0,i));\n\t}\n\tint cnt[100][100]={};\n\tint ans[100][100];\n\tfor(int i = 0 ; i < 100 ; i++)\n\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\tans[i][j] = 1e9;\n\t\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\tint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,0,0,1,1,1} };\n\tint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,1,-1,0,1,-1} };\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( q.x < 0 || q.y < 0 || q.x >= W || q.y >= H ) continue;\n\t\tif( ans[q.y][q.x] < q.c ) continue;\n\t\tif( ans[q.y][q.x] > 10000) {\n\t\t\tans[q.y][q.x] = q.c;\n\t\t\tcnt[q.y][q.x] = (1<<q.num);\n\t\t}else if( ans[q.y][q.x] == q.c ){\n\t\t\tcnt[q.y][q.x] |= (1<<q.num);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0 ; i < 6 ; i++){\n\t\t\tQ.push(NODE(q.x+dx[q.y%2][i],q.y+dy[q.y%2][i],q.c+1,q.num));\n\t\t}\n\t}\n\t\n\tint cntt = 0;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t//printf(\"%3d\",cnt[i][j]);\n\t\t\tif( cnt[i][j] == (1<<(v.size()-1)) ){\n\t\t\t\tcntt++;\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t}\n\treturn cntt;\n\t\n}\nint main(){\n\n\twhile(cin >> W >> H && W){\n\t\tint s,N;\n\t\tcin >> s;\n\t\tvector<NODE> alr;\n\t\tfor(int i = 0 ; i < s ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--,y--;\n\t\t\talr.push_back(NODE(x,y,0));\n\t\t}\n\t\tcin >> N;\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--,y--;\n\t\t\talr.push_back(NODE(x,y,0));\n\t\t\tans = max( ans , doit(alr) );\n\t\t\talr.pop_back();\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint dxo[6] = { -1,  0, -1, 1, -1, 0};\nint dxe[6] = { 0,  1, -1, 1, 0, 1};\nint dy[6] = {-1, -1,  0, 0,  1, 1}; \n\nstruct node { int x, y, dist, num; };\n\nconst int INF = 1000000009;\nconst int MAX_N = 101;\nconst int MAX_S = 11;\nint n, m, s, t;\nint cx[MAX_S], cy[MAX_S], tx[MAX_S], ty[MAX_S];\nint field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nint bfs(int x, int y) {\n\tint res = 0;\n\tqueue<node> que;\n\tnode md = {x, y, 0, -1};\n\tque.push(md);\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\tif(dist[nd.x][nd.y] <= nd.dist) continue;\n\n\t\tres++;\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tnode nnd = {xx, yy, nd.dist+1, -1};\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\trep(y,n) {\n\t\trep(x,m) {\n\t\t\tfield[x][y] = 0;\n\t\t\tdist[x][y] = INF;\n\t\t}\n\t}\n\n\tqueue<node> que;\n\trep(i,s) {\n\t\tnode nd = { cx[i]-1, cy[i]-1, 0, i+1 };\n\t\tfield[cx[i]-1][cy[i]-1] = i+1;\n\t\tdist[cx[i]-1][cy[i]-1] = 0;\n\t\tque.push(nd);\n\t}\n\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tif(dist[xx][yy] > nd.dist + 1) {\n\t\t\t\t\tdist[xx][yy] = nd.dist + 1;\n\t\t\t\t\tfield[xx][yy] = nd.num;\n\t\t\t\t} else if(dist[xx][yy] == nd.dist + 1 && field[xx][yy] != nd.num) {\n\t\t\t\t\tfield[xx][yy] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnode nnd = { xx, yy, nd.dist+1, nd.num };\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxval = 0;\n\trep(i,t) {\n\t\tint res = bfs(tx[i]-1, ty[i]-1);\n\t\tmaxval = max(res, maxval);\n\t}\n\tprintf(\"%d\\n\", maxval);\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) break;\n\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &s);\n\t\trep(i,s) scanf(\"%d%d\", &cx[i], &cy[i]);\n\n\t\tscanf(\"%d\", &t);\n\t\trep(i,t) scanf(\"%d%d\", &tx[i], &ty[i]);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define LEN 100\n#define MAX 255\nunsigned char map[LEN+2][LEN+2];\nunsigned char chk[LEN+2][LEN+2];\nunsigned char dis[LEN+2][LEN+2];\nbool now[LEN][LEN];\n\nint m,n;\n\nint edx[6] = { -1, 1, 0, 1, 0, 1 };\nint odx[6] = { -1, 1, -1, 0, -1, 0};\nint dy[6] = { 0, 0, 1, 1, -1, -1};\n\nvoid fill( int y, int x, int d, int p ) {\n\n\tif ( y < 0 || y > n || x < 0 || x > m )\n\t\treturn;\n\n\tif ( chk[y][x] == MAX ) {\n\t\tif ( dis[y][x] > d ) {\n\t\t\tchk[y][x] = p;\n\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\n\t\t} \n\t}\n\telse {\n\t\tif ( chk[y][x] == 0 ) {\n\t\t\t//\t\t\tcout << \"Start\" << y << \"\\t\" <<  x << endl;\n\t\t\tchk[y][x] = p;\n\t\t\tdis[y][x] = d;\n\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t} else\n\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t}\n\t\t} else if ( chk[y][x] == p ) {\n\t\t\tif ( dis[y][x] > d ) {\n\t\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tif ( dis[y][x] > d ) {\n\t\t\t\t//\t\t\t\tcout << \"Do\" << y << \"\\t\" <<  x << endl;\n\t\t\t\tchk[y][x] = p;\n\t\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( dis[y][x] == d ) {\n\t\t\t\t//\t\t\t\tcout << \"Here \" << y << \"\\t\" << x << endl;\n\t\t\t\tchk[y][x] = MAX;\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nint count = 0;\n\nvoid find ( int y, int x, int d ) {\n\n\tif ( y < 0 || y > n || x < 0 || x > m )\n\t\treturn;\n\n\t//\tcout << \"Do\" << y << \"\\t\" <<  x << endl;\n\n\tif ( now[y][x] ) {\n\t\tnow[y][x] = false;\n\t\t//\t\tcout << \"Get\\n\";\n\t\tif ( dis[y][x] > d ) {\n\t\t\tcount++;\n\n\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\tif ( y%2 == 1 )\n\t\t\t\t\tfind( y+dy[i], x+edx[i], d+1 );\n\t\t\t\telse\n\t\t\t\t\tfind( y+dy[i], x+odx[i], d+1 );\n\t\t\t}\n\n\t\t}\n\t}\n}\n\t\n\nint counting ( int y, int x ) {\n\t//\tcout << \"Start\\n\" << endl;\n\tcount = 1;\n\tnow[y][x] = false;\n\n\tmemset ( now, true, (LEN*LEN)*sizeof(bool));\n\n\tfind( y, x, 0 );\n\n\treturn count;\n}\n\nint main () {\n\n\twhile ( true ) {\n\n\t\tcin >> m >> n ;\n\t\tif ( m == 0 ) \n\t\t\tbreak;\n\t\tint s;\n\t\tcin >> s;\n\t\tint xs, ys;\n\n\t\tfor ( int i=0; i<n+2; i++ ) {\n\t\t\tfor ( int j=0; j<m+2; j++ ) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdis[i][j] = MAX;\n\t\t\t\tchk[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<s; i++ ) {\n\t\t\tcin >> xs >> ys;\n\t\t\tmap[ys-1][xs-1] = i+1;\n\t\t\tchk[ys-1][xs-1] = 0;\n\t\t\tfill ( ys-1, xs-1, 0, i+1);\n\t\t}\n\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (char)(map[i][j] + '0');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (int)dis[i][j] << '\\t';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (char)(chk[i][j] + '0');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\t/*\n\t\tfor ( int i=0 ; i<n+2; i++ ) {\n\t\t\tfor ( int j=0; j<m+2; j++ ) {\n\t\t\t\tif ( map[i][j] > 0 ) {\n\t\t\t\t\tfill ( i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint t;\n\t\tcin >> t;\n\t\tint max = 0;\n\t\tint pt, qt;\n\t\tfor ( int i=0; i<t; i++ ) {\n\t\t\tcin >> pt >> qt;\n\t\t\tint temp;\n\t\t\ttemp =  counting ( qt-1, pt-1 );\n\n\t\t\t//\t\t\tcout << \"Cont : \" << temp << endl;\n\t\t\tif ( max < temp ) {\n\t\t\t\tmax = temp;\n\t\t\t}\n\t\t}\n\t\t//\t\tcout << \"Ans: \"<< max << endl;\n\t\tcout << max << endl;\n\t\t\t\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\nbool f;\n \nvoid dfs(int x,int y,int cost)\n{\n  //if(!f)\n  //cout << \"xy = \"  << x << \",\" << y << \" cost = \" << cost << endl;\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n    continue;\n      //if(!f)cout << \"mincost[\"<<ny<<\"][\"<<nx<<\"] = \" << mincost[ny][nx] << \" = cost + 1  = \" << cost + 1  << endl;\n      if(mincost[ny][nx] > cost+1)\n    {\n      if(!visited[ny][nx])\n        cnt++;\n      visited[ny][nx] = true;\n      mincost[ny][nx] = cost + 1;\n      dfs(nx,ny,cost+1);\n    }\n    }\n}\n \nint main()\n{\n  while(true)\n    {\n      cin >> m;\n      if(!m) break;\n      cin >> n;\n      for(int i=0;i<n;i++) \n    for(int j=0;j<m;j++)\n      mincost[i][j] = (1<<29);  \n      f = true;\n      int s,t,mex = 0;\n      scanf(\"%d\",&s);\n      for(int i=0;i<s;i++)\n    {\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--,y--;\n      mincost[y][x] = 0;\n      dfs(x,y,0);\n    }\n      f = false;\n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n    {   \n      int pre_mincost[n][m];\n      for(int j=0;j<n;j++)\n        for(int k=0;k<m;k++)\n          pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n      int p,q;\n      scanf(\"%d %d\",&p,&q);\n \n      cnt = 1,p--,q--;\n      mincost[q][p] = 0,visited[q][p] = true;\n       \n      dfs(p,q,0);\n       \n      mex = max(mex,cnt);\n      for(int j=0;j<n;j++)\n        for(int k=0;k<m;k++)\n          mincost[j][k] = pre_mincost[j][k];\n    }\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define REP(i,n) for(int i=1; i<=n; i++)\n#define ABS(n) (n<0?-n:n)\n\n#define INF (1<<20)\nint field[128][128];\n\nint dist(int x1, int y1, int x2, int y2)\n{\n\tx1-=(y1-1)/2;\n\tx2-=(y2-1)/2;\n\n\treturn (ABS(x1-x2)+ABS(y1-y2)+ABS((x1+y1)-(x2+y2)))/2;\n}\n\nint main()\n{\n\tint w,h,n,x0,y0,cnt,ans;\n\twhile(cin >> w, w)\n\t{\n\t\tcin >> h;\n\t\tREP(y,h)REP(x,w)\n\t\t{\n\t\t\tfield[y][x] = INF;\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> x0 >> y0;\n\t\t\tREP(y,h)REP(x,w)\n\t\t\t{\n\t\t\t\tfield[y][x] = min(field[y][x],dist(x0,y0,x,y));\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcnt = 0;\n\t\t\tcin >> x0 >> y0;\n\t\t\tREP(y,h)REP(x,w)\n\t\t\t{\n\t\t\t\tif(field[y][x]>dist(x0,y0,x,y)) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\n\nconst int INF = 9999999;\nconst int MAX_M = 100, MAX_N = 100, MAX_S = 10, MAX_T = 10;\n\nint m,n,s,t;\nint dist[MAX_M][MAX_N];\nint visit[MAX_M][MAX_N];\nint dx[2][6] = {\n    {1, 1, 1, 0, 0, 0},\n    {0, 0, 0, -1, -1, -1}\n};\nint dy[2][6] = {\n    {-1, 0, 1, 1, 0, -1},\n    {-1, 0, 1, 1, 0, -1}\n};\n\nbool check(int x, int y)\n{\n    return (x >= 0 && x < m && y >= 0 && y < n);\n}\n            \nint bfs(int x, int y, bool f)\n{\n    queue<S> que;\n    que.push(S(0, P(x, y)));\n    dist[y][x] = 0;\n    int cover = 1;\n    for(int i = 0; i < n; i++) \n        for(int j = 0; j < m; j++)\n            visit[i][j] = false;\n\n    visit[y][x] = true;\n    while(!que.empty()) {\n        S s = que.front(); que.pop();\n        int xx = s.second.first, yy = s.second.second, step = s.first;\n        for(int i = 0; i < 6; i++) {\n            int nx = xx + dx[yy % 2][i], ny = yy + dy[yy % 2][i], ns = step + 1;\n            if(f) {\n                if(check(nx, ny) && !visit[ny][nx]) {\n                    que.push(S(ns, P(nx, ny)));\n                    visit[ny][nx] = true;\n                    if(dist[ny][nx] > ns) \n                        cover++;\n                }\n            } else {\n                if(check(nx, ny) && dist[ny][nx] > ns) {\n                    dist[ny][nx] = ns;\n                    que.push(S(ns, P(nx, ny)));\n                }\n            }\n        }\n    }\n    return cover;\n}\n\nint main()\n{\n    while(cin >> m && m) {\n        cin >> n;\n        for(int i = 0; i < n; i++) \n            for(int j = 0; j < m; j++) \n                    dist[i][j] = INF;\n\n        int x,y;\n        cin >> s;\n        for(int i = 0; i < s; i++) {\n            cin >> x >> y;\n            bfs(x, y, false);\n        }\n        \n        cin >> t;\n        int ans = 0;\n        for(int i = 0; i < t; i++) {\n            cin >> x >> y;\n            ans = max(ans, bfs(x, y, true));\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* You sure that's enough source code? \n  -I'll take the best challenge you can do. ツ—ツ— Respect \"El Shaddai 2010 (UTV IGNITION Entertainment)\" */\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n\n// Example: dx[i%2][d] ( i is 0-indexed )\nconst int dx[2][6] = {{ 0,-1, 1,-1,-1, 0},{ 1,-1, 0, 1, 0, 1}};\nconst int dy[2][6] = {{ 1, 0, 0, 1,-1,-1},{ 0, 0,-1,-1, 1, 1}};\nstruct NODE{\n\tint x;\n\tint y;\n\tint depth;\n};\nint W,H;\n\nbool co(int x,int y){\n\tif(x<0 || y<0)return false;\n\tif(x>=W || y>=H)return false;\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> W,W){\n\t\tint ret = 0;\n\t\tcin >> H;\n\t\tint memo[10][100][100];\n\t\trep(i,10)rep(j,100)rep(k,100)memo[i][j][k] = -1;\n\t\tint s; cin >> s;\n\t\trep(i,s){\n\t\t\tint x,y; cin >> x >> y;\n\t\t\tx--;y--;\n\t\t\tqueue<NODE> Q; NODE t = {x,y,0};\n\t\t\tQ.push(t);\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\trep(d,6){\n\t\t\t\t\tNODE next; \n\t\t\t\t\tnext.x = q.x + dx[q.y%2][d];\n\t\t\t\t\tnext.y = q.y + dy[q.y%2][d];\n\t\t\t\t\tnext.depth = q.depth+1;\n\t\t\t\t\t\n\t\t\t\t\tif(!co(next.x,next.y) || memo[i][next.y][next.x]!=-1)continue;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t\tmemo[i][next.y][next.x] = next.depth;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[i][t.y][t.x] = 0;\t\t\n\t\t}\n\t\tint t; cin >> t;\n\t\trep(i,t){\n\t\t\tbool done[100][100]={0};\n\t\t\tint cnt = 0;\n\t\t\tint x,y; cin >> x >> y;\n\t\t\tx--;y--;\n\t\t\tqueue<NODE> Q; NODE t = {x,y,0};\n\t\t\tQ.push(t);\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\t\n\t\t\t\tbool f=true;\n\t\t\t\tfor(int g=0;g<s;g++){\n\t\t\t\t\tif( memo[g][q.y][q.x] <= q.depth){\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)cnt++;\n\t\t\t\t\n\t\t\t\trep(d,6){\n\t\t\t\t\tNODE next; \n\t\t\t\t\tnext.x = q.x + dx[q.y%2][d];\n\t\t\t\t\tnext.y = q.y + dy[q.y%2][d];\n\t\t\t\t\tnext.depth = q.depth +1;\n\t\t\t\t\tif(!co(next.x,next.y) || done[next.y][next.x])continue;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t\tdone[next.y][next.x] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = max(ret,cnt);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\n\nint field[128][128], flag[128][128];\n\nstruct P{ int x, y, d; P(int x, int y, int d) : x(x), y(y), d(d) {} };\n\n#define range(x, y) (0 <= x && x < m && 0 <= y && y < n)\n\nint main()\n{\n    int m, n, s, t;\n\twhile(cin >> m && m)\n\t{\n\t\tcin >> n >> s;\n\n\t\tmemset(field, -1, sizeof field);\n\t\t\n\t\trep(i, s)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\tqueue<P> que;\n\t\t\tfor(que.push(P(x - 1, y - 1, 0)); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tP p = que.front();\n\t\t\t\t\n\t\t\t\tif(p.d < field[p.x][p.y] || field[p.x][p.y] == -1)\n\t\t\t\t{\n\t\t\t\t\tfield[p.x][p.y] = p.d;\n\t\t\t\t\t\n\t\t\t\t\trep(j, 6)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = p.x + dx[p.y % 2][j], ny = p.y + dy[j];\n\t\t\t\t\t\tif(range(nx, ny)) que.push(P(nx, ny, p.d + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint t, res = 0;\n\t\t\n\t\tcin >> t;\n\t\t\n\t\trep(i, t)\n\t\t{\n\t\t\tint x, y, sub = 0;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\tmemset(flag, 0, sizeof flag);\n\t\t\t\n\t\t\tqueue<P> que;\n\t\t\tfor(que.push(P(x - 1, y - 1, 0)); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tP p = que.front();\n\t\t\t\t\n\t\t\t\tif(p.d < field[p.x][p.y] && flag[p.x][p.y] == false)\n\t\t\t\t{\n\t\t\t\t\tflag[p.x][p.y] = true;\n\t\t\t\t\t\n\t\t\t\t\tsub++;\n\t\t\t\t\t\n\t\t\t\t\trep(j, 6)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = p.x + dx[p.y % 2][j], ny = p.y + dy[j];\n\t\t\t\t\t\tif(range(nx, ny)) que.push(P(nx, ny, p.d + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchmax(res, sub);\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x-1,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y % 2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[128][128];\nint id_list[128][128];\nint candidate_cost[128][128];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    min_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    candidate_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 1;\n    Queue Q;\n    /*\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    */\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n    }\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h, VI( w, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,m;\n  int s,t;\n  int x,y;\n  int grid[101][101];\n\n  while(cin >> n && n){\n    cin >> m;\n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=m;j++)grid[i][j] = 1<<25;\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      int hoge = 1;\n      int tmp[101][101];\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<=m;k++)tmp[j][k] = grid[j][k];\n\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    hoge++;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n      ans = max(ans,hoge);\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<=m;k++)grid[j][k] = tmp[j][k];\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint dx[][6] = {{1, 0, -1, -1, -1,  0},\n               {1, 1, 0, -1,  0,  1}\n};\nint dy[][6] = {{0, 1,  1,  0, -1, -1},\n              {0, 1, 1,  0, -1, -1}\n};\n  \ntypedef struct store{\n  int x, y;\n}store;\n\nbool range(int x, int y, int mx, int my){\n  if((0 <= x and x < mx) and (0 <= y and y < my))return true;\n  else return false;\n}\n  \n\nvoid computeDist(vector<vector<int> > &field, store st){\n  field[st.y][st.x] = 0;\n  queue<pair<store, int> > que;\n  que.push(pair<store, int>(st, 0));\n  while(not que.empty()){\n    store s  = que.front().first;\n    int dist = que.front().second;\n    que.pop();\n    for (int i = 0; i < 6; i++) {\n      int d = s.y&1;\n      if(not range(s.x + dx[d][i], s.y + dy[d][i], field[0].size(), field.size()))continue;\n      if(field[dy[d][i] + s.y][dx[d][i] + s.x] > dist + 1){\n        field[dy[d][i] + s.y][dx[d][i] + s.x] = dist + 1;\n        que.push(pair<store, int>((store){s.x + dx[d][i], s.y + dy[d][i]}, dist + 1));\n      }\n    }\n  }\n}\n  \n\nint main(){\n  int m, n;\n  while(std::cin >> m >> n, n){\n    int s, t, x, y;\n    std::cin >> s;\n    vector<store> vs(s, (store){0, 0});\n    vector<vector<vector<int> > > field(s, vector<vector<int> >(n, vector<int>(m, 1e9)));\n    for (int i = 0; i < s; i++) {\n      std::cin >> x >> y;\n      vs[i] = (store){--x, --y};\n    }\n    std::cin >> t;\n    vector<store> vp(t);\n    for (int i = 0; i < t; i++) {\n      std::cin >> x >> y;\n      vp[i] = (store){--x, --y};\n    }\n    for (int i = 0; i < s; i++) computeDist(field[i], vs[i]);\n    // for (int i = 0; i < n; i++) {\n    //   for (int j = 0; j < m; j++) {\n    //     std::cout << field[0][i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    int ans = 0;\n    for (int loop = 0; loop < t; loop++) {\n      vector<vector<int> > covered(n, vector<int>(m, 1e9));\n      computeDist(covered, vp[loop]);\n      int val = 0;\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n          int mini = covered[i][j], type = -10;\n          for (int k = 0; k < s; k++) {\n            if(mini >= field[k][i][j]) break;\n            if(k == s - 1)val++;\n          }\n        }\n      }\n      ans = max(ans, val);\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n  visited[sy][sx] = 1;\n  int res = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    if(v[y][x] > n) ++res;\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n      visited[y][x] = 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      res = max(res, count(y, x, v));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n\n#include <numeric>\n#include <algorithm>\n#include <functional>\n\n#include <cctype>\n\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nconst double EPS = 1e-9;\nconst int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nconst int ddx1[] = {0,-1,0,1,1,1};\nconst int ddy1[] = {-1,0,1,1,0,-1};\nconst int ddx0[] = {-1,-1,-1,0,1,0};\nconst int ddy0[] = {-1,0,1,1,0,-1};\n\nint main(){\n    while(true){\n        int m,n,s;\n        cin >> m;\n        if(m==0)break;\n        cin >> n >> s;\n        vector<pair<int,int> > V(s);\n\n        rep(i,s){\n            int x,y;\n            cin >> x >> y;\n            x--;y--;\n            V[i] = mp(x,y);\n        }\n        vector<vector<int> > depth(n,vector<int>(m,10000));\n        //x,y,depth\n        queue<pair<pair<int,int>,int> > Q;\n        rep(i,s){\n            Q.push(mp(V[i],0));\n        }\n        while(!Q.empty()){\n            pair<pair<int,int>,int> p = Q.front();\n            int x = p.first.first;int y = p.first.second;\n            int d = p.second;\n            Q.pop();\n            if(depth[y][x] <= d) continue;\n            depth[y][x] = d;\n            for(int i=0;i<6;i++){\n                int newx,newy;\n                if(y % 2 == 0){\n                    newx = x + ddx0[i];\n                    newy = y + ddy0[i];\n                }else{\n                    newx = x + ddx1[i];\n                    newy = y + ddy1[i];\n                }\n                if(newx == -1 || newy == -1 || newx == m || newy == n){\n                    continue;\n                }\n                Q.push(mp(mp(newx,newy),d+1));\n            }\n        }\n\n        int t;\n        cin >> t;\n        vector<pair<int,int> > Con(t);\n        rep(i,t){\n            int p,q;\n            cin >> p >> q;\n            p--;q--;\n            Con[i] = mp(p,q);\n        }\n        int maxcnt = -1;\n\n/*\n        rep(i,n){\n            rep(j,m){\n                cerr << depth[i][j] << \" \";\n            }\n            cerr << endl;\n        }\n*/\n        rep(cont,t){\n            pair<int,int> cc = Con[cont];\n            int cnt = 0;\n            queue<pair<pair<int,int>,int> > Qc;\n            Qc.push(mp(cc,0));\n            vector<vector<int> > depthc = depth;\n            while(!Qc.empty()){\n                pair<pair<int,int>,int> p = Qc.front();\n                int x = p.first.first;int y = p.first.second;\n                int d = p.second;\n                Qc.pop();\n                if(depthc[y][x] <= d) continue;\n\n                depthc[y][x] = d;\n                cnt++;\n                for(int i=0;i<6;i++){\n                    int newx,newy;\n                    if(y % 2 == 0){\n                        newx = x + ddx0[i];\n                        newy = y + ddy0[i];\n                    }else{\n                        newx = x + ddx1[i];\n                        newy = y + ddy1[i];\n                    }\n\n                    if(newx == 0 || newy == 0 || newx == m || newy == n){\n                        continue;\n                    }\n                    Qc.push(mp(mp(newx,newy),d+1));\n                }\n            }\n            maxcnt = max(maxcnt,cnt);\n        }\n        cout << maxcnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[2][6]={{-1,-1,0,0,1,1},{-1,-1,0,0,1,1}};\nint dy[2][6]={{-1,0,-1,1,-1,0},{1,0,-1,1,1,0}};\nint bfs[110][110];\nint m[110][110];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint c;scanf(\"%d\",&c);\n\t\tqueue<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)bfs[i][j]=-1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&q,&p);\n\t\t\tp--;q--;\n\t\t\tbfs[p][q]=0;\n\t\t\tQ.push(make_pair(p,q));\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tint t=row%2;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(0<=row+dx[t][i]&&row+dx[t][i]<a&&0<=col+dy[t][i]&&col+dy[t][i]<b&&!~bfs[row+dx[t][i]][col+dy[t][i]]){\n\t\t\t\t\tbfs[row+dx[t][i]][col+dy[t][i]]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[t][i],col+dy[t][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tint d;scanf(\"%d\",&d);\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&q,&p);p--;q--;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)m[j][k]=-1;\n\t\t\tm[p][q]=0;\n\t\t\tQ.push(make_pair(p,q));\n\t\t\twhile(Q.size()){\n\t\t\t\tint row=Q.front().first;\n\t\t\t\tint col=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tint t=row%2;\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\tif(0<=row+dx[t][i]&&row+dx[t][i]<a&&0<=col+dy[t][i]&&col+dy[t][i]<b&&!~m[row+dx[t][i]][col+dy[t][i]]){\n\t\t\t\t\t\tm[row+dx[t][i]][col+dy[t][i]]=m[row][col]+1;\n\t\t\t\t\t\tQ.push(make_pair(row+dx[t][i],col+dy[t][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)if(bfs[j][k]>m[j][k])val++;\n\t\t\tret=max(val,ret);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v, vector< vector<bool> > &visited){\n  int res = (v[y][x] <= n ? 0 : 1);\n  visited[y][x] = 1;\n  v[y][x] = n;\n  int t = (y % 2 == 0);\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n    res += count(ny, nx, n + 1, v, visited);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n      res = max(res, count(y, x, 0, v, visited));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    /*\n    int answer = 1;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n    }\n    return answer;\n    */\n    return 0;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h, VI( w, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[2][6] = { {0, -1, -1, -1, 0, 1}, {1, 0, -1, 0, 1, 1} };\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\n\nclass State\n{\npublic:\n  int x, y, c;\n  State(int _x = 0, int _y = 0, int _c = 0)\n    :x(_x), y(_y), c(_c) {}\n};\n\nint main()\n{\n  int m, n;\n  while (cin >> m >> n) {\n    if ((m|n) == 0)\n      break;\n\n    int s;\n    cin >> s;\n    vector<vector<int> > cost(n, vector<int>(m, INF));\n    for (int i = 0; i < s; ++i) {\n      int x, y;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] < st.c)\n\t  continue;\n\n\tcost[st.y][st.x] = st.c;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] < st.c+1)\n\t    continue;\n\t  cost[y][x] = st.c+1;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n    }\n\n    int t;\n    cin >> t;\n    int ans = 0;\n    for (int i = 0; i < t; ++i) {\n      int x, y, cnt = 0;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] <= st.c)\n\t  continue;\n\n\t++cnt;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] <= st.c+1)\n\t    continue;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n      ans = max(ans, cnt);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nconst int dx[2][6] = {\n    {-1, 0, -1, 1, -1, 0},\n    {0, 1, -1, 1, 0, 1}\n};\nconst int dy[2][6] = {\n    {-1, -1, 0, 0, 1, 1},\n    {-1, -1, 0, 0, 1, 1}\n};\n\nint m, n;\npair<int,int> bloc[100][100], tmp[100][100];\n\nvoid dfs(int idx, int x, int y, int dist) {\n    if (dist < bloc[y][x].second) {\n        bloc[y][x] = make_pair(idx, dist);\n        int k = y%2;\n        for (int i=0; i<6; ++i) {\n            if (0 <= x+dx[k][i] && x+dx[k][i] < m &&\n                0 <= y+dy[k][i] && y+dy[k][i] < n) {\n                dfs(idx, x+dx[k][i], y+dy[k][i], dist+1);\n            }\n        }\n    } else if (idx != bloc[y][x].first && dist == bloc[y][x].second) {\n        bloc[y][x] = make_pair(-1, dist);\n    }\n}\n\nint main() {\n    while (cin >> m >> n, (m || n)) {\n        for (int i=0; i<100; ++i) for (int j=0; j<100; ++j) {\n            bloc[i][j] = make_pair(INT_MAX, INT_MAX);\n        }\n        int s;\n        cin >> s;\n        int x, y;\n        for (int i=0; i<s; ++i) {\n            cin >> x >> y;\n            dfs(i, x-1, y-1, 0);\n        }\n        int t;\n        cin >> t;\n        int p, q, res = 0;\n        for (int i=0; i<t; ++i) {\n            cin >> p >> q;\n            memcpy(tmp, bloc, sizeof bloc);\n            dfs(s, p-1, q-1, 0);\n            int cnt = 0;\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<m; ++j) {\n                    if (bloc[i][j].first == s) {\n                        ++ cnt;\n                    }\n                }\n            }\n            res = max(res, cnt);\n            memcpy(bloc, tmp, sizeof tmp);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint m,n;\nint s,t;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nconst int INF=10000000;\nint field[101][101];\nint x[11],y[11];\nint nx[11],ny[11];\nint dx1[6]={0,-1,0,1,1,1};\nint dx2[6]={-1,-1,-1,0,1,0};\nint dy[6]={-1,0,1,-1,0,1};\n\nvoid bfs(int sx,int sy){\n\tqueue<PP> que;\n\tque.push(PP(P(sx,sy),0));\n\tfield[sx][sy]=0;\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field[px][py]>c+1){\n\t\t\t\tfield[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int sx,int sy,int field2[101][101]){\n\tqueue<PP> que;\n\tint res=1;\n\tif(field2[sx][sy]==0)return 0;\n\tque.push(PP(P(sx,sy),0));\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field2[px][py]>c+1){\n\t\t\t\tres++;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint ans=0;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfield[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tbfs(x[i],y[i]);\n\t\t}\n\t\tcin >> t;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> nx[i] >> ny[i];\n\t\t\tans=max(ans,bfs2(nx[i],ny[i],field));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[100][100];\nint grid[100][100];\nint grid2[100][100];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 100; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--y][--x] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tg[--q][--p] = 1;\n\t\t\tmaxi = max(maxi, solve());\n\t\t\tg[q][p] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n      if(ok)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n    \n      for(int i=0;i<10000000;i++);\n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\n\nstruct Data{\n\tint y, x;\n\tbool is_deven;\n\tData(){}\n\tData(int _y, int _x, bool _is_deven){\n\t\ty = _y; x = _x; is_deven = _is_deven;\n\t}\n};\n\nint main(){\n\tint N, M, S, T, X[10], Y[10], P, Q;\n\twhile(cin >> M >> N, M || N){\n\t\tcin >> S;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\n\t\tcin >> T;\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> P >> Q;\n\t\t\tP--; Q--;\n\n\t\t\tqueue<Data> q;\n\t\t\tData q_front;\n\t\t\tbool used[100][100] = {};\n\t\t\tint deven_scope = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < S; j++){\n\t\t\t\tq.push( Data(Y[j], X[j], false) );\n\t\t\t}\n\t\t\tq.push( Data(Q, P, true) );\n\n\t\t\twhile( !q.empty() ){\n\t\t\t\tq_front = q.front(); q.pop();\n\n\t\t\t\tif(used[q_front.y][q_front.x]) continue;\n\t\t\t\tused[q_front.y][q_front.x] = true;\n\n\t\t\t\tif(q_front.is_deven) deven_scope++;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\t\tint ny = q_front.y + dy[j];\n\t\t\t\t\tint nx = q_front.x + dx[q_front.y&1][j];\n\t\t\t\t\t\n\t\t\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\n\t\t\t\t\tq.push( Data(ny, nx, q_front.is_deven) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, deven_scope);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint d[11][MAX][MAX];\n\nint get_max_block(int M, int N,\n                  vector<int> &x, vector<int> &y)\n{\n    int s = x.size();\n    vector<int> cnt(s, 0);\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            int mini = INF, mid = -1, c = 0;\n            for (int k = 0; k < s; k++) {\n                if (d[k][i][j] < mini) {\n                    mini = d[k][i][j];\n                    c = 1;\n                    mid = k;\n                } else if (d[k][i][j] == mini) {\n                    c++;\n                }\n            }\n            if (c == 1) {\n                cnt[mid]++;\n            }\n        }\n    }\n    return cnt[s-1];\n}\n\nint get_dist(int sx, int sy, int gx, int gy, int M, int N)\n{\n    queue<pii> Q;\n    Q.push(pii(sx, sy));\n\n    vector<vector<int>> md(MAX, vector<int>(MAX, INF));\n    md[sy][sx] = 0;\n\n    const int dx[2][6] = {\n        {-1, +0, -1, +1, -1, +0},\n        {+0, +1, -1, +1, +0, +1}\n    };\n    const int dy[6] = {-1, -1, +0, +0, +1, +1};\n    \n    while (!Q.empty()) {\n        pii p = Q.front(); Q.pop();\n        int x = p.first, y = p.second;\n        if (x == gx && y == gy) {\n            return md[y][x];\n        }\n\n        for (int i = 0; i < 6; i++) {\n            int nx = x + dx[y&1][i];\n            int ny = y + dy[i];\n\n            if (0 <= nx && nx < M && 0 <= ny && ny < N) {\n                if (md[y][x] + 1 < md[ny][nx]) {\n                    md[ny][nx] = md[y][x] + 1;\n                    Q.push(pii(nx, ny));\n                }\n            }\n        }        \n    }\n    return INF;\n}\n\nint main()\n{\n    int M, N, s, t;\n    while (cin >> M >> N, M) {\n        cin >> s;\n        vector<int> x(s), y(s);\n        for (int i = 0; i < s; i++) {\n            cin >> x[i] >> y[i];\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < N; k++) {\n                    d[i][j][k] = get_dist(x[i], y[i], j, k, M, N);\n                }\n            }\n        }\n        \n        int res = 0;\n        \n        cin >> t;\n        for (int i = 0; i < t; i++) {\n            int X, Y;\n            cin >> X >> Y;\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < N; k++) {\n                    d[s][j][k] = get_dist(X, Y, j, k, M, N);\n                }\n            }\n            x.push_back(X); y.push_back(Y);\n            res = max(res, get_max_block(M, N, x, y));\n            x.pop_back(); y.pop_back();\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<pair<int,int>,int> NODE;\n#define X first.second\n#define Y first.first\n#define depth second\n\n/*ï*/\nint ox[] = {-1, 1, 0, 0, 1,1};\nint oy[] = { 0, 0,-1, 1,-1,1};\n\n/*ô*/\nint ex[] = {-1, 1, 0, 0,-1,-1};\nint ey[] = { 0, 0,-1, 1,-1, 1};\n\nint main(){\n\tint point[100][100];\n\tint h,w,a,b,t,x,y,s;\n\twhile(cin >> w  && w){\n\t\tint ret = 0;\n\t\tcin >> h;\n\t\trep(i,100)rep(j,100)point[i][j] = 0;\n\t\tcin >> t;\n\t\trep(i,t){\n\t\t\tcin >> a >> b;\n\t\t\ta--;b--;\n\t\t\tpoint[b][a] = i+1;\n\t\t}\n\t\tcin >> s;\n\t\trep(P,s){\n\t\t\tcin >> a >> b;\n\t\t\ta--;b--;\n\t\t\tpoint[b][a] = 50;\n\t\t\t\n\t\t//rep(i,h){rep(j,w)cout << point[i][j];cout << endl;}\n\t\tint pt[100] = {0};\n\t\trep(i,h)rep(j,w){\n\t\t\tx = j,y = i;\n\t\t\tqueue<NODE> Q;\n\t\t\tpair<int,int> dp[100];\n\t\t\tbool done[100][100]={0};\n\t\t\tQ.push( make_pair(make_pair(y,x),0\t) );\n\t\t\twhile( Q.size() ){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tif(point[q.Y][q.X]){\n\t\t\t\t\tdp[q.depth].first++;\n\t\t\t\t\tdp[q.depth].second = point[q.Y][q.X];\n\t\t\t  }\n\t\t\t\tif( q.Y % 2 == 1){\n\t\t\t\t\trep(L,6){\n\t\t\t\t\t\tif( q.X+ox[L] >=0 && q.X+ox[L] < w && q.Y+oy[L] < h && q.Y+oy[L]>=0 ){\n\t\t\t\t\t\t\t\tif( !done[q.Y+oy[L]][q.X+ox[L]] )Q.push( make_pair(make_pair(q.Y+oy[L],q.X+ox[L]),q.depth+1) );\n\t\t\t\t\t\t\t  \tdone[q.Y+oy[L]][q.X+ox[L]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\trep(L,6){\n\t\t\t\t\t\tif( q.X+ex[L] >=0 && q.X+ex[L] < w && q.Y+ey[L] < h && q.Y+ey[L]>=0 ){\n\t\t\t\t\t\t\t\t\tif( !done[q.Y+ey[L]][q.X+ex[L]] )Q.push( make_pair(make_pair(q.Y+ey[L],q.X+ex[L]),q.depth+1) );\n\t\t\t\t\t\t\t  \tdone[q.Y+ey[L]][q.X+ex[L]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(I,100){\n\t\t\t\tif(dp[I].first){\n\t\t\t\t\tif(dp[I].first==1)\n\t\t\t\t\t\tpt[dp[I].second-1]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tret = max(pt[49],ret);\n\t\t\tpoint[b][a] = 0;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\n\nint dist(pii a, pii b)\n{\n\tint dy = a.first - b.first;\n\tint dx = a.second - b.second;\n\tif(0 <= dy*dx){\n\t\tdy = abs(dy);\n\t\tdx = abs(dx);\n\t\treturn dy + max(0, dx - (dy+1-min(a.first,b.first)%2)/2);\n\t}\n\telse{\n\t\tdy = abs(dy);\n\t\tdx = abs(dx);\n\t\treturn dy + max(0, dx - (dy + min(a.first, b.first)%2)/2);\n\t}\n}\n\nint main()\n{\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n), m){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tpii conv[10];\n\t\trep(i, s)\n\t\t\tscanf(\"%d%d\", &conv[i].second, &conv[i].first);\n\t\t\n\t\tint d[101][101];\n\t\trep(i, n) rep(j, m){\n\t\t\td[i+1][j+1] = INF;\n\t\t\trep(k, s)\n\t\t\t\td[i+1][j+1] = min(d[i+1][j+1], dist(pii(i+1, j+1), conv[k]));\n\t\t}\n\t\t\n\t\tint t, ans = 0;\n\t\tscanf(\"%d\", &t);\n\t\trep(i, t){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\trep(j, n) rep(k, m)\n\t\t\t\tcnt += dist(pii(j+1, k+1), pii(y, x)) < d[j+1][k+1];\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define INF (1<<20)\nint field[128][128];\n\nint dist(int x1, int y1, int x2, int y2)\n{\n\tx1-=(y1-1)/2;\n\tx2-=(y2-1)/2;\n\n\treturn (abs(x1-x2)+abs(y1-y2)+abs((x1+y1)-(x2+y2)))/2;\n}\n\nint main()\n{\n\tint w,h,n,x0,y0,cnt,ans;\n\twhile(cin >> w, w)\n\t{\n\t\tcin >> h;\n\t\tfor(int y=1; y<=h; y++)\n\t\tfor(int x=1; x<=w; x++)\n\t\t{\n\t\t\tfield[y][x] = INF;\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> x0 >> y0;\n\t\t\tfor(int y=1; y<=h; y++)\n\t\t\tfor(int x=1; x<=w; x++)\n\t\t\t{\n\t\t\t\tfield[y][x] = min(field[y][x],dist(x0,y0,x,y));\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcnt = 0;\n\t\t\tcin >> x0 >> y0;\n\t\t\tfor(int y=1; y<=h; y++)\n\t\t\tfor(int x=1; x<=w; x++)\n\t\t\t{\n\t\t\t\tif(field[y][x]>dist(x0,y0,x,y)) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Point {\n\tint x, y, s;\n\tPoint(int x_, int y_, int s_) : x(x_), y(y_), s(s_) {}\n};\n\nint dx[6] = {1, 1, 1, 0, -1, 0}, \n\tdy[6] = {-1, 0, 1, 1, 0, -1},\n\tW, H, S, T;\n\nbool vis[110][110], grid[110][110];\n\nvector< Point > search(int sx, int sy) {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< Point > que;\n\tque.push(Point(sx, sy, 0));\n\tvis[sy][sx] = 1;\n\t\n\tvector< Point > res;\n\tint mns = int(1e9);\n\t\n\twhile (!que.empty()) {\n\t\tPoint p = que.front(); que.pop();\n\t\t\n\t\tif (mns < p.s) break;\n\t\t\n\t\tif (grid[p.y][p.x]) {\n\t\t\tmns = p.s;\n\t\t\tres.push_back(p);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor_(d,0,6) {\n\t\t\tint nx = p.x + dx[d], ny = p.y + dy[d];\n\t\t\tif (nx <= 0 || W < nx || ny <= 0 || H < ny) continue;\n\t\t\tif (vis[ny][nx]) continue;\n\t\t\tvis[ny][nx] = 1;\n\t\t\tque.push(Point(nx, ny, p.s + 1));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main() {\t\n\twhile (cin >> W >> H, W) {\n\t\tmemset(grid, 0, sizeof(grid));\n\t\t\n\t\tcin >> S;\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tgrid[y][x] = 1;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tcin >> T;\n\t\tfor_(i,0,T) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tgrid[y][x] = 1;\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor_(yy,0,H) for_(xx,0,W) {\n\t\t\t\tvector< Point > vp = search(xx, yy);\n\t\t\t\tif (vp.size() > 1) continue;\n\t\t\t\t\n\t\t\t\tif (vp[0].x == x && vp[0].y == y) ++cnt;\n\t\t\t}\n\t\t\t\n\t\t\tgrid[y][x] = 0;\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 999999999\n\nint w,h,s,t;\nint f[102][102]; //eXÌèÌóµ\nint d[102][102]; //e}X©çêÔß¢XÖÌÅ¬£\nbool closed[102][102]; //Dæp\n\nint dx1[] = { 0, 1, 1, 1, 0,-1}; //ïñ©çÌJÚ\nint dy1[] = {-1,-1, 0, 1, 1, 0}; //ïñ\nint dx2[] = {-1, 0, 1, 0,-1,-1}; //ôñ\nint dy2[] = {-1,-1, 0, 1, 1, 0}; //ôñ\n\n//flg : }bvðhé©hçÈ¢©\nint draw(int x,int y,int id,bool flg){\n\tint res = 0;\n\tqueue<PP> q;\n\tmemset(closed,0,sizeof(closed));\n\n\tq.push(PP(P(x,y),0));\n\n\twhile(!q.empty()){\n\t\tPP p = q.front(); q.pop();\n\t\tint x = p.first.first;\n\t\tint y = p.first.second;\n\t\tif(closed[y][x]) continue;\n\t\tclosed[y][x] = true;\n\n\t\tif(d[y][x] == p.second && flg){\n\t\t\tf[y][x] = INF;\n\t\t}\n\t\telse if(d[y][x] > p.second){\n\t\t\tif(flg){\n\t\t\t\tf[y][x] = id;\n\t\t\t\td[y][x] = p.second;\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint nx = x + (y%2==1 ? dx1[i] : dx2[i]);\n\t\t\tint ny = y + (y%2==1 ? dy1[i] : dy2[i]);\n\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\tq.push(PP(P(nx,ny),p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h) rep(j,w) f[i][j] = d[i][j] = INF;\n\n\t\t//àÆ©ç éXÌèÌóµð}bvÉ«Þ\n\t\tcin>>s;\n\t\trep(i,s){\n\t\t\tint p,q;\n\t\t\tcin>>p>>q;\n\t\t\tdraw(p-1,q-1,i,true);\n\t\t}\n\n\t\t//eóânÉu¢½Æ«ÌóµðÀÛÉV~[g\n\t\tint ans = 0;\n\t\tcin>>t;\n\t\trep(i,t){\n\t\t\tint p,q;\n\t\t\tcin>>p>>q;\n\t\t\tans = max(ans,draw(p-1,q-1,i,false));\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\npair<int,int> maja(int x) {\n  if (x == 0) return pair<int,int>(0,0);\n  int n = static_cast<int>(ceil((-1.0+sqrt(1.0+4.0/3.0*x))/2.0));\n  int a = 3*n*(n-1), d = static_cast<int>(ceil((1.0*x-a)/n-1.0));\n  int k = x - a - n * d;\n  switch (d) {\n  case 0: return pair<int,int>(n-k,k);\n  case 1: return pair<int,int>(-k,n);\n  case 2: return pair<int,int>(-n,n-k);\n  case 3: return pair<int,int>(-n+k,-k);\n  case 4: return pair<int,int>(k,-n);\n  case 5: return pair<int,int>(n,-n+k);\n  }\n}\n\nint majadist(const pair<int,int> &a, const pair<int,int> &b) {\n  int dx = abs(a.first - b.first);\n  int dy = abs(a.second - b.second);\n  int dz = abs(a.first+a.second-b.first-b.second);\n  return min(dx+dy, min(dx+dz, dy+dz));\n}\n\nint main(){\n  int W,H;\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      stage[pair<int,int>(x,y)] = true;\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      int region = 0;\n      for(int x=0;x<W;x++){\n\tfor(int y=0;y<H;y++){\n\t  int min_dist = INF;\n\t  \n\t  for(map<pair<int,int>,bool>::iterator it = stage.begin();\n\t      it != stage.end();\n\t      it++){\n\t    min_dist = min(min_dist,majadist(it->first,pair<int,int>(x,y)));\n\t  }\n\t  \n\t  if(majadist(pair<int,int>(sx,sy),pair<int,int>(x,y)) < min_dist)\n\t    {\n\t      region++;\n\t    }\n\t}\n\tres = max(region,res);\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y & 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y & 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] < c + 1) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\tvector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y & 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y & 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || v[nx][ny] == 1) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\tv[nx][ny] = 1;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1, -1, 0, 1, 0, -1}, {-1, 0, 1, 1, 1, 0}};\nint dy[2][6] = {{0, -1, -1, 0, 1, 1},{0, -1, -1, 0, 1, 1}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n      if(ok)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n    \n      for(int i=0;i<10000000;i++);\n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n\nint main() {\n\tint m, n;\n\twhile(cin >> m >> n, m || n) {\n\t\tint s, t;\n\t\tvector<pii> v0, v1;\n\t\tcin >> s;\n\t\tfor(int i = 0; i < s; i++) {\n\t\t\tpii a;\n\t\t\tcin >> a.x >> a.y;\n\t\t\ta.x--; a.y--;\n\t\t\tv0.push_back(a);\n\t\t}\n\t\tcin >> t;\n\t\tfor(int i = 0; i < t; i++) {\n\t\t\tpii a;\n\t\t\tcin >> a.x >> a.y;\n\t\t\ta.x--; a.y--;\n\t\t\tv1.push_back(a);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < v1.size(); i++) {\n\t\t\tv0.push_back(v1[i]);\n\t\t\tint tmp = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tfor(int k = 0; k < m; k++) {\n\t\t\t\t\tbool valid = true;\n\t\t\t\t\tint val = -1;\n\t\t\t\t\tint mn = 10000;\n\t\t\t\t\tfor(int l = 0; l < v0.size(); l++) {\n\t\t\t\t\t\tint h;\n\t\t\t\t\t\tint w;\n\t\t\t\t\t\th = abs(v0[l].y - j);\n\t\t\t\t\t\tw = fabs((v0[l].x + (v0[l].y % 2) / 2.0) - (k + (j % 2) / 2.0)) - h / 2.0 + 1e-6;\n\t\t\t\t\t\tif(w < 0)\n\t\t\t\t\t\t\tw = 0;\n\t\t\t\t\t\tif(mn == h + w)\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\telse if(mn > h + w) {\n\t\t\t\t\t\t\tval = l;\n\t\t\t\t\t\t\tmn = h + w;\n\t\t\t\t\t\t\tvalid = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(valid && val == v0.size() - 1)\n\t\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, tmp);\n\t\t\tv0.pop_back();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint id,dist;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdist = arg_dist;\n\t}\n\tint row,col,dist;\n};\n\nint W,H;\nint diff_row_GU[6] = {-1,-1,0,0,1,1},diff_col_GU[6] = {-1,0,-1,1,-1,0};\nint diff_row_KI[6] = {-1,-1,0,0,1,1},diff_col_KI[6] = {0,1,-1,1,0,1};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn true;\n\t}\n}\n\nvoid func(){\n\n\tInfo map[H][W];\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tmap[row][col].dist = BIG_NUM;\n\t\t}\n\t}\n\n\tint num_conv;\n\tscanf(\"%d\",&num_conv);\n\n\tint tmp_col,tmp_row;\n\tint adj_row,adj_col;\n\n\tqueue<Data> Q;\n\n\tfor(int loop = 0; loop < num_conv; loop++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_col--;\n\t\ttmp_row--;\n\n\t\tmap[tmp_row][tmp_col].id = loop;\n\t\tmap[tmp_row][tmp_col].dist = 0;\n\n\t\tQ.push(Data(tmp_row,tmp_col,0));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row%2 == 0){\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_GU[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_GU[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\tmap[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\tmap[adj_row][adj_col].id = loop;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_KI[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_KI[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\tmap[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\tmap[adj_row][adj_col].id = loop;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tInfo work_map[H][W];\n\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tint maximum = 0;\n\n\tfor(int loop = 0; loop < T; loop++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_col--;\n\t\ttmp_row--;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\twork_map[row][col].id = map[row][col].id;\n\t\t\t\twork_map[row][col].dist = map[row][col].dist;\n\t\t\t}\n\t\t}\n\n\t\twork_map[tmp_row][tmp_col].id = 999;\n\t\twork_map[tmp_row][tmp_col].dist = 0;\n\n\t\tQ.push(Data(tmp_row,tmp_col,0));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row%2 == 0){\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_GU[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_GU[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(work_map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\twork_map[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\twork_map[adj_row][adj_col].id = 999;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_KI[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_KI[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(work_map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\twork_map[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\twork_map[adj_row][adj_col].id = 999;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tint tmp = 0;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(work_map[row][col].id == 999)tmp++;\n\t\t\t}\n\t\t}\n\t\tmaximum = max(maximum,tmp);\n\t}\n\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint fie[101][101];\nint cox[11],coy[11];\nint conx[11],cony[11];\nint m,n,s,sn;\nint ans=0;\nconst int dx1[6]={-1,-1,-1,0,1,0};\nconst int dx2[6]={0,-1,0,1,1,1};\nconst int dy[6]={-1,0,1,-1,0,1};\nconst int INF=100000;\n\nvoid bfs(int x,int y){\n\tqueue<PP> que;\n\tque.push(PP(0,P(x,y)));\n\tfie[x][y]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint v=p.first,kx=p.second.first,ky=p.second.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie[fx][fy]>v+1){\n\t\t\t\t\tque.push(PP(v+1,P(fx,fy)));\n\t\t\t\t\tfie[fx][fy]=v+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int x,int y,int fie2[101][101]){\n\tint res=1;\n\tif(fie2[x][y]==0)return 0;\n\tqueue<PP> que;\n\tque.push(PP(0,P(x,y)));\n\tfie2[x][y]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint v=p.first,kx=p.second.first,ky=p.second.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint fx=kx,fy=ky+dy[i];\n\t\t\tif(ky%2==1)fx+=dx1[i];\n\t\t\tif(ky%2==0)fx+=dx2[i];\n\t\t\tif(fx>=1 && fx<=m && fy>=1 && fy<=n){\n\t\t\t\tif(fie2[fx][fy]>v+1){\n\t\t\t\t\tque.push(PP(v+1,P(fx,fy)));\n\t\t\t\t\tres++;\n\t\t\t\t\tfie2[fx][fy]=v+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&m);\n\t\tif(m==0)break;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfie[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%d%d\",&cox[i],&coy[i]);\n\t\t\tbfs(cox[i],coy[i]);\n\t\t}\n\t\tscanf(\"%d\",&sn);\n\t\tfor(int i=0;i<sn;i++){\n\t\t\tscanf(\"%d%d\",&conx[i],&cony[i]);\n\t\t\tans=max(ans,bfs2(conx[i],cony[i],fie));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\n\nstruct Data{\n\tint y, x;\n\tbool is_deven;\n\tData(){}\n\tData(int _y, int _x, bool _is_deven){\n\t\ty = _y; x = _x; is_deven = _is_deven;\n\t}\n};\n\nint main(){\n\tint N, M, S, T, X[10], Y[10], P, Q;\n\twhile(cin >> N >> M, N || M){\n\t\tcin >> S;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\n\t\tcin >> T;\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> P >> Q;\n\t\t\tP--; Q--;\n\n\t\t\tqueue<Data> q;\n\t\t\tData q_front;\n\t\t\tbool used[100][100] = {};\n\t\t\tint deven_scope = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++){\n\t\t\t\tq.push( Data(Y[i], X[i], false) );\n\t\t\t}\n\t\t\tq.push( Data(Q, P, true) );\n\n\t\t\twhile( !q.empty() ){\n\t\t\t\tq_front = q.front(); q.pop();\n\n\t\t\t\tif(used[q_front.y][q_front.x]) continue;\n\t\t\t\tused[q_front.y][q_front.x] = true;\n\n\t\t\t\tif(q_front.is_deven) deven_scope++;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\t\tint nx = q_front.x + dx[q_front.y&1][i];\n\t\t\t\t\t\n\t\t\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\n\t\t\t\t\tq.push( Data(ny, nx, q_front.is_deven) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, deven_scope);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> grid;\n\nconst int INF = 1e9;\nconst int dx[6] = {0,1,1,1,0,-1}, dy[6] = {-1,-1,0,1,1,0};\nint h,w;\n\ngrid bfs(int y, int x){\n  grid res(h,vi(w,INF));\n  res[y][x] = 0;\n  queue<int> q;\n  q.push(y*w+x);\n  \n  while(q.size()){\n    y = q.front()/w; x = q.front()%w; q.pop();\n    int c = res[y][x];\n\n    for(int i=0;i<6;i++){\n      int ny = y+dy[i], nx = x+dx[i] + ((y%2==0 && i%3!=2)?-1:0);\n      if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n      if(res[ny][nx]>c+1){\n\tres[ny][nx] = c+1;\n\tq.push(ny*w+nx);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w, h){\n    grid g(h,vi(w,INF));\n\n    int s;\n    cin >> s;\n    for(int z=0;z<s;z++){\n      int a,b; cin >> a >> b; a--; b--;\n      grid tmp = bfs(b,a);\n\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)g[i][j] = min(g[i][j], tmp[i][j]);\n      }\n    }\n\n    int t, res = 0;\n    cin >> t;\n    for(int z=0;z<t;z++){\n      int a,b; cin >> a >> b; a--; b--;\n      grid tmp = bfs(b,a);\n      int cover = 0;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(g[i][j] > tmp[i][j])cover++;\n\t}\n      }\n      res = max(res, cover);\n    }\n    \n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int x,int y)\n{\n\n  deque<Pi> deq;\n  deq.push_back(Pi(P(x,y),0));\n  mincost[y][x] = 0;\n  visited[y][x] = true;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      Pi pi = deq.front(); deq.pop_front();\n\n      for(int i=0;i<6;i++)\n\t{\n\t  int nx = pi.first.first + dx[pi.first.second%2][i];\n\t  int ny = pi.first.second + dy[pi.first.second%2][i];\n\n\t  if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\t    continue;\n\n\t  if(mincost[ny][nx] > pi.second + 1)\n\t    {\n\t      if(!visited[ny][nx])\n\t\tcnt++;\n\t      visited[ny][nx] = true;\n\t      mincost[ny][nx] = pi.second + 1;\n\t      deq.push_back(Pi(P(nx,ny),pi.second+1));\n\t    }\n\t}\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      cerr << n << \" \";\n      if(!n) break;\n      cerr << m << endl;\n      cin >> m;\n      for(int i=0;i<n;i++) \n\tfor(int j=0;j<m;j++)\n\t  mincost[i][j] = (1<<29);  \n     \n      int s,t,mex = 1;\n      scanf(\"%d\",&s);\n      cerr << s << endl;\n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  cerr << x << \" \" << y <<endl;\n\t  x--,y--;\n\t  mincost[y][x] = 0;\n\t  dfs(x,y);\n\t}\n     \n      scanf(\"%d\",&t);\n      cerr << t << endl;\n      for(int i=0;i<t;i++)\n\t{   \n\t  int pre_mincost[n][m];\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cerr << p << \" \" << q << endl;\n\t  p--,q--;\n\t  dfs(p,q);\n\t  \n\t  mex = max(mex,cnt);\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = pre_mincost[j][k];\n\t}\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;//x, y\ntypedef pair<int, pii> piii;//cost, x, y\nint dx[6] = {1, 1, 1, 0, -1, 0},\n  dy[6] = {-1, 0, 1, 1, 0, -1};\nint grid[110][110];\nint n, m, a;\n\nint bfs(int grid[110][110], int sx, int sy){\n  queue<piii> que;\n  int ans = 0;\n  grid[sy][sx] = 0;\n  que.push(mp(0, mp(sx, sy)));\n  while(!que.empty()){\n    piii p = que.front();que.pop();\n    int cost = p.first;\n    int x    = p.second.first;\n    int y    = p.second.second;\n    for (int i = 0; i < 6; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(0 <= ny && ny < n &&\n         0 <= nx && nx < m &&\n         grid[ny][nx] > cost + 1){\n        ans++;\n        grid[ny][nx] = cost + 1;\n        que.push(mp(cost + 1, mp(nx, ny)));\n      }\n    }\n  }\n  // for (int i = 0; i < n; i++) {\n  //   for (int j = 0; j < m; j++) {\n  //     std::cout << grid[i][j] << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // std::cout << std::endl;\n\n  return ans;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> m >> n, n){\n    int ans = 0, t;\n    cin >> a;\n    int sx[a], sy[a];\n    for (int i = 0; i < a; i++) {\n      cin >> sx[i] >> sy[i];\n      sx[i]--;sy[i]--;\n    }\n    cin >> t;\n    int px[t], py[t];\n    for (int i = 0; i < t; i++) {\n      cin >> px[i] >> py[i];\n      px[i]--;py[i]--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        grid[i][j] = 1e8;\n      }\n    }\n    \n    for (int i = 0; i < a; i++) {\n      bfs(grid, sx[i], sy[i]);\n    }\n\n    for (int i = 0; i < t; i++) {\n      int tmp[110][110];\n      \n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < m; k++) {\n          tmp[j][k] = grid[j][k];\n        }\n      }\n      \n      ans = max(ans, bfs(tmp, px[i], py[i]));\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n  visited[sy][sx] = 1;\n  int res = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    if(v[y][x] > n) ++res;\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n      visited[y][x] = 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n  return res;\n}\n\n//int count(int y, int x, int n, vector< vector<int> > &v, vector< vector<bool> > &visited, bool f){\n//  int res = 1;\n//  if(!f && v[y][x] <= n) res = 0;\n//  int t = (y % 2 == 0);\n//  visited[y][x] = 1;\n//  REP(i, 6){\n//    int ny = y + my[t][i], nx = x + mx[t][i];\n//    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n//    res += count(ny, nx, n + 1, v, visited, 1);\n//  }\n//  return res;\n//}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      res = max(res, count(y, x, v));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[2][6]={{1,0,-1,-1,-1,0},{1,1,0,-1,0,1}};\nconst int dy[6]={0,-1,-1,0,1,1};\nint dis[100][100];\nbool land[100][100];\n\nint main(){\n\tfor(int m,n;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++)\tland[i][j]=false,dis[i][j]=1<<30;\n\n\t\tint s;\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++){\n\t\t\tint px,py;\tscanf(\"%d%d\",&px,&py);\n\t\t\tpx--,py--;\n\t\t\tland[py][px]=true;\n\n\t\t\tdis[py][px]=0;\n\t\t\tqueue<pii> qu;\tqu.push(mp(py,px));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tpii a=qu.front();\tqu.pop();\n\t\t\t\tint y=a.first,x=a.second;\n\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\tint yy=y+dy[k],xx=x+dx[y%2][k];\n\t\t\t\t\tif(0<=yy && yy<m && 0<=xx && xx<n){\n\t\t\t\t\t\tif(dis[y][x]+1<dis[yy][xx]){\n\t\t\t\t\t\t\tqu.push(mp(yy,xx));\n\t\t\t\t\t\t\tdis[yy][xx]=dis[y][x]+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint t,ans=0;\tscanf(\"%d\",&t);\n\t\twhile(t--){\n\t\t\tstatic int tmp[100][100];\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++)\ttmp[i][j]=1<<30;\n\n\t\t\tint px,py;\tscanf(\"%d%d\",&px,&py);\n\t\t\tpx--,py--;\n\t\t\tif(dis[py][px]==0)\tcontinue;\n\n\t\t\tint cnt=0;\n\t\t\ttmp[py][px]=0;\n\t\t\tqueue<pii> qu;\tqu.push(mp(py,px));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tpii a=qu.front();\tqu.pop();\n\t\t\t\tint y=a.first,x=a.second;\n\t\t\t\tcnt++;\n\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\tint yy=y+dy[k],xx=x+dx[y%2][k];\n\t\t\t\t\tif(0<=yy && yy<m && 0<=xx && xx<n){\n\t\t\t\t\t\tif(tmp[y][x]+1<tmp[yy][xx] && tmp[y][x]+1<dis[yy][xx]){\n\t\t\t\t\t\t\tqu.push(mp(yy,xx));\n\t\t\t\t\t\t\ttmp[yy][xx]=tmp[y][x]+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans=max(ans,cnt);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\n    public:\n        int x, y;\n        coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{0, -1, 0, 1, 1, 1}, {-1, -1, -1, 0, 1, 0}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(H+1, vector<pii>(W+1, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint h = in.nextInt(), w = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] != INF) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\trep(i, 110) rep (j, 110) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v, vector< vector<bool> > &visited, bool f){\n  int res = 1;\n  if(!f && v[y][x] <= n) res = 0;\n  int t = (y % 2 == 0);\n  visited[y][x] = 1;\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n    res += count(ny, nx, n + 1, v, visited, 1);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n      res = max(res, count(y, x, 0, v, visited, 0));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\n\nstruct Data{\n\tint y, x;\n\tbool is_deven;\n\tData(){}\n\tData(int _y, int _x, bool _is_deven){\n\t\ty = _y; x = _x; is_deven = _is_deven;\n\t}\n};\n\nint main(){\n\tint N, M, S, T, X[10], Y[10], P, Q;\n\twhile(cin >> N >> M, N || M){\n\t\tcin >> S;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\t\tcin >> T;\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> P >> Q;\n\t\t\tP--; Q--;\n\n\t\t\tqueue<Data> q;\n\t\t\tData q_front;\n\t\t\tint deven_scope = 0;\n\t\t\tbool used[100][100] = {}, deven_map[100][100] = {};\n\n\t\t\tfor(int i = 0; i < S; i++){\n\t\t\t\tq.push( Data(Y[i], X[i], false) );\n\t\t\t}\n\t\t\tq.push( Data(Q, P, true) );\n\n\t\t\twhile( !q.empty() ){\n\t\t\t\tq_front = q.front(); q.pop();\n\t\t\t\tif(used[q_front.y][q_front.x]) continue;\n\t\t\t\tif(q_front.is_deven){\n\t\t\t\t\tdeven_scope++;\n\t\t\t\t\tdeven_map[q_front.y][q_front.x] = true;\n\t\t\t\t\tprintf(\"%d, %d\\n\", q_front.y, q_front.x);\n\t\t\t\t}\n\n\t\t\t\tused[q_front.y][q_front.x] = true;\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\t\tint nx = q_front.x + dx[q_front.y&1][i];\n\t\t\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\t\t\t\t\tq.push( Data(ny, nx, q_front.is_deven) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, deven_scope);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> _P;\ntypedef pair<_P,int> P;\nint color[100][100],tmp[100][100];\nbool vst[100][100];\nint dx0[]={0,1,0,-1,-1,-1},dy0[]={-1,0,1,1,0,-1};\nint dx1[]={1,1,1,0,-1,0},dy1[]={-1,0,1,1,0,-1};\nint m,n;\nint coloring(int color[100][100],int x,int y) {\n\tmemset(vst,0,sizeof(vst));\n\tqueue<P> Q;\n\tQ.push(P(_P(x,y),0));\n\tvst[x][y]=true;\n\tint sum=0;\n\twhile(!Q.empty()) {\n\t\tP p=Q.front();Q.pop();\n\t\t_P _p=p.first;\n\t\tif(color[_p.first][_p.second]<=p.second) continue;\n\t\tcolor[_p.first][_p.second]=p.second;\n\t\tsum++;\n\t\tint *dx,*dy;\n\t\tif(_p.second&1) dx=dx1,dy=dy1;\n\t\telse dx=dx0,dy=dy0;\n\t\tfor(int i=0;i<6;i++) {\n\t\t\tint nx=_p.first+dx[i],ny=_p.second+dy[i];\n\t\t\tif(0>nx||nx>=m||0>ny||ny>=n)continue;\n\t\t\tif(vst[nx][ny])continue;\n\t\t\tvst[nx][ny]=true;\n\t\t\tQ.push(P(_P(nx,ny),p.second+1));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tint s,t,x,y;\n\twhile(scanf(\"%d\",&m),m) {\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++)color[j][i]=1<<30;\n\t\t}\n\t\tscanf(\"%d\",&s);\n\t\tfor(int i=0;i<s;i++) {\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tcoloring(color,x-1,y-1);\n\t\t}\n\t\tscanf(\"%d\",&t);\n\t\tint ans=0;\n\t\tfor(int i=0;i<t;i++) {\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tmemcpy(tmp,color,sizeof(color));\n\t\t\tans=max(ans,coloring(tmp,x-1,y-1));\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\n\nint main(void){\n  Place field, others[10], p;\n  int size[10];\n  int s, t, i;\n\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    others[s].x = -1;\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n      others[i].x -= 1;\n      others[i].y -= 1;\n    }\n    scanf(\"%d\", &t);\n    size[t] = -1;\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      p.x -= 1;\n      p.y -= 1;\n      size[i] = countSize(p, others, field);\n    }\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0, a, b;\n  for(p.x = 0; p.x < field.x; p.x++){\n    for(p.y = 0; p.y < field.y; p.y++){\n      a = howLong(shop, p);\n      b = minOthersLong(others, p);\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return abs(y - 1) / 2 - m + 1;\n    }\n    else{\n      return abs(y - 1) / 2 + m;\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[i], p);\n  for(i = 1; others[i].x != -1; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    V.clear();\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( node ) == V.end() ) {\n            V.insert( node );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int, int> pii;\n\nint dist(pii a, pii b) {\n  int res = abs(a.second-b.second);\n  int r = (res + 1) / 2;\n  if (!(a.second % 2 ^ b.second % 2)) {\n    if (b.first < a.first - r || a.first + r < b.first)\n      res += min(abs(b.first - (a.first-r)), abs(b.first - (a.first+r)));\n  } else if (a.second % 2) {\n    if (b.first < a.first - r || a.first + r - 1 < b.first)\n      res += min(abs(b.first - (a.first-r)), abs(b.first - (a.first+r-1)));    \n  } else {\n    if (b.first < a.first - r+1 || a.first + r < b.first)\n      res += min(abs(b.first - (a.first-r+1)), abs(b.first - (a.first+r)));\n  }\n  return res;\n}\n\nint main() {\n  int m, n;\n  while(cin >> m, m) {\n    cin >> n;\n    int s;\n    cin >> s;\n    pii shop[s+1];\n    REP(i,s) {\n      int x, y;\n      cin >> x >> y;\n      shop[i] = pii(x,y);\n    }\n    int t;\n    cin >> t;\n    int ans = 0;\n    REP(j,t) {\n      int p, q;\n      cin >> p >> q;\n      shop[s] = pii(p,q);\n      int res = 0;\n      for(int y=1;y<=n; ++y) {\n        for(int x=1;x<=m; ++x) {\n          int mi = INF;\n          int hoge = -1;\n          REP(i, s+1) {\n            if (mi > dist(pii(x,y), shop[i])) {\n              mi = dist(pii(x,y), shop[i]);\n              hoge = i;\n            } else if (mi == dist(pii(x,y), shop[i])) {\n              hoge = -1;\n            }\n          }\n          //   cout << hoge << \" \";\n          if (hoge == s) res++;\n        }\n//        cout << endl;\n      }\n      //     cout << res << endl;\n      ans = max(ans, res);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=a&&a<b)\n#define INF 1<<30\nusing namespace std;\nint dx0[]={0,1,0,-1,-1,-1},dx1[]={1,1,1,0,-1,0},dy[]={-1,0,1,1,0,-1};\nint md[100][100],td[100][100],s,t,sx[10],sy[10],tx[10],ty[10],m,n,tc,mc;\nvoid rec(int x,int y,int a){\n\ttd[x][y]=a;\n\trep(d,6){\n\t\tint nx=x+(y%2?dx1[d]:dx0[d]),ny=y+dy[d];\n\t\tif(ck(nx,m)&&ck(ny,n)&&td[nx][ny]>a+1)rec(nx,ny,a+1);\n\t}\n}\nint main(){\n\twhile(cin>>m>>n>>s,m){\n\t\trep(i,m)rep(j,n)md[i][j]=INF;\n\t\trep(i,s)cin>>sx[i]>>sy[i],sx[i]--,sy[i]--;\n\t\tcin>>t; rep(i,t)cin>>tx[i]>>ty[i],tx[i]--,ty[i]--;\n\t\trep(i,s){\n\t\t\trep(k,m)rep(l,n)td[k][l]=INF;\n\t\t\trec(sx[i],sy[i],0);\n\t\t\trep(k,m)rep(l,n)if(md[k][l]>td[k][l])md[k][l]=td[k][l];\n\t\t}\n\t\tmc=0; rep(i,t){\n\t\t\ttc=0;\n\t\t\trep(k,m)rep(l,n)td[k][l]=INF;\n\t\t\trec(tx[i],ty[i],0);\n\t\t\trep(k,m)rep(l,n)if(md[k][l]>td[k][l])tc++;\n\t\t\tif(mc<tc)mc=tc;\n\t\t}\n\t\tcout<<mc<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n  visited[sy][sx] = 1;\n  int res = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    if(v[y][x] > n) ++res;\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n      visited[y][x] = 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      res = max(res, count(y, x, v));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\n\nint m, n, s;\nint min_cost[100][100];\nbool used[100][100];\nint dy[] = { -1, -1, 0, 1, 1, 0};\nint dx[][6] = {{ -1, 0, 1, 0, -1, -1}, { 0, 1, 1, 1, 0, -1}};\n\nbool isover(int y, int x){\n  return y < 0 || y >= n || x < 0 || x >= m;\n}\n\nvoid bfs(int y, int x){\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  min_cost[y][x] = 0;\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] < p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      min_cost[ny][nx] = p.fr + 1;\n    }\n  }\n}\n\nint prebfs(int y, int x){\n  if(!min_cost[y][x]) return 0;\n\n  int ret = 1;\n  fill_n( *used, 10000, false);\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  used[y][x] = true;\n\n\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || used[ny][nx] || min_cost[ny][nx] <= p.fr + 1) continue;\n        que.push(Pii( p.fr + 1, Pi( ny, nx)));\n        used[ny][nx] = true;\n        ret++;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> m, m){\n    queue< Pii > que;\n    fill_n( *min_cost, 10000, 1 << 30);\n\n    cin >> n >> s;\n\n    for(int i = 0 ; i < s ; i++ ){\n      int x, y;\n      cin >> x >> y;\n      bfs( y - 1, x - 1);\n    }\n\n    int t, ret = 0;\n    cin >> t;\n    while(t--){\n      int p, q;\n      cin >> p >> q;\n      ret = max( ret,prebfs( q - 1, p - 1));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nint h,w;\nint n;\nint m;\nvector<pii> pos;\nvector<pii> hoge;\n\nbool input(){\n\tcin>>w>>h;\n\tif(w==0)return false;\n\tcin>>n;\n\tpos.resize(n);\n\trep(i,n){\n\t\tcin>>pos[i].fi>>pos[i].se;\n\t\tpos[i].fi--;\n\t\tpos[i].se--;\n\t}\n\tcin>>m;\n\thoge.resize(m);\n\trep(i,m){\n\t\tcin>>hoge[i].fi>>hoge[i].se;\n\t\thoge[i].fi--;\n\t\thoge[i].se--;\n\t}\n\treturn true;\n}\n\nint dist(pii a, pii b){\n\t\n\ta.fi += -(a.se)/2;\n\tb.fi += -(b.se)/2;\n\t\n\tif(a.se > b.se)swap(a,b);\n\t\n\tb.fi -= a.fi;\n\tb.se -= a.se;\n\t\n\tint ret = 0;\n\tif(b.fi >= 0){\n\t\tret = b.fi + b.se;\n\t}else if(b.se >= -b.fi){\n\t\tret = b.se;\n\t}else{\n\t\tret = -b.fi;\n\t}\n\t\n\t\n\treturn ret;\n}\n\nint solve2(int x,int y){\n\t\n\tint ret = 0;\n\tvector<pii> cand = pos;\n\tcand.push_back(pii(x,y));\n\t\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tconst int INF = 1111;\n\t\t\tint cnt = 0;\n\t\t\tint mini = INF;\n\t\t\tint minp = -1;\n\t\t\trep(k, cand.size()){\n\t\t\t\tint d = dist(pii(j,i), cand[k]);\n\t\t\t\t\n\t\t\t\tif(d==mini){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tif(d<mini){\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tmini = d;\n\t\t\t\t\tminp = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(cnt==1 && minp==pos.size()){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint solve(){\n\tint ret = 0;\n\t\n\trep(i,m){\n\t\t\n\t\tint val = solve2(hoge[i].fi,hoge[i].se);\n\t\tret = max(ret, val);\n\t}\n\t\n\treturn ret;\n}\n\nvoid call(){\n\tcout<<solve()<<endl;\n}\n\nint main(){\n\twhile(input())call();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    V.clear();\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( !V.count( PII( x, y ) ) ) {\n            V.insert( PII( x, y ) );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint countC(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n  visited[sy][sx] = 1;\n  int res = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    if(v[y][x] > n) ++res;\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n      visited[ny][nx] = 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int ans = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      ans = max(ans, countC(y, x, v));\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[100][100];\nint grid[100][100];\nint grid2[100][100];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 200; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--y][--x] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tg[--q][--p] |= 1;\n\t\t\tmaxi = max(maxi, solve());\n\t\t\tg[q][p] -= 1;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\n\nint m, n, s;\nint min_cost[100][100];\nint dy[] = { -1, -1, 0, 1, 1, 0};\nint dx[][6] = {{ -1, 0, 1, 0, -1, -1}, { 0, 1, 1, 1, 0, -1}};\n\nbool isover(int y, int x){\n  return y < 0 || y >= n || x < 0 || x >= m;\n}\n\nvoid bfs(queue< Pii >& que){\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] < p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      min_cost[ny][nx] = p.fr + 1;\n    }\n  }\n}\n\nint prebfs(int y, int x){\n  int ret = 0;\n  bool used[100][100] = {{}};\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n\n  if(!min_cost[y][x]) return 0;\n\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    if(used[p.sc.fr][p.sc.sc]++) continue;\n    ret++;\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] <= p.fr + 1) continue;\n\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> m, m){\n    queue< Pii > que;\n    fill_n( *min_cost, 10000, 1 << 30);\n\n    cin >> n >> s;\n\n    for(int i = 0 ; i < s ; i++ ){\n      int x, y;\n      cin >> x >> y;\n      que.push( Pii( 0, Pi( y - 1, x - 1)));\n      min_cost[y - 1][x - 1] = 0;\n    }\n    bfs(que);\n\n    int t, ret = 0;\n    cin >> t;\n    while(t--){\n      int p, q;\n      cin >> p >> q;\n      ret = max( ret,prebfs( q - 1, p - 1));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x-1,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y % 2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[101][101];\nint id_list[101][101];\nint candidate_cost[101][101];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    min_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    candidate_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(s.x,s.y,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,m;\n  int s,t;\n  int x,y;\n  int grid[101][101];\n\n  while(cin >> n && n){\n    cin >> m;\n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=m;j++)grid[i][j] = 1<<25;\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      int hoge = 1;\n      int tmp[101][101];\n      copy(grid,grid+(n+1)*(m+1),tmp);\n\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    hoge++;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n      ans = max(ans,hoge);\n      copy(tmp,tmp+(n+1)*(m+1),grid);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ninline int dist(int x1,int y1,int x2,int y2)\n{\n\tif(y1>y2){\n\t\tswap(x1,x2);\n\t\tswap(y1,y2);\n\t}\n\t\n\tint dy=y2-y1;\n\tif(y1&1)\n\t\treturn max(max(x2-x1-dy/2,x1-x2-(dy+1)/2),0)+dy;\n\telse\n\t\treturn max(max(x2-x1-(dy+1)/2,x1-x2-dy/2),0)+dy;\n}\n\nint main()\n{\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tint s; scanf(\"%d\",&s);\n\t\tvector<int> xs(s),ys(s);\n\t\tfor(int i=0;i<s;i++)\n\t\t\tscanf(\"%d%d\",&xs[i],&ys[i]);\n\t\tint t; scanf(\"%d\",&t);\n\t\tint res=0;\n\t\twhile(t--){\n\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t\tint tmp=0;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tint d=1<<29;\n\t\t\t\t\tfor(int k=0;k<s;k++)\n\t\t\t\t\t\td=min(d,dist(xs[k],ys[k],j,i));\n\t\t\t\t\tif(d>dist(x,y,j,i))\n\t\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(tmp,res);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef long long int ll;\n\nint n, m;\nint dox[6] = {1, 1, 1, 0, -1, 0};\nint doy[6] = {-1, 0, 1, -1, 0, 1};\nint dex[6] = {-1, -1, -1, 0, 1, 0};\nint dey[6] = {-1, 0, 1, -1, 0, 1};\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\nint solve(int x,int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\n\nint main()\n{\n    while (cin >> n >> m, (n|m)) {\n        int s, t;\n        vector<vector<int> > g(n, vector<int>(m, 0));\n        vector<vector<bool> > pos(n, vector<bool>(m, false));\n        cin >> s;\n        for (int i = 0; i < s; i++) {\n            int x, y;\n            cin >> x >> y;\n            pos[y-1][x-1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                //cout << \"===\" << i << j << \"===\" << endl;\n                g[i][j] = bfs(i, j, g, pos);\n                \n            }\n            //cout << endl;\n        }\n        cin >> t;\n        int ans = -INF;\n        for (int i = 0; i < t; i++) {\n            int x, y;\n            cin >> x >> y;\n            ans = max(solve(y-1, x-1, g, pos), ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint solve(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0, dist = 0;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front(); a.pop();\n            x = tmp.first; y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (dist < g[x][y]) {\n                ret++;\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n\t                    int nx = x + dox[i];\n    \t                int ny = y + doy[i];\n        \t            if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }\n                \t} else {\n\t                    int nx = x + dex[i];\n    \t                int ny = y + dey[i];\n        \t            if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }                \t\t\n                \t}\n                }\n            }\n        }\n        a = b;\n        b = c;\n        dist++;\n    }\n    return ret;\n}\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0;\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front();\n            a.pop();\n            x = tmp.first;\n            y = tmp.second;\n            if (pos[x][y]) {\n                return ret;\n            } else {\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n    \t                int nx = x + dox[i];\n        \t            int ny = y + doy[i];\n            \t        if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t} else {\n    \t                int nx = x + dex[i];\n        \t            int ny = y + dey[i];\n            \t        if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t}\n                }\n            }\n        }\n        ret++;\n        a = b;\n        b = c;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 10000000;\n\nclass Node {\npublic:\n    int y, x, depth;\n    Node(int y, int x, int d) :y(y), x(x), depth(d) {}\n};\n\ntypedef tuple<int, int> Point;\n\nenum {EVEN, ODD};\nenum {Y, X};\nconst int NEXT[2][6][2] = {\n    {\n        {0, -1},\n        {-1, -1},\n        {-1, 0},\n        {0, 1},\n        {1, -1},\n        {1, 0},\n    },\n    {\n        {0, -1},\n        {-1, 0},\n        {-1, 1},\n        {0, 1},\n        {1, 0},\n        {1, 1},\n    },\n};\n\nint bfs(vector<vector<int>>& hex, int y, int x, bool write) {\n    int h = hex.size(), w = hex[0].size();\n    int result = 0;\n    set<Point> visited;\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front();\n        q.pop();\n        if(visited.count(Point(current.y, current.x))) continue;\n        visited.insert(Point(current.y, current.x));\n        if(hex[current.y][current.x] <= current.depth) continue;\n        if(write) hex[current.y][current.x] = current.depth;\n        ++result;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int m, n;\n    int s, t;\n    int x, y;\n    while(cin >> m >> n, m | n) {\n        vector<vector<int>> hex(n, vector<int>(m, INF));\n        for(cin >> s; s > 0; --s) {\n            cin >> x >> y;\n            bfs(hex, y - 1, x - 1, true);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            cin >> x >> y;\n            answer = max(answer, bfs(hex, y - 1, x - 1, false));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] != INF) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = d[a][b] == 0 ? 0 : 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\trep(i, 110) rep (j, 110) used[i][j] = false;\n\t\t\tused[a][b] = true;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t\t//cout<<\" \"<<tmp<<endl;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h + 1){\n\t\t// \trep(j, w + 1){\n\t\t// \t\tif(d[j][i] == INF) printf(\"   \");\n\t\t// \t\telse if(i & 1) printf(\"%2d \", d[j][i]);\n\t\t// \t\telse printf(\" %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\n\n/** Problem0193 : Deven-Eleven **/\nint field[100][100];\nint d[100][100];\nbool vis[100][100];\nconst int dx0[6]={0, 1, 1, 1, 0, -1}, dy0[6]={-1, -1, 0, 1, 1, 0};\nconst int dx1[6]={-1, 0, 1, 0, -1, -1}, dy1[6]={-1, -1, 0, 1, 1, 0};\n\nint main()\n{\n\tint n, m, s, t;\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(field[0], field[0]+100*100, -1);\n\t\tfill(d[0], d[0]+100*100, INF);\n\t\t\n\t\tcin >> s;\n\t\trep(k, s) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tfield[x][y] = k;\n\t\t\t\n\t\t\tfill(vis[0], vis[0]+100*100, false);\n\t\t\tqueue<P> Q;\n\t\t\tqueue<int> dis;\n\t\t\tQ.push(P(x, y));\n\t\t\tdis.push(0);\n\t\t\t\n\t\t\twhile (Q.size()) {\n\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\tint dd = dis.front(); dis.pop();\n\t\t\t\t\n\t\t\t\tif (vis[p.first][p.second])continue;\n\t\t\t\tvis[p.first][p.second]=true;\n\t\t\t\t\n\t\t\t\td[p.first][p.second] = min(dd, d[p.first][p.second]);\n\t\t\t\t\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tif (p.second%2==1) {\n\t\t\t\t\t\tnx = p.first+dx0[i]; ny = p.second+dy0[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnx = p.first+dx1[i]; ny = p.second+dy1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (0<=nx&&nx<m && 0<=ny&&ny<n && !vis[nx][ny]) {\n\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\tdis.push(dd+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\t\n\t\tcin >> t;\n\t\tint ans=0;\n\t\t\n\t\trep(k, t) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tfill(vis[0], vis[0]+100*100, false);\n\t\t\tqueue<P> Q;\n\t\t\tqueue<int> dis;\n\t\t\tQ.push(P(x, y));\n\t\t\tdis.push(0);\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\twhile (Q.size()) {\n\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\tint dd = dis.front(); dis.pop();\n\t\t\t\t\n\t\t\t\tif (vis[p.first][p.second])continue;\n\t\t\t\tvis[p.first][p.second] = true;\n\t\t\t\t\n\t\t\t\tif (dd<d[p.first][p.second])\n\t\t\t\t\tcnt++;\n\t\t\t\t\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tif (p.second%2==1) {\n\t\t\t\t\t\tnx = p.first+dx0[i]; ny = p.second+dy0[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnx = p.first+dx1[i]; ny = p.second+dy1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (0<=nx&&nx<m && 0<=ny&&ny<n && !vis[nx][ny]) {\n\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\tdis.push(dd+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\n    public:\n        int x, y;\n        coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{0, -1, 0, 1, 1, 1}, {-1, -1, -1, 0, 1, 0}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(101, vector<pii>(101, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n  visited[sy][sx] = 1;\n  int res = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    if(v[y][x] > n) ++res;\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n      visited[y][x] = 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int ans = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      ans = max(ans, count(y, x, v));\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int e_dx[] = {0, 1, 1, 1, 0, -1};\nconst int e_dy[] = {-1, -1, 0, 1, 1, 0};\nconst int o_dx[] = {-1, 0, 1, 0, -1, -1};\nconst int o_dy[] = {-1, -1, 0, 1, 1, 0};;\n\nint m, n;\nint place[102][102];\n\nclass state {\npublic:\n    int x, y;\n    int cnt;\n    state(int a, int b, int c) { x = a; y = b; cnt = c; }\n};\n\nvoid init()\n{\n    for (int y = 1; y <= n; y++)\n        for (int x = 1; x <= m; x++)\n            place[y][x] = INT_MAX;\n\n    int s;\n    cin >> s;\n    for (int i = 0; i < s; i++) {\n        int x, y;\n\n        cin >> x >> y;\n        place[y][x] = 0;\n        state s(x, y, 0);\n        queue<state> q;\n        q.push(s);\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx, ny;\n                if (now.y % 2) {\n                    nx = now.x + o_dx[i];\n                    ny = now.y + o_dy[i];\n                }\n                else {\n                    nx = now.x + e_dx[i];\n                    ny = now.y + e_dy[i];\n                }\n\n                if (nx < 1 || nx > m || ny < 1 || ny > n)\n                    continue;\n                if (now.cnt + 1 < place[ny][nx]) {\n                    place[ny][nx] = now.cnt + 1;\n                    state tmp(nx, ny, now.cnt + 1);\n                    q.push(tmp);\n                }\n            }\n        }\n    }\n}\n\n\nvoid bfs()\n{\n    int t;\n    int ans = 0;\n\n    cin >> t;\n    while (t--) {\n        int p, q;\n        map<pair<int, int>, bool > ma;\n        int num = 0;\n\n        cin >> p >> q;\n        state s(p, q, 0);\n        queue<state> qu;\n        ma[pair<int, int>(p, q)] = true;\n        qu.push(s);\n\n        while (!qu.empty()) {\n            state now = qu.front();\n            qu.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx, ny;\n                if (now.y % 2) {\n                    nx = now.x + o_dx[i];\n                    ny = now.y + o_dy[i];\n                }\n                else {\n                    nx = now.x + e_dx[i];\n                    ny = now.y + e_dy[i];\n                }\n\n                if (nx < 1 || nx > m || ny < 1 || ny > n)\n                    continue;\n                if (ma.count(pair<int, int>(nx, ny)) != 0)\n                    continue;\n                if (now.cnt + 1 < place[ny][nx]) {\n                    num++;\n                    state tmp(nx, ny, now.cnt + 1);\n                    qu.push(tmp);\n                    ma[pair<int, int>(nx, ny)] = true;\n                }\n            }\n        }\n        ans = max(ans, num + 1);\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    while (cin >> m >> n, m) {\n        init();        \n        bfs();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int even_di[] = {-1,-1,0,0,1,1};\nconst int even_dj[] = {0,1,-1,1,0,1};\nconst int odd_di[] = {-1,-1,0,0,1,1};\nconst int odd_dj[] = {-1,0,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  set<pair<int,int> > vis;\n  qpi.push( State(i,j,0) );\n\n  vis.insert(make_pair(i,j));\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(even_di)/sizeof(*even_di); ++i){\n      int ti = now.i + ( now.i%2==0 ? even_di[i] : odd_di[i] );\n      int tj = now.j + ( now.i%2==0 ? even_dj[i] : odd_dj[i] );\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( vis.find( make_pair( ti, tj ) ) != vis.end() ) continue;\n      \n      vis.insert( make_pair( ti, tj ) );\n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n\n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n    \n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nvoid bfs(int sx, int sy, int d[111][111]){\n  const int W = 110;\n  const int H = 110;\n  REP(y, H) REP(x, W) d[y][x] = INF;\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  d[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    if(y % 2 == 0){\n      int dx[6] = {-1, 0, 1, 0, -1, -1};\n      int dy[6] = {-1, -1, 0, 1, 1, 0};\n      REP(r, 6) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && d[ny][nx] > d[y][x] + 1){\n          d[ny][nx] = d[y][x] + 1;\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }else{\n      int dx[6] = {0, 1, 1, 1, 0, -1};\n      int dy[6] = {-1, -1, 0, 1, 1, 0};\n      REP(r, 6) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && d[ny][nx] > d[y][x] + 1){\n          d[ny][nx] = d[y][x] + 1;\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int W, H;\n  while(cin >> W >> H && W){\n    int N;\n    int tx[10], ty[10];\n    cin >> N;\n    REP(i, N) cin >> tx[i] >> ty[i];\n    int dist[11][111][111];\n    REP(i, N){\n      bfs(tx[i], ty[i], dist[i]);\n    }\n    int ans = 0;\n    int M; cin >> M;\n    REP(i, M){\n      int nx, ny; cin >> nx >> ny;\n      bfs(nx, ny, dist[N]);\n      int cnt = 0;\n      REP(y, H)REP(x, W){\n        bool ok = true;\n        REP(j, N) if(dist[N][y][x] >= dist[j][y][x]) ok = false;\n        if(ok) cnt++;\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct pos\n{\n\tint x,y,cost;\n\tbool operator ()(pos const& a, pos const& b) const\n\t{\n\t\treturn a.cost>b.cost;\n\t}\n\n}pos;\n\nint M,N,S,T,m[101][101],i,j,p,q,R,t;\n\nint bfs(int x,int y,int abj)\n{\n\tint i,c=1,mx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}},\n\t\t\t  my[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\n\tpriority_queue<pos,vector<pos>,pos>Q;\n\tm[y][x]=0;\n\tpos tmp={x,y,0};\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tfor(i=0;i<abj;i++)\n\t\t{\n\t\t\tif(0<=tmp.y+my[tmp.y%2][i]&&tmp.y+my[tmp.y%2][i]<M&&0<=tmp.x+mx[tmp.y%2][i]&&tmp.x+mx[tmp.y%2][i]<N)\n\t\t\t\tif(m[tmp.y+my[tmp.y%2][i]][tmp.x+mx[tmp.y%2][i]]>tmp.cost+1)\n\t\t\t\t{\n\t\t\t\t\tm[tmp.y+my[tmp.y%2][i]][tmp.x+mx[tmp.y%2][i]]=tmp.cost+1;\n\t\t\t\t\tpos tmp2={tmp.x+mx[tmp.y%2][i],tmp.y+my[tmp.y%2][i],tmp.cost+1};\n\t\t\t\t\tc++;\n\t\t\t\t\tQ.push(tmp2);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tfor(i=0;i<100;i++)\n\t\tfor(j=0;j<100;j++)\n\t\t{\n\n\t\t}\n\tfor(;~scanf(\"%d%d%d\",&M,&N,&S),M;)\n\t{\n\t\tmemset(m,0x7,sizeof(m));\n\t\tfor(i=0;i<S;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tbfs(p-1,q-1,6);\n\t\t}\n\t\tfor(R=0,scanf(\"%d\",&T),j=0;j<T;j++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tt=bfs(p-1,q-1,6);\n\t\t\tR=t<R?R:t;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nint dx1[]={0,-1,1,0,1,-1};\nint dy1[]={-1,0,0,1,1,1};\nint dx2[]={-1,0,1,1,0,-1};\nint dy2[]={0,1,0,-1,-1,-1};\nint dy[6][2];\nint dx[6][2];\nvoid mainmain(){\n\trep(i,6){\n\t\tdy[i][0]=dy1[i];\n\t\tdx[i][0]=dx1[i];\n\t}\n\trep(i,6){\n\t\tdy[i][1]=dy2[i];\n\t\tdx[i][1]=dx2[i];\n\t}\n\twhile(cin>>w>>h,h||w){\n\t\t// cout<<h<<\" \"<<w<<endl;\n\t\tqueue<pair<pii,int>> q1;\n\t\tvvint table;\n\t\tinitvv(table,h,w,-1);\n\t\tint n;\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tpii a;\n\t\t\tcin>>a.S>>a.F;\n\t\t\ta.F--;\n\t\t\ta.S--;\n\t\t\t// cout<<a.F<<\" \"<<a.S<<endl;\n\t\t\tq1.push(mkp(a,0));\n\t\t}\n\t\twhile(!q1.empty()){\n\t\t\tpair<pii,int> top=q1.front();\n\t\t\tq1.pop();\n\t\t\tif(table[top.F.F][top.F.S]!=-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttable[top.F.F][top.F.S]=top.S;\n\t\t\trep(i,6){\n\t\t\t\tpii next=top.F;\n\t\t\t\tint t=1&top.F.F;\n\t\t\t\tt=1-t;\n\t\t\t\tnext.F+=dx[i][t];\n\t\t\t\tnext.S+=dy[i][t];\n\t\t\t\tif(0<=next.F&&next.F<h&&0<=next.S&&next.S<w){\n\t\t\t\t\tq1.push(mkp(next,top.S+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// rep(i,h){\n\t\t\t// if(i&1) cout<<\" \";\n\t\t\t// rep(j,w){\n\t\t\t\t// cout<<table[i][j]<<\" \";\t\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\tint m;\n\t\tcin>>m;\n\t\tvvint used;\n\t\tint ans=0;\n\t\trep(i,m){\n\t\t\tpii a;\n\t\t\tinitvv(used,h,w,0);\n\t\t\tcin>>a.S>>a.F;\n\t\t\ta.F--;\n\t\t\ta.S--;\n\t\t\t// continue;\n\t\t\tqueue<pair<pii,int>> q2;\n\t\t\tq2.push(mkp(a,0));\n\t\t\tint tmp=0;\n\t\t\t// cout<<i<<\"----------\"<<endl;\n\t\t\twhile(!q2.empty()){\n\t\t\t\tpair<pii,int> top=q2.front();\n\t\t\t\tq2.pop();\n\t\t\t\tif(used[top.F.F][top.F.S]) continue;\n\t\t\t\tif(table[top.F.F][top.F.S]<=top.S) continue;\n\t\t\t\t// cout<<top.F.F<<\" \"<<top.F.S<<\" \"<<top.S<<\" \"<<table[top.F.F][top.F.S]<<endl;\n\t\t\t\ttmp++;\n\t\t\t\tused[top.F.F][top.F.S]=1;\n\t\t\t\trep(i,6){\n\t\t\t\t\tpii next=top.F;\n\t\t\t\t\tint t=1&top.F.F;\n\t\t\t\t\tt=1-t;\n\t\t\t\t\tnext.F+=dx[i][t];\n\t\t\t\t\tnext.S+=dy[i][t];\n\t\t\t\t\tif(0<=next.F&&next.F<h&&0<=next.S&&next.S<w){\n\t\t\t\t\t\tq2.push(mkp(next,top.S+1));\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(ans,tmp);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[200][200];\nint grid[200][200];\nint grid2[200][200];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 200; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--y][--x] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tif (g[--q][--p]) continue;\n\t\t\tg[q][p] = 1;\n\t\t\tint tmp = solve();\n\t\t\tmaxi = max(maxi, tmp);\n\t\t\tg[q][p] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\n    public:\n        int x, y;\n        coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{0, -1, 0, 1, 1, 1}, {-1, -1, -1, 0, 1, 0}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(H+1, vector<pii>(W+1, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint m,n;\nint s,t;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nconst int INF=10000000;\nint field[101][101];\nint field2[101][101];\nint x[11],y[11];\nint nx[11],ny[11];\nint dx1[6]={0,-1,0,1,1,1};\nint dx2[6]={-1,-1,-1,0,1,0};\nint dy[6]={-1,0,1,-1,0,1};\n\nvoid bfs(int sx,int sy){\n\tqueue<PP> que;\n\tque.push(PP(P(sx,sy),0));\n\tfield[sx][sy]=0;\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field[px][py]>c+1){\n\t\t\t\tfield[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int sx,int sy){\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfield2[i][j]=field[i][j];\n\t\t}\n\t}\n\tqueue<PP> que;\n\tint res=1;\n\tif(field2[sx][sy]==0)return 0;\n\tque.push(PP(P(sx,sy),0));\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field2[px][py]>c+1){\n\t\t\t\tres++;\n\t\t\t\tfield2[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint ans=0;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfield[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tbfs(x[i],y[i]);\n\t\t}\n\t\tcin >> t;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> nx[i] >> ny[i];\n\t\t\tans=max(ans,bfs2(nx[i],ny[i]));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nint distance6[200][200];\nvoid bfs(){\n  const int W = 110;\n  const int H = 110;\n  REP(y, H) REP(x, W) distance6[y][x] = INF;\n  queue<int> qx, qy;\n  qx.push(0); qy.push(0);\n  distance6[0][0] = 0;\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    if(y % 2 == 0){\n      int dx[6] = {-1, 0, 1, 0, -1, -1};\n      int dy[6] = {-1, -1, 0, 1, 1, 0};\n      REP(r, 6) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && distance6[ny][nx] > distance6[y][x] + 1){\n          distance6[ny][nx] = distance6[y][x] + 1;\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }else{\n      int dx[6] = {0, 1, 1, 1, 0, -1};\n      int dy[6] = {-1, -1, 0, 1, 1, 0};\n      REP(r, 6) {\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, W, H) && distance6[ny][nx] > distance6[y][x] + 1){\n          distance6[ny][nx] = distance6[y][x] + 1;\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }\n  }\n}\nint dist(int x1, int y1, int x2, int y2){\n  int x = abs(x2 - x1);\n  int y = abs(y2 - y1);\n  return distance6[y][x];\n}\n\nint main(){\n  bfs();\n  int W, H;\n  while(cin >> W >> H && W){\n    int N;\n    int tx[10], ty[10];\n    cin >> N;\n    REP(i, N) cin >> tx[i] >> ty[i];\n    int ans = 0;\n    int M; cin >> M;\n    REP(i, M){\n      int nx, ny; cin >> nx >> ny;\n      int cnt = 0;\n      REP(y, H)REP(x, W){\n        int d = dist(nx, ny, x, y);\n        bool ok = true;\n        REP(j, N) if(dist(tx[j], ty[j], x, y) <= d) ok = false;\n        if(ok) cnt++;\n      }\n      ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\t//vector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\trep(i, w + 1) rep (j, h + 1) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]/*v[nx][ny] == 1*/) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\t//v[nx][ny] = 1;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v){\n  int res = 1;\n  v[y][x] = n;\n  int t = y % 2 == 0;\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n    res += count(ny, nx, n + 1, v);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      res = max(res, count(y, x, 0, v));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nstruct NODE{\n\tint x,y,c,num;\n\tNODE(int x,int y,int c) : x(x) , y(y) , c(c) {}\n\tNODE(int x,int y,int c,int num) : x(x) , y(y) , c(c) , num(num) {}\n};\nint W,H;\n\nint doit(vector<NODE> v){\n\tqueue<NODE> Q;\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tQ.push(NODE(v[i].x,v[i].y,0,i));\n\t}\n\tint cnt[100][100]={};\n\tint ans[100][100];\n\tfor(int i = 0 ; i < 100 ; i++)\n\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\tans[i][j] = 1e9;\n\t\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\tint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,1,0,1,1,1} };\n\tint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,0,-1,0,1,-1} };\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\t// kore Shindoinen!!!!!!!!!!!!!\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( q.x < 0 || q.y < 0 || q.x >= W || q.y >= H ) continue;\n\t\tif( ans[q.y][q.x] < q.c ) continue;\n\t\tif( ans[q.y][q.x] > 10000) {\n\t\t\tans[q.y][q.x] = q.c;\n\t\t\tcnt[q.y][q.x] = (1<<q.num);\n\t\t}else if( ans[q.y][q.x] == q.c ){\n\t\t\tcnt[q.y][q.x] |= (1<<q.num);\n\t\t\t\n\t\t}\n\t\tfor(int i = 0 ; i < 6 ; i++){\n\t\t\tQ.push(NODE(q.x+dx[q.y%2][i],q.y+dy[q.y%2][i],q.c+1,q.num));\n\t\t}\n\t}\n\tint cntt = 0;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tif( cnt[i][j] == (1<<(v.size()-1)) ){\n\t\t\t\tcntt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cntt;\n\t\n}\nint main(){\n\n\twhile(cin >> W >> H && W){\n\t\tint s,N;\n\t\tcin >> s;\n\t\tvector<NODE> alr;\n\t\tfor(int i = 0 ; i < s ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--,y--;\n\t\t\talr.push_back(NODE(x,y,0));\n\t\t}\n\t\tcin >> N;\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx--,y--;\n\t\t\talr.push_back(NODE(x,y,0));\n\t\t\tans = max( ans , doit(alr) );\n\t\t\talr.pop_back();\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\nusing namespace std;\nconst int INF = 1e9;\n// int dx[] = {1, 1, 0, -1, -1, 0};\n// int dy[] = {0, 1, 1,  1,  0, -1};\nint dx[] = {-1, 0, 1, -1, 0, 1};\nint dy0[] = {0, -1, 0, 1, 1, 1};\nint dy1[] = {-1, -1, -1, 0, 1, 0};\nint main(){\n  int m, n;\n  while(cin >> m >> n, m){\n    int s;\n    cin >> s;\n    vector<int> X(s), Y(s);\n    queue<pair<size_t,size_t>> Q;\n    vector<vector<int>> D(n,vector<int>(m,INF));\n    for(int i = 0; i < s; ++i){\n      size_t x, y;\n      cin >> y >> x;\n      --x,--y;\n      Q.emplace(x,y);\n      D[x][y] = 0;\n    }\n    while(Q.size()){\n      size_t x, y;\n      tie(x,y) = Q.front();\n      Q.pop();\n      int d = D[x][y];\n      for(int i = 0; i < 6; ++i){\n        int* dy = ((x % 2 == 0)? dy1:dy0);\n        size_t x_ = x + dx[i], y_ = y + dy[i];\n        if(x_ >= n or y_ >= m) continue;\n        if(D[x_][y_] <= d+1) continue;\n        D[x_][y_] = d+1;\n        Q.emplace(x_,y_);\n      }\n    }\n    // for(int i = 0; i < n; ++i)\n    //   for(int j = 0; j < m; ++j)\n    //     fprintf(stderr, \"%d%c\", D[i][j], j+1<m? ' ':'\\n');\n    int t;\n    cin >> t;\n    int ans = 0;\n    for(int i = 0; i < t; ++i){\n      size_t p, q;\n      cin >> q >> p;\n      --p,--q;\n      // cerr << p << \" \" << q << \"!!!\" << endl;\n      int ret = 0;\n      queue<pair<size_t,size_t>> Q_;\n      vector<vector<int>> D_ = D;\n      if(D_[p][q] == 0) continue;\n      D_[p][q] = 0;\n      ++ret;\n      Q_.emplace(p,q);\n      while(Q_.size()){\n        size_t x, y;\n        tie(x,y) = Q_.front();\n        Q_.pop();\n        int d = D_[x][y];\n        for(int j = 0; j < 6; ++j){\n          int* dy = ((x % 2 == 0)? dy1:dy0);\n          size_t x_ = x + dx[j], y_ = y + dy[j];\n          if(x_ >= n or y_ >= m) continue;\n          if(D_[x_][y_] <= d+1) continue;\n          D_[x_][y_] = d+1;\n          // cerr << x_ << \" \" << y_ << endl;\n          ++ret;\n          Q_.emplace(x_,y_);\n        }\n      }\n      //cerr << p << \" \" << q << \" \" << ret << endl;\n      ans = max(ans,ret);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define at(t, i) get<i>(t)\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\nconst int INF = 1 << 28;\nconst int dx[] = {0, -1, -1, 0, 1, 1};\nconst int dy[][6] = {\n\t{-1, 0, 1, 1, 1, 0},\n\t{-1, -1, 0, 1, 0, -1},\n};\n\nint m, n;\nint s, t;\nPr pos[11];\nint dist[11][128][128];\n\nint solve()\n{\n\tfill_n(**dist, 11 * 128 * 128, INF);\n\tfor (int i = 0; i <= s; i++){\n\t\tfor (int j = 0; j <= 127; j++){\n\t\t\tfor (int k = 0; k <= 127; k++){\n\t\t\t\tif (j == 0 || k == 0 || j == 127 || k == 127){\n\t\t\t\t\tdist[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i <= s; i++){\n\t\tdist[i][pos[i].first][pos[i].second] = 0;\n\t\tqueue<Tp> que;\n\t\tfor (que.push(Tp(pos[i].first, pos[i].second, 0)); que.size(); que.pop()){\n\t\t\tTp t = que.front();\n\t\t\tint x = at(t, 0);\n\t\t\tint y = at(t, 1);\n\t\t\tint d = at(t, 2);\n\t\t\t//printf(\"%d %d %d\\n\", x, y, d);\n\t\t\tif (dist[i][x][y] < d) continue;\n\t\t\tfor (int dir = 0; dir < 6; dir++){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[x & 1][dir];\n\t\t\t\tif (dist[i][nx][ny] > d + 1){\n\t\t\t\t\tdist[i][nx][ny] = d + 1;\n\t\t\t\t\tque.push(Tp(nx, ny, d + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i <= s; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tfor (int k = 1; k <= m; k++){\n\t\t\t\tprintf(\"%d \", dist[i][j][k]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\\n\");\n\t}*/\n\t\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tint p = 0;\n\t\t\tfor (int k = 1; k <= s; k++){\n\t\t\t\tif (dist[p][i][j] >= dist[k][i][j]){\n\t\t\t\t\tp = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == 0) res++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tpos[i + 1] = Pr(y, x);\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tpos[0] = Pr(q, p);\n\t\t\tres = max(res, solve());\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=1; i<=n; i++)\n\n#define INF (1<<20)\nint field[128][128];\n\nint dist(int x1, int y1, int x2, int y2)\n{\n\tx1-=(y1-1)/2;\n\tx2-=(y2-1)/2;\n\n\treturn (abs(x1-x2)+abs(y1-y2)+abs((x1+y1)-(x2+y2)))/2;\n}\n\nint main()\n{\n\tint w,h,n,x0,y0,cnt,ans;\n\twhile(cin >> w, w)\n\t{\n\t\tcin >> h;\n\t\tREP(y,h)REP(x,w)\n\t\t{\n\t\t\tfield[y][x] = INF;\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> x0 >> y0;\n\t\t\tREP(y,h)REP(x,w)\n\t\t\t{\n\t\t\t\tfield[y][x] = min(field[y][x],dist(x0,y0,x,y));\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcnt = 0;\n\t\t\tcin >> x0 >> y0;\n\t\t\tREP(y,h)REP(x,w)\n\t\t\t{\n\t\t\t\tif(field[y][x]>dist(x0,y0,x,y)) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdlib.h>\nusing namespace std;\n\nint cal(int x1,int y1,int x2,int y2) {\n\tint d,x,y;\n\tif (y1==y2) return abs(x1-x2);\n\tif (x1==x2) return abs(y1-y2);\n\tif (x1>x2) { swap(x1,x2); swap(y1,y2);}\n\td= y1<y2 ? 0 : 1;\n\tif ((d==0 && (y2 % 2)==1 && y2+1==y1) || (d==1 && (y1 % 2)==1 && y1+1==y2)) x=0; else x=x2-x1;\n\ty=abs(y2-y1)/2;\n\tif (abs(y2-y1) % 2 == 1) if (y2 % 2==0) y++;\n\tif (x>y) x=y;\n\td=abs(x1-x2)+abs(y1-y2)-x;\n\treturn d;\n}\n\nint main() {\n    int a,c,m,n,s,p,k,x,y,i,j,mp[100][100];\n    while(cin >> m >> n && m>0) {\n\t  for (i=0;i<n;i++) for (j=0;j<m;j++) mp[i][j]=999;\n\t  a=0;\n\t  for (p=0;p<2;p++) {\n\t  cin >> s; \n\t  for (;s>0;s--) {\n\t\t   cin >> x >> y; k=0; x--; y--;\n\t       for (i=0;i<n;i++) for (j=0;j<m;j++) {\n\t\t\t   c=cal(x,y,j,i);\n\t       if (mp[i][j]>c) { if (p==0) mp[i][j]=c; else k++; }\n\t       }\n\t       if (a<k) a=k;\n\t\t}\n\t}\n\tcout << a << endl;\n\t}\n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define ABS(n) (n<0?-(n):(n))\n\n#define INF (1<<20)\nint field[128][128];\n\nint dist(int x1, int y1, int x2, int y2)\n{\n\tx1-=(y1-1)/2;\n\tx2-=(y2-1)/2;\n\n\treturn (abs(x1-x2)+abs(y1-y2)+abs((x1+y1)-(x2+y2)))/2;\n}\n\nint main()\n{\n\tint w,h,n,x0,y0,cnt,ans;\n\twhile(cin >> w, w)\n\t{\n\t\tcin >> h;\n\t\tfor(int y=1; y<=h; y++)\n\t\tfor(int x=1; x<=w; x++)\n\t\t{\n\t\t\tfield[y][x] = INF;\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> x0 >> y0;\n\t\t\tfor(int y=1; y<=h; y++)\n\t\t\tfor(int x=1; x<=w; x++)\n\t\t\t{\n\t\t\t\tfield[y][x] = min(field[y][x],dist(x0,y0,x,y));\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tcin >> n;\n\t\twhile(n--)\n\t\t{\n\t\t\tcnt = 0;\n\t\t\tcin >> x0 >> y0;\n\t\t\tfor(int y=1; y<=h; y++)\n\t\t\tfor(int x=1; x<=w; x++)\n\t\t\t{\n\t\t\t\tif(field[y][x]>dist(x0,y0,x,y)) cnt++;\n\t\t\t}\n\t\t\tans = max(ans,cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint id,dist;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdist = arg_dist;\n\t}\n\tint row,col,dist;\n};\n\nint W,H;\nint diff_row_GU[6] = {-1,-1,0,0,1,1},diff_col_GU[6] = {-1,0,-1,1,-1,0};\nint diff_row_KI[6] = {-1,-1,0,0,1,1},diff_col_KI[6] = {0,1,-1,1,0,1};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tInfo map[H][W];\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tmap[row][col].dist = BIG_NUM;\n\t\t}\n\t}\n\n\tint num_conv;\n\tscanf(\"%d\",&num_conv);\n\n\tint tmp_col,tmp_row;\n\tint adj_row,adj_col;\n\n\tqueue<Data> Q;\n\n\tfor(int loop = 0; loop < num_conv; loop++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_col--;\n\t\ttmp_row--;\n\n\t\tmap[tmp_row][tmp_col].id = loop;\n\t\tmap[tmp_row][tmp_col].dist = 0;\n\n\t\tQ.push(Data(tmp_row,tmp_col,0));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row%2 == 0){\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_GU[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_GU[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\tmap[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\tmap[adj_row][adj_col].id = loop;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_KI[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_KI[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\tmap[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\tmap[adj_row][adj_col].id = loop;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tInfo work_map[H][W];\n\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tint maximum = 0;\n\n\tfor(int loop = 0; loop < T; loop++){\n\t\tscanf(\"%d %d\",&tmp_col,&tmp_row);\n\t\ttmp_col--;\n\t\ttmp_row--;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\twork_map[row][col].id = map[row][col].id;\n\t\t\t\twork_map[row][col].dist = map[row][col].dist;\n\t\t\t}\n\t\t}\n\n\t\twork_map[tmp_row][tmp_col].id = 999;\n\t\twork_map[tmp_row][tmp_col].dist = 0;\n\n\t\tQ.push(Data(tmp_row,tmp_col,0));\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().row%2 == 0){\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_GU[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_GU[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(work_map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\twork_map[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\twork_map[adj_row][adj_col].id = 999;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tadj_row = Q.front().row + diff_row_KI[i];\n\t\t\t\t\tadj_col = Q.front().col + diff_col_KI[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tif(work_map[adj_row][adj_col].dist > Q.front().dist+1){\n\t\t\t\t\t\twork_map[adj_row][adj_col].dist = Q.front().dist+1;\n\t\t\t\t\t\twork_map[adj_row][adj_col].id = 999;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tint tmp = 0;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(work_map[row][col].id == 999)tmp++;\n\t\t\t}\n\t\t}\n\t\tmaximum = max(maximum,tmp);\n\t}\n\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n??\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n??\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n??\nconst int INF = 1001001001;\n??\nint dist(pii a, pii b)\n{\n????????int dy = a.first - b.first;\n????????int dx = a.second - b.second;\n????????if(0 <= dy*dx){\n????????????????dy = abs(dy);\n????????????????dx = abs(dx);\n????????????????return dy + max(0, dx - (dy+1-min(a.first,b.first)%2)/2);\n????????}\n????????else{\n????????????????dy = abs(dy);\n????????????????dx = abs(dx);\n????????????????return dy + max(0, dx - (dy + min(a.first, b.first)%2)/2);\n????????}\n}\n??\nint main()\n{\n????????int m, n;\n????????while(scanf(\"%d%d\", &m, &n), m){\n????????????????int s;\n????????????????scanf(\"%d\", &s);\n????????????????pii conv[10];\n????????????????rep(i, s)\n????????????????????????scanf(\"%d%d\", &conv[i].second, &conv[i].first);\n??????????????????\n????????????????int d[101][101];\n????????????????rep(i, n) rep(j, m){\n????????????????????????d[i+1][j+1] = INF;\n????????????????????????rep(k, s)\n????????????????????????????????d[i+1][j+1] = min(d[i+1][j+1], dist(pii(i+1, j+1), conv[k]));\n????????????????}\n??????????????????\n????????????????int t, ans = 0;\n????????????????scanf(\"%d\", &t);\n????????????????rep(i, t){\n????????????????????????int x, y;\n????????????????????????scanf(\"%d%d\", &x, &y);\n??????????????????????????\n????????????????????????int cnt = 0;\n????????????????????????rep(j, n) rep(k, m)\n????????????????????????????????cnt += dist(pii(j+1, k+1), pii(y, x)) < d[j+1][k+1];\n????????????????????????ans = max(ans, cnt);\n????????????????}\n????????????????printf(\"%d\\n\", ans);\n????????}\n????????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\npublic:\n    int x, y;\n    coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{-1, -1, -1, 0, 1, 0}, {0, -1, 0, 1, 1, 1}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(H, vector<pii>(W, MP(-1, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y; x--; y--;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n\n            int cnt = 0;\n\n            rep(i, H) rep(j, W) if (mp[i][j].fst == 0) cnt++;\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\nconst int dx[2][6]={{1,-1,-1,0,-1,0},{1,-1,1,0,0,1}};\nconst int dy[2][6]={{0,0,1,1,-1,-1},{0,0,1,1,-1,-1}};\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        int index;\n        P(){}\n        P(int x,int y,int cost,int index):x(x),y(y),cost(cost),index(index){}\n};\n\nclass Data{\n        public:\n        int cost;\n        int index;\n        Data(){}\n        Data(int cost,int index):cost(cost),index(index){}\n};\n\nint main(){\n        int m,n;\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                int s;\n                scanf(\"%d\",&s);\n\n                queue< P > Q;\n                int sx[100];\n                int sy[100];\n                for(int i = 0; i < s; i++){\n                        scanf(\"%d%d\",&sx[i],&sy[i]);\n                }\n\n                int t;\n                scanf(\"%d\",&t);\n                int ans = -11000;\n                for(int q = 0; q < t; q++){\n                        int x,y;\n                        Data vis[128][128];\n                        queue< P > Q;\n                        for(int i = 0; i < s; i++){\n                                Q.push(P(sx[i],sy[i],1,i));\n                        }\n                        for(int i = 0; i < 120; i++){\n                                for(int j = 0; j < 120; j++){\n                                        vis[i][j] = Data(0,0);\n                                }\n                        }\n\n                        scanf(\"%d%d\",&x,&y);\n                        Q.push(P(x,y,1,s));\n                        while( Q.size() ){\n                                P p = Q.front();Q.pop();\n                                for(int i = 0; i < 6; i++){\n                                        if(p.x+dx[p.y%2][i] < 0 || p.x+dx[p.y%2][i] > m || p.y+dy[p.y%2][i] < 0 || p.y+dy[p.y%2][i] > n)continue;\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost == p.cost+1){\n                                                vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost = -1;\n                                                continue;\n                                        }\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost != 0)continue;\n                                        Q.push(P(p.x+dx[p.y%2][i],p.y+dy[p.y%2][i],p.cost+1,p.index));\n                                        vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]] = Data(p.cost+1,p.index);\n                                }\n\n                        }\n                        int res = 0;\n                        for(int i = 0; i < 120; i++){\n                                for(int j = 0; j < 120; j++){\n                                        if(vis[i][j].index == s && vis[i][j].cost != -1)res++;\n                                }\n                        }\n                        ans = max(ans,res);\n                }\n                printf(\"%d\\n\",ans-1);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int INF = 1e+9;\ntypedef pair<int,int> P;\n\nint w, h;\n// st[y][x] := (x,y) が店舗かどうか\nint st[MAX_N][MAX_N];\n\n// 移動6方向のベクトル(偶数列と奇数列で遷移の仕方が異なる)\nint dx[2][6] = {  \n\t{ -1, 0, -1, 1, -1, 0 },\n\t{  0, 1, -1, 1,  0, 1 }\n};\nint dy[6] = { -1, -1, 0, 0, 1, 1 };\n\n// BFSのときに利用\nint d[MAX_N][MAX_N];\n// m[y][x] := (x,y) から最短の店舗までの距離\nint m[MAX_N][MAX_N];\n// 解\nint ans;\n\nvoid init(){\n\tfor(int y=0 ; y < MAX_N ; y++ ){\n\t\tfor(int x=0 ; x < MAX_N ; x++ ){\n\t\t\tm[y][x] = st[y][x] = 0;\n\t\t}\n\t}\n}\n\nvoid clear_d(){\n\tfor(int y=0 ; y < MAX_N ; y++ ){\n\t\tfor(int x=0 ; x < MAX_N ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t}\n\t}\n}\n\n// (sx,sy) から最短の店舗までの距離を求める\nvoid bfs(int sx, int sy){\n\tqueue<P> q;\n\tclear_d();\n\tq.push( P(sx,sy) );\n\td[sy][sx] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tint px = q.front().first; \n\t\tint py = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( st[py][px] == 1 ){\n\t\t\tm[sy][sx] = d[py][px];\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = px + dx[py%2][i];\n\t\t\tint my = py + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\n\t\t\tif( d[my][mx] == INF ){\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t\td[my][mx] = d[py][px] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// (sx,sy) からカバーできるブロック数\nint solve(int sx, int sy){\n\tqueue<P> q;\n\tclear_d();\n\tq.push( P(sx,sy) );\n\td[sy][sx] = 0;\n\tint cnt = 0;\n\t\n\twhile( !q.empty() ){\n\t\tint px = q.front().first; \n\t\tint py = q.front().second;\n\t\tq.pop();\n\t\tif( d[py][px] < m[py][px] ){\n\t\t\tcnt++;\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = px + dx[py%2][i];\n\t\t\tint my = py + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\n\t\t\tif( d[my][mx] == INF ){\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t\td[my][mx] = d[py][px] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tinit();\n\t\t\n\t\tint s, t;\n\t\tcin >> s;\n\t\tfor(int i=0 ; i < s ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tst[y][x] = 1;\n\t\t}\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tbfs( x , y );\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tcin >> t;\n\t\tfor(int i=0 ; i < t ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tint cnt = solve( x, y );\n\t\t\tans = max( ans , cnt );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,m;\n  int s,t;\n  int x,y;\n  int grid[101][101];\n\n  while(cin >> n && n){\n    cin >> m;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)grid[i][j] = 1<<25;\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      int hoge = 1;\n      int tmp[101][101];\n      copy(grid,grid+n*m,tmp);\n\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    hoge++;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n      ans = max(ans,hoge);\n      copy(tmp,tmp+n*m,grid);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <set>\nusing namespace std;\nint map[100][100];\nconst int evennext[6][2] = {\n  {-1,-1},{0,-1},{-1,0},{1,0},{-1,1},{0,1},\n};\nconst int oddnext[6][2] = {\n  {0,-1},{1,-1},{-1,0},{1,0},{0,1},{1,1},\n};\nint m,n;\nvoid paint(int d,int x,int y)\n{\n  if(map[y][x] <= d) return;\n  map[y][x] = d;\n  const int (*np)[2] = (y % 2 == 0) ? evennext : oddnext;\n  for(int i=0; i<6; i++){\n    int nx = x + np[i][0];\n    int ny = y + np[i][1];\n    if(0 <= nx && nx < m && 0 <= ny && ny < n){\n      paint(d+1,nx,ny);\n    }\n  }\n  return;\n}\nvoid count(int d,int x,int y,set<pair<int,int> > &memo)\n{\n  if(map[y][x] <= d) return;\n  const int (*np)[2] = (y % 2 == 0) ? evennext : oddnext;\n  if(!memo.insert(make_pair<int,int>(x,y)).second) return;\n  for(int i=0; i<6; i++){\n    int nx = x + np[i][0];\n    int ny = y + np[i][1];\n    if(0 <= nx && nx < m && 0 <= ny && ny < n){\n      count(d+1,nx,ny,memo);\n    }\n  }\n  return;\n}\nint main()\n{\n  for(;;){\n    cin >> m;\n    if(m == 0) break;\n    cin >> n;\n    for(int i=0; i<n; i++){\n      for(int j=0; j<m; j++){\n        map[i][j] = 500;\n      }\n    }\n    int s;\n    cin >> s;\n    for(int i=0; i<s; i++){\n      int x,y;\n      cin >> x >> y;\n      paint(0,x-1,y-1);\n    }\n    /*\n    for(int i=0; i<n; i++){\n      for(int j=0; j<m; j++){\n        cout << \" \" << map[i][j];\n      }\n      cout << endl;\n    }\n    */\n    int t;\n    cin >> t;\n    int max = 0;\n    for(int i=0; i<t; i++){\n      int x,y;\n      cin >> x >> y;\n      set<pair<int,int> > memo;\n      count(0,x-1,y-1,memo);\n      if(max < memo.size()) max = memo.size();\n    }\n    cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<30)\n\ntypedef pair<int,int> _P;\ntypedef pair<_P,int> P;\n\nint map[100][100];\nbool vst[100][100];\nint dx1[6]={-1,0,1,0,-1,-1},dy1[6]={-1,-1,0,1,1,0};\nint dx2[6]={0,1,1,1,0,-1},dy2[6]={-1,-1,0,1,1,0};\n\nint main() {\n\tint m,n,s,t;\n\twhile(scanf(\"%d\",&m),m) {\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tmap[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<s;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);x--;y--;\n\t\t\tmemset(vst,false,sizeof(vst));\n\t\t\tmap[x][y]=0;\n\t\t\tvst[x][y]=true;\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(_P(x,y),0));\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tint *dx,*dy;\n\t\t\t\tif((p.first.second+1)%2) dx=dx1,dy=dy1;\n\t\t\t\telse dx=dx2,dy=dy2;\n\t\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\t\tint nx=p.first.first+dx[i],ny=p.first.second+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<m&&0<=ny&&ny<n&&!vst[nx][ny]) {\n\t\t\t\t\t\tvst[nx][ny]=true;\n\t\t\t\t\t\tmap[nx][ny]=min(p.second+1,map[nx][ny]);\n\t\t\t\t\t\tque.push(P(_P(nx,ny),p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&t);\n\t\tint ans=0;\n\t\tfor(int i=0;i<t;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);x--;y--;\n\t\t\tmemset(vst,false,sizeof(vst));\n\t\t\tvst[x][y]=true;\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(_P(x,y),0));\n\t\t\tint count=0;\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tint *dx,*dy;\n\t\t\t\tif(p.second<map[p.first.first][p.first.second]) count++;\n\t\t\t\tif((p.first.second+1)%2) dx=dx1,dy=dy1;\n\t\t\t\telse dx=dx2,dy=dy2;\n\t\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\t\tint nx=p.first.first+dx[i],ny=p.first.second+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<m&&0<=ny&&ny<n&&!vst[nx][ny]) {\n\t\t\t\t\t\tvst[nx][ny]=true;\n\t\t\t\t\t\tque.push(P(_P(nx,ny),p.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<count) ans=count;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define LEN 100\n#define MAX 255\nunsigned char map[LEN+2][LEN+2];\nunsigned char chk[LEN+2][LEN+2];\nunsigned char dis[LEN+2][LEN+2];\nbool now[LEN][LEN];\n\nint m,n;\n\nint edx[6] = { -1, 1, 0, 1, 0, 1 };\nint odx[6] = { -1, 1, -1, 0, -1, 0};\nint dy[6] = { 0, 0, 1, 1, -1, -1};\n\nvoid fill( int y, int x, int d, int p ) {\n\n\tif ( y < 0 || y > n || x < 0 || x > m )\n\t\treturn;\n\n\tif ( chk[y][x] == MAX ) {\n\t\tif ( dis[y][x] > d ) {\n\t\t\tchk[y][x] = p;\n\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\n\t\t} \n\t}\n\telse {\n\t\tif ( chk[y][x] == 0 ) {\n\t\t\t//\t\t\tcout << \"Start\" << y << \"\\t\" <<  x << endl;\n\t\t\tchk[y][x] = p;\n\t\t\tdis[y][x] = d;\n\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t} else\n\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t}\n\t\t} else if ( chk[y][x] == p ) {\n\t\t\tif ( dis[y][x] > d ) {\n\t\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tif ( dis[y][x] > d ) {\n\t\t\t\t//\t\t\t\tcout << \"Do\" << y << \"\\t\" <<  x << endl;\n\t\t\t\tchk[y][x] = p;\n\t\t\t\tdis[y][x] = d;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( dis[y][x] == d ) {\n\t\t\t\t//\t\t\t\tcout << \"Here \" << y << \"\\t\" << x << endl;\n\t\t\t\tchk[y][x] = MAX;\n\t\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\t\tif ( y%2 == 1 ) {\n\t\t\t\t\tfill( y+dy[i], x+edx[i], d+1, p );\n\t\t\t\t\t} else\n\t\t\t\t\t\tfill( y+dy[i], x+odx[i], d+1, p );\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nint count = 0;\n\nvoid find ( int y, int x, int d ) {\n\n\tif ( y < 0 || y > n || x < 0 || x > m )\n\t\treturn;\n\n\t//\tcout << \"Do\" << y << \"\\t\" <<  x << endl;\n\n\tif ( now[y][x] ) {\n\t\tnow[y][x] = false;\n\t\t//\t\tcout << \"Get\\n\";\n\t\tif ( dis[y][x] > d ) {\n\t\t\tcount++;\n\n\t\t\tfor ( int i=0; i<6; i++ ) {\n\t\t\t\tif ( y%2 == 1 )\n\t\t\t\t\tfind( y+dy[i], x+edx[i], d+1 );\n\t\t\t\telse\n\t\t\t\t\tfind( y+dy[i], x+odx[i], d+1 );\n\t\t\t}\n\n\t\t}\n\t}\n}\n\t\n\nint counting ( int y, int x ) {\n\t//\tcout << \"Start\\n\" << endl;\n\tcount = 1;\n\tnow[y][x] = false;\n\n\tmemset ( now, true, (LEN*LEN)*sizeof(bool));\n\n\tfind( y, x, 0 );\n\n\treturn count;\n}\n\nint main () {\n\n\twhile ( true ) {\n\n\t\tcin >> m >> n ;\n\t\tif ( m == 0 ) \n\t\t\tbreak;\n\t\tint s;\n\t\tcin >> s;\n\t\tint xs, ys;\n\n\t\tfor ( int i=0; i<n+2; i++ ) {\n\t\t\tfor ( int j=0; j<m+2; j++ ) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdis[i][j] = MAX;\n\t\t\t\tchk[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<s; i++ ) {\n\t\t\tcin >> xs >> ys;\n\t\t\tmap[ys-1][xs-1] = i+1;\n\t\t\tchk[ys-1][xs-1] = 0;\n\t\t\tfill ( ys-1, xs-1, 0, i+1);\n\t\t}\n\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (char)(map[i][j] + '0');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (int)dis[i][j] << '\\t';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<m; j++ ) {\n\t\t\t\tcout << (char)(chk[i][j] + '0');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\t/*\n\t\tfor ( int i=0 ; i<n+2; i++ ) {\n\t\t\tfor ( int j=0; j<m+2; j++ ) {\n\t\t\t\tif ( map[i][j] > 0 ) {\n\t\t\t\t\tfill ( i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint t;\n\t\tcin >> t;\n\t\tint max = 0;\n\t\tint pt, qt;\n\t\tfor ( int i=0; i<t; i++ ) {\n\t\t\tcin >> pt >> qt;\n\t\t\tint temp;\n\t\t\ttemp =  counting ( qt-1, pt-1 );\n\n\t\t\t//\t\t\tcout << \"Cont : \" << temp << endl;\n\t\t\tif ( max < temp ) {\n\t\t\t\tmax = temp;\n\t\t\t}\n\t\t}\n\t\t//\t\tcout << \"Ans: \"<< max << endl;\n\t\tcout << max << endl;\n\t\t\t\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 1;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        /*\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n        */\n    }\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h, VI( w, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MSIZE = 101;\n\nint w, h;\nint s;\nint X[SIZE], Y[SIZE];\nint t;\nint PT[SIZE], QT[SIZE];\nint T[MSIZE][MSIZE];\nint Tcopy[MSIZE][MSIZE]; \n\nconst int DSIZE = 6;\nconst int dr[2][DSIZE] = {\n    { 1, 1, 0, 0, -1, -1 },\n    { 1, 1, 0, 0, -1, -1 }\n};\nconst int dc[2][DSIZE] = {\n    { -1, 0, -1, 1, -1, 0 },\n    { 0, 1, -1, 1, 0, 1 }\n};\n\nvoid init() {\n    for ( int i = 0; i < MSIZE; ++ i ) {\n        for ( int j = 0; j < MSIZE; ++ j ) {\n            T[i][j] = INT_MAX;\n        }\n    }\n}\n\nvoid save() {\n    for ( int i = 0; i < MSIZE; ++ i ) {\n        for ( int j = 0; j < MSIZE; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n}\n\nvoid load() {\n    for ( int i = 0; i < MSIZE; ++ i ) {\n        for ( int j = 0; j < MSIZE; ++ j ) {\n            T[i][j] = Tcopy[i][j];\n        }\n    }\n}\n\ntypedef II NODE;\ntypedef queue <NODE> QUEUE;\n\nbool isValidPos( int r, int c ) {\n    return r >= 0 && r < h && c >= 0 && c < w;\n}\n\nint spread( int sr, int sc ) {\n    QUEUE Q;\n    Q.push( II( sr, sc ) );\n    T[sr][sc] = 0;\n    \n    int res = 1;\n    while ( ! Q.empty() ) {\n        NODE node = Q.front();\n        Q.pop();\n\n        int r = node.first;\n        int c = node.second;\n        int d = r % 2;\n\n        for ( int i = 0; i < DSIZE; ++ i ) {\n            int nr = r + dr[d][i];\n            int nc = c + dc[d][i];\n            if ( ! isValidPos( nr, nc ) ) continue;\n            if ( T[r][c] + 1 >= T[nr][nc] ) continue;\n            T[nr][nc] = T[r][c] + 1;\n            res ++;\n            NODE next( nr, nc );\n            Q.push( next );\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    init();\n    for ( int i = 0; i < s; ++ i ) {\n        spread( Y[i], X[i] );\n    }\n    save();\n    int res = 0;\n    for ( int i = 0; i < t; ++ i ) {\n        load();\n        res = max( res, spread( QT[i], PT[i] ) );\n    }\n    cout << res << endl;\n    return;\n}\n\nvoid input() {\n    cin >> s;\n    for ( int i = 0; i < s; ++ i ) {\n        cin >> X[i] >> Y[i];\n        X[i] -= 1;\n        Y[i] -= 1;\n    }\n    cin >> t;\n    for ( int i = 0; i < t; ++ i ) {\n        cin >> PT[i] >> QT[i];\n        PT[i] -= 1;\n        QT[i] -= 1;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        if ( w == 0 && h == 0 ) break;\n        input();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\t//vector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\trep(i, w + 1) rep (j, h + 1) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]/*v[nx][ny] == 1*/) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\t//v[nx][ny] = 1;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define at(t, i) get<i>(t)\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\nconst int INF = 1 << 28;\nconst int dx[] = {0, -1, -1, 0, 1, 1};\nconst int dy[][6] = {\n\t{-1, 0, 1, 1, 1, 0},\n\t{-1, -1, 0, 1, 0, -1},\n};\n\nint m, n;\nint s, t;\nPr pos[11];\nint dist[11][128][128];\n\nint solve()\n{\n\tfill_n(**dist, 11 * 128 * 128, INF);\n\tfor (int i = 0; i <= s; i++){\n\t\tfor (int j = 0; j <= 127; j++){\n\t\t\tfor (int k = 0; k <= 127; k++){\n\t\t\t\tif (j == 0 || k == 0 || j == 127 || k == 127){\n\t\t\t\t\tdist[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i <= s; i++){\n\t\tdist[i][pos[i].first][pos[i].second] = 0;\n\t\tqueue<Tp> que;\n\t\tfor (que.push(Tp(pos[i].first, pos[i].second, 0)); que.size(); que.pop()){\n\t\t\tTp t = que.front();\n\t\t\tint x = at(t, 0);\n\t\t\tint y = at(t, 1);\n\t\t\tint d = at(t, 2);\n\t\t\t//printf(\"%d %d %d\\n\", x, y, d);\n\t\t\tif (dist[i][x][y] < d) continue;\n\t\t\tfor (int dir = 0; dir < 6; dir++){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[x & 1][dir];\n\t\t\t\tif (dist[i][nx][ny] > d + 1){\n\t\t\t\t\tdist[i][nx][ny] = d + 1;\n\t\t\t\t\tque.push(Tp(nx, ny, d + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i <= s; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tfor (int k = 1; k <= m; k++){\n\t\t\t\tprintf(\"%d \", dist[i][j][k]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\\n\");\n\t}*/\n\t\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tint p = 0;\n\t\t\tfor (int k = 1; k <= s; k++){\n\t\t\t\tif (dist[p][i][j] >= dist[k][i][j]){\n\t\t\t\t\tp = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == 0) res++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tpos[i + 1] = Pr(y, x);\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tpos[0] = Pr(q, p);\n\t\t\tres = max(res, solve());\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint M, N, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > N || nx > M || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v){\n  int res = 1;\n  v[y][x] = n;\n  int t = y % 2 == 0;\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > N || nx > M || v[ny][nx] <= n + 1) continue;\n    res += count(ny, nx, n + 1, v);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>M >>N && M && N){\n    vector< vector<int> > v(M + 1, vector<int>(N + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      res = max(res, count(y, x, 0, v));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint dis(pint a,pint b){\n\tint res=abs(a.Y-b.Y);\n\tif(a.Y%2==0){\n\t\tif(b.Y%2==0){\n\t\t\tres+=max(abs(a.X-b.X)-abs(a.Y-b.Y)/2,0);\n\t\t}else{\n\t\t\tif(a.X<b.X){\n\t\t\t\tres+=max(abs(a.X-b.X)-abs(a.Y-b.Y)/2,0);\n\t\t\t}else{\n\t\t\t\tres+=max(abs(a.X-b.X)-abs(a.Y-b.Y)/2-1,0);\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(b.Y%2==0){\n\t\t\tif(a.X<b.X){\n\t\t\t\tres+=max(abs(a.X-b.X)-abs(a.Y-b.Y)/2-1,0);\n\t\t\t}else{\n\t\t\t\tres+=max(abs(a.X-b.X)-abs(a.Y-b.Y)/2,0);\n\t\t\t}\n\t\t}else{\n\t\t\tres+=max(abs(a.X-b.X)-abs(a.Y-b.Y)/2,0);\n\t\t}\n\t}\n\treturn res;\n}\n\nint d[110][110];\n\nint main() {\n\tint m,n,s,t,res;\n\tpint c,x;\n\tIL{\n\t\tcin>>m;\n\t\tif(m==0)break;\n\t\tres=0;\n\t\tcin>>n>>s;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\td[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\trep(i,s){\n\t\t\tcin>>c.X>>c.Y;\n\t\t\t--c.X;\n\t\t\t--c.Y;\n\t\t\trep(i,n){\n\t\t\t\trep(j,m){\n\t\t\t\t\tchmin(d[i][j],dis(MP(i,j),c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\nrep(i,n){\nrep(j,m){\ndebug<<d[i][j]<<\" \";\n}\ndebug<<endl;\n}\n\t\tcin>>t;\n\t\trep(i,t){\n\t\t\tint r=0;\n\t\t\tcin>>x.X>>x.Y;\n\t\t\t--x.X;\n\t\t\t--x.Y;\n\t\t\trep(i,n){\n\t\t\t\trep(j,m){\n\t\t\t\t\tif(d[i][j]>dis(MP(i,j),x))++r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchmax(res,r);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( node ) == V.end() ) {\n            V.insert( node );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int x,int y)\n{\n\n  deque<P> deq;\n  deq.push_back(P(x,y));\n  mincost[y][x] = 0;\n  visited[y][x] = true;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      P p = deq.front(); deq.pop_front();\n\n      for(int i=0;i<6;i++)\n\t{\n\t  int nx = p.first + dx[p.second%2][i];\n\t  int ny = p.second + dy[p.second%2][i];\n\n\t  if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\t    continue;\n\n\t  if(mincost[ny][nx] > mincost[p.second][p.first] + 1)\n\t    {\n\t      if(!visited[ny][nx])\n\t\tcnt++;\n\t      visited[ny][nx] = true;\n\t      mincost[ny][nx] = mincost[p.second][p.first] + 1;\n\t      deq.push_back(P(nx,ny));\n\t    }\n\t}\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n) break;\n      cin >> m;\n      for(int i=0;i<n;i++) \n\tfor(int j=0;j<m;j++)\n\t  mincost[i][j] = (1<<29);  \n     \n      int s,t,mex = 1;\n      scanf(\"%d\",&s);\n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  mincost[y][x] = 0;\n\t  dfs(x,y);\n\t}\n     \n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n\t{   \n\t  int pre_mincost[n][m];\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  p--,q--;\n\t  dfs(p,q);\n\t  \n\t  mex = max(mex,cnt);\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = pre_mincost[j][k];\n\t}\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint m, n, s, t;//?¨????????????¢?¨??????????????????°?¨?????????°\nint dis[100][100];//???????¨?\nconst int vx1[6] = { -1,-1,0,1,0,-1 };//?????????????\\???°??¨???????????¶??°??¨\nconst int vx2[6] = { -1,0,1,1,1,0 };//??????????????¶??°??¨??????????\\???°??¨\nconst int vy[6] = { 0,-1,-1,0,1,1 };\nP store[10], plan[10];\n\nvoid bfs() {\n\tqueue<PP> q;//???????????????y??§?¨????x??§?¨?\n\tfor (int i = 0; i < s; i++) {\n\t\tq.push(make_pair(0, make_pair(store[i].first, store[i].second)));\n\t\tdis[store[i].first][store[i].second] = -1;//?????§???????????¨?????????-1??¨??????\n\t}\n\twhile (q.size()) {\n\t\tint ct = q.front().first;\n\t\tP tmp = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= n || fx < 0 || fx >= m)continue;\n\t\t\tif (dis[fy][fx] == 0) {\n\t\t\t\tdis[fy][fx] = ct + 1;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int a) {\n\tint ans = 1;\n\tqueue<PP> q;\n\tq.push(make_pair(0, plan[a]));\n\tbool islook[100][100] = {};\n\tbool f = false;\n\tfor (int i = 0; i < s; i++) {\n\t\tif (plan[a] == store[i])f = true;\n\t}\n\tif (f)return 0;\n\tislook[q.front().second.first][q.front().second.second] = true;\n\twhile (q.size()) {\n\t\tP tmp = q.front().second;\n\t\tint ct = q.front().first;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= n || fx < 0 || fx >= m)continue;\n\t\t\tif (!islook[fy][fx] && dis[fy][fx] - ct > 1) {\n\t\t\t\tans++;\n\t\t\t\tislook[fy][fx] = true;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> m >> n, m * n) {\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tcin >> store[i].second >> store[i].first;\n\t\t\tstore[i].first--, store[i].second--;\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tcin >> plan[i].second >> plan[i].first;\n\t\t\tplan[i].first--, plan[i].second--;\n\t\t}\n\t\tbfs();//?????????????????????????????¢?????¬???\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tans = max(bfs2(i), ans);//??¨????£???°?????????\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)for (int j = 0; j < m; j++)dis[i][j] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\ntypedef pair<ll,mp> mmp;\n#define inf 1e9\n\nint dx[2][6] = { {1,1,1,0,-1,0 },{0,1,0,-1,-1,-1} };\nint dy[2][6] = { {-1,0,1,-1,0,1 },{-1,0,1,-1,0,1} };\n\nint main(){\n    while(1){\n\tint n,m;\n\tcin>>m>>n;\n\tif(n==0)break;\n\tqueue<mmp> q;\n\tvector<vector<int> > dp(m+2,vector<int>(n+2,inf) );\n\tvector<vector<int> > dp2(m+2,vector<int>(n+2,inf) );\n\tint s;\n\tcin>>s;\n\tfor(int i=0;i<s;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tdp[x][y] = 0;\n\t\tq.push(mmp(0,mp(x,y) ) );\n\t}\n\twhile(!q.empty() ){\n\t\tmmp now = q.front();\n\t\tint x  = now.second.first;\n\t\tint y  = now.second.second;\n\t\tint cost = now.first;\n\t\tq.pop();\n\t\t/*if(dp[x][y] <= cost ){\n\t\t\tcontinue;\n\t\t}*/\n\t\t//dp[x][y] = cost;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint nx = x + dx[y%2][i];\n\t\t\tint ny = y + dy[y%2][i];\n\t\t\tif(0<nx&&0<ny&&nx<=m&&ny<=n&& dp[nx][ny] > cost+1 ){\n\t\t\t\tq.push(mmp(cost+1, mp(nx,ny) ) );\n\t\t\t\tdp[nx][ny] = cost + 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=1;i<=n;i++){\n\t\tfor(int j = 1;j<=m;j++){\n\t\t\tcout<<dp[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tint t;\n\tcin>>t;\n\tint ans = 0;\n\tdp2 = dp;\n\tfor(int i=0;i<t;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tdp = dp2;\n\t\tint tmp = 0;\n\t\tdp[x][y] = 0;\n\t\tq.push(mmp(0,mp(x,y) ) );\n\t\twhile(!q.empty() ){\n\t\t\tmmp now = q.front();\n\t\t\tint x  = now.second.first;\n\t\t\tint y  = now.second.second;\n\t\t\tint cost = now.first;\n\t\t\tq.pop();\n\t\t\t/*if(dp[x][y] <= cost ){\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\t//cout<<x<<' '<<y<<' '<<cost<<' '<<dp[x][y]<<endl;\n\t\t\tdp[x][y] = cost;\n\t\t\ttmp++;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx = x + dx[y%2][i];\n\t\t\t\tint ny = y + dy[y%2][i];\n\t\t\t\tif(0<nx&&0<ny&&nx<=m&&ny<=n&& dp[nx][ny] > cost+ 1  ){\n\t\t\t\t\tq.push(mmp(cost+1, mp(nx,ny) ) );\n\t\t\t\t\tdp[nx][ny] = cost + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = max(ans,tmp);\n\t}\n\n\n\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\n\n/** Problem0193 : Deven-Eleven **/\nint field[100][100];\nint d[100][100];\nbool vis[100][100];\nconst int dx0[6]={0, 1, 1, 1, 0, -1}, dy0[6]={-1, -1, 0, 1, 1, 0};\nconst int dx1[6]={-1, 0, 1, 0, -1, -1}, dy1[6]={-1, -1, 0, 1, 1, 0};\n\nint main()\n{\n\tint n, m, s, t;\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(field[0], field[0]+100*100, -1);\n\t\tfill(d[0], d[0]+100*100, INF);\n\t\t\n\t\tcin >> s;\n\t\trep(k, s) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tfield[x][y] = k;\n\t\t\t\n\t\t\tfill(vis[0], vis[0]+100*100, false);\n\t\t\tqueue<P> Q;\n\t\t\tqueue<int> dis;\n\t\t\tQ.push(P(x, y));\n\t\t\tdis.push(0);\n\t\t\t\n\t\t\twhile (Q.size()) {\n\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\tint dd = dis.front(); dis.pop();\n\t\t\t\t\n\t\t\t\tif (vis[p.first][p.second])continue;\n\t\t\t\tvis[p.first][p.second]=true;\n\t\t\t\t\n\t\t\t\td[p.first][p.second] = min(dd, d[p.first][p.second]);\n\t\t\t\t\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tif (p.second%2==1) {\n\t\t\t\t\t\tnx = p.first+dx0[i]; ny = p.second+dy0[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnx = p.first+dx1[i]; ny = p.second+dy1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (0<=nx&&nx<m && 0<=ny&&ny<n && !vis[nx][ny]) {\n\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\tdis.push(dd+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\t\n\t\tcin >> t;\n\t\tint ans=0;\n\t\t\n\t\trep(k, t) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx--; y--;\n\t\t\tfill(vis[0], vis[0]+100*100, false);\n\t\t\tqueue<P> Q;\n\t\t\tqueue<int> dis;\n\t\t\tQ.push(P(x, y));\n\t\t\tdis.push(0);\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\twhile (Q.size()) {\n\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\tint dd = dis.front(); dis.pop();\n\t\t\t\t\n\t\t\t\tif (vis[p.first][p.second])continue;\n\t\t\t\tvis[p.first][p.second] = true;\n\t\t\t\t\n\t\t\t\tif (dd<d[p.first][p.second])\n\t\t\t\t\tcnt++;\n\t\t\t\t\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tif (p.second%2==0) {\n\t\t\t\t\t\tnx = p.first+dx0[i]; ny = p.second+dy0[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnx = p.first+dx1[i]; ny = p.second+dy1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (0<=nx&&nx<m && 0<=ny&&ny<n && !vis[nx][ny]) {\n\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\tdis.push(dd+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y %2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[101][101];\nint id_list[101][101];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    min_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(sx,sy,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  int candidate_cost[101][101];\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    candidate_cost[s.x][s.y] = s.cost;\n\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(sx,sy,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= 100 || dy < 0 || dy >= 100) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nclass Node {\npublic:\n    int y, x, depth;\n    Node(int y, int x, int d) :y(y), x(x), depth(d) {}\n};\n\ntypedef tuple<int, int> Point;\n\nenum {EVEN, ODD};\nenum {Y, X};\nconst int NEXT[2][6][2] = {\n    {\n        {-1, -1},\n        {-1, 0},\n        {0, -1},\n        {0, 1},\n        {1, -1},\n        {1, 0},\n    },\n    {\n        {-1, 0},\n        {-1, 1},\n        {0, -1},\n        {0, 1},\n        {1, 0},\n        {1, 1},\n    },\n};\n\nint bfs(vector<vector<int>>& hex, int y, int x, bool write) {\n    int h = hex.size(), w = hex[0].size();\n    int result = 0;\n    set<Point> visited;\n    queue<Node> q;\n    q.push(Node(y, x, 0));\n    while(!q.empty()) {\n        Node current = q.front();\n        q.pop();\n        if(visited.count(Point(current.y, current.x))) continue;\n        visited.insert(Point(current.y, current.x));\n        if(hex[current.y][current.x] <= current.depth) continue;\n        if(write) hex[current.y][current.x] = current.depth;\n        ++result;\n        for(const auto& d: NEXT[y & 1]) {\n            int ny = current.y + d[Y];\n            int nx = current.x + d[X];\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, current.depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int m, n;\n    int s, t;\n    int x, y;\n    while(cin >> m >> n, m | n) {\n        vector<vector<int>> hex(n, vector<int>(m, INF));\n        for(cin >> s; s > 0; --s) {\n            cin >> x >> y;\n            bfs(hex, y - 1, x - 1, true);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            cin >> x >> y;\n            answer = max(answer, bfs(hex, y - 1, x - 1, false));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint m, n, s, t;//?¨????????????¢?¨??????????????????°?¨?????????°\nint dis[100][100];//???????¨?\nconst int vx1[6] = { -1,-1,0,1,0,-1 };//?????????????\\???°??¨???????????¶??°??¨\nconst int vx2[6] = { -1,0,1,1,1,0 };//??????????????¶??°??¨??????????\\???°??¨\nconst int vy[6] = { 0,-1,-1,0,1,1 };\nP store[10], plan[10];\n\nvoid bfs() {\n\tqueue<PP> q;//???????????????y??§?¨????x??§?¨?\n\tfor (int i = 0; i < s; i++) {\n\t\tq.push(make_pair(0, make_pair(store[i].first, store[i].second)));\n\t\tdis[store[i].first][store[i].second] = -1;//?????§???????????¨?????????-1??¨??????\n\t}\n\twhile (q.size()) {\n\t\tint ct = q.front().first;\n\t\tP tmp = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= n || fx < 0 || fx >= m)continue;\n\t\t\tif (dis[fy][fx] == 0) {\n\t\t\t\tdis[fy][fx] = ct + 1;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int a) {\n\tint ans = 1;\n\tqueue<PP> q;\n\tq.push(make_pair(0, plan[a]));\n\tbool islook[100][100] = {};\n\tbool f = false;\n\tfor (int i = 0; i < s; i++) {\n\t\tif (plan[a] == store[i])f = true;\n\t}\n\tif (f)return 0;\n\tislook[q.front().second.first][q.front().second.second] = true;\n\twhile (q.size()) {\n\t\tP tmp = q.front().second;\n\t\tint ct = q.front().first;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= n || fx < 0 || fx >= m)continue;\n\t\t\tif (!islook[fy][fx] && dis[fy][fx] - ct > 1) {\n\t\t\t\tans++;\n\t\t\t\tdis[fy][fx] = true;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> m >> n, m * n) {\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tcin >> store[i].second >> store[i].first;\n\t\t\tstore[i].first--, store[i].second--;\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tcin >> plan[i].second >> plan[i].first;\n\t\t\tplan[i].first--, plan[i].second--;\n\t\t}\n\t\tbfs();//?????????????????????????????¢?????¬???\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tans = max(bfs2(i), ans);//??¨????£???°?????????\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)for (int j = 0; j < m; j++)dis[i][j] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,m;\n  int s,t;\n  int x,y;\n  int grid[101][101];\n\n  while(cin >> n && n){\n    cin >> m;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)grid[i][j] = 1<<25;\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      int hoge = 1;\n      int tmp[101][101];\n      copy(grid,grid+(n+1)*(m+1),tmp);\n\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    hoge++;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n      ans = max(ans,hoge);\n      copy(tmp,tmp+(n+1)*(m+1),grid);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint INF=(1<<24);\nint dy[6]={0,-1,-1,0,1,1};\nint dx[2][6]={\n  {-1,-1,0,1,0,-1},{-1,0,1,1,1,0}\n};\nint W,H,n,m,I;\nint ty[100],tx[100];\nint uy[100],ux[100];\nint v[100][100];\n\nqueue <int> Qy;\nqueue <int> Qx;\nqueue <int> Qcnt;\nqueue <int> Qid;\n\nbool input();\nvoid init(int);\nvoid solve();\nint bfs();\n\nint main(){\n  while(input())solve();\n  return 0;\n}\n\nint bfs(){\n  int y,x,ny,nx,cnt,id,res=0;\n  while(!Qy.empty()){\n    y=Qy.front();Qy.pop();\n    x=Qx.front();Qx.pop();\n    cnt=Qcnt.front();Qcnt.pop();\n    id=Qid.front();Qid.pop();\n\n    if(cnt>=v[y][x])continue;\n    v[y][x]=cnt;\n    if(id==n+I)res++;\n\n    for(int i=0;i<6;i++){\n      ny=y+dy[i];\n      nx=x+dx[y%2][i];\n      if(ny<0||nx<0||ny>=H||nx>=W)continue;\n\t \n      Qy.push(ny);\n      Qx.push(nx);\n      Qcnt.push(cnt+1);\n      Qid.push(id);\n    \n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int ans=0;\n  for(I=0;I<m;I++){\n    init(I);\n    ans=max(ans,bfs());\n  }\n  cout<<ans<<endl;\n}\n\nbool input(){\n  cin>>W>>H;\n  if(W==0&&H==0)return false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>tx[i]>>ty[i];\n  }\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>ux[i]>>uy[i];\n  }\n  return true;\n}\n\nvoid init(int s){\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      v[i][j]=INF;\n    }\n  }\n  while(!Qy.empty()){\n    Qy.pop();\n    Qx.pop();\n    Qcnt.pop();\n    Qid.pop();\n  }\n  \n\n  for(int i=0;i<n;i++){\n    Qy.push(ty[i]);\n    Qx.push(tx[i]);\n    Qcnt.push(0);\n    Qid.push(i);\n  }\n  Qy.push(uy[s]);\n  Qx.push(ux[s]);\n  Qcnt.push(0);\n  Qid.push(n+s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T> T get(){T a;cin >> a;return a;}\ntemplate<typename T> T rev(T & a){reverse(all(a));return a;}\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nclass coord {\n    public:\n        int x, y;\n        coord(int x0, int y0){x=x0;y=y0;};\n};\n\nint dx[2][6] = {{0, -1, 0, 1, 1, 1}, {-1, -1, -1, 0, 1, 0}};\nint dy[6] = {-1, 0, 1, 1, 0, -1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<vector<pii> > mp(101, vector<pii>(101, MP(0, inf)));\n\n        int s; cin >> s;\n\n        rep1(i, s) {\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x, y));\n            mp[y][x] = MP(i, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == i) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(i, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                }\n            }\n        }\n\n        int ma = 0;\n\n        int t; cin >> t;\n\n        rep1(i, t) {\n            int cnt = 1;\n\n            vector<vector<pii> > tmp = mp;\n            int x, y; cin >> x >> y;\n\n            queue<coord> q;\n            q.push(coord(x,y));\n            mp[y][x] = MP(0, 0);\n\n            while (q.size()) {\n                coord crd = q.front(); q.pop();\n                rep(j, 6) {\n                    int ny = crd.y + dy[j], nx = crd.x + dx[crd.y % 2][j];\n                    if (ny < 1 || ny > H || nx < 1 || nx > W) continue;\n                    if (mp[ny][nx].fst == 0) continue;\n                    if (mp[ny][nx].scd < mp[crd.y][crd.x].scd + 1) continue;\n                    if (mp[ny][nx].scd == mp[crd.y][crd.x].scd + 1) {\n                        mp[ny][nx].fst = -1;\n                        continue;\n                    }\n                    mp[ny][nx] = MP(0, mp[crd.y][crd.x].scd + 1);\n                    q.push(coord(nx, ny));\n                    cnt++;\n                }\n            }\n\n            chmax(ma, cnt);\n\n            mp = tmp;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int di[] = {-1,-1,0,0,1,1};\nconst int dj[] = {0,1,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(di)/sizeof(*di); ++i){\n      int ti = now.i + di[i];\n      int tj = now.j + dj[i];\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n\n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( node ) == V.end() ) {\n            // V.insert( node );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int even_di[] = {-1,-1,0,0,1,1};\nconst int even_dj[] = {0,1,-1,1,0,1};\nconst int odd_di[] = {-1,-1,0,0,1,1};\nconst int odd_dj[] = {-1,0,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    if( M.T[now.i][now.j].dist[store] < infty ) continue;\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(even_di)/sizeof(*even_di); ++i){\n      int ti = now.i + ( now.i%2==0 ? even_di[i] : odd_di[i] );\n      int tj = now.j + ( now.i%2==0 ? even_dj[i] : odd_dj[i] );\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n      M.T[now.i][now.j].dist[store] = now.cost+1;\n\n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n\n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n    \n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    V.clear();\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( PII( x, y ) ) == V.end() ) {\n            V.insert( PII( x, y ) );\n            answer++;\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\n\nint dist(pii a, pii b)\n{\n\tint dy = a.first - b.first;\n\tint dx = a.second - b.second;\n\tif(0 <= dy*dx){\n\t\tdy = abs(dy);\n\t\tdx = abs(dx);\n\t\treturn dy + max(0, dx - (dy+1-min(a.first,b.first)%2)/2);\n\t}\n\telse{\n\t\tdy = abs(dy);\n\t\tdx = abs(dx);\n\t\treturn dy + max(0, dx - (dy + min(a.first, b.first)%2)/2);\n\t}\n}\n\nint main()\n{\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n), m){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tpii conv[10];\n\t\trep(i, s)\n\t\t\tscanf(\"%d%d\", &conv[i].second, &conv[i].first);\n\t\t\n\t\tint d[101][101];\n\t\trep(i, n) rep(j, m){\n\t\t\td[i+1][j+1] = INF;\n\t\t\trep(k, s)\n\t\t\t\td[i+1][j+1] = min(d[i+1][j+1], dist(pii(i+1, j+1), conv[k]));\n\t\t}\n\t\t\n\t\tint t, ans = 0;\n\t\tscanf(\"%d\", &t);\n\t\trep(i, t){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\trep(j, n) rep(k, m)\n\t\t\t\tcnt += dist(pii(j, k), pii(y, x)) < d[j+1][k+1];\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint INF=(1<<24);\nint dy[6]={0,-1,-1,0,1,1};\nint dx[2][6]={\n  {-1,-1,0,1,0,-1},{-1,0,1,1,1,0}\n};\nint W,H,n,m,I;\nint ty[100],tx[100];\nint uy[100],ux[100];\nint v[100][100];\n\nqueue <int> Qy;\nqueue <int> Qx;\nqueue <int> Qcnt;\nqueue <int> Qid;\n\nbool input();\nvoid init(int);\nvoid solve();\nint bfs();\n\nint main(){\n  while(input())solve();\n  return 0;\n}\n\nint bfs(){\n  int y,x,ny,nx,cnt,id,res=0;\n  while(!Qy.empty()){\n    y=Qy.front();Qy.pop();\n    x=Qx.front();Qx.pop();\n    cnt=Qcnt.front();Qcnt.pop();\n    id=Qid.front();Qid.pop();\n\n\n    if(id==n+I)res++;\n\n    for(int i=0;i<6;i++){\n      ny=y+dy[i];\n      nx=x+dx[y%2][i];\n      if(ny<0||nx<0||ny>=H||nx>=W)continue;\n      if(cnt+1>=v[ny][nx])continue; \n      v[ny][nx]=cnt+1;\n      Qy.push(ny);\n      Qx.push(nx);\n      Qcnt.push(cnt+1);\n      Qid.push(id);\n    \n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int ans=0;\n  for(I=0;I<m;I++){\n    init(I);\n    ans=max(ans,bfs());\n  }\n  cout<<ans<<endl;\n}\n\nbool input(){\n  cin>>W>>H;\n  if(W==0&&H==0)return false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>tx[i]>>ty[i];\n  }\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>ux[i]>>uy[i];\n  }\n  return true;\n}\n\nvoid init(int s){\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++){\n      v[i][j]=INF;\n    }\n  }\n  while(!Qy.empty()){\n    Qy.pop();\n    Qx.pop();\n    Qcnt.pop();\n    Qid.pop();\n  }\n  \n\n  for(int i=0;i<n;i++){\n    Qy.push(ty[i]);\n    Qx.push(tx[i]);\n    Qcnt.push(0);\n    Qid.push(i);\n    v[ty[i]][tx[i]]=0;\n  }\n  Qy.push(uy[s]);\n  Qx.push(ux[s]);\n  Qcnt.push(0);\n  Qid.push(n+s);\n  v[uy[s]][ux[s]]=0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,m;\n  int s,t;\n  int x,y;\n  int grid[101][101];\n\n  while(cin >> n && n){\n    cin >> m;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)grid[i][j] = 1<<25;\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> x >> y;\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    cin >> t;\n    for(int i=0;i<t;i++){\n      cin >> x >> y;\n      int hoge = 1;\n      int tmp[101][101];\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<m;k++)tmp[j][k] = grid[j][k];\n\n      grid[x][y] = 0;\n      queue<P> q;\n      q.push(P(x,y));\n      while(q.size()){\n\tP p = q.front();q.pop();\n\tx=p.first, y=p.second;\n\n\tint dx[6]={1,0,-1,1,0,1},dy[6] = {-1,-1,0,0,1,1};\n\tif(y&1)dx[0] = dx[5] = -1;\n\tfor(int i=0;i<6;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || n<sx || m<sy)continue;\n\t  if(grid[sx][sy]>grid[x][y]+1){\n\t    grid[sx][sy] = grid[x][y] + 1;\n\t    hoge++;\n\t    q.push(P(sx,sy));\n\t  }\n\t}\n      }\n      ans = max(ans,hoge);\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<m;k++)grid[j][k] = tmp[j][k];\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n \nvoid dfs(int x,int y)\n{\n \n  deque<Pi> deq;\n  deq.push_back(Pi(P(x,y),0));\n  mincost[y][x] = 0;\n  visited[y][x] = true;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      Pi pi = deq.front(); deq.pop_front();\n \n      for(int i=0;i<6;i++)\n    {\n      int nx = pi.first.first + dx[pi.first.second%2][i];\n      int ny = pi.first.second + dy[pi.first.second%2][i];\n \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n        continue;\n \n      if(mincost[ny][nx] > pi.second + 1)\n        {\n          if(!visited[ny][nx])\n        cnt++;\n          visited[ny][nx] = true;\n          mincost[ny][nx] = pi.second + 1;\n          deq.push_back(Pi(P(nx,ny),pi.second+1));\n        }\n    }\n    }\n}\n \nint main()\n{\n  while(cin >> m >> n,m)\n    {\n      cerr << m << \" \" << n << endl;\n      for(int i=0;i<n;i++) \n    for(int j=0;j<m;j++)\n      mincost[i][j] = (1<<29);  \n      \n      int s,t,mex = 1;\n      scanf(\"%d\",&s);\n      cerr << s << endl;\n      for(int i=0;i<s;i++)\n    {\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      cerr << x << \" \" << y << endl;\n      x--,y--;\n      mincost[y][x] = 0;\n      dfs(x,y);\n    }\n      \n      scanf(\"%d\",&t);\n      cerr << t << endl;\n      for(int i=0;i<t;i++)\n    {   \n      int pre_mincost[n][m];\n      for(int j=0;j<n;j++)\n        for(int k=0;k<m;k++)\n          pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n      int p,q;\n      scanf(\"%d %d\",&p,&q);\n      cerr << p << \" \" << q << endl;\n      p--,q--;\n      dfs(p,q);\n       \n      mex = max(mex,cnt);\n      for(int j=0;j<n;j++)\n        for(int k=0;k<m;k++)\n          mincost[j][k] = pre_mincost[j][k];\n    }\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,0,0,1,1,1} };\nint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,1,-1,0,1,-1} };\n\nclass Data{\n        public:\n        int cost;\n        int index;\n        Data(){}\n        Data(int cost,int index):cost(cost),index(index){}\n};\n\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        P(){}\n        P(int x,int y,int cost):x(x),y(y),cost(cost){}\n};\nint m,n,s;\nData field[128][128];\nData cp[128][128];\nvoid bfs(int x,int y,int index){\n        bool vis[128][128]={{0}};\n        queue< P > Q;\n        Q.push(P(x,y,1));\n        field[x][y] = Data(1,index);\n        while( Q.size() ){\n                P p = Q.front();Q.pop();\n                if(vis[p.x][p.y]++)continue;\n                for(int i = 0; i < 6; i++){\n                        int nx = p.x+dx[p.y%2][i];\n                        int ny = p.y+dy[p.y%2][i];\n                        if(nx < 0 || nx > m-1 || ny < 0 || ny > n-1)continue;\n                        if(field[nx][ny].cost > p.cost+1){\n                                field[nx][ny].cost = p.cost+1;\n                                field[nx][ny].index = index;\n                                Q.push(P(nx,ny,p.cost+1));\n                        }\n                        else if(index == s+1 && field[nx][ny].cost == p.cost+1){\n                                field[nx][ny].cost = -1;\n                        }\n                }\n        }\n        return ;\n}\nvoid copy(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        cp[i][j] = field[i][j];\n                }\n        }\n}\nint cnt(){\n        int res = 0;\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        if(field[i][j].index == s+1 && field[i][j].cost != -1)res++;\n                        field[i][j] = cp[i][j];\n                }\n        }\n        return res;\n}\nint main(){\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                scanf(\"%d\",&s);\n\n                for(int i = 0; i < 120; i++){\n                        for(int j = 0; j < 120; j++){\n                                field[i][j] = Data(1000,0);\n                        }\n                }\n\n                for(int i = 0; i < s; i++){\n                        int x,y;\n                        scanf(\"%d%d\",&x,&y);\n                        x--;y--;\n                        bfs(x,y,i+1);\n                        /*puts(\"-----\");\n                        for(int j = 0; j < m ;i++){\n                                for(int k = 0; k < n; j++){\n                                        printf(\"%d \",field[j][k].cost);\n                                }\n                                puts(\"\");\n                        }\n                        puts(\"------\");*/\n                }\n                int t;\n                scanf(\"%d\",&t);\n                copy();\n                int ans = -10000;\n                for(int i = 0; i < t; i++){\n                        /*puts(\"-----\");\n                        for(int i = 0; i < m ;i++){\n                                for(int j = 0; j < n; j++){\n                                        printf(\"%3d\",field[i][j].cost);\n                                }\n                                puts(\"\");\n                        }\n                        puts(\"------\");*/\n                        int x,y;\n                        scanf(\"%d%d\",&x,&y);\n                        x--;y--;\n                        bfs(x,y,s+1);\n                        ans = max(cnt(),ans);\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\n\nint m, n, s;\nint min_cost[100][100];\nbool used[100][100];\nint dy[] = { -1, -1, 0, 1, 1, 0};\nint dx[][6] = {{ -1, 0, 1, 0, -1, -1}, { 0, 1, 1, 1, 0, -1}};\n\nbool isover(int y, int x){\n  return y < 0 || y >= m || x < 0 || x >= n;\n}\n\nvoid bfs(int y, int x){\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  min_cost[y][x] = 0;\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] < p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      min_cost[ny][nx] = p.fr + 1;\n    }\n  }\n}\n\nint prebfs(int y, int x){\n  if(!min_cost[y][x]) return 0;\n\n  int ret = 1;\n  fill_n( *used, 10000, false);\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  used[y][x] = true;\n\n\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || used[ny][nx] || min_cost[ny][nx] <= p.fr + 1) continue;\n        que.push(Pii( p.fr + 1, Pi( ny, nx)));\n        used[ny][nx] = true;\n        ret++;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> m, m){\n    queue< Pii > que;\n    fill_n( *min_cost, 10000, 1 << 30);\n\n    cin >> n >> s;\n\n    for(int i = 0 ; i < s ; i++ ){\n      int x, y;\n      cin >> x >> y;\n      bfs( y - 1, x - 1);\n    }\n\n    int t, ret = 0;\n    cin >> t;\n    while(t--){\n      int p, q;\n      cin >> p >> q;\n      ret = max( ret,prebfs( q - 1, p - 1));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v, vector< vector<bool> > &visited){\n  int res = (v[y][x] <= n ? 0 : 1);\n  int t = (y % 2 == 0);\n  visited[y][x] = 1;\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n    res += count(ny, nx, n + 1, v, visited);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n      res = max(res, count(y, x, 0, v, visited));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n \nvoid dfs(int x,int y)\n{\n \n  deque<Pi> deq;\n  deq.push_back(Pi(P(x,y),0));\n  mincost[y][x] = 0;\n  visited[y][x] = true;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      Pi pi = deq.front(); deq.pop_front();\n \n      for(int i=0;i<6;i++)\n    {\n      int nx = pi.first.first + dx[pi.first.second%2][i];\n      int ny = pi.first.second + dy[pi.first.second%2][i];\n \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n        continue;\n \n      if(mincost[ny][nx] > pi.second + 1)\n        {\n          if(!visited[ny][nx])\n        cnt++;\n          visited[ny][nx] = true;\n          mincost[ny][nx] = pi.second + 1;\n          deq.push_back(Pi(P(nx,ny),pi.second+1));\n        }\n    }\n    }\n}\n \nint main()\n{\n  while(cin >> m >> n,m)\n    {\n      for(int i=0;i<n;i++) \n    for(int j=0;j<m;j++)\n      mincost[i][j] = (1<<29);  \n      \n      int s,t,mex = 1;\n      scanf(\"%d\",&s);\n      for(int i=0;i<s;i++)\n    {\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--,y--;\n      mincost[y][x] = 0;\n      dfs(x,y);\n    }\n      \n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n    {   \n      int pre_mincost[n][m];\n      for(int j=0;j<n;j++)\n        for(int k=0;k<m;k++)\n          pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n      int p,q;\n      scanf(\"%d %d\",&p,&q);\n      p--,q--;\n      dfs(p,q);\n       \n      mex = max(mex,cnt);\n      for(int j=0;j<n;j++)\n        for(int k=0;k<m;k++)\n          mincost[j][k] = pre_mincost[j][k];\n    }\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\n\nint dx1[]={-1,-1,0,+1,0,-1};\nint dy1[]={0,-1,-1,0,+1,+1};\nint dx2[]={-1,0,+1,+1,+1,0};\nint dy2[]={0,-1,-1,0,+1,+1};\n\nint d[110][110];\nbool used[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n\tif(x <= 0 || y <= 0 || x > w || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\tint s = in.nextInt();\n\t\tqueue<pii> q;\n\t\trep(i, 110) rep(j, 110) d[i][j] = INF;\n\t\trep(i, s){\n\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\td[a][b] = 0;\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t//cout<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] != INF) continue;\n\n\t\t\t\td[nx][ny] = c + 1;\n\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t}\n\t\t}\n\n\t\tint t = in.nextInt(), ans = 0;\n\t\trep(i, t){\n\t\t\tint a = in.nextInt(), b = in.nextInt(), tmp = 1;\n\t\t\tq.push(mp(0, a * 1000 + b));\n\t\t\t//vector<vector<int> > v(w + 1, vi(h + 1, 0));\n\t\t\trep(i, w + 1) rep (j, h + 1) used[i][j] = false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x = q.front().se / 1000, y = q.front().se % 1000, c = q.front().fi; q.pop();\n\t\t\t\trep(i, 6){\n\t\t\t\t\tint nx = x + ((y % 2 == 1) ? dx1[i] : dx2[i]);\n\t\t\t\t\tint ny = y + ((y % 2 == 1) ? dy1[i] : dy2[i]);\n\t\t\t\t\tif(isOutOfRange(nx, ny, w, h) || d[nx][ny] <= c + 1 || used[nx][ny]/*v[nx][ny] == 1*/) continue;\n\n\t\t\t\t\ttmp++;\n\t\t\t\t\t//v[nx][ny] = 1;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push(mp(c + 1, nx * 1000 + ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\t// rep(i, h){\n\t\t// \trep(j, w){\n\t\t// \t\tif(j & 1) printf(\"%2d  \", d[j][i]);\n\t\t// \t\telse printf(\"  %2d\", d[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint d[11][MAX][MAX]; \n\nint get_max_block(int M, int N,\n                  vector<int> &x, vector<int> &y)\n{\n    int s = x.size();\n    vector<int> cnt(s, 0);\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            int mini = INF, mid = -1, c = -1;\n            for (int k = 0; k < s; k++) {\n                if (d[k][i][j] < mini) {\n                    mini = d[k][i][j];\n                    c = 1;\n                    mid = k;\n                } else if (d[k][i][j] == mini) {\n                    c = -1;\n                }\n            }\n            if (c == 1) {\n                cnt[mid]++;\n            }\n        }\n    }        \n    return cnt[s-1];\n}\n\nint get_dist(int sx, int sy, int gx, int gy, int M, int N)\n{\n    queue<pii> Q;\n    Q.push(pii(sx, sy));\n\n    vector<vector<int>> md(MAX, vector<int>(MAX, INF));\n    md[sy][sx] = 0;\n\n    const int dx[2][6] = {\n        {-1, +0, -1, +1, -1, +0},\n        {+0, +1, -1, +1, +0, +1}\n    };\n    const int dy[6] = {-1, -1, +0, +0, +1, +1};\n    \n    while (!Q.empty()) {\n        pii p = Q.front(); Q.pop();\n        int x = p.first, y = p.second;\n        if (x == gx && y == gy) {\n            return md[y][x];\n        }\n\n        for (int i = 0; i < 6; i++) {\n            int nx = x + dx[y&1][i];\n            int ny = y + dy[i];\n\n            if (0 <= nx && nx < M && 0 <= ny && ny < N) {\n                if (md[y][x] + 1 < md[ny][nx]) {\n                    md[ny][nx] = md[y][x] + 1;\n                    Q.push(pii(nx, ny));\n                }\n            }\n        }        \n    }\n    return INF;\n}\n\nint main()\n{\n    int M, N, s, t;\n    while (cin >> M >> N, M) {\n        cin >> s;\n        vector<int> x(s), y(s);\n        for (int i = 0; i < s; i++) {\n            cin >> x[i] >> y[i];\n            x[i]--; y[i]--;\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < N; k++) {\n                    d[i][j][k] = get_dist(x[i], y[i], j, k, M, N);\n                }\n            }\n        }\n        \n        int res = 0;\n        \n        cin >> t;\n        for (int i = 0; i < t; i++) {\n            int X, Y;\n            cin >> X >> Y;\n            X--; Y--;\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < N; k++) {\n                    d[s][j][k] = get_dist(X, Y, j, k, M, N);\n                }\n            }\n            x.push_back(X); y.push_back(Y);\n            res = max(res, get_max_block(M, N, x, y));\n            x.pop_back(); y.pop_back();\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int even_di[] = {-1,-1,0,0,1,1};\nconst int even_dj[] = {0,1,-1,1,0,1};\nconst int odd_di[] = {-1,-1,0,0,1,1};\nconst int odd_dj[] = {-1,0,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  //if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  //if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    if( M.T[now.i][now.j].dist[store] < infty ) continue;\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(even_di)/sizeof(*even_di); ++i){\n      int ti = now.i + ( now.i%2==0 ? even_di[i] : odd_di[i] );\n      int tj = now.j + ( now.i%2==0 ? even_dj[i] : odd_dj[i] );\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n      M.T[ti][tj].dist[store] = now.cost+1;\n      \n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n\n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n    \n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nconst int e_dx[] = {0, 1, 1, 1, 0, -1};\nconst int e_dy[] = {-1, -1, 0, 1, 1, 0};\nconst int o_dx[] = {-1, 0, 1, 0, -1, -1};\nconst int o_dy[] = {-1, -1, 0, 1, 1, 0};;\n\nint m, n;\nint place[102][102];\n\nclass state {\npublic:\n    int x, y;\n    int cnt;\n    state(int a, int b, int c) { x = a; y = b; cnt = c; }\n};\n\nvoid init()\n{\n    for (int y = 1; y <= n; y++)\n        for (int x = 1; x <= m; x++)\n            place[y][x] = 9;\n\n    int s;\n    cin >> s;\n    for (int i = 0; i < s; i++) {\n        int x, y;\n\n        cin >> x >> y;\n        place[y][x] = 0;\n        state s(x, y, 0);\n        queue<state> q;\n        q.push(s);\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx, ny;\n                if (now.y % 2) {\n                    nx = now.x + o_dx[i];\n                    ny = now.y + o_dy[i];\n                }\n                else {\n                    nx = now.x + e_dx[i];\n                    ny = now.y + e_dy[i];\n                }\n\n                if (nx < 1 || nx > m || ny < 1 || ny > n)\n                    continue;\n                if (now.cnt + 1 < place[ny][nx]) {\n                    place[ny][nx] = now.cnt + 1;\n                    state tmp(nx, ny, now.cnt + 1);\n                    q.push(tmp);\n                }\n            }\n        }\n    }\n}\n\n\nvoid bfs()\n{\n    int t;\n    int ans = 0;\n\n    cin >> t;\n    while (t--) {\n        int p, q;\n        map<pair<int, int>, bool > ma;\n        int num = 1;\n\n        cin >> p >> q;\n        state s(p, q, 0);\n        queue<state> qu;\n        ma[pair<int, int>(p, q)] = true;\n        qu.push(s);\n\n        while (!qu.empty()) {\n            state now = qu.front();\n            qu.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx, ny;\n                if (now.y % 2) {\n                    nx = now.x + o_dx[i];\n                    ny = now.y + o_dy[i];\n                }\n                else {\n                    nx = now.x + e_dx[i];\n                    ny = now.y + e_dy[i];\n                }\n\n                if (nx < 1 || nx > m || ny < 1 || ny > n)\n                    continue;\n                if (ma.count(pair<int, int>(nx, ny)) != 0)\n                    continue;\n                if (now.cnt + 1 < place[ny][nx]) {\n                    num++;\n                    state tmp(nx, ny, now.cnt + 1);\n                    qu.push(tmp);\n                    ma[pair<int, int>(nx, ny)] = true;\n                }\n            }\n        }\n        ans = max(ans, num);\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    while (cin >> m >> n, m) {\n        init();        \n        bfs();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    V.clear();\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.count( PII( x, y ) ) == 0 ) {\n            V.insert( PII( x, y ) );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\n\nint m,n;\nint s,t;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nconst int INF=10000000;\nint field[101][101];\nint field2[101][101];\nint x[11],y[11];\nint nx[11],ny[11];\nint dx1[6]={0,-1,0,1,1,1};\nint dx2[6]={-1,-1,-1,0,1,0};\nint dy[6]={-1,0,1,-1,0,1};\n\nvoid bfs(int sx,int sy){\n\tqueue<PP> que;\n\tque.push(PP(P(sx,sy),0));\n\tfield[sx][sy]=0;\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field[px][py]>c+1){\n\t\t\t\tfield[px][py]=c+1;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int sx,int sy){\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfield2[i][j]=field[i][j];\n\t\t}\n\t}\n\tqueue<PP> que;\n\tint res=1;\n\tif(field2[sx][sy]==0)return 0;\n\tque.push(PP(P(sx,sy),0));\n\twhile(que.size()){\n\t\tPP q=que.front();que.pop();\n\t\tint cx=q.first.first,cy=q.first.second;\n\t\tint c=q.second;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint py=cy+dy[i];\n\t\t\tint px=cx;\n\t\t\tif(cy%2==0)px+=dx1[i];\n\t\t\tif(cy%2==1)px+=dx2[i];\n\t\t\tif(px>=1 && px<=m && py>=1 && py<=n && field2[px][py]>c+1){\n\t\t\t\tres++;\n\t\t\t\tque.push(PP(P(px,py),c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint ans=0;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfield[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tif(m==0)break;\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tbfs(x[i],y[i]);\n\t\t}\n\t\tcin >> t;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> nx[i] >> ny[i];\n\t\t\tans=max(ans,bfs2(nx[i],ny[i]));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct pos\n{\n\tint x,y,cost;\n\tbool operator ()(pos const& a, pos const& b) const\n\t{\n\t\treturn a.cost>b.cost;\n\t}\n\n}pos;\n\nint M,N,S,T,m[101][101],i,j,p,q,R,t;\n\nint bfs(int x,int y,int abj)\n{\n\tint i,c=1,mx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}},\n\t\t\t  my[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\n\tpriority_queue<pos,vector<pos>,pos>Q;\n\tm[y][x]=0;\n\tpos tmp={x,y,0};\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tfor(i=0;i<abj;i++)\n\t\t{\n\t\t\tif(0<=tmp.y+my[tmp.y%2][i]&&tmp.y+my[tmp.y%2][i]<N&&0<=tmp.x+mx[tmp.y%2][i]&&tmp.x+mx[tmp.y%2][i]<M)\n\t\t\t\tif(m[tmp.y+my[tmp.y%2][i]][tmp.x+mx[tmp.y%2][i]]>tmp.cost+1)\n\t\t\t\t{\n\t\t\t\t\tm[tmp.y+my[tmp.y%2][i]][tmp.x+mx[tmp.y%2][i]]=tmp.cost+1;\n\t\t\t\t\tpos tmp2={tmp.x+mx[tmp.y%2][i],tmp.y+my[tmp.y%2][i],tmp.cost+1};\n\t\t\t\t\tc++;\n\t\t\t\t\tQ.push(tmp2);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tfor(i=0;i<105;i++)\n\t\tfor(j=0;j<105;j++)\n\t\t{\n\n\t\t}\n\tfor(;~scanf(\"%d%d%d\",&M,&N,&S),M;)\n\t{\n\t\tmemset(m,0x7,sizeof(m));\n\t\tfor(i=0;i<S;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tbfs(p-1,q-1,6);\n\t\t}\n\t\tfor(R=0,scanf(\"%d\",&T),j=0;j<T;j++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tt=bfs(p-1,q-1,6);\n\t\t\tR=t<R?R:t;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\nbool f;\n\nvoid dfs(int x,int y,int cost)\n{\n  //if(!f)\n  //cout << \"xy = \"  << x << \",\" << y << \" cost = \" << cost << endl;\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n      //if(!f)cout << \"mincost[\"<<ny<<\"][\"<<nx<<\"] = \" << mincost[ny][nx] << \" = cost + 1  = \" << cost + 1  << endl;\n      if(mincost[ny][nx] > cost+1)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  mincost[ny][nx] = cost + 1;\n\t  dfs(nx,ny,cost+1);\n\t}\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n) break;\n      cin >> m;\n      for(int i=0;i<n;i++) \n\tfor(int j=0;j<m;j++)\n\t  mincost[i][j] = (1<<29);  \n      f = true;\n      int s,t,mex = 0;\n      scanf(\"%d\",&s);\n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  mincost[y][x] = 0;\n\t  dfs(x,y,0);\n\t}\n      f = false;\n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n\t{   \n\t  int pre_mincost[n][m];\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\n\t  cnt = 1,p--,q--;\n\t  mincost[q][p] = 0,visited[q][p] = true;\n\t  \n\t  dfs(p,q,0);\n\t  \n\t  mex = max(mex,cnt);\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = pre_mincost[j][k];\n\t}\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef long long int ll;\n\nint n, m;\nint dom[6] = {1, 1, 1, 0, -1, 0};\nint don[6] = {-1, 0, 1, -1, 0, 1};\nint dem[6] = {-1, -1, -1, 0, 1, 0};\nint den[6] = {-1, 0, 1, -1, 0, 1};\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\nint solve(int x,int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\n\nint main()\n{\n    while (cin >> n >> m, (n|m)) {\n        int s, t;\n        vector<vector<int> > g(n, vector<int>(m, 0));\n        vector<vector<bool> > pos(n, vector<bool>(m, false));\n        cin >> s;\n        for (int i = 0; i < s; i++) {\n            int x, y;\n            cin >> x >> y;\n            pos[y-1][x-1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                //cout << \"===\" << i << j << \"===\" << endl;\n                g[i][j] = bfs(i, j, g, pos);\n                \n            }\n            //cout << endl;\n        }\n        cin >> t;\n        int ans = -INF;\n        for (int i = 0; i < t; i++) {\n            int x, y;\n            cin >> x >> y;\n            ans = max(solve(y-1, x-1, g, pos), ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint solve(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0, dist = 0;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front(); a.pop();\n            x = tmp.first; y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (dist < g[x][y]) {\n                ret++;\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n\t                    int nx = x + don[i];\n    \t                int ny = y + dom[i];\n        \t            if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }\n                \t} else {\n\t                    int nx = x + den[i];\n    \t                int ny = y + dem[i];\n        \t            if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }                \t\t\n                \t}\n                }\n            }\n        }\n        a = b;\n        b = c;\n        dist++;\n    }\n    return ret;\n}\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0;\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front();\n            a.pop();\n            x = tmp.first;\n            y = tmp.second;\n            if (pos[x][y]) {\n                return ret;\n            } else {\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n    \t                int nx = x + don[i];\n        \t            int ny = y + dom[i];\n            \t        if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t} else {\n    \t                int nx = x + den[i];\n        \t            int ny = y + dem[i];\n            \t        if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t}\n                }\n            }\n        }\n        ret++;\n        a = b;\n        b = c;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint count(int y, int x, int n, vector< vector<int> > &v, vector< vector<bool> > &visited, bool f){\n  int res = 1;\n  if(!f && v[y][x] <= n) res = 0;\n  int t = (y % 2 == 0);\n  visited[y][x] = 1;\n  REP(i, 6){\n    int ny = y + my[t][i], nx = x + mx[t][i];\n    if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n    res += count(ny, nx, n + 1, v, visited, 1);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int res = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n      res = max(res, count(y, x, 0, v, visited, 0));\n    }\n    cout <<res <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int even_di[] = {-1,-1,0,0,1,1};\nconst int even_dj[] = {0,1,-1,1,0,1};\nconst int odd_di[] = {-1,-1,0,0,1,1};\nconst int odd_dj[] = {-1,0,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  //if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  //if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    if( M.T[now.i][now.j].dist[store] < infty ) continue;\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(even_di)/sizeof(*even_di); ++i){\n      int ti = now.i + ( now.i%2==0 ? even_di[i] : odd_di[i] );\n      int tj = now.j + ( now.i%2==0 ? even_dj[i] : odd_dj[i] );\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n      M.T[now.i][now.j].dist[store] = now.cost+1;\n\n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n\n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n    \n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\ntypedef pair<int, int> P;\n\nint M, N, S, T;\nvector<P> a;\nvector<P> b;\n\nbool input() {\n  cin >> M >> N;\n  if (!M && !N) {\n    return false;\n  }\n  cin >> S;\n  a.resize(S);\n  for (int i = 0; i < S; ++i) {\n    cin >> a[i].first >> a[i].second;\n    --a[i].first;\n    --a[i].second;\n  }\n  cin >> T;\n  b.resize(T);\n  for (int i = 0; i < T; ++i) {\n    cin >> b[i].first >> b[i].second;\n    --b[i].first;\n    --b[i].second;\n  }\n  return true;\n}\n\nP conv1(P p) {\n  int x = p.first - (p.second/2);\n  int y = p.second;\n  return P(x, y);\n}\n\nP conv2(P p) {\n  P q = conv1(p);\n  return P(-q.second, q.first + q.second);\n}\n\nP conv3(P p) {\n  P q = conv1(p);\n  return P(q.first + q.second, -q.first);\n}\n\nint dist_sub(P p, P q) {\n  return abs(p.first - q.first) + abs(p.second - q.second);\n}\n\nint dist(P p, P q) {\n  P p1 = conv1(p);\n  P p2 = conv2(p);\n  P p3 = conv3(p);\n  P q1 = conv1(q);\n  P q2 = conv2(q);\n  P q3 = conv3(q);\n  int d1 = dist_sub(p1, q1);\n  int d2 = dist_sub(p2, q2);\n  int d3 = dist_sub(p3, q3);\n  if (d1 <= d2 && d1 <= d3) {\n    return d1;\n  }\n  if (d2 <= d3) {\n    return d2;\n  }\n  return d3;\n}\n\nint solve() {\n  int ans = -1;\n  vector<P> c;\n  c.resize(S + 1);\n  for (int i = 0; i < S; ++i) {\n    c[i] = a[i];\n  }\n  vector<int> counter;\n  counter.resize(S + 1);\n  for (int i = 0; i < T; ++i) {\n    c[S] = b[i];\n    for (int j = 0; j <= S; ++j) {\n      counter[j] = 0;\n    }\n    for (int j = 0; j < M; ++j) {\n      for (int k = 0; k < N; ++k) {\n        bool same_flag = false;\n        int min_dist = INF;\n        int min_id = -1;\n        for (int l = 0; l <= S; ++l) {\n          int d = dist(P(j, k), c[l]);\n          if (min_dist == d) {\n            same_flag = true;\n          } else if (min_dist > d) {\n            min_dist = d;\n            min_id = l;\n            same_flag = false;\n          }\n        }\n        if (!same_flag) {\n          ++counter[min_id];\n        }\n      }\n    }\n    if (ans < counter[S]) {\n      ans = counter[S];\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n  while (input()) {\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dyo[] = {0, -1, -1, 0, 1, 1};\nint dxo[] = {1, 1, 0, -1, 0, 1};\n\nint dye[] = {0, -1, -1, 0, 1, 1};\nint dxe[] = {1, 0, -1, -1, -1, 0};\n\nint main(){\n    while(1){\n        int m, n; cin>>m>>n;\n        if(m == 0) return 0;\n        int s; cin>>s;\n        vector<int> x(s), y(s);\n        vector<vector<int>> dist(n, vector<int>(m, 1e9));\n        queue<T> que;\n        for(int i=0; i<s; i++){\n            cin>>x[i]>>y[i];\n            x[i]--;\n            y[i]--;\n            dist[y[i]][x[i]] = 0;\n            que.emplace(y[i], x[i], 0);\n        }\n\n        while(que.size()){\n            int cy, cx, cnt;\n            tie(cy, cx, cnt) = que.front();\n            que.pop();\n\n            for(int i=0; i<6; i++){\n                int ny, nx;\n                if(cy % 2 == 0){\n                    ny = cy + dye[i];\n                    nx = cx + dxe[i];\n                }\n                else{\n                    ny = cy + dyo[i];\n                    nx = cx + dxo[i];\n                }\n\n                if(0 <= ny && ny < n && 0 <= nx && nx < m){\n\n                    if(cnt + 1 < dist[ny][nx]){\n                        dist[ny][nx] = cnt + 1;\n                        que.emplace(ny, nx, cnt + 1);\n                    }\n                }\n            }\n        }\n\n        int t; cin>>t;\n        int ans = 0;\n        for(int i=0; i<t; i++){\n            int p, q; cin>>p>>q;\n            p--;\n            q--;\n\n            int sum = 0;\n            vector<vector<int>> cdist(n, vector<int>(m, 1e9));\n            cdist[q][p] = 0;\n            que.emplace(q, p, 0);\n            while(que.size()){\n                int cy, cx, cnt;\n                tie(cy, cx, cnt) = que.front();\n                que.pop();\n\n                for(int j=0; j<6; j++){\n                    int ny, nx;\n                    if(cy % 2 == 0){\n                        ny = cy + dye[j];\n                        nx = cx + dxe[j];\n                    }\n                    else{\n                        ny = cy + dyo[j];\n                        nx = cx + dxo[j];\n                    }\n\n\n                    if(0 <= ny && ny < n && 0 <= nx && nx < m){\n                        if(cnt + 1 < cdist[ny][nx]){\n                            cdist[ny][nx] = cnt + 1;\n                            //if(dist[ny][nx] <= cdist[ny][nx]) continue;\n                            que.emplace(ny, nx, cnt + 1);\n                        }\n                    }\n                }\n            }\n\n            for(int j=0; j<n; j++){\n                for(int k=0; k<m; k++){\n                    if(cdist[j][k] < dist[j][k]){\n                        sum++;\n                    }\n                }\n            }\n\n            ans = max(ans, sum);\n        \n        }\n\n        \n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct st { int x, y, c; };\nint d[100][100], b[100][100], x[10], y[10];\nint dx[][6]{ { 0,-1,0,1,1,1, },{-1,-1,-1,0,1,0} };\nint dy[]{ -1,0,1,1,0,-1 };\nint main() {\n\tint m, n, s;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tscanf(\"%d\", &s);\n\t\trep(i, s)scanf(\"%d%d\", &x[i], &y[i]), x[i]--, y[i]--;\n\t\tint t; scanf(\"%d\", &t);\n\t\tint Max = 0;\n\t\trep(i, t) {\n\t\t\tint p, q; scanf(\"%d%d\", &p, &q); p--; q--;\n\t\t\tqueue<st>que;\n\t\t\tmemset(d, -1, sizeof(d));\n\t\t\trep(j, s) {\n\t\t\t\td[x[j]][y[j]] = 0; b[x[j]][y[j]] = j;\n\t\t\t\tque.push({ x[j],y[j],j });\n\t\t\t}\n\t\t\td[p][q] = 0; b[p][q] = s; que.push({ p,q,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tst p = que.front(); que.pop();\n\t\t\t\trep(j, 6) {\n\t\t\t\t\tint nx = p.x + dx[!(p.y & 1)][j], ny = p.y + dy[j];\n\t\t\t\t\tif (0 <= nx&&nx < m && 0 <= ny&&ny < n) {\n\t\t\t\t\t\tif (d[nx][ny] == -1) {\n\t\t\t\t\t\t\td[nx][ny] = d[p.x][p.y] + 1;\n\t\t\t\t\t\t\tb[nx][ny] = p.c;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (d[nx][ny] == d[p.x][p.y] + 1) {\n\t\t\t\t\t\t\tb[nx][ny] = -1;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\trep(i, m)rep(j, n) {\n\t\t\t\tif (b[i][j] == s)cnt++;\n\t\t\t}\n\t\t\tMax = max(Max, cnt);\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\npair<int,int> hanicam(int x,int y,int angle){\n  if(y % 2 == 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x-1,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n  else if(y %2 != 0){\n    switch(angle){\n    case 0:\n      //upper left\n      return pair<int,int>(x,y-1);\n      break;\n    case 1:\n      //upper right\n      return pair<int,int>(x+1,y-1);\n      break;\n    case 2:\n      //right\n      return pair<int,int>(x+1,y);\n      break;\n    case 3:\n      //lower right\n      return pair<int,int>(x+1,y+1);\n      break;\n    case 4:\n      //lower left\n      return pair<int,int>(x,y+1);\n      break;\n    case 5:\n      //left\n      return pair<int,int>(x-1,y);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  int id;\n  State(int _x,int _y,int _c,int _i) : x(_x),y(_y),cost(_c), id(_i) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint min_cost[101][101];\nint id_list[101][101];\nint W,H;\n\nvoid bfs(int sx,int sy,int id){\n  min_cost[sx][sy] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(sx,sy,0,id));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(sx,sy,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      min_cost[dx][dy] = s.cost + 1;\n      id_list[dx][dy] = s.id;\n\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n}\n\nint candidate_bfs(int sx,int sy){\n  int candidate_cost[101][101];\n  memset(candidate_cost,0x3f,sizeof(candidate_cost));\n  candidate_cost[sx][sy] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  \n  que.push(State(sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int angle=0;angle < 6;angle++){\n      pair<int,int> next = hanicam(sx,sy,angle);\n      int dx = next.first;\n      int dy = next.second;\n      if(dx < 0 || dx >= 100 || dy < 0 || dy >= 100) continue;\n      if(min_cost[dx][dy] <= s.cost + 1) continue;\n      if(candidate_cost[dx][dy] <= s.cost + 1) continue;\n      candidate_cost[dx][dy] = s.cost + 1;\n      que.push(State(dx,dy,s.cost + 1,s.id));\n    }\n  }\n\n  int res = 0;\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(candidate_cost[x][y] != INF){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    memset(min_cost,0x3f,sizeof(min_cost));\n    memset(id_list,-1,sizeof(id_list));\n\n    map<pair<int,int>,bool> stage;\n    int total_existing_stores;\n    scanf(\"%d\",&total_existing_stores);\n    for(int store_idx = 0; store_idx < total_existing_stores; store_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      bfs(x,y,store_idx);\n    }\n\n    int total_new_stores;\n\n    int res = 0;\n    scanf(\"%d\",&total_new_stores);\n    for(int store_idx = 0; store_idx < total_new_stores; store_idx++){\n      int sx,sy;\n      scanf(\"%d %d\",&sx,&sy);\n\n      sx--;\n      sy--;\n      res = max(res,candidate_bfs(sx,sy));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nconst int dx[2][6] = {\n    {-1, 0, -1, 1, -1, 0},\n    {0, 1, -1, 1, 0, 1}\n};\nconst int dy[2][6] = {\n    {-1, -1, 0, 0, 1, 1},\n    {-1, -1, 0, 0, 1, 1}\n};\n\nint m, n;\npair<int,int> bloc[100][100], tmp[100][100];\n\nvoid dfs(int idx, int x, int y, int dist) {\n    if (dist < bloc[y][x].second) {\n        bloc[y][x] = make_pair(idx, dist);\n        for (int i=0; i<6; ++i) {\n            if (0 <= x+dx[y%2][i] && x+dx[y%2][i] < m &&\n                0 <= y+dy[y%2][i] && y+dy[y%2][i] < n) {\n                dfs(idx, x+dx[y%2][i], y+dy[y%2][i], dist+1);\n            }\n        }\n    } else if (idx != bloc[y][x].first && dist == bloc[y][x].second) {\n        bloc[y][x] = make_pair(-1, dist);\n    }\n}\n\nint main() {\n    while (cin >> m >> n, (m || n)) {\n        for (int i=0; i<100; ++i) for (int j=0; j<100; ++j) {\n            bloc[i][j] = make_pair(INT_MAX, INT_MAX);\n        }\n        int s;\n        cin >> s;\n        int x, y;\n        for (int i=0; i<s; ++i) {\n            cin >> x >> y;\n            dfs(i, x-1, y-1, 0);\n        }\n        int t;\n        cin >> t;\n        int p, q, res = 0;\n        for (int i=0; i<t; ++i) {\n            cin >> p >> q;\n            memcpy(tmp, bloc, sizeof bloc);\n            dfs(s, p-1, q-1, 0);\n            int cnt = 0;\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<m; ++j) {\n                    if (bloc[i][j].first == s) {\n                        ++ cnt;\n                    }\n                }\n            }\n            res = max(res, cnt);\n            memcpy(bloc, tmp, sizeof tmp);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint hexDist(int y1, int x1, int y2, int x2)\n{\n    if(y1 > y2){\n        swap(y1, y2);\n        swap(x1, x2);\n    }\n\n    int x3 = x1 - (y2 - y1) / 2;\n    int x4 = x1 + (y2 - y1) / 2;\n    if((y2 - y1) % 2 == 1){\n        if(y1 % 2 == 0)\n            -- x3;\n        else\n            ++ x4;\n    }\n\n    if(x2 < x3)\n        return (y2 - y1) + (x3 - x2);\n    if(x2 > x4)\n        return (y2 - y1) + (x2 - x4);\n    return y2 - y1;\n}\n\nint main()\n{\n    for(;;){\n        int m, n, s;\n        cin >> m >> n >> s;\n        if(m == 0)\n            return 0;\n\n        vector<vector<int> > dist(n, vector<int>(m, INT_MAX));\n        for(int i=0; i<s; ++i){\n            int x, y;\n            cin >> x >> y;\n\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<m; ++k){\n                    dist[j][k] = min(dist[j][k], hexDist(j, k, y-1, x-1));\n                }\n            }\n        }\n\n        int t;\n        cin >> t;\n\n        int ret = 0;\n        for(int i=0; i<t; ++i){\n            int x, y;\n            cin >> x >> y;\n\n            int num = 0;\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<m; ++k){\n                    if(hexDist(j, k, y-1, x-1) < dist[j][k])\n                        ++ num;\n                }\n            }\n            ret = max(ret, num);\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[2][6] = { {0, -1, -1, -1, 0, 1}, {1, 0, -1, 0, 1, 1} };\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\n\nclass State\n{\npublic:\n  int x, y, c;\n  State(int _x = 0, int _y = 0, int _c = 0)\n    :x(_x), y(_y), c(_c) {}\n};\n\nint main()\n{\n  int m, n;\n  while (cin >> m >> n) {\n    if ((m|n) == 0)\n      break;\n\n    int s;\n    cin >> s;\n    vector<vector<int> > cost(n, vector<int>(m, INF));\n    for (int i = 0; i < s; ++i) {\n      int x, y;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1, 0));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] < st.c)\n\t  continue;\n\n\tcost[st.y][st.x] = st.c;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] <= st.c+1)\n\t    continue;\n\t  cost[y][x] = st.c+1;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n    }\n\n    int t;\n    cin >> t;\n    int ans = 0;\n    for (int i = 0; i < t; ++i) {\n      int x, y, cnt = 0;\n      cin >> x >> y;\n      queue<State> que;\n      que.push(State(x-1, y-1, 0));\n      vector<vector<int> > visited(n, vector<int>(m, 0));\n      while (!que.empty()) {\n\tconst State st = que.front();\n\tque.pop();\n\n\tif (cost[st.y][st.x] <= st.c || visited[st.y][st.x])\n\t  continue;\n\n\t++cnt;\n\tvisited[st.y][st.x] = 1;\n\tfor (int d = 0; d < 6; ++d) {\n\t  x = st.x + dx[st.y%2][d];\n\t  y = st.y + dy[d];\n\t  if (x < 0 || m <= x || y < 0 || n <= y || cost[y][x] <= st.c+1 || visited[y][x])\n\t    continue;\n\t  que.push(State(x, y, st.c+1));\n\t}\n      }\n      ans = max(ans, cnt);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<climits>\n#include<algorithm>\nusing namespace std;\n\nenum{X, Y, DEPTH};\ntypedef tuple<int, int, int> Node;\n\nint dx[2][6] = {{-1, 0, -1, 1, -1, 0}, {0, 1, -1, 1, 0, 1}};\nint dy[2][6] = {{-1, -1, 0, 0, 1, 1}, {-1, -1, 0, 0, 1, 1}};\n\nint m, n;\nvector<vector<int>> field;\n\nint bfs(int start_x, int start_y, bool write) {\n    int result = 0;\n    vector<vector<int>> visited(m, vector<int>(n, 0));\n    queue<Node> q;\n    q.push(Node(start_x, start_y, 0));\n    while(!q.empty()) {\n        int x = get<X>(q.front());\n        int y = get<Y>(q.front());\n        int depth = get<DEPTH>(q.front());\n        q.pop();\n        if(visited[x][y]) continue;\n        visited[x][y] = 1;\n        if(field[x][y] <= depth) continue;\n        if(write) field[x][y] = depth;\n        ++result;\n        for(int i = 0; i < 6; ++i) {\n            int nx = x + dx[y & 1][i];\n            int ny = y + dy[y & 1][i];\n            if(nx < 0 || m <= nx || ny < 0 || n <= ny) continue;\n            q.push(Node(nx, ny, depth + 1));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int s, t;\n    int x, y;\n    while(cin >> m >> n, m | n) {\n        field = vector<vector<int>>(m, vector<int>(n, INT_MAX));\n        for(cin >> s; s > 0; --s) {\n            cin >> x >> y;\n            bfs(x - 1, y - 1, true);\n        }\n        int answer = 0;\n        for(cin >> t; t > 0; --t) {\n            cin >> x >> y;\n            answer = max(answer, bfs(x - 1, y - 1, false));\n        }\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;//x, y\ntypedef pair<int, pii> piii;//cost, x, y\nint dx[2][6] = {\n  {0, 1, 0, -1, -1, -1},\n  {1, 1, 1,  0, -1,  0}\n};\nint dy[2][6] = {\n  {-1, 0, 1, 1, 0, -1},\n  {-1, 0, 1, 1, 0, -1}\n};\nint grid[110][110];\nint n, m, a;\n\nint bfs(int grid[110][110], int sx, int sy){\n  queue<piii> que;\n  int ans = 1;\n  grid[sy][sx] = 0;\n  que.push(mp(0, mp(sx, sy)));\n  while(!que.empty()){\n    piii p = que.front();que.pop();\n    int cost = p.first;\n    int x    = p.second.first;\n    int y    = p.second.second;\n    for (int i = 0; i < 6; i++) {\n      int nx = x + dx[y&1][i], ny = y + dy[y&1][i];\n      if(0 <= ny && ny < n &&\n         0 <= nx && nx < m &&\n         grid[ny][nx] > cost + 1){\n        ans++;\n        grid[ny][nx] = cost + 1;\n        que.push(mp(cost + 1, mp(nx, ny)));\n      }\n    }\n  }\n  // for (int i = 0; i < n; i++) {\n  //   for (int j = 0; j < m; j++) {\n  //     std::cout << grid[i][j] << \" \";\n  //   }\n  //   std::cout << std::endl;\n  // }\n  // std::cout << std::endl;\n\n  return ans;\n}\n\nint main(int argc, char *argv[]){\n  while(cin >> m >> n, n){\n    int ans = 0, t;\n    cin >> a;\n    int sx[a], sy[a];\n    for (int i = 0; i < a; i++) {\n      cin >> sx[i] >> sy[i];\n      sx[i]--;sy[i]--;\n    }\n    cin >> t;\n    int px[t], py[t];\n    for (int i = 0; i < t; i++) {\n      cin >> px[i] >> py[i];\n      px[i]--;py[i]--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        grid[i][j] = 1e8;\n      }\n    }\n    \n    for (int i = 0; i < a; i++) {\n      bfs(grid, sx[i], sy[i]);\n    }\n\n    for (int i = 0; i < t; i++) {\n      int tmp[110][110];\n      \n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < m; k++) {\n          tmp[j][k] = grid[j][k];\n        }\n      }\n      \n      ans = max(ans, bfs(tmp, px[i], py[i]));\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[6] = {-1, -1, 0, 1, 1, 0};\nconst int dx[2][6] = { {-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1} };\n\nstruct Data{\n\tint y, x;\n\tbool is_deven;\n\tData(){}\n\tData(int _y, int _x, bool _is_deven){\n\t\ty = _y; x = _x; is_deven = _is_deven;\n\t}\n};\n\nint main(){\n\tint N, M, S, T, X[10], Y[10], P, Q;\n\twhile(cin >> N >> M, N || M){\n\t\tcin >> S;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\t\tcin >> T;\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> P >> Q;\n\t\t\tP--; Q--;\n\n\t\t\tqueue<Data> q;\n\t\t\tData q_front;\n\t\t\tint deven_scope = 0;\n\t\t\tbool used[100][100] = {};\n\n\t\t\tfor(int i = 0; i < S; i++){\n\t\t\t\tq.push( Data(Y[i], X[i], false) );\n\t\t\t}\n\t\t\tq.push( Data(Q, P, true) );\n\n\t\t\twhile( !q.empty() ){\n\t\t\t\tq_front = q.front(); q.pop();\n\t\t\t\tif(used[q_front.y][q_front.x]) continue;\n\t\t\t\tif(q_front.is_deven) deven_scope++;\n\n\t\t\t\tused[q_front.y][q_front.x] = true;\n\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\t\tint nx = q_front.x + dx[q_front.y&1][i];\n\t\t\t\t\tif(ny < 0 || N <= ny || nx < 0 || M <= nx) continue;\n\t\t\t\t\tq.push( Data(ny, nx, q_front.is_deven) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, deven_scope);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MSIZE = 101;\n\nint w, h;\nint s;\nint X[SIZE], Y[SIZE];\nint t;\nint PT[SIZE], QT[SIZE];\nint T[MSIZE][MSIZE];\nint Tcopy[MSIZE][MSIZE]; \n\nconst int DSIZE = 6;\nconst int dr[2][DSIZE] = {\n    { 1, 1, 0, 0, -1, -1 },\n    { 1, 1, 0, 0, -1, -1 }\n};\nconst int dc[2][DSIZE] = {\n    { -1, 0, -1, 1, -1, 0 },\n    { 0, 1, -1, 1, 0, 1 }\n};\n\nvoid init() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = INT_MAX;\n        }\n    }\n}\n\nvoid save() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n}\n\nvoid load() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = Tcopy[i][j];\n        }\n    }\n}\n\ntypedef II NODE;\ntypedef queue <NODE> QUEUE;\n\nbool isValidPos( int r, int c ) {\n    return r >= 0 && r < h && c >= 0 && c < w;\n}\n\nint spread( int sr, int sc ) {\n    QUEUE Q;\n\n    Q.push( II( sr, sc ) );\n    T[sr][sc] = 0;\n    \n    int res = 1;\n    while ( ! Q.empty() ) {\n        NODE node = Q.front();\n        Q.pop();\n\n        int r = node.first;\n        int c = node.second;\n        int d = r % 2;\n\n        for ( int i = 0; i < DSIZE; ++ i ) {\n            int nr = r + dr[d][i];\n            int nc = c + dc[d][i];\n            if ( ! isValidPos( nr, nc ) ) continue;\n            if ( T[r][c] + 1 >= T[nr][nc] ) continue;\n            T[nr][nc] = T[r][c] + 1;\n            res ++;\n            NODE next( nr, nc );\n            Q.push( next );\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    init();\n    for ( int i = 0; i < s; ++ i ) {\n        spread( X[i], Y[i] );\n    }\n    save();\n    int res = 0;\n    for ( int i = 0; i < t; ++ i ) {\n        load();\n        res = max( res, spread( PT[i], QT[i] ) );\n    }\n    cout << res << endl;\n    return;\n}\n\nvoid input() {\n    cin >> s;\n    for ( int i = 0; i < s; ++ i ) {\n        cin >> X[i] >> Y[i];\n        X[i] -= 1;\n        Y[i] -= 1;\n    }\n    cin >> t;\n    for ( int i = 0; i < t; ++ i ) {\n        cin >> PT[i] >> QT[i];\n        PT[i] -= 1;\n        QT[i] -= 1;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        if ( w == 0 && h == 0 ) break;\n        input();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n\nstruct HexCoordinate {\n\tint x, y;\n\tstd::vector<HexCoordinate> neighbors() const {\n\t\tif (y % 2 == 0) {\n\t\t\treturn { {x - 1, y}, {x + 1, y}, {x, y - 1}, {x + 1, y - 1}, {x, y + 1}, {x + 1, y + 1} };\n\t\t}\n\t\telse {\n\t\t\treturn { {x - 1, y}, {x + 1, y}, {x - 1, y - 1}, {x, y - 1}, {x - 1, y + 1}, {x, y + 1} };\n\t\t}\n\t}\n};\nint main() {\n\twhile (true) {\n\t\tint m, n; std::cin >> m >> n; if (n == 0 && m == 0) break;\n\t\tint s; std::cin >> s;\n\t\tstd::vector<std::vector<int>> min_distance(n, std::vector<int>(m, INT_MAX));\n\t\tfor (auto i = 0; i < s; ++i) {\n\t\t\tint x, y; std::cin >> x >> y;\n\t\t\tstd::queue<HexCoordinate> queue; queue.push(HexCoordinate{ x, y });\n\t\t\tmin_distance[y - 1][x - 1] = 0;\n\t\t\twhile (!queue.empty()) {\n\t\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\t\tfor (const auto next : top.neighbors()) if (1 <= next.x && next.x <= m && 1 <= next.y && next.y <= n) {\n\t\t\t\t\tif (min_distance[next.y - 1][next.x - 1] > min_distance[top.y - 1][top.x - 1] + 1) {\n\t\t\t\t\t\tmin_distance[next.y - 1][next.x - 1] = min_distance[top.y - 1][top.x - 1] + 1;\n\t\t\t\t\t\tqueue.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint t; std::cin >> t;\n\t\tint max_count = 0;\n\t\tfor (auto i = 0; i < t; ++i) {\n\t\t\tint x, y; std::cin >> x >> y;\n\t\t\tauto min = min_distance;\n\t\t\tint count = 1;\n\t\t\tstd::queue<HexCoordinate> queue; queue.push(HexCoordinate{ x, y });\n\t\t\tmin[y - 1][x - 1] = 0;\n\t\t\twhile (!queue.empty()) {\n\t\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\t\tfor (const auto next : top.neighbors()) if (1 <= next.x && next.x <= m && 1 <= next.y && next.y <= n) {\n\t\t\t\t\tif (min[next.y - 1][next.x - 1] > min[top.y - 1][top.x - 1] + 1) {\n\t\t\t\t\t\tmin[next.y - 1][next.x - 1] = min[top.y - 1][top.x - 1] + 1;\n\t\t\t\t\t\tqueue.push(next);\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax_count = std::max(max_count, count);\n\t\t}\n\t\tstd::cout << max_count << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int m, n, s;\n        cin >> m >> n >> s;\n        if(m == 0)\n            return 0;\n\n        vector<vector<int> > dist(n, vector<int>(m, INT_MAX));\n        for(int i=0; i<s; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<m; ++k){\n                    int dy = abs(y - j);\n                    int dx = abs(x - k);\n                    dist[j][k] = min(dist[j][k], max(dy, dx));\n                }\n            }\n        }\n\n        int t;\n        cin >> t;\n\n        int ret = 0;\n        for(int i=0; i<t; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n\n            int num = 0;\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<m; ++k){\n                    int dy = abs(y - j);\n                    int dx = abs(x - k);\n                    if(max(dy, dx) < dist[j][k])\n                        ++ num;\n                }\n            }\n            ret = max(ret, num);\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct st { int x, y, c; };\nint d[100][100], b[100][100], x[11], y[11];\nint dx[][6]{ { 0,-1,0,1,1,1, },{ -1,-1,-1,0,1,0 } };\nint dy[]{ -1,0,1,1,0,-1 };\nint main() {\n\tint m, n, s;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tscanf(\"%d\", &s);\n\t\trep(i, s)scanf(\"%d%d\", &x[i], &y[i]), x[i]--, y[i]--;\n\t\tint t; scanf(\"%d\", &t);\n\t\tint Max = 0;\n\t\trep(i, t) {\n\t\t\tscanf(\"%d%d\", &x[s], &y[s]); x[s]--; y[s]--;\n\t\t\tqueue<st>que;\n\t\t\tmemset(d, -1, sizeof(d));\n\t\t\trep(j, s + 1) {\n\t\t\t\td[x[j]][y[j]] = 0; b[x[j]][y[j]] = j;\n\t\t\t\tque.push({ x[j],y[j],j });\n\t\t\t}\n\t\t\twhile (!que.empty()) {\n\t\t\t\tst p = que.front(); que.pop();\n\t\t\t\trep(j, 6) {\n\t\t\t\t\tint nx = p.x + dx[!(p.y & 1)][j], ny = p.y + dy[j];\n\t\t\t\t\tif (0 <= nx&&nx < m && 0 <= ny&&ny < n) {\n\t\t\t\t\t\tif (d[nx][ny] == -1) {\n\t\t\t\t\t\t\td[nx][ny] = d[p.x][p.y] + 1;\n\t\t\t\t\t\t\tb[nx][ny] = p.c;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (d[nx][ny] == d[p.x][p.y] + 1&&b[nx][ny]!=p.c) {\n\t\t\t\t\t\t\tb[nx][ny] = -1;\n\t\t\t\t\t\t\tque.push({ nx,ny,p.c });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\trep(i, m)rep(j, n) {\n\t\t\t\tif (b[i][j] == s)cnt++;\n\t\t\t}\n\t\t\tMax = max(Max, cnt);\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 10000000\n#define F first\n#define S second\ntypedef pair<int,int> P;\n//int ody[]={-1,-1,0,0,1,1};   //y軸　奇数のベクトル \n//int odx[]={-1,0,-1,1,-1,0}                //x軸　奇数のベクトル\n//int edy[]={-1,-1,0,0,1,1};              //y軸　偶数のベクトル              \n//int edx[]={0,1,-1,1,0,1};                //x軸　偶数のベクトル\nint dy[6]={-1,-1,0,0,1,1};\nint dx[2][6]={{-1,0,-1,1,-1,0},{0,1,-1,1,0,1}}; //1偶数　0奇数\nint w,h,s,kx,ky,t,sx,sy;         //m=横　n=縦　\nint maps[101][101]; \nint cnt,ans;\nvoid kbfs();\nvoid sbfs();\nint main(){\n  while(cin>>w>>h,w|h){\n    ans=0;\n    //初期化\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tmaps[i][j]=INF;\n      }\n    }\n    cin>>s;            //既設のコンビニの数\n    for(int i=0;i<s;i++){\n      cin>>kx>>ky;     //kx,ky=既設のコンビニの座標\n      kx--;ky--;\n      maps[ky][kx]=0;\n      kbfs();\n    }\n    \n    cin>>t;           //新候補地の数\n    for(int i=0;i<t;i++){\n      cin>>sx>>sy;    //候補地の座標\n      sx--;sy--;\n      cnt=0;\n      maps[sy][sx]=0;\n      sbfs();\n      ans=max(ans,cnt);\n    }\n    cout<<ans<<endl;\n  }\n}\nvoid kbfs(){\n  queue<P>que;\n  que.push(P(ky,kx));\n  while(!que.empty()){\n    P p=que.front();que.pop();\n    int y=p.F;\n    int x=p.S;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[y%2][i];\n      if(ny>=0 && ny<h && nx>=0 && nx<w && maps[y][x]+1<maps[ny][nx]){\n\tmaps[ny][nx]=maps[y][x]+1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return;\n}\n\nvoid sbfs(){\n  queue<P>que;\n  que.push(P(sy,sx));\n  while(!que.empty()){\n    cnt++;\n    P p=que.front();que.pop();\n    int y=p.F;\n    int x=p.S;\n    for(int i=0;i<6;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[y%2][i];\n      if(ny>=0 && ny<h && nx>=0 && nx<w && maps[y][x]+1<maps[ny][nx]){\n\tmaps[ny][nx]=maps[y][x]+1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Point {\n\tint x, y, s;\n\tPoint(int x_, int y_, int s_) : x(x_), y(y_), s(s_) {}\n};\n\nint dx[2][6] = {\n\t\t{1, 1, 1, 0, -1, 0}, \n\t\t{0, 1, 0, -1, -1, -1}\n\t},\n\tdy[6] = {-1, 0, 1, 1, 0, -1},\n\tW, H, S, T;\n\nbool vis[110][110], grid[110][110];\n\nvector< Point > search(int sx, int sy) {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< Point > que;\n\tque.push(Point(sx, sy, 0));\n\tvis[sy][sx] = 1;\n\t\n\tvector< Point > res;\n\tint mns = int(1e9);\n\t\n\twhile (!que.empty()) {\n\t\tPoint p = que.front(); que.pop();\n\t\t\n\t\tif (mns < p.s) break;\n\t\t\n\t\tif (grid[p.y][p.x]) {\n\t\t\tmns = p.s;\n\t\t\tres.push_back(p);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor_(d,0,6) {\n\t\t\tint nx = p.x + dx[p.y % 2][d], ny = p.y + dy[d];\n\t\t\tif (nx <= 0 || W < nx || ny <= 0 || H < ny) continue;\n\t\t\tif (vis[ny][nx]) continue;\n\t\t\tvis[ny][nx] = 1;\n\t\t\tque.push(Point(nx, ny, p.s + 1));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main() {\t\n\twhile (cin >> W >> H, W) {\n\t\tmemset(grid, 0, sizeof(grid));\n\t\t\n\t\tcin >> S;\t\t\n\t\tfor_(i,0,S) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tgrid[y][x] = 1;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tcin >> T;\n\t\tfor_(i,0,T) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tgrid[y][x] = 1;\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor_(yy,1,H+1) for_(xx,1,W+1) {\n\t\t\t\tvector< Point > vp = search(xx, yy);\n\t\t\t\tif (vp.size() > 1) continue;\t\t\t\t\n\t\t\t\tif (vp[0].x == x && vp[0].y == y) ++cnt;\n\t\t\t}\n\t\t\t\n\t\t\tgrid[y][x] = 0;\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    SPII V;\n    V.clear();\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( (PII)node ) == V.end() ) {\n            V.insert( (PII)node );\n        }\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return V.size();\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint m, n, s, t;//?¨????????????¢?¨??????????????????°?¨?????????°\nint dis[100][100];//???????¨?\nconst int vx1[6] = { -1,-1,0,1,0,-1 };//?????????????\\???°??¨???????????¶??°??¨\nconst int vx2[6] = { -1,0,1,1,1,0 };//??????????????¶??°??¨??????????\\???°??¨\nconst int vy[6] = { 0,-1,-1,0,1,1 };\nP store[10], plan[10];\n\nvoid bfs() {\n\tqueue<PP> q;//????????????????????§?¨?????????§?¨?\n\tfor (int i = 0; i < s; i++) {\n\t\tq.push(make_pair(0, make_pair(store[i].first, store[i].second)));\n\t\tdis[store[i].first][store[i].second] = -1;//?????§???????????¨?????????-1??¨??????\n\t}\n\twhile (q.size()) {\n\t\tint ct = q.front().first;\n\t\tP tmp = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fx = tmp.first, fy = tmp.second;\n\t\t\tif (fx % 2)fy += vx2[i];\n\t\t\telse fy += vx1[i];\n\t\t\tfx += vy[i];\n\t\t\tif (fx < 0 || fx >= m || fy < 0 || fy >= n)continue;\n\t\t\tif (!dis[fx][fy]) {\n\t\t\t\tdis[fx][fy] = ct + 1;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fx, fy)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int a) {\n\tint ans = 1;\n\tqueue<PP> q;\n\tq.push(make_pair(0, plan[a]));\n\tbool islook[100][100] = {};\n\tislook[q.front().second.first][q.front().second.second] = true;\n\twhile (q.size()) {\n\t\tP tmp = q.front().second;\n\t\tint ct = q.front().first;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fx = tmp.first, fy = tmp.second;\n\t\t\tif (fx % 2)fy += vx2[i];\n\t\t\telse fy += vx1[i];\n\t\t\tfx += vy[i];\n\t\t\tif (fx < 0 || fx >= m || fy < 0 || fy >= n)continue;\n\t\t\tif (!islook[fx][fy] && dis[fx][fy] - ct > 1) {\n\t\t\t\tans++;\n\t\t\t\tdis[fx][fy] = true;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fx, fy)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> m >> n , m * n) {\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tcin >> store[i].second >> store[i].first;\n\t\t\tstore[i].first--, store[i].second--;\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tcin >> plan[i].second >> plan[i].first;\n\t\t\tplan[i].first--, plan[i].second--;\n\t\t}\n\t\tbfs();//?????????????????????????????¢?????¬???\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tans = max(bfs2(i), ans);//??¨????£???°?????????\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)for (int j = 0; j < m; j++)dis[i][j] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint dxo[6] = { -1,  0, -1, 1, -1, 0};\nint dxe[6] = { 0,  1, -1, 1, 0, 1};\nint dy[6] = {-1, -1,  0, 0,  1, 1}; \n\nstruct node { int x, y, dist, num; };\n\nconst int INF = 1000000009;\nconst int MAX_N = 101;\nconst int MAX_S = 11;\nint n, m, s, t;\nint cx[MAX_S], cy[MAX_S], tx[MAX_S], ty[MAX_S];\nint field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nint bfs(int x, int y) {\n\tint res = 0;\n\tqueue<node> que;\n\tnode nd = {x, y, 0, -1};\n\tque.push(nd);\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\tif(dist[nd.x][nd.y] <= nd.dist) continue;\n\n\t\tres++;\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tnode nnd = {xx, yy, nd.dist+1, -1};\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\trep(y,n) {\n\t\trep(x,m) {\n\t\t\tfield[x][y] = 0;\n\t\t\tdist[x][y] = INF;\n\t\t}\n\t}\n\n\tqueue<node> que;\n\trep(i,s) {\n\t\tnode nd = { cx[i]-1, cy[i]-1, 0, i+1 };\n\t\tfield[cx[i]-1][cy[i]-1] = i+1;\n\t\tdist[cx[i]-1][cy[i]-1] = 0;\n\t\tque.push(nd);\n\t}\n\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tif(dist[xx][yy] > nd.dist + 1) {\n\t\t\t\t\tdist[xx][yy] = nd.dist + 1;\n\t\t\t\t\tfield[xx][yy] = nd.num;\n\t\t\t\t} else if(dist[xx][yy] == nd.dist + 1 && field[xx][yy] != nd.num) {\n\t\t\t\t\tfield[xx][yy] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnode nnd = { xx, yy, nd.dist+1, nd.num };\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n\n\tint maxval = 0;\n\trep(i,t) {\n\t\tint res = bfs(tx[i]-1, ty[i]-1);\n\t\tmaxval = max(res, maxval);\n\t}\n\tprintf(\"%d\\n\", maxval);\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) break;\n\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &s);\n\t\trep(i,s) scanf(\"%d%d\", &cx[i], &cy[i]);\n\n\t\tscanf(\"%d\", &t);\n\t\trep(i,t) scanf(\"%d%d\", &tx[i], &ty[i]);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[100][100];\nint grid[100][100];\nint grid2[100][100];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 100; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(grid, 0, sizeof(grid));\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid2[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--y][--x] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tg[--q][--p] = 1;\n\t\t\tmaxi = max(maxi, solve());\n\t\t\tg[q][p] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint mx[2][6] = {\n  {-1, 0, 1, 0, -1, -1},\n  {0, 1, 1, 1, 0, -1}\n};\nint my[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-1, -1, 0, 1, 1, 0}\n};\n\nint W, H, S, T;\n\nvoid update(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  v[sy][sx] = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1) continue;\n      v[ny][nx] = n + 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n}\n\nint countc(int sy, int sx, vector< vector<int> > &v){\n  queue<PP> open;\n  open.push(PP(0, P(sy, sx)));\n  vector< vector<bool> > visited(H + 1, vector<bool>(W + 1, 0));\n  visited[sy][sx] = 1;\n  int res = 0;\n  while(!open.empty()){\n    PP pp = open.front(); open.pop();\n    int y = pp.second.first, x = pp.second.second, n = pp.first, t = (y % 2 == 0);\n    if(v[y][x] > n) ++res;\n    REP(i, 6){\n      int ny = y + my[t][i], nx = x + mx[t][i];\n      if(ny <= 0 || nx <= 0 || ny > H || nx > W || v[ny][nx] <= n + 1 || visited[ny][nx]) continue;\n      visited[y][x] = 1;\n      open.push(PP(n + 1, P(ny, nx)));\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >>W >>H && W && H){\n    vector< vector<int> > v(H + 1, vector<int>(W + 1, 1e9));\n    cin >>S;\n    REP(s, S){\n      int x, y; cin >>x >>y;\n      update(y, x, v);\n    }\n    cin >>T;\n    int ans = 0;\n    REP(t, T){\n      int x, y; cin >>x >>y;\n      ans = max(ans, countc(y, x, v));\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n#define INV (-1)\n#define MAX 128\n#define MAX_ENEMY 10\n#define MAX_STORE 21\n\nusing namespace std;\n\nconst int even_di[] = {-1,-1,0,0,1,1};\nconst int even_dj[] = {0,1,-1,1,0,1};\nconst int odd_di[] = {-1,-1,0,0,1,1};\nconst int odd_dj[] = {-1,0,-1,1,-1,0};\nconst int infty = 1 << 26;\n\nclass Area{\n public:\n  int store;\n  int dist[MAX_STORE];\n  bool valid;\n  Area():store(INV),valid(false){\n    for(int i = 0; i < MAX_STORE; ++i){\n      dist[i] = infty;\n    }\n  }\n};\n\nclass Map{\n public:\n  int n,m;\n  Area T[MAX][MAX];\n  Map(){}\n  Map(int n, int m):n(n),m(m){\n    for(int i = 1; i < n+1; ++i){\n      for(int j = 1; j < m+1; ++j){\n\tT[i][j].valid = true;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  T[i][j].dist[k] = infty;\n\t}\n      }\n    }\n  }\n  int occupied(int store){\n    int ret = 0;\n    for(int i = 1; i < n + 1; ++i){\n      for(int j = 1; j < m + 1; ++j){\n\tint minimum = infty;\n\tint id = -1;\n\tint cnt = 0;\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  minimum = min( minimum, T[i][j].dist[k] ); \n\t}\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  if( k >= MAX_ENEMY && k != store ) continue;\n\t  if( minimum == T[i][j].dist[k] ){\n\t    ++cnt;\n\t    id = k;\n\t  }\n\t}\n\tif( cnt == 1 && id == store ){\n\t  ++ret;\n\t}\n      }\n    }\n    return ret;\n  }\n};\n\nclass State\n{\npublic:\n  int i,j;\n  int cost;\n  State():i(0),j(0),cost(infty){}\n  State(int i, int j, int cost):i(i),j(j),cost(cost){}\n};\n  \nvoid store_bfs( int i, int j, int store, Map &M )\n{\n  queue< State > qpi;\n  \n  qpi.push( State(i,j,0) );\n  while(!qpi.empty()){\n    State now = qpi.front();\n    qpi.pop();\n    \n    if( M.T[now.i][now.j].dist[store] < infty ) continue;\n    M.T[now.i][now.j].dist[store] = now.cost;\n    \n    for(int i = 0; i < sizeof(even_di)/sizeof(*even_di); ++i){\n      int ti = now.i + ( now.i%2==0 ? even_di[i] : odd_di[i] );\n      int tj = now.j + ( now.i%2==0 ? even_dj[i] : odd_dj[i] );\n      \n      if( !M.T[ti][tj].valid ) continue;\n      if( M.T[ti][tj].dist[store] < infty ) continue;\n      M.T[ti][tj].dist[store] = now.cost+1;\n      \n      qpi.push( State(ti,tj,now.cost+1) );\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int m,n;\n    int ans = 0;\n    cin >> m;\n    if( m == 0 ) break;\n    cin >> n;\n    if( n == 0 ) break;\n    int st;\n    Map M(n,m);\n    \n    cin >> st;\n    for(int i = 0; i < st; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = i;\n      store_bfs( y, x, i, M );\n    }\n    \n    int cands;\n    cin >> cands;\n    for(int i = 0; i < cands; ++i){\n      int y,x;\n      cin >> x >> y;\n      //++x;++y;\n      M.T[y][x].store = MAX_ENEMY + i;\n      store_bfs( y, x, MAX_ENEMY+i, M );\n    }\n    \n\n    /*\n    for(int i = 0; i < n+2; ++i){\n      for(int j = 0; j < m+2; ++j){\n\tcout << \"(\" << j << \" , \" << i << \") = \";\n\tfor(int k = 0; k < MAX_STORE; ++k){\n\t  cout << M.T[i][j].dist[k] << ' ';\n\t}\n\tcout << endl;\n      }\n      cout << \"--------\" << endl;\n    }\n    */\n    \n\n    for(int i = 0; i < cands; ++i){\n      ans = max( ans, M.occupied( MAX_ENEMY + i ) );\n    }\n\n    cout << ans << endl;\n    \n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      \n      mincost[ny][nx] = cost;\n\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n      if(ok)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t}\n\n      \n\n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n\n    \n     \n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint H, W, N, M, p[100], q[100], x, y, dist[109][109][11]; vector<pair<int, int>> X[109][109];\nint dy1[6] = { 0,0,-1,-1,1,1 }, dx1[6] = { -1,1,-1,0,-1,0 };\nint dy2[6] = { 0,0,-1,-1,1,1 }, dx2[6] = { -1,1,0,1,0,1 };\n\nint solve() {\n\tfor (int i = 1; i <= H; i++) { for (int j = 1; j <= W; j++) { for (int k = 0; k <= N; k++) dist[i][j][k] = (1 << 30); } }\n\tfor (int i = 0; i <= N; i++) {\n\t\tqueue<pair<int, int>>Q;\n\t\tQ.push(make_pair(p[i], q[i])); dist[p[i]][q[i]][i] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint to1 = Q.front().first, to2 = Q.front().second; Q.pop();\n\t\t\tfor (int j = 0; j < X[to1][to2].size(); j++) {\n\t\t\t\tint p1 = X[to1][to2][j].first, p2 = X[to1][to2][j].second;\n\t\t\t\tif (dist[p1][p2][i] > dist[to1][to2][i] + 1) {\n\t\t\t\t\tdist[p1][p2][i] = dist[to1][to2][i] + 1;\n\t\t\t\t\tQ.push(make_pair(p1, p2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tbool OK = true;\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (dist[i][j][0] >= dist[i][j][k]) OK = false;\n\t\t\t}\n\t\t\tif (OK == true) ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0) break;\n\t\tfor (int i = 0; i < 109; i++) { for (int j = 0; j < 109; j++) X[i][j].clear(); }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\tint fx = i, fy = j;\n\t\t\t\t\tif (j % 2 == 1) { fx += dx1[k]; fy += dy1[k]; }\n\t\t\t\t\tif (j % 2 == 0) { fx += dx2[k]; fy += dy2[k]; }\n\t\t\t\t\tif (fx <= 0 || fy <= 0 || fx > H || fy > W) continue;\n\t\t\t\t\tX[i][j].push_back(make_pair(fx, fy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor (int i = 1; i <= N; i++) { cin >> p[i] >> q[i]; }\n\t\tint ret = 0;\n\t\tcin >> M;\n\t\tfor (int i = 1; i <= M; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[0] = x; q[0] = y;\n\t\t\tret = max(ret, solve());\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nbool visited[100][100];\nint dx[2][6] = {{-1, -1, 0, 1, 0, -1}, {-1, 0, 1, 1, 1, 0}};\nint dy[2][6] = {{0, -1, -1, 0, 1, 1},{0, -1, -1, 0, 1, 1}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n      if(ok)\n\t{\n\t  if(!visited[ny][nx])\n\t    cnt++;\n\t  visited[ny][nx] = true;\n\t  dfs2(nx,ny,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n    \n      for(int i=0;i<10000000;i++);\n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29),visited[j][k] = false;\n\t  mincost[q][p] = 0;\n\t  visited[q][p] = true;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint dxo[6] = { -1,  0, -1, 1, -1, 0};\nint dxe[6] = { 0,  1, -1, 1, 0, 1};\nint dy[6] = {-1, -1,  0, 0,  1, 1}; \n\nstruct node { int x, y, dist, num; };\n\nconst int INF = 1000000009;\nconst int MAX_N = 101;\nconst int MAX_S = 11;\nint n, m, s, t;\nint cx[MAX_S], cy[MAX_S], tx[MAX_S], ty[MAX_S];\nint field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nint bfs(int x, int y) {\n\tint res = 0;\n\tqueue<node> que;\n\tnode nd = {x, y, 0, -1};\n\tque.push(nd);\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\tif(dist[nd.x][nd.y] <= nd.dist) continue;\n\n\t\tres++;\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tnode nnd = {xx, yy, nd.dist+1, -1};\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\trep(y,n) {\n\t\trep(x,m) {\n\t\t\tfield[x][y] = 0;\n\t\t\tdist[x][y] = INF;\n\t\t}\n\t}\n\n\tqueue<node> que;\n\trep(i,s) {\n\t\tnode nd = { cx[i]-1, cy[i]-1, 0, i+1 };\n\t\tfield[cx[i]-1][cy[i]-1] = i+1;\n\t\tdist[cx[i]-1][cy[i]-1] = 0;\n\t\tque.push(nd);\n\t}\n\n\twhile(!que.empty()) {\n\t\tnode nd = que.front();\n\t\tque.pop();\n\n\t\trep(k,6) {\n\t\t\tint xx = (nd.y % 2 == 0) ?  nd.x + dxo[k] : nd.x + dxe[k];\n\t\t\tint yy = nd.y + dy[k];\n\t\t\tif(xx >= 0 && yy >= 0 && xx < m && yy < n) {\n\t\t\t\tif(dist[xx][yy] > nd.dist + 1) {\n\t\t\t\t\tdist[xx][yy] = nd.dist + 1;\n\t\t\t\t\tfield[xx][yy] = nd.num;\n\t\t\t\t} else if(dist[xx][yy] == nd.dist + 1 && field[xx][yy] != nd.num) {\n\t\t\t\t\tfield[xx][yy] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnode nnd = { xx, yy, nd.dist+1, nd.num };\n\t\t\t\tque.push(nnd);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxval = 0;\n\trep(i,t) {\n\t\tint res = bfs(tx[i]-1, ty[i]-1);\n\t\tmaxval = max(res, maxval);\n\t}\n\tprintf(\"%d\\n\", maxval);\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) break;\n\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &s);\n\t\trep(i,s) scanf(\"%d%d\", &cx[i], &cy[i]);\n\n\t\tscanf(\"%d\", &t);\n\t\trep(i,t) scanf(\"%d%d\", &tx[i], &ty[i]);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[2][6]={{-1,-1,0,0,1,1},{-1,-1,0,0,1,1}};\nint dy[2][6]={{-1,0,-1,1,-1,0},{1,0,-1,1,1,0}};\nint bfs[110][110];\nint m[110][110];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tint c;scanf(\"%d\",&c);\n\t\tqueue<pair<int,int> >Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)bfs[i][j]=-1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&q,&p);\n\t\t\tp--;q--;\n\t\t\tbfs[p][q]=0;\n\t\t\tQ.push(make_pair(p,q));\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tint t=row%2;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(0<=row+dx[t][i]&&row+dx[t][i]<a&&0<=col+dy[t][i]&&col+dy[t][i]<b&&!~bfs[row+dx[t][i]][col+dy[t][i]]){\n\t\t\t\t\tbfs[row+dx[t][i]][col+dy[t][i]]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[t][i],col+dy[t][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tint d;scanf(\"%d\",&d);\n\t\tfor(int i=0;i<d;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&q,&p);p--;q--;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)m[j][k]=-1;\n\t\t\tm[p][q]=0;\n\t\t\tQ.push(make_pair(p,q));\n\t\t\twhile(Q.size()){\n\t\t\t\tint row=Q.front().first;\n\t\t\t\tint col=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tint t=row%2;\n\t\t\t\tfor(int j=0;j<6;j++){\n\t\t\t\t\tif(0<=row+dx[t][j]&&row+dx[t][j]<a&&0<=col+dy[t][j]&&col+dy[t][j]<b&&!~m[row+dx[t][j]][col+dy[t][j]]){\n\t\t\t\t\t\tm[row+dx[t][j]][col+dy[t][j]]=m[row][col]+1;\n\t\t\t\t\t\tQ.push(make_pair(row+dx[t][j],col+dy[t][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)if(bfs[j][k]>m[j][k])val++;\n\t\t\tret=max(val,ret);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 1;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n    }\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h, VI( w, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[100][100];\nint grid[100][100];\nint grid2[100][100];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 200; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--y][--x] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tif (g[--q][--p]) continue;\n\t\t\tg[q][p] = 1;\n\t\t\tmaxi = max(maxi, solve());\n\t\t\tg[q][p] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,cnt;\nint Cost[10][100][100];\nint mincost[100][100];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int p,int x,int y,int cost)\n{\n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(Cost[p][ny][nx] > cost)\n\t{\n\t  Cost[p][ny][nx] = cost;\n\t  dfs(p,nx,ny,cost+1);\n\t}\n    }\n}\n\nvoid dfs2(int x,int y,int cost)\n{\n  \n  for(int i=0;i<6;i++)\n    {\n      int nx = x + dx[y%2][i];\n      int ny = y + dy[y%2][i];\n   \n      if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\tcontinue;\n\n      if(mincost[ny][nx] <= cost)\n\tcontinue;    \n\n      mincost[ny][nx] = cost;\n\n      bool ok = true;\n      for(int j=0;j<s;j++)\n\tif(Cost[j][ny][nx] <= cost)\n\t  {\n\t    ok = false;\n\t    break;\n\t  }\n\n\n\n      if(ok)\n\t{\n\t  cnt++;\n\t  dfs2(nx,ny,cost+1);\n\t}\n\n    }\n\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      if(!n)\n\tbreak;\n      cin >> m;\n\n    \n     \n      scanf(\"%d\",&s);\n\n\n      for(int i=0;i<s;i++)\n\tfor(int j=0;j<n;j++)\n\t  for(int k=0;k<m;k++)\n\t    Cost[i][j][k] = (1<<29);\n      \n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  x--,y--;\n\t  Cost[i][y][x] = 0;\n\t  dfs(i,x,y,1);\n\t}\n\n      int t;\n      scanf(\"%d\",&t);\n\n      int mex = 0;\n      for(int i=0;i<t;i++)\n\t{\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cnt = 1;\n\t  p--,q--;\n\t  \n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = (1<<29);\n\t  mincost[q][p] = 0;\n\t  dfs2(p,q,1);\n\t  \n\t  mex = max(mex,cnt);\n\t}\n      cout << mex << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,0,0,1,1,1} };\nint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,1,-1,0,1,-1} };\n\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        int index;\n        P(){}\n        P(int x,int y,int cost,int index):x(x),y(y),cost(cost),index(index){}\n};\n\nclass Data{\n        public:\n        int cost;\n        int index;\n        Data(){}\n        Data(int cost,int index):cost(cost),index(index){}\n};\n\nint main(){\n        int m,n;\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                int s;\n                scanf(\"%d\",&s);\n\n                int sx[100];\n                int sy[100];\n                for(int i = 0; i < s; i++){\n                        scanf(\"%d%d\",&sx[i],&sy[i]);\n                }\n\n                int t;\n                scanf(\"%d\",&t);\n                int ans = -100000;\n                for(int q = 0; q < t; q++){\n                        int x,y;\n                        Data vis[128][128];\n                        queue< P > Q;\n\n                        for(int i = 0; i < 120; i++){\n                                for(int j = 0; j < 120; j++){\n                                        vis[i][j] = Data(0,0);\n                                }\n                        }\n                        for(int i = 0; i < s; i++){\n                                Q.push(P(sx[i]-1,sy[i]-1,1,i+1));\n                                vis[sx[i]-1][sy[i]-1]=Data(1,i+1);\n                        }\n                        scanf(\"%d%d\",&x,&y);\n                        Q.push(P(x-1,y-1,1,s+1));\n                        vis[x-1][y-1]=Data(1,s+1);\n                        while( Q.size() ){\n                                P p = Q.front();Q.pop();\n                                if(vis[p.x][p.y].cost == -1)continue;\n                //              printf(\"--%d--\\n\",p.index);\n                                for(int i = 0; i < 6; i++){\n                                        if(p.x+dx[p.y%2][i] < 0 || p.x+dx[p.y%2][i] > m-1 || p.y+dy[p.y%2][i] < 0 || p.y+dy[p.y%2][i] > n-1)continue;\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost == p.cost+1){\n                                                vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost = -1;\n                                                //continue;\n                                        }\n                                        if(vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]].cost != 0)continue;\n                //                      printf(\"%d %d\\n\",p.x+dx[p.y%2][i],p.y+dy[p.y%2][i]);\n                                        vis[p.x+dx[p.y%2][i]][p.y+dy[p.y%2][i]] = Data(p.cost+1,p.index);\n                                        Q.push(P(p.x+dx[p.y%2][i],p.y+dy[p.y%2][i],p.cost+1,p.index));\n                                }\n                        }\n                        int res = 0;\n                        //puts(\"-------\");\n                        for(int i = 0; i < m; i++){\n                                for(int j = 0; j < n; j++){\n                                        if(vis[i][j].cost == -1){\n                        //                      printf(\"%d %d\\n\",i,j);\n                                                vis[i][j].index = 0;\n                                        }\n                                }\n                        }\n                        //puts(\"-------\");\n                        for(int i = 0; i < m; i++){\n                                for(int j = 0; j < n; j++){\n                //                      printf(\"%3d\",vis[i][j].index);\n                                        if(vis[i][j].index == s+1 && vis[i][j].cost != -1)res++;\n                                }\n                //              puts(\"\");\n                        }\n                        ans = max(ans,res);\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[7] = {0, 0, -1, -1, 0, 1, 1};\nconst int dy[2][7] = {\n\t{0, -1, -1, 0, 1, 0, -1},\n\t{0, -1, 0, 1, 1, 1, 0}\n};\n\nint n, m;\nint g[200][200];\nint grid[200][200];\nint grid2[200][200];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < n && j < m;\n}\n\nint solve()\n{\n\tint maxi = 0;\n\tmemcpy(grid, g, sizeof(g));\n\tfor (int a = 0; a < 200; a++){\n\t\tmemset(grid2, 0, sizeof(grid2));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tfor (int dir = 0; dir < 7; dir++){\n\t\t\t\t\tint nx = i + dx[dir];\n\t\t\t\t\tint ny = j + dy[i % 2][dir];\n\t\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\t\tgrid2[nx][ny] |= grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tif (grid2[i][j] == (grid2[i][j] & (-grid2[i][j]))){\n\t\t\t\t\tgrid[i][j] = grid2[i][j];\n\t\t\t\t\tif (grid[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d \", grid[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tmaxi = max(maxi, cnt);\n\t}\n\treturn maxi;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tmemset(g, 0, sizeof(g));\n\t\tint maxi = 0;\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tfor (int i = 0; i < s; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tg[--x][--y] = 1 << i + 1;\n\t\t}\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tint p, q;\n\t\t\tscanf(\"%d %d\", &p, &q);\n\t\t\tif (g[--p][--q]) continue;\n\t\t\tg[p][q] = 1;\n\t\t\tint tmp = solve();\n\t\t\tmaxi = max(maxi, tmp);\n\t\t\tg[p][q] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<deque>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> Pi;\nint n,m,cnt;\nint mincost[110][110];\nbool visited[110][110];\nint dx[2][6] = {{-1,+0,1,0,-1,-1},{+0,+1,1,1,0,-1}};\nint dy[2][6] = {{-1,-1,0,1,+1,+0},{-1,-1,0,1,1,+0}};\n\nvoid dfs(int x,int y)\n{\n\n  deque<Pi> deq;\n  deq.push_back(Pi(P(x,y),0));\n  mincost[y][x] = 0;\n  visited[y][x] = true;\n  cnt = 1;\n  while(!deq.empty())\n    {\n      Pi pi = deq.front(); deq.pop_front();\n\n      for(int i=0;i<6;i++)\n\t{\n\t  int nx = pi.first.first + dx[pi.first.second%2][i];\n\t  int ny = pi.first.second + dy[pi.first.second%2][i];\n\n\t  if(!(0 <= nx && nx < m && 0 <= ny && ny < n))\n\t    continue;\n\n\t  if(mincost[ny][nx] > pi.second + 1)\n\t    {\n\t      if(!visited[ny][nx])\n\t\tcnt++;\n\t      visited[ny][nx] = true;\n\t      mincost[ny][nx] = pi.second + 1;\n\t      deq.push_back(Pi(P(nx,ny),pi.second+1));\n\t    }\n\t}\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> n;\n      cerr << n << \" \";\n      if(!n) break;\n      cerr << m << endl;\n      cin >> m;\n      for(int i=0;i<n;i++) \n\tfor(int j=0;j<m;j++)\n\t  mincost[i][j] = (1<<29);  \n     \n      int s,t,mex = 1;\n      scanf(\"%d\",&s);\n      cerr << s << endl;\n      for(int i=0;i<s;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  cerr << x << \" \" << y << endl;\n\t  x--,y--;\n\t  mincost[y][x] = 0;\n\t  dfs(x,y);\n\t}\n     \n      scanf(\"%d\",&t);\n      for(int i=0;i<t;i++)\n\t{   \n\t  int pre_mincost[n][m];\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      pre_mincost[j][k] = mincost[j][k],visited[j][k] = false;\n\t  int p,q;\n\t  scanf(\"%d %d\",&p,&q);\n\t  cerr << p << \" \" << q << endl;\n\t  p--,q--;\n\t  dfs(p,q);\n\t  \n\t  mex = max(mex,cnt);\n\t  for(int j=0;j<n;j++)\n\t    for(int k=0;k<m;k++)\n\t      mincost[j][k] = pre_mincost[j][k];\n\t}\n      cout << mex << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\n\nint m, n, s;\nint min_cost[100][100];\nint dy[] = { -1, -1, 0, 1, 1, 0};\nint dx[][6] = {{ -1, 0, 1, 0, -1, -1}, { 0, 1, 1, 1, 0, -1}};\n\nbool isover(int y, int x){\n  return y < 0 || y >= n || x < 0 || x >= m;\n}\n\nvoid bfs(int y, int x){\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n  min_cost[y][x] = 0;\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] < p.fr + 1) continue;\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n      min_cost[ny][nx] = p.fr + 1;\n    }\n  }\n}\n\nint prebfs(int y, int x){\n  int ret = 0;\n  bool used[100][100] = {{}};\n  queue< Pii > que;\n  que.push(Pii( 0, Pi( y, x)));\n\n  if(!min_cost[y][x]) return 0;\n\n  while(!que.empty()){\n    Pii p = que.front();\n    que.pop();\n    if(used[p.sc.fr][p.sc.sc]++) continue;\n    ret++;\n    for(int i = 0 ; i < 6 ; i++ ){\n      int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[p.sc.fr % 2][i];\n      if(isover( ny, nx) || min_cost[ny][nx] <= p.fr + 1) continue;\n\n      que.push(Pii( p.fr + 1, Pi( ny, nx)));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> m, m){\n    queue< Pii > que;\n    fill_n( *min_cost, 10000, 1 << 30);\n\n    cin >> n >> s;\n\n    for(int i = 0 ; i < s ; i++ ){\n      int x, y;\n      cin >> x >> y;\n      bfs( y - 1, x - 1);\n    }\n\n    int t, ret = 0;\n    cin >> t;\n    while(t--){\n      int p, q;\n      cin >> p >> q;\n      ret = max( ret,prebfs( q - 1, p - 1));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint m, n, s, t;//?¨????????????¢?¨??????????????????°?¨?????????°\nint dis[100][100];//???????¨?\nconst int vx1[6] = { -1,-1,0,1,0,-1 };//?????????????\\???°??¨???????????¶??°??¨\nconst int vx2[6] = { -1,0,1,1,1,0 };//??????????????¶??°??¨??????????\\???°??¨\nconst int vy[6] = { 0,-1,-1,0,1,1 };\nP store[10], plan[10];\n\nvoid bfs() {\n\tqueue<PP> q;//????????????????????§?¨?????????§?¨?\n\tfor (int i = 0; i < s; i++) {\n\t\tq.push(make_pair(0, make_pair(store[i].first, store[i].second)));\n\t\tdis[store[i].first][store[i].second] = -1;//?????§???????????¨?????????-1??¨??????\n\t}\n\twhile (q.size()) {\n\t\tint ct = q.front().first;\n\t\tP tmp = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= m || fx < 0 || fx >= n)continue;\n\t\t\tif (!dis[fy][fx]) {\n\t\t\t\tdis[fy][fx] = ct + 1;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int a) {\n\tint ans = 1;\n\tqueue<PP> q;\n\tq.push(make_pair(0, plan[a]));\n\tbool islook[100][100] = {};\n\tislook[q.front().second.first][q.front().second.second] = true;\n\twhile (q.size()) {\n\t\tP tmp = q.front().second;\n\t\tint ct = q.front().first;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint fy = tmp.first, fx = tmp.second;\n\t\t\tif (fy % 2)fx += vx2[i];\n\t\t\telse fx += vx1[i];\n\t\t\tfy += vy[i];\n\t\t\tif (fy < 0 || fy >= m || fx < 0 || fx >= n)continue;\n\t\t\tif (!islook[fy][fx] && dis[fy][fx] - ct > 1) {\n\t\t\t\tans++;\n\t\t\t\tdis[fy][fx] = true;\n\t\t\t\tq.push(make_pair(ct + 1, make_pair(fy, fx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> m >> n , m * n) {\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tcin >> store[i].second >> store[i].first;\n\t\t\tstore[i].first--, store[i].second--;\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tcin >> plan[i].second >> plan[i].first;\n\t\t\tplan[i].first--, plan[i].second--;\n\t\t}\n\t\tbfs();//?????????????????????????????¢?????¬???\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tans = max(bfs2(i), ans);//??¨????£???°?????????\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)for (int j = 0; j < m; j++)dis[i][j] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nint dx[2][6] = { {-1, 0, 1,-1,-1,0 } , {-1,0,0,1,1,1} };\nint dy[2][6] = { { 0, 1, 0, 1,-1,-1} , {0,1,-1,0,1,-1} };\n\nclass P{\n        public:\n        int x;\n        int y;\n        int cost;\n        P(){}\n        P(int x,int y,int cost):x(x),y(y),cost(cost){}\n};\n\nint m,n,s;\nint field[128][128];\nint cp[128][128];\nint res;\n\nvoid bfs(int x,int y,int index){\n        bool vis[128][128]={{0}};\n        queue< P > Q;\n        Q.push(P(x,y,1));\n        field[x][y] = 1;\n        res = 0;\n        while( Q.size() ){\n                P p = Q.front();Q.pop();\n                for(int i = 0; i < 6; i++){\n                        int nx = p.x+dx[p.y%2][i];\n                        int ny = p.y+dy[p.y%2][i];\n                        if(vis[p.x][p.y]++)continue;\n                        if(nx < 0 || nx > m-1 || ny < 0 || ny > n-1)continue;\n                        if(field[nx][ny] > p.cost+1){\n                                field[nx][ny] = p.cost+1;\n                                if(index == s+1){\n                                        res++;\n                                }\n                                Q.push(P(nx,ny,p.cost+1));\n                        }\n                        else if(field[nx][ny] == p.cost+1){\n                                field[nx][ny] = -1;\n                        }\n                }\n        }\n        return ;\n}\nvoid init(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        cp[i][j] = field[i][j];\n                }\n        }\n}\n\nvoid copy(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        field[i][j] = cp[i][j];\n                }\n        }\n}\n\nvoid output(){\n        for(int i = 0; i < m; i++){\n                for(int j = 0; j < n; j++){\n                        printf(\"%3d\",field[i][j]);\n                }\n                puts(\"\");\n        }\n        return ;\n}\nint main(){\n        while(scanf(\"%d\",&m),m){\n\n                scanf(\"%d\",&n);\n                scanf(\"%d\",&s);\n\n                for(int i = 0; i < 120; i++){\n                        for(int j = 0; j < 120; j++){\n                                field[i][j] = 99;\n                        }\n                }\n\n                for(int i = 0; i < s; i++){\n                        int x,y;\n                        scanf(\"%d%d\",&x,&y);\n                        x--;y--;\n                        //output();\n                        bfs(x,y,i+1);\n                }\n                int t;\n                scanf(\"%d\",&t);\n                init();\n                int ans = -10000;\n                for(int i = 0; i < t; i++){\n                        int x,y;\n                        scanf(\"%d%d\",&x,&y);\n                        x--;y--;\n                        bfs(x,y,s+1);\n                        //output();\n                        ans = max(res,ans);\n                        copy();\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef long long int ll;\n\nint n, m;\nint dom[6] = {1, 1, 1, 0, -1, 0};\nint don[6] = {-1, 0, 1, -1, 0, 1};\nint dem[6] = {-1, -1, -1, 0, 1, 0};\nint den[6] = {-1, 0, 1, -1, 0, 1};\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\nint solve(int x,int y, vector<vector<int> > &g, vector<vector<bool> > &pos);\n\nint main()\n{\n    while (cin >> n >> m, (n|m)) {\n        int s, t;\n        vector<vector<int> > g(n, vector<int>(m, 0));\n        vector<vector<bool> > pos(n, vector<bool>(m, false));\n        cin >> s;\n        for (int i = 0; i < s; i++) {\n            int x, y;\n            cin >> x >> y;\n            pos[y-1][x-1] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                //cout << \"===\" << i << j << \"===\" << endl;\n                g[i][j] = bfs(i, j, g, pos);\n                //cout << g[i][j];\n            }\n            //cout << endl;\n        }\n        cin >> t;\n        int ans = -INF;\n        for (int i = 0; i < t; i++) {\n            int x, y;\n            cin >> x >> y;\n            ans = max(solve(y-1, x-1, g, pos), ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint solve(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0, dist = 0;\n    vector<vector<bool> > ch(n, vector<bool>(m, false));\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front(); a.pop();\n            x = tmp.first; y = tmp.second;\n            if (ch[x][y]) {\n                continue;\n            } else {\n                ch[x][y] = true;\n            }\n            if (dist < g[x][y]) {\n                ret++;\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n\t                    int nx = x + don[i];\n    \t                int ny = y + dom[i];\n        \t            if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }\n                \t} else {\n\t                    int nx = x + den[i];\n    \t                int ny = y + dem[i];\n        \t            if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n            \t            b.push(make_pair(nx, ny));\n                \t    }                \t\t\n                \t}\n                }\n            }\n        }\n        a = b;\n        b = c;\n        dist++;\n    }\n    return ret;\n}\n\nint bfs(int x, int y, vector<vector<int> > &g, vector<vector<bool> > &pos)\n{\n    int ret = 0;\n    queue<i_i> a, b, c;\n    a.push(make_pair(x, y));\n    while (!a.empty()) {\n        while (!a.empty()) {\n            i_i tmp = a.front();\n            a.pop();\n            x = tmp.first;\n            y = tmp.second;\n            if (pos[x][y]) {\n                return ret;\n            } else {\n                for (int i = 0; i < 6; i++) {\n                \tif (x % 2) {\n    \t                int nx = x + don[i];\n        \t            int ny = y + dom[i];\n            \t        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t} else {\n    \t                int nx = x + den[i];\n        \t            int ny = y + dem[i];\n            \t        if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                \t        b.push(make_pair(nx, ny));\n                    \t}\n                \t}\n                }\n            }\n        }\n        ret++;\n        a = b;\n        b = c;\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 1;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n            answer++;\n        }\n    }\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef PII Node;\ntypedef queue <Node> Queue;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef set<PII> SPII;\n\nSPII V;\n\nint w, h;\nconst int inf = 1<<24;\nconst int odx[6] = { 0, 1, 1, 1, 0, -1 };\nconst int ody[6] = { -1, -1, 0, 1, 1, 0 };\nconst int edx[6] = { -1, 0, 1, 0, -1, -1 };\nconst int edy[6] = { -1, -1, 0, 1, 1, 0 };\n\nint bfs( VVI& M, int X, int Y ) {\n    int answer = 0;\n    Queue Q;\n    Node start( X, Y );\n    Q.push( start );\n    M[Y][X] = 0;\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int x = node.first;\n        int y = node.second;\n        if ( V.find( PII( x, y ) ) == V.end() ) answer++;\n\n        for ( int i = 0; i < 6; i++ ) {\n            int nx = x + ( y%2==0 ? edx[i] : odx[i] );\n            int ny = y + ( y%2==0 ? edy[i] : ody[i] );\n            if ( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n            if ( M[y][x] + 1 >= M[ny][nx] ) continue;\n            M[ny][nx] = M[y][x] + 1;\n            Node nnode( nx, ny );\n            Q.push( nnode );\n        }\n    }\n    return answer;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        V.clear();\n        VVI M( h+1, VI( w+1, inf ) );\n\n        int s;\n        cin >> s;\n        for ( int i = 0; i < s; i++ ) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            V.insert(PII(x,y));\n            bfs( M, x, y );\n        }\n\n        int answer = 0;\n        VVI backup = M;\n        int t;\n        cin >> t;\n        for ( int i = 0; i < t; i++ ) {\n            M = backup;\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            answer = max( answer, bfs( M, x, y ) );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\nint main(void){\n  Place field, others[20], p;\n  int size[20];\n  int s, t, i;\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n    }\n    others[s].x = 0;\n\n    scanf(\"%d\", &t);\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      size[i] = countSize(p, others, field);\n    }\n    size[t] = -1;\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0;\n  for(p.x = 1; p.x <= field.x; p.x++){\n    for(p.y = 1; p.y <= field.y; p.y++){\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return abs((y - 1) / 2 + m);\n    }\n    else{\n      return abs((y - 1) / 2 - m + 1);\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[0], p);\n  for(i = 1; others[i].x != 0; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nint check(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return 0;\n\tif(sss[x][y]==set || map[x][y]<=k)return 0;\n\tsss[x][y]=set;\n\treturn 1+check(x-1+y%2,y-1,k+1)+check(x+y%2,y-1,k+1)+check(x-1,y,k+1)+check(x+1,y,k+1)+check(x-1+y%2,y+1,k+1)+check(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset++;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i%2)fprintf(stderr,\" \");\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tfprintf(stderr,\"%d \",map[j][i]);\n\t\t\t}\n\t\t\tfprintf(stderr,\"\\n\");\n\t\t}\n\t\tfprintf(stderr,\"\\n\");\n\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set++;\n\t\t\tblk=check(x,y,0);\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[101][201]={0};\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];;\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2<=x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  <=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /*for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[max=0]);\n      c[y[t]][x[t]=x[t]*2-y[t]%2]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2<x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  <y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nvoid check2(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]>=set || map[x][y]<=k)return;\n\tsss[x][y]=set+k;\n\tq[j][0]=x;q[j][1]=y;\n\tj++;\n}\n\nvoid check(int x,int y,int k){\n\tcheck2(x-1+y%2,y-1,k+1);\n\tcheck2(x+y%2,y-1,k+1);\n\tcheck2(x-1,y,k+1);\n\tcheck2(x+1,y,k+1);\n\tcheck2(x-1+y%2,y+1,k+1);\n\tcheck2(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset+=300;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set+=300;\n\t\t\tblk=0;j=1;\n\t\t\tq[0][0]=x;q[0][1]=y;\n\t\t\tsss[x][y]=set;\n\t\t\twhile(blk<j){\n\t\t\t\tcheck(q[blk][0],q[blk][1],sss[q[blk][0]][q[blk][1]]-set);\n\t\t\t\tblk++;\n\t\t\t}\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "int m,n,X[10],Y[10];\nint D[101][101];//ツ甘ケツ静敖コツδ督ビツニツづづ個催短ツ仰猟猟」\n#define INF 1e9\nint dist(x0,y0,x1,y1){\n\tint dx,dy,vl,vr;\n\tdy=abs(y0-y1);\n\tif(y0%2==0){\n\t\tvl=dy/2;\n\t\tvr=(dy+1)/2;\n\t}else{\n\t\tvl=(dy+1)/2;\n\t\tvr=dy/2;\n\t}\n\tif(x1<x0-vl)\n\t\tdx=x0-vl-x1;\n\telse if(x1>x0+vr)\n\t\tdx=x1-x0-vr;\n\telse\n\t\tdx=0;\n\treturn dx+dy;\n}\nint main(){\n\tint s,i,x,y,d;\n\tint t,p,q,c,best;\n\tfor(;scanf(\"%d%d%d\",&m,&n,&s),m;){\n\t\tfor(i=0;i<s;i++)\n\t\t\tscanf(\"%d%d\",X+i,Y+i);\n\t\tfor(y=1;y<=n;y++){\n\t\t\tfor(x=1;x<=m;x++){\n\t\t\t\tD[x][y]=INF;\n\t\t\t\tfor(i=0;i<s;i++){\n\t\t\t\t\td=dist(x,y,X[i],Y[i]);\n\t\t\t\t\tif(d<D[x][y])\n\t\t\t\t\t\tD[x][y]=d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&t);\n\t\tbest=0;\n\t\tfor(;t--;){\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tc=0;\n\t\t\tfor(y=1;y<=n;y++){\n\t\t\t\tfor(x=1;x<=m;x++){\n\t\t\t\t\td=dist(x,y,p,q);\n\t\t\t\t\tif(d<D[x][y])\n\t\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c>best)\n\t\t\t\tbest=c;\n\t\t}\n\t\tprintf(\"%d\\n\",best);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0193: Convenience Store\n// 2017.8.25 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c, f; } T;\nT shop[25]; int n, S, N;\nint R, C;\n\nint hexDistance(int r1, int c1, int r2, int c2)\n{\n#define abs(a) ((a)>=0?(a):(-(a)))\n\tint dr, dc, c;\n\tdr = abs(r2 - r1), dc = abs(c2 - c1);\n\tif (r2 == r1) return dc;\n\tif (c2 == c1) return dr;\n\tif (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;\n\tif (c2 >= c1) {\n\t\tc = c1 + (dr+1-(r1&1))/2;\n\t\tif (c2 >= c) dr += abs(c-c2);\n\t} else {\n\t\tc = c1 - (dr+(r1&1))/2;\n\t\tif (c2 <= c) dr += abs(c-c2);\n\t}\n\treturn dr;\n}\n\nint main()\n{\n\tint i, k, r, c;\n\tint d[25];\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tscanf(\"%d\", &S); for (n = 0, i = 0; i < S; i++)\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\tscanf(\"%d\", &N); for (i = 0; i < N; i++)\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++) {\n\t\t\tfor (i = 0; i < n; i++) d[i] = hexDistance(shop[i].r, shop[i].c, r, c);\n\t\t\tfor (k = -1, i = 0; i < S; i++) if (k < 0 || d[i] < k) k = d[i];\n\t\t\tfor (i = S; i < n; i++) if (d[i] < k) shop[i].f++;\n\t\t}\t\n\t\tfor (k = -1, i = S; i < n; i++) if (shop[i].f > k) k = shop[i].f;\n\t\tprintf(\"%d\\n\", k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int tx;\n    int ty;\n    int dist;\n} STORE;\n\nSTORE queue[40000];\nint head, tail;\n\nvoid enq(STORE t)\n{\n    queue[(tail++) % 40000] = t;\n}\n\nvoid deq(STORE *t)\n{\n    *t = queue[(head++) % 40000];\n}\n\nint main(void)\n{\n    STORE first, temp;\n    int map[101][101], rec[101][101];\n    int x, y;\n    int sx, sy, mx, my;\n    int n, s;\n    int i, j;\n    int dx[2][6] = {{-1, -1, -1, 0, 1, 0}, {0, -1, 0, 1, 1, 1}};\n    int dy[2][6] = {{-1, 0, 1, -1, 0, 1}, {-1, 0, 1, -1, 0, 1}};\n    int ans;\n    \n    while (1){\n        scanf(\"%d\", &x);\n        \n        if (x == 0){\n            break;\n        }\n        \n        scanf(\"%d\", &y);\n        scanf(\"%d\", &s);\n        memset(map, -1, sizeof(map));\n        \n        for (i = 0; i < s; i++){\n            scanf(\"%d%d\", &sx, &sy);\n            map[sy - 1][sx - 1] = 0;\n            first.tx = sx - 1;\n            first.ty = sy - 1;\n            first.dist = 0;\n            head = tail = 0;\n            enq(first);\n            while (head != tail){\n                deq(&temp);\n                for (j = 0; j < 6; j++){\n                    mx = temp.tx + dx[temp.ty % 2][j];\n                    my = temp.ty + dy[temp.ty % 2][j];\n                    if (0 <= mx && mx < x && 0 <= my && my < y && (map[my][mx] == -1 || map[my][mx] > temp.dist + 1)){\n                        map[my][mx] = temp.dist + 1;\n                        first.tx = temp.tx + dx[temp.ty % 2][j];\n                        first.ty = temp.ty + dy[temp.ty % 2][j];\n                        first.dist = temp.dist + 1;\n                        enq(first);\n                    }\n                }\n            }\n        }\n        scanf(\"%d\", &n);\n        \n        ans = 0;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &sx, &sy);\n            first.tx = sx - 1;\n            first.ty = sy - 1;\n            first.dist = 0;\n            head = tail = 0;\n            memcpy(rec, map, sizeof(map));\n            enq(first);\n            s = 0;\n            if (rec[sy - 1][sx - 1] > 0){\n                s++;\n                rec[sy - 1][sx - 1] = 0;\n            }\n            \n            while (head != tail){\n                deq(&temp);\n                for (j = 0; j < 6; j++){\n                    mx = temp.tx + dx[temp.ty % 2][j];\n                    my = temp.ty + dy[temp.ty % 2][j];\n                    if (0 <= mx && mx < x && 0 <= my && my < y && (rec[my][mx] > temp.dist + 1)){\n                        s++;\n                        rec[my][mx] = temp.dist + 1;\n                        first.tx = temp.tx + dx[temp.ty % 2][j];\n                        first.ty = temp.ty + dy[temp.ty % 2][j];\n                        first.dist = temp.dist + 1;\n                        enq(first);\n                    }\n                }\n            }\n            \n            ans = ans > s ? ans : s;\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nint check(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return 0;\n\tif(sss[x][y]==set || map[x][y]<=k)return 0;\n\tsss[x][y]=set;\n\treturn 1+check(x-1+y%2,y-1,k+1)+check(x+y%2,y-1,k+1)+check(x-1,y,k+1)+check(x+1,y,k+1)+check(x-1+y%2,y+1,k+1)+check(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset++;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i%2)fprintf(stderr,\" \");\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tfprintf(stderr,\"%d \",map[j][i]);\n\t\t\t}\n\t\t\tfprintf(stderr,\"\\n\");\n\t\t}\n\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set++;\n\t\t\tblk=check(x,y,0);\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0193: Convenience Store\n// 2017.8.25 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define abs(a) ((a)>=0?(a):(-(a)))\n//#define min(a,b) ((a)<=(b)?(a):(b))\n\ntypedef struct { int r, c, f; } T;\nT shop[25]; int n, S, N;\nint R, C;\n\nint hexDistance(int r1, int c1, int r2, int c2)\n{\n\tint dr, dc, c;\n\tdr = abs(r2 - r1), dc = abs(c2 - c1);\n\tif (r2 == r1) return dc;\n\tif (c2 == c1) return dr;\n\tif (r2 < r1) c = r2, r2 = r1, r1 = c, c = c2, c2 = c1, c1 = c;\n\tif (c2 >= c1) {\n\t\tc = c1 + (dr+1-(r1&1))/2;\n\t\tif (c2 >= c) dr += abs(c-c2);\n\t} else {\n\t\tc = c1 - (dr+(r1&1))/2;\n\t\tif (c2 <= c) dr += abs(c-c2);\n\t}\n\treturn dr;\n}\n\nint belong(int r, int c)\n{\n\tint i, d, k, min;\n\tfor (min = -1, d = -2, k = 0, i = 1; i <= n; i++) {\n\t\td = hexDistance(shop[i].r, shop[i].c, r, c);\n\t\tif (min < 0 || d < min) min = d, k = i;\n\t\telse if (d == min) k = 0;\n\t}\n\treturn k;\n}\n\nint main()\n{\n\tint i, r, c;\n\tint ans;\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tscanf(\"%d\", &S);\n\t\tfor (n = 1, i = 0; i < S; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tscanf(\"%d\", &N);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &shop[n].c, &shop[n].r), shop[n++].f = 0;\n\t\t}\n\t\tn--;\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++)\n\t\t\tif ((i = belong(r, c)) > 0) shop[i].f++;\n\t\tfor (ans = -1, i = S+1; i <= n; i++) if (shop[i].f > ans) ans = shop[i].f;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\nint main(void){\n  Place field, others[20], p;\n  int size[20];\n  int s, t, i;\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n      others[i].x -= 1;\n      others[i].y -= 1;\n\n      //p.x = 1; p.y = 2;\n      //printf(\"%d\\n\", howLong(others[i], p));\n    }\n    others[s].x = -1;\n\n    scanf(\"%d\", &t);\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      p.x -= 1;\n      p.y -= 1;\n      size[i] = countSize(p, others, field);\n    }\n    size[t] = -1;\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0;\n  for(p.x = 0; p.x < field.x; p.x++){\n    for(p.y = 0; p.y < field.y; p.y++){\n      //printf(\"%d,%d\\n\", howLong(shop, p), minOthersLong(others, p));\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n        //printf(\"%d, %d\\n\", p.x, p.y);\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return (y - 1) / 2 + m;\n    }\n    else{\n      return (y - 1) / 2 - m + 1;\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[0], p);\n  for(i = 1; others[i].x != -1; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,y[30010],x[30010],c[30010],r,t,ny,nx,a,b,n;\n  int Y[]={-1,-1,0,0,1,1};\n  int X[]={-1,1,-2,2,-1,1};\n  while(scanf(\"%d %d\",&w,&h),w){\n    int max=0,d[200][300]={};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)d[i][j*2+1-i%2]=1e9;\n    }\n    scanf(\"%d\",&n);\n    for(i=r=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      a=a*2+1-b%2;\n      d[y[r]=b][x[r]=a]=1;\n      r++;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[y[t]][x[t]]+1>=d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    while(n--){\n      int f[200][300]={};\n      scanf(\"%d %d\",&a,&b);\n      f[y[0]=b][x[0]=a*2+1-b%2]=1;\n      c[t=0]=1;\n      \n      if(d[b][a]==1)continue;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  ny=y[t]+Y[i];\n\t  nx=x[t]+X[i];\n\t  if(d[ny][nx]<=c[t]+1||f[ny][nx])continue;\n\t  f[y[r]=ny][x[r]=nx]=1;\n\t  c[r++]=c[t]+1;\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nvoid check2(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]==set || map[x][y]<=k)return;\n\tsss[x][y]=set+k;\n\tq[j][0]=x;q[j][1]=y;\n\tj++;\n}\n\nvoid check(int x,int y,int k){\n\tcheck2(x-1+y%2,y-1,k+1);\n\tcheck2(x+y%2,y-1,k+1);\n\tcheck2(x-1,y,k+1);\n\tcheck2(x+1,y,k+1);\n\tcheck2(x-1+y%2,y+1,k+1);\n\tcheck2(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset++;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set+=500;\n\t\t\tblk=0;j=1;\n\t\t\tq[0][0]=x;q[0][1]=y;\n\t\t\tsss[x][y]=set;\n\t\t\twhile(blk<j){\n\t\t\t\tcheck(q[blk][0],q[blk][1],sss[q[blk][0]][q[blk][1]]-set);\n\t\t\t\tblk++;\n\t\t\t}\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int tx;\n    int ty;\n    int dist;\n} STORE;\n\nSTORE queue[40000];\nint head, tail;\n\nvoid enq(STORE t)\n{\n    queue[(tail++) % 40000] = t;\n}\n\nvoid deq(STORE *t)\n{\n    *t = queue[(head++) % 40000];\n}\n\nint main(void)\n{\n    STORE first, temp;\n    int map[101][101], rec[101][101];\n    int x, y;\n    int sx, sy, mx, my;\n    int n, s;\n    int i, j;\n    int dx[6] = {0, -1, 0, 1, 1, 1};\n    int dy[6] = {-1, 0, 1, -1, 0, 1};\n    int ans;\n    \n    while (1){\n        scanf(\"%d\", &x);\n        \n        if (x == 0){\n            break;\n        }\n        \n        scanf(\"%d\", &y);\n        \n        scanf(\"%d\", &s);\n        \n        head = tail = 0;\n        memset(map, -1, sizeof(map));\n        \n        for (i = 0; i < s; i++){\n            scanf(\"%d%d\", &sx, &sy);\n            map[sy - 1][sx - 1] = 0;\n            first.tx = sx - 1;\n            first.ty = sy - 1;\n            first.dist = 0;\n            enq(first);\n        }\n        \n        while (head != tail){\n            deq(&temp);\n            for (i = 0; i < 6; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                if (0 <= mx && mx < x && 0 <= my && my < y && (map[my][mx] == -1 || map[my][mx] > temp.dist + 1)){\n                    map[my][mx] = temp.dist + 1;\n                    first.tx = temp.tx + dx[i];\n                    first.ty = temp.ty + dy[i];\n                    first.dist = temp.dist + 1;\n                    enq(first);\n                }\n            }\n        }\n        \n        scanf(\"%d\", &n);\n        \n        ans = 0;\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &sx, &sy);\n            first.tx = sx - 1;\n            first.ty = sy - 1;\n            first.dist = 0;\n            head = tail = 0;\n            memcpy(rec, map, sizeof(map));\n            enq(first);\n            s = 0;\n            \n            while (head != tail){\n                deq(&temp);\n                for (j = 0; j < 6; j++){\n                    mx = temp.tx + dx[j];\n                    my = temp.ty + dy[j];\n                    if (0 <= mx && mx < x && 0 <= my && my < y && (map[my][mx] > temp.dist + 1)){\n                        s++;\n                        map[my][mx] = temp.dist + 1;\n                        first.tx = temp.tx + dx[j];\n                        first.ty = temp.ty + dy[j];\n                        first.dist = temp.dist + 1;\n                        enq(first);\n                    }\n                }\n            }\n            \n            ans = ans > s ? ans : s;\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\nint main(void){\n  Place field, others[20], p;\n  int size[20];\n  int s, t, i;\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n      others[i].x -= 1;\n      others[i].y -= 1;\n    }\n    others[s].x = -1;\n    scanf(\"%d\", &t);\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      p.x -= 1;\n      p.y -= 1;\n      size[i] = countSize(p, others, field);\n    }\n    size[t] = -1;\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0;\n  for(p.x = 0; p.x < field.x; p.x++){\n    for(p.y = 0; p.y < field.y; p.y++){\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return abs(y - 1) / 2 - m + 1;\n    }\n    else{\n      return abs(y - 1) / 2 + m;\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[i], p);\n  for(i = 1; others[i].x != -1; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef struct pos\n{\n\tint x,y,cost;\n\tbool operator ()(pos const& a, pos const& b) const\n\t{\n\t\treturn a.cost>b.cost;\n\t}\n\n}pos;\n\nint M,N,S,T,m[101][101],i,j,p,q,R,t;\n\nint bfs(int x,int y,int abj)\n{\n\tint i,c=1,mx[2][6]={{-1,0,1,0,-1,-1},{0,1,1,1,0,-1}},\n\t\t\t  my[2][6]={{-1,-1,0,1,1,0},{-1,-1,0,1,1,0}};\n\tpriority_queue<pos,vector<pos>,pos>Q;\n\tm[y][x]=0;\n\tpos tmp={x,y,0};\n\tQ.push(tmp);\n\twhile(!Q.empty())\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tfor(i=0;i<abj;i++)\n\t\t{\n\t\t\tif(0<=tmp.y+my[tmp.y%2][i]&&tmp.y+my[tmp.y%2][i]<M&&0<=tmp.x+mx[tmp.y%2][i]&&tmp.x+mx[tmp.y%2][i]<N)\n\t\t\t\tif(m[tmp.y+my[tmp.y%2][i]][tmp.x+mx[tmp.y%2][i]]>tmp.cost+1)\n\t\t\t\t{\n\t\t\t\t\tm[tmp.y+my[tmp.y%2][i]][tmp.x+mx[tmp.y%2][i]]=tmp.cost+1;\n\t\t\t\t\tpos tmp2={tmp.x+mx[tmp.y%2][i],tmp.y+my[tmp.y%2][i],tmp.cost+1};\n\t\t\t\t\tc++;\n\t\t\t\t\tQ.push(tmp2);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tfor(i=0;i<100;i++)\n\t\tfor(j=0;j<100;j++)\n\t\t{\n\n\t\t}\n\tfor(;~scanf(\"%d%d%d\",&M,&N,&S),M;)\n\t{\n\t\tmemset(m,0x7,sizeof(m));\n\t\tfor(i=0;i<S;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tbfs(p-1,q-1,6);\n\t\t}\n\t\tfor(R=0,scanf(\"%d\",&T),j=0;j<T;j++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tt=bfs(p-1,q-1,6);\n\t\t\tR=t<R?R:t;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m,n,counts;\n\nvoid makeboard(int **board,int x,int y,int rank);\nint countboard(int **board,int x,int y,int rank);\n\nint main(void){\n  int s,t;\n  int i,j,k,count=0;\n  int place[10][2];\n  int **board,**copyboard;\n  \n  while(scanf(\"%d\",&m) && m!=0){\n    scanf(\"%d\",&n);\n    board=(int **)calloc(m,sizeof(int *));\n    for(i=0;i<m;i++) *(board+i)=(int *)calloc(n,sizeof(int));\n    copyboard=(int **)calloc(m,sizeof(int *));\n    for(i=0;i<m;i++) *(copyboard+i)=(int *)calloc(n,sizeof(int));\n    \n    for(i=0;i<m;i++) for(j=0;j<n;j++) *(*(board+i)+j)=999;\n    scanf(\"%d\",&s);\n    for(i=0;i<s;i++) scanf(\"%d %d\",&place[i][0],&place[i][1]);\n    for(i=0;i<s;i++) makeboard(board,place[i][0]-1,place[i][1]-1,0);\n    \n    scanf(\"%d\",&t);\n    for(i=0;i<t;i++) scanf(\"%d %d\",&place[i][0],&place[i][1]);\n    for(i=0;i<t;i++){\n      for(j=0;j<m;j++) for(k=0;k<n;k++) *(*(copyboard+j)+k)=*(*(board+j)+k);\n      makeboard(copyboard,place[i][0]-1,place[i][1]-1,0);\n      if(count<counts) count=counts;\n    }\n    printf(\"%d\\n\",count);\n    for(i=0;i<m;i++) free(*(board+i));\n    for(i=0;i<m;i++) free(*(copyboard+i));\n    free(board);\n    free(copyboard);\n  }\n  return 0;\n}\n\nvoid makeboard(int **board,int x,int y,int rank){\n  if(*(*(board+x)+y)<=rank) return;\n  *(*(board+x)+y)=rank;\n  if(rank==0) counts=1;\n  else counts++;\n  if(x>0) makeboard(board,x-1,y,rank+1); \n  if(x<m-1) makeboard(board,x+1,y,rank+1); \n  if(y%2==0){\n    if(x>0 && y>0) makeboard(board,x-1,y-1,rank+1);\n    if(y>0) makeboard(board,x,y-1,rank+1);\n    if(x>0 && y<n-1) makeboard(board,x-1,y+1,rank+1);\n    if(y<n-1) makeboard(board,x,y+1,rank+1);\n  }else{\n    if(y>0) makeboard(board,x,y-1,rank+1);\n    if(x<m-1 && y>0) makeboard(board,x+1,y-1,rank+1);\n    if(y<n-1) makeboard(board,x,y+1,rank+1);\n    if(x<m-1 && y<n-1) makeboard(board,x+1,y+1,rank+1);\n  }\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nvoid check2(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]>=set || map[x][y]<=k)return;\n\tsss[x][y]=set+k;\n\tq[j][0]=x;q[j][1]=y;\n\tj++;\n}\n\nvoid check(int x,int y,int k){\n\tcheck2(x-1+y%2,y-1,k+1);\n\tcheck2(x+y%2,y-1,k+1);\n\tcheck2(x-1,y,k+1);\n\tcheck2(x+1,y,k+1);\n\tcheck2(x-1+y%2,y+1,k+1);\n\tcheck2(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset+=300;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set+=300;\n\t\t\tblk=0;j=1;\n\t\t\tq[0][0]=x;q[0][1]=y;\n\t\t\tsss[x][y]=set;\n\t\t\twhile(blk<j){\n\t\t\t\tcheck(q[blk][0],q[blk][1],sss[q[blk][0]][q[blk][1]]-set);\n\t\t\t\tblk++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tif(x%2)printf(\"     \");\n\t\t\t\tfor(y=0;y<m;y++){\n\t\t\t\t\tprintf(\"%5d \",sss[y][x]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n  int m[101][202]={0};\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2+1<=x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  +1<=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /* for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    max=0;\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[0]);\n      c[y[t]][x[t]=x[t]*2-y[t]%2]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2+1<=x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  +1<=y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m,n,counts;\n\nvoid makeboard(int **board,int x,int y,int rank);\nint countboard(int **board,int x,int y,int rank);\n\nint main(void){\n  int s,t;\n  int i,j,k,count=0;\n  int place[10][2];\n  int **board,**copyboard;\n  \n  while(scanf(\"%d\",&m) && m!=0){\n    count=0;\n    scanf(\"%d\",&n);\n    board=(int **)calloc(m,sizeof(int *));\n    for(i=0;i<m;i++) *(board+i)=(int *)calloc(n,sizeof(int));\n    copyboard=(int **)calloc(m,sizeof(int *));\n    for(i=0;i<m;i++) *(copyboard+i)=(int *)calloc(n,sizeof(int));\n    \n    for(i=0;i<m;i++) for(j=0;j<n;j++) *(*(board+i)+j)=999;\n    scanf(\"%d\",&s);\n    for(i=0;i<s;i++) scanf(\"%d %d\",&place[i][0],&place[i][1]);\n    for(i=0;i<s;i++) makeboard(board,place[i][0]-1,place[i][1]-1,0);\n    \n    scanf(\"%d\",&t);\n    for(i=0;i<t;i++) scanf(\"%d %d\",&place[i][0],&place[i][1]);\n    for(i=0;i<t;i++){\n      for(j=0;j<m;j++) for(k=0;k<n;k++) *(*(copyboard+j)+k)=*(*(board+j)+k);\n      makeboard(copyboard,place[i][0]-1,place[i][1]-1,0);\n      if(count<counts) count=counts;\n    }\n    printf(\"%d\\n\",count);\n    for(i=0;i<m;i++) free(*(board+i));\n    for(i=0;i<m;i++) free(*(copyboard+i));\n    free(board);\n    free(copyboard);\n  }\n  return 0;\n}\n\nvoid makeboard(int **board,int x,int y,int rank){\n  if(*(*(board+x)+y)<=rank) return;\n  *(*(board+x)+y)=rank;\n  if(rank==0) counts=1;\n  else counts++;\n  if(x>0) makeboard(board,x-1,y,rank+1); \n  if(x<m-1) makeboard(board,x+1,y,rank+1); \n  if(y%2==0){\n    if(x>0 && y>0) makeboard(board,x-1,y-1,rank+1);\n    if(y>0) makeboard(board,x,y-1,rank+1);\n    if(x>0 && y<n-1) makeboard(board,x-1,y+1,rank+1);\n    if(y<n-1) makeboard(board,x,y+1,rank+1);\n  }else{\n    if(y>0) makeboard(board,x,y-1,rank+1);\n    if(x<m-1 && y>0) makeboard(board,x+1,y-1,rank+1);\n    if(y<n-1) makeboard(board,x,y+1,rank+1);\n    if(x<m-1 && y<n-1) makeboard(board,x+1,y+1,rank+1);\n  }\n}\n "
  },
  {
    "language": "C",
    "code": "x,y,X,Y,v,d;C(w){w=abs(y-Y);d=(X<x-(v=(w+y%2)/2)?x-v-X:X>x+(v=(w+1-y%2)/2)?X-x-v:0)+w;}m,n,D[101][101],s,b;main(c){for(;scanf(\"%d%d%d\",&m,&n,&s),m;printf(\"%d\\n\",b)){for(memset(D,1,40804);s--;)for(scanf(\"%d%d\",&X,&Y),y=n;y;y--)for(x=m;x;x--)C(),d<D[x][y]?D[x][y]=d:0;for(b=!scanf(\"%d\",&s);s--;b=c>b?c:b)for(c=!scanf(\"%d%d\",&X,&Y),y=n;y;y--)for(x=m;x;c+=d<D[x--][y])C();}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nvoid check2(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]>=set || map[x][y]<=k)return;\n\tsss[x][y]=set+k;\n\tq[j][0]=x;q[j][1]=y;\n\tj++;\n}\n\nvoid check(int x,int y,int k){\n\tcheck2(x-1+y%2,y-1,k+1);\n\tcheck2(x+y%2,y-1,k+1);\n\tcheck2(x-1,y,k+1);\n\tcheck2(x+1,y,k+1);\n\tcheck2(x-1+y%2,y+1,k+1);\n\tcheck2(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset++;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set+=300;\n\t\t\tblk=0;j=1;\n\t\t\tq[0][0]=x;q[0][1]=y;\n\t\t\tsss[x][y]=set;\n\t\t\twhile(blk<j){\n\t\t\t\tcheck(q[blk][0],q[blk][1],sss[q[blk][0]][q[blk][1]]-set);\n\t\t\t\tblk++;\n\t\t\t}\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n  int m[101][202]={0};\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2<x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  <y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /*for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    max=0;\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[0]);\n      x[t]=x[t]*2-y[t]%2;\n      c[y[t]][x[t]]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2<x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  <y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[101][201]={0};\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];;\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2<=x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  <=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /*for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[max=0]);\n      c[y[t]][x[t]=x[t]*2-y[t]%2]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2<x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  <y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];;\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n  int m[101][201]={0};\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2<=x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  <=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /*for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    max=0;\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[0]);\n      c[y[t]][x[t]=x[t]*2-y[t]%2]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2<x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  <y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n  int m[101][202]={0};\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2<=x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  <=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /*for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    max=0;\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[0]);\n      c[y[t]][x[t]=x[t]*2-y[t]%2]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2<=x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  <=y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\n\nint main(void){\n  Place field, others[10], p;\n  int size[10];\n  int s, t, i;\n\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    others[s].x = -1;\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n      others[i].x -= 1;\n      others[i].y -= 1;\n    }\n    scanf(\"%d\", &t);\n    size[t] = -1;\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      p.x -= 1;\n      p.y -= 1;\n      size[i] = countSize(p, others, field);\n    }\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0, a, b;\n  for(p.x = 0; p.x < field.x; p.x++){\n    for(p.y = 0; p.y < field.y; p.y++){\n      a = howLong(shop, p);\n      b = minOthersLong(others, p);\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return abs(y - 1) / 2 - m + 1;\n    }\n    else{\n      return abs(y - 1) / 2 + m;\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[i], p);\n  for(i = 1; others[i].x != -1; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[101][201]={0};\n  int c[101][201]={0};\n  int n,k,a,b,t,r,max,i;\n  int x[10000],y[10000];;\n  int X[]={ 1, 2, 1,-1,-2,-1};\n  int Y[]={ 1, 0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&k),n||k){\n    scanf(\"%d\",&a);\n    for(r=0;r<a;r++){\n      scanf(\"%d %d\",&x[r],&y[r]);\n      x[r]=x[r]*2-y[r]%2;\n      m[y[r]][x[r]]=1;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tif(x[t]+X[i]<1||k*2<=x[t]+X[i]||\n\t   y[t]+Y[i]<1||n  <=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]==0||\n\t   m[y[t]+Y[i]][x[t]+X[i]]>m[y[t]][x[t]]+1){\n\t  m[y[t]+Y[i]][x[t]+X[i]]=m[y[t]][x[t]]+1;\n\t  x[r  ]=x[t]+X[i];\n\t  y[r++]=y[t]+Y[i];\n\t}\n      }\n    }\n    /*for(i=0;i<=n+1;i++){\n      for(a=0;a<=k*2+1;a++)printf(\"%2d\",m[i][a]);\n      printf(\"\\n\");\n      }*/\n    scanf(\"%d\",&a);\n    max=0;\n    while(a--){\n      scanf(\"%d %d\",&x[t=0],&y[0]);\n      c[y[t]][x[t]=x[t]*2-y[t]%2]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  if(x[t]+X[i]<1||k*2<x[t]+X[i]||\n\t     y[t]+Y[i]<1||n  <y[t]+Y[i])continue;\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]>c[y[t]][x[t]]+1){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r  ]=x[t]+X[i];\n\t    y[r++]=y[t]+Y[i];\n\t  }\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nint check(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return 0;\n\tif(sss[x][y]==set || map[x][y]<=k)return 0;\n\tsss[x][y]=set;\n\treturn 1+check(x-1+y%2,y-1,k+1)+check(x+y%2,y-1,k+1)+check(x-1,y,k+1)+check(x+1,y,k+1)+check(x-1+y%2,y+1,k+1)+check(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset++;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set++;\n\t\t\tblk=check(x,y,0);\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m,n;\n\nvoid makeboard(int **board,int x,int y,int rank);\nint countboard(int **board,int x,int y,int rank);\n\nint main(void){\n  int s,t;\n  int i,j,k,count=0,counts;\n  int place[10][2];\n  int **board,**copyboard;\n  \n  while(scanf(\"%d\",&m) && m!=0){\n    count=0;\n    scanf(\"%d\",&n);\n    board=(int **)calloc(m,sizeof(int *));\n    for(i=0;i<m;i++) *(board+i)=(int *)calloc(n,sizeof(int));\n    copyboard=(int **)calloc(m,sizeof(int *));\n    for(i=0;i<m;i++) *(copyboard+i)=(int *)calloc(n,sizeof(int));\n    \n    for(i=0;i<m;i++) for(j=0;j<n;j++) *(*(board+i)+j)=999;\n    scanf(\"%d\",&s);\n    for(i=0;i<s;i++) scanf(\"%d %d\",&place[i][0],&place[i][1]);\n    for(i=0;i<s;i++) makeboard(board,place[i][0]-1,place[i][1]-1,0);\n    \n    scanf(\"%d\",&t);\n    for(i=0;i<t;i++) scanf(\"%d %d\",&place[i][0],&place[i][1]);\n    for(i=0;i<t;i++){\n      for(j=0;j<m;j++) for(k=0;k<n;k++) *(*(copyboard+j)+k)=*(*(board+j)+k);\n      makeboard(copyboard,place[i][0]-1,place[i][1]-1,0);\n      counts=0;\n      for(j=0;j<m;j++) for(k=0;k<n;k++) if(*(*(copyboard+j)+k)!=*(*(board+j)+k)) counts++;\n      if(count<counts) count=counts;\n    }\n    printf(\"%d\\n\",count);\n    for(i=0;i<m;i++) free(*(board+i));\n    for(i=0;i<m;i++) free(*(copyboard+i));\n    free(board);\n    free(copyboard);\n  }\n  return 0;\n}\n\nvoid makeboard(int **board,int x,int y,int rank){\n  if(*(*(board+x)+y)<=rank) return;\n  *(*(board+x)+y)=rank;\n  if(x>0) makeboard(board,x-1,y,rank+1); \n  if(x<m-1) makeboard(board,x+1,y,rank+1); \n  if(y%2==0){\n    if(x>0 && y>0) makeboard(board,x-1,y-1,rank+1);\n    if(y>0) makeboard(board,x,y-1,rank+1);\n    if(x>0 && y<n-1) makeboard(board,x-1,y+1,rank+1);\n    if(y<n-1) makeboard(board,x,y+1,rank+1);\n  }else{\n    if(y>0) makeboard(board,x,y-1,rank+1);\n    if(x<m-1 && y>0) makeboard(board,x+1,y-1,rank+1);\n    if(y<n-1) makeboard(board,x,y+1,rank+1);\n    if(x<m-1 && y<n-1) makeboard(board,x+1,y+1,rank+1);\n  }\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,set,map[150][150],sss[150][150],q[20000][2],blk,ans;\nint m,n,s,t,x,y;\n\nvoid mark(int x,int y){\n\tif(x<0 || y<0 || x>=m || y>=n)return;\n\tif(sss[x][y]!=set){\n\t\tmap[x][y]=map[q[i][0]][q[i][1]]+1;\n\t\tsss[x][y]=set;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t}\n}\n\nvoid search(int x,int y){\n\tmark(x-1+y%2,y-1);\n\tmark(x+y%2,y-1);\n\tmark(x-1,y);\n\tmark(x+1,y);\n\tmark(x-1+y%2,y+1);\n\tmark(x+y%2,y+1);\n}\n\nint check(int x,int y,int k){\n\tif(x<0 || y<0 || x>=m || y>=n)return 0;\n\tif(sss[x][y]==set || map[x][y]<=k)return 0;\n\tsss[x][y]=set;\n\treturn 1+check(x-1+y%2,y-1,k+1)+check(x+y%2,y-1,k+1)+check(x-1,y,k+1)+check(x+1,y,k+1)+check(x-1+y%2,y+1,k+1)+check(x+y%2,y+1,k+1);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&m)*m){\n\t\tset++;\n\t\tscanf(\"%d %d\",&n,&s);\n\t\tfor(i=0;i<s;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\ty--;x--;\n\t\t\tmap[x][y]=0;\n\t\t\tsss[x][y]=set;\n\t\t\tq[i][0]=x;\n\t\t\tq[i][1]=y;\n\t\t}\n\t\ti=0;j=s;\n\t\twhile(i<j){\n\t\t\tsearch(q[i][0],q[i][1]);\n\t\t\ti++;\n\t\t}\n\t\tif(i!=n*m)fprintf(stderr,\"ERROR!!\");\n\n\t\tscanf(\"%d\",&t);\n\t\tans=0;\n\t\tfor(i=0;i<t;i++){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx--;y--;set++;\n\t\t\tblk=check(x,y,0);\n\t\t\tif(ans<blk)ans=blk;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\n\nint main(void){\n  Place field, others[20], p;\n  int size[20];\n  int s, t, i;\n\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    others[s].x = -1;\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n      others[i].x -= 1;\n      others[i].y -= 1;\n    }\n    scanf(\"%d\", &t);\n    size[t] = -1;\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      p.x -= 1;\n      p.y -= 1;\n      size[i] = countSize(p, others, field);\n    }\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0, a, b;\n  for(p.x = 0; p.x < field.x; p.x++){\n    for(p.y = 0; p.y < field.y; p.y++){\n      a = howLong(shop, p);\n      b = minOthersLong(others, p);\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return abs(y - 1) / 2 - m + 1;\n    }\n    else{\n      return abs(y - 1) / 2 + m;\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[i], p);\n  for(i = 1; others[i].x != -1; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define max(a, b) ((a) > (b) ? (a) : (b))\n\nint mp[256][256];\nint test[256][256];\nint X, Y;\n\nint dx[2][6] = {{-1, 0, -1, 1, -1, 0}, {0, 1, -1, 1, 0, 1}};\nint dy[2][6] = {{-1, -1, 0, 0, 1, 1}, {-1, -1, 0, 0, 1, 1}};\n\ntypedef struct {\n\tint tx, ty;\n\tint time;\n} State;\n\nState q[100000];\nint head, tail;\n\nvoid enq(State a)\n{\n\tq[head++] = a;\n\ttail %= 100000;\n}\n\nState deq(void)\n{\n\tState r;\n\t\n\tr = q[tail++];\n\ttail %= 100000;\n\treturn (r);\n}\n\nint bfs(int c[][256], int sx, int sy)\n{\n\tint i;\n\tint ans;\n\tchar v[256][256];\n\tState s;\n\t\n\tmemset(v, 0, sizeof(v));\n\t\n\tv[sy][sx] = 1;\n\tc[sy][sx] = 0;\n\thead = tail = 0;\n\ts.tx = sx, s.ty = sy;\n\ts.time = 0;\n\tans = 1;\n\t\n\tenq(s);\n\twhile (head != tail){\n\t\tState t = deq();\n\t\tState n;\n\t\t\n\t\tfor (i = 0; i < 6; i++){\n\t\t\tint mx, my;\n\t\t\tmx = t.tx + dx[t.ty % 2][i], my = t.ty + dy[t.ty % 2][i];\n\t\t\t\n\t\t\tif (0 <= mx && mx < X && 0 <= my && my < Y && !v[my][mx] && t.time + 1 < c[my][mx]){\n\t\t\t\tv[my][mx] = 1;\n\t\t\t\tc[my][mx] = t.time + 1;\n\t\t\t\tn = t;\n\t\t\t\tn.tx = mx, n.ty = my, n.time = t.time + 1;\n\t\t\t\tenq(n);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ans);\n}\n\nint main(void)\n{\n\tint s, t;\n\tint i, j;\n\tint ans;\n\t\n\twhile (scanf(\"%d\", &X) && X){\n\t\tscanf(\"%d\", &Y);\n\t\t\n\t\tscanf(\"%d\", &s);\n\t\t\n\t\tfor (i = 0; i < Y; i++){\n\t\t\tfor (j = 0; j < X; j++){\n\t\t\t\tmp[i][j] = 99999;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < s; i++){\n\t\t\tint xi, yi;\n\t\t\tscanf(\"%d %d\", &xi, &yi);\n\t\t\tbfs(mp, --xi, --yi);\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &t);\n\t\tans = 0;\n\t\t\n\t\tfor (i = 0; i < t; i++){\n\t\t\tint pi, qi;\n\t\t\tint k;\n\t\t\tscanf(\"%d %d\", &pi, &qi);\n\t\t\tmemcpy(test, mp, sizeof(mp));\n\t\t\tk = bfs(test, --pi, --qi);\n\t\t\tans = max(ans, k);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,y[30010],x[30010],c[30010],r,t,ny,nx,a,b,n;\n  int Y[]={-1,-1,0,0,1,1};\n  int X[]={-1,1,-2,2,-1,1};\n  while(scanf(\"%d %d\",&w,&h),w){\n    int max=0,d[200][300]={};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)d[i][j*2+1-i%2]=1e9;\n    }\n    scanf(\"%d\",&n);\n    for(i=r=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      a=a*2+1-b%2;\n      d[y[r]=b][x[r]=a]=1;\n      r++;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[y[t]][x[t]]+1>=d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    while(n--){\n      scanf(\"%d %d\",&a,&b);\n      y[0]=b;\n      x[0]=a*2+1-b%2;\n      c[t=0]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  ny=y[t]+Y[i];\n\t  nx=x[t]+X[i];\n\t  if(d[ny][nx]<=c[t]+1)continue;\n\t  y[r]=ny;\n\t  x[r]=nx;\n\t  c[r++]=c[t]+1;\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\nint main(void){\n  Place field, others[20], p;\n  int size[20];\n  int s, t, i;\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n      others[i].x -= 1;\n      others[i].y -= 1;\n\n      //p.x = 0; p.y = 1;\n      //printf(\"%d\\n\", howLong(others[i], p));\n    }\n    others[s].x = -1;\n\n    scanf(\"%d\", &t);\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      p.x -= 1;\n      p.y -= 1;\n      size[i] = countSize(p, others, field);\n    }\n    size[t] = -1;\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0;\n  for(p.x = 0; p.x < field.x; p.x++){\n    for(p.y = 0; p.y < field.y; p.y++){\n      //printf(\"%d,%d\\n\", howLong(shop, p), minOthersLong(others, p));\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n        //printf(\"%d, %d\\n\", p.x, p.y);\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan > 0){\n      return abs((y - 1) / 2 + m);\n    }\n    else{\n      return abs((y - 1) / 2 - m + 1);\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[0], p);\n  for(i = 1; others[i].x != -1; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,y[30010],x[30010],c[30010],r,t,ny,nx,a,b,n;\n  int Y[]={-1,-1,0,0,1,1};\n  int X[]={-1,1,-2,2,-1,1};\n  while(scanf(\"%d %d\",&w,&h),w){\n    int max=0,d[200][300]={};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)d[i][j*2+1-i%2]=1e9;\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    for(i=r=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      a=a*2+1-b%2;\n      d[y[r]=b][x[r]=a]=1;\n      r++;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[y[t]][x[t]]+1>=d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    while(n--){\n      int f[200][300]={};\n      scanf(\"%d %d\",&a,&b);\n      f[y[0]=b][x[0]=a*2+1-b%2]=c[t=0]=1;\n      if(d[y[0]][x[0]]==1)continue;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  ny=y[t]+Y[i];\n\t  nx=x[t]+X[i];\n\t  if(d[ny][nx]<=c[t]+1||f[ny][nx])continue;\n\t  f[y[r]=ny][x[r]=nx]=1;\n\t  c[r++]=c[t]+1;\n\t}\n      }\n      /*for(i=0;i<h+2;i++){\n\tfor(j=0;j<w*2+3;j++)printf(\"%d \",f[i][j]);\n\tprintf(\"\\n\");\n\t}//*/\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,y[30010],x[30010],c[30010],r,t,ny,nx,a,b,n;\n  int Y[]={-1,-1,0,0,1,1};\n  int X[]={-1,1,-2,2,-1,1};\n  while(scanf(\"%d %d\",&w,&h),w){\n    int max=0,d[200][300]={};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)d[i][j*2+1-i%2]=1e9;\n    }\n    scanf(\"%d\",&n);\n    for(i=r=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      a=a*2+1-b%2;\n      d[y[r]=b][x[r]=a]=1;\n      r++;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[y[t]][x[t]]+1>=d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    while(n--){\n      scanf(\"%d %d\",&a,&b);\n      y[0]=b;\n      x[0]=a*2+1-b%2;\n      c[t=0]=1;\n      if(d[b][a]==1)continue;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  ny=y[t]+Y[i];\n\t  nx=x[t]+X[i];\n\t  if(d[ny][nx]<=c[t]+1)continue;\n\t  y[r]=ny;\n\t  x[r]=nx;\n\t  c[r++]=c[t]+1;\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "x,y,X,Y,v,d;S(){scanf(\"%d%d\",&X,&Y);}C(w){w=abs(y-Y);d=(X<x-(v=(w+y%2)/2)?x-v-X:X>x+(v=(w+1-y%2)/2)?X-x-v:0)+w;}m,n,D[124][101],s,b,F=\"%d\\n\";main(c){for(;S(),n=Y,m=X;printf(F,b)){for(memset(D,scanf(F,&s),5e4);s--;)for(S(y=n);y;y--)for(x=m;x;x--)C(),d<D[x][y]?D[x][y]=d:0;for(b=!scanf(F,&s);s--;b=c>b?c:b)for(S(c=0),y=n;y;y--)for(x=m;x;c+=d<D[x--][y])C();}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  int x, y;\n}Place;\n\nint max(int *);\nint min(int, int);\nint abs(int);\nint countSize(Place, Place[], Place);\nint howLong(Place, Place);\nint countSlope(Place, Place);\nint minOthersLong(Place[], Place);\n\nint main(void){\n  Place field, others[20], p;\n  int size[20];\n  int s, t, i;\n  while(1){\n    scanf(\"%d %d\", &field.x, &field.y);\n    if(field.x == 0 && field.y == 0){\n      break;\n    }\n\n    scanf(\"%d\", &s);\n    for(i = 0; i < s; i++){\n      scanf(\"%d %d\", &others[i].x, &others[i].y);\n    }\n    others[s].x = 0;\n\n    scanf(\"%d\", &t);\n    for(i = 0; i < t; i++){\n      scanf(\"%d %d\", &p.x, &p.y);\n      size[i] = countSize(p, others, field);\n    }\n    size[t] = -1;\n\n    printf(\"%d\\n\", max(size));\n  }\n\n  return 0;\n}\nint max(int *size){\n  int max = 0;\n  while(*size != -1){\n    if(max < *size){\n      max = *size;\n    }\n    size++;\n  }\n  return max;\n}\nint min(int x, int y){\n  if(x < y){\n    return x;\n  }\n  return y;\n}\nint abs(int x){\n  if(x < 0){\n    return x * -1;\n  }\n  return x;\n}\nint countSize(Place shop, Place others[], Place field){\n  Place p;\n  int size = 0;\n  for(p.x = 1; p.x <= field.x; p.x++){\n    for(p.y = 1; p.y <= field.y; p.y++){\n      if(howLong(shop, p) < minOthersLong(others, p)){\n        size++;\n      }\n    }\n  }\n  return size;\n}\nint howLong(Place p1, Place p2){\n  int x = abs(p1.x - p2.x);\n  int y = abs(p1.y - p2.y);\n\n  return x + y - min(x, countSlope(p1, p2));\n}\nint countSlope(Place p1, Place p2){\n  int y = p1.y - p2.y;\n  int tan = (p1.x - p2.x) * (p1.y - p2.y);\n  int m = p2.y % 2;\n\n  if(y % 2 == 0){\n    return abs(y) / 2;\n  }\n  else{\n    if(tan < 0){\n      return abs((y - 1) / 2 + m);\n    }\n    else{\n      return abs((y - 1) / 2 - m + 1);\n    }\n  }\n}\nint minOthersLong(Place others[], Place p){\n  int i, l, min = howLong(others[0], p);\n  for(i = 1; others[i].x != 0; i++){\n    l = howLong(others[i], p);\n    if(min > l){\n      min = l;\n    }\n  }\n  return min;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,y[30010],x[30010],c[30010],r,t,ny,nx,a,b,n;\n  int Y[]={-1,-1,0,0,1,1};\n  int X[]={-1,1,-2,2,-1,1};\n  while(scanf(\"%d %d\",&w,&h),w){\n    int max=0,d[200][300]={};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)d[i][j*2+1-i%2]=1e9;\n    }\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      a=a*2+1-b%2;\n      d[y[r]=b][x[r]=a]=1;\n      r++;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[y[t]][x[t]]+1>=d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    while(n--){\n      scanf(\"%d %d\",&a,&b);\n      y[0]=b;\n      x[0]=a*2+1-b%2;\n      c[t=0]=1;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  ny=y[t]+Y[i];\n\t  nx=x[t]+X[i];\n\t  if(d[ny][nx]<=c[t]+1)continue;\n\t  y[r]=ny;\n\t  x[r]=nx;\n\t  c[r++]=c[t]+1;\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,y[30010],x[30010],c[30010],r,t,ny,nx,a,b,n;\n  int Y[]={-1,-1,0,0,1,1};\n  int X[]={-1,1,-2,2,-1,1};\n  while(scanf(\"%d %d\",&w,&h),w){\n    int max=0,d[200][300]={};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)d[i][j*2+1-i%2]=1e9;\n    }\n    scanf(\"%d\",&n);\n    for(i=r=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      a=a*2+1-b%2;\n      d[y[r]=b][x[r]=a]=1;\n      r++;\n    }\n    for(t=0;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[y[t]][x[t]]+1>=d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h+2;i++){\n      for(j=0;j<w*2+3;j++)printf(\"%d \",d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&n);\n    while(n--){\n      int f[200][300]={};\n      scanf(\"%d %d\",&a,&b);\n      y[0]=b;\n      x[0]=a*2+1-b%2;\n      c[t=0]=1;\n      if(d[b][a]==1)continue;\n      for(r=1;r-t;t++){\n\tfor(i=0;i<6;i++){\n\t  ny=y[t]+Y[i];\n\t  nx=x[t]+X[i];\n\t  if(d[ny][nx]<=c[t]+1||f[ny][nx])continue;\n\t  f[y[r]=ny][x[r]=nx]=1;;\n\t  c[r++]=c[t]+1;\n\t}\n      }\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int SIZE = 100;\n\t\n\tpublic static final int[][][] move_dir = \n\t\t{\n\t\t\t{\n\t\t\t\t{ 1,  0},\n\t\t\t\t{-1,  0},\n\t\t\t\t{ 0,  1},\n\t\t\t\t{ 0, -1},\n\t\t\t\t{-1, -1},\n\t\t\t\t{-1,  1}\n\t\t\t},\n\t\t\t{\n\t\t\t\t{ 1,  0},\n\t\t\t\t{-1,  0},\n\t\t\t\t{ 0,  1},\n\t\t\t\t{ 0, -1},\n\t\t\t\t{ 1, -1},\n\t\t\t\t{ 1,  1}\n\t\t\t}\n\t\t};\n\t\n\tpublic static boolean is_ok(int x, int y, int m, int n){\n\t\tif(x < 0 || y < 0 || x >= m || y >= n){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tint[][] dist = new int[SIZE][SIZE];\n\t\tboolean[][] visited = new boolean[SIZE][SIZE];\n\t\t\n\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> time_queue = new LinkedList<Integer>();\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tdist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tx_queue.clear();\n\t\t\ty_queue.clear();\n\t\t\ttime_queue.clear();\n\t\t\t\n\t\t\tfinal int s = sc.nextInt();\n\t\t\tfor(int i = 0; i < s; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tdist[y][x] = 0;\n\t\t\t\tx_queue.add(x);\n\t\t\t\ty_queue.add(y);\n\t\t\t}\n\t\t\t\n\t\t\twhile(!x_queue.isEmpty()){\n\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(x + \" \" + y);\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir[y % 2]){\n\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\tfinal int next_dist = dist[y][x] + 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(nx, ny, m, n)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(dist[ny][nx] <= next_dist){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdist[ny][nx] = next_dist;\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tSystem.out.print(dist[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t\t*/\n\t\t\tfinal int t = sc.nextInt();\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < t; i++){\n\t\t\t\tfinal int sx = sc.nextInt() - 1;\n\t\t\t\tfinal int sy = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tif(dist[sy][sx] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n ; j++){\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tvisited[j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx_queue.clear();\n\t\t\t\ty_queue.clear();\n\t\t\t\ttime_queue.clear();\n\t\t\t\t\n\t\t\t\tx_queue.add(sx);\n\t\t\t\ty_queue.add(sy);\n\t\t\t\ttime_queue.add(0);\n\t\t\t\tvisited[sy][sx] = true;\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\twhile(!time_queue.isEmpty()){\n\t\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\t\tfinal int time = time_queue.poll();\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(i + \" \" + x + \" \" +  y + \" \" + time);\n\t\t\t\t\tcount++;\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(count);\n\t\t\t\t\t\n\t\t\t\t\tfor(int[] move : move_dir[y % 2]){\n\t\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\t\tfinal int next_time = time + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!is_ok(nx, ny, m, n)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(dist[ny][nx] <= next_time){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\ttime_queue.add(next_time);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//ライバル社\n\tvoid color(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num){\n\t\t\t\t\t\tif(xy[i+1][j] == 0){\n\t\t\t\t\t\t\txy[i+1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] == 0){\n\t\t\t\t\t\t\txy[i-1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] == 0){\n\t\t\t\t\t\t\txy[i][j+1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] == 0){\n\t\t\t\t\t\t\txy[i][j-1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t}\n\t//自社\n\tint Map(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\tint result = 0;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num*(-1)){\n\t\t\t\t\t\tif(xy[i+1][j] > num+1){\n\t\t\t\t\t\t\txy[i+1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] > num+1){\n\t\t\t\t\t\t\txy[i-1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] > num+1){\n\t\t\t\t\t\t\txy[i][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] > num+1){\n\t\t\t\t\t\t\txy[i][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i = 1;i < n+1;i++){\n\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\tif(xy[i][j] < 0)result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint ans = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m == 0)break;\n\t\t\tint xy[][] = new int [n+2][m+2];\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int i = 0;i < num;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\txy[y][x] = 1;\n\t\t\t}\n\t\t\tcolor(xy,n,m);\n\t\t\tint map[][] = new int [n+2][m+2];\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int k = 0;k < s;k++){\n\t\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\t\tmap[i][j] = xy[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint xm = sc.nextInt();\n\t\t\t\tint ym = sc.nextInt();\n\t\t\t\tmap[ym][xm] = -1;\n\t\t\t\tif(k == 0){\n\t\t\t\t\tans = Map(map,n,m);\n\t\t\t\t}else{\n\t\t\t\t\tif(ans < Map(map,n,m)){\n\t\t\t\t\t\tans = Map(map,n,m); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int[][] map2;\n\tstatic int[] vx = new int[] {0,1,-1,1,0,1};\n\tstatic int[] vy = new int[] {-1,-1,0,0,1,1};\n\t\n\tstatic int[] vx2 = new int[] {-1,0,-1,1,-1,0};\n\tstatic int[] vy2 = new int[] {-1,-1,0,0,1,1};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tmap = new int[n][m];\n\t\t\tmap2 = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], 2 << 27);\n\t\t\t\tArrays.fill(map2[i], -1);\n\t\t\t}\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int i = 0; i < s; i++) {\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,i);\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\tfor(int i = 0; i < t; i++) {\n\t\t\t\tint[][] tmpMap = new int[n][];\n\t\t\t\tint[][] tmpMap2 = new int[n][];\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\ttmpMap[j] = Arrays.copyOf(map[j], map[j].length);\n\t\t\t\t\ttmpMap2[j] = Arrays.copyOf(map2[j], map2[j].length);\n\t\t\t\t}\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,-2);\n\t\t\t\tint ret = count();\n\t\t\t\tif(ret > max) { \n\t\t\t\t\tmax = ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap = tmpMap;\n\t\t\t\tmap2 = tmpMap2;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic void solv(int y ,int x, int count,int id) {\n\t\tif(map[y][x] < count) return;\n\t\tif(map[y][x] == count && map2[y][x] != id) {\n\t\t\tmap2[y][x] = -10;\n\t\t\treturn;\n\t\t}\n\t\tif(map[y][x] == count) {\n\t\t\treturn;\n\t\t}\n\t\tmap[y][x] = count;\n\t\tmap2[y][x] = id;\n\t\t\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tint tmpy;\n\t\t\tint tmpx;\n\t\t\tif(y % 2 == 1) {\n\t\t\t\ttmpy = y + vy[i];\n\t\t\t\ttmpx = x + vx[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmpy = y + vy2[i];\n\t\t\t\ttmpx = x + vx2[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(!check(tmpy,tmpx)) continue;\n\t\t\tsolv(tmpy,tmpx,count+1,id);\n\t\t}\n\t}\n\t\n\tstatic boolean check(int y, int x) {\n\t\tif(y < 0 || x < 0 || y >= map.length || x >= map[y].length) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int count() {\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tfor(int j = 0; j < map[i].length; j++) {\n\t\t\t\tif(map2[i][j] == -2) ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t//1251\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 24;\n\tint [][] field;\n\tint [][] vx = {{0,1,0,-1,-1,-1},{0,1,0,-1,1,1}};\n\tint [][] vy = {{1,0,-1,0,1,-1 },{1,0,-1,0,-1,1}};\n\tint n,m;\n\t\n\tclass C{\n\t\tint x,y, step;\n\n\t\tpublic C(int x, int y, int step) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n== 0)break;\n\t\t\tm = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tfield = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(field[i], INF);\n\t\t\t}\n\t\t\tfor(int i = 0; i < s; i++){\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tbfs(x,y);\n\t\t\t}\n\t\t\tint t = sc.nextInt();\n\t\t\tint [][] work = deepcopy(field);\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < t; i++){\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tfield = deepcopy(work);\n\t\t\t\tint res = bfs(x,y);\n\t\t\t\tmax = Math.max(max, res);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tprivate int[][] deepcopy(int[][] field2) {\n\t\tint [][] res = new int[n][m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tres[i][j] = field2[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int bfs(int x, int y) {\n\t\tLinkedList<C> open = new LinkedList<Main.C>();\n\t\topen.add(new C(x, y, 0));\n\t\tfield[y][x] = 0;\n\t\tint ans = 1;\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.poll();\n\t\t\tint ind = now.y % 2;\n\t\t\tfor(int i = 0; i < vx[ind].length; i++){\n\t\t\t\tint xx = now.x + vx[ind][i];\n\t\t\t\tint yy = now.y + vy[ind][i];\n\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\tif(field[yy][xx] <= now.step + 1) continue;\n\t\t\t\topen.add(new C(xx, yy, now.step + 1));\n\t\t\t\tfield[yy][xx] = now.step + 1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0<= xx && xx < m && 0<= yy && yy < n){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int[][] map2;\n\tstatic int[] vx = new int[] {0,1,-1,1,0,1};\n\tstatic int[] vy = new int[] {-1,-1,0,0,1,1};\n\t\n\tstatic int[] vx2 = new int[] {-1,0,-1,1,-1,0};\n\tstatic int[] vy2 = new int[] {-1,-1,0,0,1,1};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tmap = new int[n][m];\n\t\t\tmap2 = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], 2 << 27);\n\t\t\t\tArrays.fill(map2[i], -1);\n\t\t\t}\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int i = 0; i < s; i++) {\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,i);\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\tfor(int i = 0; i < t; i++) {\n\t\t\t\tint[][] tmpMap = new int[n][];\n\t\t\t\tint[][] tmpMap2 = new int[n][];\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\ttmpMap[j] = Arrays.copyOf(map[j], map[j].length);\n\t\t\t\t\ttmpMap2[j] = Arrays.copyOf(map2[j], map2[j].length);\n\t\t\t\t}\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,-2);\n\t\t\t\tint ret = count();\n\t\t\t\tif(ret > max) { \n\t\t\t\t\tmax = ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap = tmpMap;\n\t\t\t\tmap2 = tmpMap2;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic void solv(int y ,int x, int count,int id) {\n\t\tif(map[y][x] < count) return;\n\t\tif(map[y][x] == count && map2[y][x] != id) {\n\t\t\tmap2[y][x] = -10;\n\t\t\treturn;\n\t\t}\n\t\tmap[y][x] = count;\n\t\tmap2[y][x] = id;\n\t\t\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tint tmpy = y + vy[i];\n\t\t\tint tmpx = x + vx[i];\n\t\t\tif(y % 2 == 0) {\n\t\t\t\ttmpy = y + vy2[i];\n\t\t\t\ttmpx = x + vx2[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(!check(tmpy,tmpx)) continue;\n\t\t\tsolv(tmpy,tmpx,count+1,id);\n\t\t}\n\t}\n\t\n\tstatic boolean check(int y, int x) {\n\t\tif(y < 0 || x < 0 || y >= map.length || x >= map[y].length) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int count() {\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tfor(int j = 0; j < map[i].length; j++) {\n\t\t\t\tif(map2[i][j] == -2) ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Deven-Eleven\npublic class Main{\n\n\tstatic int[][] move = {{0,-1},{1,-1},{-1,0},{1,0},{0,1},{1,1}};\n\tstatic int[][] move2 = {{-1,-1},{0,-1},{-1,0},{1,0},{-1,1},{0,1}};\n\tstatic int m, n, s;\n\t\n\tstatic int[][] bfs(int x, int y){\n\t\tint[][] r = new int[m+1][n+1];\n\t\tboolean[][] v = new boolean[m+1][n+1];\n\t\tint step = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tv[x][y] = true;\n\t\tl.add(new int[]{x, y});\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\tint nx = a[0]+(a[1]%2==0?move[k][0]:move2[k][0]);\n\t\t\t\t\tint ny = a[1]+(a[1]%2==0?move[k][1]:move2[k][1]);\n\t\t\t\t\tif(1<=nx&&nx<=m&&1<=ny&&ny<=n&&!v[nx][ny]){\n\t\t\t\t\t\tv[nx][ny] = true;\n\t\t\t\t\t\tr[nx][ny] = step;\n\t\t\t\t\t\tnext.add(new int[]{nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t\tl = next;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt();\n\t\t\tint[][][] a = new int[s][m+1][n+1];\n\t\t\tfor(int i=0;i<s;i++)a[i]=bfs(sc.nextInt(), sc.nextInt());\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\twhile(t--!=0){\n\t\t\t\tint[][] r = bfs(sc.nextInt(), sc.nextInt());\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int x=1;x<=m;x++){\n\t\t\t\t\tfor(int y=1;y<=n;y++){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\t\tif(r[x][y]>=a[k][x][y])f=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f)c++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, c);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int[][] map2;\n\tstatic int[] vx = new int[] {0,1,-1,1,0,1};\n\tstatic int[] vy = new int[] {-1,-1,0,0,1,1};\n\t\n\tstatic int[] vx2 = new int[] {-1,0,-1,1,-1,0};\n\tstatic int[] vy2 = new int[] {-1,-1,0,0,1,1};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tmap = new int[n][m];\n\t\t\tmap2 = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], 2 << 27);\n\t\t\t\tArrays.fill(map2[i], -1);\n\t\t\t}\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int i = 0; i < s; i++) {\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,i);\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\tfor(int i = 0; i < t; i++) {\n\t\t\t\tint[][] tmpMap = new int[n][];\n\t\t\t\tint[][] tmpMap2 = new int[n][];\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\ttmpMap[j] = Arrays.copyOf(map[j], map[j].length);\n\t\t\t\t\ttmpMap2[j] = Arrays.copyOf(map2[j], map2[j].length);\n\t\t\t\t}\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,-2);\n\t\t\t\tint ret = count();\n\t\t\t\tif(ret > max) { \n\t\t\t\t\tmax = ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap = tmpMap;\n\t\t\t\tmap2 = tmpMap2;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic void solv(int y ,int x, int count,int id) {\n\t\tif(map[y][x] < count) return;\n\t\tif(map[y][x] == count) {\n\t\t\tmap2[y][x] = -10;\n\t\t\treturn;\n\t\t}\n\t\tmap[y][x] = count;\n\t\tmap2[y][x] = id;\n\t\t\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tint tmpy;\n\t\t\tint tmpx;\n\t\t\tif(y % 2 == 1) {\n\t\t\t\ttmpy = y + vy[i];\n\t\t\t\ttmpx = x + vx[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmpy = y + vy2[i];\n\t\t\t\ttmpx = x + vx2[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(!check(tmpy,tmpx)) continue;\n\t\t\tsolv(tmpy,tmpx,count+1,id);\n\t\t}\n\t}\n\t\n\tstatic boolean check(int y, int x) {\n\t\tif(y < 0 || x < 0 || y >= map.length || x >= map[y].length) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int count() {\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tfor(int j = 0; j < map[i].length; j++) {\n\t\t\t\tif(map2[i][j] == -2) ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint[][][] map = new int[s][n][m];\n\t\t\tfor (int i = 0; i < s; i++) {\n\t\t\t\tint x = scanner.nextInt() - 1;\n\t\t\t\tint y = scanner.nextInt() - 1;\n\t\t\t\tmap[i] = dfs(x, y);\n\t\t\t}\n\t\t\tint v = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\twhile (v-- > 0) {\n\t\t\t\tint c = 0;\n\t\t\t\tint x = scanner.nextInt() - 1;\n\t\t\t\tint y = scanner.nextInt() - 1;\n\t\t\t\tint[][] r = dfs(x, y);\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tboolean flag = true;\n\t\t\t\t\t\tfor (int k = 0; k < s; k++) {\n\t\t\t\t\t\t\tif (map[k][i][j] <= r[i][j]) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, c);\n\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tprivate int[][] dfs(int x, int y) {\n\t\tint[][] tmp = new int[n][m];\n\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\tdeque.offer(new Point(y, x));\n\t\tboolean[][] b = new boolean[n][m];\n\t\tb[y][x] = true;\n\t\tint step = 1;\n\t\twhile (!deque.isEmpty()) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tPoint point = deque.poll();\n\t\t\t\tif (point.y % 2 == 0) {\n\t\t\t\t\tslove(deque, point, move, b, tmp, step);\n\t\t\t\t} else {\n\t\t\t\t\tslove(deque, point, move2, b, tmp, step);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tprivate void slove(Deque<Point> deque, Point point, int[][] move,\n\t\t\tboolean[][] b, int[][] tmp, int step) {\n\t\tfor (int[] a : move) {\n\t\t\tint dy = point.y + a[0];\n\t\t\tint dx = point.x + a[1];\n\t\t\tif (0 <= dy && dy < n && 0 <= dx && dx < m && !b[dy][dx]) {\n\t\t\t\tb[dy][dx] = true;\n\t\t\t\ttmp[dy][dx] = step;\n\t\t\t\tdeque.offer(new Point(dy, dx));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Point {\n\t\tint y;\n\t\tint x;\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t}\n\n\tint[][] move = { { -1, -1 }, { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, -1 },\n\t\t\t{ 1, 0 } };\n\tint[][] move2 = { { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, 0 },\n\t\t\t{ 1, 1 } };\n\n\tint m;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(n=s.nextInt())>0;){\n\t\t\tm=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tq.add(new int[]{s.nextInt()-1,s.nextInt()-1,1});\n\t\t\t\tint c=0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tif(a[t[1]][t[0]]>t[2]){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\t\tint u=t[0]+dm[t[1]%2][i],v=t[1]+dn[t[1]%2][i];\n\t\t\t\t\t\t\tif(0<=u&&u<m&&0<=v&&v<n){\n\t\t\t\t\t\t\t\tq.add(new int[]{u,v,t[2]+1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Deven-Eleven\npublic class Main{\n\n\tstatic int[][] move = {{-1,0},{-1,1},{0,-1},{0,1},{1,0},{1,1}};\n\tstatic int[][] move2 = {{-1,-1},{-1,0},{0,-1},{0,1},{1,-1},{1,0}};\n\tstatic int m, n, s;\n\t\n\tstatic int[][] bfs(int x, int y){\n\t\tint[][] r = new int[m+1][n+1];\n\t\tboolean[][] v = new boolean[m+1][n+1];\n\t\tint step = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tv[x][y] = true;\n\t\tl.add(new int[]{x, y});\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\tint nx = a[0]+(a[1]%2==0?move[k][0]:move2[k][0]);\n\t\t\t\t\tint ny = a[1]+(a[1]%2==0?move[k][1]:move2[k][1]);\n\t\t\t\t\tif(1<=nx&&nx<=m&&1<=ny&&ny<=n&&!v[nx][ny]){\n\t\t\t\t\t\tv[nx][ny] = true;\n\t\t\t\t\t\tr[nx][ny] = step;\n\t\t\t\t\t\tnext.add(new int[]{nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t\tl = next;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt();\n\t\t\tint[][][] a = new int[s][m+1][n+1];\n\t\t\tfor(int i=0;i<s;i++)a[i]=bfs(sc.nextInt(), sc.nextInt());\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\twhile(t--!=0){\n\t\t\t\tint[][] r = bfs(sc.nextInt(), sc.nextInt());\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int x=1;x<=m;x++){\n\t\t\t\t\tfor(int y=1;y<=n;y++){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\t\tif(r[x][y]>=a[k][x][y])f=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f)c++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, c);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tif(a[t[0]][t[1]]>t[2]){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m){\n\t\t\t\t\t\t\t\tq.add(new int[]{u1,v1,t[2]+1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=1;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&a[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\tq.add(new int[]{u1,v1,t[2]+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(n=s.nextInt())>0;){\n\t\t\tm=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint u=s.nextInt()-1,v=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dn={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dm={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\t\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[1]%2][i],v=t[1]+dm[t[1]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint u=s.nextInt()-1,v=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\t\ttmp[u][v]=1;\n\t\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\t\tint c=1;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\t\tint u1=t[0]+dn[t[1]%2][i],v1=t[1]+dm[t[1]%2][i];\n\t\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Deven-Eleven\n */\npublic class Main {\n\n\tfinal static int UNK = -1;\n\tfinal static int INF = 1 << 29;\n\tfinal static int[][] HV = {\n\t\t\t{0, -1},\n\t\t\t{1, -1},\n\t\t\t{1, 0},\n\t\t\t{1, 1},\n\t\t\t{0, 1},\n\t\t\t{-1, 0},\n\t};\n\tfinal static int DEVEN = 11;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint m, n, s;\n\t\t\tm = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((m | n) == 0) break;\n\t\t\ts = parseInt(br.readLine());\n\n\t\t\tint[][][] map = new int[m + 2][n + 2][2];\n\t\t\tfor (int i = 0; i < m + 2; i++) {\n\t\t\t\tfor (int j = 0; j < n + 2; j++) {\n\t\t\t\t\tmap[i][j][0] = UNK;\n\t\t\t\t\tif (i == 0 || i == m + 1\n\t\t\t\t\t\t\t|| j == 0 || j == n + 1) {\n\t\t\t\t\t\tmap[i][j][1] = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i][j][1] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDeque<int[]> queue1 = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < s; ++i) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tmap[x][y][0] = i;\n\t\t\t\tmap[x][y][1] = 0;\n\t\t\t\tqueue1.offer(new int[]{x, y, i, 0});\n\t\t\t}\n\n\t\t\twhile (!queue1.isEmpty()) {\n\t\t\t\tint[] _s = queue1.poll();\n\t\t\t\tfor (int i = 0; i < HV.length; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = _s[0] + HV[i][0];\n\t\t\t\t\tny = _s[1] + HV[i][1];\n\t\t\t\t\tif (map[nx][ny][0] != _s[2]) {\n\t\t\t\t\t\tif (map[nx][ny][1] > _s[3] + 1) {\n\t\t\t\t\t\t\tmap[nx][ny][0] = _s[2];\n\t\t\t\t\t\t\tmap[nx][ny][1] = _s[3] + 1;\n\t\t\t\t\t\t\tqueue1.offer(new int[]{nx, ny, _s[2], _s[3] + 1});\n\t\t\t\t\t\t} else if (map[nx][ny][1] == _s[3] + 1) {\n\t\t\t\t\t\t\tmap[nx][ny][0] = UNK;\n\t\t\t\t\t\t\tmap[nx][ny][1] = _s[3] + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tint t = parseInt(br.readLine());\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tint count = 0;\n\t\t\t\tint[][][] _map = map.clone();\n\t\t\t\tDeque<int[]> queue2 = new ArrayDeque<>();\n\t\t\t\tqueue2.offer(new int[]{x, y, DEVEN, 0});\n\t\t\t\twhile (!queue2.isEmpty()) {\n\t\t\t\t\tint[] d = queue2.poll();\n\t\t\t\t\tfor (int j = 0; j < HV.length; j++) {\n\t\t\t\t\t\tint nx, ny;\n\t\t\t\t\t\tnx = d[0] + HV[j][0];\n\t\t\t\t\t\tny = d[1] + HV[j][1];\n\t\t\t\t\t\tif (_map[nx][ny][0] != DEVEN) {\n\t\t\t\t\t\t\tif (_map[nx][ny][1] > d[3] + 1) {\n\t\t\t\t\t\t\t\t_map[nx][ny][0] = DEVEN;\n\t\t\t\t\t\t\t\t_map[nx][ny][1] = d[3] + 1;\n\t\t\t\t\t\t\t\tqueue2.offer(new int[]{nx, ny, DEVEN, d[3] + 1});\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t} else if (_map[nx][ny][1] == d[3] + 1) {\n\t\t\t\t\t\t\t\t_map[nx][ny][0] = UNK;\n\t\t\t\t\t\t\t\t_map[nx][ny][1] = d[3] + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int[][] map;\n\tstatic int[][] map2;\n\tstatic int[] vx = new int[] {0,1,-1,1,0,1};\n\tstatic int[] vy = new int[] {-1,-1,0,0,1,1};\n\t\n\tstatic int[] vx2 = new int[] {-1,0,-1,1,-1,0};\n\tstatic int[] vy2 = new int[] {-1,-1,0,0,1,1};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tmap = new int[n][m];\n\t\t\tmap2 = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], 2 << 27);\n\t\t\t\tArrays.fill(map2[i], -1);\n\t\t\t}\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int i = 0; i < s; i++) {\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,i);\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\tfor(int i = 0; i < t; i++) {\n\t\t\t\tint[][] tmpMap = new int[n][];\n\t\t\t\tint[][] tmpMap2 = new int[n][];\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\ttmpMap[j] = Arrays.copyOf(map[j], map[j].length);\n\t\t\t\t\ttmpMap2[j] = Arrays.copyOf(map2[j], map2[j].length);\n\t\t\t\t}\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tsolv(y,x,0,-2);\n\t\t\t\tint ret = count();\n\t\t\t\tif(ret > max) { \n\t\t\t\t\tmax = ret;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap = tmpMap;\n\t\t\t\tmap2 = tmpMap2;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic void solv(int y ,int x, int count,int id) {\n\t\tif(map[y][x] < count) return;\n\t\tif(map[y][x] == count && map2[y][x] != id) {\n\t\t\tmap2[y][x] = -10;\n\t\t\treturn;\n\t\t}\n\t\tmap[y][x] = count;\n\t\tmap2[y][x] = id;\n\t\t\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tint tmpy;\n\t\t\tint tmpx;\n\t\t\tif(y % 2 == 1) {\n\t\t\t\ttmpy = y + vy[i];\n\t\t\t\ttmpx = x + vx[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmpy = y + vy2[i];\n\t\t\t\ttmpx = x + vx2[i];\n\t\t\t}\n\t\t\t\n\t\t\tif(!check(tmpy,tmpx)) continue;\n\t\t\tsolv(tmpy,tmpx,count+1,id);\n\t\t}\n\t}\n\t\n\tstatic boolean check(int y, int x) {\n\t\tif(y < 0 || x < 0 || y >= map.length || x >= map[y].length) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int count() {\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\tfor(int j = 0; j < map[i].length; j++) {\n\t\t\t\tif(map2[i][j] == -2) ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "6 6\n6  \n1 1\n6 1\n3 2\n3 5\n1 6\n5 6\n2\n1 3\n5 3\n6 6\n6\n3 2\n3 5\n6 1\n1 1\n1 6\n5 6\n2\n2 3\n5 3\n0 0"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int SIZE = 100;\n\t\n\tpublic static final int[][][] move_dir = \n\t\t{\n\t\t\t{\n\t\t\t\t{ 1,  0},\n\t\t\t\t{-1,  0},\n\t\t\t\t{ 0,  1},\n\t\t\t\t{ 0, -1},\n\t\t\t\t{-1, -1},\n\t\t\t\t{-1,  1}\n\t\t\t},\n\t\t\t{\n\t\t\t\t{ 1,  0},\n\t\t\t\t{-1,  0},\n\t\t\t\t{ 0,  1},\n\t\t\t\t{ 0, -1},\n\t\t\t\t{ 1, -1},\n\t\t\t\t{ 1,  1}\n\t\t\t}\n\t\t};\n\t\n\tpublic static boolean is_ok(int x, int y, int m, int n){\n\t\tif(x < 0 || y < 0 || x >= m || y >= n){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tint[][] dist = new int[SIZE][SIZE];\n\t\tboolean[][] visited = new boolean[SIZE][SIZE];\n\t\t\n\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> time_queue = new LinkedList<Integer>();\n\t\t\n\t\twhile(true){\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tdist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tx_queue.clear();\n\t\t\ty_queue.clear();\n\t\t\ttime_queue.clear();\n\t\t\t\n\t\t\tfinal int s = sc.nextInt();\n\t\t\tfor(int i = 0; i < s; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tdist[y][x] = 0;\n\t\t\t\tx_queue.add(x);\n\t\t\t\ty_queue.add(y);\n\t\t\t}\n\t\t\t\n\t\t\twhile(!x_queue.isEmpty()){\n\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(x + \" \" + y);\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir[y % 2]){\n\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\tfinal int next_dist = dist[y][x] + 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(nx, ny, m, n)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(dist[ny][nx] <= next_dist){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdist[ny][nx] = next_dist;\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tSystem.out.print(dist[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t\t*/\n\t\t\tfinal int t = sc.nextInt();\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < t; i++){\n\t\t\t\tfinal int sx = sc.nextInt() - 1;\n\t\t\t\tfinal int sy = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tif(dist[sy][sx] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n ; j++){\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tvisited[j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx_queue.clear();\n\t\t\t\ty_queue.clear();\n\t\t\t\ttime_queue.clear();\n\t\t\t\t\n\t\t\t\tx_queue.add(sx);\n\t\t\t\ty_queue.add(sy);\n\t\t\t\ttime_queue.add(0);\n\t\t\t\tvisited[sy][sx] = true;\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\twhile(!time_queue.isEmpty()){\n\t\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\t\tfinal int time = time_queue.poll();\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(i + \" \" + x + \" \" +  y + \" \" + time);\n\t\t\t\t\tcount++;\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(count);\n\t\t\t\t\t\n\t\t\t\t\tfor(int[] move : move_dir[y % 2]){\n\t\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\t\tfinal int next_time = time + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!is_ok(nx, ny, m, n)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(dist[ny][nx] <= next_time){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\ttime_queue.add(next_time);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(n=s.nextInt())>0;){\n\t\t\tm=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tq.add(new int[]{s.nextInt()-1,s.nextInt()-1,1});\n\t\t\t\tint c=0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tif(a[t[1]][t[0]]>t[2]){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\t\tint u=t[0]+dm[t[1]%2][i],v=t[1]+dn[t[1]%2][i];\n\t\t\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m){\n\t\t\t\t\t\t\t\tq.add(new int[]{u,v,t[2]+1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(m=s.nextInt())>0;){\n\t\t\tn=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dm={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dn={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[0]%2][i],v=t[1]+dm[t[0]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint v=s.nextInt()-1,u=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\tint c=1;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\tint u1=t[0]+dn[t[0]%2][i],v1=t[1]+dm[t[0]%2][i];\n\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\ts = scanner.nextInt();\n\t\t\tint[][][] a = new int[s][m][n];\n\t\t\tfor (int i = 0; i < s; i++) {\n\t\t\t\ta[i] = bfs(scanner.nextInt() - 1, scanner.nextInt() - 1);\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tint t = scanner.nextInt();\n\t\t\twhile (t-- > 0) {\n\t\t\t\tint[][] r = bfs(scanner.nextInt() - 1, scanner.nextInt() - 1);\n\t\t\t\tint c = 0;\n\t\t\t\tfor (int x = 0; x < m; x++) {\n\t\t\t\t\tfor (int y = 0; y < n; y++) {\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tfor (int k = 0; k < s; k++) {\n\t\t\t\t\t\t\tif (r[x][y] >= a[k][x][y]) {\n\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, c);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tprivate int[][] bfs(int x, int y) {\n\t\tint[][] r = new int[m][n];\n\t\tboolean[][] v = new boolean[m][n];\n\t\tint step = 1;\n\t\tDeque<List<Integer>> deque = new ArrayDeque<List<Integer>>();\n\t\tv[x][y] = true;\n\t\tdeque.offer(Arrays.asList(x, y));\n\t\twhile (!deque.isEmpty()) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tList<Integer> a = deque.poll();\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tint nx = a.get(0)\n\t\t\t\t\t\t\t+ (a.get(1) % 2 == 1 ? move[j][0] : move2[j][0]);\n\t\t\t\t\tint ny = a.get(1)\n\t\t\t\t\t\t\t+ (a.get(1) % 2 == 1 ? move[j][1] : move2[j][1]);\n\t\t\t\t\tif (0 <= nx && nx < m && 0 <= ny && ny < n && !v[nx][ny]) {\n\t\t\t\t\t\tv[nx][ny] = true;\n\t\t\t\t\t\tr[nx][ny] = step;\n\t\t\t\t\t\tdeque.offer(Arrays.asList(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\treturn r;\n\t}\n\n\tint[][] move = { { 0, -1 }, { 1, -1 }, { -1, 0 }, { 1, 0 }, { 0, 1 },\n\t\t\t{ 1, 1 } };\n\tint[][] move2 = { { -1, -1 }, { 0, -1 }, { -1, 0 }, { 1, 0 }, { -1, 1 },\n\t\t\t{ 0, 1 } };\n\tint m, n, s;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//ライバル社\n\tvoid color(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num){\n\t\t\t\t\t\tif(xy[i+1][j] == 0){\n\t\t\t\t\t\t\txy[i+1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] == 0){\n\t\t\t\t\t\t\txy[i-1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] == 0){\n\t\t\t\t\t\t\txy[i][j+1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] == 0){\n\t\t\t\t\t\t\txy[i][j-1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t}\n\t//自社\n\tint Map(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\tint result = 0;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num*(-1)){\n\t\t\t\t\t\tif(xy[i+1][j] > num+1){\n\t\t\t\t\t\t\txy[i+1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] > num+1){\n\t\t\t\t\t\t\txy[i-1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] > num+1){\n\t\t\t\t\t\t\txy[i][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] > num+1){\n\t\t\t\t\t\t\txy[i][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i = 1;i < n+1;i++){\n\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\tif(xy[i][j] < 0)result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint ans = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m == 0)break;\n\t\t\tint xy[][] = new int [102][102];\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int i = 0;i < num;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\txy[y][x] = 1;\n\t\t\t}\n\t\t\tcolor(xy,n,m);\n\t\t\tint map[][] = new int [102][102];\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int k = 0;k < s;k++){\n\t\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\t\tmap[i][j] = xy[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint xm = sc.nextInt();\n\t\t\t\tint ym = sc.nextInt();\n\t\t\t\tmap[ym][xm] = -1;\n\t\t\t\tif(k == 0){\n\t\t\t\t\tans = Map(map,n,m);\n\t\t\t\t}else{\n\t\t\t\t\tif(ans < Map(map,n,m)){\n\t\t\t\t\t\tans = Map(map,n,m); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DevenEleven {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tfor(int m,n,x,a[][];(n=s.nextInt())>0;){\n\t\t\tm=s.nextInt();\n\t\t\tx=s.nextInt();\n\t\t\ta=new int[n][m];\n\t\t\tDeque<int[]>q=new ArrayDeque<int[]>();\n\t\t\tfor(int i=0;i<x;++i){\n\t\t\t\tint u=s.nextInt()-1,v=s.nextInt()-1;\n\t\t\t\ta[u][v]=1;\n\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t}\n\t\t\tint[][]dn={{-1,-1,-1,0,0,1},{-1,0,0,1,1,1}};\n\t\t\tint[][]dm={{-1,0,1,-1,1,0},{0,-1,1,-1,0,1}};\n\t\t\t\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[]t=q.poll();\n\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\tint u=t[0]+dn[t[1]%2][i],v=t[1]+dm[t[1]%2][i];\n\t\t\t\t\tif(0<=u&&u<n&&0<=v&&v<m&&a[u][v]<1){\n\t\t\t\t\t\tq.add(new int[]{u,v,a[u][v]=t[2]+1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=0;\n\t\t\tfor(x=s.nextInt();x-->0;){\n\t\t\t\tint u=s.nextInt()-1,v=s.nextInt()-1;\n\t\t\t\tif(a[u][v]>1){\n\t\t\t\t\tint[][] tmp = new int[n][];\n\t\t\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\t\t\ttmp[i]=Arrays.copyOf(a[i],m);\n\t\t\t\t\ttmp[u][v]=1;\n\t\t\t\t\tq.add(new int[]{u,v,1});\n\t\t\t\t\tint c=1;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tint[]t=q.poll();\n\t\t\t\t\t\tfor(int i=0;i<6;++i){\n\t\t\t\t\t\t\tint u1=t[0]+dn[t[1]%2][i],v1=t[1]+dm[t[1]%2][i];\n\t\t\t\t\t\t\tif(0<=u1&&u1<n&&0<=v1&&v1<m&&tmp[u1][v1]>t[2]+1){\n\t\t\t\t\t\t\t\t++c;\n\t\t\t\t\t\t\t\tq.add(new int[]{u1,v1,tmp[u1][v1]=t[2]+1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr=r>c?r:c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic final Scanner stdin = new Scanner(System.in);\n\tstatic final int INF = Integer.MAX_VALUE/2, X = 0, Y = 1, D = 2, HEX = 6;\n\tstatic final int dx[][] = { {-1, 0, 1, 0,-1,-1}, {0,  1, 1, 1, 0,-1} };\n\tstatic final int dy[][] = { {-1,-1, 0, 1, 1, 0}, {-1,-1, 0, 1, 1, 0} };\n\tstatic int m, n;\n\tstatic int[][] d;\n\tpublic static void main(String[] args) {\n\t\twhile(true){\n\t\t\tm = stdin.nextInt(); n = stdin.nextInt();\n\t\t\tif((m|n) == 0) break;\n\t\t\td = new int[n][m]; for(int i = 0; i < n; ++i) Arrays.fill(d[i], INF);\n\t\t\tint s = stdin.nextInt();\n\t\t\tfor(int i = 0; i < s; ++i) BFS(stdin.nextInt()-1, stdin.nextInt()-1, true);\n\t\t\tint ans = 0, t = stdin.nextInt();\n\t\t\tfor(int i = 0; i < t; ++i) ans = Math.max(ans, BFS(stdin.nextInt()-1, stdin.nextInt()-1, false));\n\t\t\tSystem.out.println(ans);\t\t\n\t\t}\n\t}\n\tstatic int BFS(int x, int y, boolean calcMinDist){\n\t\tint res = 0;\n\t\tQueue<int[]> q = new LinkedList<int[]>();\n\t\tboolean[][] closed = new boolean[n][m]; for(int i = 0; i < n; ++i) Arrays.fill(closed[i], false); \n\t\tq.add(new int[]{x, y, 0});\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] e = q.poll();\n\t\t\tif(closed[e[Y]][e[X]]) continue;\n\t\t\tclosed[e[Y]][e[X]] = true;\n\t\t\tif(d[e[Y]][e[X]] > e[D]){\n\t\t\t\tif(calcMinDist) d[e[Y]][e[X]] = e[D];\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tfor(int i = 0; i < HEX; ++i){\n\t\t\t\tint nx = e[X] + dx[e[Y]%2][i], ny = e[Y] + dy[e[Y]%2][i];\n\t\t\t\tif(0 <= nx && nx < m && 0 <= ny && ny < n) q.add(new int[]{nx, ny, e[D]+1});\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\t\tn = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint[][][] map = new int[s][n][m];\n\t\t\tfor (int i = 0; i < s; i++) {\n\t\t\t\tint x = scanner.nextInt() - 1;\n\t\t\t\tint y = scanner.nextInt() - 1;\n\t\t\t\tmap[i] = dfs(x, y);\n\t\t\t}\n\t\t\tint v = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\twhile (v-- > 0) {\n\t\t\t\tint c = 0;\n\t\t\t\tint x = scanner.nextInt() - 1;\n\t\t\t\tint y = scanner.nextInt() - 1;\n\t\t\t\tint[][] r = dfs(x, y);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\tboolean flag = true;\n\t\t\t\t\t\tfor (int k = 0; k < s; k++) {\n\t\t\t\t\t\t\tif (map[k][i][j] <= r[i][j]) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, c);\n\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tprivate int[][] dfs(int x, int y) {\n\t\tint[][] tmp = new int[n][m];\n\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\tdeque.offer(new Point(y, x));\n\t\tboolean[][] b = new boolean[n][m];\n\t\tb[y][x] = true;\n\t\tint step = 1;\n\t\twhile (!deque.isEmpty()) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tPoint point = deque.poll();\n\t\t\t\tif (point.y % 2 == 0) {\n\t\t\t\t\tslove(deque, point, move, b, tmp, step);\n\t\t\t\t} else {\n\t\t\t\t\tslove(deque, point, move2, b, tmp, step);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tprivate void slove(Deque<Point> deque, Point point, int[][] move,\n\t\t\tboolean[][] b, int[][] tmp, int step) {\n\t\tfor (int[] a : move) {\n\t\t\tint dy = point.y + a[0];\n\t\t\tint dx = point.x + a[1];\n\t\t\tif (0 <= dy && dy < n && 0 <= dx && dx < m && !b[dy][dx]) {\n\t\t\t\tb[dy][dx] = true;\n\t\t\t\ttmp[dy][dx] = step;\n\t\t\t\tdeque.offer(new Point(dy, dx));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Point {\n\t\tint y;\n\t\tint x;\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t}\n\n\tint[][] move = { { -1, -1 }, { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, -1 },\n\t\t\t{ 1, 0 } };\n\tint[][] move2 = { { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, 0 },\n\t\t\t{ 1, 1 } };\n\n\tint m;\n\tint n;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Deven-Eleven\npublic class Main{\n\n\tstatic int[][] move = {{0,-1},{1,-1},{-1,0},{1,0},{0,1},{1,1}};\n\tstatic int[][] move2 = {{-1,-1},{0,-1},{-1,0},{1,0},{-1,1},{0,1}};\n\tstatic int m, n, s;\n\t\n\tstatic int[][] bfs(int x, int y){\n\t\tint[][] r = new int[m+1][n+1];\n\t\tboolean[][] v = new boolean[m+1][n+1];\n\t\tint step = 1;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tv[x][y] = true;\n\t\tl.add(new int[]{x, y});\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\tint nx = a[0]+(a[1]%2==0?move[k][0]:move2[k][0]);\n\t\t\t\t\tint ny = a[1]+(a[1]%2==0?move[k][1]:move2[k][1]);\n\t\t\t\t\tif(1<=nx&&nx<=m&&1<=ny&&ny<=n&&!v[nx][ny]){\n\t\t\t\t\t\tv[nx][ny] = true;\n\t\t\t\t\t\tr[nx][ny] = step;\n\t\t\t\t\t\tnext.add(new int[]{nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t\tl = next;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = sc.nextInt();\n\t\t\tif(m==0)break;\n\t\t\tn = sc.nextInt();\n\t\t\ts = sc.nextInt();\n\t\t\tint[][][] a = new int[s][m+1][n+1];\n\t\t\tfor(int i=0;i<s;i++)a[i]=bfs(sc.nextInt(), sc.nextInt());\n\t\t\tint max = 0;\n\t\t\tint t = sc.nextInt();\n\t\t\twhile(t--!=0){\n\t\t\t\tint[][] r = bfs(sc.nextInt(), sc.nextInt());\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int x=1;x<=m;x++){\n\t\t\t\t\tfor(int y=1;y<=n;y++){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\t\tif(r[x][y]>=a[k][x][y])f=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f)c++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, c);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//ライバル社\n\tvoid color(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num){\n\t\t\t\t\t\tif(xy[i+1][j] == 0){\n\t\t\t\t\t\t\txy[i+1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] == 0){\n\t\t\t\t\t\t\txy[i-1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] == 0){\n\t\t\t\t\t\t\txy[i][j+1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] == 0){\n\t\t\t\t\t\t\txy[i][j-1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t}\n\t//自社\n\tint Map(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\tint result = 0;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num*(-1)){\n\t\t\t\t\t\tif(xy[i+1][j] > num+1){\n\t\t\t\t\t\t\txy[i+1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] > num+1){\n\t\t\t\t\t\t\txy[i-1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] > num+1){\n\t\t\t\t\t\t\txy[i][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] > num+1){\n\t\t\t\t\t\t\txy[i][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i = 1;i < n+1;i++){\n\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\tif(xy[i][j] < 0)result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint ans = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m == 0)break;\n\t\t\tint xy[][] = new int [n+2][m+2];\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int i = 0;i < num;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\txy[y][x] = 1;\n\t\t\t}\n\t\t\tcolor(xy,n,m);\n\t\t\tint map[][] = new int [n+2][n+2];\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int k = 0;k < s;k++){\n\t\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\t\tmap[i][j] = xy[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint xm = sc.nextInt();\n\t\t\t\tint ym = sc.nextInt();\n\t\t\t\tmap[ym][xm] = -1;\n\t\t\t\tif(k == 0){\n\t\t\t\t\tans = Map(map,n,m);\n\t\t\t\t}else{\n\t\t\t\t\tif(ans < Map(map,n,m)){\n\t\t\t\t\t\tans = Map(map,n,m); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//ライバル社\n\tvoid color(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num){\n\t\t\t\t\t\tif(xy[i+1][j] == 0){\n\t\t\t\t\t\t\txy[i+1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] == 0){\n\t\t\t\t\t\t\txy[i-1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] == 0){\n\t\t\t\t\t\t\txy[i][j+1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] == 0){\n\t\t\t\t\t\t\txy[i][j-1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t}\n\t//自社\n\tint Map(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\tint result = 0;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num*(-1)){\n\t\t\t\t\t\tif(xy[i+1][j] > num+1){\n\t\t\t\t\t\t\txy[i+1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] > num+1){\n\t\t\t\t\t\t\txy[i-1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] > num+1){\n\t\t\t\t\t\t\txy[i][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] > num+1){\n\t\t\t\t\t\t\txy[i][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i = 1;i < n+1;i++){\n\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\tif(xy[i][j] < 0)result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint ans = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m == 0)break;\n\t\t\tint xy[][] = new int [m+2][n+2];\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int i = 0;i < num;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\txy[y][x] = 1;\n\t\t\t}\n\t\t\tcolor(xy,n,m);\n\t\t\tint map[][] = new int [m+2][n+2];\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int k = 0;k < s;k++){\n\t\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\t\tmap[i][j] = xy[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint xm = sc.nextInt();\n\t\t\t\tint ym = sc.nextInt();\n\t\t\t\tmap[ym][xm] = -1;\n\t\t\t\tif(k == 0){\n\t\t\t\t\tans = Map(map,n,m);\n\t\t\t\t}else{\n\t\t\t\t\tif(ans < Map(map,n,m)){\n\t\t\t\t\t\tans = Map(map,n,m); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//ライバル社\n\tvoid color(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < m+1;i++){\n\t\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\t\tif(xy[i][j] == num){\n\t\t\t\t\t\tif(xy[i+1][j] == 0){\n\t\t\t\t\t\t\txy[i+1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] == 0){\n\t\t\t\t\t\t\txy[i-1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] == 0){\n\t\t\t\t\t\t\txy[i][j+1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] == 0){\n\t\t\t\t\t\t\txy[i][j-1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t}\n\t//自社\n\tint Map(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\tint result = 0;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < m+1;i++){\n\t\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\t\tif(xy[i][j] == num*(-1)){\n\t\t\t\t\t\tif(xy[i+1][j] > num+1){\n\t\t\t\t\t\t\txy[i+1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] > num+1){\n\t\t\t\t\t\t\txy[i-1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] > num+1){\n\t\t\t\t\t\t\txy[i][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] > num+1){\n\t\t\t\t\t\t\txy[i][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i = 1;i < m+1;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tif(xy[i][j] < 0)result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint ans = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m == 0)break;\n\t\t\tint xy[][] = new int [m+2][n+2];\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int i = 0;i < num;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\txy[y][x] = 1;\n\t\t\t}\n\t\t\tcolor(xy,n,m);\n\t\t\tint map[][] = new int [m+2][n+2];\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int k = 0;k < s;k++){\n\t\t\t\tfor(int i = 1;i < m+1;i++){\n\t\t\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\t\t\tmap[i][j] = xy[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint xm = sc.nextInt();\n\t\t\t\tint ym = sc.nextInt();\n\t\t\t\tmap[ym][xm] = -1;\n\t\t\t\tif(k == 0){\n\t\t\t\t\tans = Map(map,n,m);\n\t\t\t\t}else{\n\t\t\t\t\tif(ans < Map(map,n,m)){\n\t\t\t\t\t\tans = Map(map,n,m); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t//1251\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 24;\n\tint [][] field;\n\tint [][] vx = {{0,1,0,-1,-1,-1},{0,1,0,-1,1,1}};\n\tint [][] vy = {{1,0,-1,0,1,-1 },{1,0,-1,0,-1,1}};\n\tint n,m;\n\t\n\tclass C{\n\t\tint x,y, step;\n\n\t\tpublic C(int x, int y, int step) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\twhile(true){\n\t\t\tm = sc.nextInt();\n\t\t\tif(m== 0)break;\n\t\t\tn = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tfield = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(field[i], INF);\n\t\t\t}\n\t\t\tfor(int i = 0; i < s; i++){\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tbfs(x,y);\n\t\t\t}\n\t\t\tint t = sc.nextInt();\n\t\t\tint [][] work = deepcopy(field);\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < t; i++){\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tfield = deepcopy(work);\n\t\t\t\tint res = bfs(x,y);\n\t\t\t\tmax = Math.max(max, res);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tprivate int[][] deepcopy(int[][] field2) {\n\t\tint [][] res = new int[n][m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tres[i][j] = field2[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int bfs(int x, int y) {\n\t\tLinkedList<C> open = new LinkedList<Main.C>();\n\t\topen.add(new C(x, y, 0));\n\t\tfield[y][x] = 0;\n\t\tint ans = 1;\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.poll();\n\t\t\tint ind = now.y % 2;\n\t\t\tfor(int i = 0; i < vx[ind].length; i++){\n\t\t\t\tint xx = now.x + vx[ind][i];\n\t\t\t\tint yy = now.y + vy[ind][i];\n\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\tif(field[yy][xx] <= now.step + 1) continue;\n\t\t\t\topen.add(new C(xx, yy, now.step + 1));\n\t\t\t\tfield[yy][xx] = now.step + 1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0<= xx && xx < m && 0<= yy && yy < n){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//ライバル社\n\tvoid color(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num){\n\t\t\t\t\t\tif(xy[i+1][j] == 0){\n\t\t\t\t\t\t\txy[i+1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] == 0){\n\t\t\t\t\t\t\txy[i-1][j] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] == 0){\n\t\t\t\t\t\t\txy[i][j+1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] == 0){\n\t\t\t\t\t\t\txy[i][j-1] = num + 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] == 0){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num + 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t}\n\t//自社\n\tint Map(int xy[][],int n,int m){\n\t\tint num = 1;\n\t\tint result = 0;\n\t\twhile(true){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\tif(xy[i][j] == num*(-1)){\n\t\t\t\t\t\tif(xy[i+1][j] > num+1){\n\t\t\t\t\t\t\txy[i+1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i-1][j] > num+1){\n\t\t\t\t\t\t\txy[i-1][j] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j+1] > num+1){\n\t\t\t\t\t\t\txy[i][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xy[i][j-1] > num+1){\n\t\t\t\t\t\t\txy[i][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t\t\tif(xy[i+1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j+1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j+1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(i % 2 == 1){\n\t\t\t\t\t\t\tif(xy[i+1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i+1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xy[i-1][j-1] > num+1){\n\t\t\t\t\t\t\t\txy[i-1][j-1] = num*(-1) - 1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)break;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i = 1;i < n+1;i++){\n\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\tif(xy[i][j] < 0)result++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint ans = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m == 0)break;\n\t\t\tint xy[][] = new int [n+2][m+2];\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int i = 0;i < num;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\txy[y][x] = 1;\n\t\t\t}\n\t\t\tcolor(xy,n,m);\n\t\t\tint map[][] = new int [n+2][n+2];\n\t\t\tint s = sc.nextInt();\n\t\t\tfor(int k = 0;k < s;k++){\n\t\t\t\tfor(int i = 1;i < n+1;i++){\n\t\t\t\t\tfor(int j = 1;j < m+1;j++){\n\t\t\t\t\t\tmap[i][j] = xy[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint xm = sc.nextInt();\n\t\t\t\tint ym = sc.nextInt();\n\t\t\t\tmap[ym][xm] = -1;\n\t\t\t\tif(k == 0){\n\t\t\t\t\tans = Map(map,n,m);\n\t\t\t\t}else{\n\t\t\t\t\tif(ans < Map(map,n,m)){\n\t\t\t\t\t\tans = Map(map,n,m); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0193\n{\n    public class Program\n\n    {\n\n        public static int[] di = new int[] { -1, -1, 0, 0, 1, 1 };\n        public static int[,] dj = new int[,] { { -1, 0, -1, 1, -1, 0 }, { 0, 1, -1, 1, 0, 1 } };\n        public static int[,] map;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nm = RIntAr();\n                if (nm.Sum() == 0) break;\n\n                map = new int[nm[0], nm[1]];\n                for (int i = 0 ; i < map.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < map.GetLength(1) ; j++)\n                    {\n                        map[i, j] = int.MaxValue;\n                    }\n                }\n\n                int s = RInt();\n                for (int k = 0 ; k < s ; k++)\n                {\n                    int[] items = RIntAr();\n                    BFS(items[1] - 1, items[0] - 1);\n                }\n\n                int[,] defaultMap = new int[nm[0], nm[1]];\n                Array.Copy(map, defaultMap, map.Length);\n\n                int t = RInt();\n                int max = 0;\n                for (int k = 0 ; k < t ; k++)\n                {\n                    Array.Copy(defaultMap, map, map.Length);\n                    int[] items = RIntAr();\n                    max = Math.Max(max, (BFS(items[1] - 1, items[0] - 1) + 1));          \n                }\n\n                Console.WriteLine(max);\n            }\n        }\n\n\n        private static int BFS(int sI, int sJ)\n        {\n\n            int cnt = 0;\n\n            Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n            q.Enqueue(new Tuple<int, int>(sI, sJ));\n            map[sI, sJ] = 0;\n\n            while (q.Count > 0)\n            {\n                Tuple<int, int> point = q.Dequeue();\n                for (int i = 0 ; i < di.Length ; i++)\n                {\n                    int nI = point.Item1 + di[i];\n                    int nJ = point.Item2 + dj[point.Item1 % 2, i];\n\n                    if (InArea(nI, nJ) && map[point.Item1, point.Item2] + 1 < map[nI, nJ])\n                    {\n                        map[nI, nJ] = map[point.Item1, point.Item2] + 1;\n                        q.Enqueue(new Tuple<int, int>(nI, nJ));\n                        cnt++;\n                    }\n                }\n            }\n            return cnt;\n        }\n\n        private static bool InArea(int nI, int nJ)\n        {\n            return 0 <= nI && nI < map.GetLength(0) && 0 <= nJ && nJ < map.GetLength(1);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0193\n{\n    public class Program\n\n    {\n\n        public static int[] di = new int[] { -1, -1, 0, 0, 1, 1 };\n        public static int[,] dj = new int[,] { { -1, 0, -1, 1, -1, 0 }, { 0, 1, -1, 1, 0, 1 } };\n        public static int[,] map;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nm = RIntAr();\n                if (nm.Sum() == 0) break;\n\n                map = new int[nm[0], nm[1]];\n                for (int i = 0 ; i < map.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < map.GetLength(1) ; j++)\n                    {\n                        map[i, j] = int.MaxValue;\n                    }\n                }\n\n                int s = RInt();\n                for (int k = 0 ; k < s ; k++)\n                {\n                    int[] items = RIntAr();\n                    BFS(items[1] - 1, items[0] - 1);\n                }\n\n                int[,] defaultMap = new int[nm[0], nm[1]];\n                Array.Copy(map, defaultMap, map.Length);\n\n                int t = RInt();\n                int max = 0;\n                for (int k = 0 ; k < t ; k++)\n                {\n                    Array.Copy(defaultMap, map, map.Length);\n                    int[] items = RIntAr();\n                    max = Math.Max(max, (BFS(items[1] - 1, items[0] - 1) + 1);          \n                }\n\n                Console.WriteLine(max);\n            }\n        }\n\n\n        private static int BFS(int sI, int sJ)\n        {\n\n            int cnt = 0;\n\n            Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n            q.Enqueue(new Tuple<int, int>(sI, sJ));\n            map[sI, sJ] = 0;\n\n            while (q.Count > 0)\n            {\n                Tuple<int, int> point = q.Dequeue();\n                for (int i = 0 ; i < di.Length ; i++)\n                {\n                    int nI = point.Item1 + di[i];\n                    int nJ = point.Item2 + dj[point.Item1 % 2, i];\n\n                    if (InArea(nI, nJ) && map[point.Item1, point.Item2] + 1 < map[nI, nJ])\n                    {\n                        map[nI, nJ] = map[point.Item1, point.Item2] + 1;\n                        q.Enqueue(new Tuple<int, int>(nI, nJ));\n                        cnt++;\n                    }\n                }\n            }\n            return cnt;\n        }\n\n        private static bool InArea(int nI, int nJ)\n        {\n            return 0 <= nI && nI < map.GetLength(0) && 0 <= nJ && nJ < map.GetLength(1);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0193\n{\n    public class Program\n\n    {\n\n        public static int[] di = new int[] { -1, -1, 0, 0, 1, 1 };\n        public static int[,] dj = new int[,] { { -1, 0, -1, 1, -1, 0 }, { 0, 1, -1, 1, 0, 1 } };\n        public static int[,] map;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nm = RIntAr();\n                if (nm.Sum() == 0) break;\n\n                map = new int[nm[1], nm[0]];\n                for (int i = 0 ; i < map.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < map.GetLength(1) ; j++)\n                    {\n                        map[i, j] = int.MaxValue;\n                    }\n                }\n\n                int s = RInt();\n                for (int k = 0 ; k < s ; k++)\n                {\n                    int[] items = RIntAr();\n                    BFS(items[1] - 1, items[0] - 1);\n                }\n\n                int[,] defaultMap = new int[nm[1], nm[0]];\n                Array.Copy(map, defaultMap, map.Length);\n\n                int t = RInt();\n                int max = 0;\n                for (int k = 0 ; k < t ; k++)\n                {\n                    Array.Copy(defaultMap, map, map.Length);\n                    int[] items = RIntAr();\n                    max = Math.Max(max, (BFS(items[1] - 1, items[0] - 1) + 1));          \n                }\n\n                Console.WriteLine(max);\n            }\n        }\n\n\n        private static int BFS(int sI, int sJ)\n        {\n\n            int cnt = 0;\n\n            Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n            q.Enqueue(new Tuple<int, int>(sI, sJ));\n            map[sI, sJ] = 0;\n\n            while (q.Count > 0)\n            {\n                Tuple<int, int> point = q.Dequeue();\n                for (int i = 0 ; i < di.Length ; i++)\n                {\n                    int nI = point.Item1 + di[i];\n                    int nJ = point.Item2 + dj[point.Item1 % 2, i];\n\n                    if (InArea(nI, nJ) && map[point.Item1, point.Item2] + 1 < map[nI, nJ])\n                    {\n                        map[nI, nJ] = map[point.Item1, point.Item2] + 1;\n                        q.Enqueue(new Tuple<int, int>(nI, nJ));\n                        cnt++;\n                    }\n                }\n            }\n            return cnt;\n        }\n\n        private static bool InArea(int nI, int nJ)\n        {\n            return 0 <= nI && nI < map.GetLength(0) && 0 <= nJ && nJ < map.GetLength(1);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 31) - 1\n\nNEIGHBORS = [\n  [[-1, -1], [ 0, -1], [-1,  0], [ 1,  0], [-1,  1], [ 0,  1]],\n  [[ 0, -1], [ 1, -1], [-1,  0], [ 1,  0], [ 0,  1], [ 1,  1]]\n]\n\n### global variables\n\n### subroutines\n\ndef gen_dists(x, y, m, n)\n  dists = n.times.map{m.times.map{MAX_INT}}\n  dists[y][x] = 0\n  queue = [[x, y]]\n\n  while ! queue.empty?\n    x0, y0 = queue.shift\n    d0 = dists[y0][x0] + 1\n\n    for nxy in NEIGHBORS[y0 & 1]\n      dx, dy = nxy\n      x1 = x0 + dx\n      y1 = y0 + dy\n      if x1 >= 0 && x1 < m && y1 >= 0 && y1 < m && dists[y1][x1] > d0\n        dists[y1][x1] = d0\n        queue << [x1, y1]\n      end\n    end\n  end\n\n  dists\nend\n\n### main\n\nwhile true\n  m, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if m == 0 && n == 0\n\n  s = gets.strip.to_i\n\n  min_dists = n.times.map{m.times.map{MAX_INT}}\n\n  for i in (0...s)\n    x0, y0 = gets.strip.split(' ').map{|s| s.to_i - 1}\n    dists = gen_dists(x0, y0, m, n)\n\n    for y in (0...n)\n      for x in (0...m)\n        min_dists[y][x] = dists[y][x] if min_dists[y][x] > dists[y][x]\n      end\n    end\n  end\n  #p min_dists\n\n  t = gets.strip.to_i\n  max_count = 0\n\n  t.times.each do\n    x0, y0 = gets.strip.split(' ').map{|s| s.to_i - 1}\n    ndists = gen_dists(x0, y0, m, n)\n    count = 0\n\n    for y in (0...n)\n      for x in (0...m)\n        count += 1 if ndists[y][x] < min_dists[y][x]\n      end\n    end\n\n    max_count = count if max_count < count\n  end\n\n  puts max_count\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 31) - 1\n\nNEIGHBORS = [\n  [[-1, -1], [ 0, -1], [-1,  0], [ 1,  0], [-1,  1], [ 0,  1]],\n  [[ 0, -1], [ 1, -1], [-1,  0], [ 1,  0], [ 0,  1], [ 1,  1]]\n]\n\n### global variables\n\n### subroutines\n\ndef gen_dists(x, y, m, n)\n  dists = n.times.map{m.times.map{MAX_INT}}\n  dists[y][x] = 0\n  queue = [[x, y]]\n\n  while ! queue.empty?\n    x0, y0 = queue.shift\n    d0 = dists[y0][x0] + 1\n\n    for nxy in NEIGHBORS[y0 & 1]\n      dx, dy = nxy\n      x1 = x0 + dx\n      y1 = y0 + dy\n      if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && dists[y1][x1] > d0\n        dists[y1][x1] = d0\n        queue << [x1, y1]\n      end\n    end\n  end\n\n  dists\nend\n\n### main\n\nwhile true\n  m, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if m == 0 && n == 0\n\n  s = gets.strip.to_i\n\n  min_dists = n.times.map{m.times.map{MAX_INT}}\n\n  for i in (0...s)\n    x0, y0 = gets.strip.split(' ').map{|s| s.to_i - 1}\n    dists = gen_dists(x0, y0, m, n)\n\n    for y in (0...n)\n      for x in (0...m)\n        min_dists[y][x] = dists[y][x] if min_dists[y][x] > dists[y][x]\n      end\n    end\n  end\n  #p min_dists\n\n  t = gets.strip.to_i\n  max_count = 0\n\n  t.times.each do\n    x0, y0 = gets.strip.split(' ').map{|s| s.to_i - 1}\n    ndists = gen_dists(x0, y0, m, n)\n    count = 0\n\n    for y in (0...n)\n      for x in (0...m)\n        count += 1 if ndists[y][x] < min_dists[y][x]\n      end\n    end\n\n    max_count = count if max_count < count\n  end\n\n  puts max_count\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nwhile(m,n=g)[0]>0\na=(1..g[0]).map{|i|g<<i}\np (1..g[0]).map{d=a+[c=g<<11]\ns=0\n(1..n).map{|j|(1..m).map{|i|d.min_by{|x,y,t|z=(y-j).abs\n[z+[(x-i).abs-(z+(i<x ?1-j%2:j%2))/2,0].max,t]}==c&&s+=1}}\ns}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nwhile(m,n=g)[0]>0\na=(1..g[0]).map{|i|g<<i}\np (1..g[0]).map{d=a+[c=g<<11]\n(0..m*n-1).count{|k|i=k/n+1;j=k%n+1\nd.min_by{|x,y,t|z=(y-j).abs\n[z+[(x-i).abs-(z+(i<x ?1-j%2:j%2))/2,0].max,t]}==c}}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nwhile(m,n=g)[0]>0\na=(1..g[0]).map{|i|g+[i]}\nb=(1..g[0]).map{g+[11]}\np b.map{|c|d=a+[c]\ns=0\n(1..n).map{|j|(1..m).map{|i|d.min_by{|x,y,t|z=(y-j).abs\n[z+[(x-i).abs-(z+(i<x ?1-j%2:j%2))/2,0].max,t]}==c&&s+=1}}\ns}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nwhile(m,n=g)[0]>0\na=(1..g[0]).map{|i|g<<i}\np (1..g[0]).map{d=a+[c=g<<11]\n(0..m*n).count{|k|i=k/n+1;j=k%n+1\nd.min_by{|x,y,t|z=(y-j).abs\n[z+[(x-i).abs-(z+(i<x ?1-j%2:j%2))/2,0].max,t]}==c}}.max\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nconst INF = 0x7FFFFFFF\n\nvar (\n\tdirection1 = [][]int{ // 奇数段目の移動方向\n\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, -1}, {1, 1},\n\t}\n\tdirection2 = [][]int{ // 偶数段目の移動方向\n\t\t{-1, -1}, {0, -1}, {1, 0}, {0, 1}, {-1, 1}, {-1, 0},\n\t}\n)\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\tm, _ := strconv.Atoi(buf[0])\n\t\tn, _ := strconv.Atoi(buf[1])\n\t\tif m == 0 && n == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// initialize district_map\n\t\t/*\n\t\t\tdistrict_map = [\n\t\t\t\t[-1, -1,  -1,  -1,  -1]\n\t\t\t\t[-1, INF, INF, INF, -1]\n\t\t\t\t[-1, INF, INF, INF, -1]\n\t\t\t\t[-1, INF, INF, INF, -1]\n\t\t\t\t[-1, INF, INF, INF, -1]\n\t\t\t\t[-1, -1,  -1,  -1,  -1]\n\t\t\t]\n\t\t*/\n\t\tdistrict_map := make([][]int, n+2)\n\t\tfor i := range district_map {\n\t\t\tdistrict_map[i] = make([]int, m+2)\n\t\t}\n\t\ttmp1 := make([]int, m+2)\n\t\tfor i := range tmp1 {\n\t\t\ttmp1[i] = -1\n\t\t}\n\t\tdistrict_map[0] = tmp1\n\t\tdistrict_map[n+1] = tmp1\n\t\tfor i := 1; i < n+1; i++ {\n\t\t\tdistrict_map[i] = make([]int, m+2)\n\t\t\tdistrict_map[i][0] = -1\n\t\t\tdistrict_map[i][m+1] = -1\n\t\t\tfor j := 1; j < m+1; j++ {\n\t\t\t\tdistrict_map[i][j] = INF\n\t\t\t}\n\t\t}\n\n\t\tscanner.Scan()\n\t\ts, _ := strconv.Atoi(scanner.Text())\n\t\tfor i := 0; i < s; i++ {\n\t\t\tscanner.Scan()\n\t\t\tbuf_ := strings.Split(scanner.Text(), \" \")\n\t\t\tx, _ := strconv.Atoi(buf_[0])\n\t\t\ty, _ := strconv.Atoi(buf_[1])\n\t\t\tSearch(Point{x, y}, district_map, m, n)\n\t\t}\n\t\tans := 0\n\t\tscanner.Scan()\n\t\tt, _ := strconv.Atoi(scanner.Text())\n\t\tfor i := 0; i < t; i++ {\n\t\t\tscanner.Scan()\n\t\t\tbuf__ := strings.Split(scanner.Text(), \" \")\n\t\t\tx, _ := strconv.Atoi(buf__[0])\n\t\t\ty, _ := strconv.Atoi(buf__[1])\n\t\t\tz := Count(Point{x, y}, district_map, m, n)\n\t\t\tans = max(ans, z)\n\t\t}\n\t\tfmt.Println(ans)\n\t}\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\ntype Point struct {\n\tx, y int\n}\n\ntype Entry struct {\n\thop   int\n\tpoint Point\n}\n\nfunc Search(p Point, mp [][]int, m, n int) {\n\tque := make([]Entry, 0)\n\tque = append(que, Entry{0, p})\n\tcheck := make([][]bool, n+2)\n\tfor i := range check {\n\t\tcheck[i] = make([]bool, m+2)\n\t}\n\tcheck[p.y][p.x] = true\n\tmp[p.y][p.x] = 0\n\tvar direction [][]int\n\tfor len(que) > 0 {\n\t\ttmp := que[0]\n\t\tque = que[1:]\n\t\tdist, point := tmp.hop, tmp.point\n\t\tif point.y%2 == 0 {\n\t\t\tdirection = direction1\n\t\t} else {\n\t\t\tdirection = direction2\n\t\t}\n\t\tfor _, d := range direction {\n\t\t\tnx, ny := point.x+d[0], point.y+d[1]\n\t\t\tif !check[ny][nx] && mp[ny][nx] != -1 {\n\t\t\t\tcheck[ny][nx] = true\n\t\t\t\tif mp[ny][nx] > dist+1 {\n\t\t\t\t\tmp[ny][nx] = dist + 1\n\t\t\t\t}\n\t\t\t\tque = append(que, Entry{dist + 1, Point{nx, ny}})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Count(p Point, mp [][]int, m, n int) int {\n\tque := make([]Entry, 0)\n\tque = append(que, Entry{0, p})\n\tcheck := make([][]bool, n+2)\n\tfor i := range check {\n\t\tcheck[i] = make([]bool, m+2)\n\t}\n\tcheck[p.y][p.x] = true\n\tans := 1\n\tvar direction [][]int\n\tfor len(que) > 0 {\n\t\ttmp := que[0]\n\t\tque = que[1:]\n\t\tdist, point := tmp.hop, tmp.point\n\t\tif point.y%2 == 0 {\n\t\t\tdirection = direction1\n\t\t} else {\n\t\t\tdirection = direction2\n\t\t}\n\t\tfor _, d := range direction {\n\t\t\tnx, ny := point.x+d[0], point.y+d[1]\n\t\t\tif !check[ny][nx] && mp[ny][nx] != -1 {\n\t\t\t\tcheck[ny][nx] = true\n\t\t\t\tif mp[ny][nx] > dist+1 {\n\t\t\t\t\tans++\n\t\t\t\t}\n\t\t\t\tque = append(que, Entry{dist + 1, Point{nx, ny}})\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.container;\nimport std.functional;\nimport std.algorithm;\n\nstruct P {\n    int y, x;\n    int t;\n}\n\nvoid dump(int[][] x) {\n    foreach (l; x) {\n        l.writeln;\n    }\n    writeln;\n}\n\nvoid calcDist(int[][] F, int y, int x) {\n    auto Y = F.length,\n         X = F[0].length;\n    foreach (i; 0 .. Y) \n        foreach (j; 0 .. X)\n            F[i][j] = int.max;\n    static const oD = [\n        [-1, 0], [-1, 1],\n        [0, -1], [0, 1],\n        [1, 0], [1, 1]\n    ];\n    static const eD = [\n        [-1, -1], [-1, 0],\n        [0, -1], [0, 1],\n        [1, -1], [1, 0]\n    ];\n    DList!P Q;\n    Q.insert(P(y, x, 0)); \n    F[y][x] = 0;\n    while (!Q.empty) {\n        P cur = Q.front; Q.removeFront;\n        foreach (d; (cur.y % 2 == 0 ? eD : oD)) {\n            int ny = cur.y + d[0],\n                nx = cur.x + d[1];\n            if (ny < 0 || ny >= Y) continue;\n            if (nx < 0 || nx >= X) continue;\n            if (F[ny][nx] <= cur.t) continue;\n            F[ny][nx] = cur.t + 1;\n            Q.insert(P(ny, nx, cur.t + 1));\n        }\n    }\n}\n\nvoid main() {\n    int m, n;\n    int s, t;\n    while (readf(\"%d\", &m), m) {\n        readf(\" %d\\n\", &n);\n        readf(\"%d\\n\", &s);\n        auto S = new int[][][](s, n, m);\n        foreach (i; 0 .. s) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            y--; x--;\n            calcDist(S[i], y, x);\n        }\n        readf(\"%d\\n\", &t);\n        auto T = new int[][](n, m);\n        int[] R = new int[t];\n        int count() {\n            int c = 0;\n            foreach (i; 0 .. n) {\n                foreach (j; 0 .. m) {\n                    foreach (k; 0 .. s) {\n                        if (T[i][j] >= S[k][i][j]) \n                            goto next;\n                    }\n                    c++;\nnext:;\n                }\n            }\n            return c;\n        }\n        foreach (i; 0 .. t) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            y--; x--;\n            calcDist(T, y, x);\n            R[i] = count;\n        }\n        R.reduce!max.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.container;\nimport std.functional;\nimport std.algorithm;\n\nstruct P {\n    int y, x;\n    int t;\n}\n\nvoid dump(int[][] x) {\n    foreach (l; x) {\n        l.writeln;\n    }\n    writeln;\n}\n\nvoid calcDist(int[][] F, int y, int x) {\n    auto Y = F.length,\n         X = F[0].length;\n    foreach (i; 0 .. Y) \n        foreach (j; 0 .. X)\n            F[i][j] = int.max;\n    static const oD = [\n        [-1, 0], [-1, 1],\n        [0, -1], [0, 1],\n        [1, 0], [1, 1]\n    ];\n    static const eD = [\n        [-1, -1], [-1, 0],\n        [0, -1], [0, 1],\n        [1, -1], [1, 0]\n    ];\n    DList!P Q;\n    Q.insert(P(y, x, 0)); \n    F[y][x] = 0;\n    while (!Q.empty) {\n        P cur = Q.front; Q.removeFront;\n        foreach (d; (cur.y % 2 == 0 ? eD : oD)) {\n            int ny = cur.y + d[0],\n                nx = cur.x + d[1];\n            if (ny < 0 || ny >= Y) continue;\n            if (nx < 0 || nx >= X) continue;\n            if (F[ny][nx] <= cur.t + 1) continue;\n            F[ny][nx] = cur.t + 1;\n            Q.insert(P(ny, nx, cur.t + 1));\n        }\n    }\n}\n\nvoid main() {\n    int m, n;\n    int s, t;\n    while (readf(\"%d\", &m), m) {\n        readf(\" %d\\n\", &n);\n        readf(\"%d\\n\", &s);\n        auto S = new int[][][](s, n, m);\n        foreach (i; 0 .. s) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            y--; x--;\n            calcDist(S[i], y, x);\n        }\n        readf(\"%d\\n\", &t);\n        auto T = new int[][](n, m);\n        int[] R = new int[t];\n        int count() {\n            int c = 0;\n            foreach (i; 0 .. n) {\n                foreach (j; 0 .. m) {\n                    foreach (k; 0 .. s) {\n                        if (T[i][j] >= S[k][i][j]) \n                            goto next;\n                    }\n                    c++;\nnext:;\n                }\n            }\n            return c;\n        }\n        foreach (i; 0 .. t) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            y--; x--;\n            calcDist(T, y, x);\n            R[i] = count;\n        }\n        R.reduce!max.writeln;\n        delete(S);\n        delete(T);\n        delete(R);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.container;\nimport std.functional;\nimport std.algorithm;\n\nstruct P {\n    int y, x;\n    int t;\n}\n\nvoid dump(int[][] x) {\n    foreach (l; x) {\n        l.writeln;\n    }\n    writeln;\n}\n\nvoid calcDist(int[][] F, int y, int x) {\n    auto Y = F.length,\n         X = F[0].length;\n    foreach (i; 0 .. Y) \n        foreach (j; 0 .. X)\n            F[i][j] = int.max;\n    static const oD = [\n        [-1, 0], [-1, 1],\n        [0, -1], [0, 1],\n        [1, 0], [1, 1]\n    ];\n    static const eD = [\n        [-1, -1], [-1, 0],\n        [0, -1], [0, 1],\n        [1, -1], [1, 0]\n    ];\n    DList!P Q;\n    Q.insert(P(y, x, 0)); \n    F[y][x] = 0;\n    while (!Q.empty) {\n        P cur = Q.front; Q.removeFront;\n        foreach (d; (cur.y % 2 == 0 ? eD : oD)) {\n            int ny = cur.y + d[0],\n                nx = cur.x + d[1];\n            if (ny < 0 || ny >= Y) continue;\n            if (nx < 0 || nx >= X) continue;\n            if (F[ny][nx] <= cur.t) continue;\n            F[ny][nx] = cur.t + 1;\n            Q.insert(P(ny, nx, cur.t + 1));\n        }\n    }\n}\n\nvoid main() {\n    int m, n;\n    int s, t;\n    while (readf(\"%d\", &m), m) {\n        readf(\" %d\\n\", &n);\n        readf(\"%d\\n\", &s);\n        auto S = new int[][][](s, n, m);\n        foreach (i; 0 .. s) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            y--; x--;\n            calcDist(S[i], y, x);\n        }\n        readf(\"%d\\n\", &t);\n        auto T = new int[][](n, m);\n        int[] R = new int[t];\n        int count() {\n            int c = 0;\n            foreach (i; 0 .. n) {\n                foreach (j; 0 .. m) {\n                    foreach (k; 0 .. s) {\n                        if (T[i][j] >= S[k][i][j]) \n                            goto next;\n                    }\n                    c++;\nnext:;\n                }\n            }\n            return c;\n        }\n        foreach (i; 0 .. t) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            y--; x--;\n            calcDist(T, y, x);\n            R[i] = count;\n        }\n        R.reduce!max.writeln;\n        delete(S);\n        delete(T);\n        delete(R);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef generate_next_hexes(x, y):\n    hexes = list()\n    hexes.append((x, y - 1))\n    hexes.append((x, y + 1))\n    hexes.append((x - 1, y))\n    hexes.append((x + 1, y))\n    if y % 2:\n        hexes.append((x - 1, y - 1))\n        hexes.append((x - 1, y + 1))\n    else:\n        hexes.append((x + 1, y - 1))\n        hexes.append((x + 1, y + 1))\n    return hexes\n\ndef update_map(hex_map, hexes):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if (1 <= x <= m and 1 <= y <= n\n                    and (pos not in hex_map or distance < hex_map[pos])):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\nwhile True:\n    (m, n) = [int(i) for i in sys.stdin.readline().split()]\n    if m == n == 0:\n        break\n\n    s = int(sys.stdin.readline())\n    stores = []\n    for i in range(s):\n        cord = [int(j) for j in sys.stdin.readline().split()]\n        stores.append(tuple(cord))\n    hex_map = {}\n    update_map(hex_map, stores)\n\n    t = int(sys.stdin.readline())\n    candidates = []\n    for i in range(t):\n        cord = [int(j) for j in sys.stdin.readline().split()]\n        candidates.append(tuple(cord))\n\n    # search max num\n    max_num_blocks = 0\n    for candidate in candidates:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate])\n        max_num_blocks = max(max_num_blocks, num_blocks)\n\n    print(max_num_blocks)"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    m, n = map(int, data.split())\n    if m == 0:\n        break\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    hexes = [(a, b) for (a, b) in hexes if 1 <= b <= m and 1 <= b <= n]\n    return hexes\n\ndef update_map(hex_map, hexes):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            if pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(pos[0], pos[1])\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\nwhile True:\n    (m, n) = [int(i) for i in sys.stdin.readline().split()]\n    if m == n == 0:\n        break\n\n    s = int(sys.stdin.readline())\n    stores = []\n    for i in range(s):\n        pos = [int(j) for j in sys.stdin.readline().split()]\n        stores.append(tuple(pos))\n    hex_map = {}\n    update_map(hex_map, stores)\n\n    t = int(sys.stdin.readline())\n    candidates = []\n    for i in range(t):\n        pos = [int(j) for j in sys.stdin.readline().split()]\n        candidates.append(tuple(pos))\n\n    max_num_blocks = 0\n    for candidate in candidates:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate])\n        max_num_blocks = max(max_num_blocks, num_blocks)\n\n    print(max_num_blocks)"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            x = pos[0]\n            y = pos[1]\n            if (1 <= x <= m and 1 <= y <= n\n                    and (pos not in hex_map or distance < hex_map[pos])):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(x, y)\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\nwhile True:\n    (m, n) = [int(i) for i in sys.stdin.readline().split()]\n    if m == n == 0:\n        break\n\n    s = int(sys.stdin.readline())\n    stores = []\n    for i in range(s):\n        pos = [int(j) for j in sys.stdin.readline().split()]\n        stores.append(tuple(pos))\n    hex_map = {}\n    update_map(hex_map, stores)\n\n    t = int(sys.stdin.readline())\n    candidates = []\n    for i in range(t):\n        pos = [int(j) for j in sys.stdin.readline().split()]\n        candidates.append(tuple(pos))\n\n    max_num_blocks = 0\n    for candidate in candidates:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate])\n        max_num_blocks = max(max_num_blocks, num_blocks)\n\n    print(max_num_blocks)"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    try:\n        data = raw_input()\n        if data == \"0\":\n            break\n        m, n = map(int, data.split())\n        s = input()\n        spos = [map(int, raw_input().split()) for _ in xrange(s)]\n        t = input()\n        tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n        print solve()\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    m, n = map(int, data.split())\n    if m | n == 0:\n        break\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:            \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m and cover[ny][nx] < 0:\n                q.append((ny, nx, step + 1))\n    return cover\n\ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min(sc[y][x] for sc in scover):\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dy, dx in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]   \n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min(sc[y][x] for sc in scover):\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nINF = 10 ** 5\ndirect1 = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, -1), (1, 1))\ndirect2 = ((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0))\n\ndef search(p, mp):\n  que = deque()\n  que.append((0, p))\n  visited = [[False] * (m + 2) for _ in range(n + 2)]\n  visited[p[1]][p[0]] = True\n  mp[p[1]][p[0]] = 0\n  while que:\n    dist, point = que.popleft()\n    px, py = point\n    if py % 2 == 0:\n      direct = direct1\n    else:\n      direct = direct2\n    for dx, dy in direct:\n      nx, ny = px + dx, py + dy\n      if not visited[ny][nx] and mp[ny][nx] != -1:\n        visited[ny][nx] = True\n        if mp[ny][nx] > dist + 1:\n          mp[ny][nx] = dist + 1\n        que.append((dist + 1, (nx, ny)))\n\ndef count(p, mp):\n  que = deque()\n  que.append((0, p))\n  visited = [[False] * (m + 2) for _ in range(n + 2)]\n  visited[p[1]][p[0]] = True\n  ans = 1\n  while que:\n    dist, point = que.popleft()\n    px, py = point\n    if py % 2 == 0:\n      direct = direct1\n    else:\n      direct = direct2\n    for dx, dy in direct:\n      nx, ny = px + dx, py + dy\n      if not visited[ny][nx] and mp[ny][nx] != -1:\n        visited[ny][nx] = True\n        if mp[ny][nx] > dist + 1:\n          ans += 1\n        que.append((dist + 1, (nx, ny)))\n  return ans\n\n\nwhile True:\n  m, n = map(int, input().split())\n  if m == 0:\n    break\n\n  mp = [[-1] + [INF] * m + [-1] for _ in range(n)] \n  mp.insert(0, [-1] * (m + 2))\n  mp.append([-1] * (m + 2))\n  \n  s = int(input())\n  for _ in range(s):\n    x, y = map(int, input().split())\n    search((x, y), mp)\n  \n  ans = 0\n  t = int(input())\n  for _ in range(t):\n    x, y = map(int, input().split())\n    z = count((x, y), mp)\n    ans = max(ans, z)\n  \n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nimport re\np = re.compile(\"\\d+\\s\\d+\")\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input()\n    if p.match(data) is None:\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    return cover\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        return ret\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    return cover\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0 and len(q) <= (10 ** 3):\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input()\n    m, n = map(int, data.split())\n    if m == 0:\n        break\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nimport re\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input().sprit()\n    if data == \"0 0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input().strip()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndd0 = ((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0))\ndd1 = ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0))\n\ndef solve(S, p, q):\n    INF = 10**9\n    L = [[0]*M for i in range(N)]\n    D = [[INF]*M for i in range(N)]\n    que = deque()\n    for i, (x, y) in enumerate(S):\n        L[y][x] = 1\n        D[y][x] = 0\n        que.append((x, y))\n    L[q][p] = 2\n    D[q][p] = 0\n    que.append((p, q))\n    while que:\n        x, y = que.popleft()\n        l = L[y][x]\n        d0 = D[y][x] + 1\n        for dx, dy in (dd1 if y % 2 else dd0):\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N or D[ny][nx] < d0:\n                continue\n            d = D[ny][nx]\n            if d == INF:\n                D[ny][nx] = d0\n                que.append((nx, ny))\n            L[ny][nx] |= l\n    res = 0\n    for i in range(N):\n        for j in range(M):\n            if L[i][j] == 2:\n                res += 1\n    return res\n\nwhile 1:\n    M, N = map(int, input().split())\n    if M == N == 0:\n        break\n    s = int(input())\n    S = []\n    for i in range(s):\n        x, y = map(int, input().split())\n        S.append((x-1, y-1))\n    t = int(input())\n    ans = 0\n    for i in range(t):\n        p, q = map(int, input().split())\n        ans = max(ans, solve(S, p-1, q-1))\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    return cover\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n\ndef count(cover, min_cover):\n    ret = 0\n    return ret\n    for y in xrange(n):\n        for x in xrange(m):\n            if cover[y][x] < min_cover[y][x]:\n                ret += 1\n    return ret\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    return max(count(func(pos[1] - 1, pos[0] - 1), min_cover) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0 and len(q) <= (10 ** 5):\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:           \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n \ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    min_cover = [[min(sc[y][x] for sc in scover) for x in xrange(m)] for y in xrange(n)]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min_cover[y][x]:\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n \nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef generate_next_hexes(x, y):\n    hexes = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n    if y % 2:\n        hexes += [(x - 1, y - 1), (x - 1, y + 1)]\n    else:\n        hexes += [(x + 1, y - 1), (x + 1, y + 1)]\n    return hexes\n\ndef update_map(hex_map, hexes):\n    num_updated_hexes = 0\n    distance = 0\n    while hexes:\n        next_hexes = []\n        for pos in hexes:\n            if (1 <= pos[0] <= m and 1 <= pos[1] <= n) and (pos not in hex_map or distance < hex_map[pos]):\n                hex_map[pos] = distance\n                num_updated_hexes += 1\n                next_hexes += generate_next_hexes(pos[0], pos[1])\n        distance += 1\n        hexes = next_hexes\n    return num_updated_hexes\n\nwhile True:\n    (m, n) = [int(i) for i in sys.stdin.readline().split()]\n    if m == n == 0:\n        break\n\n    s = int(sys.stdin.readline())\n    stores = []\n    for i in range(s):\n        pos = [int(j) for j in sys.stdin.readline().split()]\n        stores.append(tuple(pos))\n    hex_map = {}\n    update_map(hex_map, stores)\n\n    t = int(sys.stdin.readline())\n    candidates = []\n    for i in range(t):\n        pos = [int(j) for j in sys.stdin.readline().split()]\n        candidates.append(tuple(pos))\n\n    max_num_blocks = 0\n    for candidate in candidates:\n        new_hex_map = hex_map.copy()\n        num_blocks = update_map(new_hex_map, [candidate])\n        max_num_blocks = max(max_num_blocks, num_blocks)\n\n    print(max_num_blocks)"
  },
  {
    "language": "Python",
    "code": "D = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)), ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:            \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m and cover[ny][nx] < 0:\n                q.append((ny, nx, step + 1))\n    return cover\n\ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]\n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min(sc[y][x] for sc in scover):\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  },
  {
    "language": "Python",
    "code": "#Deven-Eleven:\nD = (((-1, -1), (0, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)),\n     ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0)))\ndef func(y, x):\n    q = [(y, x, 0)]\n    cover = [[-1] * m for _ in xrange(n)]\n    while len(q) != 0:\n        y, x, step = q.pop(0)\n        if cover[y][x] >= 0:\n            continue\n        cover[y][x] = step\n        for dx, dy in D[y % 2]:            \n            ny, nx = y + dy, x + dx\n            if 0 <= ny < n and 0 <= nx < m:\n                q.append((ny, nx, step + 1))\n    return cover\n\ndef solve():\n    scover = [func(pos[1] - 1, pos[0] - 1) for pos in spos]    \n    def count(cover):\n        ret = 0\n        for y in xrange(n):\n            for x in xrange(m):\n                if cover[y][x] < min(sc[y][x] for sc in scover):\n                    ret += 1\n        return ret\n    return max(count(func(pos[1] - 1, pos[0] - 1)) for pos in tpos)\n\nwhile True:\n    data = raw_input()\n    if data == \"0\":\n        break\n    m, n = map(int, data.split())\n    s = input()\n    spos = [map(int, raw_input().split()) for _ in xrange(s)]\n    t = input()\n    tpos = [map(int, raw_input().split()) for _ in xrange(t)]\n    print solve()"
  }
]