[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint directions[6][2] = {{1, 0}, {0, 1}, {-1, 1}, {-1, 0}, {0, -1}, {1, -1}};\n\nint distance(Point a, Point b) {\n    int dx = a.x - b.x;\n    int dy = a.y - b.y;\n    if ((dx >= 0 && dy >= 0) || (dx <= 0 && dy <= 0)) {\n        return abs(dx + dy);\n    } else {\n        return abs(dx) > abs(dy) ? abs(dx) : abs(dy);\n    }\n}\n\nint main() {\n    int W, H, N;\n    scanf(\"%d %d %d\", &W, &H, &N);\n    \n    Point* stores = malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &stores[i].x, &stores[i].y);\n    }\n    \n    int max_coverage = 0;\n    \n    for (int x = 0; x < W; x++) {\n        for (int y = 0; y < H; y++) {\n            Point current = {x, y};\n            int is_store = 0;\n            for (int i = 0; i < N; i++) {\n                if (stores[i].x == x && stores[i].y == y) {\n                    is_store = 1;\n                    break;\n                }\n            }\n            if (is_store) continue;\n            \n            int coverage = 0;\n            for (int nx = 0; nx < W; nx++) {\n                for (int ny = 0; ny < H; ny++) {\n                    Point neighbor = {nx, ny};\n                    int min_dist = INT_MAX;\n                    for (int i = 0; i < N; i++) {\n                        int dist = distance(neighbor, stores[i]);\n                        if (dist < min_dist) {\n                            min_dist = dist;\n                        }\n                    }\n                    int new_dist = distance(neighbor, current);\n                    if (new_dist < min_dist) {\n                        coverage++;\n                    }\n                }\n            }\n            if (coverage > max_coverage) {\n                max_coverage = coverage;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_coverage);\n    free(stores);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConvenienceStoreOptimization {\n    static final int[] dx = {1, -1, 0, 0, 1, -1};\n    static final int[] dy = {0, 0, 1, -1, 1, -1};\n    \n    public static int findMaxCoverage(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int[][] distance = new int[rows][cols];\n        \n        // Initialize distances\n        for (int[] row : distance) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        \n        // Calculate distances to existing stores\n        Queue<int[]> queue = new LinkedList<>();\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (grid[r][c] == 1) {\n                    distance[r][c] = 0;\n                    queue.offer(new int[]{r, c});\n                }\n            }\n        }\n        \n        // BFS to calculate distances\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1];\n            \n            for (int i = 0; i < 6; i++) {\n                int nr = r + dy[i];\n                int nc = c + dx[i];\n                \n                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\n                    if (distance[nr][nc] > distance[r][c] + 1) {\n                        distance[nr][nc] = distance[r][c] + 1;\n                        queue.offer(new int[]{nr, nc});\n                    }\n                }\n            }\n        }\n        \n        // Find blocks without coverage that maximize potential new store\n        int maxCoverage = 0;\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (grid[r][c] == 0) {\n                    int coverage = calculateCoverage(distance, r, c);\n                    maxCoverage = Math.max(maxCoverage, coverage);\n                }\n            }\n        }\n        \n        return maxCoverage;\n    }\n    \n    private static int calculateCoverage(int[][] distance, int r, int c) {\n        int coverage = 0;\n        int rows = distance.length;\n        int cols = distance[0].length;\n        \n        for (int nr = 0; nr < rows; nr++) {\n            for (int nc = 0; nc < cols; nc++) {\n                if (grid[nr][nc] == 0) {\n                    int currDist = getHexDistance(r, c, nr, nc);\n                    if (currDist < distance[nr][nc]) {\n                        coverage++;\n                    }\n                }\n            }\n        }\n        \n        return coverage;\n    }\n    \n    private static int getHexDistance(int r1, int c1, int r2, int c2) {\n        return Math.abs(r1 - r2) + Math.abs(c1 - c2);\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        \n        int[][] grid = new int[rows][cols];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                grid[r][c] = scanner.nextInt();\n            }\n        }\n        \n        int result = findMaxCoverage(grid);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:35:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\nvector<vector<int>> directions = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, -1}, {-1, 1}\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    queue<Point> q;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '#') {\n                dist[i][j] = 0;\n                q.push(Point(i, j));\n            }\n        }\n    }\n\n    while (!q.empty()) {\n        Point p = q.front();\n        q.pop();\n        for (auto& dir : directions) {\n            int nx = p.x + dir[0];\n            int ny = p.y + dir[1];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                if (dist[nx][ny] > dist[p.x][p.y] + 1) {\n                    dist[nx][ny] = dist[p.x][p.y] + 1;\n                    q.push(Point(nx, ny));\n                }\n            }\n        }\n    }\n\n    int max_dist = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '.' && dist[i][j] != 0) {\n                if (dist[i][j] > max_dist) {\n                    max_dist = dist[i][j];\n                }\n            }\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '.' && dist[i][j] == max_dist) {\n                count++;\n            }\n        }\n    }\n\n    if (max_dist == 0) {\n        cout << -1 << endl;\n    } else {\n        cout << max_dist - 1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_BLOCKS 50\n#define MAX_STORES 10\n\nint map[MAX_BLOCKS][MAX_BLOCKS];\nint existing_stores[MAX_STORES][2];\nint num_existing_stores;\nint rows, cols;\n\nint distance(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint find_nearest_store(int x, int y) {\n    int min_dist = INT_MAX;\n    for (int i = 0; i < num_existing_stores; i++) {\n        int dist = distance(x, y, existing_stores[i][0], existing_stores[i][1]);\n        min_dist = (dist < min_dist) ? dist : min_dist;\n    }\n    return min_dist;\n}\n\nint calculate_coverage(int new_store_x, int new_store_y) {\n    int covered_blocks = 0;\n    for (int x = 0; x < rows; x++) {\n        for (int y = 0; y < cols; y++) {\n            int min_dist_existing = find_nearest_store(x, y);\n            int dist_new_store = distance(x, y, new_store_x, new_store_y);\n            \n            if (dist_new_store < min_dist_existing) {\n                covered_blocks++;\n            }\n        }\n    }\n    return covered_blocks;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    scanf(\"%d\", &num_existing_stores);\n    \n    for (int i = 0; i < num_existing_stores; i++) {\n        scanf(\"%d %d\", &existing_stores[i][0], &existing_stores[i][1]);\n    }\n    \n    int max_coverage = 0;\n    for (int x = 0; x < rows; x++) {\n        for (int y = 0; y < cols; y++) {\n            int coverage = calculate_coverage(x, y);\n            max_coverage = (coverage > max_coverage) ? coverage : max_coverage;\n        }\n    }\n    \n    printf(\"%d\\n\", max_coverage);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_N = 55;\nconst int dx[6] = {-1, -1, 0, 0, 1, 1};\nconst int dy[6] = {-1, 0, -1, 1, 0, 1};\n\nint N, M;\nint map_grid[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\nvector<pair<int, int>> stores;\n\nvoid bfs() {\n    for(int i = 0; i < MAX_N; i++)\n        for(int j = 0; j < MAX_N; j++)\n            dist[i][j] = INT_MAX;\n\n    for(auto& store : stores) {\n        int sx = store.first, sy = store.second;\n        dist[sx][sy] = 0;\n        vector<pair<int, int>> queue = {{sx, sy}};\n        vector<bool> visited(queue.size(), false);\n\n        while(!queue.empty()) {\n            int x = queue.front().first;\n            int y = queue.front().second;\n            queue.erase(queue.begin());\n\n            for(int k = 0; k < 6; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n\n                if(nx >= 0 && nx < MAX_N && ny >= 0 && ny < MAX_N) {\n                    if(dist[nx][ny] > dist[x][y] + 1) {\n                        dist[nx][ny] = dist[x][y] + 1;\n                        queue.push_back({nx, ny});\n                    }\n                }\n            }\n        }\n    }\n}\n\nint count_coverage() {\n    int coverage = 0;\n    for(int i = 0; i < MAX_N; i++)\n        for(int j = 0; j < MAX_N; j++)\n            if(map_grid[i][j] == 0 && dist[i][j] != INT_MAX)\n                coverage++;\n    return coverage;\n}\n\nint solve() {\n    int max_coverage = 0;\n    for(int x = 0; x < MAX_N; x++) {\n        for(int y = 0; y < MAX_N; y++) {\n            if(map_grid[x][y] == 0) {\n                stores.push_back({x, y});\n                bfs();\n                max_coverage = max(max_coverage, count_coverage());\n                stores.pop_back();\n            }\n        }\n    }\n    return max_coverage;\n}\n\nint main() {\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        int x, y;\n        cin >> x >> y;\n        map_grid[x][y] = 1;\n        stores.push_back({x, y});\n    }\n\n    cout << solve() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int[][] directions = {{1, 0}, {0, 1}, {-1, 1}, {-1, 0}, {0, -1}, {1, -1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        char[][] grid = new char[H][W];\n        int[][] nearestDist = new int[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                nearestDist[i][j] = -1;\n                if (grid[i][j] == '#') {\n                    queue.add(new int[]{i, j, 0});\n                    nearestDist[i][j] = 0;\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int dist = current[2];\n\n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && nearestDist[nx][ny] == -1) {\n                    nearestDist[nx][ny] = dist + 1;\n                    queue.add(new int[]{nx, ny, dist + 1});\n                }\n            }\n        }\n\n        int maxCoverage = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.' && (nearestDist[i][j] > maxCoverage)) {\n                    maxCoverage = nearestDist[i][j];\n                }\n            }\n        }\n\n        System.out.println(maxCoverage);\n    }\n}",
    "timestamp": "2025-08-05 18:37:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef max_coverage(map_height, map_width, existing_stores, potential_stores):\n    # Hexagonal directions (6 directions)\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1)]\n\n    def is_in_bounds(x, y):\n        return 0 <= x < map_height and 0 <= y < map_width\n\n    def bfs_coverage(start_x, start_y, blocks_no_store):\n        visited = set()\n        queue = deque([(start_x, start_y, 0)])\n\n        while queue:\n            x, y, dist = queue.popleft()\n            if (x, y) not in visited and (x, y) in blocks_no_store:\n                visited.add((x, y))\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if is_in_bounds(nx, ny):\n                        queue.append((nx, ny, dist + 1))\n\n        return len(visited)\n\n    # Create a set of blocks not covered by any existing store\n    blocks_no_store = set((i, j) for i in range(map_height) for j in range(map_width))\n\n    # Mark blocks covered by existing stores\n    for store_x, store_y in existing_stores:\n        queue = deque([(store_x, store_y, 0)])\n        visited = set()\n\n        while queue:\n            x, y, dist = queue.popleft()\n            if (x, y) not in visited:\n                visited.add((x, y))\n                if (x, y) in blocks_no_store:\n                    blocks_no_store.remove((x, y))\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if is_in_bounds(nx, ny):\n                        queue.append((nx, ny, dist + 1))\n\n    # Calculate potential coverage for each new store location\n    max_covered = 0\n    for store_x, store_y in potential_stores:\n        covered_blocks = bfs_coverage(store_x, store_y, blocks_no_store)\n        max_covered = max(max_covered, covered_blocks)\n\n    return max_covered\n\n# Example usage\nmap_height = 5\nmap_width = 5\nexisting_stores = [(0, 0), (2, 3)]\npotential_stores = [(0, 1), (4, 4), (1, 2)]\nprint(max_coverage(map_height, map_width, existing_stores, potential_stores))",
    "timestamp": "2025-08-13 00:02:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DebunEleven {\n\n    static int[][] directions = {{0, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, 0}, {-1, 1}};\n\n    public static int findMaxCoverage(char[][] map, List<int[]> vacantLocations) {\n        int maxCoverage = 0;\n\n        for (int[] loc : vacantLocations) {\n            maxCoverage = Math.max(maxCoverage, calculateCoverage(map, loc[0], loc[1]));\n        }\n\n        return maxCoverage;\n    }\n\n    private static int calculateCoverage(char[][] map, int startX, int startY) {\n        int rows = map.length;\n        int cols = map[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{startX, startY});\n        visited[startX][startY] = true;\n        int coverage = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            coverage++;\n\n            for (int[] dir : directions) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                if (isValid(newX, newY, map, visited)) {\n                    visited[newX][newY] = true;\n                    queue.add(new int[]{newX, newY});\n                }\n            }\n        }\n\n        return coverage;\n    }\n\n    private static boolean isValid(int x, int y, char[][] map, boolean[][] visited) {\n        int rows = map.length;\n        int cols = map[0].length;\n        return x >= 0 && x < rows && y >= 0 && y < cols && !visited[x][y] && map[x][y] == '.';\n    }\n\n    public static void main(String[] args) {\n        char[][] map = {\n            { '.', '.', '.', '.', '.', '.' },\n            { '.', '.', '.', 'C', '.', '.' },\n            { '.', '.', '.', '.', '.', '.' },\n            { '.', '.', '.', '.', '.', '.' },\n            { '.', 'C', '.', '.', '.', '.' },\n            { '.', '.', '.', '.', '.', '.' }\n        };\n\n        List<int[]> vacantLocations = Arrays.asList(\n            new int[]{0, 0},\n            new int[]{0, 2},\n            new int[]{2, 0},\n            new int[]{2, 2}\n        );\n\n        System.out.println(findMaxCoverage(map, vacantLocations));\n    }\n}",
    "timestamp": "2025-08-13 00:02:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_BLOCKS 100\n#define MAX_CONVENIENCE 100\n\nint hex_distance(int x1, int y1, int x2, int y2) {\n    return (abs(x1 - x2) + abs(y1 - y2) + abs(x1 + y1 - x2 - y2)) / 2;\n}\n\nint main() {\n    int n, m;\n    printf(\"Enter the number of blocks: \");\n    scanf(\"%d\", &n);\n    int blocks[n][2];\n    printf(\"Enter the blocks coordinates:\\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &blocks[i][0], &blocks[i][1]);\n    }\n\n    printf(\"Enter the number of existing convenience stores: \");\n    scanf(\"%d\", &m);\n    int stores[m][2];\n    printf(\"Enter the existing convenience stores coordinates:\\n\");\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &stores[i][0], &stores[i][1]);\n    }\n    \n    int max_coverage = 0;\n    int best_block = -1;\n\n    for (int i = 0; i < n; i++) {\n        int coverage = 0;\n        for (int j = 0; j < n; j++) {\n            int nearest_store_distance = INT_MAX;\n            for (int k = 0; k < m; k++) {\n                int current_store_distance = hex_distance(blocks[j][0], blocks[j][1], stores[k][0], stores[k][1]);\n                if (current_store_distance < nearest_store_distance) {\n                    nearest_store_distance = current_store_distance;\n                }\n            }\n            int new_store_distance = hex_distance(blocks[j][0], blocks[j][1], blocks[i][0], blocks[i][1]);\n            if (new_store_distance < nearest_store_distance) {\n                coverage++;\n            }\n        }\n        \n        if (coverage > max_coverage) {\n            max_coverage = coverage;\n            best_block = i;\n        }\n    }\n\n    printf(\"Best block for new convenience store is at (%d, %d) covering %d blocks.\\n\", blocks[best_block][0], blocks[best_block][1], max_coverage);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:03:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solution(grid):\n    rows, cols = len(grid), len(grid[0])\n    covered_blocks = set()\n    existing_stores = []\n\n    # Find existing stores\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'S':\n                existing_stores.append((r, c))\n\n    # Calculate distances and find covered blocks for existing stores\n    def find_covered_blocks(store_row, store_col):\n        store_coverage = set()\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] != 'S':\n                    # Calculate hex grid distance\n                    dist = max(abs(r - store_row), abs(c - store_col), \n                               abs(r + c - store_row - store_col))\n                    if (r, c) not in covered_blocks or \\\n                       dist < max_distance((r, c), covered_blocks):\n                        store_coverage.add((r, c))\n        return store_coverage\n\n    def max_distance(block, current_covered):\n        return min(hex_distance(block, store) for store in current_covered)\n\n    def hex_distance(block1, block2):\n        return max(abs(block1[0] - block2[0]), \n                   abs(block1[1] - block2[1]), \n                   abs(block1[0] + block1[1] - block2[0] - block2[1]))\n\n    # Identify uncovered blocks\n    uncovered_blocks = set()\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 'S':\n                uncovered_blocks.add((r, c))\n\n    # Try placing a new store in each uncovered block\n    max_coverage = 0\n    best_block = None\n    for potential_row in range(rows):\n        for potential_col in range(cols):\n            if grid[potential_row][potential_col] != 'S':\n                new_store_coverage = find_covered_blocks(potential_row, potential_col)\n                coverage_count = len(new_store_coverage)\n                if coverage_count > max_coverage:\n                    max_coverage = coverage_count\n                    best_block = (potential_row, potential_col)\n\n    return max_coverage",
    "timestamp": "2025-08-13 00:03:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    H = int(input[ptr])\n    ptr += 1\n    W = int(input[ptr])\n    ptr += 1\n    \n    grid = []\n    convs = []\n    for i in range(H):\n        row = input[ptr:ptr+W]\n        ptr += W\n        grid.append(row)\n        for j in range(W):\n            if row[j] == '1':\n                convs.append((i, j))\n    \n    if not convs:\n        print(H * W)\n        return\n    \n    directions = [(-1, 0), (-1, 1), (0, 1), (1, 0), (1, -1), (0, -1)]\n    \n    dist = [[-1 for _ in range(W)] for _ in range(H)]\n    q = deque()\n    for i, j in convs:\n        dist[i][j] = 0\n        q.append((i, j))\n    \n    while q:\n        i, j = q.popleft()\n        for di, dj in directions:\n            ni = i + di\n            nj = j + dj\n            if 0 <= ni < H and 0 <= nj < W and dist[ni][nj] == -1:\n                dist[ni][nj] = dist[i][j] + 1\n                q.append((ni, nj))\n    \n    max_candidates = {}\n    max_dist = -1\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '0' and dist[i][j] > max_dist:\n                max_dist = dist[i][j]\n                max_candidates = {(i, j)}\n            elif grid[i][j] == '0' and dist[i][j] == max_dist:\n                max_candidates.add((i, j))\n    \n    if not max_candidates:\n        print(0)\n        return\n    \n    best = 0\n    for ci, cj in max_candidates:\n        new_dist = [[-1 for _ in range(W)] for _ in range(H)]\n        q = deque()\n        q.append((ci, cj))\n        new_dist[ci][cj] = 0\n        count = 0\n        \n        while q:\n            i, j = q.popleft()\n            if new_dist[i][j] < dist[i][j]:\n                count += 1\n            elif new_dist[i][j] == dist[i][j]:\n                continue\n            for di, dj in directions:\n                ni = i + di\n                nj = j + dj\n                if 0 <= ni < H and 0 <= nj < W and new_dist[ni][nj] == -1:\n                    new_dist[ni][nj] = new_dist[i][j] + 1\n                    if new_dist[ni][nj] < dist[ni][nj]:\n                        q.append((ni, nj))\n        best = max(best, count)\n    \n    print(best)\n\nsolve()",
    "timestamp": "2025-08-13 00:03:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n// Hexagonal grid movements (q, r)\nconst vector<pair<int, int>> hex_moves = {{1, 0}, {0, 1}, {-1, 1}, {-1, 0}, {0, -1}, {1, -1}};\n\n// Determine coverage of blocks from a specific convenience store\nvector<vector<int>> determineCoverage(int rows, int cols, const vector<pair<int, int>>& existingStores) {\n    vector<vector<int>> coverage(rows, vector<int>(cols, numeric_limits<int>::max()));\n    queue<pair<int, int>> q;\n\n    for (const auto& store : existingStores) {\n        q.push(store);\n        coverage[store.first][store.second] = 0;\n    }\n\n    while (!q.empty()) {\n        auto [cur_q, cur_r] = q.front();\n        q.pop();\n\n        for (const auto& move : hex_moves) {\n            int new_q = cur_q + move.first;\n            int new_r = cur_r + move.second;\n\n            if (new_q >= 0 && new_q < rows && new_r >= 0 && new_r < cols && coverage[new_q][new_r] > coverage[cur_q][cur_r] + 1) {\n                coverage[new_q][new_r] = coverage[cur_q][cur_r] + 1;\n                q.push({new_q, new_r});\n            }\n        }\n    }\n\n    return coverage;\n}\n\n// Find the potential new store location that maximizes coverage of uncovered blocks\nint maximizeCoverage(int rows, int cols, const vector<pair<int, int>>& existingStores, const vector<pair<int, int>>& potentialNewStores) {\n    auto coverage = determineCoverage(rows, cols, existingStores);\n    int maxCovered = 0;\n    \n    for (const auto& newStore : potentialNewStores) {\n        int covered = 0;\n\n        for (int q = 0; q < rows; ++q) {\n            for (int r = 0; r < cols; ++r) {\n                int newDistance = abs(q - newStore.first) + abs(r - newStore.second); // Hex distance approximation\n                if (coverage[q][r] > newDistance) {\n                    covered++;\n                }\n            }\n        }\n\n        maxCovered = max(maxCovered, covered);\n    }\n\n    return maxCovered;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    int numExisting, numPotential;\n    cin >> numExisting >> numPotential;\n\n    vector<pair<int, int>> existingStores(numExisting);\n    vector<pair<int, int>> potentialNewStores(numPotential);\n\n    for (int i = 0; i < numExisting; ++i) {\n        cin >> existingStores[i].first >> existingStores[i].second;\n    }\n\n    for (int i = 0; i < numPotential; ++i) {\n        cin >> potentialNewStores[i].first >> potentialNewStores[i].second;\n    }\n\n    cout << maximizeCoverage(rows, cols, existingStores, potentialNewStores) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:52:10"
  }
]