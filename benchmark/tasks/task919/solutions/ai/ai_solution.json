[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <queue>\n#include <utility>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nusing namespace std;\n\nchar grid[MAX_H][MAX_W];\nint H, W, K;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nbool isExit(int x, int y) {\n    return x == 0 || x == H-1 || y == 0 || y == W-1;\n}\n\nint bfs() {\n    queue<pair<pair<int, int>, pair<int, int>>> q;\n    bool visited[MAX_H][MAX_W][K+1];\n    memset(visited, false, sizeof(visited));\n    \n    int startX = -1, startY = -1;\n    for(int x = 0; x < H; x++) {\n        for(int y = 0; y < W; y++) {\n            if(grid[x][y] == 'S') {\n                startX = x;\n                startY = y;\n                break;\n            }\n        }\n        if(startX != -1) break;\n    }\n    \n    q.push({{startX, startY}, {0, 0}});\n    visited[startX][startY][0] = true;\n    \n    while(!q.empty()) {\n        int x = q.front().first.first;\n        int y = q.front().first.second;\n        int casts = q.front().second.first;\n        int breaks = q.front().second.second;\n        q.pop();\n        \n        if(isExit(x, y)) return casts;\n        \n        for(int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            if(grid[nx][ny] == '.' || grid[nx][ny] == 'S') {\n                if(!visited[nx][ny][breaks]) {\n                    q.push({{nx, ny}, {casts, breaks}});\n                    visited[nx][ny][breaks] = true;\n                }\n            }\n            \n            if(grid[nx][ny] == '#' && breaks < K) {\n                if(!visited[nx][ny][breaks+1]) {\n                    q.push({{nx, ny}, {casts+1, breaks+1}});\n                    visited[nx][ny][breaks+1] = true;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    \n    for(int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    int result = bfs();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n#define INF 1000000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint H, W, K;\nchar grid[MAX_H][MAX_W + 1];\nint dist[MAX_H][MAX_W];\nPoint queue[MAX_H * MAX_W];\nint front, rear;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid bfs(int sx, int sy) {\n    front = rear = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dist[i][j] = INF;\n        }\n    }\n    dist[sx][sy] = 0;\n    queue[rear++] = (Point){sx, sy};\n\n    while (front < rear) {\n        Point p = queue[front++];\n        for (int d = 0; d < 4; d++) {\n            int nx = p.x + dx[d];\n            int ny = p.y + dy[d];\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if (grid[nx][ny] == '#') {\n                if (dist[p.x][p.y] + 1 < dist[nx][ny] && dist[p.x][p.y] + 1 <= K) {\n                    dist[nx][ny] = dist[p.x][p.y] + 1;\n                    queue[rear++] = (Point){nx, ny};\n                }\n            } else {\n                if (dist[p.x][p.y] < dist[nx][ny]) {\n                    dist[nx][ny] = dist[p.x][p.y];\n                    queue[--front] = (Point){nx, ny};\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    int sx, sy;\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                sx = i;\n                sy = j;\n            }\n        }\n    }\n\n    bfs(sx, sy);\n\n    int ans = INF;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (i == 0 || i == H - 1 || j == 0 || j == W - 1) {\n                if (dist[i][j] <= K) {\n                    int steps = (dist[i][j] + K - 1) / K;\n                    if (steps < ans) ans = steps;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> grid(H);\n    int sx, sy;\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                sx = i;\n                sy = j;\n            }\n        }\n    }\n\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    queue<pair<int, int>> q;\n    dist[sx][sy] = 0;\n    q.emplace(sx, sy);\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        if (x == 0 || x == H - 1 || y == 0 || y == W - 1) {\n            cout << 1 << endl;\n            return 0;\n        }\n        if (dist[x][y] >= K) continue;\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] != '#' && dist[nx][ny] > dist[x][y] + 1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.emplace(nx, ny);\n            }\n        }\n    }\n\n    int min_dist = INT_MAX;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (dist[i][j] != INT_MAX) {\n                int border_dist = min({i, H - 1 - i, j, W - 1 - j});\n                int casts = (border_dist + K - 1) / K + 1;\n                min_dist = min(min_dist, casts);\n            }\n        }\n    }\n\n    cout << min_dist << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:21:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int H, W, K;\n    static char[][] grid;\n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n\n    static class State {\n        int x, y, casts, remaining;\n        State(int x, int y, int casts, int remaining) {\n            this.x = x;\n            this.y = y;\n            this.casts = casts;\n            this.remaining = remaining;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        H = Integer.parseInt(st.nextToken());\n        W = Integer.parseInt(st.nextToken());\n        K = Integer.parseInt(st.nextToken());\n        grid = new char[H][W];\n        int sx = -1, sy = -1;\n        for (int i = 0; i < H; i++) {\n            grid[i] = br.readLine().toCharArray();\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 'S') {\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n\n        int[][][] dist = new int[H][W][K + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                Arrays.fill(dist[i][j], Integer.MAX_VALUE);\n            }\n        }\n        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> a.casts - b.casts);\n        pq.offer(new State(sx, sy, 0, K));\n        dist[sx][sy][K] = 0;\n\n        int minCasts = Integer.MAX_VALUE;\n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            if (isExit(curr.x, curr.y)) {\n                minCasts = curr.casts;\n                break;\n            }\n            if (curr.casts > dist[curr.x][curr.y][curr.remaining]) continue;\n\n            for (int d = 0; d < 4; d++) {\n                int nx = curr.x + dx[d];\n                int ny = curr.y + dy[d];\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if (grid[nx][ny] == '.' || grid[nx][ny] == 'S') {\n                    if (dist[nx][ny][curr.remaining] > curr.casts) {\n                        dist[nx][ny][curr.remaining] = curr.casts;\n                        pq.offer(new State(nx, ny, curr.casts, curr.remaining));\n                    }\n                } else if (grid[nx][ny] == '#' && curr.remaining > 0) {\n                    if (dist[nx][ny][curr.remaining - 1] > curr.casts + 1) {\n                        dist[nx][ny][curr.remaining - 1] = curr.casts + 1;\n                        pq.offer(new State(nx, ny, curr.casts + 1, curr.remaining - 1));\n                    }\n                }\n            }\n        }\n        System.out.println(minCasts);\n    }\n\n    static boolean isExit(int x, int y) {\n        return x == 0 || x == H - 1 || y == 0 || y == W - 1;\n    }\n}",
    "timestamp": "2025-08-05 23:22:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static int H, W, K;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static int escape() {\n        Queue<State> queue = new LinkedList<>();\n        int startX = -1, startY = -1;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                    break;\n                }\n            }\n            if (startX != -1) break;\n        }\n\n        queue.offer(new State(startX, startY, 0, 0));\n        visited = new boolean[H][W];\n        visited[startX][startY] = true;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (isExit(current.x, current.y)) {\n                return current.casts;\n            }\n\n            for (int k = 0; k <= K; k++) {\n                Set<Point> unlockedRooms = unlockRooms(current.x, current.y, k);\n                for (Point room : unlockedRooms) {\n                    for (int dir = 0; dir < 4; dir++) {\n                        int nx = room.x + dx[dir];\n                        int ny = room.y + dy[dir];\n\n                        if (isValid(nx, ny) && !visited[nx][ny]) {\n                            visited[nx][ny] = true;\n                            queue.offer(new State(nx, ny, current.casts + 1, k));\n                        }\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    static Set<Point> unlockRooms(int x, int y, int k) {\n        Set<Point> rooms = new HashSet<>();\n        rooms.add(new Point(x, y));\n\n        Queue<Point> queue = new LinkedList<>();\n        queue.offer(new Point(x, y));\n        boolean[][] tempVisited = new boolean[H][W];\n        tempVisited[x][y] = true;\n\n        while (!queue.isEmpty() && k > 0) {\n            Point current = queue.poll();\n\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = current.x + dx[dir];\n                int ny = current.y + dy[dir];\n\n                if (isValid(nx, ny) && !tempVisited[nx][ny]) {\n                    if (grid[nx][ny] == '#') {\n                        rooms.add(new Point(nx, ny));\n                        k--;\n                    }\n                    queue.offer(new Point(nx, ny));\n                    tempVisited[nx][ny] = true;\n                }\n            }\n        }\n\n        return rooms;\n    }\n\n    static boolean isExit(int x, int y) {\n        return x == 0 || x == H - 1 || y == 0 || y == W - 1;\n    }\n\n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] != '#';\n    }\n\n    static class State {\n        int x, y, casts, unlocked;\n        State(int x, int y, int casts, int unlocked) {\n            this.x = x;\n            this.y = y;\n            this.casts = casts;\n            this.unlocked = unlocked;\n        }\n    }\n\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Point point = (Point) o;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        H = scanner.nextInt();\n        W = scanner.nextInt();\n        K = scanner.nextInt();\n        scanner.nextLine();\n\n        grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            grid[i] = scanner.nextLine().toCharArray();\n        }\n\n        System.out.println(escape());\n    }\n}",
    "timestamp": "2025-08-05 23:22:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint H, W, K;\nvector<string> grid;\n\nstruct State {\n    int x, y, unlocked, casts;\n};\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint bfs() {\n    vector<vector<vector<bool>>> visited(H, vector<vector<bool>>(W, vector<bool>(K + 1, false)));\n    queue<State> q;\n    \n    // Find start position\n    int sx = -1, sy = -1;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                sx = i;\n                sy = j;\n                break;\n            }\n            if (sx != -1) break;\n        }\n    }\n    \n    q.push({sx, sy, 0, 0});\n    visited[sx][sy][0] = true;\n    \n    int minCasts = numeric_limits<int>::max();\n    \n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n        \n        // Check if exit reached\n        if (curr.x == 0 || curr.x == H-1 || curr.y == 0 || curr.y == W-1) {\n            minCasts = min(minCasts, curr.casts);\n            continue;\n        }\n        \n        for (int d = 0; d < 4; d++) {\n            int nx = curr.x + dx[d];\n            int ny = curr.y + dy[d];\n            \n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            int newUnlocked = curr.unlocked;\n            int newCasts = curr.casts;\n            \n            if (grid[nx][ny] == '#') {\n                if (curr.unlocked >= K) continue;\n                newUnlocked++;\n            }\n            \n            if (curr.unlocked >= K) {\n                newCasts++;\n                newUnlocked = 1;\n            }\n            \n            if (!visited[nx][ny][newUnlocked]) {\n                visited[nx][ny][newUnlocked] = true;\n                q.push({nx, ny, newUnlocked, newCasts});\n            }\n        }\n    }\n    \n    return minCasts == numeric_limits<int>::max() ? -1 : minCasts;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    grid.resize(H);\n    \n    for (int i = 0; i < H; i++) {\n        cin >> grid[i];\n    }\n    \n    cout << bfs() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_casts_to_escape(H, W, K, grid):\n    # Find the starting position and possible exits\n    start = None\n    exits = set()\n    \n    # Directions: [right, down, left, up]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            if grid[i][j] != '#' and (i in (0, H-1) or j in (0, W-1)):\n                exits.add((i, j))\n    \n    if not start:\n        return -1  # In case there's no starting point (shouldn't happen)\n    \n    # BFS Initialization\n    queue = deque([(start[0], start[1], 0)])  # (row, col, casts_used)\n    visited = set([(start[0], start[1], 0)])  # (row, col, casts_used)\n    \n    # BFS to search the minimum casts\n    while queue:\n        r, c, casts = queue.popleft()\n        \n        # Check if we've reached an exit\n        if (r, c) in exits:\n            return casts\n        \n        # Consider adjacent rooms\n        for dr, dc in directions:\n            for steps in range(1, K + 1):  # Move from 1 step up to K steps\n                nr, nc = r + dr * steps, c + dc * steps\n                \n                # Stop if out of bounds\n                if not (0 <= nr < H and 0 <= nc < W):\n                    continue\n                \n                # Stop if it's a wall and more casts would be used than available\n                if grid[nr][nc] == '#' and (casts + 1, nr, nc) in visited:\n                    break\n                \n                # Check if we can add to the queue\n                if (grid[nr][nc] == '.' or grid[nr][nc] == 'S') and (casts, nr, nc) not in visited:\n                    visited.add((casts, nr, nc))\n                    queue.append((nr, nc, casts))\n                elif grid[nr][nc] == '#' and (casts + 1 <= K) and (casts + 1, nr, nc) not in visited:\n                    visited.add((casts + 1, nr, nc))\n                    queue.append((nr, nc, casts + 1))\n                    break\n                \n    return -1  # If no exit is found\n\n# Example usage\nH = 4\nW = 4\nK = 1\ngrid = [\n    \"###.\",\n    \"#S#.\",\n    \"###.\",\n    \"....\"\n]\n\nprint(min_casts_to_escape(H, W, K, grid))",
    "timestamp": "2025-08-13 14:52:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class EscapeBuilding {\n\n    private static class State {\n        int x, y, castsLeft;\n\n        public State(int x, int y, int castsLeft) {\n            this.x = x;\n            this.y = y;\n            this.castsLeft = castsLeft;\n        }\n    }\n\n    public static int minCastsToEscape(char[][] building, int K) {\n        int H = building.length, W = building[0].length;\n        int[][] direction = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        Queue<State> queue = new LinkedList<>();\n        boolean[][][] visited = new boolean[H][W][K + 1];\n        \n        // Find starting point S\n        int startX = 0, startY = 0;\n        outerLoop:\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (building[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                    break outerLoop;\n                }\n            }\n        }\n\n        // Add initial state to queue\n        queue.add(new State(startX, startY, K));\n        visited[startX][startY][K] = true;\n\n        int casts = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n\n            for (int i = 0; i < size; i++) {\n                State state = queue.poll();\n\n                if (isExit(state.x, state.y, H, W)) {\n                    return casts;\n                }\n\n                for (int[] dir : direction) {\n                    int nx = state.x + dir[0];\n                    int ny = state.y + dir[1];\n\n                    if (nx < 0 || ny < 0 || nx >= H || ny >= W) continue;\n\n                    if ((building[nx][ny] == '.' || building[nx][ny] == 'S') && !visited[nx][ny][state.castsLeft]) {\n                        visited[nx][ny][state.castsLeft] = true;\n                        queue.add(new State(nx, ny, state.castsLeft));\n                    }\n\n                    if (building[nx][ny] == '#' && state.castsLeft > 0 && !visited[nx][ny][state.castsLeft - 1]) {\n                        visited[nx][ny][state.castsLeft - 1] = true;\n                        queue.add(new State(nx, ny, state.castsLeft - 1));\n                    }\n                }\n            }\n\n            casts++;\n        }\n\n        return -1;\n    }\n\n    private static boolean isExit(int x, int y, int H, int W) {\n        return x == 0 || y == 0 || x == H - 1 || y == W - 1;\n    }\n\n    public static void main(String[] args) {\n        char[][] building = {\n                {'.', '#', '#', '#', '#', '#', '#'},\n                {'.', '#', 'S', '.', '.', '.', '#'},\n                {'.', '#', '.', '#', '#', '.', '#'},\n                {'.', '.', '.', '#', '.', '.', '#'},\n                {'.', '#', '#', '#', '#', '.', '#'}\n        };\n        int K = 3;\n        System.out.println(minCastsToEscape(building, K)); // Output the minimum casts required\n    }\n}",
    "timestamp": "2025-08-13 14:52:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define MAX_HW 1000\n#define INF 1000000\n\ntypedef struct {\n    int x, y, remainingK;\n} Point;\n\nchar building[MAX_HW][MAX_HW];\nint H, W, K;\nint minCasts[MAX_HW][MAX_HW];\nint dirX[4] = {1, -1, 0, 0};\nint dirY[4] = {0, 0, 1, -1};\n\nbool isWithinBounds(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nbool isExit(int x, int y) {\n    return x == 0 || x == H-1 || y == 0 || y == W-1;\n}\n\nint bfs(int startX, int startY) {\n    memset(minCasts, INF, sizeof(minCasts));\n    minCasts[startX][startY] = 0;\n\n    Point *queue = (Point *)malloc(H * W * K * sizeof(Point));\n    int front = 0, rear = 0;\n\n    queue[rear++] = (Point){startX, startY, K};\n\n    while (front < rear) {\n        Point current = queue[front++];\n        int x = current.x, y = current.y, remainingK = current.remainingK;\n\n        if (isExit(x, y))\n            return minCasts[x][y];\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dirX[i];\n            int ny = y + dirY[i];\n\n            if (isWithinBounds(nx, ny)) {\n                if (building[nx][ny] == '.' || building[nx][ny] == 'S') {\n                    if (minCasts[nx][ny] > minCasts[x][y]) {\n                        minCasts[nx][ny] = minCasts[x][y];\n                        queue[rear++] = (Point){nx, ny, remainingK};\n                    } \n                } else if (building[nx][ny] == '#' && remainingK > 0) {\n                    if (minCasts[nx][ny] > minCasts[x][y] + 1) {\n                        minCasts[nx][ny] = minCasts[x][y] + 1;\n                        queue[rear++] = (Point){nx, ny, remainingK - 1};\n                    }\n                }\n            }\n        }\n    }\n    free(queue);\n    return INF;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    int startX, startY;\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", building[i]);\n        for (int j = 0; j < W; j++) {\n            if (building[i][j] == 'S') {\n                startX = i;\n                startY = j;\n            }\n        }\n    }\n    \n    int result = bfs(startX, startY);\n    \n    printf(\"%d\\n\", result == INF ? -1 : result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:53:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nconst int INF = 1e9;\nint h, w, k;\nvector<string> grid;\n\nvector<int> di = {-1, 1, 0, 0};\nvector<int> dj = {0, 0, -1, 1};\n\nbool isExit(int i, int j) {\n    return i == 0 || i == h-1 || j == 0 || j == w-1;\n}\n\nint bfs(int si, int sj) {\n    vector<vector<int>> dist(h, vector<int>(w, INF));\n    queue<tuple<int, int, int>> q; // i, j, number of casts\n    \n    q.emplace(si, sj, 0);\n    dist[si][sj] = 0;\n    \n    while (!q.empty()) {\n        auto [ci, cj, casts] = q.front();\n        q.pop();\n        \n        for (int d = 0; d < 4; ++d) {\n            int ni = ci + di[d], nj = cj + dj[d];\n            if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n            \n            int newCasts = casts + (grid[ni][nj] == '#' ? 1 : 0);\n            if (newCasts <= k && newCasts < dist[ni][nj]) {\n                dist[ni][nj] = newCasts;\n                q.emplace(ni, nj, newCasts);\n                if (isExit(ni, nj)) return newCasts;\n            }\n        }\n    }\n    return INF;\n}\n\nint main() {\n    cin >> h >> w >> k;\n    grid.resize(h);\n    \n    int si, sj;\n    for (int i = 0; i < h; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < w; ++j) {\n            if (grid[i][j] == 'S') {\n                si = i;\n                sj = j;\n            }\n        }\n    }\n    \n    int result = bfs(si, sj);\n    cout << (result == INF ? -1 : result) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:53:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve(H, W, K, grid):\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W\n\n    def find_start():\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == 'S':\n                    return i, j\n\n    def is_exit(x, y):\n        return x == 0 or x == H-1 or y == 0 or y == W-1\n\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    start_x, start_y = find_start()\n    \n    queue = deque([(start_x, start_y, 0, 0)])\n    visited = set([(start_x, start_y, 0)])\n\n    while queue:\n        x, y, casts, unlocked = queue.popleft()\n\n        if is_exit(x, y):\n            return casts\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if is_valid(nx, ny):\n                new_unlocked = unlocked\n                new_casts = casts\n\n                if grid[nx][ny] == '#':\n                    if unlocked >= K:\n                        continue\n                    new_unlocked += 1\n                    new_casts += 1\n\n                if (nx, ny, new_unlocked) not in visited:\n                    visited.add((nx, ny, new_unlocked))\n                    queue.append((nx, ny, new_casts, new_unlocked))\n\n    return -1\n\n# Read input\nH, W, K = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(H)]\n\n# Solve and print result\nprint(solve(H, W, K, grid))",
    "timestamp": "2025-08-13 14:53:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W, K = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Find the starting position 'S'\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n                break\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    INF = float('inf')\n    dist = [[INF] * W for _ in range(H)]\n    q = deque()\n    q.append((start[0], start[1], 0))\n    dist[start[0]][start[1]] = 0\n    \n    min_escape = INF\n    \n    while q:\n        i, j, casts = q.popleft()\n        # Check if current position is on the border\n        if i == 0 or i == H-1 or j == 0 or j == W-1:\n            min_escape = min(min_escape, casts)\n            continue\n        \n        if casts > min_escape:\n            continue\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                new_dist = dist[i][j] + 1\n                if grid[ni][nj] == '#':\n                    new_casts = casts + 1\n                    new_dist = 0\n                else:\n                    new_casts = casts\n                if new_casts > K:\n                    continue\n                if new_dist <= K and dist[ni][nj] > new_dist:\n                    dist[ni][nj] = new_dist\n                    if new_dist == 0:\n                        q.appendleft((ni, nj, new_casts))\n                    else:\n                        q.append((ni, nj, new_casts))\n    \n    print(min_escape + 1)\n\nsolve()",
    "timestamp": "2025-08-13 14:53:27"
  }
]