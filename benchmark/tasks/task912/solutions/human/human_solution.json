[
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e18\nusing namespace std;\n\nconst int maxn = 210000;\n\nll L,R;\nint n,pos;\nbool flag;\nint ex[maxn],id,mx;\nchar str[maxn];\nstruct node\n{\n\tll n,s[26];\n\tnode(){n=0;memset(s,0,sizeof s);}\n}f[maxn]; int ed;\ninline node operator +(node &x,node &y)\n{\n\tnode re; re.n=x.n+y.n;\n\tfor(int i=0;i<26;i++) re.s[i]=x.s[i]+y.s[i];\n\treturn re;\n}\n\nvoid dp()\n{\n\tf[0].n=pos;\n\tfor(int i=0;i<pos;i++) f[0].s[str[i]-'a']++;\n\tf[1].n=n;\n\tfor(int i=0;i<n;i++) f[1].s[str[i]-'a']++;\n\t\n\ted=1;\n\twhile(f[ed].n<inf) \n\t\tf[ed+1]=f[ed]+f[ed-1],ed++;\n}\nnode solve1(ll x)\n{\n\tll div=x/f[0].n,oth=x%f[0].n;\n\tnode re; for(int i=0;i<26;i++) re.s[i]=f[0].s[i]*div;\n\tif(oth)\n\t{\n\t\tfor(int i=0;i<oth;i++) re.s[str[i]-'a']++;\n\t}\n\treturn re;\n}\nnode solve2(ll x,int now)\n{\n\twhile(now&&f[now-1].n>=x) now--;\n\tnode re;\n\tif(now<=1)\n\t{\n\t\tfor(int i=0;i<x;i++) re.s[str[i]-'a']++;\n\t\treturn re;\n\t}\n\tre=f[now-1];\n\tnode temp=solve2(x-f[now-1].n,now-2);\n\tre=re+temp;\n\treturn re;\n}\nnode calc(ll x)\n{\n\tnode re;\n\tif(!x) return re;\n\tif(flag) re=solve1(x);\n\telse re=solve2(x,ed);\n}\n\nint main()\n{\n\tscanf(\"%s\",str); n=strlen(str); n>>=1; str[n]='$';\n\tid=1,mx=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(mx>=i) ex[i]=min(ex[i-id],mx-i);\n\t\twhile(str[i+ex[i]]==str[ex[i]]) ex[i]++;\n\t\tif(i+ex[i]-1>mx) id=i,mx=i+ex[i]-1;\n\t}\n\t\n\tflag=false;\n\tfor(pos=1;pos<n&&pos+ex[pos]-1!=n-1;pos++);\n\tif(n%pos==0) flag=true;\n\tdp();\n\t\n\tscanf(\"%lld%lld\",&L,&R);\n\tnode a1=calc(R),a2=calc(L-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",a1.s[i]-a2.s[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nchar s[111111];\nlong long l,r,g,cnt[28][100011],nn,p[28][100011],q[28][100011];\nlong long sp,sq,len[111],num[111],n1,re,sz,z[111111];\nbool f;\nlong long query(long long p,long long a)\n{\n\treturn cnt[a][g-1]*(p/g)+cnt[a][p%g];\n}\nlong long Query(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sp+sq) \n\t{\n\t\tif (pos<=sp) return p[a][pos-1];\n\t\treturn p[a][sp-1]+q[a][pos-sp-1];\n\t}\n\tlen[1]=sp;len[2]=sp+sq;re=pos-sp-sq;num[1]=p[a][sp-1];num[2]=p[a][sp-1]+q[a][sq-1];\n\tlong long res=p[a][sp-1]+q[a][sq-1];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re>=len[i-2])\n\t\t{\n\t\t\tre-=len[i-2];\n\t\t\tres+=num[i-2];\n\t\t\tnum[i]=num[i-1]+num[i-2];\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t} \n\t\telse\n\t\t{\n\t\t\tn1=i-2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlong long pre=re;\n\twhile(n1>2)\n\t{\n\t\tif (pre>=len[n1-1]) \n\t\t{\n\t\t\tres+=num[n1-1];\n\t\t\tpre=pre-len[n1-1];\n\t\t\tn1-=2;\n\t\t}\n\t\telse n1--;\n\t}\n\tif (!pre) return res;\n\tif (n1==1) res+=p[a][pre-1];\n\telse \n\t{\n\t\tif (pre<=sp) res+=p[a][pre-1];\n\t\telse res=res+p[a][sp-1]+q[a][pre-sp-1];\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tlong long ll,rr,j,k;\n\tll=0;rr=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>rr)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tll=i;rr=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-ll;\n\t\t\tif (z[k]<rr-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=rr;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tll=i;rr=j-1;z[i]=rr-ll+1;\n\t\t\t}\n\t\t}\n\t\tif (z[i]+i==sz && sz%i==0) \n\t\t{\n\t\t\tif (!f) g=i;\n\t\t\tf=1;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tfor (int i=0;i<g;i++) \n\t\t{\n\t\t\tif (z[i]+i==g) f=0;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t}\n\telse\n\t{\n\t\tnn=sz;\n\t\tfor (int i=sz-1;i>=sz/2+1;i--)\n\t\t{\n\t\t\tif (i+z[i]!=sz) continue;\n\t\t\tnn=i;\n\t\t}\n\t\tp[s[0]-'a'][0]=1;\n\t\tsp=1;\n\t\tfor (int i=1;i<sz;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') p[j][i]=p[j][i-1]+1;\n\t\t\t\telse p[j][i]=p[j][i-1];\n\t\t\t}\n\t\t\tsp++;\n\t\t}\n\t\tq[s[sz-nn]-'a'][0]=1;\n\t\tsq=1;\n\t\tfor (int i=1;i<nn*2-sz;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i+(sz-nn)]-'a') q[j][i]=q[j][i-1]+1;\n\t\t\t\telse q[j][i]=q[j][i-1];\n\t\t\t}\n\t\t\tsq++;\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",Query(r,i)-Query(l-1,i));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 20160116\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n// cf IO: I64d\n// atcoder IO: lld\nconst int Maxn=500005;\nconst long long mod=12384738759123LL;\nconst long long tim=1311;\nchar s[Maxn];\nint n;\nlong long cnt[Maxn][26],ans[26];\nlong long l,r;\nvoid Output(long long x[]){\n\tfor (int i=0;i<26;i++){\n\t\tprintf(\"%lld \",x[i]);\n\t}\n\tprintf(\"\\n\");\n\texit(0);\n}\npair<long long,vector<long long> > go(long long len,vector<long long> lfsum, long long lflen,vector<long long> rgsum,long long rglen){\n\tvector<LL> ret,newlf,newrg;\n\tret.resize(26,0);\n\tnewlf.resize(26,0);\n\tnewrg.resize(26,0);\n\tif (lflen+rglen<=len){\n\t\tfor (int i=0;i<26;i++){\n\t\t\tnewlf[i]=lfsum[i]+rgsum[i];\n\t\t\tnewrg[i]=lfsum[i];\n\t\t}\n\t\tpair<LL,vector<LL> > tmp=go(len,newlf,lflen+rglen,newrg,lflen);\n\t\tfor (int i=0;i<26;i++) ret[i]+=(tmp.second[i]);\n\t\tlen=tmp.first;\n\t}\n\tif (len>lflen){\n\t\tfor (int i=0;i<26;i++) ret[i]+=lfsum[i];\n\t\tlen-=lflen;\n\t}\n\treturn mp(len,ret); \n}\nvector<long long> solve(long long target,int pre){\n\tvector<LL> lf,rg;\n\tlf.resize(26),rg.resize(26,0);\n\tfor (int i=0;i<26;i++){\n\t\tlf[i]=cnt[n-pre][i];\n\t\trg[i]=cnt[n][i]-cnt[n-pre][i];\n\t}\n\tpair<LL,vector<LL> > res=go(target,lf,(LL)n-pre,rg,(LL)pre);\n\tfor (int i=0;i<26;i++){\n\t\t(res.second)[i]+=cnt[res.first][i];\n\t} \n\treturn res.second;\n}\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tn/=2;\n\tscanf(\"%lld %lld\",&l,&r);\n\tlong long hashval1=0,hashval2=0;\n\tlong long now=1;\n\tint len=0;\n\tfor (int i=0;i<n-1;i++){\n\t\thashval1=hashval1*tim;\n\t\thashval1+=(int)s[i];\n\t\thashval2+=now*(int)s[n-i-1];\n\t\thashval1%=mod;\n\t\thashval2%=mod;\n\t\tnow*=tim;\n\t\tnow%=mod;\n\t\tif (hashval1==hashval2){\n\t\t\tlen=i+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++){\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tl--;\n\tif (len==0){\n\t\tfor (int i=0;i<26;i++){\n\t\t\tans[i]+=cnt[n][i]*(r/n);\n\t\t\tans[i]-=cnt[n][i]*(l/n);\n\t\t\tans[i]+=cnt[r%n][i];\n\t\t\tans[i]-=cnt[l%n][i];\n\t\t}\n\t\tOutput(ans);\n\t\treturn 0;\n\t}\n\tvector<LL> ans1=solve(r,len);\n\tvector<LL> ans2=solve(l,len);\n\tfor (int i=0;i<26;i++){\n\t\tans1[i]-=ans2[i];\n\t\tprintf(\"%lld \",ans1[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MX=400005;\nconst LL MXP=1000000000000000000ll;\n\nchar s[MX];int n;int bd[MX];\nint T;\nLL len[201],cf[201][26];\nLL c[MX][26];\nint typ;\n#define A(x,y) for(int iA=0;iA<26;iA++)x[iA]+=y[iA]\nvoid ini(){\n\tbd[0]=0;\n\tn=strlen(s);\n\tfor(int i=1;i<n;i++){\n\t\tint t=bd[i-1];\n\t\twhile(t&&s[t]!=s[i])t=bd[t-1];\n\t\tbd[i]=(s[t]==s[i]?t+1:0);\n\t}\n\tint l=bd[n-1];\n\twhile(l>=n/2)l=bd[l-1];\n\tn-=l;\n\tmemset(s+n,0,sizeof(char)*l);\n\tcerr<<s<<endl;\n\tT=n-bd[n-1];//最小正周期 \n\tcerr<<T<<endl;\n\tfor(int i=0;i<n;i++){\n\t\tif(i)memcpy(c[i],c[i-1],sizeof(c[i]));\n\t\tc[i][s[i]-'a']++;\n\t}\n\tif(bd[n-1]%T){//fib\n\t\ttyp=0;\n\t\tlen[1]=n,len[2]=n+T;\n\t\tfor(int i=0;i<26;i++)memcpy(cf[1],c[n-1],sizeof(cf[1]));\n\t\tmemcpy(cf[2],cf[1],sizeof(cf[1]));\n\t\tA(cf[2],c[T-1]);\n\t\tfor(int i=3;;i++){\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t\tmemcpy(cf[i],cf[i-1],sizeof(cf[i-1]));\n\t\t\tA(cf[i],cf[i-2]);\n\t\t\tif(len[i]>MXP)break;\n\t\t}\n\t}else{//cycle\n\t\ttyp=1;\n\t}\n}\nLL cal(LL x,int ch){\n\tif(!x)return 0;\n\tif(typ)return (x%T?c[x%T-1][ch]:0)+c[T-1][ch]*(x/T);\n\telse{\n\t\tif(x<=n)return c[x-1][ch];\n\t\tfor(int i=1;;i++){\n\t\t\tif(len[i+1]>x)return cf[i][ch]+cal(x-len[i],ch);\n\t\t}\n\t}\n}\nint main(){\n\tcin>>s;\n\tini();\n\tLL L,R;cin>>L>>R;\n\tfor(int i=0;i<26;i++)cout<<cal(R,i)-cal(L-1,i)<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,pl,g;\nll qz[SZ],hz[SZ];\nchar s[SZ]; ll l,r;\nstruct arr {ll c[26];}clr;\narr operator + (arr a,arr b)\n{for(int i=0;i<26;++i) a.c[i]+=b.c[i]; return a;}\narr operator - (arr a,arr b)\n{for(int i=0;i<26;++i) a.c[i]-=b.c[i]; return a;}\narr ps[SZ]; ll len[SZ];\narr calc(char*l,char*r)\n{\n\tarr g=clr;\n\twhile(l!=r) ++g.c[*(l++)-'a'];\n\treturn g;\n}\narr qry(int r,ll p)\n{\n\tif(!p) return clr;\n\tif(r<=1) return calc(s+1,s+p+1);\n\tif(p<=len[r-1]) return qry(r-1,p);\n\treturn ps[r-1]+qry(r-2,p-len[r-1]);\n}\narr qry(ll p)\n{return qry(g,p);}\nint main()\n{\n\tmemset(&clr,0,sizeof clr);\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1); n/=2; s[n+1]=0;\n\tfor(int i=1;i<=n;++i)\n\t\tqz[i]=qz[i-1]*233+s[i];\n\t{\n\tll po=1;\n\tfor(int i=n;i>=1;--i)\n\t\thz[i]=hz[i+1]+ll(s[i])*po,po*=233;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(qz[n-i]==hz[i+1])\n\t\t{pl=i; break;}\n\tlen[0]=pl; len[1]=n;\n\tps[0]=calc(s+1,s+pl+1);\n\tps[1]=calc(s+1,s+n+1);\n\tfor(int i=2;;++i)\n\t{\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tps[i]=ps[i-1]+ps[i-2];\n\t\tif(len[i]>1e18) {g=i; break;}\n\t}\n\tarr ans=qry(r)-qry(l-1);\n\tfor(int i=0;i<26;++i)\n\t\tprintf(\"%lld \",ans.c[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tif (n%k==0){\n\t\t\tr-=n;\n\t\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']++;\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=r/k;\n\t\t\tfor (ll i=0;i<r%k;i++) w[s[i]-'a']++;\n\t\t}else{\n\t\t\tll _s=0,_t=1,S=1,T=0;\n\t\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\t\twork(r-_s*n-_t*k);\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nchar S[202020];\nint F[202020], L;\nlong long x[100], y[100], cntx[100][26], cnty[100][26], ans[26];\n\nvoid go(int p, long long l, long long r)\n{\n\tif (r <= L){\n\t\twhile (l < r){\n\t\t\tans[S[l]-'a']++;\n\t\t\tl++;\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long w = 0;\n\tfor (int k=0;;k++){\n\t\tlong long a = (k%3==1?y[p]:x[p]);\n\t\tlong long u = max(l, w);\n\t\tlong long v = min(r, w+a);\n\t\tif (r <= w) break;\n\t\tif (v - u == a){\n\t\t\tif (k % 3 == 1) for (int k=0;k<26;k++) ans[k] += cnty[p][k];\n\t\t\telse for (int k=0;k<26;k++) ans[k] += cntx[p][k];\n\t\t}\n\t\telse if (u < v) go(p-1, u-w, v-w);\n\t\tw += a;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\", S);\n\n\tint l = 0;\n\twhile (S[l]) l++;\n\tL = l;\n\n\tint k = -1; F[0] = -1;\n\tfor (int i=1;i<l;i++){\n\t\twhile (k >= 0 && S[k+1] != S[i]) k = F[k];\n\t\tif (S[k+1] == S[i]) k++;\n\t\tF[i] = k;\n\t}\n\n\tint u = l-1;\n\twhile ((u + 1) > l / 2) u = F[u];\n\tint r = l - (u + 1) * 2;\n\n\tconst long long lim = (long long)1e18 + 10;\n\tint v = F[u+r];\n\tfor (int i=0;i<=v;i++) cntx[0][S[i]-'a']++;\n\tfor (int i=v+1;i<=u+r-v-1;i++) cnty[0][S[i]-'a']++;\n\tx[0] = v + 1;\n\ty[0] = u+r-v-1 - v;\n\n\tint p = 1;\n\twhile (1){\n\t\tfor (int k=0;k<26;k++){\n\t\t\tcntx[p][k] = cntx[p-1][k] + cnty[p-1][k];\n\t\t\tcnty[p][k] = cntx[p-1][k];\n\t\t}\n\t\tx[p] = x[p-1] + y[p-1];\n\t\ty[p] = x[p-1];\n\t\tif (x[p] > lim) break;\n\t\tp++;\n\t}\n\t{\n\t\tlong long l, r;\n\t\tscanf(\"%lld %lld\", &l, &r);\n\t\tgo(p, l-1, r);\n\t}\n\tfor (int i=0;i<26;i++) printf(\"%lld%c\", ans[i], i+1<26?' ':'\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\nusing namespace std;\n\n#define Rep(i,l,r) for (int i = (l); i <= (r); ++ i)\n#define RepD(i,r,l) for (int i = (r); i >= (l); -- i)\n#define RepG(i,x) for (int i = hd[x]; i; i = e[i].nxt)\n\ntypedef long long ll;\nconst int N = 4e5+5;\nint n, bd, f[N][35], ne[N]; ll l, r;\nchar s[N];\n\nvoid pre () {\n\tRep(i,1,n) {\n\t\t++ f[i][s[i]-'a'+1];\n\t\tRep(j,1,26) f[i][j] += f[i-1][j];\n\t}\n\tint t = 2, k = ne[1] = 0;\n\twhile (t<=n) {\n\t\twhile (k && s[k+1]!=s[t]) k = ne[k];\n\t\tif (s[k+1]==s[t]) ++ k; ne[t++] = k;\n\t}\n\tbd = n-ne[n];\n}\n\nll calc (ll k, int c) {\n\tif (k<=n) return f[k][c];\n\tif (k<=(n<<1)) return f[n][c]+f[k-n][c];\n\tll lsf = f[n][c], nwf = f[n][c]+f[bd][c], lsl = n, nwl = n+bd;\n\twhile (k>lsl+nwl) {\n\t\tswap (lsl, nwl); nwl = lsl+nwl;\n\t\tswap (lsf, nwf); nwf = lsf+nwf;\n\t}\n\treturn nwf+calc (k-nwl, c);\n}\n\nint main () {\n\tscanf (\"%s%I64d%I64d\", s+1, &l, &r);\n\tn = strlen (s+1)>>1; pre ();\n\tRep(i,1,26) printf (\"%I64d \", calc (r,i)-calc (l-1,i));\n\tputs (\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,m,i,j,ha[200005],cm[200005],f[205][26],sum[205],flag,l,r,ans[26];\nchar s[200005];\nlong long minn(long long u,long long v){\n\treturn u<v?u:v;\n}\nlong long hash(long long u,long long v){\n\treturn ha[v]-ha[u-1]*cm[v-u+1];\n}\nint main(){\n\t//freopen(\"7.in\",\"r\",stdin);\n    //freopen(\"7.out\",\"w\",stdout);\n   \tscanf(\"%s\",s+1);\n   \tn=strlen(s+1);\n   \tn>>=1;\n   \tl=read()-1;r=read();\n   \tcm[0]=1;\n   \tfor(i=1;i<=n;i++)\n   \t\tcm[i]=cm[i-1]*101;\n   \tfor(i=1;i<=n;i++)\n   \t\tha[i]=ha[i-1]*101+s[i]-'a'+1;\n   \tfor(i=1;i<=n;i++){\n   \t\tflag=0;\n   \t\tfor(j=1;j<=n;j+=i)\n\t\t\tif(hash(1,minn(i,n-j+1))!=hash(j,minn(j+i-1,n))){\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(flag==0){\n\t\t\tflag=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(i<=flag)\n\t\t\tf[0][s[i]-'a']++;\n\t\tf[1][s[i]-'a']++;\n\t}\n\tsum[0]=flag;\n\tsum[1]=n;\n\tfor(i=2;sum[i-1]+sum[i-2]<r;i++){\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t\tfor(j=0;j<=25;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t}\n\tm=i-1;\n\tfor(i=m;i>=0;i--)\n\t\tif(r>=sum[i]){\n\t\t\tr-=sum[i];\n\t\t\tfor(j=0;j<=25;j++)\n\t\t\t\tans[j]+=f[i][j];\n\t\t}\n\tfor(i=1;i<=r;i++)\n\t\tans[s[i]-'a']++;\n\tfor(i=m;i>=0;i--)\n\t\tif(l>=sum[i]){\n\t\t\tl-=sum[i];\n\t\t\tfor(j=0;j<=25;j++)\n\t\t\t\tans[j]-=f[i][j];\n\t\t}\n\tfor(i=1;i<=l;i++)\n\t\tans[s[i]-'a']--;\n\tfor(i=0;i<=25;i++)\n\t\tpus(ans[i],1);\n\tcout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = false;\n\ts = conv(s);\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 1; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200010;\nstring x;\nll l,r;\nint fail[maxn];\nstruct ZMB{\n\tll a[27];\n\tvoid out()\n\t{\n\t\tfor(int i=1;i<=26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",a[i]);\n\t\t}\n\t}\n}ans,p[maxn],sum[maxn];\nZMB operator+(ZMB a,ZMB b)\n{\n\tstatic ZMB tmp;\n\tfor(int i=1;i<=26;i++)\n\t{\n\t\ttmp.a[i]=a.a[i]+b.a[i];\n\t}\n\treturn tmp;\n}\nZMB operator*(ll a,ZMB b)\n{\n\tstatic ZMB tmp;\n\tfor(int i=1;i<=26;i++)\n\t{\n\t\ttmp.a[i]=a*b.a[i];\n\t}\n\treturn tmp;\n}\nll len[maxn];\nint MAX;\nvoid f_f()\n{\n\tint L=x.length();\n\tL>>=1;\n\tint i,j;\n\tfor(i=1;i<=L;i++)\n\t{\n\t\tp[i]=p[i-1];\n\t\tp[i].a[x[i-1]-'a'+1]++;\n\t}\n\tfor(i=2,j=0;i<=L;i++)\n\t{\n\t\twhile(j&&x[i-1]!=x[j])j=fail[j];\n\t\tif(x[i-1]==x[j])j+=1;\n\t\tfail[i]=j;\n\t}\n}\nll lth;\nvoid ans1(ll m,ll a)\n{\n\tif(m<=0)return;\n\tll k=m/lth;\n\tans=ans+(k*a*p[lth]);\n\tk=m%lth;\n\tans=ans+p[k];\n}\nvoid bef()\n{\n\tlen[1]=x.length()/2;\n\tfor(int i=1;i<=len[1];i++)\n\t{\n\t\tsum[1].a[x[i-1]-'a'+1]+=1;\n\t}\n\tsum[2]=sum[1];\n\tlen[2]=len[1]+lth;\n\tsum[2]=sum[2]+p[lth];\n\tfor(int i=3;i;i++){\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tif(len[i]>=r){\n\t\t\tMAX=i;\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid ans2(ll m,ll a)\n{\n\tif(m<=0) return;\n\tfor(int i=MAX;i;i--)\n\t{\n\t\tif(len[i]<=m){\n\t\t\tm-=len[i];\n\t\t\tans=ans+(a*sum[i]);\n\t\t}\n\t}\n\tans=ans+(a*p[m]);\n}\nint main()\n{\n\tcin>>x;\n\tscanf(\"%lld%lld\",&l,&r);\n\tf_f();\n\tlth=x.length()/2;\n\tint tmp=lth;\n\tlth=lth-fail[lth];\n\tif(!(tmp%lth)){\n\t\tans1(r,1);\n\t\tans1(l-1,-1);\n\t}\n\telse{\n\t\tbef();\n\t\tans2(r,1);\n\t\tans2(l-1,-1);\n\t}\n\tans.out();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\n\nvector<int>Z_Algorithm(const string&s) {\n    int n=s.size();\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && s[r-l] == s[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && s[r-l] == s[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=2; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    assert(R <= N);\n    REP (i, R) ans[S[i]-'a'] += sgn;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    N /= 2;\n    VI z = Z_Algorithm(string(S, S+N));\n    \n    int pos = N;\n    for (int i=1; i<N; i++) if (i + z[i] == N) {\n\tpos = i;\n\tbreak;\n    }\n\n    len[0] = pos;\n    len[1] = N;\n    REP (i, N) {\n\tif (i < pos) C[0][S[i]-'a']++;\n\tC[1][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n//    puts(S);\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    assert(len[LEVEL-1] > r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200100,M=1000;\ntypedef long long ll;\nint f[N],n;\nll tmp[M][26],len[M],ans[26],l,r;\nchar s[N];\n\nvoid MP(){\n\tint j=f[0]=-1;f[1]=0;\n\tfor(int i=1;i<n;f[++i]=++j)\n\t\tfor(;~j&&s[i]!=s[j];j=f[j]);\n}\n\nvoid solve1(ll lim,int op){\n\tmemset(tmp,0,sizeof tmp);\n\tfor(int j=0;j<n+n-f[n];++j){\n\t\tif(j<n)tmp[0][s[j]]++;\n\t\ttmp[1][s[j]]++;\n\t}\n\tlen[0]=n;len[1]=n+n-f[n];\n\tint i=2;\n\tfor(;len[i-1]<=lim;++i){\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tfor(int j=0;j<26;++j)tmp[i][j]=tmp[i-1][j]+tmp[i-2][j];\n\t\tll sum=0;\n\t\tfor(int j=0;j<26;++j)sum+=tmp[i][j];\n\t\tassert(sum==len[i]);\n\t}\n\tfor(i-=2;i>=0;--i)\n\t\tif(lim>=len[i]){\n\t\t\tfor(int k=0;k<26;++k)ans[k]+=tmp[i][k]*op;\n\t\t\tlim-=len[i];\n\t\t}\n\tfor(int j=0;j<lim;++j)ans[s[j]]+=op;\n}\n\nvoid solve2(ll lim,int op){\n\tfor(int i=0;i<(n-f[n]);++i)\n\t\tans[s[i]]+=(lim+n-f[n]-i)/(n-f[n])*op;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>s>>l>>r;n=strlen(s)/2;\n\tfor(int i=0;i<2*n;++i)s[i]-='a';MP();\n\tif(n%(n-f[n])){solve1(r,1);solve1(l-1,-1);}\n\telse{solve2(r,1);solve2(l-1,-1);}\n\tfor(int i=0;i<26;++i)cout<<ans[i]<<\" \\n\"[i==25];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=255555;\ntypedef long long LL;\nstruct data{\n\tLL len,a[26];\n\tinline void operator+=(const data&rhs){\n\t\tlen+=rhs.len;\n\t\tfor(int i=0;i<26;++i)a[i]+=rhs.a[i];\n\t}\n\tinline data operator-(const data&rhs)const{\n\t\tdata c;\n\t\tc.len=0;\n\t\tfor(int i=0;i<26;++i)c.a[i]=a[i]-rhs.a[i];\n\t\treturn c;\n\t}\n}d[500],ans;\nchar s[N];\nint fail[N],n;\nLL L,R;\nvoid getfail(){\n    for(int i=2,j=0;i<=n;++i){\n        while(j&&s[j+1]!=s[i])j=fail[j];\n        if(s[j+1]==s[i])++j;\n        fail[i]=j;\n    }\n}\ndata solve(LL R){\n\tdata ret;\n\tfor(int i=ret.len=0;i<26;++i)ret.a[i]=0;\n\tif(n%(n-fail[n])==0){\n\t\tLL k=R/n;\n\t\tfor(int i=1;i<=n;++i)ret.a[s[i]-'a']+=k;\n\t\tfor(int i=1;i<=R%n;++i)++ret.a[s[i]-'a'];\n\t}else{\n\t\tmemset(d,0,sizeof d);\n\t\tint tot=2;\n\t\td[2].len=n;\n\t\tfor(int i=1;i<=n;++i)++d[2].a[s[i]-'a'];\n\t\td[1].len=n-fail[n];\n\t\tfor(int i=1;i<=n-fail[n];++i)++d[1].a[s[i]-'a'];\n\t\twhile(d[tot].len<=R){\n\t\t\t++tot;\n\t\t\td[tot]=d[tot-1],d[tot]+=d[tot-2];\n\t\t}\n\t\tfor(int i=tot;i;--i)\n\t\tif(R>=d[i].len)R-=d[i].len,ret+=d[i];\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&L,&R);\n\tn=strlen(s+1)>>1;\n\tgetfail();\n\tans=solve(R);\n\tans=ans-solve(L-1);\n\tfor(int i=0;i<26;++i)\n\tprintf(\"%lld \",ans.a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\n#define rl rd<LL>\nusing namespace std;\ntypedef long long LL;\nconst int maxN = 2e5 + 7;\nconst int maxC = 26;\nconst int maxM = 127;\nconst LL INF = 1e18;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nchar s[maxN];\nint n, len, t;\nint nx[maxN];\nLL occ[maxC];\nLL L, R;\n\nvoid kmp() {\n\tnx[1] = 0; int i, j;\n\tfor (i = 2, j = 0; i <= n; ++ i) {\n\t\twhile (j && s[j+1] != s[i]) j = nx[j];\n\t\tif (s[j+1] == s[i]) ++ j;\n\t\tnx[i] = j;\n\t}\n}\n\nvoid solve1(LL len, LL kd) {\n\tLL tms = len / t, res = len % t;\n\trep (i, 1, t) occ[s[i] - 'a'] += kd * (tms + (i <= res));\n}\n\nnamespace solve2 {\n\tLL f[maxM][maxC], len[maxM], Top;\n\t\n\tvoid init() {\n\t\tlen[1] = t; rep (i, 1, t) ++ f[1][s[i] - 'a'];\n\t\tlen[0] = n - 2 * t; rep (i, t+1, n-t) ++ f[0][s[i] - 'a'];\n\t\tFor (i, 2, maxM) {\n\t\t\tlen[i] = len[i-1] + len[i-2];\n\t\t\tTop = i;\n\t\t\tFor (j, 0, maxC) f[i][j] = f[i-1][j] + f[i-2][j];\n\t\t\tif (len[i] > INF) break;\n\t\t}\n\t}\n\n\tvoid dfs(int p, LL l, LL kd) {\n\t\tif (l <= 0) return;\n\t\tassert(l <= len[p]);\n\t\tif (l == len[p]) {\n\t\t\tFor (i, 0, 26) occ[i] += kd * f[p][i];\n\t\t\treturn;\n\t\t}\n\t\tif (p == 0 || p == 1) {\n\t\t\tint bg = (p == 1) ? 0 : t;\n\t\t\trep (i, 1, l) occ[s[bg+i] - 'a'] += kd;\n\t\t\treturn;\n\t\t}\n\t\tdfs(p-1, min(l, len[p-1]), kd);\n\t\tdfs(p-2, l - len[p-1], kd);\n\t}\n\n\tvoid work(LL l, LL kd) {\n\t\tdfs(Top, l, kd);\n\t}\n}\n\nint main() {\n\n\tscanf(\"%s\", s+1);\n\tL = rl(), R = rl();\n\tn = strlen(s+1) >> 1;\n\tlen = (n + 1) >> 1;\n\tkmp();\n\t\n\tt = n - nx[n];\n\tif (n % t == 0) solve1(R, 1), solve1(L-1, -1);\n\telse {\n\t\tfor (t = nx[n]; t >= len; t = nx[t]);\n\t\tsolve2::init(), solve2::work(R, 1), solve2::work(L-1, -1);\n\t}\n\n\tFor (i, 0, 26) printf(\"%lld%c\", occ[i], \" \\n\"[i == 25]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int N=2e6+7;\nchar s[N];\nint f[N],n,n1,n2,n3;\ni64 l,r;\nvoid ext(){\n\tfor(int i=2,j=0;i<=n;++i){\n\t\twhile(j&&s[i]!=s[j+1])j=f[j];\n\t\tif(s[i]==s[j+1])++j;\n\t\tf[i]=j;\n\t}\n\tint p=f[n];\n\twhile(p*2>=n)p=f[p];\n\tmemcpy(s+n-p+1,s+1,n-p);\n\tn+=n-p*2;\n}\nint t[333],ts[2][333];\ni64 ans[333];\nvoid cal1(i64 x,int sgn){\n\tmemset(t,0,sizeof(t));\n\tfor(int i=1;i<=x%n;++i)++t[s[i]];\n\tfor(int i='a';i<='z';++i)ans[i]+=t[i]*sgn;\n\tfor(int i=x%n+1;i<=n;++i)++t[s[i]];\n\tfor(int i='a';i<='z';++i)ans[i]+=t[i]*sgn*(x/n);\n}\nvoid cal1(){\n\tn=n2-n1;\n\tcal1(r,1),cal1(l-1,-1);\n}\ni64 fs[207][2],len[207];\nint mx;\nvoid cal2(i64 x,int sgn){\n\tfor(int i=mx;i>=2;--i)if(len[i]<=x){\n\t\tx-=len[i];\n\t\tfor(int j='a';j<='z';++j)ans[j]+=sgn*(fs[i][0]*ts[0][j]+fs[i][1]*ts[1][j]);\n\t}\n\tcal1(x,sgn);\n}\nvoid cal2(){\n\tn1/=2,n2/=2,n3/=2,n/=2;\n\tfor(int i=1;i<=n1;++i)++ts[0][s[i]];\n\tfor(int i=n1+1;i<=n2;++i)++ts[1][s[i]];\n\tlen[0]=n1,len[1]=n2;\n\tfs[0][0]=fs[1][0]=fs[1][1]=1;\n\tmx=1;\n\tdo{\n\t\t++mx;\n\t\tlen[mx]=len[mx-1]+len[mx-2];\n\t\tfs[mx][0]=fs[mx-1][0]+fs[mx-2][0];\n\t\tfs[mx][1]=fs[mx-1][1]+fs[mx-2][1];\n\t}while(len[mx]<r);\n\tcal2(r,1),cal2(l-1,-1);\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1);\n\text();\n\tn1=n;\n\text();\n\tn2=n;\n\text();\n\tn3=n;\n\tif(n2-n1==n3-n2)cal1();\n\telse cal2();\n\tfor(int i='a';i<='z';++i)printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n#define N 200005\n\nchar ch[N];\nint p[N];\nlong long a[30];\nint n,len;\nlong long ans[30][1005];\nlong long length[N];\nlong long l,r;\n\nvoid work(long long x,int flag)\n{\n\tif (x == 0) return ;\n\tlong long tmp = 0;\n\tif (x <= len)\n\t{\n\t\tfor(int i = 1;i <= x;i++)\n\t\t{\n\t\t\ta[ch[i] - 'a'] += flag;\n\t\t}\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tint t = 1;\n\t\twhile(length[t + 1] <= x) t++;\n\t\tfor(int i = 0; i < 26;i++)\n\t\t{\n\t\t\ta[i] += ans[i][t] * flag;\n\t\t}\n\t\twork(x - length[t],flag);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"test.in\",\"r\",stdin);\n\tint j = 0;\n\tscanf(\"%s%lld%lld\",ch + 1,&l,&r);\n\tlen = strlen(ch + 1);\n\t//p[1] = 0;\n\tfor(int i = 2;i <= len; i++)\n\t{\n\t\twhile(j > 0 && ch[j + 1] != ch[i]) j = p[j];\n\t\tif (ch[j + 1] == ch[i]) j++;\n\t\tp[i] = j;\n\t//\tprintf(\"%d \",p[i]);\n\t}\n\t//puts(\"\");\n\tlen >>= 1;\n\tn = len - p[len];\n\t//printf(\"%d %d\\n\",len,n);\n\tif( len % n == 0)\n\t{\n\t\tfor(int i = 1;i <= n;i++) a[ch[i] - 'a'] += (long long)r/n;\n\t\tfor(int i = 1;i <= r % n; i++) a[ch[i] - 'a']++;\n\t\tfor(int i = 1;i <= n;i++) a[ch[i] - 'a'] -= (long long)(l - 1)/n;\n\t\tfor(int i = 1;i <= (l - 1) % n;i++) a[ch[i] - 'a']--;\t\n\t}\n\telse\n\t{\n\t\tfor(int i = 1;i <= n; i++)\n\t\t{\n\t\t\tans[ch[i] - 'a'][0]++;\n\t\t}\n\t\tfor(int i = 1;i <= len; i++)\n\t\t{\n\t\t\tans[ch[i] - 'a'][1]++;\n\t\t}\n\t\tlength[0] = n;\n\t\tlength[1] = len;\n\t\tfor(int i = 2;;i++)\n\t\t{\n\t\t\tlength[i] = length[i - 1] + length[i - 2];\n\t\t\tif(length[i] > r) break;\n\t\t\tfor(int j = 0; j < 26; j++)\n\t\t\t\tans[j][i] = ans[j][i - 1] + ans[j][i - 2];\n\t\t}\n\t\twork(r,1);work(l - 1,-1);\n\t}\n\tfor(int i = 0; i < 26; i++)\n\t{\n\t\tprintf(\"%lld \",a[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, x, y) for(int i = (x), _ = (y); i <= _; ++ i)\n\ntypedef long long LL;\n\nconst int maxN = 2e5 + 5;\n\nchar s[maxN];\nLL fib[100];\nint fail[maxN];\nint lens, lent;\nLL ansl[26], ansr[26], L; \nint sums[26], sumt[26];\n\nvoid getans(LL Bnd, LL ans[])\n{\n\tif(Bnd < lens)\n\t{\n\t\trep(i, 1, Bnd) ans[s[i] - 'a']++;\n\t\treturn;\n\t}\n\trep(i, 0, 90) if(fib[i] * lent + fib[i + 1] * lens > Bnd)\n\t{\n\t\trep(j, 0, 25) ans[j] += fib[i - 1] * sumt[j] + fib[i] * sums[j];\n\t\tgetans(Bnd - fib[i - 1] * lent - fib[i] * lens, ans);\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tfib[0] = 0; fib[1] = 1;\n\trep(i, 2, 90) fib[i] = fib[i - 1] + fib[i - 2];\n\tscanf(\"%s\", s + 1);\n\tlens = strlen(s + 1) >> 1;\n\tfail[0] = fail[1] = 0;\n\trep(i, 2, lens)\n\t{\n\t\tint tmp = fail[i - 1];\n\t\twhile(tmp && s[tmp + 1] != s[i]) tmp = fail[tmp];\n\t\tfail[i] = s[tmp + 1] == s[i] ? tmp + 1 : 0;\n\t}\n\tlent = lens - fail[lens];\n\trep(i, 1, lent) sumt[s[i] - 'a']++;\n\trep(i, 1, lens) sums[s[i] - 'a']++;\n\tscanf(\"%lld\", &L), getans(L-1, ansl);\n\tscanf(\"%lld\", &L), getans(L, ansr);\n\trep(i, 0, 25) printf(\"%lld \", ansr[i] - ansl[i]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nstring trans(string s) {\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s.substr(0, i) == s.substr(s.size() - i, i)) {\n            string b = s.substr(0, s.size() - i);\n            return s + b;\n        }\n    }\n    assert(false);\n    return \"\";\n}\nvoid stupid() {\n    while (true) {\n        string s;\n        int p = rand() % 7 + 2;\n        for (int i = 0; i < p; i++) {\n            s += (char) (rand() % 2 + 'a');\n        }\n        string ns = trans(s);\n        int blen = ns.size() - s.size();\n        int slen = s.size() - blen;\n//        if (blen <= slen) continue;\n        bool f1 = (slen == 0);\n        bool f2 = (s.size() % blen == 0);//(blen <= slen);\n        if (blen <= slen && !f2) {\n            s = ns;\n            ns = trans(s);\n            blen = ns.size() - s.size();\n            slen = s.size() - blen;\n            assert(blen > slen);\n        }\n        string init = s;\n        s = ns;\n        for (int step = 0; step < 10; step++) {\n            string ns = trans(s);\n            int hisb = ns.size() - s.size();\n            int hiss = s.size() - hisb;\n            if (f1) {\n                assert(hisb == blen);\n            }\n            else if (f2) {\n                assert(hisb == blen);\n            }\n            else {\n//            if (hiss != blen) {\n//                cout << init << \" GG \" << s << \" \" << ns << \" \" << hiss << \" \" << blen << endl;\n//            }\n                assert(hiss == blen);\n            }\n            blen = hisb;\n            slen = hiss;\n//            cout << s << \" -> \" << ns << endl;\n            s = ns;\n        }\n    }\n}\nstring s;\nll l, r;\nvector < int > z_function(string& s) {\n    vector < int > z(s.size());\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < s.size(); i++) {\n        if (r < i) {\n            l = r = i;\n        }\n        z[i] = min(r - i, z[i - l]);\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\nll ans[26];\nll len[100];\nll lenB[100];\nll lenS[100];\nconst ll INF = 1e18 + 2;\nconst int maxN = 2e5 + 10;\nint pref[26][maxN];\nll calcB(ll r, int c, int who);\nll calcS(ll r, int c, int who);\nll calc(ll r, int c, int who);\nmap < pair < pair < ll, int >, int >, ll > mp, mpB, mpS;\nll calc(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mp.find({{r, c}, who}) != mp.end()) return mp[{{r, c}, who}];\n    ll& d = mp[{{r, c}, who}];\n    if (r <= lenB[who] - 1) {\n        return d = calc(r, c, who - 1);\n    }\n    return d = calc(lenB[who] - 1, c, who - 1) + calcB(r - lenB[who], c, who - 1);\n}\nll calcB(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpB.find({{r, c}, who}) != mpB.end()) return mpB[{{r, c}, who}];\n    ll& d = mpB[{{r, c}, who}];\n    if (r <= lenB[who] - 1) {\n        return d = calcB(r, c, who - 1);\n    }\n    return d = calcB(lenB[who] - 1, c, who - 1) + calcS(r - lenB[who], c, who - 1);\n}\nll calcS(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpS.find({{r, c}, who}) != mpS.end()) return mpS[{{r, c}, who}];\n    ll& d = mpS[{{r, c}, who}];\n    return d = calcB(r, c, who - 1);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> s;\n    s = s.substr(0, s.size() / 2);\n    cin >> l >> r;\n    l--;\n    r--;\n    auto zz = z_function(s);\n    int n = s.size();\n    int blen = 0;\n    int slen = 0;\n    for (int i = 1; i < n; i++) {\n        if (zz[i] == n - i) {\n            blen = i;\n            slen = n - i;\n            break;\n        }\n    }\n    if (blen == 0 && slen == 0) {\n        blen = n;\n    }\n    if (n % blen == 0) {\n        string f = s.substr(0, blen);\n        for (int i = 0; i < f.size(); i++) {\n            // blen * k + i >= l\n            // blen * k + i <= r\n            ll at_least = max(0LL, (l - i + blen - 1) / blen);\n            ll at_most = (i > r ? -1 : (r - i) / blen);\n            ans[f[i] - 'a'] += max(0LL, at_most - at_least + 1);\n        }\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n    }\n    else {\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < n; i++) {\n                pref[j][i] = ((s[i] - 'a') == j);\n                if (i) pref[j][i] += pref[j][i - 1];\n            }\n        }\n        len[0] = s.size();\n        lenB[0] = blen;\n        lenS[0] = slen;\n        int who = -1;\n        for (int i = 1; i < 100; i++) {\n            if (len[i - 1] - 1 >= r) {\n                who = i - 1;\n                break;\n            }\n            lenS[i] = lenB[i - 1];\n            lenB[i] = len[i - 1];\n            len[i] = lenB[i] + lenS[i];\n        }\n        assert(who != -1);\n        for (int i = 0; i < 26; i++) {\n            ans[i] = calc(r, i, who);\n            if (l) ans[i] -= calc(l - 1, i, who);\n            cout << ans[i] << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int SIGMA = 26;\nvoid print(vector<ll> a) {\n    for (int i = 0; i < (int)a.size(); i++) printf(\"%lld%c\", a[i], \" \\n\"[i + 1 == (int)a.size()]);\n}\n\nvector<int> getPr(string s) {\n    int n = s.length();\n    vector<int> pr(n);\n    for (int i = 1; i < n; i++) {\n        pr[i] = pr[i - 1];\n        while (pr[i] > 0 && s[i] != s[pr[i]]) pr[i] = pr[pr[i] - 1];\n        pr[i] += s[i] == s[pr[i]];\n    }\n    return pr;\n}\n\nstring f(string s) {\n    int n = s.length();\n    auto pr = getPr(s);\n\n    int per = -1;\n    int len = (int)1e9;\n    for (int x = pr[n - 1];; x = pr[x - 1]) {\n        int cper = n - x;\n        int cn = n;\n        cn = cn / cper * cper + cper;\n        if (cn / cper % 2 == 1) cn += cper;\n        if (len > cn) {\n            len = cn;\n            per = cper;\n        }\n        if (x == 0) break;\n    }\n    while (s.length() < len) {\n        char c = s[s.length() % per];\n        s += c;\n    }\n    return s;\n}\n\nvector<ll> solve(string s, ll r) {\n    vector<ll> ans(SIGMA);\n\n    string t = f(s);\n    t = t.substr(0, t.length() / 2);\n\n    int m = t.length();\n    auto pr = getPr(t);\n    int per = m - pr[m - 1];\n\n    vector<pair<ll, vector<ll> > > vct;\n    vct.push_back({m - per, vector<ll>(SIGMA)});\n    for (int i = per; i < m; i++) vct.back().second[t[i] - 'a']++;\n    vct.push_back({per, vector<ll>(SIGMA)});\n    for (int i = 0; i < per; i++) vct.back().second[t[i] - 'a']++;\n\n    while (vct.back().first < r) {\n        auto x = vct[(int)vct.size() - 1];\n        auto y = vct[(int)vct.size() - 2];\n        auto z = make_pair(x.first + y.first, vector<ll>(SIGMA));\n        for (int i = 0; i < SIGMA; i++) {\n            z.second[i] = x.second[i] + y.second[i];\n        }\n        vct.push_back(z);\n    }\n    while (vct.size() > 2) {\n        if (r >= vct.back().first) {\n            r -= vct.back().first;\n            for (int i = 0; i < SIGMA; i++) ans[i] += vct.back().second[i];\n        }\n        vct.pop_back();\n    }\n    for (int i = 0; i < r; i++) ans[t[i] - 'a']++;\n\n    return ans;\n}\n\nvector<ll> solve(string s, ll l, ll r) {\n    auto a1 = solve(s, r);\n    auto a2 = solve(s, l - 1);\n    for (int i = 0; i < SIGMA; i++) {\n        a1[i] -= a2[i];\n    }\n    return a1;\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    string s;\n    ll l, r;\n    while (cin >> s >> l >> r) {\n        print(solve(s, l, r));\n    }\n\n#ifdef HOME\n    cerr << clock() / (double)CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[880008],sz,pos,g,cnt[26][200022],p[26][400044],q[26][800088];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[800088];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc077/tasks/arc077_d\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\nstring s;\nint Z[N], n;\nlong long l, r, cnt[1000], ch[1000][26], ans[26];\n\nvoid cal(long long x, int v){\n    int cur = 0;\n    while (cnt[cur] < x) cur++;\n    while (x){\n        while (cnt[cur-1] >= x) cur--;\n        if (x <= cnt[0]){\n            for (int i = 0; i < x; i++) ans[s[i] - 'a'] += v;\n            break;\n        }\n        if (cnt[cur] == x){\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur][i] * v;\n            x = 0;\n        }\n        else{\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur-1][i] * v;\n            x -= cnt[cur-1];\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s >> l >> r; n = s.size();\n    for (int i = 1, l = 0, r = 0; i < n; i++){\n        if (i <= r) Z[i] = min(r-i+1, Z[i-l]);\n        while (i + Z[i] < n && s[Z[i]] == s[i+Z[i]]) Z[i]++;\n        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;\n    }\n    for (int i = 1; i < n; i++) if (i > n/2 && i + Z[i] == n){\n        s.resize(i); n = i; break;\n    }\n    cnt[0] = n;\n    for (int i = 1; i < n; i++) if (i + Z[i] >= n){\n        cnt[1] = cnt[0] + i;\n        break;\n    }\n    if (!cnt[1]) cnt[1] = 2 * cnt[0];\n    if (cnt[0] % (cnt[1] - cnt[0]) == 0){\n        int siz = cnt[1] - cnt[0];\n        for (int i = 0; i < siz; i++) ans[s[i] - 'a'] += ((r+siz-i) / siz) - ((l-1+siz-i) / siz);\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) ch[0][s[i] - 'a']++, ch[1][s[i] - 'a']++;\n    for (int i = 0; i < (cnt[1] - cnt[0]); i++) ch[1][s[i] - 'a']++;\n\n    for (int i = 2; cnt[i-1] <= r; i++) {\n        cnt[i] = cnt[i-1] + cnt[i-2];\n        for (int j = 0; j < 26; j++) ch[i][j] = ch[i-1][j] + ch[i-2][j];\n    }\n    cal(r, 1); cal(l-1, -1);\n\n    for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\nusing namespace std;\n\n#define Rep(i,l,r) for (int i = (l); i <= (r); ++ i)\n#define RepD(i,r,l) for (int i = (r); i >= (l); -- i)\n#define RepG(i,x) for (int i = hd[x]; i; i = e[i].nxt)\n\ntypedef long long ll;\nconst int N = 4e5+5;\nint n, bd, f[N][35], ne[N]; ll l, r;\nchar s[N];\n\nvoid pre () {\n\tRep(i,1,n) {\n\t\t++ f[i][s[i]-'a'+1];\n\t\tRep(j,1,26) f[i][j] += f[i-1][j];\n\t}\n\tint t = 2, k = ne[1] = 0;\n\twhile (t<=n) {\n\t\twhile (k && s[k+1]!=s[t]) k = ne[k];\n\t\tif (s[k+1]==s[t]) ++ k; ne[t++] = k;\n\t}\n\tbd = n-ne[n];\n}\n\nll calc (ll k, int c) {\n\tif (k<=n) return f[k][c];\n\tif (k<=(n<<1)) return f[n][c]+f[k-n][c];\n\tll lsf = f[n][c], nwf = f[n][c]+f[bd][c], lsl = n, nwl = n+bd;\n\twhile (k>lsl+nwl) {\n\t\tswap (lsl, nwl); nwl = lsl+nwl;\n\t\tswap (lsf, nwf); nwf = lsf+nwf;\n\t}\n\treturn nwf+calc (k-nwl, c);\n}\n\nint main () {\n\tscanf (\"%s%lld%lld\", s+1, &l, &r);\n\tn = strlen (s+1)>>1; pre ();\n\tRep(i,1,26) printf (\"%lld \", calc (r,i)-calc (l-1,i));\n\tputs (\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next NexT\n#define LL long long\n\nconst int maxn=2e5+10;\n\nint n,next[maxn];\nLL L,R,c0[30],cA[30],cB[30],Ans[30],LA,LB;\nchar s[maxn];\n\nvoid KMP()\n{\n\tint i;\n\tnext[0]=0; next[1]=0;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tnext[i]=next[i-1];\n\t\twhile (s[next[i]+1]!=s[i]&&next[i])\n\t\t\tnext[i]=next[next[i]];\n\t\tnext[i]+=s[next[i]+1]==s[i];\n\t}\n}\n\nvoid solve(LL R,int flag)\n{\n\tint i;\n\tif (R<=n)\n\t{\n\t\tfor (i=1;i<=R;i++)\n\t\t\tAns[s[i]-'a']+=flag;\n\t\treturn;\n\t}\n\tLA=next[n];\n\tLB=n-2*next[n];\n\tmemset(cA,0,sizeof(cA));\n\tmemset(cB,0,sizeof(cB));\n\tfor (i=1;i<=LA;i++) cA[s[i]-'a']++;\n\tfor (i=LA+1;i<=LA+LB;i++) cB[s[i]-'a']++;\n\twhile (LA+LB+LA+LA+LB<=R)\n\t{\n\t\tswap(LA,LB); LA+=LB;\n\t\tfor (i=0;i<26;i++)\n\t\t\tswap(cA[i],cB[i]),cA[i]+=cB[i];\n\t}\n\tfor (i=0;i<26;i++)\n\t\tAns[i]+=flag*(cA[i]+cB[i]+cA[i]);\n\tR-=LA+LB+LA;\n\twhile (R)\n\t{\n\t\tLA-=LB; swap(LA,LB);\n\t\tfor (i=0;i<26;i++)\n\t\t\tcA[i]-=cB[i],swap(cA[i],cB[i]);\n\t\tif (R>=LA)\n\t\t{\n\t\t\tfor (i=0;i<26;i++)\n\t\t\t\tAns[i]+=flag*cA[i];\n\t\t\tR-=LA;\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i;\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tn=strlen(s+1);\n\tn=n/2;\n\tKMP();\n\tif (n%(n-next[n])==0)\n\t{\n\t\tfor (i=1;i<=n;i++) c0[s[i]-'a']++;\n\t\tfor (i=0;i<26;i++) Ans[i]+=c0[i]*((R/n)-((L-1)/n));\n\t\tfor (i=1;i<=R%n;i++) Ans[s[i]-'a']++;\n\t\tfor (i=1;i<=(L-1)%n;i++) Ans[s[i]-'a']--;\n\t\tfor (i=0;i<26;i++) printf(\"%lld \",Ans[i]);\n\t\treturn 0;\n\t}\n\twhile (next[n]>=(n+1)/2)\n\t\tn+=n-next[n],KMP();\n\tsolve(R,+1);\n\tsolve(L-1,-1);\n\tfor (i=0;i<26;i++)\n\t\tprintf(\"%lld \",Ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 1000;\n\nstruct State\n{\n\tlong long cnt[26], size;\n\tState()\n\t{\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\tsize = 0;\n\t}\n\tvoid add(char c)\n\t{\n\t\tcnt[c - 'a']++, size++;\n\t}\n};\n\nState operator + (const State &a, const State &b)\n{\n\tState ret;\n\tfor(int i = 0; i < 26; i++)\n\t\tret.cnt[i] = a.cnt[i] + b.cnt[i];\n\tret.size = a.size + b.size;\n\treturn ret;\n}\n\nint n, m;\nlong long L, R;\nchar s[MAXN];\nState f[MAXN];\n\nState prefix(int v)\n{\n\tState ret;\n\tfor(int i = 1; i <= v; i++)\n\t\tret.add(s[i]);\n\treturn ret;\n}\n\nState calc(int x, long long v)\n{\n\tif(x == 0 || x == 1)\n\t\treturn prefix(v);\n\tif(v <= f[x - 1].size)\n\t\treturn calc(x - 1, v);\n\telse\n\t\treturn f[x - 1] + calc(x - 2, v - f[x - 1].size);\n}\n\nint get_period()\n{\n\tstatic int next[MAXN];\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tint j = next[i - 1];\n\t\twhile(j && s[j + 1] != s[i])\n\t\t\tj = next[j];\n\t\tif(s[j + 1] == s[i])\n\t\t\tj = j + 1;\n\t\tnext[i] = j;\n\t}\n\treturn n - next[n];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> (s + 1);\n\tcin >> L >> R;\n\tn = strlen(s + 1) / 2;\n\ts[n + 1] = 0;\n\n\tint k = get_period();\n\tf[0] = prefix(k);\n\tf[1] = prefix(n);\n\n\tm = 2;\n\twhile(f[m - 1].size <= R) {\n\t\tf[m] = f[m - 1] + f[m - 2];\n\t\tm++;\n\t}\n\n\tState ans1 = calc(m, L - 1);\n\tState ans2 = calc(m, R);\n\n\tfor(int i = 0; i < 26; i++)\n\t\tcout << ans2.cnt[i] - ans1.cnt[i] << ' ';\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define all(x) (x).begin(), (x).end()\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 4;\n\nvector<ll> solve(string s, ll n0, ll k0, ll R)\n{\n    vector<ll> ans(26);\n\n    while (R)\n    {\n        if (R <= n0)\n        {\n            for (int i = 0; i < R; i++) ans[s[i] - 'a']++;\n            break;\n        }\n        ll n = n0, k = k0;\n        vector<ll> cnt0(26), cnt1(26);\n        for (int i = 0; i < k; i++) cnt0[s[i] - 'a']++;\n        for (int i = 0; i < n; i++) cnt1[s[i] - 'a']++;\n        while (n + k <= R)\n        {\n            ll m = n + k;\n            vector<ll> cnt2(26);\n            for (int i = 0; i < 26; i++) cnt2[i] = cnt1[i] + cnt0[i];\n            k = n;\n            n = m;\n            cnt0 = cnt1;\n            cnt1 = cnt2;\n        }\n        R -= n;\n        for (int i = 0; i < 26; i++)\n            ans[i] += cnt1[i];\n    }\n\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    string s;\n    cin >> s;\n    {\n        vector<int> z(s.size());\n        int L = 0, R = 0;\n        for (int i = 1; i < s.size(); i++)\n        {\n            z[i] = max(0, min(z[i - L], R - i));\n            while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n            if (i + z[i] > R)\n            {\n                R = i + z[i];\n                L = i;\n            }\n        }\n        int len = s.size();\n        for (int i = s.size() - 1; 2 * i > s.size(); i--)\n        {\n            if (i + z[i] == s.size())\n            {\n                len = i;\n            }\n        }\n        while (s.size() > len) s.pop_back();\n    }\n\n    ll n = s.size();\n    vector<int> z(s.size());\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    ll k = n;\n    for (int i = 1; i < s.size(); i++)\n    {\n        if (i + z[i] == s.size())\n        {\n            k = i;\n            break;\n        }\n    }\n    if (n % k == 0)\n    {\n        vector<ll> cnt(26);\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        ll c = R / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] += c + 1;\n            else cnt[s[i] - 'a'] += c;\n        }\n        c = L / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < L % k) cnt[s[i] - 'a'] -= c + 1;\n            else cnt[s[i] - 'a'] -= c;\n        }\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cnt[i] << \" \";\n        }\n    }\n    else\n    {\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        vector<ll> cntR = solve(s, n, k, R);\n        vector<ll> cntL = solve(s, n, k, L);\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cntR[i] - cntL[i] << \" \";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t{\n\t\t\tassert(lim<=la);\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(lim<=lb);\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\t}\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=len-(npos+1)*2;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <valarray>\n\ntypedef long long i64;\n\nconst int N = 100000 + 10, S = 100;\n\nint n, x, y;\nchar s[N];\n\nstd::valarray<i64> sum[N];\n\nvoid init() {\n  static int next[N];\n  next[1] = 0;\n  for (int i = 2; i <= n; ++i) {\n    int j = next[i - 1];\n    while (j && s[j + 1] != s[i]) j = next[j];\n    j += (s[j + 1] == s[i]);\n    next[i] = j;\n  }\n  sum[0].resize(26);\n  for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1], ++sum[i][s[i] - 'a'];\n  x = n - next[n];\n  y = x - next[x];\n}\n\nstd::valarray<i64> solve(i64 m) {\n  if (m <= n) return sum[m];\n  if (x % y == 0) {\n    m -= x;\n    return sum[x] + sum[y] * (m / y) + sum[m % y];\n  }\n  static i64 fib[S];\n  static std::valarray<i64> temp[S];\n  temp[0] = sum[fib[0] = x];\n  temp[1] = sum[fib[1] = x + y];\n  for (int i = 2; i < S; ++i) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n    temp[i] = temp[i - 1] + temp[i - 2];\n  }\n  int k = 2;\n  while (fib[k] < m) ++k;\n  std::valarray<i64> res(26);\n  while (k > 2) {\n    if (m >= fib[k - 1]) {\n      res += temp[k - 1];\n      m -= fib[k - 1];\n      k -= 2;\n    } else {\n      --k;\n    }\n  }\n  res += sum[m];\n  return res;\n}\n\nint main() {\n  i64 l, r;\n  scanf(\" %s%lld%lld\", s + 1, &l, &r);\n  n = strlen(s + 1);\n  init();\n  std::valarray<i64> ans = solve(r) - solve(l - 1);\n  for (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int64;\nstruct Hash\n{\n\tint n;\n\tstatic const int64 moda=1000000007ll,modb=2147483647ll;\n\tvector<int64> a,b,p,q;\n\tHash(const string &s):n(s.size()),a(n+1,0),b(n+1,0),p(n+1,1),q(n+1,1)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i+1]=(a[i]*17+s[i])%moda;\n\t\t\tb[i+1]=(b[i]*19+s[i])%modb;\n\t\t\tp[i+1]=p[i]*17%moda;\n\t\t\tq[i+1]=q[i]*19%modb;\n\t\t}\n\t}\n\tpair<int64,int64> query(int l,int r){return make_pair((p[r-l]*a[l]-a[r]+moda)%moda,(q[r-l]*b[l]-b[r]+modb)%modb);}\n};\nint64 cnt[300000][33];\nvector<int64> add(vector<int64> a,vector<int64> b)\n{\n\tfor(int i=0;i<26;i++)a[i]+=b[i];\n\treturn a;\n}\npair<vector<int64>,int64> f(int64 n,int64 l,vector<int64> left,int64 r,vector<int64> right)\n{\n\tvector<int64> ans(26);\n\tif(l+r<=n)\n\t{\n\t\tint64 tot=l+r;\n\t\tvector<int64> sum=add(left,right);\n\t\tauto x=f(n,tot,sum,l,left);\n\t\tans=add(ans,x.first);\n\t\tn=x.second;\n\t}\n\tif(l<=n)\n\t{\n\t\tans=add(ans,left);\n\t\tn-=l;\n\t}\n\treturn make_pair(ans,n);\n}\nint main()\n{\n\tstring s;\n\tint64 l,r,k=0;\n\tcin>>s>>l>>r;\n\ts=s.substr(0,s.size()>>1);l--;\n\tint64 n=s.size();\n\tHash h(s);\n\tfor(int i=0;i<n;i++)\n\t\tif(h.query(0,i)==h.query(n-i,n))k=i;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)cnt[i+1][j]=cnt[i][j];\n\t\tcnt[i+1][s[i]-'a']++;\n\t}\n\tif(!k)\n\t{\n\t\tfor(int i=0;i<26;i++)\n\t\t{\n\t\t\tcout<<cnt[n][i]*(r/n)+cnt[r%n][i]-cnt[n][i]*(l/n)-cnt[l%n][i];\n\t\t\tif(i==25)cout<<endl;\n\t\t\telse cout<<' ';\n\t\t}\n\t\treturn 0;\n\t}\n\tvector<int64> left(26,0),right(26,0);\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tcout<<upper.first[i]+cnt[upper.second][i]-lower.first[i]-cnt[lower.second][i];\n\t\tif(i==25)cout<<endl;\n\t\telse cout<<' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n} \n\nstring s,t;\nll l,r,S,T;\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0,I=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tI=i;\n\t\t}\n\t}\n\tt=(I==S?s:s.substr(0,I));\n\tT=t.size();\n\tif(S%T==0){\n\t\tcout<<'A'<<endl;\n/*\t\tvl a(26);\n\t\tfor(int i=l;i<S;i++) a[f(s[i])]++;\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(r<=S?0:(r-S)/T);\n\t\tfor(int i=0;i<(r-S)%T;i++) a[f(t[i])]++;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<a[i];\n\t\t}\n\t\tcout<<endl;*/\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define ONLINE_JUDGE\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y){ return y > x ? x = y, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &x, const T &y){ return y < x ? x = y, 1 : 0; }\n\n#ifdef ONLINE_JUDGE\n#define debug(...) ;\n#else\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define DEBUG\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 4e5 + 100;\n\nint n, m;\nchar s[maxn], t[maxn];\nLL cnt[maxn][26], cnt2[maxn][26];\nLL l, r;\nLL ans[26];\nint border[maxn];\n\nvoid KMP()\n{\n\tborder[0] = -1;\n\tforn(i, 1, n)\n\t{\n\t\tt[++m] = s[i];\n\t\tint j = border[i - 1];\n\t\twhile(~j && s[j + 1] != s[i]) j = border[j];\n\t\tborder[i] = j + 1;\n\t}\n\tint l = border[n / 2];\n\tforn(i, l + 1, n - l) t[++m] = s[i];\n\treturn;\n}\n\nvoid Q(LL N, int opr)\n{\n\tif(!N) return;\n\tstatic vl fib; fib.clear();\n\tfib.pb(n); fib.pb(m);\n\tif(N <= m)\n\t{\n\t\trep(i, 26) ans[i] += 1ll * opr * cnt2[N][i];\n\t\treturn;\n\t}\n\twhile(fib.back() <= N) fib.pb(fib.back() + fib[SZ(fib) - 2]);\n\tstatic LL A[26], B[26], C[26];\n\tmemcpy(A, cnt[n], sizeof(cnt[n]));\n\tmemcpy(B, cnt2[m], sizeof(cnt2[m]));\n\tforn(i, 2, SZ(fib) - 2)\n\t{\n\t\tmemset(C, 0, sizeof C);\n\t\trep(j, 26) C[j] = A[j] + B[j];\n\t\tmemcpy(A, B, sizeof A);\n\t\tmemcpy(B, C, sizeof B);\n\t}\n\trep(i, 26) ans[i] += 1ll * opr * B[i];\n\tQ(N - fib[SZ(fib) - 2], opr);\n\treturn;\n}\n\nint main()\n{\n\tscanf(\"%s\", s + 1); scf(l, r); n = strlen(s + 1);\n\tforn(i, 1, n) cnt[i][s[i] - 'a'] = 1;\n\tforn(i, 1, n) rep(j, 26) cnt[i][j] += cnt[i - 1][j];\n\tKMP();\n#ifdef DEBUG\n\tprintf(\"%s\\n\", t + 1);\n#endif\n\tforn(i, 1, m) cnt2[i][t[i] - 'a'] = 1;\n\tforn(i, 1, m) rep(j, 26) cnt2[i][j] += cnt2[i - 1][j];\n\tQ(r, 1);\n#ifdef DEBUG\n\trep(i, 26) printf(\"%lld \", ans[i]); puts(\"\");\n#endif\n\tQ(l - 1, -1);\n\trep(i, 26) printf(\"%lld \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 400005;\nconst int MM = 1000000007;\n\nstring D;\n\nstring f(string D, int &a){\n\tstatic int F[MX] = {};\n\tint N = D.size();\n\tfor(int i = 0; i <= D.size(); i++) F[i] = -1;\n\tfor(int i = 1; i <= D.size(); i++){\n\t\tF[i] = F[i-1];\n\t\twhile(F[i] != -1 && D[F[i]] != D[i-1]) F[i] = F[F[i]];\n\t\tF[i] += 1;\n\t}\n\ta = F[N];\n\twhile(a >= N/2) a = F[a];\n\treturn D + D.substr(a, N-2*a);\n}\n\nvoid solve1(string A, ll ad, ll ans[26])\n{\n\tfor(int i = 0; i < 26; i++) ans[i] = 0;\n\tint cnt[26] = {};\n\tstring B = A.substr(0, A.size()/2);\n\tfor(char c : B) cnt[c-'a']++;\n\tfor(int i = 0; i < ad%B.size(); i++) ans[B[i]-'a']++;\n\tfor(int i = 0; i < 26; i++) ans[i] += cnt[i] * (ad/B.size());\n}\n\nvoid solve2(string A, string B, ll ad, ll ans[26])\n{\n\tint c1[26] = {}, c2[26] = {};\n\tfor(char c : A) c1[c-'a']++;\n\tfor(char c : B) c2[c-'a']++;\n\n\tvector<pll> L;\n\tL.push_back(pll(1, 0));\n\tL.push_back(pll(0, 1));\n\twhile(L.back().first * A.size() + L.back().second * B.size() <= ad){\n\t\tL.emplace_back(L[L.size()-2].first + L.back().first, L[L.size()-2].second + L.back().second);\n\t}\n\treverse(L.begin(), L.end());\n\tL.pop_back(); L.pop_back();\n\tfor(pll c : L){\n\t\tll v = c.first * A.size() + c.second * B.size();\n\t\tif( ad < v ) continue;\n\t\tad -= v;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tans[i] += c1[i] * c.first + c2[i] * c.second;\n\t\t}\n\t}\n\tstring C = A+B;\n\tfor(int i = 0; i < ad; i++) ans[C[i]-'a'] ++;\n}\n\nint main()\n{\n\tstring A;\n\tint a;\n\tll l, r;\n\tcin >> A >> l >> r; A = f(A, a);\n\tf(A, a);\n\n\tll a1[26] = {}, a2[26] = {};\n\tif( a == 0 || a*4 == A.size() ) solve1(A, r, a1), solve1(A, l-1, a2);\n\telse{\n\t\tsolve2(A.substr(0, a), A.substr(a, A.size()/2-a), r, a1);\n\t\tsolve2(A.substr(0, a), A.substr(a, A.size()/2-a), l-1, a2);\n\t}\n\tfor(int i = 0; i < 26; i++) printf(\"%lld \", a1[i] - a2[i]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 30000\n\nll l,r;\n\nint z[MAXN];\nvoid getz(char s[]){\n\tms(z);\n\tint n = strlen(s);\n\tint l = 0, r = 0;\n\tfor(int i = 1;i < n;i++){\n\t\tif(i > r){\n\t\t\tl = r = i;\n\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\tr--;\n\t\t\tz[i] = r-l+1;\n\t\t}else{\n\t\t\tint k = i-l;\n\t\t\tif(z[k] < r-i) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tl = i;\n\t\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\t\tr--;\n\t\t\t\tz[i] = r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nll j;\nchar s1[MAXN];\nll final[28][2];\nint n;\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\tlen[0] = n - z[n-1];\n\tlen[1] = n;\n\t\n\tj = 2;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 0;i < len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 0;i < len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 0;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t//freopen(\"ss.txt\",\"r\",stdin);\n\t\n\tcin >> s1;\n\tcin >> l >> r;\n\t\n\tn = strlen(s1);\n\tl--;r--;\n\t\n\tgetz(s1);\n\t\n\tn /= 2;\n\t\n\tms(final);\n\tif(l >= 1) getans(l-1,0);\n\tif(r >= 0)getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = false;\n\ts = conv(s);\n\t//cout << s << endl;\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 1; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tif (n%k==0){\n\t\t\tr-=n;\n\t\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']++;\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=r/k;\n\t\t\tfor (ll i=0;i<r%k;i++) w[s[i]-'a']++;\n\t\t}else{\n\t\t\tll _s=0,_t=1,S=1,T=0;\n\t\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\t\twork(r-_s*n-_t*k);\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=2e6+5,M=1e7+50,mo=1e9+7;\nint fail[N],n,i,per;\nll len1,len2,d,prt[30],l,r,f[305][26],g[305][26],sf[305],sg[305];\nchar s[N];\nvoid ext()\n{\n\tint i,j;\n\tj=0;\n\tn=strlen(s+1);\n\tfo(i,2,n)\n\t{\n\t\twhile (j&&s[i]!=s[j+1]) j=fail[j];\n\t\tif (s[i]==s[j+1]) j++;\n\t\tfail[i]=j;\n\t}\n\ti=fail[n];\n\twhile (i>=n/2) i=fail[i];\n\tfo(j,n+1,n+n-2*i) s[j]=s[i+j-n];\n}\nvoid fib()\n{\n\tint i,j;\n\tfo(i,2,300)\n\t{\n\t\tfo(j,0,25)  g[i][j]=g[i-1][j]+g[i-2][j];\n\t\tsg[i]=sg[i-1]+sg[i-2];\n\t\tif (sg[i]*2>r) break;\n\t}\n\tfo(i,0,300)\n\t{\n\t\tfo(j,0,25) f[i][j]=g[i][j]*2;\n\t\tsf[i]=sg[i]*2;\n\t\tif (sf[i]>r) break;\n\t}\n}\nvoid calc(ll x,ll xs)\n{\n\tint pos;\n\tfo(pos,0,300)\n\t\tif (sf[pos]>x) break;\n\twhile (pos>1)\n\t{\n\t\tif (sf[pos-1]<=x)\n\t\t{\n\t\t\tfo(i,0,25) prt[i]+=xs*f[pos-1][i];\n\t\t\tx-=sf[pos-1];\n\t\t\tpos-=2;\n\t\t}else\n\t\tpos--;\n\t}\n\twhile (n<x) ext(),n=strlen(s+1);\n\tfo(i,1,x) prt[s[i]-'a']+=xs;\n}\nint main()\n{\n\tscanf(\"%s %lld %lld\",s+1,&l,&r);\n\text();\n\tn=strlen(s+1);\n\tfo(i,1,n/2) g[0][s[i]-'a']++,sg[0]++;\n\tper=n/2-fail[n/2];\n\tfo(i,0,25) g[1][i]=g[0][i];\n\tsg[1]=sg[0];\n\tfo(i,1,per) g[1][s[i]-'a']++,sg[1]++;\n\tfib();\n\tcalc(r,1);\n\tcalc(l-1,-1);\n\tfo(i,0,25) printf(\"%lld \",prt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=2e6+5,M=1e7+50,mo=1e9+7;\nint fail[N],n,i,per;\nll len1,len2,d,prt[30],l,r,f[305][26],g[305][26],sf[305],sg[305];\nchar s[N];\nvoid kmp()\n{\n\tint i,j;\n\tj=0;\n\tn=strlen(s+1);\n\tfo(i,2,n)\n\t{\n\t\twhile (j&&s[i]!=s[j+1]) j=fail[j];\n\t\tif (s[i]==s[j+1]) j++;\n\t\tfail[i]=j;\n\t}\n\ti=fail[n];\n}\nvoid fib()\n{\n\tint i,j;\n\tfo(i,2,300)\n\t{\n\t\tfo(j,0,25)  g[i][j]=g[i-1][j]+g[i-2][j];\n\t\tsg[i]=sg[i-1]+sg[i-2];\n\t\tif (sg[i]*2>r) break;\n\t}\n\tfo(i,0,300)\n\t{\n\t\tfo(j,0,25) f[i][j]=g[i][j]*2;\n\t\tsf[i]=sg[i]*2;\n\t\tif (sf[i]>r) break;\n\t}\n}\nvoid calc(ll x,ll xs)\n{\n\tint pos;\n\tfo(pos,0,300)\n\t\tif (sf[pos]>x) break;\n\twhile (pos>0)\n\t{\n\t\tif (sf[pos-1]<=x)\n\t\t{\n\t\t\tfo(i,0,25) prt[i]+=xs*f[pos-1][i];\n\t\t\tx-=sf[pos-1];\n\t\t\tpos-=2;\n\t\t}else\n\t\tpos--;\n\t}\n\tfo(i,1,x) prt[s[i]-'a']+=xs;\n}\nint main()\n{\n\tscanf(\"%s %lld %lld\",s+1,&l,&r);\n\tkmp();\n\tn=strlen(s+1);\n\tfo(i,1,n/2) g[0][s[i]-'a']++,sg[0]++;\n\tper=n/2-fail[n/2];\n\tfo(i,0,25) g[1][i]=g[0][i];\n\tsg[1]=sg[0];\n\tfo(i,1,per) g[1][s[i]-'a']++,sg[1]++;\n\tfib();\n\tcalc(r,1);\n\tcalc(l-1,-1);\n\tfo(i,0,25) printf(\"%lld \",prt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 20160116\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n// cf IO: I64d\n// atcoder IO: lld\nconst int Maxn=500005;\nconst long long mod=12384738759127LL;\nconst long long tim=1311;\nchar s[Maxn];\nint n;\nlong long cnt[Maxn][26],ans[26];\nlong long l,r;\nvoid Output(long long x[]){\n\tfor (int i=0;i<26;i++){\n\t\tprintf(\"%lld \",x[i]);\n\t}\n\tprintf(\"\\n\");\n\texit(0);\n}\npair<long long,vector<long long> > go(long long len,vector<long long> lfsum, long long lflen,vector<long long> rgsum,long long rglen){\n\tvector<LL> ret,newlf,newrg;\n\tret.resize(26,0);\n\tnewlf.resize(26,0);\n\tnewrg.resize(26,0);\n\tif (lflen+rglen<=len){\n\t\tfor (int i=0;i<26;i++){\n\t\t\tnewlf[i]=lfsum[i]+rgsum[i];\n\t\t\tnewrg[i]=lfsum[i];\n\t\t}\n\t\tpair<LL,vector<LL> > tmp=go(len,newlf,lflen+rglen,newrg,lflen);\n\t\tfor (int i=0;i<26;i++) ret[i]+=(tmp.second[i]);\n\t\tlen=tmp.first;\n\t}\n\tif (len>=lflen){\n\t\tfor (int i=0;i<26;i++) ret[i]+=lfsum[i];\n\t\tlen-=lflen;\n\t}\n\treturn mp(len,ret); \n}\nvector<long long> solve(long long target,int pre){\n\tvector<LL> lf,rg;\n\tlf.resize(26),rg.resize(26,0);\n\tfor (int i=0;i<26;i++){\n\t\tlf[i]=cnt[n-pre][i];\n\t\trg[i]=cnt[n][i]-cnt[n-pre][i];\n\t}\n\tpair<LL,vector<LL> > res=go(target,lf,(LL)n-pre,rg,(LL)pre);\n\t//cout<<res.first<<endl;\n\tfor (int i=0;i<26;i++){\n\t\t(res.second)[i]+=cnt[res.first][i];\n\t} \n\treturn res.second;\n}\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tn/=2;\n\tscanf(\"%lld %lld\",&l,&r);\n\tlong long hashval1=0,hashval2=0;\n\tlong long now=1;\n\tint len=0;\n\tfor (int i=0;i<n-1;i++){\n\t\thashval1=hashval1*tim;\n\t\thashval1+=(long long)s[i];\n\t\thashval2+=now*(long long)s[n-i-1];\n\t\thashval1%=mod;\n\t\thashval2%=mod;\n\t\tnow*=tim;\n\t\tnow%=mod;\n\t\tif (hashval1==hashval2){\n\t\t\tlen=i+1;\n\t\t}\n\t}\n\t//cout<<len<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++){\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tl--;\n\tif (len==0){\n\t\tlong long tot=0;\n\t\tfor (int i=0;i<26;i++){\n\t\t\tans[i]+=cnt[n][i]*(r/n);\n\t\t\tans[i]-=cnt[n][i]*(l/n);\n\t\t\tans[i]+=cnt[r%n][i];\n\t\t\tans[i]-=cnt[l%n][i];\n\t\t\ttot+=ans[i];\n\t\t}\n\t\t//cout<<tot<<endl;\n\t\tOutput(ans);\n\t\treturn 0;\n\t}\n\tvector<LL> ans1=solve(r,len);\n\tvector<LL> ans2=solve(l,len);\n\tfor (int i=0;i<26;i++){\n\t\tans1[i]-=ans2[i];\n\t\tprintf(\"%lld \",ans1[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint n;\nchar s[200001];\nint z[200001];\nlong long ans[26];\n\nint gcd(int x, int y) {\n    if (x % y == 0) return y;\n    return gcd(y, x % y);\n}\n\nvoid calc(long long c, long long g, long long f) {\n    int i;\n    \n    for (i = 0; i < g; i++) ans[s[i] - 'a'] += c / g * f;\n    for (i = 0; i < c % g; i++) ans[s[i] - 'a'] += f;\n}\n\nvoid calc2(long long c, long long x, long long y, int f) {\n    int i;\n    vector <long long> v;\n    map <long long, long long> mp;\n    map <long long, long long>::reverse_iterator it;\n    \n    v.push_back(x);\n    v.push_back(y);\n    \n    while (v.back() < c) {\n        v.push_back(v[v.size() - 1] + v[v.size() - 2]);\n    }\n    \n    mp[c]++;\n    \n    for (it = mp.rbegin(); it != mp.rend(); it++) {\n        long long x = it->first;\n        \n        for (i = 0; ; i++) {\n            if (v[i] >= x) break;\n        }\n        \n        if (v[i] <= n) {\n            calc(x, v[i], it->second * f);\n        } else {\n            mp[v[i - 1]] += it->second;\n            mp[x - v[i - 1]] += it->second;\n        }\n    }\n}\n\nint main() {\n    int x, y, i, j, k;\n    long long l, r;\n    \n    scanf(\"%s\", s);\n    scanf(\"%lld %lld\", &l, &r);\n    \n    n = strlen(s);\n    \n    i = 1, j = 0;\n    z[0] = n;\n    \n    while (i < n) {\n        while (i + j < n && s[j] == s[i + j]) j++;\n        \n        z[i] = j;\n        \n        if (j == 0) {\n            i++;\n            \n            continue;\n        }\n        \n        k = 1;\n        \n        while (i + k < n && k + z[k] < j) {\n            z[i + k] = z[k];\n            k++;\n        }\n        \n        i += k;\n        j -= k;\n    }\n    \n    x = n / 2;\n    y = n;\n    \n    for (i = n - 1; i > n / 2; i--) {\n        if (i + z[i] == n) y = i;\n    }\n    \n    if (x == 1) {\n        ans[s[0] - 'a'] = r - l + 1;\n    } else {\n        int g = gcd(x, y);\n        \n        if (g > 1) {\n            calc(r, g, 1);\n            calc(l - 1, g, -1);\n        } else {\n            calc2(r, x, y, 1);\n            calc2(l - 1, x, y, -1);\n        }\n    }\n    \n    for (i = 0; i < 26; i++) {\n        if (i > 0) putchar(' ');\n        \n        printf(\"%lld\", ans[i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst ll  inf=1e18;\nconst int maxn=2e5+10;\nconst int maxm=1e2+10;\nchar s[maxn];int n,lst,nxt[maxn],pre[maxn][26];\nll l,r,cutpos,ans[26],fib[maxm],f[maxm][26];\nll read(){\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(ll x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(ll x){print(x);putchar(' ');}\nvoid get_nxt(){\n    nxt[1]=0;\n    for(int i=2,j;i<=n;i++){\n        j=nxt[i-1];\n        while(j&&s[j+1]!=s[i])j=nxt[j];\n        nxt[i]=s[j+1]==s[i]?j+1:0;\n    }\n}\nvoid get_fib(){\n    fib[1]=n;\n    for(int i=1;i<=n;i++){f[1][s[i]-'a']++;f[2][s[i]-'a']++;}\n    fib[2]=n+cutpos;\n    for(int i=0;i<26;i++)f[2][i]+=pre[cutpos][i];\n    for(int i=3;;i++){\n        for(int j=0;j<26;j++)f[i][j]=f[i-2][j]+f[i-1][j];\n        fib[i]=fib[i-2]+fib[i-1];if(fib[i]>inf){lst=i;break;}\n    }\n}\nvoid cal(ll x,ll v){\n    for(int i=lst;i>=1;i--)\n        if(fib[i]<=x){\n            x-=fib[i];\n            for(int j=0;j<26;j++)ans[j]+=v*f[i][j];\n        }\n    for(int i=0;i<26;i++)ans[i]+=v*pre[x][i];\n}\nint main(){\n    scanf(\"%s\",s+1);l=read();r=read();\n    n=strlen(s+1);n>>=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<26;j++)pre[i][j]+=pre[i-1][j];\n        pre[i][s[i]-'a']++;\n    }get_nxt();cutpos=n-nxt[n];\n    get_fib();cal(r,1);cal(l-1,-1);\n    for(int i=0;i<26;i++)write(ans[i]);puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n} \n\nstring s,t;\nll l,r,S,T;\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0;\n\tT=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tT=i;\n\t\t}\n\t}\n\tt=s.substr(0,T);\n\tif(S%T==0){\n\t\tvl a(26);\n\t\tfor(int i=l;i<S;i++) a[f(s[i])]++;\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(r<=S?0:(r-S)/T);\n\t\tif(r>S){\n\t\t\tfor(int i=0;i<(r-S)%T;i++) a[f(t[i])]++;\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<a[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200000+10;\n\nint n,lt,lim; char s[N];\nint sum[N][26];\nll ans[26],len[100],cnt[100][26];\n\nint nxt[N];\nvoid getnext() {\n\tfor (int i=2,j=0;i<=n;++i) {\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif (s[j+1]==s[i]) ++j;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid calc_sp(ll p,int w) {\n\tif (!p) return;\n\tfor (int i=0;i<26;++i) ans[i]+=w*(p/lt)*sum[lt][i];\n\tfor (int i=0;i<26;++i) ans[i]+=w*sum[p%lt][i];\n}\n\nvoid calc(ll p,int w) {\n\tif (!p) return;\n\tfor (int i=lim;i;--i) {\n\t\tif (p<len[i]) continue;\n\t\tp-=len[i];\n\t\tfor (int j=0;j<26;++j) ans[j]+=w*cnt[i][j];\n\t}\n\tfor (int i=0;i<26;++i) ans[i]+=w*sum[p][i];\n}\n\nint main() {\n\tscanf(\"%s\",s+1); n=strlen(s+1)>>1;\n\tll l=read(),r=read();\n\tgetnext(); lt=n-nxt[n];\n\tfor (int i=1;i<=n;++i) {\n\t\tmemcpy(sum[i],sum[i-1],sizeof(sum[i]));\n\t\t++sum[i][s[i]-'a'];\n\t}\n\tif (n%lt==0) calc_sp(r,1),calc_sp(l-1,-1);\n\telse {\n\t\tlen[1]=n,len[2]=n+lt;\n\t\tfor (int i=0;i<26;++i)\n\t\t\tcnt[1][i]=sum[n][i],cnt[2][i]=sum[n][i]+sum[lt][i];\n\t\tfor (int i=3;;++i) {\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t\t\tif (len[i]>1e18) { lim=i; break; }\n\t\t}\n\t\tcalc(r,1),calc(l-1,-1);\n\t}\n\tfor (int i=0;i<26;++i) printf(\"%lld \",ans[i]); puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  // first step\n  s = f(s);\n  // second\n  string t = f(s);\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  // if(l>1){\n    calc(X,Y,l-1);\n    REP(i,26)ans[i]-=cnt[i];\n  // }\n  REP(i,26)printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    for(int i = 0; i < (int)T.size() - pi[T.size() - 1]; i++) A.push_back(T[i]);\n    B = T;\n\n    //cout << A << ' ' << B << endl;\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\trep(i,1,m) if(g[i][26]>=r) {m=i;break;}\n\t\tdwn(j,m-1,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m-1,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nconst int N=200010;\ntypedef long long ll;\nint n,prd,fail[N],k=0;\nchar a[N];\nll l,r,pre[N][30];\ninline ll fib(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(p<=n*2) return pre[n][c]+pre[p-n][c];\n\tll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n\twhile(p>a+b){\n\t\tll c=ret1; ret1+=ret2; ret2=c;\n\t\tc=a; a+=b; b=c;\n\t}\n\treturn ret1+fib(p-a,c);\n}\ninline ll cal(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(n%prd==0){\n\t\tll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n\t\tp%=prd;\n\t\treturn ret+pre[p][c];  \n\t}\n\telse return fib(p,c);\n}\n \nint main(){\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    \tpre[i][a[i]-'a']++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor(int i=2;i<=n;i++){\n\t\tif (k&&a[k+1]!=a[i]) k=fail[k];\n\t\tif (a[k+1]==a[i]) k++;\n\t\tfail[i]=k;\n\t}\n\tprd=n-fail[n];\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",cal(r,i)-cal(l-1,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll len[200], cnt[200][26];\nint sum0[26][100001], sum1[26][200001];\n\nll rec(int n, ll l, ll r, int c){\n\tif(l >= len[n] || r <= 0) return 0;\n\tif(l <= 0 && len[n] <= r) return cnt[n][c];\n\t\n\tl = max(l, 0ll); r = min(r, len[n]);\n\t\n\tif(n <= 1){\n\t\tif(n == 1) return sum1[c][r] - sum1[c][l];\n\t\treturn sum0[c][r] - sum0[c][l];\n\t}\n\treturn rec(n - 1, l, r, c) + rec(n - 2, l - len[n - 1], r - len[n - 1], c);\n}\n\nint* buildFail(const string &s){\n\tint n = s.size();\n\tint *p = new int[n];\n\tp[0] = 0;\n\tfor (int i = 1; i < n; ++i){\n\t\tp[i] = p[i - 1];\n\t\twhile (p[i] > 0 && s[p[i]] != s[i]) p[i] = p[p[i] - 1];\n\t\tif (s[p[i]] == s[i]) p[i]++;\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tstring s;\n\tll l, r; cin >> s >> l >> r; l--;\n\tint n = s.size() / 2;\n\tint *f = buildFail(s.substr(0, n));\n\tint p = n - f[n - 1];\n\t\n\tif(n % p == 0){\n\t\trep(i, 26){\n\t\t\trep(j, p) sum1[i][j + 1] = sum1[i][j] + (s[j] == 'a' + i);\n\t\t\tll k = r / p, m = l / p, cnt = 0;\n\t\t\tcnt += sum1[i][p] * k + sum1[i][r % p];\n\t\t\tcnt -= sum1[i][p] * m + sum1[i][l % p];\n\t\t\tcout << cnt << (i == 25 ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse{\n\t\tstring t = s.substr(0, n) + s.substr(0, p);\n\t\tlen[0] = n;\n\t\tlen[1] = t.size();\n\t\trep(i, 26){\n\t\t\trep(j, n)        sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\trep(j, t.size()) sum1[i][j + 1] = sum1[i][j] + (t[j] == 'a' + i);\n\t\t\tcnt[0][i] = sum0[i][n];\n\t\t\tcnt[1][i] = sum1[i][t.size()];\n\t\t}\n\t\tint m = 1;\n\t\tfor(; len[m] < r; m++){\n\t\t\tlen[m + 1] = len[m] + len[m - 1];\n\t\t\trep(i, 26) cnt[m + 1][i] = cnt[m][i] + cnt[m - 1][i];\n\t\t}\n\t\trep(i, 26) cout << rec(m, l, r, i) << (i == 25 ? \"\\n\": \" \");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\ntypedef long long ll; \nint n, k, nxt[200005]; \nll ans[35]; \nchar str[200005]; \nvoid work(ll r)\n{\n\tif (r <= n)\n\t{\n\t\tfor (int i = 0; i < r; i++)\n\t\t\tans[str[i] - 'a']++; \n\t\treturn; \n\t}\n\tll cnt_s = 1, cnt_t = 0, lst_s = 0, lst_t = 1; \n\twhile (cnt_s * n + cnt_t * k < r)\n\t{\n\t\tcnt_s += lst_s; \n\t\tcnt_t += lst_t; \n\t\tlst_s = cnt_s - lst_s; \n\t\tlst_t = cnt_t - lst_t; \n\t}\n\twork(r - lst_s * n - lst_t * k); \n\tfor (int i = 0; i < n; i++)\n\t\tans[str[i] - 'a'] += lst_s; \n\tfor (int i = 0; i < k; i++)\n\t\tans[str[i] - 'a'] += lst_t; \n}\nint main()\n{\n\t// freopen(\"ARC077-F.in\", \"r\", stdin); \n\tscanf(\"%s\", str); \n\tn = strlen(str) / 2; \n\tnxt[0] = -1; \n\tfor (int i = 1, j = -1; i < n; i++)\n\t{\n\t\twhile (~j && str[i] != str[j + 1])\n\t\t\tj = nxt[j]; \n\t\tj += str[i] == str[j + 1]; \n\t\tnxt[i] = j; \n\t}\n\tk = n - nxt[n - 1] - 1; \n\tll l, r; \n\tscanf(\"%lld%lld\", &l, &r); \n\twork(l - 1); \n\tfor (int i = 0; i < 26; i++)\n\t\tans[i] *= -1; \n\twork(r); \n\tfor (int i = 0; i < 26; i++)\n\t\tprintf(\"%lld%c\", ans[i], \" \\n\"[i == 25]);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 1000010\n#define LL long long\n\nint n;\nchar str[MAXN];\nint nxt[MAXN];\nint s[26][MAXN];\nLL L,R,S,T;\n\nvoid gaoNext(){\n\tnxt[1]=0;\n\tfor(int i=2,j=1;i<=n;i++,j++){\n\t\twhile(j && str[i]!=str[j]){\n\t\t\tif(j==1) j=0;\n\t\t\telse j=nxt[j-1]+1;\n\t\t}\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid gaoS(){\n\tfor(int i=0;i<26;i++){\n\t\ts[i][0]=0;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ts[i][j]=s[i][j-1]+((str[j]=='a'+i)?1:0);\n\t}\n}\n\nvoid pre_gao(){\n\tgaoNext();\n\tint temp=n;\n\twhile(temp*2>=n) temp=nxt[temp];\n\tn-=temp;\n}\n\nLL getS(int ch,LL len){\n\tif(len<=n) return s[ch][len];\n\tLL l1=T,l2=S;\n\tLL s1=s[ch][l1],s2=s[ch][l2];\n\twhile(l1+l2<=len){\n\t\tLL l3=l1+l2,s3=s1+s2;\n\t\tl1=l2; l2=l3;\n\t\ts1=s2; s2=s3;\n\t}\n\treturn s2+getS(ch,len-l2);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tpre_gao();\n\tgaoS();\n\tS=n; T=n-nxt[n];\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",getS(i,R)-getS(i,L-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\ntypedef unsigned long long ull;\nchar s[800111];\null hs[800111],bs,pw[800111];\nint n;\nvoid iniths()\n{\n\tfor(int i=1;i<=n;i++)hs[i]=hs[i-1]*bs+s[i];\n}\null calchs(int l,int r)\n{\n\treturn ((hs[r]-1ll*hs[l-1]*pw[r-l+1])%mod+mod)%mod;\n}\nll l,r;\nvoid nxtstr()\n{\n\tiniths();\n\tint len=0;\n\tfor(int i=n/2-1;i>=1;i--)\n\t{\n\t\tif(calchs(1,i)==calchs(n-i+1,n))\n\t\t{\n\t\t\tlen=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint nn=n-len;\n\tn=nn+nn;\n\tfor(int i=1;i<=nn+nn;i++)s[i]=s[(i-1)%nn+1];\n}\nll ans[26];\nint pre[800111][26];\nll dp[100],dpcnt[100][26];\nbool type;\nvoid calc(int lv,ll x,int coef)\n{\n\tif(type)\n\t{\n//\t\tcout<<\"calc:\"<<lv<<\" \"<<x<<endl;\n\t\tif(lv<=1)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[x][i];\n\t\t\treturn;\n\t\t}\n\t\tll t=dp[lv]/2;\n\t\tif(x<=t)calc(lv-1,x,coef);\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*(dpcnt[lv][i]/2);\n\t\t\tcalc(lv-1,x-t,coef);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(x<=n)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[x][i];\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[n][i]*(x/n);\n\t\t\tcalc(lv,x%n,coef);\n\t\t}\n\t}\n}\nint main()\n{\n\tsrand(time(NULL));\n\tbs=rand()+1000;\n\tpw[0]=1;\n\tfor(int i=1;i<=800011;i++)pw[i]=pw[i-1]*bs;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tint n1=n;\n\tnxtstr();\n\tint n2=n;\n\tnxtstr();\n\tint n3=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t{\n\t\t\tpre[i][j]=pre[i-1][j]+(s[i]=='a'+j);\n\t\t}\n\t}\n\tif(n3-n2==n2-n1)type=0;\n\telse type=1;\n//\tcout<<n<<endl;\n//\tfor(int i=1;i<=n;i++)cout<<s[i];cout<<endl;\n\tdp[0]=n1;\n\tdp[1]=n2;\n\tdp[2]=n3;\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tdpcnt[0][i]=pre[n1][i];\n\t\tdpcnt[1][i]=pre[n2][i];\n\t\tdpcnt[2][i]=pre[n3][i];\n\t}\n\tint mx=0;\n\tif(type)\n\t{\n\t\tfor(int i=3;i<100;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+dp[i-2];\n\t\t\tmemset(ans,0,sizeof(ans));\n\t\t\tif(dp[i]>1ll*mod*mod)\n\t\t\t{\n\t\t\t\tmx=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcalc(i-1,dp[i]/2,2);\n\t\t\tfor(int j=0;j<26;j++)dpcnt[i][j]=ans[j];\n\t\t}\n\t}\n//\tfor(int i=0;i<26;i++)cout<<dpcnt[0][i]<<\" \";cout<<endl;\n//\tfor(int i=0;i<26;i++)cout<<dpcnt[1][i]<<\" \";cout<<endl;\n//\tfor(int i=0;i<26;i++)cout<<dpcnt[2][i]<<\" \";cout<<endl;\n\t\n//\tcout<<n1<<\" \"<<n2<<\" \"<<n3<<endl;\n\tgetii(l,r);\n\tcalc(mx-1,r,1);\n\tcalc(mx-1,l-1,-1);\n\tfor(int i=0;i<26;i++)cout<<ans[i]<<\" \";cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\trep(j,n)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXLEN = 4e5 + 5;\n\nstruct my_string {\n\tchar s[MAXLEN];\n\tint n;\n\t\n\tint z[MAXLEN];\n\t\n\tvoid get_z(){\n\t\tz[0] = 0;\n\t\tint l = 0, r = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif (i <= r){\n\t\t\t\tz[i] = min(r - i + 1, z[i - l]);\n\t\t\t}\n\t\t\twhile(i + z[i] < n && s[z[i]] == s[i + z[i]]){\n\t\t\t\tz[i]++;\n\t\t\t}\n\t\t\tif (i + z[i] - 1 > r){\n\t\t\t\tl = i;\n\t\t\t\tr = i + z[i] - 1;\n\t\t\t}\n\t\t}\n\t}\n};\n\nmy_string str;\n\nll cnt[200];\nll ans[200];\n\nll cnta[200], cntb[200];\n\nvector<pair<ll, ll> > vv;\nll len_a, len_b;\n\nvoid calc(ll pos, ll sgn, int ind) {\n\tif (pos <= 0) {\n\t\treturn;\n\t}\n\tif (ind <= 1) {\n\t\tREP(i, 0, pos) {\n\t\t\tans[str.s[i]] += sgn;\n\t\t}\n\t\treturn;\n\t}\n\tll cur_len = len_a * vv[ind]._1 + len_b * vv[ind]._2;\n\tif (cur_len > pos) {\n\t\tcalc(pos, sgn, ind - 1);\n\t\treturn;\n\t}\n\tcalc(pos - cur_len, sgn, ind - 1);\n\tREPN(i, 'a', 'z') {\n\t\tans[i] += sgn * vv[ind]._1 * cnta[i];\n\t\tans[i] += sgn * vv[ind]._2 * cntb[i];\n\t}\n}\n\n\nvoid solve(){\n\tll l, r;\n\tscanf(\"%s%lld%lld\", &str.s[0], &l, &r);\n\tstr.n = strlen(str.s) / 2;\n\tl--;\n\tr--;\n\tstr.get_z();\n\tint start = str.n;\n\tREP(i, 1, str.n) {\n\t\tif (str.z[i] == str.n - i) {\n\t\t\tstart = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (str.n % start == 0) {\n\t\tREP(i, 0, str.n) {\n\t\t\tcnt[str.s[i]]++;\n\t\t}\n\t\t\n\t\tfor(; l <= r; ) {\n\t\t\tif (l % str.n == 0) {\n\t\t\t\tif (l / str.n < r / str.n) {\n\t\t\t\t\tREPN(j, 'a', 'z') {\n\t\t\t\t\t\tans[j] += (r / str.n - l / str.n) * cnt[j];\n\t\t\t\t\t}\n\t\t\t\t\tl = r - r % str.n;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[str.s[l % str.n]]++;\n\t\t\tl++;\n\t\t}\n\t} else {\n\t\tif (start <= str.n / 2) {\n\t\t\t/*for(int i = start - 1; i >= 0; i--) {\n\t\t\t\tstr.s[str.n++] = str.s[i];\n\t\t\t}*/\n\t\t\tREP(i, 0, start) {\n\t\t\t\tstr.s[str.n++] = str.s[i];\n\t\t\t}\n\t\t\tstr.get_z();\n\t\t\tstart = str.n - start;\n\t\t}\n\t\tstr.s[str.n] = 0;\n\t\t\n\t\t//printf(\"%s\\n\", str.s);\n\t\t\n\t\tlen_a = str.n - start;\n\t\tlen_b = str.n - 2 * len_a;\n\t\t//printf(\"%lld %lld\\n\", len_a, len_b);\n\t\tREP(i, 0, str.n) {\n\t\t\tif (i < len_a) {\n\t\t\t\tcnta[str.s[i]]++;\n\t\t\t} else if (i < len_a + len_b) {\n\t\t\t\tcntb[str.s[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*REPN(j, 'a', 'z') {\n\t\t\tprintf(\"%lld \", cnta[j]);\n\t\t}\n\t\tputchar('\\n');\n\t\tREPN(j, 'a', 'z') {\n\t\t\tprintf(\"%lld \", cntb[j]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\t\n\t\tvv.pb(mp(1, 0));\t// A\n\t\tvv.pb(mp(1, 1));\t// AB\n\t\twhile(1) {\n\t\t\tint ind = SZ(vv) - 1;\n\t\t\tif (len_a * vv[ind]._1 + len_b * vv[ind]._2 > r) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvv.pb(mp(vv[ind]._1 + vv[ind - 1]._1, vv[ind]._2 + vv[ind - 1]._2)); \n\t\t}\n\t\t\n\t\tcalc(r + 1, 1, SZ(vv) - 1);\n\t\t\n\t\t/*REPN(j, 'a', 'z') {\n\t\t\tprintf(\"%lld \", ans[j]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\t\n\t\tcalc(l, -1, SZ(vv) - 1);\n\t}\n\tREPN(j, 'a', 'z') {\n\t\tprintf(\"%lld \", ans[j]);\n\t}\n\tputchar('\\n');\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll cnt[27];\nstring t;\nstring s; \n\nconst int MOD = 1e9 + 7;\nll S[500011];\nll powr[500011];\nll ipowr[500011];\nconst int C = 2017;\n\nll add(ll a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll modpow(ll a, ll b)\n{\n\tll r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nll hsh(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return S[r];\n\treturn mult(ipowr[l],add(S[r],MOD-S[l-1]));\n}\n\nll dp[111][27];\nll leng[111];\nconst ll INF=ll(2e18);\n\nvoid solve(ll len, int idx, int v)\n{\t\n\tif(len==0) return ;\n\tif(idx==0)\n\t{\n\t\tfor(int i=0;i<len;i++)\n\t\t{\n\t\t\tcnt[s[i]-'a']+=v;\n\t\t}\n\t\treturn ;\n\t}\n\tif(idx==1)\n\t{\n\t\tfor(int i=0;i<len;i++)\n\t\t{\n\t\t\tcnt[t[i]-'a']+=v;\n\t\t}\n\t\treturn ;\n\t}\n\tif(len<=leng[idx-1])\n\t{\n\t\tsolve(len,idx-1,v);\n\t\treturn ;\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tcnt[i]+=ll(v)*dp[idx-1][i];\n\t}\n\tsolve(len-leng[idx-1],idx-2,v);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>s;\n\ts=s.substr(0,s.length()/2);\n\tint n=s.length();\n\tll l,r; cin>>l>>r;\n\tpowr[0]=1; ipowr[0]=1;\n\tll iC = modpow(C,MOD-2);\n\tfor(int i=1;i<=500000;i++)\n\t{\n\t\tpowr[i]=mult(powr[i-1],C);\n\t\tipowr[i]=mult(ipowr[i-1],iC);\n\t}\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tS[i] = mult((s[i]-'a'+1),powr[i]);\n\t\tif(i>0) S[i]=add(S[i-1],S[i]);\n\t}\n\tint minper = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool pos=1;\n\t\tfor(int j=0;j<n;j+=i)\n\t\t{\n\t\t\tint lm=j; int rm=min(j+i-1,n-1);\n\t\t\tint ren = rm - j;\n\t\t\tif(hsh(0,ren)!=hsh(lm,rm))\n\t\t\t{\n\t\t\t\tpos=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pos)\n\t\t{\n\t\t\tminper=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tt=s+s.substr(0,minper);\n\tleng[0]=s.length(); leng[1]=t.length();\n\tfor(int i=0;i<s.length();i++) dp[0][s[i]-'a']++;\n\tfor(int i=0;i<t.length();i++) dp[1][t[i]-'a']++;\n\tfor(int i=2;i<=100;i++)\n\t{\n\t\tleng[i]=leng[i-1]+leng[i-2];\n\t\tif(leng[i]>=INF) leng[i]=INF;\n\t\tfor(int j=0;j<26;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i-2][j];\n\t\t\tif(dp[i][j]>=INF) dp[i][j]=INF;\n\t\t}\n\t}\n\tsolve(r,100,1);\n\tsolve(l-1,100,-1);\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tcout<<cnt[i];\n\t\tif(i+1<26) cout<<' ';\n\t}\n\tcout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\nconst bool DEBUG = 0;\n/// --- .lumrc Template {{{ ///\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\";\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\";\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n<<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\";\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\";\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\nstring s = ins;\nint n = s.size() / 2;\n\nll ans;\nint k = 0;\nconst int N = 1e5 + 10;\narray<ll, 27> cnt[N];\nconst int MAXS = 300;\narray<ll, 27> SS[300];\nint SSLength;\n\narray<ll, 27> add(array<ll, 27> a, array<ll, 27> b, bool minus = false) {\n  REP(i, 27) {\n    a[i] += b[i] * (minus ? -1 : 1);\n  }\n  return a;\n}\n\narray<ll, 27> solve(ll x) {\n  array<ll,27> res;\n  if(x <= n) {\n    return cnt[x];\n  }\n  array<ll,27> search;\n  search[0] = x;\n  search[1] = LINF;\n\n  int p = lower_bound(SS, SS + SSLength, search) - SS;\n  p--;\n  assert(p>=0);\n  // dump2(x, SS[p][0]);\n  // dump2(p, SSLength);\n  return add(SS[p], solve(x - SS[p][0]));\n}\n\null upow(ull a, ull b) {\n  ull res = 1;\n  while(b) {\n    if(b&1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  // ローリングハッシュ法で前半k文字と後半k文字で一致する\n  // ような最大のkを求める\n  dump(2);\n  ull backHash = 0;\n  ull forwardHash = 0;\n  REP(i, n-1) {\n    backHash *= 26;\n    backHash += s[i]-'a';\n    forwardHash += upow(26, i) * (s[n-1-i]-'a');\n    if(backHash == forwardHash) k = i + 1;\n  }\n  dump(k);\n  \n  dump(3);\n  ll l=inl, r=inl;\n  dump2(l, s);\n  \n  FOR(i, 1, n+1) {\n    cnt[i] = cnt[i-1];\n    cnt[i][0]++;\n    cnt[i][1+s[i-1]-'a']++;\n  }\n  REP(i, n-k) {\n    SS[0][0]++;\n    SS[0][1+s[i]-'a']++;\n  }\n  FOR(i, n-k, n) {\n    SS[1][0]++;\n    SS[1][1+s[i]-'a']++;\n  }\n  dump(4);\n  SSLength = MAXS;\n  FOR(i, 2, MAXS) {\n    REP(j, i-2+1) {\n      SS[i] = add(SS[i], SS[j]);\n      if(SS[i][0]>LINF) {\n        SSLength = i;\n        break;\n      }\n    }\n    if(SSLength!=MAXS) break;\n  }\n  \n  dump(1);\n  dump(r);\n  auto ans = add(solve(r), solve(l-1), true);\n  \n\n  dump(7);\n  REP(i, 26) {\n    cout << ans[i+1] << (i!=int(ans.size()-1)?\" \":\"\\n\");\n  }\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 9;\n\nchar s[N];\nint f[N], n, t, lim;\nusing ll = long long;\nll l, r, c[120][26], ans[26], fib[N];\n\nll Solve (ll x, int t) {\n\tll bs = x / t, b2 = x % t;\n\tbs *= t;\n\tfor (int i = 0; i < t; ++i) {\n\t\tans[s[i] - 'a'] += bs;\n\t\tif (i < b2) ans[s[i] - 'a'] += bs;\n\t}\n}\n\nll Solve2 (ll x, int t) {\n\tint now = lim;\n\twhile (now-- > 0) {\n\t\tif (x >= fib[now]) {\n\t\t\tfor (int i = 0; i < 26; ++i) ans[i] += c[now][i] * t;\n\t\t\tx -= fib[now], --now;\n\t\t}\n\t}\n}\n\nint main () {\n\tscanf(\"%s\", s); n = strlen(s); n >>= 1; s[n] = '\\0';\n\tscanf(\"%lld%lld\", &l, &r);\n\tfor (int i = 1, j; i < n; ++i) {\n\t\tj = f[i];\n\t\twhile (j && s[j] != s[i]) j = f[j];\n\t\tf[i + 1] = s[i] == s[j] ? j + 1 : 0;\n\t}\n\tt = n - f[n];\n\tif (n % t == 0) {\n\t\tSolve(r, 1); Solve(l - 1, -1);\n\t} else {\n\t\tfor (int i = 0; i < t; ++i) ++c[0][s[i] - 'a'];\n\t\tfor (int i = 0; i < n; ++i) ++c[1][s[i] - 'a'];\n\t\tfib[0] = t; fib[1] = n;\n\t\tfor (lim = 2; ; ++lim) {\n\t\t\tfor (int j = 0; j < 26; ++j) c[lim][j] = c[lim - 1][j] + c[lim - 2][j];\n\t\t\tif ((fib[lim] = fib[lim - 1] + fib[lim - 2]) >= 1e18) break;\n\t\t}\n\t\tSolve2(r, 1); Solve2(l - 1, -1);\n\t}\n\tfor (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\tbool chked = false;\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tchked = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(chked);\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\ntypedef long long ll;\n\nchar s[N];\nll l,r;\nint sum[N][26],c,nxt[N],k,n;\n\nll cal(ll m) {\n\tif(m<=n) return sum[m][c];\n\tll l1=n,l2=k,s1=sum[n][c],s2=sum[k][c];\n\twhile(l1+l2<=m) {\n\t\tll tmp=l1;l1+=l2;l2=tmp;\n\t\ttmp=s1;s1+=s2;s2=tmp;\n\t}\n\treturn s1+cal(m-l1);\n}\n\nint main() {\n\tscanf(\"%s\",s+1),n=strlen(s+1)/2;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<26;j++) sum[i][j]=sum[i-1][j];\n\t\t++sum[i][s[i]-'a'];\n\t}\n\tfor(int i=2,j=0;i<=n;i++) {\n\t\twhile(j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif(s[j+1]==s[i]) ++j;\n\t\tnxt[i]=j;\n\t}\n\tk=n-nxt[n];cin>>l>>r;\n\tfor(c=0;c<26;c++) cout<<cal(r)-cal(l-1)<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nvector<ll> z_algo(string S) {//0-index\n\tll N = S.size();\n\n\tvector<ll> A(N, 0);\n\n\n\tll c = 0;\n\trepn(i, N - 1) {\n\t\tif (c > 0 && i - c + A[i - c] < A[c]) { A[i] = A[i - c]; }\n\t\telse {\n\t\t\tll j = max(0, c + A[c] - i);\n\t\t\twhile (i + j < N && S[j] == S[i + j]) { j++; }\n\t\t\tA[i] = j;\n\t\t\tc = i;\n\t\t}\n\t}\n\n\tA[0] = N;\n\n\treturn A;\n}\n\nll pre(string S) {\n\tll N = S.size();\n\tvll z = z_algo(S);\n\t//rep(j, N)cout << z[j] << \" \";\n\t//cout << endl;\n\n\trepn(i, N) {\n\t\tbool b = 1;\n\t\tfor (ll j = i; j < N; j+=i) {\n\t\t\tif (z[j] < min(N - j, i)) { b = 0; break; }\n\t\t}\n\t\tif (b) { return i; break; }\n\t}\n}\n\nstring S;\nll N;\nll P;\n\nmap<ll, vll> mp;\n\nvll f;\n\nvoid cal(ll l) {\n\t//cout << l << endl;\n\tif (mp.count(l)) { return; }\n\n\tif (N % P == 0) {\n\t\tll k = l / P;\n\t\tvll v = mp[P];\n\t\trep(j, 26) { v[j] *= k; }\n\t\trep(j, 26) {\n\t\t\tv[j] += mp[l % P][j];\n\t\t}\n\t\tmp[l] = v;\n\n\t\t\n\t\treturn;\n\t}\n\n\tauto itr = lower_bound(f.begin(), f.end(), l);\n\tll x = distance(f.begin(), itr) - 1;\n\t//cout << x<<\" \"<<f[x] << endl;\n\t\n\tcal(f[x]);\n\tcal(l - f[x]);\n\n\tvll ret(26, 0);\n\trep(j, 26) {\n\t\tret[j] = mp[f[x]][j] + mp[l - f[x]][j];\n\t}\n\tmp[l] = ret;\n\treturn;\n}\n\nint main(){\n\tll l, r;\n\tcin >> S >> l >> r;\n\tll M = S.size();\n\tvll d = z_algo(S);\n\tN = M;\n\trepn(i, M - 1) {\n\t\tif (i * 2 >= M && d[i] >= M - i) { N = i; break; }\n\t}\n\tS = S.substr(0, N);\n\t//cout << S << endl;\n\n\tP = pre(S);\n\t//cout << N<<\" \"<<P << endl;\n\t\n\tvll c(26, 0);\n\tmp[0] = c;\n\trepn(i, N) {\n\t\tc[S[i - 1] - 'a']++;\n\t\tmp[i] = c;\n\t}\n\n\tf.assign(3, 0);\n\tf[0] = N;\n\tf[1] = N + P;\n\tf[2] = N * 2 + P;\n\tll X = 3;\n\twhile (1) {\n\t\tf.push_back(f[X - 1] - f[X - 3] + f[X - 1]);\n\t\tif (f[X] > INF || X > 500) { break; }\n\t\t//cout << f[X] << endl;\n\t\tX++;\n\t}\n\n\tcal(r);\n\tcal(l - 1);\n\trep(j, 26) {\n\t\tcout << mp[r][j] - mp[l - 1][j] << \" \";\n\t}\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nchar s[maxn]; int len;\nint h0[maxn], pw[maxn];\ninline int sub(int l,int r) {\n\treturn (h0[r] + ll(mod - pw[r - l + 1]) * h0[l - 1]) % mod;\n}\nstruct T { ll a[26]; };\ninline T add(T x, T y) {\n\tfor(int i = 0;i < 26;++i) {\n\t\tx.a[i] += y.a[i];\n\t}\n\treturn x;\n}\ninline T sub(T x, T y) {\n\tfor(int i = 0;i < 26;++i) {\n\t\tx.a[i] -= y.a[i];\n\t}\n\treturn x;\n}\ntypedef std::string str;\nT sum[maxn], empty;\nll size[maxn];\nint ok[maxn];\ninline void init(str s0, str s1) {\n\ts1 = s0 + s1;\n\tsize[1] = s0.size(), size[2] = s1.size();\n\tfor(char i : s0) ++ sum[1].a[i - 'a'];\n\tfor(char i : s1) ++ sum[2].a[i - 'a'];\n\tok[1] = ok[2] = 1;\n\tfor(int i = 3;i <= 100;++i) {\n\t\tsize[i] = size[i - 1] + size[i - 2];\n\t\tok[i] = ok[i - 1] && size[i] <= 2e18;\n\t\tsum[i] = add(sum[i - 1], sum[i - 2]);\n\t}\n}\ninline T pre(ll x) {\n\tT ans = empty;\n\tfor(int j = 100;j >= 0;--j) if(ok[j] && x >= size[j]) {\n\t\tans = add(ans, sum[j]);\n\t\tx -= size[j], --j;\n\t}\n\tfor(int j = 1;j <= x;++j) ++ ans.a[s[j] - 'a'];\n\treturn ans;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t*pw = 1;\n\tfor(int i = 1;i < maxn;++i) {\n\t\tpw[i] = pw[i - 1] * 233ll % mod;\n\t}\n\tcin >> s + 1, len = strlen(s + 1) >> 1;\n\tfor(int i = 1;i <= len;++i) {\n\t\th0[i] = (h0[i - 1] * 233ll + s[i]) % mod;\n\t}\n\tint border = -1;\n\tfor(int i = 1;i < len;++i) {\n\t\tif(sub(1, i) == sub(len - i + 1, len)) {\n\t\t\tborder = i;\n\t\t}\n\t}\n\tif(border << 1 >= len) {\n\t\tinit(str(s + border, s + len + 1), str(s + border, s + len + 1));\n\t} else if(border > 0) {\n\t\tinit(str(s + 1, s + len + 1), str(s + 1, s + len - border + 1));\n\t} else {\n\t\tinit(str(s + 1, s + len + 1), str(s + 1, s + len + 1));\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\tT ans = sub(pre(r), pre(l - 1));\n\tfor(int i = 0;i < 26;++i) {\n\t\tcout << ans.a[i] << ' ';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (false)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = false;\n\ts = conv(s);\n\t//cout << s << endl;\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 1; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t{\n\t\t\tassert(lim<=la);\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++,assert(s[i]>='a' && s[i]<='z');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(lim<=lb);\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++,assert(s[i]>='a' && s[i]<='z');\n\t\t}\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=len-(npos+1)*2;\n\t\t\tint wpos=pre[len/2-1];npos=len/2-1;\n\t\t\t\n\t\t\tif(wpos==-1)\n\t\t\t{\n\t\t\t\tsset(A[0],0,npos);\n\t\t\t\tsset(B[0],0,npos);\n\t\t\t\tsset(B[0],0,npos);\n\t\t\t\tla=npos+1;lb=la+la;\n\t\t\t\tsa=0,sb=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsset(A[0],0,wpos);\n\t\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\t\tsa=0,sb=wpos+1;\n\t\t\t}\n\t\t}\n\t}    \t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;i=-(~i))\nnamespace IO\n{\n\tconst unsigned int bufsize=1<<15,outsize=1<<24;\n\tstatic char ch[bufsize],*S=ch,*T=ch;\n\tinline char getc()\n\t{return ((S==T)&&(T=(S=ch)+fread(ch,1,bufsize,stdin),S==T)?0:*S++);}\n\tstatic char Out[outsize],*nowp=Out;\n\tinline void flush(){fwrite(Out,1,nowp-Out,stdout);nowp=Out;}\n\ttemplate<typename T>\n\t\tinline void read(T &x)\n\t\t{\n\t\t\tchar c=getc();x=0;\n\t\t\tfor(;!isdigit(c);c=getc());\n\t\t\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getc());\n\t\t}\n\ttemplate<typename T>\n\t\tinline void write(T x,char c='\\n')\n\t\t{\n\t\t\tif(!x)*nowp++='0';\n\t\t\tstatic unsigned int stk[50],tp=0;\n\t\t\tfor(;x;x/=10)stk[++tp]=x%10;\n\t\t\tfor(;tp;*nowp++=stk[tp--]^'0');*nowp++=c;\n\t\t}\n\tvoid readstr(char *str)\n\t{\n\t\tchar c=getc();\n\t\tfor(;!isalpha(c);c=getc());\n\t\tint len=0;\n\t\tfor(;isalpha(c);c=getc())str[++len]=c;\n\t}\n\tvoid writstr(char *str)\n\t{\n\t\tint len=strlen(str)-1;\n\t\tf(i,0,len)*nowp++=str[i];*nowp++='\\n';\n\t}\n}\nconst int leko=100,neko=200010;\ntypedef long long ll;\nll l,r,ans[30],len[leko],cnt[leko][30];\nnamespace String\n{\n\tchar s[neko];\n\tint fail[neko],n;\n\tvoid get_alpha(int x,ll *p)\n\t{f(i,1,x)++p[s[i]-'a'];}\n\tvoid get_border()\n\t{\n\t\tfail[0]=-1;\n\t\tfor(register int i=1,j=-1;i<=n;fail[i++]=++j)\n\t\t\tfor(;j>=0&&s[j+1]^s[i];j=fail[j]);\n\t\tlen[0]=n-fail[n],len[1]=n;\n\t\tget_alpha(len[0],cnt[0]),get_alpha(len[1],cnt[1]);\n\t}\n\tvoid get_ans(ll x)\n\t{\n\t\tif(x<=n)return get_alpha(x,ans);\n\t\tint i;\n\t\tfor(i=0;len[i+1]<=x;++i);\n\t\tf(j,0,25)ans[j]+=cnt[i][j];\n\t\tget_ans(x-len[i]);\n\t}\n\tvoid get_string(ll x)\n\t{\n\t\tget_border();\n\t\tfor(register int i=2;len[i-1]<=x;++i)\n\t\t{\n\t\t\tlen[i]=len[i-1]+len[i-2];\t\n\t\t\tf(j,0,25)cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t\t}\n\t}\n\n}\nint main()\n{\n\tusing namespace IO;\n\tusing namespace String;\n\treadstr(s),n=strlen(s+1)>>1;\n\tread(l),read(r);\n\tget_string(r),get_ans(l-1);\n\tf(i,0,25)ans[i]=-ans[i];\n\tget_ans(r);\n\tf(i,0,25)write(ans[i],i^iend?' ':'\\n');\n\treturn flush(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = s+t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<s+t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\twhile(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\twhile(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2 - fail[n / 2];\n\tint t = fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 500006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nlong long n,p,t,v[26],height[N],sa[N],fuckyouatcoder[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\nvoid SA()\n{\n\tfor(long long i=1;i<=n;i++)cntA[(long long)s[i]]++;\n\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(long long i=n;i;i--)sa[cntA[(long long)s[i]]--]=i;\n\tfuckyouatcoder[sa[1]]=1;\n\tfor(long long i=2;i<=n;i++){\n\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t}\n\tfor(long long l=1;fuckyouatcoder[sa[n]]!=n;l<<=1){\n\t\tfor(long long i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\tcntA[A[i]=fuckyouatcoder[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?fuckyouatcoder[i+l]:0)]++;\n\t\t}\n\t\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(long long i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(long long i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\tfuckyouatcoder[sa[1]]=1;\n\t\tfor(long long i=2;i<=n;i++){\n\t\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t\t}\n\t}\n\tlong long tot=0;\n\tfor(long long i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[fuckyouatcoder[i]-1]+tot])tot++;\n\t\theight[fuckyouatcoder[i]]=tot;\n\t}\n\tp=n;long long mi=N;\n\tfor(long long i=fuckyouatcoder[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(long long i=fuckyouatcoder[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(long long w,long long F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(long long i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(long long i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(long long i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(long long i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(long long i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(long long i=(l-n-1)%p+1;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(long long i=1;i<=(r-1)%p+1;i++)a[s[i]-97]++;\n\t\t\tfor(long long i=0;i<26;i++)a[i]+=1LL*v[i]*(r/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(long long i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(long long i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(long long i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(long long i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll len[200], cnt[200][26];\nint sum0[26][200001], sum1[26][400001];\n\nll rec(int n, ll l, ll r, int c){\n\tif(l >= len[n] || r <= 0) return 0;\n\tif(l <= 0 && len[n] <= r) return cnt[n][c];\n\t\n\tl = max(l, 0ll); r = min(r, len[n]);\n\t\n\tif(n <= 1){\n\t\tif(n == 1) return sum1[c][r] - sum1[c][l];\n\t\treturn sum0[c][r] - sum0[c][r];\n\t}\n\treturn rec(n - 1, l, r, c) + rec(n - 2, l - len[n - 1], r - len[n - 1], c);\n}\n\nint* buildFail(const string &s){\n\tint n = s.size();\n\tint *p = new int[n];\n\tp[0] = 0;\n\tfor (int i = 1; i < n; ++i){\n\t\tp[i] = p[i - 1];\n\t\twhile (p[i] > 0 && s[p[i]] != s[i]) p[i] = p[p[i] - 1];\n\t\tif (s[p[i]] == s[i]) p[i]++;\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tstring s;\n\tll l, r; cin >> s >> l >> r; l--;\n\tint n = s.size() / 2;\n\tint *f = buildFail(s.substr(0, n));\n\tint p = n - f[n - 1];\n\t\n\trep(i, n) assert(s[i] == s[i % p]);\n\t\n\tif(n % p == 0){\n\t\tassert(0);\n\t}\n\telse{\n\t\tstring t = s.substr(0, n) + s.substr(0, p);\n\t\tlen[0] = n;\n\t\tlen[1] = t.size();\n\t\trep(i, 26){\n\t\t\trep(j, n)        sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\trep(j, t.size()) sum1[i][j + 1] = sum1[i][j] + (t[j] == 'a' + i);\n\t\t\tcnt[0][i] = sum0[i][n];\n\t\t\tcnt[1][i] = sum1[i][t.size()];\n\t\t}\n\t\tint m = 1;\n\t\tfor(; len[m] < r; m++){\n\t\t\tlen[m + 1] = len[m] + len[m - 1];\n\t\t\trep(i, 26) cnt[m + 1][i] = cnt[m][i] + cnt[m - 1][i];\n\t\t}\n\t\trep(i, 26) cout << rec(m, l, r, i) << (i == 25 ? \"\\n\": \" \");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nchar in[2010000];\nint fail[2010000];\nint n;\nmap<pair<long long,long long>,long long>M;\nlong long calc(long long a,long long b,long long c,int d){\n\tif(M.count(make_pair(a,b)))return M[make_pair(a,b)];\n\t//printf(\"%lld %lld %lld %d\\n\",a,b,c,d);\n\tlong long ret=0;\n\tif(n>=b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif('a'+d==in[i])ret++;\n\t\t}\n\t\treturn M[make_pair(a,b)]=ret;\n\t}\n\tlong long to=b-c;\n\tlong long to2=c-to;\n\tret+=calc(min(a,c),c,to,d);\n\tif(a>c){\n\t\tret+=calc(a-c,to,to2,d);\n\t}\n\treturn M[make_pair(a,b)]=ret;\n}\nint main(){\n\tscanf(\"%s\",in);\n \n\tn=strlen(in)/2;\n \n\tfor(int i=1;i<n;i++){\n\t\tint at=fail[i];\n\t\twhile(1){\n\t\t\tif(in[at]==in[i]){\n\t\t\t\tfail[i+1]=at+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(at==0)break;\n\t\t\tat=fail[at];\n\t\t}\n\t}\n\tlong long L,R;\n\tscanf(\"%lld%lld\",&L,&R);\n\tL--;\n\tint sh=n-fail[n];\n\tlong long f1=n;\n\tlong long f2=sh;\n\twhile(f1<R){\n\t\tlong long tmp=f1+f2;\n\t\tf2=f1;f1=tmp;\n\t}\n\tfor(int i=0;i<26;i++){\n\t\tM.clear();\n\t\tprintf(\"%lld \",calc(R,f1,f2,i)-calc(L,f1,f2,i));\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nll rui[1000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = true;\n\ts = conv(s);\n\tvector<int>v = zalgo(s);\n\tfor (int i = 1; i < v.size() / 2; i++)\n\t{\n\t\tif (v[i] + i == s.size())\n\t\t{\n\t\t\tif (s.size() % i != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll len[200], cnt[200][26];\nint sum0[26][200001], sum1[26][400001];\n\nll rec(int n, ll l, ll r, int c){\n\tif(l >= len[n] || r <= 0) return 0;\n\tif(l <= 0 && len[n] <= r) return cnt[n][c];\n\t\n\tl = max(l, 0ll); r = min(r, len[n]);\n\t\n\tif(n <= 1){\n\t\tif(n == 1) return sum1[c][r] - sum1[c][l];\n\t\treturn sum0[c][r] - sum0[c][r];\n\t}\n\treturn rec(n - 1, l, r, c) + rec(n - 2, l - len[n - 1], r - len[n - 1], c);\n}\n\nint* buildFail(const string &s){\n\tint n = s.size();\n\tint *p = new int[n];\n\tp[0] = 0;\n\tfor (int i = 1; i < n; ++i){\n\t\tp[i] = p[i - 1];\n\t\twhile (p[i] > 0 && s[p[i]] != s[i]) p[i] = p[p[i] - 1];\n\t\tif (s[p[i]] == s[i]) p[i]++;\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tstring s;\n\tll l, r; cin >> s >> l >> r; l--;\n\tint n = s.size() / 2;\n\tint *f = buildFail(s.substr(0, n));\n\tint p = n - f[n - 1];\n\t\n\t//rep(i, n) assert(s[i] == s[i % p]);\n\t\n\tif(n % p == 0){\n\t\trep(i, 26){\n\t\t\trep(j, p) sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\tll k = r / p, m = l / p, cnt = 0;\n\t\t\tcnt += sum0[i][p] * k + sum0[i][r % p];\n\t\t\tcnt -= sum0[i][p] * m + sum0[i][l % p];\n\t\t\tcout << cnt << (i == 25 ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse{\n\t\tassert(0);\n\t\tstring t = s.substr(0, n) + s.substr(0, p);\n\t\tlen[0] = n;\n\t\tlen[1] = t.size();\n\t\trep(i, 26){\n\t\t\trep(j, n)        sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\trep(j, t.size()) sum1[i][j + 1] = sum1[i][j] + (t[j] == 'a' + i);\n\t\t\tcnt[0][i] = sum0[i][n];\n\t\t\tcnt[1][i] = sum1[i][t.size()];\n\t\t}\n\t\tint m = 1;\n\t\tfor(; len[m] < r; m++){\n\t\t\tlen[m + 1] = len[m] + len[m - 1];\n\t\t\trep(i, 26) cnt[m + 1][i] = cnt[m][i] + cnt[m - 1][i];\n\t\t}\n\t\trep(i, 26) cout << rec(m, l, r, i) << (i == 25 ? \"\\n\": \" \");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nstring S, T;\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p){\n\tvector<lint> dap(26);\n\tfor(int i=0; i<222; i++){\n\t\tif(p < dp[i]){\n\t\t\tif(i == 0){\n\t\t\t\tfor(int i=0; i<p; i++) dap[S[i] - 'a']++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=0; j<26; j++) dap[j] += cnt[i-1][j];\n\t\t\t\tauto k = solve(p - dp[i-1]);\n\t\t\t\tfor(int j=0; j<26; j++) dap[j] += k[j];\n\t\t\t}\n\t\t\treturn dap;\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tfor(int i=0; i<n / 2 - fail[n / 2]; i++) S.push_back(str[i]);\n\tfor(int i=0; i<n/2; i++) T.push_back(str[i]);\n\tfor(auto &i : S) cnt[0][i - 'a']++;\n\tfor(auto &i : T) cnt[1][i - 'a']++;\n\tdp[0] = S.size();\n\tdp[1] = T.size();\n\tfor(int i=2; i<200; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t}\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r);\n\tauto y = solve(l-1);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 200010;\ntypedef long long LL;\ntypedef std::vector<LL> V;\nV operator + (V a, V b) {\n\tfor (int i = 0; i != 26; ++i) a[i] += b[i];\n\treturn a;\n}\nstruct item {\n\tV a; char * s;\n\titem * l, * r; LL L;\n\titem() { a = V(26, 0); s = NULL, l = r = NULL; L = 0; }\n\tV qry(LL rr) {\n\t\tassert(rr <= L);\n\t\tif (s != NULL) {\n\t\t\tV res(26, 0);\n\t\t\tfor (int i = 0; i != rr; ++i) ++res[s[i] - 'a'];\n\t\t\treturn res;\n\t\t} else {\n\t\t\tif (rr <= l->L) return l->qry(rr);\n\t\t\treturn l->a + r->qry(rr - l->L);\n\t\t}\n\t}\n} is[100];\nchar buf[MAXN]; int n, fail[MAXN];\nchar s1[MAXN], s2[MAXN];\nLL ansl[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> buf + 1; n = strlen(buf + 1) / 2;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint now = fail[i - 1];\n\t\twhile (now && buf[now + 1] != buf[i]) now = fail[now];\n\t\t++now, fail[i] = now != i && buf[now] == buf[i] ? now : 0;\n\t}\n\tint tl = n - fail[n];\n\tstd::copy(buf + 1, buf + 1 + n, s2);\n\tstd::copy(buf + 1, buf + 1 + tl, s1);\n\tis[0].L = tl, is[0].s = s1, is[1].L = n, is[1].s = s2;\n\tis[0].a = is[0].qry(is[0].L);\n\tis[1].a = is[1].qry(is[1].L);\n\tLL L, R; std::cin >> L >> R;\n\tint cur = 1;\n\twhile (is[cur].L < R) {\n\t\t++cur;\n\t\tis[cur].a = is[cur - 1].a + is[cur - 2].a;\n\t\tis[cur].L = is[cur - 1].L + is[cur - 2].L;\n\t\tis[cur].l = &is[cur - 1], is[cur].r = &is[cur - 2];\n\t}\n\tV aa = is[cur].qry(R);\n\tV ab = L > 1 ? is[cur].qry(L - 1) : V(26, 0);\n\tfor (int i = 0; i < 26; ++i) std::cout << aa[i] - ab[i] << ' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nll rui[1000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t)\n{\n\tif (len[2] - len[1] == len[1] - len[0])\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\ts = conv(conv(s));\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf), v2 = get(lf - 1);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nvector<int> kmp(string s) {\n    int n = (int)s.size();\n    vector<int> ret(n, 0);\n    REP(i, n - 1) {\n        int j = ret[i];\n        while(1) {\n            if(j == 0) {\n                if(s[i + 1] == s[0]) ret[i + 1] = 1;\n                else ret[i + 1] = 0;\n                break;\n            }\n            if(s[j] == s[i + 1]) {\n                ret[i + 1] = j + 1;\n                break;\n            } else {\n                j = ret[j - 1];\n            }\n        }\n    }\n    return ret;\n}\n\nvector<ll> solve(string ss, ll m) {\n    string s = ss.substr(0, (int)ss.size() / 2);\n    ll n = (int)s.size();\n    vector<ll> ret(26, 0);\n    vector<int> v = kmp(s);\n    ll peri = n - v[n - 1];\n    string s0 = s.substr(0, peri);\n    if(n % peri == 0) {\n        ll a = m / peri, b = m % peri;\n        REP(i, peri) {\n            ret[s0[i] - 'a'] += a;\n            if(i < b) ret[s0[i] - 'a']++;\n        }\n    } else {\n        if(m <= 2 * n) {\n            REP(i, m) ret[ss[i] - 'a']++;\n            return ret;\n        }\n        vector<ll> l(101, 0);\n        vector<vector<ll>> c(101, vector<ll>(26, 0));\n        l[0] = s0.size(); REP(i, l[0]) c[0][s0[i] - 'a']++;\n        l[1] = s.size(); REP(i, l[1]) c[1][s[i] - 'a']++;\n        FOR(i, 2, 100) {\n            l[i] = l[i - 1] + l[i - 2];\n            REP(j, 26) c[i][j] = c[i - 1][j] + c[i - 2][j];\n            if(l[i] * 2 >= m) {\n                REP(j, 26) ret[j] += c[i][j];\n                ll rem = m - l[i];\n                for(ll j = i; j >= 0; j--) {\n                    if(j == 0) {\n                        REP(k, rem) ret[s0[k] - 'a']++;\n                        break;\n                    } else if(j == 1) {\n                        REP(k, rem) ret[s[k] - 'a']++;\n                        break;\n                    }\n                    if(rem <= l[j - 1]) continue;\n                    rem -= l[j - 1];\n                    REP(k, 26) ret[k] += c[j - 1][k];\n                    j--;\n                }\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    cin >> s;\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> ans = solve(s, r);\n    if(l) {\n        vector<ll> tmp = solve(s, l - 1);\n        REP(i, 26) ans[i] -= tmp[i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 200005\nusing namespace std;\n//ifstream cin(\"date.in\");\n//ofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    for(i = 1; i <= n; i++){\n        if(i <= n / 2 + n % 2){\n            a[i] = s[i];\n        }\n        else{\n            a[i + 1] = s[i];\n        }\n    }\n    a[n / 2 + n % 2 + 1] = '*';\n    for(i = 2; i <= n + 1; i++){\n        while(L > 0 && a[i] != a[L + 1]){\n            L = p[L];\n        }\n        if(a[i] == a[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    n = n - p[n + 1];\n    L = 0;\n    for(i = 2; i <= n; i++){\n        while(L > 0 && s[i] != s[L + 1]){\n            L = p[L];\n        }\n        if(s[i] == s[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    for(i = 1; i <= n; i++){\n        ok = 1;\n        for(j = i + i; j <= n; j += i){\n            if(p[j] != j - i){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(j = j - i + 1; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n >= dr || fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\nvector<int>zalgo(string s)\n{\n\tvector<int>r;\n\tr.resize(s.size());\n\tr[0] = s.size();\n\ts.push_back('$');\n\tint pt = 1, kn = 0;\n\tfor (;;)\n\t{\n\t\tif (pt == s.size() - 1)break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (s[pt + kn] != s[kn])break;\n\t\t\telse kn++;\n\t\t}\n\t\tr[pt] = kn;\n\t\tint t = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (r[t] < kn - t)r[pt + t] = r[t], t++;\n\t\t\telse break;\n\t\t}\n\t\tpt += t;\n\t\tkn = max(0, kn - t);\n\t}\n\treturn r;\n}\ntypedef long long ll;\nvector<ll>get1(ll a, string s)\n{\n\tvector<ll>r;\n\tr.resize(26);\n\tfor (int i = 0; i < s.size(); i++)r[s[i] - 'a'] += a / s.size();\n\tfor (int i = 0; i < a%s.size(); i++)r[s[i] - 'a']++;\n\treturn r;\n}\nvector<ll>fib[1000];\nll len[1000];\nvector<ll>get2(ll a, string x, string y)\n{\n\tif (a <= x.size() + y.size())\n\t{\n\t\tvector<ll>r;\n\t\tr.resize(26);\n\t\tfor (int i = 0; i < min(a, (ll)(x.size())); i++)r[x[i] - 'a']++;\n\t\tfor (int i = x.size(); i < a; i++)r[y[i - x.size()] - 'a']++;\n\t\treturn r;\n\t}\n\tint rr;\n\tfor (int i = 0;; i++)\n\t{\n\t\tif (len[i] <= a)rr = i;\n\t\telse break;\n\t}\n\tvector<ll>r = fib[rr];\n\tvector<ll>s = get2(a - len[rr], x, y);\n\tfor (int i = 0; i < 26; i++)r[i] += s[i];\n\treturn r;\n}\nint main()\n{\n\tstring zs;\n\tcin >> zs;\n\tll lb, ub;\n\tscanf(\"%lld%lld\", &lb, &ub);\n\tstring s;\n\tfor (int i = 0; i < zs.size() / 2; i++)s.push_back(zs[i]);\n\tvector<int>v = zalgo(s);\n\tint rr = -1;\n\tfor (int i = 1; i < v.size(); i++)\n\t{\n\t\tif (v[i] == s.size() - i)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rr == -1 || s.size() % rr == 0)\n\t{\n\t\tvector<ll>a = get1(ub, s), b = get1(lb - 1, s);\n\t\tfor (int i = 0; i < 26; i++)printf(\"%lld \", a[i] - b[i]);\n\t\tprintf(\"\\n\");\n\t}\n\telse\n\t{\n\t\tstring x, y;\n\t\tfor (int i = 0; i < rr; i++)x.push_back(s[i]);\n\t\tfor (int i = rr; i < s.size(); i++)y.push_back(s[i]);\n\t\tfor (int i = 0; i < 200; i++)fib[i].resize(26);\n\t\tfor (int i = 0; i < x.size(); i++)fib[0][x[i] - 'a']++, fib[1][x[i] - 'a'] += 2;\n\t\tfor (int i = 0; i < y.size(); i++)fib[0][y[i] - 'a']++, fib[1][y[i] - 'a']++;\n\t\tfor (int i = 2; i < 200; i++)for (int j = 0; j < 26; j++)fib[i][j] = fib[i - 1][j] + fib[i - 2][j];\n\t\tlen[0] = x.size() + y.size(), len[1] = x.size() + y.size() + x.size();\n\t\tfor (int i = 2; i < 200; i++)len[i] = len[i - 1] + len[i - 2];\n\t\tvector<ll>a = get2(ub, x, y), b = get2(lb - 1, x, y);\n\t\tfor (int i = 0; i < 26; i++)printf(\"%lld \", a[i] - b[i]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n//Z Algorithm\n#include<cstdio>\n#include<cstring>\n#include<valarray>\nusing namespace std;\npair<valarray<long long>,long long> f(long long n,long long l,const valarray<long long> &left,long long r,const valarray<long long> &right)\n{\n\tvalarray<long long> ans(26);\n\tif(l+r<=n)\n\t{\n\t\tauto x=f(n,l+r,left+right,l,left);\n\t\tans+=x.first;\n\t\tn=x.second;\n\t}\n\tif(l<=n)ans+=left,n-=l;\n\treturn make_pair(ans,n);\n}\nchar s[300000];\nlong long cnt[300000][30],z[300000],n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tz[1]=n;\n\tlong long l=1,r=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tif(i>r)\n\t\t{\n\t\t\tz[i]=0;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tif(z[i])l=i,r=i+z[i]-1;\n\t\t}\n\t\telse if(z[i-l+1]<r-i+1)z[i]=z[i-l+1];\n\t\telse\n\t\t{\n\t\t\tz[i]=r-i+1;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tl=i,r=i+z[i]-1;\n\t\t}\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tfor(long long j=0;j<26;j++)cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tlong long k=0;\n\tfor(long long i=n;i>1;i--)\n\t\tif(z[i]+i-1==n)k=z[i];\n\tscanf(\"%lld%lld\",&l,&r);l--;\n\tif(!k)\n\t{\n\t\tfor(long long i=0;i<26;i++)printf(\"%lld \",cnt[n][i]*(r/n)+cnt[r%n][i]-cnt[n][i]*(l/n)-cnt[l%n][i]);\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\tvalarray<long long> left(26),right(26);\n\tfor(long long i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(long long i=0;i<26;i++)printf(\"%lld \",upper.first[i]-lower.first[i]+cnt[upper.second][i]-cnt[lower.second][i]);\n\tputchar('\\n');\n\treturn 0;\n}\n#else\n#include<iostream>\n#include<cstring>\n#include<valarray>\n#define array valarray<long long>\nusing namespace std;\nlong long a[200011],b[200011],p[200011]={1},q[200011]={1},moda=1000000007,modb=2147483647,cnt[300000][27];\nchar s[300000];\npair<long long,long long> query(int l,int r){return make_pair((p[r-l]*a[l]-a[r]+moda)%moda,(q[r-l]*b[l]-b[r]+modb)%modb);}\npair<array,long long> f(long long n,long long l,const array &left,long long r,const array &right)\n{\n\tarray ans(26);\n\tif(l+r<=n)\n\t{\n\t\tauto x=f(n,l+r,left+right,l,left);\n\t\tans+=x.first;\n\t\tn=x.second;\n\t}\n\tif(l<=n)\n\t{\n\t\tans+=left;\n\t\tn-=l;\n\t}\n\treturn make_pair(ans,n);\n}\nint main()\n{\n\tint l,r;\n\tstring s;\n\tcin>>s>>l>>r;l--;\n\ts=s.substr(0,s.size()>>1);\n\tlong long n=s.size();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=(a[i-1]*17+s[i-1]-'a')%moda;\n\t\tb[i]=(b[i-1]*19+s[i-1]-'a')%modb;\n\t\tp[i]=p[i-1]*17%moda;\n\t\tq[i]=q[i-1]*19%modb;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)cnt[i+1][j]=cnt[i][j];\n\t\tcnt[i+1][s[i]-'a']++;\n\t}\n\tint k=0;\n\tfor(int i=0;i<n;i++)\n\t\tif(query(0,i)==query(n-i,n))k=i;\n\tif(!k)\n\t{\n\t\tfor(int i=0;i<26;i++)cout<<cnt[n][i]*(r/n)-cnt[n][i]*(l/n)+cnt[r%n][i]-cnt[l%n][i]<<' ';\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\tarray left(26),right(26);\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(int i=0;i<26;i++)cout<<upper.first[i]+cnt[upper.second][i]-lower.first[i]-cnt[lower.second][i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,m,fail[100010];\nll ans[30],len[95],sum[95][30],cnt[100010][30];\nchar s[100010];\nvoid kmp()\n{\n\tfail[0]=-1;\n\tint p=-1;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\twhile (p>=0 && s[i]!=s[p+1])\n\t\t{\n\t\t\tp=fail[p];\n\t\t}\n\t\tif (s[i]==s[p+1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\tfail[i]=p;\n\t}\n}\nvoid solve(ll k,ll f)\n{\n\tll p=k/(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*p*cnt[m][i];\n\t}\n\tll q=k%(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[q][i];\n\t}\n}\nvoid work(ll k,ll f)\n{\n\tint i=1;\n\twhile (len[i]<=k)\n\t{\n\t\ti++;\n\t}\n\tassert(len[i]>k);\n\tfor (;i;i--)\n\t{\n\t\tif (k>len[i])\n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tans[j]+=f*sum[i][j];\n\t\t\t}\n\t\t\tk-=len[i];\n\t\t}\n\t}\n\tfor (i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[k][i];\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",&s);\n\tn=strlen(s);\n\tn/=2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tkmp();\n\tm=n-1-fail[n-1];\n\tll l,r;\n\tcin>>l>>r;\n\tif (n%m==0)\n\t{\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t}\n\telse\n\t{\n\t\tlen[1]=n;\n\t\tlen[2]=m+n;\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tsum[1][i]=cnt[n][i];\n\t\t\tsum[2][i]=cnt[m][i]+sum[1][i];\n\t\t}\n\t\tfor (int i=3;i<=90;i++)\n\t\t{\n\t\t\tlen[i]=len[i-2]+len[i-1];\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\t\t}\n\t\t}\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define iter(i, n) forw(i, 1, n)\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef vector<i64> Info;\n\nconst int NR = 2e5 + 100;\n\ni64 f[200];\nint p[NR];\nstring s, t;\ni64 L, R;\nint n;\n\nInfo c[200];\n\nInfo add(Info a, Info b) {\n\tInfo c(26);\n\tfor (int i = 0; i < 26; ++i) c[i] = a[i] + b[i];\n\treturn c;\n}\n\nInfo count(string s) {\n\tInfo a(26);\n\tfor (char c : s) ++a[c - 'a'];\n\treturn a;\n}\n\nInfo print(int n, i64 L, i64 R) {\n//\tprintf(\"%d %lld %lld\\n\", n, L, R);\n\tif (L == 1 && R == f[n]) {\n\t\treturn c[n];\n\t}\n\n\tif (n < 2) {\n\t\treturn count((n == 0 ? s : s + t).substr(L - 1, R - L + 1));\n\t}\n\n\ti64 t = f[n - 1];\n\tif (R <= t) return print(n - 1, L, R);\n\telse if (L > t) return print(n - 2, L - t, R - t);\n\telse {\n\t\treturn add(print(n - 1, L, t), print(n - 2, 1, R - t));\n\t}\n}\n\nstring per(string s) {\n\tint j = -1, n = s.length();\n\tp[0] = -1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (; j >= 0 && s[i] != s[j + 1]; j = p[j]);\n\t\tif (s[i] == s[j + 1]) ++j;\n\t\tp[i] = j;\n\t}\n\treturn s.substr(0, n - 1 - p[n - 1]);\n}\n\n\n\nint main() {\n\t//freopen(\"77F.in\", \"r\", stdin);\n\tcin >> s >> L >> R;\n\ts = s.substr(0, s.length() / 2);\n\tt = per(s);\n\tf[0] = s.length();\n\tc[0] = count(s);\n\tf[1] = f[0] + t.length();\n\tc[1] = add(c[0], count(t));\n\tfor (n = 2; (u64) f[n - 1] + f[n - 2] <= 1e18; ++n)\n\t\tf[n] = f[n - 1] + f[n - 2], \n\t\tc[n] = add(c[n - 1], c[n - 2]);\n\tInfo tmp = print(n, L, R);\n\tfor (int i = 0; i < 26; ++i) printf(\"%lld \", tmp[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 100003;\nchar s[MaxN];\nLL l,r;\nint cnt[MaxN][26];\nstruct Statu{\n\tLL s[26];\n\tStatu() {memset(s,0,sizeof s);}\n\ttemplate<typename T>\n\tStatu(const T* x) {\n\t\tfor (LL* p=s;p<s+26;++p,++x) *p=*x;\n\t}\n\tinline LL& operator [](const char& ch) {\n\t\treturn *(s+(int)ch-'a');\n\t}\n\tinline LL& operator [] (const int& x) {\n\t\treturn *(s+x);\n\t}\n\tinline Statu& operator +=(const Statu& o) {\n\t\tfor (int i=0;i<26;++i) s[i]+=o.s[i];\n\t\treturn *this;\n\t}\n\tinline Statu operator +(const Statu& b) const {\n\t\tStatu ret;\n\t\tfor (int i=0;i<26;++i) ret.s[i]=s[i]+b.s[i];\n\t\treturn ret;\n\t}\n\tinline void print() const {\n\t\tfor (int i=0;i<26;++i) printf(\"%I64d \",s[i]);\n\t\tputchar('\\n');\n\t}\n};\n\ninline int* Z_box(const char* str,int* z) {\n\tint r=-1,p=-1,l=strlen(str);\n\tz[0]=l-1;\n\tfor (int i=1;i<l;++i) {\n\t\tz[i]=-1;\n\t\tif (r>=i) z[i]=min(z[i-p],r-i);\n\t\twhile (i+z[i]+1<l && str[i+z[i]+1]==str[z[i]+1]) z[i]++;\n\t\tif (i+z[i]>r) r=i+z[i],p=i;\n\t}\n\treturn z;\n}\n\nLL solve(LL llen,Statu L,LL rlen,Statu R,LL last,Statu& ans) {\n\tif (llen+rlen<=last) {\n\t\tLL t=solve(llen+rlen,L+R,llen,L,last,ans);\n\t\tlast=t;\n\t}\n\tif (llen<=last) {\n\t\tans+=L;\n\t\tlast-=llen;\n\t}\n\treturn last;\n} \nchar s2[MaxN];int z[MaxN];\nint main() {\n\tscanf(\"%s%I64d%I64d\",s,&l,&r);\n\tint len=strlen(s);\n\tfor (int i=0;i<len/2;++i) s2[i]=s[i];\n\tint l2=strlen(s2);\n\tZ_box(s2,z);\n\tmemset(cnt,0,sizeof cnt);\n\tcnt[0][s[0]-'a']=1;\n\tfor (int i=1;i<l2;++i) {\n\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tint pre=0x7fffffff; \n\tfor (int i=1;i<l2;++i) {\n\t\tif (z[i]!=-1 && i+z[i]==l2-1) pre=min(pre,i); \n\t}\n\tif (pre==0x7fffffff) {\n\t\tStatu ans;\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]+=(LL)cnt[l2-1][i]*(r/l2)+cnt[r%l2][i];\n\t\t\tif (l>=1) ans[i]-=(LL)cnt[l2-1][i]*((l-1)/l2)+cnt[(l-1)%l2][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) printf(\"%I64d \",ans[i]);\n\t} else {\n\t\tStatu L,R,ans1,ans2,ans;\n\t\tfor (int i=0;i<26;++i) \n\t\t\tL[i]=cnt[pre-1][i],\n\t\t\tR[i]=cnt[l2-1][i]-cnt[pre-1][i];\n\t\tLL x1=solve(pre,L,l2-pre,R,r+1,ans1),x2=solve(pre,L,l2-pre,R,l,ans2);\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]=ans1[i]-ans2[i]; \n\t\t\tif (x1>=1) ans[i]+=cnt[x1-1][i];\n\t\t\tif (x2>=1) ans[i]-=cnt[x2-1][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) printf(\"%I64d \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 2e5+3;\nchar s[MaxN];\nLL l,r;\nint cnt[MaxN][26];\nstruct Statu{\n\tLL s[26];\n\tStatu() {memset(s,0,sizeof s);}\n\ttemplate<typename T>\n\tStatu(const T* x) {\n\t\tfor (LL* p=s;p<s+26;++p,++x) *p=*x;\n\t}\n\tinline LL& operator [](const char& ch) {\n\t\treturn *(s+(int)ch-'a');\n\t}\n\tinline LL& operator [] (const int& x) {\n\t\treturn *(s+x);\n\t}\n\tinline Statu& operator +=(const Statu& o) {\n\t\tfor (int i=0;i<26;++i) s[i]+=o.s[i];\n\t\treturn *this;\n\t}\n\tinline Statu operator +(const Statu& b) const {\n\t\tStatu ret;\n\t\tfor (int i=0;i<26;++i) ret.s[i]=s[i]+b.s[i];\n\t\treturn ret;\n\t}\n\tinline void print() const {\n\t\tfor (int i=0;i<26;++i) printf(\"%I64d \",s[i]);\n\t\tputchar('\\n');\n\t}\n};\n\ninline int* Z_box(const char* str,int* z) {\n\tint r=-1,p=-1,l=strlen(str);\n\tz[0]=l-1;\n\tfor (int i=1;i<l;++i) {\n\t\tz[i]=-1;\n\t\tif (r>=i) z[i]=min(z[i-p],r-i);\n\t\twhile (i+z[i]+1<l && str[i+z[i]+1]==str[z[i]+1]) z[i]++;\n\t\tif (i+z[i]>r) r=i+z[i],p=i;\n\t}\n\treturn z;\n}\n\nLL solve(LL llen,Statu L,LL rlen,Statu R,LL last,Statu& ans) {\n\tif (llen+rlen<=last) {\n\t\tLL t=solve(llen+rlen,L+R,llen,L,last,ans);\n\t\tlast=t;\n\t}\n\tif (llen<=last) {\n\t\tans+=L;\n\t\tlast-=llen;\n\t}\n\treturn last;\n} \nchar s2[MaxN];int z[MaxN];\nint main() {\n\tscanf(\"%s\",s);\n\tcin >> l >> r;\n\tl--,r--;\n\tint len=strlen(s);\n\tfor (int i=0;i<len/2;++i) s2[i]=s[i];\n\tint l2=strlen(s2);\n\tZ_box(s2,z);\n\tmemset(cnt,0,sizeof cnt);\n\tcnt[0][s[0]-'a']=1;\n\tfor (int i=1;i<l2;++i) {\n\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tint pre=0x7fffffff; \n\tfor (int i=1;i<l2;++i) {\n\t\tif (z[i]!=-1 && i+z[i]==l2-1) pre=min(pre,i); \n\t}\n\tif (pre==0x7fffffff) {\n\t\tStatu ans;\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]+=(LL)cnt[l2-1][i]*(r/l2)+cnt[r%l2][i];\n\t\t\tif (l>=1) ans[i]-=(LL)cnt[l2-1][i]*((l-1)/l2)+cnt[(l-1)%l2][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) cout << ans[i] << \" \";\n\t} else {\n\t\tStatu L,R,ans1,ans2,ans;\n\t\tfor (int i=0;i<26;++i) \n\t\t\tL[i]=cnt[pre-1][i],\n\t\t\tR[i]=cnt[l2-1][i]-cnt[pre-1][i];\n\t\tLL x1=solve(pre,L,l2-pre,R,r+1,ans1),x2=solve(pre,L,l2-pre,R,l,ans2);\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]=ans1[i]-ans2[i]; \n\t\t\tif (x1>=1) ans[i]+=cnt[x1-1][i];\n\t\t\tif (x2>=1) ans[i]-=cnt[x2-1][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) cout << ans[i] << \" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4;\n\nchar s[N];\nint len,n,m;\nll L,R;\nint app[N][26],p[N];\n\nll count(ll a,ll b)\n{\n\tif(a<=(n<<1))return a<=n?app[a][b]:app[n][b]+app[a-n][b];\n\tll f1=n,f2=m,k1=app[n][b],k2=app[m][b],k3,f3;\n\twhile(f1*2<a){\n\t\tf3=f1+f2; f2=f1; f1=f3;\n\t\tk3=k1+k2; k2=k1; k1=k3;\n\t}\n\treturn k3+count(a-f1,b);\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tlen=strlen(s+1); n=len>>1;\n\tcin>>L>>R; --L;\n\tfo(i,1,n){\n\t\tfo(l,0,25)app[i][l]=app[i-1][l];\n\t\t++app[i][s[i]-97];\n\t}\n\tfor(int j=0,i=2;i<=n;++i){\n\t\twhile(j!=0&&s[j+1]!=s[i])j=p[j];\n\t\tif(s[j+1]==s[i])++j;\n\t\tp[i]=j;\n\t}\n\tm=n-p[n];\n\tfo(i,0,25)printf(\"%lld \",count(R,i)-count(L,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nvoid init() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tn-=j;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tinit();s[n]='\\0';\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\tdwn(j,m,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=2e6+5,M=1e7+50,mo=1e9+7;\nint fail[N],n,i,per;\nll len1,len2,d,prt[30],l,r,f[305][26],g[305][26],sf[305],sg[305];\nchar s[N];\nvoid kmp()\n{\n\tint i,j;\n\tj=0;\n\tn=strlen(s+1)/2;\n\tfo(i,2,n)\n\t{\n\t\twhile (j&&s[i]!=s[j+1]) j=fail[j];\n\t\tif (s[i]==s[j+1]) j++;\n\t\tfail[i]=j;\n\t}\n}\nvoid fib()\n{\n\tint i,j;\n\tfo(i,2,300)\n\t{\n\t\tfo(j,0,25)  g[i][j]=g[i-1][j]+g[i-2][j];\n\t\tsg[i]=sg[i-1]+sg[i-2];\n\t\tif (sg[i]*2>r) break;\n\t}\n\tfo(i,0,300)\n\t{\n\t\tfo(j,0,25) f[i][j]=g[i][j]*2;\n\t\tsf[i]=sg[i]*2;\n\t\tif (sf[i]>r) break;\n\t}\n}\nvoid calc(ll x,ll xs)\n{\n\tint pos;\n\tfo(pos,0,300)\n\t\tif (sf[pos]>x) break;\n\twhile (pos>=0)\n\t{\n\t\tif (sf[pos]<=x)\n\t\t{\n\t\t\tfo(i,0,25) prt[i]+=xs*f[pos][i];\n\t\t\tx-=sf[pos];\n\t\t\tpos--;\n\t\t}else\n\t\tpos--;\n\t}\n\tfo(i,1,x) prt[s[i]-'a']+=xs; \n}\nint main()\n{\n\tscanf(\"%s %lld %lld\",s+1,&l,&r);\n\tkmp();\n\tfo(i,1,n) g[0][s[i]-'a']++,sg[0]++;\n\tper=n-fail[n];\n\tfo(i,0,25) g[1][i]=g[0][i];\n\tsg[1]=sg[0];\n\tfo(i,1,per) g[1][s[i]-'a']++,sg[1]++;\n\tfib();\n\tcalc(r,1);\n\tcalc(l-1,-1);\n\tfo(i,0,25) printf(\"%lld \",prt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef __int128 INT;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\nV kmp_table_build(string word){\n    int n=word.size();\n    V table(n+1,0);\n    table[0]=-1;\n    for(int i=2,j=0;i<=n;){\n        if(word[i-1]==word[j])table[i++]=++j;\n        else if(j>0)j=table[j];\n        else table[i++]=0;\n    }\n    return table;\n}\n\nV f(string s,INT k){\n    LL x=s.size();\n    V ret(26,0);\n    LL loop=k/x;\n    for(auto &it:s)ret[it-'a']+=loop;\n    k-=loop*x;\n    REP(i,k)ret[s[i]-'a']++;\n    return ret;\n}\nV g(string &s1,VV &c,vector<INT> &l,INT k,int id){\n    if(k==0)return V(26,0);\n    if(id<=1){\n        V ret(26,0);\n        REP(i,k)ret[s1[i]-'a']++;\n        return ret;\n    }\n    if(l[id-1]<=k){\n        V ret=c[id-1];\n        V rest=g(s1,c,l,k-l[id-1],id-2);\n        REP(i,26)ret[i]+=rest[i];\n        return ret;\n    }\n    else return g(s1,c,l,k,id-1);\n}\n\nint main(){\n    string s;LL l,r;\n    cin>>s>>l>>r;\n    LL n=s.size()/2;\n    s=s.substr(0,n);\n    V table=kmp_table_build(s);\n    LL x=n-table[n];\n    if(n%x==0){\n        s=s.substr(0,x);\n        auto a=f(s,r);\n        auto b=f(s,l-1);\n        REP(i,26)cout<<\" \"+(!i)<<a[i]-b[i];cout<<endl;\n    }\n    else{\n        VV cnt(128,V(26,0));\n        vector<INT> len(128);\n        REP(i,n)cnt[0][s[i]-'a']++;\n        len[0]=n;\n        len[1]=n+x;\n        cnt[1]=cnt[0];\n        REP(i,x)cnt[1][s[i]-'a']++;\n        int id=-1;\n        FOR(i,2,128){\n            len[i]=len[i-1]+len[i-2];\n            //cout<<i<<\":\"<<(int)len[i]<<endl;\n                        \n            REP(j,26)cnt[i][j]+=cnt[i-1][j]+cnt[i-2][j];\n            if(len[i]>r){\n                id=i;\n                break;\n            }\n        }\n        s=s+s.substr(0,x);\n        auto a=g(s,cnt,len,r,id);\n        auto b=g(s,cnt,len,l-1,id);\n        REP(i,26)cout<<\" \"+(!i)<<a[i]-b[i];cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nconst int H=31;\nll l,r;\nint n,len,len2; \nstring s;\nint cnt[maxn][maxm];\nint hash[maxn],power[maxn],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nbool same(int pos){\n\tint k1=hash[pos-1],k2=hash[n-1]-hash[n-1-pos]*power[pos];\n\treturn k1==k2;\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\thash[0]=s[0]-'a';power[0]=1;\n\tREP(i,n-1)hash[i]=hash[i-1]*H+s[i]-'a',power[i]=power[i-1]*H;\n\tREP(i,n-1)if(same(i))len=max(len,i);\n\t\n//\tZ_algorithm();\n//\tREP(i,n-1)if(z[i]+i==n)len2=max(len2,i);\n\n\tif(len==0){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tlen=n-len;\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nint n,p,t,v[26],height[N],sa[N],rank[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\ninline int read()\n{\n\tint x=0,c=getchar(),f=1;while(c<'0'||c>'9')f=(c=='-'?-f:f),c=getchar();\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+c-48,c=getchar();return f>0?x:-x;\n}\nvoid print(long long x)\n{\n\tif(x>9)print(x/10);putchar(x%10+48);\n}\nvoid SA()\n{\n\tfor(int i=1;i<=n;i++)cntA[s[i]]++;\n\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(int i=n;i;i--)sa[cntA[s[i]]--]=i;\n\trank[sa[1]]=1;\n\tfor(int i=2;i<=n;i++){\n\t\trank[sa[i]]=rank[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])rank[sa[i]]++;\n\t}\n\tfor(int l=1;rank[sa[n]]!=n;l<<=1){\n\t\tfor(int i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcntA[A[i]=rank[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?rank[i+l]:0)]++;\n\t\t}\n\t\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(int i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(int i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\trank[sa[1]]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\trank[sa[i]]=rank[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])rank[sa[i]]++;\n\t\t}\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[rank[i]-1]+tot])tot++;\n\t\theight[rank[i]]=tot;\n\t}\n\tp=n;int mi=N;\n\tfor(int i=rank[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(int i=rank[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(int w,int F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(int i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(int i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(int i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(int i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(int i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(int i=(l-n)%p;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(int i=1;i<=r%p;i++)a[s[i]-97]++;\n\t\t\tfor(int i=0;i<26;i++)a[i]+=1LL*v[i]*(r/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(int i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(int i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(int i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(int i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 2000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nstring f1(string s) {\n    rep(i, 0, sz(s)) {\n        string t = s.substr(0, i + 1);\n        t += t;\n        if (sz(t) > sz(s) && t.substr(0, sz(s)) == s) {\n            return t;\n        }\n    }\n    return \"\";\n}\n\nstring f(string s) {\n    repb(i, sz(s) - 1, 0) {\n        if (s.substr(0, i) == s.substr(sz(s) - i)) {\n            return s + s.substr(0, sz(s) - i);\n        }\n    }\n    return \"\";\n}\n\nvoid fff1(string s) {\n    rep(i, 0, 6) {\n        cout << s << endl;\n        s = f1(s);\n    }\n}\n\nvoid ff2(string s) {\n    rep(i, 0, 6) {\n        cout << s << endl;\n        s = f(s);\n    }\n}\n\nvoid prefix_function(string &s, vector<int> &p) {\n    int n = sz(s);\n    rep(i, 0, n) {\n        int c = i - 1;\n        while (c >= 0) {\n            if (s[p[c]] == s[i]) {\n                p[i] = p[c] + 1;\n                break;\n            }\n            c = p[c] - 1;\n        }\n        if (c == -1) {\n            p[i] = 0;\n        }\n    }\n}\n\nvector<ll> solve1(string s, ll x) {\n    vector<ll> res(26, 0);\n    rep(i, 0, sz(s)) {\n        res[s[i] - 'a'] += x / sz(s);\n    }\n    rep(i, 0, x % sz(s)) {\n        res[s[i] - 'a']++;\n    }\n    return res;\n}\n\nvoid solve(string s) {\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve1(s, r), b = solve1(s, l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nstring t1, t2;\nvector<ll> c1(26, 0), c2(26, 0);\nll len[100], cnt1[100], cnt2[100];\nvector<ll> ans;\n\nvoid init(string &s, string &per) {\n    t1 = s;\n    t2 = s + per;\n    rep(i, 0, sz(t1)) {\n        c1[t1[i] - 'a']++;\n    }\n    rep(i, 0, sz(t2)) {\n        c2[t2[i] - 'a']++;\n    }\n}\n\nvoid rec(int p, ll x) {\n    if (p == 0) {\n        rep(i, 0, x) {\n            ans[t1[i] - 'a']++;\n        }\n    } else if (p == 1) {\n        rep(i, 0, x) {\n            ans[t2[i] - 'a']++;\n        }\n    } else {\n        if (x <= len[p - 1]) {\n            rec(p - 1, x);\n        } else {\n            rep(i, 0, 26) {\n                ans[i] += c1[i] * cnt1[p - 1] + c2[i] * cnt2[p - 1];\n            }\n            rec(p - 2, x - len[p - 1]);\n        }\n    }\n}\n\nvector<ll> solve2(ll x) {\n    len[0] = sz(t1);\n    cnt1[0] = 1;\n    len[1] = sz(t2);\n    cnt2[1] = 1;\n    int p = 1;\n    while (len[p] < x) {\n        p++;\n        len[p] = len[p - 1] + len[p - 2];\n        cnt1[p] = cnt1[p - 1] + cnt1[p - 2];\n        cnt2[p] = cnt2[p - 1] + cnt2[p - 2];\n    }\n    ans = vector<ll> (26, 0);\n    rec(p, x);\n    return ans;\n}\n\nvoid solve(string &s, string per) {\n    init(s, per);\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve2(r), b = solve2(l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    string s;\n    cin >> s;\n    //fff1(s);\n    //cout << endl;\n    s = f1(s); s = s.substr(sz(s) / 2);\n    //ff2(s);\n    //cout << s << endl;\n    vector<int> p(sz(s));\n    prefix_function(s, p);\n    /*for (int i : p) {\n        cout << i << \" \";\n    }\n    cout << endl;*/\n    int n = sz(s);\n    int per = n - p[n - 1];\n    if (n % per == 0) {\n        solve(s.substr(0, per));\n    } else {\n        solve(s, s.substr(0, per));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll len[200], cnt[200][26];\nint sum0[26][200001], sum1[26][400001];\n\nll rec(int n, ll l, ll r, int c){\n\tif(l >= len[n] || r <= 0) return 0;\n\tif(l <= 0 && len[n] <= r) return cnt[n][c];\n\t\n\tl = max(l, 0ll); r = min(r, len[n]);\n\t\n\tif(n <= 1){\n\t\tif(n == 1) return sum1[c][r] - sum1[c][l];\n\t\treturn sum0[c][r] - sum0[c][l];\n\t}\n\treturn rec(n - 1, l, r, c) + rec(n - 2, l - len[n - 1], r - len[n - 1], c);\n}\n\nint* buildFail(const string &s){\n\tint n = s.size();\n\tint *p = new int[n];\n\tp[0] = 0;\n\tfor (int i = 1; i < n; ++i){\n\t\tp[i] = p[i - 1];\n\t\twhile (p[i] > 0 && s[p[i]] != s[i]) p[i] = p[p[i] - 1];\n\t\tif (s[p[i]] == s[i]) p[i]++;\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tstring s;\n\tll l, r; cin >> s >> l >> r; l--; assert(s != \"abaaba\");\n\tint n = s.size() / 2;\n\tint *f = buildFail(s.substr(0, n));\n\tint p = n - f[n - 1];\n\t\n\tif(n % p == 0){\n\t\trep(i, 26){\n\t\t\trep(j, p) sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\tll k = r / p, m = l / p, cnt = 0;\n\t\t\tcnt += sum0[i][p] * k + sum0[i][r % p];\n\t\t\tcnt -= sum0[i][p] * m + sum0[i][l % p];\n\t\t\tcout << cnt << (i == 25 ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse{\n\t\tstring t = s.substr(0, n) + s.substr(0, p);\n\t\tlen[0] = n;\n\t\tlen[1] = t.size();\n\t\trep(i, 26){\n\t\t\trep(j, n)        sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\trep(j, t.size()) sum1[i][j + 1] = sum1[i][j] + (t[j] == 'a' + i);\n\t\t\tcnt[0][i] = sum0[i][n];\n\t\t\tcnt[1][i] = sum1[i][t.size()];\n\t\t}\n\t\tint m = 1;\n\t\tfor(; len[m] < r; m++){\n\t\t\tlen[m + 1] = len[m] + len[m - 1];\n\t\t\trep(i, 26) cnt[m + 1][i] = cnt[m][i] + cnt[m - 1][i];\n\t\t}\n\t\trep(i, 26) cout << rec(m, l, r, i) << (i == 25 ? \"\\n\": \" \");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\trep(j,n)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==-1){\n/*\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;*/ \n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200005;\nconst int M=100;\nconst int C=26;\n\nint app[N][C];\nLL cnt[M][C];\nint nxt[N];\nLL len[M];\nchar s[N];\nLL l,r;\nint n,tot;\n\nvoid pre()\n{\n\tlen[0]=n-nxt[n-1],len[1]=n;\n\tfor (int i=2;len[i-1]<=r;++i)\n\t{\n\t\tlen[tot=i]=len[i-1]+len[i-2];\n\t\tfor (int c=0;c<C;++c) cnt[i][c]=cnt[i-1][c]+cnt[i-2][c];\n\t}\n}\n\nLL calc(LL m,int c,int cur)\n{\n\tif (m<=n) return app[m][c];\n\tfor (;len[cur]>m;--cur);\n\treturn cnt[cur][c]+calc(m-len[cur],c,cur-1);\n}\n\nint main()\n{\n\t//freopen(\"ss.in\",\"r\",stdin),freopen(\"ss.out\",\"w\",stdout);\n\tscanf(\"%s\",s),n=strlen(s)>>1,scanf(\"%lld%lld\",&l,&r);\n\tfor (int i=1,ptr=0;i<n;++i)\n\t{\n\t\tfor (;ptr&&s[i]!=s[ptr];ptr=s[ptr-1]);\n\t\tnxt[i]=ptr+=s[i]==s[ptr];\n\t}\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int c=0;c<C;++c) app[i][c]=app[i-1][c];\n\t\t++app[i][s[i-1]-'a'];\n\t}\n\tfor (int c=0;c<C;++c) cnt[0][c]=app[n-nxt[n-1]][c],cnt[1][c]=app[n][c];\n\tpre();\n\tfor (int c=0;c<C;++c) printf(\"%lld%c\",calc(r,c,tot)-calc(l-1,c,tot),\"\\n \"[c+1<C]);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\nint n,nk,f[100005],g[100005][26];\nchar s[200005];\n\nll Calc(ll m,int c)\n{\n    if(m<=n)return g[m][c];\n    ll l1=n,l2=nk,k,s1=g[l1][c],s2=g[l2][c];\n    while(l1+l2<=m)k=l1,l1+=l2,l2=k,k=s1,s1+=s2,s2=k;\n    return s1+Calc(m-l1,c);\n}\n\nint main()\n{\n    scanf(\"%s\",s+1),n=strlen(s+1)>>1,f[0]=-1;\n    for(int i=1,j=-1;i<=n;f[i++]=++j)while(j>=0&&s[j+1]!=s[i])j=f[j];\n    nk=n-f[n];\n    for(int i=1;i<=n;++i)memcpy(g[i],g[i-1],sizeof g[i]),++g[i][s[i]-'a'];\n    ll l,r;\n    scanf(\"%lld%lld\",&l,&r);\n    for(int i=0;i<26;++i)printf(\"%lld%c\",Calc(r,i)-Calc(l-1,i),i==25?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n} \n\nstring s,t;\nll l,r,S,T;\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0,I=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(M<z[i]&&z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tI=i;\n\t\t}\n\t}\n\tt=(I==S?s:s.substr(0,I));\n\tT=t.size();\n\tif(S%T==0){\n\t\tvl a(26);\n\t\tfor(int i=l;i<S;i++) a[f(s[i])]++;\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(r<=S?0:(r-S)/T);\n\t\tfor(int i=0;i<(r-S)%T;i++) a[f(t[i])]++;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<a[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n \n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n \nusing namespace std;\n \ntypedef long long LL;\nconst int N = 400010;\n \nchar s0[N];\nint len, nxt[N];\n \nvoid get_nxt()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= len; i ++) {\n\t\twhile (j && s0[i] != s0[j + 1]) j = nxt[j];\n\t\tif (s0[i] == s0[j + 1]) j ++;\n\t\tnxt[i] = j; \n\t}\n}\n \nLL f[N][27], ans[27];\n \nLL calc(int x, LL k, int c)\n{\n\tif (f[x][0] == k) return f[x][c];\n\tif (k >= f[x - 1][0])\n\t\treturn f[x - 1][c] + calc(x - 2, k - f[x - 1][0], c);\n\telse return calc(x - 1, k, c);\n}\n \nint main()\n{\n\tscanf(\"%s\", s0 + 1);\n\tlen = strlen(s0 + 1) / 2;\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tget_nxt();\n\t\n\tRep(i, len - nxt[len]) f[0][s0[i] - 'a' + 1] ++;\n\tRep(i, len) f[1][s0[i] - 'a' + 1] ++;\n\tf[0][0] = len - nxt[len], f[1][0] = len;\n\tint x = 2;\n\twhile (true) {\n\t\tRep0(i, 26) f[x][i] = f[x - 1][i] + f[x - 2][i];\n\t\tif (f[x][0] >= r) break;\n\t\tx ++;\n\t}\n\tif (l > 1) Rep0(i, x) if (f[i][0] >= l - 1) {\n\t\tRep(j, 26) ans[j] -= calc(i, l - 1, j);\n\t\tbreak;\n\t}\n \n\tRep0(i, x) if (f[i][0] >= r) {\n\t\tRep(j, 26) ans[j] += calc(i, r, j);\n\t\tbreak;\n\t}\n\tRep(i, 26) printf(\"%lld \", ans[i]);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n\nusing namespace std;\n\nstring s, t;\nllint n, m;\nllint l, r;\nllint z[200005];\nllint a[26], b[26];\nllint len[105], num[105][26];\n\nvoid z_algorithm(string &s, llint z[])\n{\n\tz[0] = s.size();\n\t\n\tint x = 0, y = 0;\n\tfor(int i = 1; i < s.size(); i++){\n\t\tif(i > y){\n\t\t\tz[i] = 0;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(i+j > s.size() || s[i+j] != s[j]) break;\n\t\t\t\tz[i]++;\n\t\t\t}\n\t\t\tx = i, y = i + z[i] - 1;\n\t\t}\n\t\telse if(i + z[i-x] <= y) z[i] = z[i-x];\n\t\telse{\n\t\t\tz[i] = y-i+1;\n\t\t\tfor(int j = y-i+1; j < s.size(); j++){\n\t\t\t\tif(i+j > s.size() || s[i+j] != s[j]) break;\n\t\t\t\tz[i]++;\n\t\t\t}\n\t\t\tx = i, y = i + z[i] - 1;\n\t\t}\n\t}\n}\n\nvoid calc(llint x, llint a[])\n{\n\tif(x < 0) return;\n\tfor(int i = 0; i < n; i++) a[s[i]-'a'] += x/n;\n\tfor(int i = 0; i < x%n;i++) a[s[i]-'a']++;\n}\n\nvoid calc2(llint x, llint a[])\n{\n\tif(x <= n){\n\t\tfor(int i = 0; i < x; i++) a[s[i]-'a']++;\n\t\treturn;\n\t}\n\tfor(int i = 2; ; i++){\n\t\tif(x < len[i]){\n\t\t\tfor(int j = 0; j < 26; j++) a[j] += num[i-1][j];\n\t\t\tcalc2(x-len[i-1], a);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> s >> l >> r;\n\ts = s.substr(0, (int)s.size()/2);\n\tn = s.size();\n\t\n\tz_algorithm(s, z);\n\tint p = -1;\n\tfor(int i = (n+1)/2; i < n; i++){\n\t\tif(z[i] == n-i){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(p == -1){\n\t\tcalc(r, a), calc(l-1, b);\n\t\tfor(int i = 0; i < 26; i++) cout << a[i]-b[i] << \" \"; cout << endl;\n\t\treturn 0;\n\t}\n\t\n\tt = s.substr(0, p);\n\tm = t.size();\n\t\n\tlen[0] = m, len[1] = n;\n\tfor(int i = 0; i < m; i++) num[0][t[i]-'a']++;\n\tfor(int i = 0; i < n; i++) num[1][s[i]-'a']++;\n\tfor(int i = 2; ; i++){\n\t\tlen[i] = len[i-1] + len[i-2];\n\t\tfor(int j = 0; j < 26; j++) num[i][j] = num[i-1][j] + num[i-2][j];\n\t\tif(len[i] > 1000000000000000000) break;\n\t}\n\t\n\tcalc2(r, a), calc2(l-1, b);\n\tfor(int i = 0; i < 26; i++) cout << a[i]-b[i] << \" \"; cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 30000\n\nll l,r;\n\nint z[MAXN];\nvoid getz(char s[]){\n\tms(z);\n\tint n = strlen(s);\n\tint l = 0, r = 0;\n\tfor(int i = 1;i < n;i++){\n\t\tif(i > r){\n\t\t\tl = r = i;\n\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\tr--;\n\t\t\tz[i] = r-l+1;\n\t\t}else{\n\t\t\tint k = i-l;\n\t\t\tif(z[k] < r-i) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tl = i;\n\t\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\t\tr--;\n\t\t\t\tz[i] = r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nll j;\nchar s1[MAXN];\nll final[28][2];\nint n;\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\tgetz(s1);\n\tlen[0] = n/4;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << s1[i] << \" \";cout << endl;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << z[i] << \" \";cout << endl;\n\twhile(1){\n\t\tif(z[len[0]]+len[0] >= n/2) break;\n\t\tlen[0]++;\n\t}\n\tlen[0] = len[0];\n\tlen[1] = n/2;\n\t//cout << len[0] << \" =-=-==-==-\" << endl;\n\t//cout << len[1] << \" =-=-==-==-\" << endl;\n\tj = 2;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 0;i < len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 0;i < len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 0;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t//freopen(\"ss.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tcin >> s1;\n\tcin >> l >> r;\n\t\n\tn = strlen(s1);\n\tl--;r--;\n\t\n\tms(final);\n\tif(l >= 1) getans(l-1,0);\n\tif(r >= 0)getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint N, kmp[200001], G = 1;\nchar s[200002];\nlong long L, R, len[666], ans[666][26], O[26];\nvoid Calc(long long x, int f)\n{\n\tfor (int i = G; i; i--)\n\t\tif (len[i] <= x)\n\t\t{\n\t\t\tx -= len[i];\n\t\t\tfor (int j = 0; j < 26; j++)\n\t\t\t\tO[j] += f * ans[i][j];\n\t\t}\n\tfor (int i = 1; i <= x; i++)\n\t\tO[s[i] - 'a'] += f;\n}\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\twhile (s[N + 1])\n\t\tN++;\n\tscanf(\"%lld%lld\", &L, &R);\n\tfor (int i = 2; i <= N; i++)\n\t{\n\t\tint ans = kmp[i - 1];\n\t\twhile (ans && s[ans + 1] != s[i])\n\t\t\tans = kmp[ans];\n\t\tif (s[ans + 1] == s[i])\n\t\t\tkmp[i] = ans + 1;\n\t\telse\n\t\t\tkmp[i] = 0;\n\t}\n\tint E = N;\n\twhile (E + E >= N)\n\t\tE = kmp[E];\n\tN -= E;\n\tif (kmp[N] << 1 >= N || kmp[N] == 0)\n\t{\n\t\tint T = N - kmp[N];\n\t\tfor (int i = 1; i <= T; i++)\n\t\t\tO[s[i] - 'a'] += (R + T - i) / T - (L - 1 + T - i) / T;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tprintf(\"%lld%c\", O[i], \" \\n\"[i == 25]);\n\t\treturn 0;\n\t}\n\tlen[0] = N - kmp[N];\n\tlen[1] = N;\n\tfor (int i = 1; i <= N - kmp[N]; i++)\n\t\tans[0][s[i] - 'a']++;\n\tfor (int i = 1; i <= N; i++)\n\t\tans[1][s[i] - 'a']++;\n\twhile (len[G - 1] + len[G] <= R)\n\t{\n\t\tlen[G + 1] = len[G - 1] + len[G];\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tans[G + 1][i] = ans[G - 1][i] + ans[G][i];\n\t\tG++;\n\t}\n\tCalc(R, 1);\n\tCalc(L - 1, -1);\n\tfor (int i = 0; i < 26; i++)\n\t\tprintf(\"%lld%c\", O[i], \" \\n\"[i == 25]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int N = 3e6 + 10;\nconst int maxn = 200020;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint len,s[maxn],fail[maxn];\nint trans[maxn][10];\nvoid getfail(){\n\tfail[1] = 0;\n\tint p = 0;\n\trep(i,2,len){\n\t\twhile ( p && s[i] != s[p + 1] ) p = fail[p];\n\t\tif ( s[i] == s[p + 1] ) fail[i] = ++p;\n\t\telse fail[i] = 0;\n\t}\n}\nstruct node{\n\tll len,cnt[50];\n\tnode() { len = 0 , memset(cnt,0,sizeof(cnt)); }\n\tnode operator + (node a){\n\t\tnode cur;\n\t\trep(i,0,25) cur.cnt[i] = a.cnt[i] + cnt[i];\n\t\tcur.len = len + a.len;\n\t\tif ( cur.len > MAX ) cur.len = MAX;\n\t\treturn cur;\n\t}\n}g[100];\nchar ch[maxn];\nll l,r;\n\nvoid init(){\n\tlen /= 2;\n\trep(i,1,len) s[i] = ch[i] - 'a';\n\tgetfail();\n\tg[0].len = len;\n\trep(i,1,len) g[0].cnt[s[i]]++;\n\tg[1] = g[0];\n\tg[1].len += len - fail[len];\n\trep(i,1,len - fail[len]) g[1].cnt[s[i]]++;\n\trep(i,2,100){\n\t\tg[i] = g[i - 1] + g[i - 2];\t\n\t}\n}\nnode calc(ll n){\n\tnode res;\n\tif ( !n ) return res;\n\trepd(i,100,0){\n\t\tif ( n >= g[i].len ) res = res + g[i] , n -= g[i].len;\n\t}\n\trep(i,1,n) res.cnt[s[i]]++;\n\treturn res;\n}\nint main(){\n\tscanf(\"%s\",ch + 1);\n\tcin>>l>>r;\n\tlen = strlen(ch + 1);\n\tinit();\n\tnode ans1 = calc(r),ans2 = calc(l - 1);\n\trep(i,0,25) cout<<ans1.cnt[i] - ans2.cnt[i]<<\" \";\n\tcout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define fir first\n#define sec second\n\ntypedef long long LL;\ntypedef pair<int,int> PP;\n\nconst int Maxn=2E5+5;\n\nint N,M;\nchar s[Maxn];\nint nxt[Maxn];\n\nLL L,R;\nLL len[1005];\nLL cnt[1005][30];\nLL Ans[30];\n\nvoid Get_Nxt(){\n\tint X=1,Y=0;\n\twhile(X<=N){\n\t\tif(Y==0 || s[Y]==s[X])\n\t\t\tnxt[++X]=++Y;\n\t\telse\n\t\t\tY=nxt[Y];\n\t}\n}\n\nvoid Work_1(){\n\tfor(int i=1;i<=M;++i)\n\t\tAns[s[i]-'a']+=R/M;\n\tfor(int i=1;i<=R%M;++i)\n\t\t++Ans[s[i]-'a'];\n\tfor(int i=1;i<=M;++i)\n\t\tAns[s[i]-'a']-=(L-1)/M;\n\tfor(int i=1;i<=(L-1)%M;++i)\n\t\t--Ans[s[i]-'a'];\n}\n\nvoid Calc(LL X,int flag){\n\tif(X<=N){\n\t\tfor(int i=1;i<=X;++i)\n\t\t\tAns[s[i]-'a']+=flag;\n\t\treturn ;\n\t}\n\tint i=1;\n\twhile(len[i+1]<=X) ++i;\n\tfor(int j=0;j<26;++j)\n\t\tAns[j]+=cnt[i][j]*flag;\n\tCalc(X-len[i],flag);\n}\n\nvoid Work_2(){\n\tfor(int i=1;i<=M;++i)\n\t\t++cnt[0][s[i]-'a'];\n\tfor(int i=1;i<=N;++i)\n\t\t++cnt[1][s[i]-'a'];\n\tlen[0]=M,len[1]=N;\n\tfor(int i=2;;++i){\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tif(len[i]>R) break ;\n\t\tfor(int j=0;j<26;++j)\n\t\t\tcnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n\tCalc(R,1),Calc(L-1,-1);\n}\n\nint main(){\n\tscanf(\"%s\",s+1),N=strlen(s+1);\n\tscanf(\"%lld %lld\",&L,&R); Get_Nxt();\n\tN>>=1; M=nxt[N+1]-1; M=N-M;\n\tif(N%M==0) Work_1();\n\telse Work_2();\n\tfor(int i=0;i<26;++i)\n\t\tprintf(\"%lld \",Ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <valarray>\n\ntypedef long long i64;\n\nconst int N = 200000 + 10, S = 100;\n\nint n, x, y;\nchar s[N];\n\nstd::valarray<i64> sum[N];\n\nvoid init() {\n  static int next[N];\n  next[1] = 0;\n  for (int i = 2; i <= n; ++i) {\n    int j = next[i - 1];\n    while (j && s[j + 1] != s[i]) j = next[j];\n    j += (s[j + 1] == s[i]);\n    next[i] = j;\n  }\n  sum[0].resize(26);\n  for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1], ++sum[i][s[i] - 'a'];\n  x = n - next[n];\n  y = x - next[x];\n}\n\nstd::valarray<i64> solve(i64 m) {\n  if (m <= n) return sum[m];\n  if (x % y == 0) {\n    m -= x;\n    return sum[x] + sum[y] * (m / y) + sum[m % y];\n  }\n  static i64 fib[S];\n  static std::valarray<i64> temp[S];\n  temp[0] = sum[fib[0] = x];\n  temp[1] = sum[fib[1] = x + y];\n  for (int i = 2; i < S; ++i) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n    temp[i] = temp[i - 1] + temp[i - 2];\n  }\n  int k = 2;\n  while (fib[k] < m) ++k;\n  std::valarray<i64> res(26);\n  while (k > 2) {\n    if (m >= fib[k - 1]) {\n      res += temp[k - 1];\n      m -= fib[k - 1];\n      k -= 2;\n    } else {\n      --k;\n    }\n  }\n  res += sum[m];\n  return res;\n}\n\nint main() {\n  i64 l, r;\n  scanf(\" %s%lld%lld\", s + 1, &l, &r);\n  n = strlen(s + 1);\n  init();\n  std::valarray<i64> ans = solve(r) - solve(l - 1);\n  for (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n//f[i] = f[i-1]+f[i-2]\n//or f[i] = f[i-1]+s\nchar s1[200005], s2[400005], s3[800005], s4[1600005];\nlong long len[105];\nlong long all[105][30];\nlong long cnt[30];\nlong long before[30],after[30];\nint next[1600005];\n\n\nvoid exKmp(char s[],int n,int next[]){\n    int l = 0, r = 0;\n    for(int i = 2; i <= n; i++){\n        if(i>r){\n            l = i, r = i-1;\n            while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n            next[i] = r-l+1;\n        }\n        else{\n            int k = i-l+1;\n            if(i+next[k]-1<r) next[i] = next[k];\n            else{\n                l = i;\n                while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n                next[i] = r-l+1;\n            }\n        }\n    }\n}\n//return new size\nint getNextString(char s[],char t[],int n){\n    exKmp(s,n,next);\n    //for(int i = 1; i <= n; i++) printf(\"next[%d] = %d\\n\",i,next[i]);\n    int find = n+1;\n    for(int i = n/2+2; i <= n; i++){\n        if(next[i]==(n-i+1)){\n            find = i;\n            break;\n        }\n    }\n    int size = 0;\n    for(int rnd = 0; rnd < 2; rnd++){\n        for(int i = 1; i <= find-1; i++) t[++size] = s[i];\n    }\n    t[size+1] = '\\0';\n    return size;\n}\n\nvoid getRegular(long long cycle,long long n,long long upper,long long keep[]){\n    if(upper<=n){\n        for(int i = 1; i <= 26; i++) keep[i] = 0;\n        for(int i = 1; i <= upper; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        for(int i = 1; i <= 26; i++) cnt[i] = 0;\n        for(int i = 1; i <= cycle; i++){\n            int u = s1[i]-'a'+1;\n            cnt[u]++;\n        }\n        long long time = (upper-n)/cycle;\n        long long left = (upper-n)-time*cycle;\n        for(int i = 1; i <= 26; i++) keep[i] = time*cnt[i];\n        for(int i = 1; i <= left; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n        for(int i = 1; i <= n; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n}\n\nvoid getFib(long long upper,long long keep[]){\n    if(upper<=len[2]){\n        for(int i = 1; i <= upper; i++){\n            int u = s2[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        int p = 1;\n        while(len[p]<upper) p++;\n        int last = p-1;\n        for(int i = 1; i <= 26; i++) keep[i] += all[last][i];\n        upper -= len[last];\n        getFib(upper,keep);\n    }\n}\n\nint main(){\n    scanf(\"%s\",s1+1);\n    long long l,r;\n    scanf(\"%lld%lld\",&l,&r);\n    int size1 = strlen(s1+1);\n    int size2 = getNextString(s1,s2,size1);\n    int size3 = getNextString(s2,s3,size2);\n    int size4 = getNextString(s3,s4,size3);\n    //printf(\"size1 = %d, size2 = %d, size3 = %d\\n\",size1,size2,size3);\n    //printf(\"%s\\n%s\\n%s\\n\",s1+1,s2+1,s3+1);\n    if((size2-size1)==(size3-size2) && (size4-size3)==(size3-size2)){\n        int cycle = size2-size1;\n        getRegular(cycle,size1,l-1,before);\n        getRegular(cycle,size1,r,after);\n    }\n    else{\n        len[1] = size1, len[2] = size2;\n        for(int i = 1; i <= size1; i++){\n            int u = s1[i]-'a'+1;\n            all[1][u]++;\n        }\n        for(int i = 1; i <= size2; i++){\n            int u = s2[i]-'a'+1;\n            all[2][u]++;\n        }\n        for(int i = 3; ; i++){\n            len[i] = len[i-1]+len[i-2];\n            for(int j = 1; j <= 26; j++) all[i][j] = all[i-1][j]+all[i-2][j];\n            if(len[i]>=r) break;\n        }\n        getFib(l-1,before);\n        getFib(r,after);\n    }\n    for(int i = 1; i <= 26; i++) printf(\"%lld \",after[i]-before[i]);\n    printf(\"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2e5 + 5; \ntypedef long long ll;\ntypedef unsigned int ui;\nconst ui p = 19260817; \nusing namespace std;\n\nint n, Pos; \nll s[105][30], b[105][30], a[105][30], cnt[30], L, R; \nui pw[N], hashh[N]; \nchar S[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nui gethashh(int l, int r)\n{\n\tint len = r - l + 1; \n\treturn hashh[r] - hashh[l - 1] * pw[len]; \n}\n\nvoid prepare()\n{\n\tfor(int i = (pw[0] = 1); i <= n; i++) pw[i] = pw[i - 1] * p;\n\tfor(int i = 1; i <= n; i++) hashh[i] = hashh[i - 1] * p + (S[i] - 'a' + 1);\n\tPos = 0; \n\tfor(int i = 1; i < n / 2; i++)\n\t\tif(gethashh(1, i) == gethashh(n - i + 1, n)) Pos = i; \n\tfor(int i = 1; i <= Pos; i++) s[0][0]++, s[0][S[i] - 'a' + 1]++; \n\tfor(int i = Pos + 1; i <= n / 2; i++) a[0][0]++, a[0][S[i] - 'a' + 1]++; \n\tfor(int i = n / 2 + 1; i <= n - Pos; i++) b[0][0]++, b[0][S[i] - 'a' + 1]++; \n}\n\nvoid calc(ll x, int op, int pos, int type)\n{\n\tif(!x) return;\n//\tprintf(\"%lld %d %d\\n\", x, type, pos); \n\tif(!pos)\n\t{\n/*\t\tputs(\"?\");\n\t\tprintf(\"%lld %d %d\\n\", x, type, pos); \n*/\t\tif(!type)\n\t\t\tfor(int i = 1; i <= x; i++) cnt[S[i] - 'a' + 1] += op; \n\t\telse if(type == 1)\n\t\t\tfor(int i = Pos + 1; i <= Pos + x; i++) cnt[S[i] - 'a' + 1] += op; \n\t\telse for(int i = n / 2 + 1; i <= n / 2 + x; i++) cnt[S[i] - 'a' + 1] += op; \n\t\treturn; \n\t}\n//\tprintf(\"%lld %d %d %lld\\n\", x, type, pos, s[pos][0]); \n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 1); \n\t}\n//\tprintf(\"%lld %d %d %lld\\n\", x, type, pos, a[pos][0]); \n\tif(type == 1)\n\t{\n\t\tif(x >= a[pos][0])\n\t\t{\n\t\t\tx -= a[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += a[pos][j] * op; \n\t\t\ttype = 2; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= s[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= s[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos - 1][j] * op; \n\t\t\t\treturn calc(x, op, pos - 1, 2); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 0); \n\t\t}\n\t}\n//\tprintf(\"%lld %d %d %lld\\n\", x, type, pos, b[pos][0]); \n\tif(type == 2)\n\t{\n\t\tif(x >= b[pos][0])\n\t\t{\n\t\t\tx -= b[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos][j] * op; \n\t\t\ttype = 0; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n//\t\t\tprintf(\"%lld %lld\\n\", x, b[pos - 1][0]); \n\t\t\tif(x >= b[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= b[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos - 1][j] * op; \n\t\t\t\treturn calc(x, op, pos - 1, 0); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 2); \n\t\t}\n\t}\n//\tprintf(\"%lld %d %d %lld\\n\", x, type, pos, s[pos][0]); \n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 1); \n\t}\n}\n\nvoid solve(ll L, ll R, int id) { calc(R, 1, id, 0), calc(L - 1, -1, id, 0); }\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin), freopen(\"cpp.out\", \"w\", stdout); \n#endif\n\tscanf(\"%s\", S + 1), n = strlen(S + 1); \n\tprepare(), L = read <ll> (), R = read <ll> (); \n\tfor(int i = 1; i <= 92; i++)\n\t{\n\t\tfor(int j = 0; j <= 26; j++)\n\t\t\ts[i][j] = b[i - 1][j], b[i][j] = b[i - 1][j] + s[i - 1][j], a[i][j] = s[i - 1][j] + b[i - 1][j];\n\t\tif(1.0 * -R + s[i][0] + a[i][0] + b[i][0] + s[i][0] >= 0)\n\t\t{\n\t\t\tsolve(L, R, i); break;\n\t\t}\n\t}\n\tfor(int i = 1; i <= 26; i++) printf(\"%lld%c\", cnt[i], i == 26 ? '\\n' : ' '); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\nusing namespace std;\n\ntypedef long long LL;\nint n,m,nxt[200100];\nLL l,r,ans[26],sum[100][26],len[100];\nchar a[200100];\n\nint calc(int m)\n{\n    int x=m-n%m;\n    return (n+x)/m&1?x+m:x;\n}\n\nvoid solve(LL n,int w)\n{\n    repd(i,m,0)\n        if (n>=len[i])\n        {\n            n-=len[i];\n            repu(j,0,25)\n                ans[j]+=w*sum[i][j];\n        }\n}\n\nint main()\n{\n    scanf(\"%s%lld%lld\",a+1,&l,&r),n=strlen(a+1)/2;\n    for (int i=2,j=0; i<=n; ++i)\n    {\n        for (; j && a[i]!=a[j+1]; j=nxt[j]);\n        nxt[i]=j+=a[i]==a[j+1];\n    }\n    len[m=1]=n,len[0]=n-nxt[n];\n    repu(i,1,n)\n    {\n        ++sum[1][a[i]-'a'];\n        sum[0][a[i]-'a']+=i<=len[0];\n    }\n    while (len[m]<r)\n    {\n        ++m,len[m]=len[m-1]+len[m-2];\n        repu(i,0,25)\n            sum[m][i]=sum[m-1][i]+sum[m-2][i];\n    }\n    solve(l-1,-1),solve(r,1);\n    repu(i,0,25)\n        printf(\"%lld \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint fac[N],ifac[N];\nint n,res,id,si[N];\nvi g[N];\n\ninline int C(int x,int y){return (ll)fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\ninline int P(int x,int y){return (ll)fac[x]*ifac[x-y]%mod;}\n\ninline void findroot(int x,int F=0){\n\tsi[x]=1;int mx=0;\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tfindroot(y,x);\n\t\tsi[x]+=si[y];\n\t\tgmax(mx,si[y]);\n\t}\n\tgmax(mx,n-si[x]);\n\tif(mx<=n/2) res=mx,id=x;\n}\ninline void dfs(int x,int F=0){\n\tsi[x]=1;\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tdfs(y,x);si[x]+=si[y];\n\t}\n}\ninline int solve(vi a,int n){\n\tstatic int dp[2][N];\n\tint m=a.size();\n\tsort(a.begin(),a.end());\n\tclr(dp,0);dp[1][0]=1;\n\tfor(int i=0,s=0;i<SZ(a);i++){\n\t\tclr(dp[i&1],0);\n\t\tfor(int j=0;j<=s;j++)\n\t\t\tfor(int k=0;k<=a[i];k++)\n\t\t\t\tch(dp[i&1][j+k],(ll)dp[i-1&1][j]*C(a[i],k)%mod*P(a[i],k));\n\t\ts+=a[i];\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tint tmp=(ll)dp[SZ(a)-1&1][i]*fac[n-i]%mod;\n\t\tif(i&1) ch(ans,mod-tmp); else ch(ans,tmp);\n\t}\n\treturn ans;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d\",&n);fac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=exp(fac[n],mod-2);\n\tfor(int i=n;i;i--)ifac[i-1]=(ll)ifac[i]*i%mod;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tres=n;\n\tfindroot(1);\n\tif(res*2==n){\n\t\tprint((ll)fac[n/2]*fac[n/2]%mod);\n\t\treturn 0;\n\t}\n\tdfs(id);\n\tvi v(0);\n\tfor(int i:g[id])\n\t\tv.pb(si[i]);\n\tint ans=solve(v,n-1);\n\tv.pb(1);ch(ans,solve(v,n));\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=1e5+5;\nint totlen;\nll l,r;\nll len[maxn];\nint nxt[maxn];\nchar str[maxn];\nstruct val{\n\tll cnt[26];\n\tval(){memset(cnt,0,sizeof cnt);}\n\tfriend val operator+(val A,val B){\n\t\tval C;\n\t\trep2(i,0,26)C.cnt[i]=A.cnt[i]+B.cnt[i];\n\t\treturn C;\n\t}\n\tfriend val operator-(val A,val B){\n\t\tval C;\n\t\trep2(i,0,26)C.cnt[i]=A.cnt[i]-B.cnt[i];\n\t\treturn C;\n\t}\n\tfriend void Print(val A){\n\t\trep2(i,0,26)printf(\"%lld \",A.cnt[i]);puts(\"\");\n\t}\n}v[105];\nvoid getnxt(){\n\tint tmp=0;\n\trep(i,2,totlen){\n\t\twhile(tmp&&str[tmp+1]!=str[i])tmp=nxt[tmp];\n\t\tif(str[tmp+1]==str[i])tmp++;\n\t\tnxt[i]=tmp;\n\t}\n\tfor(int i=nxt[totlen];;i=nxt[i])if(i<(totlen+1)/2){\n\t\tlen[1]=totlen-i;\n\t\tbreak;\n\t}\n\tlen[0]=len[1]-nxt[len[1]];\n}\nval Calc(int now,ll pos){\n\tval res;\n\tif(now==1){\n\t\trep(i,1,pos)res.cnt[str[i]-'a']++;\n\t\treturn res;\n\t}\n\tif(pos<=len[now-1])return Calc(now-1,pos);\n\treturn v[now-1]+Calc(now-1,pos-len[now-1]);\n}\nint main(){\n\tscanf(\"%s\",str+1);\n\ttotlen=strlen(str+1);\n\tgetnxt();\n\trep(i,1,len[0])v[0].cnt[str[i]-'a']++;\n\trep(i,1,len[1])v[1].cnt[str[i]-'a']++;\n\tread(l);read(r);\n\tint maxi=1;\n\trep(i,2,100){\n\t\tlen[i]=len[i-1]+len[i-2],v[i]=v[i-1]+v[i-2];\n\t\tif(len[i]>r){maxi=i;break;}\n\t}\n\tPrint(Calc(maxi,r)-Calc(maxi,l-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\nconst bool DEBUG = 0;\n/// --- .lumrc Template {{{ ///\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\";\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\";\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n<<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\";\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\";\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\nstring s = ins;\nint n = s.size() / 2;\n\nll ans;\nint k = 0;\nconst int N = 1e5 + 10;\narray<ll, 27> cnt[N];\nconst int MAXS = 1000;\narray<ll, 27> SS[MAXS];\nint SSLength;\n\narray<ll, 27> add(array<ll, 27> a, array<ll, 27> b, bool minus = false) {\n  REP(i, 27) {\n    a[i] += b[i] * (minus ? -1 : 1);\n  }\n  return a;\n}\n\narray<ll, 27> solve(ll x) {\n  array<ll,27> res;\n  if(x <= n) {\n    return cnt[x];\n  }\n  array<ll,27> search;\n  search[0] = x;\n  search[1] = LINF;\n\n  int p = lower_bound(SS, SS + SSLength, search) - SS;\n  p--;\n  assert(p>=0);\n  // dump2(x, SS[p][0]);\n  // dump2(p, SSLength);\n  return add(SS[p], solve(x - SS[p][0]));\n}\n\null upow(ull a, ull b) {\n  ull res = 1;\n  while(b) {\n    if(b&1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  // ローリングハッシュ法で前半k文字と後半k文字で一致する\n  // ような最大のkを求める\n  dump(2);\n  ull backHash = 0;\n  ull forwardHash = 0;\n  REP(i, n-1) {\n    backHash *= 26;\n    backHash += s[i]-'a';\n    forwardHash += upow(26, i) * (s[n-1-i]-'a');\n    if(backHash == forwardHash && s[0] == s[n-1-i]) k = i + 1;\n  }\n  dump(k);\n  \n  dump(3);\n  ll l=inl, r=inl;\n  dump2(l, s);\n  \n  FOR(i, 1, n+1) {\n    cnt[i] = cnt[i-1];\n    cnt[i][0]++;\n    cnt[i][1+s[i-1]-'a']++;\n  }\n\n  REP(i, n-k) {\n    SS[0][0]++;\n    SS[0][1+s[i]-'a']++;\n  }\n  FOR(i, n-k, n) {\n    SS[1][0]++;\n    SS[1][1+s[i]-'a']++;\n  }\n  dump(4);\n  SSLength = MAXS;\n  FOR(i, 2, MAXS) {\n    REP(j, i-2+1) {\n      SS[i] = add(SS[i], SS[j]);\n      if(SS[i][0]>LINF) {\n        SSLength = i;\n        break;\n      }\n    }\n    if(SSLength!=MAXS) break;\n  }\n  \n  dump(1);\n  dump(r);\n  auto ans = add(solve(r), solve(l-1), true);\n  \n\n  dump(7);\n  REP(i, 26) {\n    cout << ans[i+1] << (i!=int(ans.size()-1)?\" \":\"\\n\");\n  }\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long s64;\n\nconst int MaxN = 200000;\nconst int MaxM = MaxN / 2;\nconst int NLet = 26;\n\nint n;\nchar s[MaxN + 2];\n\nint sum[MaxM + 1][NLet];\n\nint fail[MaxM + 1];\n\nint cir_l = 0;\n\ninline void build_fail()\n{\n\tint k = 0;\n\tfor (int i = 2; i <= n; ++i)\n\t{\n\t\twhile (k && s[k + 1] != s[i])\n\t\t\tk = fail[k];\n\t\tfail[i] = (k += s[k + 1] == s[i]);\n\t}\n}\n\ns64 solve(s64 l, int c)\n{\n\ts64 res = 0;\n\twhile (l > n)\n\t{\n\t\ts64 nl = cir_l, nr = n;\n\t\ts64 sl = sum[cir_l][c], sr = sum[n][c];\n\n\t\twhile (l >= nl + nr)\n\t\t{\n\t\t\tnr += nl, nl = nr - nl;\n\t\t\tsr += sl, sl = sr - sl;\n\t\t}\n\n\t\tl -= nr, res += sr;\n\t}\n\n\treturn res + sum[l][c];\n}\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1) / 2;\n\ts[n + 1] = '\\0';\n\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int c = 0; c < NLet; ++c)\n\t\t\tsum[i][c] = sum[i - 1][c];\n\t\t++sum[i][s[i] - 'a'];\n\t}\n\n\tbuild_fail();\n\n\tcir_l = n - fail[n];\n\n\ts64 l, r;\n\tcin >> l >> r;\n\n\tfor (int c = 0; c < NLet; ++c)\n\t\tcout << solve(r, c) - solve(l - 1, c) << ' ';\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\nchar s[200002];\nlong long hs[200002],pw[200002];\nlong long gethash(int st,int ed)\n{\n\treturn hs[ed]-hs[st-1]*pw[ed-st+1];\n}\nvector<long long> accumulate(int st,int ed)\n{\n\tvector<long long> ret(26);\n\tfor (int i=st;i<=ed;++i)\n\t\t++ret[s[i]-'a'];\n\treturn ret;\n}\nvoid count_numbers(vector<long long> p,vector<long long> q,vector<long long>& ans,long long& rem)\n{\n\tlong long sm=0;\n\tvector<long long> add;\n\tfor (int i=0;i<26;++i)\n\t{\n\t\tsm+=q[i];\n\t\tif (sm>rem)\n\t\t\treturn;\n\t\tadd.push_back(p[i]+q[i]);\n\t}\n\tcount_numbers(q,add,ans,rem);\n\tif (sm<=rem)\n\t{\n\t\tfor (int i=0;i<26;++i)\n\t\t\tans[i]+=q[i];\n\t\trem-=sm;\n\t}\n}\nint plen;\nvector<long long> f10100(long long len,vector<long long> p,vector<long long> q)\n{\n\tvector<long long> ans(26),add(26);\n\tfor (int i=0;i<26;++i)\n\t\tadd[i]=p[i]+q[i];\n\tcount_numbers(p,add,ans,len);\n\tfor (int i=1;i<=len;++i)\n\t\t++ans[s[i]-'a'];\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=int(strlen(s+1));\n\tpw[0]=1;\n\tn/=2;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpw[i]=pw[i-1]*202877;\n\t\ths[i]=hs[i-1]*202877+s[i];\n\t}\n\tfor (int i=n;i>=(n+1)/2;--i)\n\t\tif (gethash(1,n-i)==gethash(i+1,n))\n\t\t\tplen=i;\n\tvector<long long> p=accumulate(1,plen),q=accumulate(plen+1,n);\n\tlong long l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tvector<long long> rnum=f10100(r,p,q),lnum=f10100(l-1,p,q);\n\tfor (int i=0;i<26;++i)\n\t\tprintf(\"%lld \",rnum[i]-lnum[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<class Iter> vector<int>Z_Algorithm(Iter a, Iter a_end) {\n    int n = a_end - a;\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && a[r-l] == a[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && a[r-l] == a[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\n\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=3; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    assert(R <= len[2]);\n    REP (i, R) ans[S[i%N]-'a'] += sgn;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    N /= 2;\n    VI z = Z_Algorithm(S, S+N);\n    \n    int pos = N;\n    for (int i=1; i<N; i++) if (i + z[i] == N) {\n\tpos = i;\n\tbreak;\n    }\n\n    len[0] = pos;\n    len[1] = N;\n    REP (i, N) {\n\tif (i < pos) C[0][S[i]-'a']++;\n\tC[1][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n//    puts(S);\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    assert(len[LEVEL-1] > r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[203][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=199;i>=1;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=200;i++) {\n\t\t\tFOR(j,27) cnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n \n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n \nusing namespace std;\n \ntypedef long long LL;\nconst int N = 400010;\n \nchar s0[N];\nint len, nxt[N];\n \nvoid get_nxt()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= len; i ++) {\n\t\twhile (j && s0[i] != s0[j + 1]) j = nxt[j];\n\t\tif (s0[i] == s0[j + 1]) j ++;\n\t\tnxt[i] = j; \n\t}\n}\n \nLL f[N][30], ans[30];\n \nLL calc(int x, LL k, int c)\n{\n\tif (x == 1 || x == 0) {\n\t\tint ret = 0;\n\t\tRep(i, k) if (s0[i] - 'a' + 1 == c) ret ++;\n\t\treturn ret;\n\t}\n\t\n\tif (f[x][0] == k) return f[x][c];\n\tif (k >= f[x - 1][0])\n\t\treturn f[x - 1][c] + calc(x - 2, k - f[x - 1][0], c);\n\telse return calc(x - 1, k, c);\n}\n \nint main()\n{\n\tscanf(\"%s\", s0 + 1);\n\tlen = strlen(s0 + 1) / 2;\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tget_nxt();\n\t\n\tRep(i, len - nxt[len]) f[0][s0[i] - 'a' + 1] ++;\n\tRep(i, len) f[1][s0[i] - 'a' + 1] ++;\n\tf[0][0] = len - nxt[len], f[1][0] = len;\n\tint x = 2;\n\twhile (true) {\n\t\tRep0(i, 26) f[x][i] = f[x - 1][i] + f[x - 2][i];\n\t\tif (f[x][0] >= r) break;\n\t\tx ++;\n\t}\n\n\tif (l > 1) Rep0(i, x) if (f[i][0] >= l - 1) {\n\t\tRep(j, 26) ans[j] -= calc(i, l - 1, j);\n\t\tbreak;\n\t}\n \n\tRep0(i, x) if (f[i][0] >= r) {\n\t\tRep(j, 26) ans[j] += calc(i, r, j);\n\t\tbreak;\n\t}\n\tRep(i, 26) printf(\"%lld \", ans[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[880008],sz,pos,g,cnt[26][200022],p[26][400044],q[26][800088];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[800088];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int p=998244353;\ntypedef unsigned long long ull;\nint n,len,mx;\nlong long l,r,siz[110],cnt1[110],cnt2[110],ans[26],sum[110][26];\null fhash[200010],bhash[200010],bs[200010];\nchar s[200010];\nvoid solve(long long m,int type){\n    for(int i=mx;~i;i--){\n        if(m>=siz[i]){\n            for(int j=0;j<26;j++)\n                ans[j]+=type?sum[i][j]:-sum[i][j];\n            m-=siz[i];\n        }\n    }\n    for(int i=1;i<=m;i++)\n        ans[s[i]-'a']+=type?1:-1;\n    return;\n}\nsigned main(){\n    scanf(\"%s%lld%lld\",s+1,&l,&r);\n    n=strlen(s+1);\n    bs[0]=1;\n    for(int i=1;i<=n;i++){\n        fhash[i]=fhash[i-1]*p+(s[i]-'a'+1);\n        bs[i]=bs[i-1]*p;\n    }\n    for(int i=n;~i;i--)\n        bhash[i]=bhash[i+1]+(s[i]-'a'+1)*bs[n-i];\n    for(int i=n/2-1;~i;i--)\n        if(fhash[i]==bhash[n-i+1]){\n            len=i;\n            break;\n        }\n    for(int i=1;i<=n/2;i++)\n        sum[0][s[i]-'a']++;\n    for(int i=0;i<26;i++)\n        sum[1][i]=sum[0][i];\n    for(int i=1;i<=n/2-len;i++)\n        sum[1][s[i]-'a']++;\n    siz[0]=n/2;\n    siz[1]=n-len;\n    for(int i=2;i<=100;i++){\n        for(int j=0;j<26;j++)\n            sum[i][j]=sum[i-1][j]+sum[i-2][j];\n        siz[i]=siz[i-1]+siz[i-2];\n        if(siz[i]>1e18){\n            mx=i;\n            break;\n        }\n    }\n    solve(l-1,0);\n    solve(r,1);\n    for(int i=0;i<26;i++)\n        printf(\"%lld \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\t/*\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tV=0;\n\t\t}*/\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define N 200010\n#define ll long long\n\nusing namespace std;\n\nstruct data\n{\n\tll len,a[30];\n\tdata()\n\t{\n\t\tlen=0;\n\t\tmemset(a,0,sizeof(a));\n\t}\n}f[100];\n\ndata operator + (data a,data b)\n{\n\tdata c;\n\tc.len=a.len+b.len;\n\tfor(int i=0;i<26;i++)\n\t\tc.a[i]=a.a[i]+b.a[i];\n\treturn c;\n}\n\ndata operator - (data a,data b)\n{\n\tdata c;\n\tc.len=a.len-b.len;\n\tfor(int i=0;i<26;i++)\n\t\tc.a[i]=a.a[i]-b.a[i];\n\treturn c;\n}\n\nint n,maxn;\nint cut,kmp[N];\nchar s[N],ss[N];\nll ql,qr;\n\ndata query(int k,ll x)\n{\n\tif(x==f[k].len) return f[k];\n\tif(!k)\n\t{\n\t\tdata c;\n\t\tc.len=x;\n\t\tfor(int i=cut+1;i<=cut+x;i++)\n\t\t\tc.a[s[i]-'a']++;\n\t\treturn c;\n\t}\n\tif(k==1)\n\t{\n\t\tdata c;\n\t\tc.len=x;\n\t\tfor(int i=1;i<=x;i++)\n\t\t\tc.a[s[i]-'a']++;\n\t\treturn c;\n\t}\n\tif(x<=f[k-1].len) return query(k-1,x);\n\treturn f[k-1]+query(k-2,x-f[k-1].len);\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&ql,&qr);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n/2;i++)\n\t\tss[n/2-i+1]=s[i];\n\tfor(int i=2,j=0;i<=n/2;i++)\n\t{\n\t\twhile(j&&ss[j+1]!=ss[i]) j=kmp[j];\n\t\tif(ss[j+1]==ss[i]) j++;\n\t\tkmp[i]=j;\n\t}\n\tint cut=n/2-kmp[n/2];\n\tfor(int i=cut+1;i<=n/2;i++)\n\t{\n\t\tf[0].len++;\n\t\tf[0].a[s[i]-'a']++;\n\t}\n\tfor(int i=1;i<=cut;i++)\n\t{\n\t\tf[1].len++;\n\t\tf[1].a[s[i]-'a']++;\n\t}\n\tfor(int i=2;;i++)\n\t{\n\t\tf[i].len=f[i-1].len+f[i-2].len;\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i].a[j]=f[i-1].a[j]+f[i-2].a[j];\n\t\tif(f[i].len>qr)\n\t\t{\n\t\t\tmaxn=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdata ans=query(maxn,qr)-query(maxn,ql-1);\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",ans.a[i]);\n\treturn 0;\n}\n/*\n87167725689669676 0 0 0 0 0 282080685775825810 0 0 0 87167725689669676 0 87167725689669676 0 0 87167725689669676 0 0 0 0 87167725689669676 141040342887912905 0 141040342887912905 0 0\n87167725689669676 0 0 0 0 0 282080685775825810 0 0 0 87167725689669676 0 87167725689669676 0 0 87167725689669676 0 0 0 0 87167725689669676 141040342887912905 0 141040342887912905 0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < 2*INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 400010;\n\nchar s0[N];\nint len, nxt[N];\n\nvoid get_nxt()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= len; i ++) {\n\t\twhile (j && s0[i] != s0[j + 1]) j = nxt[j];\n\t\tif (s0[i] == s0[j + 1]) j ++;\n\t\tnxt[i] = j; \n\t}\n}\n\nLL f[N][27], ans[27];\n\nLL calc(int x, LL k, int c)\n{\n\t//printf(\"%d %lld %lld %d\\n\", x, k, f[x][0], c);\n\t\n\tif (f[x][0] == k) return f[x][c];\n\tif (k >= f[x - 1][0])\n\t\treturn f[x - 1][c] + calc(x - 2, k - f[x - 1][0], c);\n\telse return calc(x - 1, k, c);\n}\n\nint main()\n{\n\tscanf(\"%s\", s0 + 1);\n\tlen = strlen(s0 + 1) / 2;\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tget_nxt();\n\t\n\t//printf(\"%d %d\\n\", nxt[len], len - nxt[len]);\n\t\n\tRep(i, len - nxt[len]) f[0][s0[i] - 'a' + 1] ++;\n\tRep(i, len) f[1][s0[i] - 'a' + 1] ++;\n\tf[0][0] = len - nxt[len], f[1][0] = len;\n\tint x = 2;\n\twhile (true) {\n\t\tRep0(i, 26) f[x][i] = f[x - 1][i] + f[x - 2][i];\n\t\t//printf(\"%d %lld\\n\", x, f[x][0]);\n\t\tif (f[x][0] >= r) break;\n\t\tx ++;\n\t}\n\tif (l > 1) Rep0(i, x) if (f[i][0] >= l - 1) {\n\t\tRep(j, 26) ans[j] -= calc(i, l - 1, j);\n\t\tbreak;\n\t}\n\n\tRep0(i, x) if (f[i][0] >= r) {\n\t\tRep(j, 26) ans[j] += calc(i, r, j);\n\t\tbreak;\n\t}\n\tRep(i, 26) printf(\"%lld \", ans[i]);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n/*\nxx\n1 100\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252*2];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt <= end && y*ycnt <= end && x*xcnt+y*ycnt > 0 && x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  s = f(s);\n  int x1 = s.size();\n  // first step\n  s = f(s);\n  int x2 = s.size();\n  // second\n  string t = f(s);\n  int x3 = t.size();\n\n  if(x3-x2 == x2-x1){\n    int width = x3-x2;\n    {\n      ll x = r;\n      ll tms = x/width;\n      ll y = x-tms*width;\n      REP(i,width)ans[s[i]-'a'] += tms;\n      REP(i,y)ans[s[i]-'a']++;\n    }\n    {\n      ll x = l-1;\n      ll tms = x/width;\n      ll y = x-tms*width;\n      REP(i,width)ans[s[i]-'a'] -= tms;\n      REP(i,y)ans[s[i]-'a']--;\n    }\n    REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n    return 0;\n  }\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r+1);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(X,Y,l);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(ad, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tassert(c);\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tif (n%k==0){\n\t\t\tr-=n;\n\t\t\t/*for (ll i=0;i<n;i++) w[s[i]-'a']++;\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=r/k;\n\t\t\tfor (ll i=0;i<r%k;i++) w[s[i]-'a']++;*/\n\t\t}else{\n\t\t\tll _s=0,_t=1,S=1,T=0;\n\t\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\t\twork(r-_s*n-_t*k);\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 30000\n\nll l,r;\n\nint z[MAXN];\nvoid getz(char s[]){\n\tms(z);\n\tint n = strlen(s);\n\tint l = 0, r = 0;\n\tfor(int i = 1;i < n;i++){\n\t\tif(i > r){\n\t\t\tl = r = i;\n\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\tr--;\n\t\t\tz[i] = r-l+1;\n\t\t}else{\n\t\t\tint k = i-l;\n\t\t\tif(z[k] < r-i) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tl = i;\n\t\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\t\tr--;\n\t\t\t\tz[i] = r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nll j;\nchar s1[MAXN];\nll final[28][2];\nint n;\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\tgetz(s1);\n\tlen[0] = n/4;\n\tfor(int i = 0;i < n;i++)\n\t\tcout << s1[i] << \" \";cout << endl;\n\tfor(int i = 0;i < n;i++)\n\t\tcout << z[i] << \" \";cout << endl;\n\twhile(1){\n\t\tif(z[len[0]]+len[0] >= n/2) break;\n\t\tlen[0]++;\n\t}\n\tlen[0] = len[0];\n\tlen[1] = n/2;\n\tcout << len[0] << \" =-=-==-==-\" << endl;\n\tcout << len[1] << \" =-=-==-==-\" << endl;\n\tj = 2;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 0;i < len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 0;i < len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 0;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n//\tfreopen(\"ss.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tcin >> s1;\n\tcin >> l >> r;\n\t\n\tn = strlen(s1);\n\tl--;r--;\n\t\n\tms(final);\n\tif(l >= 1) getans(l-1,0);\n\tif(r >= 0)getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=2e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nclass alphs{\npublic:\n\tarray<llint,26> kaz;\n\talphs(){for(int i=0;i<26;i++){kaz[i]=0;}}\n\talphs& operator +=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]+=other.kaz[i];}\n\t\treturn (*this);\n\t}\n\talphs& operator -=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]-=other.kaz[i];}\n\t\treturn (*this);\n\t}\n};\nvector<llint> retu;\nvector<alphs> mowa;\nstring str;\nvoid retus(void){\n\tllint k=retu.back();\n\talphs a=mowa.back();\n\twhile(-1){\n\t\tk+=retu[retu.size()-2];retu.pub(k);\n\t\ta+=mowa[mowa.size()-2];mowa.pub(a);\n\t\tif(retu.back()>big){return;}\n\t}\n}\nalphs solve(llint x,llint fu){\n\talphs ans;\n\tif(fu==0||fu==1){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[str[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(x<retu[fu-1]){return solve(x,fu-1);}\n\tans=mowa[fu-1];\n\tans+=solve(x-retu[fu-1],fu-2);\n\treturn ans;\n}\n\nint main(void){\n\tllint l,r,n,i,j;//p r p の最初のp\n\tcin>>str;n=str.size();\n\tcin>>l>>r;\n\talphs it;n/=2;\n\tfor(i=0;i<n;i++){it.kaz[str[i]-'a']++;}\n\tmowa.pub(it);\n\tretu.pub(n);\n\tfor(j=0;j<n;j++){str.pob();}\n\tllint ueha=0;\n\tllint siha=0;\n\tconst llint ueka=101;\n\tllint uegen=1;\n\tfor(i=1;i<=n;i++){//上と下が良い数\n\t\tueha+=(str[i-1]-'a')*uegen;ueha%=mod;\n\t\tuegen*=ueka;uegen%=mod;\n\t\tsiha*=ueka;\n\t\tsiha+=(str[n-i]-'a');\n\t\tsiha%=mod;\n\t\tif(ueha==siha){break;}\n\t}\n\tfor(j=0;j<n-i;j++){\n\t\tstr.pub(str[j]);\n\t\tit.kaz[str[j]-'a']++;\n\t}\n\tmowa.pub(it);\n\tretu.pub(str.size());\n\tretus();\n\tauto ans=solve(r,retu.size());\n\tans-=solve(l-1,retu.size());\n\tfor(i=0;i<26;i++){cout<<ans.kaz[i]<<\" \";}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 200005\nusing namespace std;\n//ifstream cin(\"date.in\");\n//ofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    n /= 2;\n    for(i = 2; i <= n; i++){\n        while(L > 0 && s[i] != s[L + 1]){\n            L = p[L];\n        }\n        if(s[i] == s[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    for(i = 1; i <= n; i++){\n        ok = 1;\n        for(j = i + i; j <= n; j += i){\n            if(p[j] != j - i){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(j = j - i + 1; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n >= dr || fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 2000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nstring f1(string s) {\n    rep(i, 0, sz(s)) {\n        string t = s.substr(0, i + 1);\n        t += t;\n        if (sz(t) > sz(s) && t.substr(0, sz(s)) == s) {\n            return t;\n        }\n    }\n    return \"\";\n}\n\nstring f(string s) {\n    repb(i, sz(s) - 1, 0) {\n        if (s.substr(0, i) == s.substr(sz(s) - i)) {\n            return s + s.substr(0, sz(s) - i);\n        }\n    }\n    return \"\";\n}\n\nvoid fff1(string s) {\n    rep(i, 0, 6) {\n        cout << s << endl;\n        s = f1(s);\n    }\n}\n\nvoid ff2(string s) {\n    rep(i, 0, 6) {\n        cout << s << endl;\n        s = f(s);\n    }\n}\n\nvector<int> pf(string s) {\n    int n = sz(s);\n    vector<int> p(n, 0);\n    rep(i, 1, n) {\n        int pos = i - 1;\n        while (pos >= 0) {\n            if (s[i] == s[p[pos]]) {\n                p[i] = p[pos] + 1;\n                break;\n            }\n            pos = p[pos] - 1;\n        }\n        if (pos == -1) {\n            p[i] = 0;\n        }\n    }\n    return p;\n}\n\nvector<ll> solve1(string s, ll x) {\n    vector<ll> res(26, 0);\n    rep(i, 0, sz(s)) {\n        res[s[i] - 'a'] += x / sz(s);\n    }\n    rep(i, 0, x % sz(s)) {\n        res[s[i] - 'a']++;\n    }\n    return res;\n}\n\nvoid solve(string s) {\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve1(s, r), b = solve1(s, l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nstring t1, t2;\nvector<ll> c1(26, 0), c2(26, 0);\nll len[100], cnt1[100], cnt2[100];\nvector<ll> ans;\n\nvoid rec(int p, ll x) {\n    if (p == 0) {\n        rep(i, 0, x) {\n            ans[t1[i] - 'a']++;\n        }\n    } else if (p == 1) {\n        rep(i, 0, x) {\n            ans[t2[i] - 'a']++;\n        }\n    } else {\n        if (x <= len[p - 1]) {\n            rec(p - 1, x);\n        } else {\n            rep(i, 0, 26) {\n                ans[i] += c1[i] * cnt1[p - 1] + c2[i] * cnt2[p - 1];\n            }\n            rec(p - 2, x - len[p - 1]);\n        }\n    }\n}\n\nvector<ll> solve2(string A, int k, string B, ll x) {\n    t1 = \"\"; t2 = \"\";\n    rep(i, 0, k) {\n        t1 += A;\n    }\n    t1 += B;\n    t2 = t1 + A;\n    c1 = vector<ll> (26, 0);\n    c2 = vector<ll> (26, 0);\n    rep(i, 0, sz(t1)) {\n        c1[t1[i] - 'a']++;\n    }\n    rep(i, 0, sz(t2)) {\n        c2[t2[i] - 'a']++;\n    }\n    len[0] = sz(t1);\n    cnt1[0] = 1;\n    len[1] = sz(t2);\n    cnt2[1] = 1;\n    int p = 1;\n    while (len[p] < x) {\n        p++;\n        len[p] = len[p - 1] + len[p - 2];\n        cnt1[p] = cnt1[p - 1] + cnt1[p - 2];\n        cnt2[p] = cnt2[p - 1] + cnt2[p - 2];\n    }\n    ans = vector<ll> (26, 0);\n    rec(p, x);\n    return ans;\n}\n\nvoid solve(string A, int k, string B) {\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve2(A, k, B, r), b = solve2(A, k, B, l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    string s;\n    cin >> s;\n    //fff1(s);\n    //cout << endl;\n    s = f1(s); s = s.substr(sz(s) / 2);\n    //ff2(s);\n    //cout << s << endl;\n    vector<int> p = pf(s);\n    /*for (int i : p) {\n        cout << i << \" \";\n    }\n    cout << endl;*/\n    int n = sz(s);\n    int per = n - p[n - 1];\n    if (n % per == 0) {\n        solve(s.substr(0, per));\n    } else {\n        solve(s.substr(0, per), n / per, s.substr(0, n % per));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\tint i,j;\n\tfor(i=99;i>=2;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j]-cnt[i-2][j]/2;\n\t\t\tV-=cnt[i][26]-cnt[i-2][26]/2;\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.11.2019 02:41:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> kmp_table(int n, const T &s) {\n  vector<int> p(n, 0);\n  int k = 0;\n  for (int i = 1; i < n; i++) {\n    while (k > 0 && !(s[i] == s[k])) {\n      k = p[k - 1];\n    }\n    if (s[i] == s[k]) {\n      k++;\n    }\n    p[i] = k;\n  }\n  return p;\n}\n\ntemplate <typename T>\nvector<int> kmp_table(const T &s) {\n  return kmp_table((int) s.size(), s);\n}\n\ntemplate <typename T>\nvector<int> kmp_search(int n, const T &s, int m, const T &w, const vector<int> &p) {\n  assert(n >= 1 && (int) p.size() == n);\n  vector<int> res;\n  int k = 0;\n  for (int i = 0; i < m; i++) {\n    while (k > 0 && (k == n || !(w[i] == s[k]))) {\n      k = p[k - 1];\n    }\n    if (w[i] == s[k]) {\n      k++;\n    }\n    if (k == n) {\n      res.push_back(i - n + 1);\n    }\n  }\n  return res;\n  // returns 0-indexed positions of occurrences of s in w\n}\n\ntemplate <typename T>\nvector<int> kmp_search(const T &s, const T &w, const vector<int> &p) {\n  return kmp_search((int) s.size(), s, (int) w.size(), w, p);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  if (s.size() == 1) s += s;\n  long long L, R;\n  cin >> L >> R;\n  vector<int> pers;\n  vector<string> sss;\n  while (true) {\n    vector<int> p = kmp_table(s);\n    int n = (int) s.size();\n    int x = p[n - 1];\n    while (x >= n / 2) {\n      x = p[x - 1];\n    }\n    s += s.substr(x, n - 2 * x);\n    pers.push_back(n - x);\n    debug(s, pers);\n    sss.push_back(s);\n    if (pers.size() == 2) break;\n  }\n  string A = sss[0];\n  string B = sss[1];\n  vector<long long> len(2);\n  vector<vector<long long>> cnt(2, vector<long long>(26));\n  for (char c : A) {\n    len[0] += 1;\n    cnt[0][c - 'a'] += 1;\n  }\n  for (char c : B) {\n    len[1] += 1;\n    cnt[1][c - 'a'] += 1;\n  }\n  while (len.back() < R) {\n    len.push_back(len.back() + len[len.size() - 2]);\n    cnt.emplace_back(26, 0);\n    for (int i = 0; i < 26; i++) cnt.back()[i] = cnt[cnt.size() - 3][i] + cnt[cnt.size() - 2][i];\n  }\n  vector<long long> res(26);\n  function<void(long long, long long)> Fun = [&](long long L, long long R) {\n    int id = 0;\n    while (len[id] < R) {\n      ++id;\n    }\n    if (id == 0) {\n      for (int i = L; i <= R; i++) res[A[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (id == 1) {\n      for (int i = L; i <= R; i++) res[B[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (L == 1 && R == len[id]) {\n      for (int i = 0; i < 26; i++) res[i] += cnt[id][i];\n      return;\n    }\n    if (L > len[id - 1]) {\n      Fun(L - len[id - 1], R - len[id - 1]);\n    } else {\n      Fun(L, len[id - 1]);\n      Fun(1, R - len[id - 1]);\n    }\n  };\n  Fun(L, R);\n  for (int i = 0; i < 26; i++) cout << res[i] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define REPD(i, a, b) for(int i = a; i >= b; -- i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPG(i, h, x) for(int i = h[x]; ~i; i = edge[i].next)\n\ntypedef long long LL;\nconst int N = 2e5 + 3;\n\nchar buf[N];\nLL suc[N][30];\nint n;\n\nint pe, nxt[N];\nLL fib(LL len, int c) {\n    if(len <= n) return suc[len][c];\n    if(len <= n * 2) return suc[n][c] + suc[len - n][c];\n    LL g1 = suc[n][c], g2 = suc[n][c] + suc[pe][c], l1 = n, l2 = n + pe;\n    while(len > l1 + l2) {\n        LL tg = g2; g2 += g1, g1 = tg;\n        LL tl = l2; l2 += l1, l1 = tl;\n    }\n    return g2 + fib(len - l2, c);\n}\nLL lf, rt;\nLL calc(LL len, int c) {\n    if(len <= n) return suc[len][c];\n    else if(n % pe) return fib(len, c);\n    else {\n        LL ret = 1ll * (len - n) / pe * suc[pe][c] + suc[n][c];\n        len -= n, len %= pe;\n        return ret + suc[len][c];\n    }\n}\n\ninline void get_nxt() {\n    int j = 0; nxt[1] = 0;\n    REP(i, 2, n) {\n        while(j && buf[j + 1] != buf[i]) j = nxt[j];\n        if(buf[j + 1] == buf[i]) ++ j;\n        nxt[i] = j;\n    }\n\n}\n\nint main() {\n    scanf(\"%s%lld%lld\", buf + 1, &lf, &rt);\n    n = strlen(buf + 1); n >>= 1;\n    get_nxt();\n    for(int i = 1; i <= n; i ++) {\n        for(int j = 0; j < 26; j ++) suc[i][j] = suc[i - 1][j];\n        suc[i][buf[i] - 'a'] ++;\n    }\n    pe = n - nxt[n];\n    REP(i, 0, 25) printf(\"%lld \", calc(rt, i) - calc(lf - 1, i));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int MAXN=3e5+5;\n\nint len,anc[30][MAXN],S,T,num,nxt[MAXN];\nll l,r;\nchar s[MAXN];\n\nll calc(ll lt,int n){\n\tif(lt<=len)return anc[n][lt];\n\tif(lt<=2*len)return anc[n][len]+anc[n][lt-len];\n\tll f1=anc[n][S],f2=anc[n][len],lenf1=S,lenf2=len;\n\twhile(lt>lenf1+lenf2){\n\t\tll tem2=f2,lentem2=lenf2;\n\t\tf2+=f1;lenf2+=lenf1;\n\t\tf1=tem2;lenf1=lentem2;\n\t}\n\treturn f2+calc(lt-lenf2,n);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\tlen=strlen(s+1)/2;\n\tnxt[1]=0;\n    for(int j=0,i=2;i<=len;i++){\n        for(;j&& s[j+1]!=s[i];)j=nxt[j];\n        if(s[j + 1]==s[i])j++;\n        nxt[i]=j;\n    }\n\tT=nxt[len];\n\tS=len-T;\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=1;j<=len;j++){\n\t\t\tanc[i][j]=anc[i][j-1];\n\t\t\tif((int)s[j]-96==i)anc[i][j]++;\n\t\t}\n\t}\n//\tcout<<calc(43200,1);\n\tfor(int i=1;i<=26;i++){\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 400050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\telse\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=npos+1;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\nconst bool debug = 0;\n//---------------------------------//\n\nvector<int> z_algorithm(string s) {\n\tvector<int> res(s.size());\n\t\n\tres[0] = s.size();\n\t\n\tint i = 1, j = 0;\n\t\n\twhile (i < s.size()) {\n\t\twhile (i + j < s.size() && s[j] == s[i + j]) j++;\n\t\tres[i] = j;\n\t\tif (j == 0) { i++; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < s.size() && k + res[k] < j) res[i + k] = res[k], k++;\n\t\ti += k;\n\t\tj -= k;\n\t}\n\t\n\treturn res;\n}\n\nstring S, T;\nll l, r;\nll cnt[100][26], size[100], ans[26]; // g^i(S)の各文字の数, |g^i(S)|\nstring s0, s1; // g^0(S), g^1(S)\n\nll solve(ll x, int c) {\n\tll p = 0, pos = x;\n\tREP(i, 100) if (size[i] >= x) { p = i; break; }\n\t\n\tll res = 0;\n\t\n\twhile (p > 1) {\n\t\tif (pos >= size[p - 1]) {\n\t\t\tres += cnt[p - 1][c];\n\t\t\tpos -= size[p - 1];\n\t\t\tp -= 2;\n\t\t}\n\t\telse {\n\t\t\tp -= 1;\n\t\t}\n\t}\n\t\n\tres += count(s1.begin(), s1.begin() + pos, c + 'a');\n\treturn res;\n}\n\nll solve2(ll x, int c) {\n\tif (x <= 0) return 0;\n\t\n\tll res = 0;\n\tif (x <= size[1]) {\n\t\tres += count(s1.begin(), s1.begin() + x, c + 'a');\n\t}\n\telse {\n\t\tll b = cnt[1][c] - cnt[0][c], ts = size[1] - size[0]; // Tに含まれる文字cの数, |T|\n\t\t\n\t\tres += b * (x / ts);\n\t\tres += count(T.begin(), T.begin() + (x % ts), c + 'a');\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tcin >> S >> l >> r;\n\t\n\ts0 = S.substr(0, S.size() / 2);\n\t\n\tvector<int> z = z_algorithm(s0);\n\tint k = INF;\n\tFOR(i, 1, z.size()) if (z[i] + i == s0.size()) chmin(k, s0.size() - z[i]);\n\tif (k == INF) k = s0.size();\n\t\n\tT = s0.substr(0, k);\n\ts1 = s0 + T;\n\t\n\tsize[0] = s0.size();\n\tREP(i, s0.size()) cnt[0][s0[i] - 'a']++;\n\t\n\tsize[1] = s1.size();\n\tREP(i, s1.size()) cnt[1][s1[i] - 'a']++;\n\t\n\tif (s0.size() % k == 0) {\n\t\tREP(i, 26) ans[i] = solve2(r, i) - solve2(l - 1, i);\n\t}\n\telse {\n\t\tFOR(i, 2, 100) {\n\t\t\tsize[i] = size[i - 1] + size[i - 2];\n\t\t\tREP(j, 26) cnt[i][j] = cnt[i - 1][j] + cnt[i - 2][j];\n\t\t\tif (size[i] > 1000000000000000000ll) break;\n\t\t}\n\t\t\n\t\tREP(i, 26) ans[i] = solve(r, i) - solve(l - 1, i);\n\t}\n\t\n\tREP(i, 26) printf(\"%lld%c\", ans[i], i == 25 ? '\\n' : ' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <valarray>\n\ntypedef long long i64;\n\nconst int N = 400000 + 10, S = 100;\n\nint n, x, y;\nchar s[N];\n\nstd::valarray<i64> sum[N];\n\nvoid init() {\n  static int next[N];\n  next[1] = 0;\n  for (int i = 2; i <= n; ++i) {\n    int j = next[i - 1];\n    while (j && s[j + 1] != s[i]) j = next[j];\n    j += (s[j + 1] == s[i]);\n    next[i] = j;\n  }\n  sum[0].resize(26);\n  for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1], ++sum[i][s[i] - 'a'];\n  x = n - next[n];\n  y = x - next[x];\n}\n\nstd::valarray<i64> solve(i64 m) {\n  if (m <= n) return sum[m];\n  if (x % y == 0) {\n    m -= x;\n    return sum[x] + sum[y] * (m / y) + sum[m % y];\n  }\n  static i64 fib[S];\n  static std::valarray<i64> temp[S];\n  temp[0] = sum[fib[0] = y];\n  temp[1] = sum[fib[1] = x];\n  for (int i = 2; i < S; ++i) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n    temp[i] = temp[i - 1] + temp[i - 2];\n  }\n  int k = 2;\n  while (fib[k] < m) ++k;\n  std::valarray<i64> res(26);\n  while (k > 1) {\n    if (m >= fib[k - 1]) {\n      res += temp[k - 1];\n      m -= fib[k - 1];\n      k -= 2;\n    } else {\n      --k;\n    }\n  }\n  res += sum[m];\n  return res;\n}\n\nint main() {\n  i64 l, r;\n  scanf(\" %s%lld%lld\", s + 1, &l, &r);\n  n = strlen(s + 1);\n  init();\n  std::valarray<i64> ans = solve(r) - solve(l - 1);\n  for (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 400005;\nconst int MM = 1000000007;\n\nstring D;\n\nstring f(string D, int &a){\n\tstatic int F[MX] = {};\n\tint N = D.size();\n\tfor(int i = 0; i <= D.size(); i++) F[i] = -1;\n\tfor(int i = 1; i <= D.size(); i++){\n\t\tF[i] = F[i-1];\n\t\twhile(F[i] != -1 && D[F[i]] != D[i-1]) F[i] = F[F[i]];\n\t\tF[i] += 1;\n\t}\n\ta = F[N];\n\twhile(a >= N/2) a = F[a];\n\treturn D + D.substr(a, N-2*a);\n}\n\nvoid solve1(string A, ll ad, ll ans[26])\n{\n\tfor(int i = 0; i < 26; i++) ans[i] = 0;\n\tint cnt[26] = {};\n\tstring B = A.substr(0, A.size()/2);\n\tfor(char c : B) cnt[c-'a']++;\n\tfor(int i = 0; i < ad%B.size(); i++) ans[B[i]-'a']++;\n\tfor(int i = 0; i < 26; i++) ans[i] += cnt[i] * (ad/B.size());\n}\n\nvoid solve2(string A, string B, ll ad, ll ans[26])\n{\n\tint c1[26] = {}, c2[26] = {};\n\tfor(char c : A) c1[c-'a']++;\n\tfor(char c : B) c2[c-'a']++;\n\n\tvector<pll> L;\n\tL.push_back(pll(1, 0));\n\tL.push_back(pll(0, 1));\n\twhile(L.back().first * A.size() + L.back().second * B.size() <= ad){\n\t\tL.emplace_back(L[L.size()-2].first + L.back().first, L[L.size()-2].second + L.back().second);\n\t}\n\treverse(L.begin(), L.end());\n\tfor(pll c : L){\n\t\tll v = c.first * A.size() + c.second * B.size();\n\t\tif( ad < v ) continue;\n\t\tad -= v;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tans[i] += c1[i] * c.first + c2[i] * c.second;\n\t\t}\n\t}\n\tfor(int i = 0; i < ad; i++) ans[A[i]-'a'] ++;\n}\n\nint main()\n{\n\tstring A;\n\tint a;\n\tll l, r;\n\tcin >> A >> l >> r; A = f(A, a);\n\tf(A, a);\n\n\tll a1[26] = {}, a2[26] = {};\n\tif( a == 0 || a*4 == A.size() ) solve1(A, r, a1), solve1(A, l-1, a2);\n\telse{\n\t\tsolve2(A.substr(0, a), A.substr(a, A.size()/2-a), r, a1);\n\t\tsolve2(A.substr(0, a), A.substr(a, A.size()/2-a), l-1, a2);\n\t}\n\tfor(int i = 0; i < 26; i++) printf(\"%lld \", a1[i] - a2[i]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nstring S, T;\nll sz[100];\nll cc[100][26];\n\nstring get_nv ()\n{\n    for (int i = S.length() + 2; ; i += 2)\n    {\n        bool bad = false;\n        int cchunk = i / 2;\n        for (int j = cchunk; j < S.length(); j++)\n            if (S[j] != S[j-cchunk])\n            {\n                bad = true;\n                break;\n            }\n\n        if (!bad)\n        {\n            return S + S.substr(S.length() - cchunk, i - S.length());\n        }\n    }\n}\n\nvector <ll> gogo (ll x)\n{\n    if (x < sz[0])\n    {\n        vector <ll> res;\n        for (int i = 0; i < 26; i++)\n            res.push_back(0);\n\n        for (int i = 0; i < x; i++)\n            res[S[i]-'a']++;\n        return res;\n    }\n\n    int chi = 0;\n    while (x >= sz[chi+1])\n        chi++;\n\n    vector <ll> res;\n    for (int i = 0; i < 26; i++)\n        res.push_back(cc[chi][i]);\n\n    vector <ll> nleft = gogo (x - sz[chi]);\n    for (int i = 0; i < 26; i++)\n        res[i] += nleft[i];\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> S;\n    T = get_nv ();\n\n    //cout << T << \"\\n\";\n\n    sz[0] = S.length() / 2;\n    for (int i = 0; i < S.length() / 2; i++)\n    {\n        int nv = S[i] - 'a';\n        cc[0][nv]++;\n    }\n    sz[1] = T.length() / 2;\n    for (int i = 0; i < T.length() / 2; i++)\n    {\n        int nv = T[i] - 'a';\n        cc[1][nv]++;\n    }\n    \n    int chi = 2;\n    while (true)\n    {\n        sz[chi] = sz[chi-1] + sz[chi-2];\n        for (int i = 0; i < 26; i++)\n        {\n            cc[chi][i] = cc[chi-1][i] + cc[chi-2][i];\n        }\n\n        if (sz[chi] > 2e18)\n            break;\n        chi++;\n    }\n\n    ll L, R;\n    cin >> L >> R;\n    vector <ll> res1 = gogo (R), res2 = gogo (L - 1);\n    for (int i = 0; i < 26; i++)\n        res1[i] -= res2[i];\n\n    for (int i = 0; i < 26; i++)\n    {\n        if (i) cout << \" \";\n        cout << res1[i];\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n/*\tREP(i,n-1)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==0){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}*/ \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=200010;\nchar s[N];\nint nxt[N];\nLL l,r;\nLL f[100][27];\nLL sum[100],ans[27];\n\nvoid getnext()\n{\n\tint n=strlen(s+1)/2,j=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile(j&&s[i]!=s[j+1]) j=nxt[j];\n\t\tif(s[i]==s[j+1]) j++;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid initfib()\n{\n\tfor(int i=2;i<=87;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t}\n}\n\nvoid gao(LL x,int fg)\n{\n\tint p;\n\tfor(p=0;p<=87;p++)\n\t\tif(sum[p]>x) break;\n\tfor(;p>=0;p--)\n\t\tif(x>=sum[p])\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t\tans[i]+=fg*f[p][i];\n\t\t\tx-=sum[p];\n\t\t}\n\tfor(int i=1;i<=x;i++) ans[s[i]-'a']+=fg;\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tf[0][s[i]-'a']++;\n\tgetnext();\n\tsum[0]=n;sum[1]=2*(n-nxt[n/2]);\n\tfor(int i=0;i<26;i++) f[1][i]=f[0][i];\n\tfor(int i=nxt[n/2]+1;i<=n-nxt[n/2];i++)\n\t\tf[1][s[i]-'a']++;\n\tinitfib();gao(r,1);gao(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\nchar s[200002];\nlong long hs[200002],pw[200002];\nlong long gethash(int st,int ed)\n{\n\treturn hs[ed]-hs[st-1]*pw[ed-st+1];\n}\nvector<long long> accumulate(int st,int ed)\n{\n\tvector<long long> ret(26);\n\tfor (int i=st;i<=ed;++i)\n\t\t++ret[s[i]-'a'];\n\treturn ret;\n}\nvoid count_numbers(vector<long long> p,vector<long long> q,vector<long long>& ans,long long& rem)\n{\n\tlong long sm=0;\n\tvector<long long> add;\n\tfor (int i=0;i<26;++i)\n\t{\n\t\tsm+=q[i];\n\t\tadd.push_back(p[i]+q[i]);\n\t}\n\tif (sm>rem)\n\t\treturn;\n\tcount_numbers(q,add,ans,rem);\n\tif (sm<=rem)\n\t{\n\t\tfor (int i=0;i<26;++i)\n\t\t\tans[i]+=q[i];\n\t\trem-=sm;\n\t}\n}\nint plen;\nvector<long long> f10100(long long len,vector<long long> p,vector<long long> q)\n{\n\tvector<long long> ans(26);\n\tcount_numbers(q,p,ans,len);\n\tfor (int i=1;i<=len;++i)\n\t\t++ans[s[i]-'a'];\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=int(strlen(s+1));\n\tpw[0]=1;\n\tn/=2;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpw[i]=pw[i-1]*202877;\n\t\ths[i]=hs[i-1]*202877+s[i];\n\t}\n\tfor (int i=n;i>=n/2+1;--i)\n\t\tif (gethash(1,n-i)==gethash(i+1,n))\n\t\t\tplen=i;\n\tvector<long long> p=accumulate(1,plen),q=accumulate(plen+1,n);\n\tlong long l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tvector<long long> rnum=f10100(r,p,q),lnum=f10100(l-1,p,q);\n\tfor (int i=0;i<26;++i)\n\t\tprintf(\"%lld \",rnum[i]-lnum[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=1;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nchar S[202020];\nint F[202020], L;\nlong long x[100], y[100], cntx[100][26], cnty[100][26], ans[26];\n\nvoid go(int p, long long l, long long r)\n{\n\tif (r <= L){\n\t\twhile (l < r){\n\t\t\tans[S[l]-'a']++;\n\t\t\tl++;\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long w = 0;\n\tfor (int k=0;;k++){\n\t\tlong long a = (k%3==1?y[p]:x[p]);\n\t\tlong long u = max(l, w);\n\t\tlong long v = min(r, w+a);\n\t\tif (r <= w) break;\n\t\tif (v - u == a){\n\t\t\tif (k % 3 == 1) for (int k=0;k<26;k++) ans[k] += cnty[p][k];\n\t\t\telse for (int k=0;k<26;k++) ans[k] += cntx[p][k];\n\t\t}\n\t\telse if (u < v) go(p-1, u-w, v-w);\n\t\tw += a;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\", S);\n\n\tint l = 0;\n\twhile (S[l]) l++;\n\tL = l;\n\n\tint k = -1; F[0] = -1;\n\tfor (int i=1;i<l;i++){\n\t\twhile (k >= 0 && S[k+1] != S[i]) k = F[k];\n\t\tif (S[k+1] == S[i]) k++;\n\t\tF[i] = k;\n\t}\n\n\tint u = l-1;\n\twhile ((u + 1) >= (l + 1) / 2) u = F[u];\n\tint r = l - (u + 1) * 2;\n\n\tconst long long lim = (long long)1e18 + 10;\n\tint v = u+r;\n\twhile ((v + 1) > (u + r + 1) / 2) v = F[v];\n\tfor (int i=0;i<=v;i++) cntx[0][S[i]-'a']++;\n\tfor (int i=v+1;i<=u+r-v-1;i++) cnty[0][S[i]-'a']++;\n\tx[0] = v + 1;\n\ty[0] = u+r-v-1 - v;\n\n\tint p = 1;\n\twhile (1){\n\t\tfor (int k=0;k<26;k++){\n\t\t\tcntx[p][k] = cntx[p-1][k] + cnty[p-1][k];\n\t\t\tcnty[p][k] = cntx[p-1][k];\n\t\t}\n\t\tx[p] = x[p-1] + y[p-1];\n\t\ty[p] = x[p-1];\n\t\tif (x[p] > lim) break;\n\t\tp++;\n\t}\n\t{\n\t\tlong long l, r;\n\t\tscanf(\"%lld %lld\", &l, &r);\n\t\tgo(p, l-1, r);\n\t}\n\tfor (int i=0;i<26;i++) printf(\"%lld%c\", ans[i], i+1<26?' ':'\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nstring f(const string& s) {\n  const int n = s.size();\n  vector<int> Z(n);\n\n  Z[0] = n;\n  for (int i = 1, j = 0; i < n; ) {\n    while (i + j < n && s[j] == s[i + j]) {\n      ++j;\n    }\n    Z[i] = j;\n    if (j == 0) {\n      ++i;\n      continue;\n    }\n    int k = 1;\n    while (i + k < n && k + Z[k] < j) {\n      Z[i + k] = Z[k];\n      ++k;\n    }\n    i += k;\n    j -= k;\n  }\n\n  int r = 0;\n  for (int i = 1; i * 2 < n; ++i) {\n    if (Z[n - i] == i) {\n      r = i;\n    }\n  }\n\n  return s.substr(0, n - r) + s.substr(0, n - r);\n}\n\nInt len[1024], res[26], cnt[1024][26];\nstring A0, A1;\n\nvoid solve(int k, Int L, Int R) {\n  // cerr<<k<<' '<<L<<' '<<R<<endl;\n  if (len[k] == R - L) {\n    for (int i = 0; i < 26; ++i) {\n      res[i] += cnt[k][i];\n    }\n    return;\n  }\n  if (k <= 1) {\n    const string& s = (k == 0 ? A0 : A1);\n    for (int i = L; i < R; ++i) {\n      res[s[i] - 'a']++;\n    }\n    return;\n  }\n  if (L < len[k - 1]) solve(k - 1, L, min(R, len[k - 1]));\n  if (R > len[k - 1]) solve(k - 2, max(L, len[k - 1]) - len[k - 1], R - len[k - 1]);\n}\n\nint main() {\n  string S;\n  cin >> S;\n\n  Int L, R;\n  cin >> L >> R;\n  --L;\n\n  S = f(S);\n  const string S1 = f(S);\n  const string S2 = f(S1);\n\n  A0 = S1.substr(S.size() / 2, S1.size() / 2 - S.size() / 2);\n  A1 = S2.substr(S1.size() / 2, S2.size() / 2 - S1.size() / 2);\n\n  for (const char c : A0) cnt[0][c - 'a']++;\n  for (const char c : A1) cnt[1][c - 'a']++;\n\n  int k = 1;\n  len[0] = A0.size();\n  len[1] = A1.size();\n  for (int i = 2; ; ++i) {\n    len[i] = len[i - 1] + len[i - 2];\n    for (int j = 0; j < 26; ++j) {\n      cnt[i][j] = cnt[i - 1][j] + cnt[i - 2][j];\n    }\n    if (len[i] > INFLL) {\n      k = i;\n      break;\n    }\n  }\n\n  S = S.substr(S.size() / 2);\n\n  fill(res, res + 26, 0);\n  if (L < S.size()) {\n    while (L < S.size() && L < R) {\n      res[S[L] - 'a']++;\n      ++L;\n    }\n  }\n  L -= S.size();\n  R -= S.size();\n\n  if (R - L > 0) {\n    solve(k, L, R);\n  }\n\n  for (int i = 0; i < 26; ++i) {\n    printf(\"%lld%c\", res[i], i+1 == 26 ? '\\n' : ' ');\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n\nusing namespace std;\n\nstring s, t;\nllint n, m;\nllint l, r;\nllint z[200005];\nllint a[26], b[26];\nllint len[105], num[105][26];\n\nvoid z_algorithm(string &s, llint z[])\n{\n\tz[0] = s.size();\n\t\n\tint x = 0, y = 0;\n\tfor(int i = 1; i < s.size(); i++){\n\t\tif(i > y){\n\t\t\tz[i] = 0;\n\t\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\t\tif(i+j > s.size() || s[i+j] != s[j]) break;\n\t\t\t\tz[i]++;\n\t\t\t}\n\t\t\tx = i, y = i + z[i] - 1;\n\t\t}\n\t\telse if(i + z[i-x] <= y) z[i] = z[i-x];\n\t\telse{\n\t\t\tz[i] = y-i+1;\n\t\t\tfor(int j = y-i+1; j < s.size(); j++){\n\t\t\t\tif(i+j > s.size() || s[i+j] != s[j]) break;\n\t\t\t\tz[i]++;\n\t\t\t}\n\t\t\tx = i, y = i + z[i] - 1;\n\t\t}\n\t}\n}\n\nvoid calc(llint x, llint a[])\n{\n\tif(x < 0) return;\n\tfor(int i = 0; i < n; i++) a[s[i]-'a'] += x/n;\n\tfor(int i = 0; i < x%n;i++) a[s[i]-'a']++;\n}\n\nvoid calc2(llint x, llint a[])\n{\n\tif(x <= n){\n\t\tfor(int i = 0; i < x; i++) a[s[i]-'a']++;\n\t\treturn;\n\t}\n\tfor(int i = 2; ; i++){\n\t\tif(x < len[i]){\n\t\t\tfor(int j = 0; j < 26; j++) a[j] += num[i-1][j];\n\t\t\tcalc2(x-len[i-1], a);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> s >> l >> r;\n\ts = s.substr(0, (int)s.size()/2);\n\tn = s.size();\n\t\n\tz_algorithm(s, z);\n\tint p = -1;\n\tfor(int i = 1; i < n; i++){\n\t\tif(z[i] == n-i){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(p == -1){\n\t\tcalc(r, a), calc(l-1, b);\n\t\tfor(int i = 0; i < 26; i++) cout << a[i]-b[i] << \" \"; cout << endl;\n\t\treturn 0;\n\t}\n\t\n\tt = s.substr(0, p);\n\tm = t.size();\n\t\n\tlen[0] = m, len[1] = n;\n\tfor(int i = 0; i < m; i++) num[0][t[i]-'a']++;\n\tfor(int i = 0; i < n; i++) num[1][s[i]-'a']++;\n\tfor(int i = 2; ; i++){\n\t\tlen[i] = len[i-1] + len[i-2];\n\t\tfor(int j = 0; j < 26; j++) num[i][j] = num[i-1][j] + num[i-2][j];\n\t\tif(len[i] > 1000000000000000000) break;\n\t}\n\t\n\tcalc2(r, a), calc2(l-1, b);\n\tfor(int i = 0; i < 26; i++) cout << a[i]-b[i] << \" \"; cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[880008],sz,pos,g,cnt[26][200022],p[26][400044],q[26][800088];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[800088];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*if (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}*/\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (len <= n * 2) return num[n][c] + num[len - n][c];\n    long long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    while (len > l1 + l2) {\n        long long t = f2;\n        f2 += f1, f1 = t;\n        t = l2, l2 += l1, l1 = t;\n    }\n    return f2 + fib(len - l2, c);\n}\n\nlong long calc(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (n % T == 0) {\n        long long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n        len -= n, len %= T;\n        return re + num[len][c];\n    }\n    else return fib(len, c);\n}\n\nint main() {\n    scanf(\"%s%lld%lld\", s + 1, &L, &R);\n    n = strlen(s + 1) / 2;\n    p[1] = 0;\n    for (int j = 0, i = 2; i <= n; i ++) {\n        for (; j && s[j + 1] != s[i];) j = p[j];\n        if (s[j + 1] == s[i]) j ++;\n        p[i] = j;\n    }\n    for (int i = 1; i <= n; i ++) {\n        for (int j = 0; j < 26; j ++) num[i][j] = num[i - 1][j];\n        num[i][s[i] - 'a'] ++;\n    }\n    T = n - p[n];\n\tfor (int i = 0; i < 26; i ++) printf(\"%lld%c\", fib(R, i) - fib(L - 1, i), i == 25 ? 10 : 32);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 200006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nint n,p,t,v[26],height[N],sa[N],rank[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\ninline int read()\n{\n\tint x=0,c=getchar(),f=1;while(c<'0'||c>'9')f=(c=='-'?-f:f),c=getchar();\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+c-48,c=getchar();return f>0?x:-x;\n}\nvoid print(long long x)\n{\n\tif(x>9)print(x/10);putchar(x%10+48);\n}\nvoid SA()\n{\n\tfor(int i=1;i<=n;i++)cntA[(int)s[i]]++;\n\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(int i=n;i;i--)sa[cntA[(int)s[i]]--]=i;\n\trank[sa[1]]=1;\n\tfor(int i=2;i<=n;i++){\n\t\trank[sa[i]]=rank[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])rank[sa[i]]++;\n\t}\n\tfor(int l=1;rank[sa[n]]!=n;l<<=1){\n\t\tfor(int i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcntA[A[i]=rank[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?rank[i+l]:0)]++;\n\t\t}\n\t\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(int i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(int i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\trank[sa[1]]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\trank[sa[i]]=rank[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])rank[sa[i]]++;\n\t\t}\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[rank[i]-1]+tot])tot++;\n\t\theight[rank[i]]=tot;\n\t}\n\tp=n;int mi=N;\n\tfor(int i=rank[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(int i=rank[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(int w,int F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(int i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(int i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(int i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(int i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(int i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(int i=(l-n)%p;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(int i=1;i<=r%p;i++)a[s[i]-97]++;\n\t\t\tfor(int i=0;i<26;i++)a[i]+=1LL*v[i]*(r/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(int i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(int i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(int i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(int i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <complex>\n#include <ctime>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\n#define REP(i,s,t) for(int i=(s);i<(t);i++)\n#define FILL(x,v) memset(x,v,sizeof(x))\n\nconst ll INF = (ll)1E18+1;\n#define MAXN 200005\n\nchar pattern[MAXN];\nint nxt[MAXN];\nvoid calcNext(){\n  int k=0, len = strlen(pattern);\n  nxt[0] = 0;\n  for(int i=1; i<=len; i++){\n    if(pattern[i]==pattern[k]) nxt[i] = nxt[k++];\n    else{\n      nxt[i] = k;\n      while(k>0 && pattern[i]!=pattern[k]) k=nxt[k];\n      if(pattern[k]==pattern[i]) k++;\n    }\n  }\n}\n\nll L, R, plen[100], cnt[100][26];\nint stcnt[MAXN][26];\nvector<ll> solve(int i, ll k) {\n  vector<ll> sol(26,0), sol2(26,0);\n  if (k == 0) return sol;\n  if (i <= 1) {\n    REP(c,0,26) sol[c] = stcnt[k-1][c];\n    return sol;\n  }\n  if (k <= plen[i-1]) {\n    sol = solve(i-1, k);\n  } else {\n    REP(c,0,26) sol[c] = cnt[i-1][c];\n    sol2 = solve(i-2, k-plen[i-1]);\n    REP(c,0,26) sol[c] += sol2[c];\n  }\n  return sol;\n}\nint main() {\n  //freopen(\"input\", \"r\", stdin);\n  cin >> pattern >> L >> R;\n  int N = strlen(pattern);\n  N /= 2;\n  pattern[N] = 0;\n  calcNext();\n  int Tlen = N - nxt[N];\n  REP(i,N,N+Tlen) pattern[i] = pattern[i-N];\n  REP(i,0,N+Tlen) {\n    REP(c,0,26) stcnt[i][c] = stcnt[i-1][c];\n    stcnt[i][pattern[i]-'a']++;\n  }\n  plen[0] = N;\n  plen[1] = N + Tlen;\n  REP(c,0,26) {\n    cnt[0][c] = stcnt[N-1][c];\n    cnt[1][c] = stcnt[N+Tlen-1][c];\n  }\n  int maxi = 1;\n  REP(i,2,100) {\n    plen[i] = plen[i-1] + plen[i-2];\n    REP(c,0,26) cnt[i][c] = cnt[i-1][c] + cnt[i-2][c];\n    if (plen[i] >= INF) {\n      maxi = i;\n      break;\n    }\n  }\n  vector<ll> ans = solve(maxi, R);\n  vector<ll> dec = solve(maxi, L-1);\n  REP(c,0,26) cout << ans[c] - dec[c] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\ntypedef long long ll;\nchar s[maxn];\nint fail[maxn],n;\nll L,R,c[50],d[100][50],len[100];\nvoid solve(ll x,int k,int flag){\n\tif(n%k==0){\n\t\tfor(int i=1;i<=n&&i<=x;++i)\n\t\t\tc[s[i]-'a']+=flag;\n\t\tll y=(x-n)/k;\n\t\tif(y>0){\n\t\t\tfor(int i=1;i<=k;++i)c[s[i]-'a']+=flag*y;\n\t\t\tfor(int i=1;i<=x-n-k*y;i++)c[s[i]-'a']+=flag;\n\t\t}\n\t} else {\n\t\tmemset(d,0,sizeof(d)),memset(len,0,sizeof(len));\n\t\tfor(int i=1;i<=k;++i)d[1][s[i]-'a']+=flag;len[1]=k;\n\t\tfor(int i=1;i<=n;++i)d[2][s[i]-'a']+=flag;len[2]=n;\n\t\tfor(int i=3;len[i-1]+len[i-2]<=x;i++){\n\t\t\tfor(int j=0;j<26;++j)d[i][j]=d[i-1][j]+d[i-2][j];\n\t\t\tlen[i]=len[i-1]+len[i-2];\n//\t\t\tprintf(\"[Len:%lld]\\n\",len[i]);\n\t\t}\n\t\tint i=1;\n\t\tfor(;len[i]<=x&&len[i];i++);i--;\n\t\tfor(int j=i;j>=2;--j)if(x>=len[j]){\n\t\t\tx-=len[j];\n\t\t\tfor(int k=0;k<26;++k)c[k]+=d[j][k];\n\t\t}\n//\t\tprintf(\"[%lld]\",x);\n\t\tfor(int i=1;i<=x;++i)c[s[i]-'a']+=flag;\n\t}\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tfail[1]=0;\n\tfor(int i=2;i<=n;++i){\n\t\tint j=fail[i-1];\n\t\twhile(j&&s[j+1]!=s[i])j=fail[j];\n\t\tif(s[j+1]==s[i])fail[i]=j+1;\n\t\telse fail[i]=j;\n\t}\n\tscanf(\"%lld%lld\",&L,&R);\n\tsolve(L-1,n-fail[n],-1);\n\tsolve(R,n-fail[n],1);\n\tfor(int i=0;i<26;++i)printf(\"%lld \",c[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 300\n\nll l,r;\n\nint z[MAXN];\nvoid getz(char s[]){\n\tms(z);\n\tint n = strlen(s);\n\tint l = 0, r = 0;\n\tfor(int i = 1;i < n;i++){\n\t\tif(i > r){\n\t\t\tl = r = i;\n\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\tr--;\n\t\t\tz[i] = r-l+1;\n\t\t}else{\n\t\t\tint k = i-l;\n\t\t\tif(z[k] < r-i) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tl = i;\n\t\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\t\tr--;\n\t\t\t\tz[i] = r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nll j;\nchar s1[MAXN];\nll final[28][2];\nint n;\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\tgetz(s1);\n\tlen[0] = n/4;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << s1[i] << \" \";cout << endl;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << z[i] << \" \";cout << endl;\n\twhile(1){\n\t\tif(z[len[0]]+len[0] >= n/2) break;\n\t\tlen[0]++;\n\t}\n\tlen[1] = n/2;\n\tlen[2] = len[0] + len[1];\n\tlen[0] = 0;\n\t//cout << len[0] << \" =-=-==-==-\" << endl;\n\t//cout << len[1] << \" =-=-==-==-\" << endl;\n\tj = 3;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\tj--;\n\t//cout << j << \" PPPPPPPPPPPPPPPPPPPPPPPPPP\" << endl;\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 0;i < len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 0;i < len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 0;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t//freopen(\"ss.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tcin >> s1;\n\tcin >> l >> r;\n\t\n\tn = strlen(s1);\n\tl--;r--;\n\t\n\tms(final);\n\tif(l >= 1) getans(l-1,0);\n\tif(r >= 0) getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\ntypedef struct Z { ll l,r,nxt; vector<ll> bordercnt,totcnt; Z() {} Z(ll l,ll r,ll nxt):l(l),r(r),nxt(nxt) {} } Z;\n\nchar s[MAXN+1]; int n;\nll ql,qr;\n\nint nxt[MAXN]; // nxt[i] = longest border of [0..i]\nint scnt[MAXN][26];\n\n\nvector<Z> z;\nvector<ll> add(vector<ll> a,vector<ll> b) { vector<ll> c(26); REP(i,26) c[i]=a[i]+b[i]; return c; }\nvector<ll> sub(vector<ll> a,vector<ll> b) { vector<ll> c(26); REP(i,26) c[i]=a[i]-b[i]; return c; }\nvector<ll> calc(ll r) {\n\tvector<ll> ret(26,0);\n\tint at=0; while(at<SZ(z)&&z[at].r<r) ret=add(ret,z[at].totcnt),++at; assert(at<SZ(z));\n\tif(at==0) {\n\t\tREP(i,26) ret[i]=r==0?0:scnt[r-1][i];\n\t} else {\n\t\tret=add(ret,sub(calc(z[at].nxt+r-z[at].l-1),z[at-1].bordercnt));\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%s%lld%lld\",s,&ql,&qr); --ql; n=strlen(s);\n\t//n=100; REP(i,n/2) s[i]=s[n/2+i]='a'+rand()%2; s[n]='\\0'; ql=1; qr=1000000000000000000;\n\n\tnxt[0]=0; FOR(i,1,n) { nxt[i]=nxt[i-1]; while(nxt[i]!=0&&s[i]!=s[nxt[i]]) nxt[i]=nxt[nxt[i]-1]; if(s[i]==s[nxt[i]]) ++nxt[i]; }\n\t//REP(i,n) printf(\"%d \",nxt[i]); puts(\"\");\n\tmemset(scnt,0,sizeof(scnt)); REP(i,n) { if(i!=0) REP(j,26) scnt[i][j]=scnt[i-1][j]; ++scnt[i][s[i]-'a']; }\n\n\tz.clear(); z.PB(Z(0,n,-1)); z.back().totcnt=calc(n);\n\tll cnxt=nxt[n-1]; while(2*cnxt>=n) cnxt=nxt[cnxt-1]; int at=0;\n\twhile(z.back().r<qr) {\n\t\t//printf(\"cnxt=%lld\\n\",cnxt);\n\t\tz.back().bordercnt=calc(cnxt);\n\t\t//printf(\"cnxt=%lld:\",cnxt); REP(j,26) printf(\" %lld\",z.back().bordercnt[j]); puts(\"\");\n\t\tvector<ll> totcnt=sub(calc(z.back().r-cnxt),z.back().bordercnt);\n\t\t//printf(\"cnxt=%lld:\",cnxt); REP(j,26) printf(\" %lld\",totcnt[j]); puts(\"\");\n\t\tz.PB(Z(z.back().r,z.back().r+z.back().r-2*cnxt,cnxt+1));\n\t\tz.back().totcnt=totcnt;\n\t\tcnxt=z.back().nxt+z.back().r-z.back().l-1-1;\n\t\twhile(at<SZ(z)&&cnxt>=z[at].r) ++at; assert(at<SZ(z));\n\t\tcnxt=at==0?nxt[cnxt]:z[at].nxt+cnxt-z[at].l;\n\t\t//printf(\"cnxt=%lld\\n\",cnxt);\n\t}\n\t//REPSZ(i,z) { printf(\"(%lld,%lld,%lld)\",z[i].l,z[i].r,z[i].nxt); REP(j,26) printf(\" %lld\",z[i].totcnt[j]); if(i!=SZ(z)-1) { printf(\" |\"); REP(j,26) printf(\" %lld\",z[i].bordercnt[j]); } puts(\"\"); }\n\tvector<ll> ret=sub(calc(qr),calc(ql)); REP(j,26) { if(j!=0) printf(\" \"); printf(\"%lld\",ret[j]); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2e5 + 5 ;\nusing namespace std ;\n\nchar s[N] ;\nint p[N], n, f[N][26], top = 0 ;\nstruct poi {\n\tll sum[26], cnt ;\n} a[N] ;\n\nvoid solve(int c, ll x, ll (&ret)[26]) {\n\trep(i, 0, 25) ret[i] = 0 ;\n\tif (x <= (ll) n) {\n\t\trep(i, 1, x) ++ ret[s[i] - 'a'] ;\n\t\treturn ;\n\t}\n\tif (x <= a[c - 1].cnt) {\n\t\tsolve(c - 1, x, ret) ;\n\t\treturn ;\n\t}\n\tsolve(c - 2, x - a[c - 1].cnt, ret) ;\n\trep(i, 0, 25) ret[i] += a[c - 1].sum[i] ;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1) ;\n\tn = strlen(s + 1) ; n /= 2 ;\n\tp[1] = 0 ; int j = 0 ;\n\trep(i, 2, n) {\n\t\tfor ( ; j && s[j + 1] != s[i] ; ) j = p[j] ;\n\t\tif (s[j + 1] == s[i]) ++ j ; \n\t\tp[i] = j ;\n\t}\n\trep(i, 1, n) {\n\t\trep(j, 0, 25) f[i][j] = f[i - 1][j] ;\n\t\t++ f[i][s[i] - 'a'] ;\n\t}\n\ttop = 1 ;\n\ta[1].cnt = n ;\n\trep(i, 0, 25) a[1].sum[i] = f[n][i] ;\n\ta[0].cnt = n - p[n] ;\n\trep(i, 0, 25) a[0].sum[i] = f[a[0].cnt][i] ;\n\tfor ( ; ; ) {\n\t\t++ top ;\n\t\ta[top].cnt = a[top - 1].cnt + a[top - 2].cnt ;\n\t\trep(i, 0, 25) a[top].sum[i] = a[top - 1].sum[i] + a[top - 2].sum[i] ;\n\t\tif (a[top].cnt > 1e18) break ;\n\t}\n\tll A[26], B[26], l, r ;\n\tscanf(\"%lld%lld\", &l, &r) ;\n\tsolve(top, r, A), solve(top, l - 1, B) ;\n\trep(i, 0, 25) printf(\"%lld \", A[i] - B[i]) ; puts(\"\") ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=5e5+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nchar s[N];\nint len,ch[N][26],nxt[N],T;\nll gao(ll x,int c){\n\tif(x<=len)return ch[x][c];\n\tll n1=ch[len/2][c],n2=ch[T][c],l1=len/2,l2=T;\n\twhile(l1+l2<=x){\n\t\tswap(l1,l2);l1+=l2;\n\t\tswap(n1,n2);n1+=n2;\n\t}return n1+gao(x-l1,c);\n}\nint main(){\n\tscanf(\"%s\",s+1);len=strlen(s+1);\n\trep(i,1,len){\n\t\tre(j,0,26)ch[i][j]=ch[i-1][j];\n\t\tch[i][s[i]-'a']++;\n\t}\n\tll l,r;read(l,r);int j=0;\n\trep(i,2,len){\n\t\twhile(j&&s[j+1]!=s[i])j=nxt[j];\n\t\tif(s[j+1]==s[i])j++;\n\t\tnxt[i]=j;\n\t}\n\tT=nxt[len];while(T>=len/2)T=nxt[T];\n\tT=len/2-T;\n\tre(i,0,26)cout<<gao(r,i)-gao(l-1,i)<<\" \";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nvector<ll> z_algo(string S) {//0-index\n\tll N = S.size();\n\n\tvector<ll> A(N, 0);\n\n\n\tll c = 0;\n\trepn(i, N - 1) {\n\t\tif (c > 0 && i - c + A[i - c] < A[c]) { A[i] = A[i - c]; }\n\t\telse {\n\t\t\tll j = max(0, c + A[c] - i);\n\t\t\twhile (i + j < N && S[j] == S[i + j]) { j++; }\n\t\t\tA[i] = j;\n\t\t\tc = i;\n\t\t}\n\t}\n\n\tA[0] = N;\n\n\treturn A;\n}\n\nll pre(string S) {\n\tll N = S.size();\n\tvll z = z_algo(S);\n\t//rep(j, N)cout << z[j] << \" \";\n\t//cout << endl;\n\n\trepn(i, N) {\n\t\tbool b = 1;\n\t\tfor (ll j = i; j < N; j+=i) {\n\t\t\tif (z[j] < min(N - j, i)) { b = 0; break; }\n\t\t}\n\t\tif (b) { return i; break; }\n\t}\n}\n\nstring S;\nll N;\nll P;\n\nmap<ll, vll> mp;\n\nvll f;\n\nvoid cal(ll l) {\n\t//cout << l << endl;\n\tif (mp.count(l)) { return; }\n\n\tif (N % P == 0) {\n\t\tll k = l / P;\n\t\tvll v = mp[P];\n\t\trep(j, 26) { v[j] *= k; }\n\t\tmp[l] = v;\n\t\treturn;\n\t}\n\n\tauto itr = lower_bound(f.begin(), f.end(), l);\n\tll x = distance(f.begin(), itr) - 1;\n\t//cout << x<<\" \"<<f[x] << endl;\n\t\n\tcal(f[x]);\n\tcal(l - f[x]);\n\n\tvll ret(26, 0);\n\trep(j, 26) {\n\t\tret[j] = mp[f[x]][j] + mp[l - f[x]][j];\n\t}\n\tmp[l] = ret;\n\treturn;\n}\n\nint main(){\n\tll l, r;\n\tcin >> S >> l >> r;\n\tll M = S.size();\n\tvll d = z_algo(S);\n\tN = M;\n\trepn(i, M - 1) {\n\t\tif (i * 2 >= M && d[i] >= M - i) { N = i; break; }\n\t}\n\tS = S.substr(0, N);\n\t//cout << S << endl;\n\n\tP = pre(S);\n\t//cout << N<<\" \"<<P << endl;\n\t\n\tvll c(26, 0);\n\tmp[0] = c;\n\trepn(i, N) {\n\t\tc[S[i - 1] - 'a']++;\n\t\tmp[i] = c;\n\t}\n\n\tf.assign(3, 0);\n\tf[0] = N;\n\tf[1] = N + P;\n\tf[2] = N * 2 + P;\n\tll X = 3;\n\twhile (1) {\n\t\tf.push_back(f[X - 1] - f[X - 3] + f[X - 1]);\n\t\tif (f[X] > INF || X > 500) { break; }\n\t\tassert(N% P == 0 || X < 400);\n\t\t//cout << f[X] << endl;\n\t\tX++;\n\t}\n\n\tcal(r);\n\tcal(l - 1);\n\trep(j, 26) {\n\t\tcout << mp[r][j] - mp[l - 1][j] << \" \";\n\t}\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n//f[i] = f[i-1]+f[i-2]\n//or f[i] = f[i-1]+s\nchar s1[200005], s2[400005], s3[800005], s4[1600005];\nlong long len[105];\nlong long all[105][30];\nlong long cnt[30];\nlong long before[30],after[30];\nint next[1600005];\n\n\nvoid exKmp(char s[],int n,int next[]){\n    int l = 0, r = 0;\n    for(int i = 2; i <= n; i++){\n        if(i>r){\n            l = i, r = i-1;\n            while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n            next[i] = r-l+1;\n        }\n        else{\n            int k = i-l+1;\n            if(i+next[k]-1<r) next[i] = next[k];\n            else{\n                l = i;\n                while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n                next[i] = r-l+1;\n            }\n        }\n    }\n}\n//return new size\nint getNextString(char s[],char t[],int n){\n    exKmp(s,n,next);\n    //for(int i = 1; i <= n; i++) printf(\"next[%d] = %d\\n\",i,next[i]);\n    int find = n+1;\n    for(int i = n/2+2; i <= n; i++){\n        if(next[i]==(n-i+1)){\n            find = i;\n            break;\n        }\n    }\n    int size = 0;\n    for(int rnd = 0; rnd < 2; rnd++){\n        for(int i = 1; i <= find-1; i++) t[++size] = s[i];\n    }\n    t[size+1] = '\\0';\n    return size;\n}\n\nvoid getRegular(long long cycle,long long n,long long upper,long long keep[]){\n    if(upper<=n){\n        for(int i = 1; i <= 26; i++) keep[i] = 0;\n        for(int i = 1; i <= upper; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        for(int i = 1; i <= 26; i++) cnt[i] = 0;\n        for(int i = 1; i <= cycle; i++){\n            int u = s1[i]-'a'+1;\n            cnt[u]++;\n        }\n        long long time = (upper-n)/cycle;\n        long long left = (upper-n)-time*cycle;\n        for(int i = 1; i <= 26; i++) keep[i] = time*cnt[i];\n        for(int i = 1; i <= left; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n        for(int i = 1; i <= n; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n}\n\nvoid getFib(long long upper,long long keep[]){\n    //printf(\"upper = %lld\\n\",upper);\n    if(upper<=len[4]){\n        for(int i = 1; i <= upper; i++){\n            int u = s4[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        int p = 1;\n        while(len[p]<upper) p++;\n        int last = p-1;\n        for(int i = 1; i <= 26; i++) keep[i] += all[last][i];\n        upper -= len[last];\n        getFib(upper,keep);\n    }\n}\n\nint main(){\n    scanf(\"%s\",s1+1);\n    long long l,r;\n    scanf(\"%lld%lld\",&l,&r);\n    int size1 = strlen(s1+1);\n    int size2 = getNextString(s1,s2,size1);\n    int size3 = getNextString(s2,s3,size2);\n    int size4 = getNextString(s3,s4,size3);\n    //printf(\"size1 = %d, size2 = %d, size3 = %d, size4 = %d\\n\",size1,size2,size3,size4);\n    //printf(\"%s\\n%s\\n%s\\n%s\\n\",s1+1,s2+1,s3+1,s4+1);\n    if((size2-size1)==(size3-size2) && (size4-size3)==(size3-size2)){\n        int cycle = size2-size1;\n        getRegular(cycle,size1,l-1,before);\n        getRegular(cycle,size1,r,after);\n    }\n    else{\n        len[1] = size1, len[2] = size2, len[3] = size3, len[4] = size4;\n        for(int i = 1; i <= size1; i++){\n            int u = s1[i]-'a'+1;\n            all[1][u]++;\n        }\n        for(int i = 1; i <= size2; i++){\n            int u = s2[i]-'a'+1;\n            all[2][u]++;\n        }\n        for(int i = 1; i <= size3; i++){\n            int u = s3[i]-'a'+1;\n            all[3][u]++;\n        }\n        for(int i = 1; i <= size4; i++){\n            int u = s4[i]-'a'+1;\n            all[4][u]++;\n        }\n        for(int i = 5; ; i++){\n            len[i] = len[i-1]+len[i-2];\n            for(int j = 1; j <= 26; j++) all[i][j] = all[i-1][j]+all[i-2][j];\n            if(len[i]>=r) break;\n            //printf(\"len[%d] = %lld\\n\",i,len[i]);\n            //for(int j = 1; j <= 26; j++) printf(\"%lld \",all[i][j]);\n            //printf(\"\\n\");\n        }\n        getFib(l-1,before);\n        getFib(r,after);\n    }\n    /*for(int i = 1; i <= 26; i++) printf(\"%lld \",before[i]);\n    printf(\"\\n\");\n    for(int i = 1; i <= 26; i++) printf(\"%lld \",after[i]);\n    printf(\"\\n\");*/\n    for(int i = 1; i <= 26; i++) printf(\"%lld \",after[i]-before[i]);\n    printf(\"\\n\");\n    return 0;\n}\n/*\nedeed\n20 20\nedeed\nedeede\nedeededeed\nedeededeedeedede\nedeededeedeededeededeedeed\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pi acos(-1)\n#define inf 1e18\nusing namespace std;\nconst int N=200050;\ninline ll rd(){\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn f?x:-x;\n}char str[N];int nxt[N],n,m,tot,top;\nll len[1005],nt[1005],cnt[1005][27],ct2[1005][27],o[27],ans[27];\ninline void kmp(){\n\tint j=0;\n\tfor(int i=2;i<=n;i++){\n\t\twhile(j&&str[j+1]!=str[i]) j=nxt[j];\n\t\tif(str[j+1]==str[i]) j++;\n\t\tnxt[i]=j;\n\t}\n}\ninline void work(ll n,int f){\n\tfor(int i=top;i>=1;i--){\n\t\tif(n>=len[i]){\n\t\t\tfor(int j=0;j<26;j++) ans[j]+=f*(cnt[i][j]*2+ct2[i][j]);\n\t\t\tn-=len[i];\n\t\t}\n\t}\n\tif(n>=len[0]){\n\t\tfor(int j=0;j<26;j++) ans[j]+=f*o[j];\n\t\tn-=len[0];\n\t}for(int i=1;i<=n;i++) ans[str[i]-'a']+=f;\n}\ninline void solve(ll n,int f){\n\tfor(int i=0;i<26;i++) ans[i]+=1ll*f*(n/tot)*o[i];\n\tn%=tot;\n\tfor(int i=1;i<=n;i++) ans[str[i]-'a']+=f; \n}\nint main(){\n\tscanf(\"%s\",str+1);n=strlen(str+1);n/=2;\n\tkmp();ll l=rd(),r=rd();\n\tif(n%(n-nxt[n])){\n\t\tfor(int i=1;i<=nxt[n];i++) cnt[0][str[i]-'a']++;\n\t\tfor(int i=nxt[n]+1;i<=n-nxt[n];i++) ct2[0][str[i]-'a']++; \n\t\tfor(int i=1;i<=n;i++) o[str[i]-'a']++;\n\t\tlen[0]=n;nt[0]=nxt[n];\n\t\tif(nxt[n]>=(n+1)/2){\n\t\t\ttop++;\n\t\t\tlen[top]=len[top-1]*2-nt[top-1];\n\t\t\tnt[top]=len[top-1]-nt[top-1];\n\t\t\tfor(int i=1;i<=nt[top];i++){\n\t\t\t\tcnt[top][str[i]-'a']++;\n\t\t\t}\n\t\t\tfor(int i=n-nxt[n]+1;i<=n;i++){\n\t\t\t\tct2[top][str[i]-'a']++; \n\t\t\t} \n\t\t} \n\t\twhile(len[top]<inf){\n\t\t\ttop++;\n\t\t\tlen[top]=len[top-1]*2-nt[top-1];\n\t\t\tnt[top]=len[top-1]-nt[top-1];\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tcnt[top][i]=cnt[top-1][i]+ct2[top-1][i];\n\t\t\t\tct2[top][i]=cnt[top-1][i];\n\t\t\t}\n\t\t}\n\t\twork(r,1);work(l-1,-1);\n\t}\n\telse{\n\t\ttot=n-nxt[n];\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\to[str[i]-'a']++;\n\t\t}solve(r,1);solve(l-1,-1);\n\t}\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,sz[105],cnt[105][26],ans[26];\nint nxt[200005],a[200005];\nchar s[200005];\nvoid query(ll now,ll c)\n{\n\t//printf(\"query(%lld,%lld)\\n\",now,c);\n\tif(now<=n)\n\t{\n\t\tfor(int i=1;i<=now;i++) ans[a[i]]+=c;\n\t\treturn;\n\t}\n\tint i=1;\n\twhile(sz[i]<=now&&sz[i]>0) i++;\n\tfor(int j=0;j<26;j++) ans[j]+=cnt[i-1][j]*c;\n\tquery(now-sz[i-1],c);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++) a[i]=s[i]-'a';\n\tn/=2;\n\tfor(int i=2,j=0;i<=n;i++)\n\t{\n\t\twhile(j&&a[j+1]!=a[i]) j=nxt[j];\n\t\tif(a[i]==a[j+1]) j++;\n\t\tnxt[i]=j;\n\t\t//printf(\"nxt[%d]=%d\\n\",i,j);\n\t}\n\tsz[0]=n,sz[1]=n+n-nxt[n];\n\t//printf(\"%lld %lld\\n\",sz[0],sz[1]);\n\tfor(int i=1;i<=n;i++) cnt[0][a[i]]++,cnt[1][a[i]]++;\n\tfor(int i=1;i<=n-nxt[n];i++) cnt[1][a[i]]++;\n\tfor(int i=2;i<=100;i++)\n\t{\n\t\tsz[i]=sz[i-1]+sz[i-2];\n\t\t//printf(\"sz[%d]=%lld\\n\",i,sz[i]);\n\t\tfor(int j=0;j<26;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n\tll l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tquery(r,1);\n\tquery(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\ntypedef long long LL;\n\nstatic const int MAXS = 100000 + 10;\nLL w[MAXS][26];\n\nLL fib(int id, LL order ,int n, int k) {\n    if (order <= n) return w[order][id];\n    if (order <= 2*n) return w[n][id] + w[order-n][id];\n    LL f1 = w[n][id];\n    LL f2 = w[n][id] + w[k][id];\n    LL x1 = n;\n    LL x2 = n + k;\n    while (x1 + x2 < order) {\n        LL tmp = f2;\n        f2 = f2 + f1;\n        f1 = tmp;\n        tmp = x2;\n        x2 = x1 + x2;\n        x1 = tmp;\n    }\n    return f2 + fib(id, order - x2, n, k);\n\n}\n\n\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int n = s.size() >> 1;\n    LL left, right;\n    cin >> left >> right;\n    memset(w, 0, sizeof(w));\n    int k = 1;\n    while (true) {\n        bool fail = false;\n        for (int i = 0; i < n-k; i++) {\n            if (s[i] != s[i+k]) {\n                fail = true;\n                break;\n            }\n        }\n        if (fail) k++;\n        else break;\n    }\n    for (int i = 1; i <= n; i++) {\n        w[i][s[i-1]-'a']++;\n        for (int j = 0; j < 26; j++) {\n            w[i][j] += w[i-1][j];\n        }\n    }\n    for (int i = 0; i < 26; i++) {\n        cout << fib(i, right, n, k) - fib(i, left-1, n, k);\n        if (i != 25) cout << ' ';\n    }\n    cout << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nconst int M = 110;\n\ntypedef long long LL;\n\nchar S[N];\nint n, f[N];\n\nstruct Info{\n\tLL cnt[26];\n\n\tInfo(){\n\t\tmemset(cnt, 0, sizeof cnt);\n\t}\n\n\tvoid operator = (const Info& A){\n\t\tFor(i, 0, 25) cnt[i] = A.cnt[i];\n\t}\n\n\tInfo operator + (const Info& A) const{\n\t\tInfo ret;\n\t\tFor(i, 0, 25) ret.cnt[i] = A.cnt[i] + cnt[i];\n\t\treturn ret;\n\t}\n\n\tInfo operator - (const Info& A) const{\n\t\tInfo ret;\n\t\tFor(i, 0, 25) ret.cnt[i] = cnt[i] - A.cnt[i];\n\t\treturn ret;\n\t}\n\n}A[M];\n\nLL len[M];\n\nInfo work(int x, LL r){\n\tif(x <= 2){\n\t\tInfo ret;\n\t\tFor(i, 1, r) ret.cnt[S[i] - 'a']++;\n\t\treturn ret;\n\t}\n\tif(r < len[x - 1]) return work(x - 1, r);\n\telse return A[x - 1] + work(x - 1, r - len[x - 1]);\n}\n\nInfo calc(LL r){\n\tif(r <= n) return work(1, r);\n\tint i = 1;\n\twhile(len[i] * 2 < r) ++i;\n\treturn A[i] + work(i, r - len[i]);\n}\n\nint main(){\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\n\tf[1] = 0;\n\tFor(i, 2, n){\n\t\tint p = f[i - 1];\n\t\twhile(p && S[p + 1] != S[i]) p = f[p];\n\t\tf[i] = S[p + 1] == S[i] ? p + 1 : 0;\n\t}\n//\tprintf(\"period = %d\\n\", n - f[n]);\n\n\tFor(i, 1, n) A[1].cnt[S[i] - 'a']++;\n\tlen[1] = n;\n\tFor(i, 1, n + n - f[n]) A[2].cnt[S[i] - 'a']++;\n\tlen[2] = n + n - f[n];\n\tFor(i, 3, 100) len[i] = len[i - 1] + len[i - 2], A[i] = A[i - 1] + A[i - 2];\n\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tInfo ans = calc(r) - calc(l - 1);\n\tFor(i, 0, 25) printf(\"%lld%c\", ans.cnt[i], i == 25 ? '\\n' : ' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nvector<Int> zalgorithm(string s){\n  Int n=s.size();\n  vector<Int> a(n,0);\n  a[0]=n;\n  Int i=1,j=0;\n  while(i<n){\n    while(i+j<n&&s[j]==s[i+j]) j++;\n    a[i]=j;\n    if(j==0){\n      i++;\n      continue;\n    }\n    Int k=1;\n    while(i+k<n&&k+a[k]<j) a[i+k]=a[k],k++;\n    i+=k;\n    j-=k;\n  }\n  return a;\n}\n\n//INSERT ABOVE HERE\nusing vint = vector<Int>;\nvoid print(const vint &v){\n  for(Int i=0;i<(Int)v.size();i++){\n    if(i) cout<<\" \";\n    cout<<v[i];\n  }\n  cout<<endl;\n}\n\nvint add(const vint &a,const vint &b){\n  vint c(26,0);\n  for(Int i=0;i<26;i++) c[i]=a[i]+b[i];\n  return c;\n}\nvint sub(const vint &a,const vint &b){\n  vint c(26,0);\n  for(Int i=0;i<26;i++) c[i]=a[i]-b[i];\n  return c;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  Int l,r;\n  cin>>l>>r;\n  l--;\n  {\n    string t(s);\n    t.erase(unique(t.begin(),t.end()),t.end());\n    if(t.size()==1u){\n      vint ans(26,0);\n      ans[t[0]-'a']=r-l;\n      print(ans);\n      return 0;\n    }\n  }\n  \n  Int n=s.size(),k=n/2+1;\n  vector<Int> z=zalgorithm(s);\n  while(k<n&&k+z[k]<n) k++;\n  \n  vector<Int> x;\n  x.emplace_back(n);\n  x.emplace_back(k*2);\n  for(Int i=0;x.back()<=r;i++)\n    x.emplace_back(Int(x[i]+x[i+1]));\n\n  vector<vint> a(n+1,vint(26,0));\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<26;j++)\n      a[i+1][j]=a[i][j]+(s[i]=='a'+j);\n  \n  using P = pair<Int, Int>;\n  map<P, vint> dp;\n  function<vint(Int, Int)> dfs=\n    [&](Int l,Int r){\n      if(dp.count(P(l,r))) return dp[P(l,r)];\n      vint &res=dp[P(l,r)];\n      if(r<=n) return res=sub(a[r],a[l]);\n      Int p=0;\n      while(r>x[p]) p++;\n      Int y=x[p]/2;\n      if(y<=l) return res=dfs(l-y,r-y);\n      return res=add(dfs(l,y),dfs(0,r-y));\n    };\n  \n  print(dfs(l,r));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 2*1e5+10;\n\nstring s;\nll l,r,len[maxn],cnt[100][maxn],ans[30];\nint KMP[maxn];\n\nint pre_calc(string s, int type) {\n    memset(KMP,0,sizeof(KMP));\n    //cout<<s<<endl;\n    int n= s.length();\n    for (int i=0;i<n;i++) {\n        if (i==0) KMP[i]=-1;\n        else {\n            KMP[i] = KMP[i-1];\n            while (1) {\n                //cout<<i<<\" \"<<KMP[i]<<endl;\n                if (s[KMP[i]+1] == s[i]) {\n                    KMP[i]++;\n                    break;\n                }\n                if (KMP[i]==-1) break;\n                KMP[i] = KMP[KMP[i]];\n            }\n        }\n    }\n    //cout<<\"fuk\"<<endl;\n    int tmp = KMP[n-1];\n    //cout<<tmp<<endl;\n    if (type==1) while (tmp*2+2>=n) tmp=KMP[tmp];\n    else while (tmp*2+2>n) tmp=KMP[tmp];\n    return tmp+1;\n}\n\nvoid calc(ll LEN,ll coe) {\n    int T1 = pre_calc(s,1);\n    string s2 = \"\";\n    for (int i=0;i<s.length()-T1;i++) s2+=s[i];\n    int T2 = pre_calc(s2,2);\n    int sz=0;\n    //cout<<T1<<\" \"<<T2<<endl;\n    for (int i=T2;i<s2.length()-T2;i++) {\n        len[sz]++;\n        cnt[sz][s2[i]-'a']++;\n    }\n    sz++;\n    for (int i=0;i<T2;i++) {\n        len[sz]++;\n        cnt[sz][s2[i]-'a']++;\n    }\n    sz++;\n    while (len[sz-1]<=LEN) {\n        len[sz] = len[sz-1] + len[sz-2];\n        for (int i=0;i<26;i++) cnt[sz][i] = cnt[sz-1][i] + cnt[sz-2][i];\n        sz++;\n        ///cout<<len[sz-1]<<endl;\n    }\n    for (int i=sz-1;i>=2;i--) {\n        if (LEN>=len[i]) {\n            LEN-=len[i];\n            for (int j=0;j<26;j++) ans[j]+= coe*cnt[i][j];\n        }\n    }\n    for (int i=0;i<LEN;i++) ans[s[i]-'a']+=coe;\n\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>s;\n    cin>>l>>r;\n    calc(r,1);\n    calc(l-1,-1);\n    for (int i=0;i<26;i++) cout<<ans[i]<<\" \";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nvector< int > z_algorithm(const string &s) {\n  vector< int > prefix(s.size());\n  for(int i = 1, j = 0; i < s.size(); i++) {\n    if(i + prefix[i - j] < j + prefix[j]) {\n      prefix[i] = prefix[i - j];\n    } else {\n      int k = max(0, j + prefix[j] - i);\n      while(i + k < s.size() && s[k] == s[i + k]) ++k;\n      prefix[i] = k;\n      j = i;\n    }\n  }\n  prefix[0] = (int) s.size();\n  return prefix;\n}\nstring s, s1;\nint n, m;\nvector<int> v;\nint main()\n{\n  cin>>s;\n  n=s.size()/2;\n  s1=s.substr(0, n);\n  ll l, r;\n  cin>>l>>r;\n  l--;\n  v=z_algorithm(s1);\n  int d=0;\n  for(int k=1; k<n; k++){\n    if(n%k!=0) continue;\n    if(v[k]==n-k){\n      d=k;\n      break;\n    }\n  }\n  for(int i=1; i<n; i++){\n    if(v[i]==n-i){\n      m=i; break;\n    }\n  }\n  if(m==0) d=n;\n  if(d){\n    ll cnt[26]={};\n    for(int i=0; i<d; i++){\n      cnt[s[i]-'a']+=(r-1-i+d)/d;\n      cnt[s[i]-'a']-=(l-1-i+d)/d;\n    }\n    for(int i=0; i<26; i++){\n      cout<<cnt[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n  }\n  ll cnt[26]={};\n  ll xl[100];\n  xl[0]=n-m, xl[1]=m;\n  ll xc[100][26]={};\n  for(int i=0; i<n; i++){\n    if(i<m) xc[1][s[i]-'a']++;\n    else xc[0][s[i]-'a']++;\n  }\n  int c=2;\n  const ll MAX=1e18;\n  for(int i=2; i<100; i++){\n    if(xl[i-1]>MAX){\n      c=i; break;\n    }\n    xl[i]=xl[i-1]+xl[i-2];\n    for(int j=0; j<26; j++){\n      xc[i][j]=xc[i-1][j]+xc[i-2][j];\n    }\n  }\n  auto solve=[&](auto solve, ll k, bool myon)->void{\n    if(k<=n){\n      for(int i=0; i<k; i++){\n        if(myon) cnt[s[i]-'a']++;\n        else cnt[s[i]-'a']--;\n      }\n      return;\n    }\n    int t=upper_bound(xl+2, xl+c, k)-xl-1;\n    for(int i=0; i<26; i++){\n      if(myon) cnt[i]+=xc[t][i];\n      else cnt[i]-=xc[t][i];\n    }\n    solve(solve, k-xl[t], myon);\n  };\n  solve(solve, r, 1);\n  solve(solve, l, 0);\n  for(int i=0; i<26; i++){\n    cout<<cnt[i]<<\" \";\n  }\n  cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[100][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\t/*rep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,100) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\trep(i,1,m) if(g[i][26]>=r) {m=i;break;}\n\t\tdwn(j,m-1,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m-1,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;*/\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 200005\nusing namespace std;\n//ifstream cin(\"date.in\");\n//ofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    for(i = 1; i <= n; i++){\n        if(i <= n / 2 + n % 2){\n            a[i] = s[i];\n        }\n        else{\n            a[i + 1] = s[i];\n        }\n    }\n    a[n / 2 + n % 2 + 1] = '*';\n    for(i = 2; i <= n + 1; i++){\n        while(L > 0 && a[i] != a[L + 1]){\n            L = p[L];\n        }\n        if(a[i] == a[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    n = n - p[n + 1];\n    L = 0;\n    for(i = 2; i <= n; i++){\n        while(L > 0 && s[i] != s[L + 1]){\n            L++;\n        }\n        if(s[i] == s[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    for(i = 1; i <= n; i++){\n        ok = 1;\n        for(j = i + i; j <= n; j += i){\n            if(p[j] != j - i){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(j = j - i + 1; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\n\nusing namespace std;\n\nconst int maxn=2e5+5;\n\nll a[maxn][28];\nll i,j,k,l,r,x,y,n,t;\nchar s[maxn];\nint ne[maxn];\nbool bz;\n\nvoid ge_border(){\n\tfo(i,2,n){\n\t\twhile (j && s[j+1]!=s[i]) j=ne[j];\n\t\tif (s[j+1]==s[i]) j++;\n\t\tne[i]=j;\n\t}\n\tt=n-ne[n];\n\tif (n%t==0) bz=true;\n}\nll calc(ll x,int c){\n\tif (x<=n) return a[x][c];\n\tif (x<=2*n) return a[n][c]+a[x-n][c];\n\tll t1=n,t2=n+t,an1=a[n][c],an2=an1+a[t][c],t3,an3;\n\twhile (t1+t2<=x){\n\t\tt3=t2; t2=t1+t2; t1=t3;\n\t\tan3=an2; an2=an1+an2; an1=an3;\n\t}\n\treturn an2+calc(x-t2,c);\n}\nll ge_ans(ll x,int c){\n\tif (x<=n) return a[x][c];\n\tif (bz){\n\t\tx=x-n; ll ans=a[n][c];\n\t\tans=ans+(x/t)*a[t][c]+a[x%t][c];\n\t\treturn ans; \n\t}\n\treturn calc(x,c);\n}\nint main(){\n//\tfreopen(\"077f.in\",\"r\",stdin);\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\tn=strlen(s+1)/2;\n\tge_border();\n\tfo(i,1,n){\n\t\tfo(j,1,26) a[i][j]=a[i-1][j];\n\t\ta[i][s[i]-96]++;\n\t}\n\tfo(j,1,26) printf(\"%lld \",-ge_ans(l-1,j)+ge_ans(r,j));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N=2e5+10;\n\nLL l,r,ans[26],g[110],sum[N][26],sm[N][26];\nint len,plen,nxt[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n}\n\nvoid Getnext(char *s,int len) {\n\tnxt[0]=0;nxt[1]=0;\n\tfor (int i=1,k=0;i<len;++i) {\n\t\twhile (k && s[i]!=s[k]) k=nxt[k];\n\t\twhile (s[i]==s[k]) ++k;\n\t\tnxt[i+1]=k;\n\t}\n}\n\nvoid Calc(int dep,LL *ans,LL pos,int op) {\n\tif (pos==g[dep]) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sm[dep][j];\n\t\treturn ;\n\t}\n\tif (dep==0 || dep==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sum[pos][j];\n\t\treturn ;\n\t}\n\tif (pos>g[dep-1]) {\n\t\tCalc(dep-1,ans,g[dep-1],op);\n\t\tCalc(dep-2,ans,pos-g[dep-1],op);\n\t}else Calc(dep-1,ans,pos,op);\n}\n\nvoid Solve() {\n\tlen=strlen(s);len/=2;\n\tGetnext(s,len);\n\tfor (int i=1;i<=len;++i) {\n\t\tfor (int j=0;j<26;++j) sum[i][j]=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tplen=len-nxt[len];\n\tg[0]=plen; for (int j=0;j<26;++j) sm[0][j]=sum[plen][j];\n\tg[1]=len; for (int j=0;j<26;++j) sm[1][j]=sum[len][j];\n\tfor (int i=2;i<=100;++i) {\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tfor (int j=0;j<26;++j) sm[i][j]=sm[i-1][j]+sm[i-2][j];\n\t}\n\t\n\tfor (int i=0;i<=100;++i) \n\t\tif (g[i]>=r) { Calc(i,ans,r,1); break; }\n\tfor (int i=0;i<=100;++i) \n\t\tif (g[i]>=l) { Calc(i,ans,l-1,-1); break; }\n\t\t\n\tfor (int i=0;i<26;++i) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 201000;\nchar str[N];\nint f[26][N], n;\nint nxt[N], t;\n\nll calc(int*a, ll p) {\n\tif(p <= n) return a[p];\n\tif(p <= (n<<1)) return a[n] + a[p-n];\n\tll t0 = n, t1 = n + t;\n\tll r0 = a[n], r1 = a[n] + a[t];\n\twhile(t0 + t1 <= p) {\n\t\tt0 += t1, r0 += r1;\n\t\tswap(t0, t1), swap(r0, r1);\n\t}\n\treturn r1 + calc(a, p - t1);\n}\n\nbool fac;\n\nll work(int*a, ll p) {\n\tif(p <= n) return a[p];\n\tif(p <= (n<<1)) return a[n] + a[p-n];\n\tif(fac) {\n\t\tp -= n;\n\t\treturn a[n] + (p/t) * a[t] + a[p%t];\n\t}\n\treturn calc(a, p);\n}\n\nint main() {\n\tscanf(\"%s\", str+1);\n\tn = strlen(str+1) >> 1;\n\tfor(int i=0;i<26;++i) {\n\t\tint*arr = f[i];\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tarr[j] = arr[j-1] + (str[j] == (i+'a'));\n\t}\n\t\n\tfor(int i=2,k=0;i<=n;++i) {\n\t\twhile(k and str[k+1] != str[i]) k = nxt[k];\n\t\tif(str[k+1] == str[i]) ++k;\n\t\tnxt[i] = k;\n\t}\n\t\n\tt = n - nxt[n];\n\tfac = (n%t == 0);\n\t\n\tll l, r; scanf(\"%lld%lld\",&l,&r);\n\tfor(int i=0;i<26;++i)\n\t\tprintf(\"%lld \", work(f[i], r) - work(f[i], l-1));\n\tputchar(10);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int MAXN=3e5+5;\n\nint len,anc[30][MAXN],S,T,num,p[MAXN];\nll l,r;\nchar s[MAXN];\n\nll calc(ll lt,int n){\n\tif(lt<=len)return anc[n][lt];\n\tif(lt<=2*len)return anc[n][len]+anc[n][lt-len];\n\tll f1=anc[n][S],f2=anc[n][len],lenf1=S,lenf2=len;\n\twhile(lt>lenf1+lenf2){\n\t\tll tem2=f2,lentem2=lenf2;\n\t\tf2+=f1;lenf2+=lenf1;\n\t\tf1=tem2;lenf1=lentem2;\n\t}\n\treturn f2+calc(lt-lenf2,n);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\tlen=strlen(s+1)/2;\n\tbool ok=0;\n\tfor(int i=2*len;;i--){\n\t\tint tmp=i;num=1;\n\t\twhile(s[num]==s[tmp]){\n\t\t\tnum++;tmp++;\n\t\t\tif(tmp==2*len+1){\n\t\t\t\tok=1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t}\n\t\tif(ok){num--;break;}\n\t}\t\n\tT=num;\n\tS=len-num;\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=1;j<=len;j++){\n\t\t\tanc[i][j]=anc[i][j-1];\n\t\t\tif((int)s[j]-96==i)anc[i][j]++;\n\t\t}\n\t}\n//\tcout<<calc(43200,1);\n\tfor(int i=1;i<=26;i++){\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long n, l, r, a[26], hash1[1000009], hash2[1000009], mod = 1000000007, leng; string S; vector<long long>X;\n\nlong long repeated(string V) {\n\tfor (int i = 1; i < n / 2; i++) {\n\t\tif (n%i > 0) continue;\n\t\tstring W = V.substr(0, i); bool flag = false;\n\t\tfor (int j = 0; j < n; j += i) {\n\t\t\tstring WW = V.substr(j, j + i);\n\t\t\tif (W != WW) { flag = true; break; }\n\t\t}\n\t\tif (flag == false) return i;\n\t}\n\treturn -1;\n}\n\nstring naive_solve(string T) {\n\tfor (int i = 0; i <= T.size(); i++) { hash1[i] = 0; hash2[i] = 0; }\n\tlong long U = 1;\n\tfor (int i = 0; i < T.size(); i++) { hash1[i + 1] = hash1[i] + 1LL * U*(long long)(T[i] - 'a'); hash1[i + 1] %= mod; U *= 26; U %= mod; }\n\tfor (int i = T.size() - 1; i >= 0; i--) { hash2[i] = hash2[i + 1] * 26LL + (long long)(T[i] - 'a'); hash2[i] %= mod; }\n\tfor (int i = T.size() / 2 - 1; i >= 0; i--) {\n\t\tif (hash1[i] == hash2[T.size() - i]) return T.substr(0, T.size() - i) + T.substr(0, T.size() - i);\n\t}\n\treturn \"\";\n}\nchar get_s(long long pos) {\n\tif (pos < (long long)S.size()) return S[pos];\n\tint pos1 = upper_bound(X.begin(), X.end(), pos) - X.begin(); pos1--;\n\treturn get_s(pos - X[pos1]);\n}\nlong long solve() {\n\tstring I1 = S.substr(0, n);\n\tstring I2 = \"\";\n\tfor (long long i = leng - n; i < leng; i++) I2 += get_s(i);\n\tfor (int i = 0; i <= n; i++) { hash1[i] = 0; hash2[i] = 0; }\n\tlong long U = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\thash1[i + 1] = hash1[i] + 1LL * U*(long long)(I1[i] - 'a'); hash1[i + 1] %= mod;\n\t\tU *= 26; U %= mod;\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\thash2[i] = hash2[i + 1] * 26LL + (long long)(I2[i] - 'a'); hash2[i] %= mod;\n\t}\n\tfor (int i = n; i >= 0; i--) {\n\t\tif (hash1[i] == hash2[n - i]) return leng - n;\n\t}\n\treturn -1;\n}\n\nlong long p[200009], q[200009];\n\nvoid solve_last(vector<long long>XX) {\n\tp[XX.size() - 1] = 1;\n\tfor (int i = XX.size() - 1; i >= 0; i--) {\n\t\tlong long cx = XX[i];\n\t\twhile (true) {\n\t\t\tlong long pos1 = upper_bound(XX.begin(), XX.end(), cx) - XX.begin(); pos1--;\n\t\t\tif (pos1 >= 0 && XX[pos1] == cx) pos1--;\n\t\t\tif (pos1 < 0) break;\n\t\t\tlong long I = cx / XX[pos1];\n\t\t\tp[pos1] += I*p[i];\n\t\t\tcx -= I*XX[pos1];\n\t\t}\n\t\tq[n] += (cx / n)*p[i];\n\t\tq[cx%n] += p[i];\n\t}\n\tfor (int i = n; i >= 1; i--) q[i] += q[i + 1];\n}\nvector<long long> solve_last2(long long lim) {\n\tfor (int i = 0; i < 200009; i++) { p[i] = 0; q[i] = 0; }\n\tvector<long long>X2;\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] < lim)X2.push_back(X[i]);\n\t}\n\tX2.push_back(lim);\n\tsolve_last(X2);\n\tvector<long long>X3(26, 0);\n\tfor (int i = 1; i <= n; i++) X3[S[i - 1] - 'a'] += q[i];\n\treturn X3;\n}\nvoid init_last() {\n\tvector<long long>Y;\n\tlong long maxn = (1LL << 60);\n\tfor (int i = X.size() - 1; i >= 0; i--) { if (maxn > X[i]) { maxn = X[i]; Y.push_back(maxn); } }\n\treverse(Y.begin(), Y.end());\n\tX = Y;\n}\n\nint main() {\n\tcin >> S >> l >> r; n = S.size();\n\tlong long R = repeated(S);\n\tif (R != -1) {\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tlong long I = (n - i + (R - 1)) / R;\n\t\t\ta[S[i] - 'a'] += I;\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) { if (i)cout << \" \"; cout << a[i]; }cout << endl;\n\t\treturn 0;\n\t}\n\tleng = n;\n\twhile (S.size() < 4 * n) {\n\t\tX.push_back(leng);\n\t\tS = naive_solve(S);\n\t\tleng = S.size();\n\t\tX.push_back(leng / 2); init_last();\n\t}\n\tX.push_back(leng);\n\twhile (leng < r) {\n\t\tlong long E = solve();\n\t\tleng = E * 2;\n\t\tif (leng >= (1LL << 31)) {\n\t\t\tleng += 0;\n\t\t}\n\t\tX.push_back(leng / 2);\n\t\tX.push_back(leng); init_last();\n\t}\n\tinit_last();\n\tvector<long long>R1 = solve_last2(l - 1);\n\tvector<long long>R2 = solve_last2(r);\n\tfor (int i = 0; i < 26; i++) { if (i)cout << \" \"; cout << R2[i] - R1[i]; }cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nstruct rolling_hash {\n    static constexpr int size = 4;\n    static const int32_t prime[size];\n    static int32_t base[size];\n    static struct base_initializer_t {\n        base_initializer_t() {\n            random_device device;\n            default_random_engine gen(device());\n            REP (i, size) {\n                base[i] = uniform_int_distribution<int32_t>(256, prime[i] - 1)(gen);\n            }\n        }\n    } base_initializer;\npublic:\n    array<int32_t, size> data;\n    rolling_hash() : data({}) {}\n    rolling_hash(char c) {\n        REP (i, size) data[i] = c;\n    }\n    void push_back(char c) {\n        REP (i, size) {\n            data[i] = (data[i] *(int64_t) base[i] + c) % prime[i];\n        }\n    }\n    rolling_hash & operator -= (rolling_hash const & other) {\n        REP (i, size) {\n            data[i] -= other.data[i];\n            if (data[i] < 0) data[i] += prime[i];\n        }\n        return *this;\n    }\n    rolling_hash & operator <<= (array<int32_t, size> const & pow_base) {\n        REP (i, size) {\n            data[i] = data[i] *(int64_t) pow_base[i] % prime[i];\n        }\n        return *this;\n    }\n    bool operator == (rolling_hash const & other) const {\n        return equal(ALL(data), other.data.begin());\n    }\n    bool operator != (rolling_hash const & other) const {\n        return not (*this == other);\n    }\n};\nconst int32_t rolling_hash::prime[size] = { 1000000027, 1000000033, 1000000087, 1000000093 };\nint32_t rolling_hash::base[size];\nrolling_hash::base_initializer_t rolling_hash::base_initializer;\n\nstruct rolling_hash_cumulative_sum {\n    rolling_hash_cumulative_sum() = default;\n    int size;\n    vector<rolling_hash> data;\n    vector<array<int32_t, rolling_hash::size> > pow_base;\n    rolling_hash_cumulative_sum(string const & s) {\n        size = s.length();\n        data.resize(size + 1);\n        data[0] = rolling_hash();\n        REP (i, size) {\n            data[i + 1] = data[i];\n            data[i + 1].push_back(s[i]);\n        }\n        pow_base.resize(size + 1);\n        fill(ALL(pow_base[0]), 1);\n        REP (i, size) {\n            REP (j, rolling_hash::size) {\n                pow_base[i + 1][j] = pow_base[i][j] *(int64_t) rolling_hash::base[j] % rolling_hash::prime[j];\n            }\n        }\n    }\n    rolling_hash get_range(int l, int r) {\n        assert (0 <= l and l <= r and r <= size);\n        return rolling_hash(data[r]) -= (rolling_hash(data[l]) <<= pow_base[r - l]);\n    }\n};\n\ntemplate <class Func>\nvoid enumerate_cycles(string const & s, Func func) {\n    rolling_hash_cumulative_sum hash(s);\n    REP3 (cycle, 1, s.length() + 1) {\n        bool is_cycle = true;\n        auto x = hash.get_range(0, cycle);\n        int i = cycle;\n        for (; i + cycle < s.length() and is_cycle; i += cycle) {\n            auto y = hash.get_range(i, i + cycle);\n            if (x != y) is_cycle = false;\n        }\n        if (is_cycle) {\n            auto y = hash.get_range(i, s.length());\n            auto z = hash.get_range(0, s.length() - i);\n            if (y != z) is_cycle = false;\n        }\n        if (is_cycle) {\n            if (not func(cycle)) {\n                return;\n            }\n        }\n    }\n}\n\nstring delta_f(string const & s) {\n    int result_cycle = s.length();\n    int result_delta_length = s.length();\n    enumerate_cycles(s, [&](int cycle) {\n        int a = s.length() / cycle;\n        int b = s.length() % cycle;\n        int delta_length = 0;\n        if (b != 0) {\n            delta_length += cycle - b;\n            a += 1;\n        }\n        if (a % 2 == 1) {\n            delta_length += cycle;\n        }\n        if (delta_length == 0) {\n            delta_length += 2 * cycle;\n        }\n        if (delta_length < result_delta_length) {\n            result_delta_length = delta_length;\n            result_cycle = cycle;\n        }\n        return true;\n    });\n    int cycle = result_cycle;\n    int a = s.length() / cycle;\n    int b = s.length() % cycle;\n    string delta;\n    if (b != 0) {\n        delta += s.substr(b, cycle - b);\n        a += 1;\n    }\n    if (a % 2 == 1) {\n        delta += s.substr(0, cycle);\n    }\n    if (delta.length() == 0) {\n        delta += s.substr(0, cycle);\n        delta += s.substr(0, cycle);\n    }\n    return delta;\n}\n\narray<ll, 26> count_alphabets(string const & s) {\n    array<ll, 26> cnt = {};\n    for (char c : s) cnt[c - 'a'] += 1;\n    return cnt;\n}\narray<ll, 26> operator + (array<ll, 26> const & a, array<ll, 26> const & b) {\n    array<ll, 26> c;\n    REP (i, 26) c[i] = a[i] + b[i];\n    return c;\n}\narray<ll, 26> operator - (array<ll, 26> const & a, array<ll, 26> const & b) {\n    array<ll, 26> c;\n    REP (i, 26) c[i] = a[i] - b[i];\n    return c;\n}\nstring half(string const & s) {\n    assert (s.substr(0, s.length() / 2) == s.substr(s.length() / 2));\n    return s.substr(0, s.length() / 2);\n}\n\nint main() {\n    // input\n    string s; cin >> s;\n    ll l, r; cin >> l >> r; -- l;\n\n    // solve\n    s += delta_f(s);\n    string t = half(s);\n    string gt = half(s + delta_f(s));\n    vector<ll> len(2);\n    len[0] =  t.size();\n    len[1] = gt.size();\n    vector<array<ll, 26> > cnt(2);\n    cnt[0] = count_alphabets( t);\n    cnt[1] = count_alphabets(gt);\n    while (len.back() < 2 * r + 10000) {\n        int i = len.size();\n        len.push_back(len[i - 1] + len[i - 2]);\n        cnt.push_back(cnt[i - 1] + cnt[i - 2]);\n    }\n    function<array<ll, 26> (ll)> func = [&](ll r) {\n        if (r < len[0]) return count_alphabets(t.substr(0, r));\n        int i = 0;\n        while (len[i + 1] < r) ++ i;\n        return cnt[i] + func(r - len[i]);\n    };\n    auto result = func(r) - func(l);\n\n    // output\n    REP (i, 26) {\n        cout << result[i] << ' ';\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define N 200010\n#define lint long long\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\nchar s[N];int nxt[N];\nstruct E{\n\tlint len,cnt[26];E() { len=0,memset(cnt,0,sizeof cnt); }\n\tinline E operator=(const E &e)\n\t{\treturn len=e.len,memcpy(cnt,e.cnt,sizeof cnt),*this;\t}\n\tinline E operator+(const E &e)const\n\t{\n\t\tE res;res=*this;\n\t\tfor(int i=0;i<26;i++) res.cnt[i]+=e.cnt[i];\n\t\treturn res.len+=e.len,res;\n\t}\n\tinline E operator-(const E &e)const\n\t{\n\t\tE res;res=*this;\n\t\tfor(int i=0;i<26;i++) res.cnt[i]-=e.cnt[i];\n\t\treturn res.len-=e.len,res;\n\t}\n\tinline E operator+=(const E &e) { return (*this)=(*this)+e; }\n}a[1010];\ninline int getg(char *s,int n)\n{\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint &j=nxt[i];j=nxt[i-1];\n\t\twhile(j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif(s[j+1]==s[i]) j++;\n\t}\n\treturn n-nxt[n];\n}\ninline E query(lint n,int c)\n{\n\tE ans;\n\tfor(int i=c;i>=1;i--)\n\t\tif(n>=a[i].len) n-=a[i].len,ans+=a[i];\n\tfor(int i=1;i<=n;i++) ans.cnt[s[i]-'a']++;\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);int n=(int)strlen(s+1),c=2;\n\tint k=n/2,g=getg(s,k);lint l,r;cin>>l>>r;\n\tfor(int i=1;i<=k;i++) a[1].cnt[s[i]-'a']++;\n\ta[2]=a[1],a[1].len=k,a[2].len=k+g;\n\tfor(int i=1;i<=g;i++) a[2].cnt[s[i]-'a']++;\n\twhile(a[c-1].len+a[c].len<=r) c++,a[c]=a[c-1]+a[c-2];\n\tE ans=query(r,c);\n\tans=ans-query(l-1,c);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans.cnt[i]);\n\treturn !printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint z[200005];\nlong long l,r,num[200005][26];\nint n,p;\nstring s;\nvoid zfunc()\n{\n\tint l=0,r=0;\n\tmemset(z,0,sizeof(z));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<=r)z[i]=min(z[i-l],r-i+1);\n\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;\n\t\tif(i+z[i]-1>r)\n\t\t{\n\t\t\tl=i;\n\t\t\tr=i+z[i]-1;\n\t\t}\n\t}\n}\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tif(n%p==0)\n\t{\n\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n\t\txx+=num[x%(long long)p][y];\n\t\treturn xx;\n\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size();\n\tn/=2;\n\ts=s.substr(0,n);\n\tzfunc();\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(z[i]+i==n)\n\t\t{\n\t\t\tp=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]=num[i-1][j];\n\t\tnum[i][s[i-1]-'a']++;\n\t}\n//\tcout<<sol(10,0)<<endl;\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0||r<=n){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();while(1);return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=0;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nvector<unsigned long long> x_cnt, y_cnt, pref_x_cnt, pref_y_cnt;\nint suffix[200005];\n\nlong long gcd(long long a, long long b)\n{\n    if (a%b == 0) return b;\n    else return gcd(b,a%b);\n}\n\nint find_suffix(string s)\n{\n    //find length of longest suffix of s that is also a prefix of s\n    suffix[0] = suffix[1] = 0;\n    for (int i=2; i<=s.length(); i++) {\n        int j = suffix[i-1];\n        while (true) {\n            if (s[j] == s[i-1]) {\n                suffix[i] = j+1;\n                break;\n            }\n            else if (j == 0) {\n                suffix[i] = 0;\n                break;\n            }\n            j = suffix[j];\n        }\n    }\n    //printa(suffix,s.length()+1);\n    return suffix[s.length()];\n}\n\nvector<ll> simple_query(string period, ll r, vector<ll> &chr_cnt)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    ll num_periods = r/period.length();\n    ll remain = r % period.length();\n    for0(i,26) {\n        ret[i] = chr_cnt[i]*num_periods;\n    }\n\n    for0(i,remain) {\n        ret[period[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve_simple(string period, ll l, ll r)\n{\n    //prl(period);\n    vector<ll> chr_cnt(26,0);\n    iter(period) {\n        chr_cnt[*it-'a']++;\n    }\n\n    vector<ll> r_cnt = simple_query(period, r, chr_cnt);\n    vector<ll> l_cnt = simple_query(period, l-1, chr_cnt);\n    //printv(r_cnt);\n    //printv(l_cnt);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\npair<ll,ll> explicit_query(ll x, ll y, ll r)\n{\n    //count the number of x's and y's using the pattern explicitly.\n    //This is for testing only since the explicit pattern is too long.\n    ll query_x_cnt = 0, query_y_cnt = 0;\n\n    //construct the pattern\n    vector<ll> pattern = {x,x,y,x,x,y,x,y,x,x,y,x,x,y,x};\n    int lv = 3;\n    while (sz(pattern) < 100000) {\n        lv++;\n        for (int i=pref_x_cnt[lv]+pref_y_cnt[lv]; sz(pattern)<x_cnt[lv]+y_cnt[lv]; i++) {\n            pattern.pb(pattern[i]);\n        }\n    }\n    //printv(pattern)\n\n    int i = 0;\n    while (true) {\n        if (pattern[i] == x) {\n            if (r >= x) {\n                r -= x;\n                query_x_cnt++;\n            }\n            else break;\n        }\n        else {\n            if (r >= y) {\n                r -= y;\n                query_y_cnt++;\n            }\n            else break;\n        }\n        i++;\n    }\n    return mp(query_x_cnt, query_y_cnt);\n}\n\nvector<ll> hard_query(ll x, ll y, ll r, string s)\n{\n    //prl(x) prl(y) prl(r) nl\n    ll rr = r;\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    //count the number of occurrences of x and y in the pattern x,x,y,x,x,y,x,y,x,... (not periodic!)\n    //until the sum is greater than r\n    int lv = 0;\n    while (lv < sz(x_cnt) && x*x_cnt[lv] + y*y_cnt[lv] <= r) {\n        lv++;\n    }\n    assert(lv < sz(x_cnt));\n    int prefix = 0;\n    ll query_x_cnt = 0, query_y_cnt = 0;\n\n    while (lv > 2) {\n        if (x_cnt[lv-1]+y_cnt[lv-1] < pref_x_cnt[prefix]+pref_y_cnt[prefix]) {\n            //not sure why this works...\n            prefix = lv+2;\n        }\n        //prl(lv) prl(r) prl(prefix)\n        //pr(x_cnt[lv-1]+y_cnt[lv-1]) pr(pref_x_cnt[prefix]+pref_y_cnt[prefix]) nl\n        ll num_x_lv = x_cnt[lv-1] - pref_x_cnt[prefix];\n        ll num_y_lv = y_cnt[lv-1] - pref_y_cnt[prefix];\n        ll len = x*num_x_lv + y*num_y_lv;\n        //prl(num_x_lv);\n        //prl(num_y_lv);\n        //prl(len)\n        assert(num_x_lv >= 0 && num_y_lv >= 0);\n        if (len < r) {\n            query_x_cnt += num_x_lv;\n            query_y_cnt += num_y_lv;\n            r -= len;\n            prefix = lv;\n        }\n        lv--;\n        //nl\n    }\n    //prl(query_x_cnt);\n    //prl(query_y_cnt);\n\n    //add the last part using the pattern explicitly\n    vector<ll> pattern = {x,x,y,x,x,y,x,y,x,x,y,x,x,y,x};\n    for (int i=pref_x_cnt[prefix]+pref_y_cnt[prefix]; i<sz(pattern); i++) {\n        //prl(i)\n        if (pattern[i] == x) {\n            if (r >= x) {\n                r -= x;\n                query_x_cnt++;\n            }\n            else {\n                //partial s remaining\n                for (int j=0; r>0; j++) {\n                    ret[s[j]-'a']++;\n                    r--;\n                }\n                break;\n            }\n        }\n        else {\n            if (r >= y) {\n                r -= y;\n                query_y_cnt++;\n            }\n            else {\n                //partial suffix of s remaining\n                for (int j=x-y; r>0; j++) {\n                    ret[s[j]-'a']++;\n                    r--;\n                }\n                break;\n            }\n        }\n    }\n    assert(r == 0);\n    //prl(query_x_cnt);\n    //prl(query_y_cnt);\n\n    /*pair<ll,ll> correct = explicit_query(x, y, rr);\n    assert(query_x_cnt == correct.first);\n    assert(query_y_cnt == correct.second);*/\n    //prp(correct) nl\n\n    //count character frequencies in s and the suffix of s of length y\n    vector<ll> x_chr_cnt(26,0);\n    vector<ll> y_chr_cnt(26,0);\n    for0(i,x) {\n        x_chr_cnt[s[i]-'a']++;\n    }\n    for (int i=x-y; i<x; i++) {\n        y_chr_cnt[s[i]-'a']++;\n    }\n\n    for0(i,26) {\n        ret[i] += query_x_cnt * x_chr_cnt[i];\n        ret[i] += query_y_cnt * y_chr_cnt[i];\n    }\n\n    return ret;\n}\n\nvoid solve_hard(string s, int suffix_len, ll l, ll r)\n{\n    ll x = s.length();\n    ll y = x - suffix_len;\n\n    vector<ll> r_cnt = hard_query(x, y, r, s);\n    vector<ll> l_cnt = hard_query(x, y, l-1, s);\n\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"D.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    string s;\n    cin >> s;\n    s = s.substr(0,s.length()/2);\n    long long l,r;\n    cin >> l >> r;\n\n    int suf_len = find_suffix(s);\n    //prl(suf_len)\n    if (suf_len == 0) {\n        //special case where pattern is periodic with period s\n        solve_simple(s, l, r);\n    }\n    else if (suf_len >= (s.length()+1)/2 && gcd(suf_len,s.length()) > 1) {\n        //special case where s is periodic. Pattern is periodic with period repeated\n        string period = s.substr(0,gcd(suf_len, s.length()));\n        solve_simple(period, l, r);\n    }\n    else if (suf_len == s.length()-1) {\n        //s consists of all 1 character. Again pattern is periodic with that character repeated\n        solve_simple(s.substr(0,1), l, r);\n    }\n    else {\n        //pattern is not periodic. Do some tricky stuff...\n        x_cnt = {2,4};\n        y_cnt = {1,1};\n        while (x_cnt.back() < 1e18) {\n            x_cnt.pb(x_cnt[sz(x_cnt)-1] + x_cnt[sz(x_cnt)-2]);\n            y_cnt.pb(y_cnt[sz(y_cnt)-1] + y_cnt[sz(y_cnt)-2] + 1);\n        }\n        pref_x_cnt = {0,0,0,1,2,3};\n        pref_y_cnt = {0,0,0,0,0,1};\n        while (sz(pref_x_cnt) < sz(x_cnt)) {\n            pref_x_cnt.pb(pref_x_cnt[sz(pref_x_cnt)-1] + pref_x_cnt[sz(pref_x_cnt)-2]);\n            pref_y_cnt.pb(pref_y_cnt[sz(pref_y_cnt)-1] + pref_y_cnt[sz(pref_y_cnt)-2]+1);\n        }\n\n        solve_hard(s, suf_len, l, r);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 5;\n\nchar s[N];\nint fail[N], n, cyc;\nLL l, r, add[27], sub[27], tots[27], tott[27];\nLL tab[90], cnts[90], cntt[90];\n\ninline void solve1() {\n  for (int i = 1; i <= cyc; i ++) add[s[i] - 'a'] ++;\n  for (int i = 0; i < 26; i ++) {\n    sub[i] = add[i] * (l / cyc);\n    add[i] *= r / cyc;\n  }\n  for (int i = 1; i <= l % cyc; i ++) sub[s[i] - 'a'] ++;\n  for (int i = 1; i <= r % cyc; i ++) add[s[i] - 'a'] ++;\n}\n\ninline void dfs(LL x, LL *res) {\n  if (x <= n) {\n    for (int i = 1; i <= x; i ++) res[s[i] - 'a'] ++;\n    return;\n  }\n  int p;\n  for (p = 1; tab[p + 1] <= x; p ++);\n  for (int i = 0; i < 26; i ++) res[i] += cnts[p] * tots[i] + cntt[p] * tott[i];\n  dfs(x - tab[p], res);\n}\n\ninline void solve2() {\n  tab[0] = cyc; tab[1] = n;\n  cnts[1] = 1;\n  cntt[0] = 1;\n  for (int i = 1; tab[i] <= r; i ++) {\n    tab[i + 1] = tab[i] + tab[i - 1];\n    cnts[i + 1] = cnts[i] + cnts[i - 1];\n    cntt[i + 1] = cntt[i] + cntt[i - 1];\n  }\n  for (int i = 1; i <= n; i ++) tots[s[i] - 'a'] ++;\n  for (int i = 1; i <= cyc; i ++) tott[s[i] - 'a'] ++;\n  dfs(l, sub);\n  dfs(r, add);\n}\n\nint main() {\n  scanf(\"%s\", s + 1);\n  scanf(\"%lld%lld\", &l, &r);\n  l --;\n  n = strlen(s + 1) >> 1;\n  for (int i = 2, j = 0; i <= n; i ++) {\n    while (j && s[j + 1] != s[i]) j = fail[j];\n    if (s[i] == s[j + 1]) fail[i] = ++ j;\n    else fail[i] = j;\n  }\n  cyc = n - fail[n];\n  if (n % cyc == 0) solve1();\n  else solve2();\n  LL tot = 0;\n  for (int i = 0; i < 26; i ++) {\n    printf(\"%lld \", add[i] - sub[i]);\n    tot += add[i] - sub[i];\n  }\n  cerr << \"!!!!!!!!!!!!!\" << tot << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nchar s[200005];ll len,slen,tlen,sum[30][200005],nex[200005],l,r;\nll solve(ll now,int n)\n{\n\tif(now<=len) return sum[n][now];\n\tll f1=sum[n][slen],f2=sum[n][len],l1=slen,l2=len,tf,tl;\n\twhile(l1+l2<now) tf=f2,tl=l2,f2+=f1,l2+=l1,f1=tf,l1=tl;\n\treturn f2+solve(now-l2,n);\n}\nmain()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);len=strlen(s+1)/2;\n\tfor(int i=2,j=0;i<=len;i++) \n\t{\n\t\twhile(j&&s[i]!=s[j+1]) j=nex[j];\n\t\tif(s[j+1]==s[i]) nex[i]=++j;\n\t}\n\tslen=len-nex[len];\n\tfor(int i=0;i<26;i++) for(int j=1;j<=len;j++)\n\t{\n\t\tsum[i][j]=sum[i][j-1];\n\t\tif(s[j]-'a'==i) sum[i][j]++;\n\t}\n\tfor(int i=0;i<26;i++) printf(\"%lld \",solve(r,i)-solve(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=200010;\nchar s[N];\nint nxt[N];\nLL l,r;\nLL f[100][27];\nLL sum[100],ans[27];\nint mx=90;\n\nvoid getnext()\n{\n\tint n=strlen(s+1)/2,j=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile(j&&s[i]!=s[j+1]) j=nxt[j];\n\t\tif(s[i]==s[j+1]) j++;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid initfib()\n{\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t\tif(sum[i]>LL(1e18)){mx=i;break;}\n\t}\n}\n\nvoid gao(LL x,int fg)\n{\n\tint p;\n\tfor(p=0;p<=mx;p++)\n\t\tif(sum[p]>x) break;\n\tfor(;p>=0;p--)\n\t\tif(x>=sum[p])\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t\tans[i]+=fg*f[p][i];\n\t\t\tx-=sum[p];\n\t\t}\n\tfor(int i=1;i<=x;i++) ans[s[i]-'a']+=fg;\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n/2;i++)\n\t\tf[0][s[i]-'a']++;\n\tgetnext();\n\tsum[0]=n/2;sum[1]=n-nxt[n/2];\n\tfor(int i=0;i<26;i++) f[1][i]=f[0][i];\n\tfor(int i=1;i<=n/2-nxt[n/2];i++)\n\t\tf[1][s[i]-'a']++;\n\tinitfib();gao(r,1);gao(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nchar s[200010];\nll n,a[200010],cnt[110][26],fib[110],fail[200010],m,b[200010],ans[26],l,r;\nvoid getb(){\n\tll i,j=0;fail[0]=fail[1]=0;\n\tfor(i=1;i<n;i++){\n//\t\tcout<<\"enter kmp \"<<i<<' '<<j<<' '<<a[i]<<' '<<a[j]<<'\\n';\n\t\twhile(a[i]!=a[j]&&j) j=fail[j];\n\t\tj+=(a[i]==a[j]);fail[i+1]=j;\n\t}\n//\tfor(i=0;i<=n;i++) cout<<i<<' '<<fail[i]<<'\\n';\n\tfor(i=0;i<n-fail[n];i++) b[i]=a[i];\n\tm=n-fail[n];\n}\nvoid solve(ll lim,ll type){\n\tll i,j;\n//\tcout<<\"solve \"<<lim<<' '<<type<<'\\n';\n\tif(lim<=n){\n\t\tfor(i=1;i<=lim;i++) ans[a[i]]++;\n\t\treturn;\n\t}\n\tfor(i=1;i<=100;i++){\n\t\tif(fib[i]<=lim) continue;\n\t\tfor(j=0;j<26;j++) ans[j]+=cnt[i-1][j]*type;\n\t\tsolve(lim-fib[i-1],type);break;\n\t}\n}\nvoid add(ll len,ll type){\n\tll i,tot=len/m;\n\tfor(i=1;i<=m;i++) ans[b[i]]+=tot*type;\n\tfor(i=tot*m+1;i<=len;i++) ans[b[i-tot*m]]+=type;\n} \nvoid another(){\n\tadd(l-1,-1);add(r,1);\n}\nint main(){\n\tscanf(\"%s\",s);n=strlen(s)>>1;ll i,j;\n\tl=read();r=read();\n\tfor(i=0;i<n;i++) a[i]=s[i]-'a';\n\tgetb();\n\tfor(i=n;i>=1;i--) a[i]=a[i-1];\n\tfor(i=m;i>=1;i--) b[i]=b[i-1];\n\tif(n%m==0){\n\t\tanother();goto print;\n\t}\n\tfor(i=1;i<=n;i++) cnt[0][a[i]]+=1,cnt[1][a[i]]+=1;\n\tfor(i=1;i<=m;i++) cnt[1][b[i]]+=1;\n\tfib[0]=n;fib[1]=(n+m);\n\tfor(i=2;i<=100;i++){\n\t\tfib[i]=fib[i-1]+fib[i-2];\n\t\tfor(j=0;j<=25;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n//\tfor(i=0;i<26;i++) cout<<i<<' '<<cnt[0][i]<<' '<<cnt[1][i]<<'\\n';\n\tsolve(l-1,-1);\n\tsolve(r,1);\n\tprint:\n\tfor(i=0;i<26;i++) printf(\"%lld \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x) {\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nchar str[N];\nint f[26][N], n;\nint nxt[N], t;\n\nll calc(int*a, ll p) {\n\tif(p <= n) return a[p];\n\tif(p <= (n<<1)) return a[n] + a[p-n];\n\tll t0 = n, t1 = n + t;\n\tll r0 = a[n], r1 = a[n] + a[t];\n\twhile(t0 + t1 <= p) {\n\t\tt0 += t1, r0 += r1;\n\t\tswap(t0, t1), swap(r0, r1);\n\t}\n\treturn r1 + calc(a, p - t1);\n}\n\nbool fac;\n\nll work(int*a, ll p) {\n\tif(p <= n) return a[p];\n\tif(p <= (n<<1)) return a[n] + a[p-n];\n\tif(fac) {\n\t\tp -= n;\n\t\treturn a[n] + (p/t) * a[t] + a[p%t];\n\t}\n\treturn calc(a, p);\n}\n\nint main() {\n\tscanf(\"%s\", str+1);\n\tn = strlen(str+1) >> 1;\n\tfor(int i=0;i<26;++i) {\n\t\tint*arr = f[i];\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tarr[j] = arr[j-1] + (str[j] == (i+'a'));\n\t}\n\t\n\tfor(int i=2,k=0;i<=n;++i) {\n\t\twhile(k and str[k+1] != str[i]) k = nxt[k];\n\t\tif(str[k+1] == str[i]) ++k;\n\t\tnxt[i] = k;\n\t}\n\t\n\tt = n - nxt[n];\n\tfac = (n%t == 0);\n\t\n\tll l, r; scanf(\"%lld%lld\",&l,&r);\n\tfor(int i=0;i<26;++i)\n\t\tprintf(\"%lld \", work(f[i], r) - work(f[i], l-1));\n\tputchar(10);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define all(x) (x).begin(), (x).end()\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 4;\n\nvector<ll> solve(string s, ll n0, ll k0, ll R)\n{\n    vector<ll> ans(26);\n\n    while (R)\n    {\n        if (R <= n0)\n        {\n            for (int i = 0; i < R; i++) ans[s[i] - 'a']++;\n            break;\n        }\n        ll n = n0, k = k0;\n        vector<ll> cnt0(26), cnt1(26);\n        for (int i = 0; i < k; i++) cnt0[s[i] - 'a']++;\n        for (int i = 0; i < n; i++) cnt1[s[i] - 'a']++;\n        while (n + k <= R)\n        {\n            ll m = n + k;\n            vector<ll> cnt2(26);\n            for (int i = 0; i < 26; i++) cnt2[i] = cnt1[i] + cnt0[i];\n            k = n;\n            n = m;\n            cnt0 = cnt1;\n            cnt1 = cnt2;\n        }\n        R -= n;\n        for (int i = 0; i < 26; i++)\n            ans[i] += cnt1[i];\n    }\n\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    string s;\n    cin >> s;\n    {\n        vector<int> z(s.size());\n        int L = 0, R = 0;\n        for (int i = 1; i < s.size(); i++)\n        {\n            z[i] = max(0, min(z[i - L], R - i));\n            while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n            if (i + z[i] > R)\n            {\n                R = i + z[i];\n                L = i;\n            }\n        }\n        int len = s.size();\n        for (int i = s.size() - 1; 2 * i > s.size(); i--)\n        {\n            if (i + z[i] == s.size())\n            {\n                len = i;\n            }\n        }\n        while (s.size() > len) s.pop_back();\n    }\n\n    ll n = s.size();\n    vector<int> z(s.size());\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    ll k = n;\n    for (int i = 1; i < s.size(); i++)\n    {\n        if (i + z[i] == s.size())\n        {\n            k = i;\n            break;\n        }\n    }\n    if (n % k == 0)\n    {\n        vector<ll> cnt(26);\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        ll c = R / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] += c + 1;\n            else cnt[s[i] - 'a'] += c;\n        }\n        c = L / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] -= c + 1;\n            else cnt[s[i] - 'a'] -= c;\n        }\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cnt[i] << \" \";\n        }\n    }\n    else\n    {\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        vector<ll> cntR = solve(s, n, k, R);\n        vector<ll> cntL = solve(s, n, k, L);\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cntR[i] - cntL[i] << \" \";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[100][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\trep(x,0,25) {\n\t\t\tll k=(r-n)/(c-b);if(r<n) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tk=(l-n-1)/(c-b);if(l-1<n) k=0;\n\t\t\tans[x]-=k*cnt[x];\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,100) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\trep(i,1,m) if(g[i][26]>=r) {m=i;break;}\n\t//\tprintf(\"%d\\n\",m);\n\t\tdwn(j,m-1,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m-1,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+10;\nchar s[N];\nll l,r,len,border,sta[N],suf[N],ans[N];\nint n,top,nxt[N];\nvoid query(ll len,int d){\n\tmap<ll,ll> m;\n\tm[-len]=1;\n\tfor (int i=top;i;i--){\n\t\tll T=sta[i];\n\t\tfor (map<ll,ll>::iterator i=m.begin();i!=m.end();++i){\n\t\t\tll len=-i->first,cnt=i->second;\n\t\t\tif (len<=T) continue;\n\t\t\tm[-T]+=cnt*(len/T);\n\t\t\tm[-len%T]+=cnt;\n\t\t}\n\t\twhile (-m.begin()->first>T) m.erase(m.begin());\n\t}\n\tfor (map<ll,ll>::iterator i=m.begin();i!=m.end();++i) suf[-i->first]+=d*i->second;\n}\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=len=sta[top=1]=strlen(s+1);\n\tfor (int i=2;i<=n;i++){\n\t\tint j=nxt[i-1];\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tnxt[i]=(s[j+1]==s[i]?j+1:0);\n\t}\n\tborder=nxt[n/2];\n\twhile (len<r){\n\t\twhile (sta[top]>len-border) top--;\n\t\tsta[++top]=len-border;\n\t\tsta[++top]=2*(len-border);\n\t\tborder=len/2-border;\n\t\tlen=sta[top];\n\t}\n\tquery(r,1);query(l-1,-1);\n\tfor (int i=n;i;i--) suf[i]+=suf[i+1],ans[s[i]]+=suf[i];\n\tfor (int i='a';i<='z';i++) printf(\"%lld \",ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 2000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nstring f1(string s) {\n    rep(i, 0, sz(s)) {\n        string t = s.substr(0, i + 1);\n        t += t;\n        if (sz(t) > sz(s) && t.substr(0, sz(s)) == s) {\n            return t;\n        }\n    }\n    return \"\";\n}\n\nstring f(string s) {\n    repb(i, sz(s) - 1, 0) {\n        if (s.substr(0, i) == s.substr(sz(s) - i)) {\n            return s + s.substr(0, sz(s) - i);\n        }\n    }\n    return \"\";\n}\n\nvoid fff1(string s) {\n    rep(i, 0, 6) {\n        cout << s << endl;\n        s = f1(s);\n    }\n}\n\nvoid ff2(string s) {\n    rep(i, 0, 6) {\n        cout << s << endl;\n        s = f(s);\n    }\n}\n\nvoid prefix_function(string &s, vector<int> &p) {\n    int n = sz(s);\n    rep(i, 0, n) {\n        int c = i - 1;\n        while (c >= 0) {\n            if (s[p[c]] == s[i]) {\n                p[i] = p[c] + 1;\n                break;\n            }\n            c = p[c] - 1;\n        }\n        if (c == -1) {\n            p[i] = 0;\n        }\n    }\n}\n\nvector<ll> solve1(string s, ll x) {\n    vector<ll> res(26, 0);\n    rep(i, 0, sz(s)) {\n        res[s[i] - 'a'] += x / sz(s);\n    }\n    rep(i, 0, x % sz(s)) {\n        res[s[i] - 'a']++;\n    }\n    return res;\n}\n\nvoid solve(string s) {\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve1(s, r), b = solve1(s, l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nstring t1, t2;\nvector<ll> c1(26, 0), c2(26, 0);\nll len[100], cnt1[100], cnt2[100];\nvector<ll> ans;\n\nvoid rec(int p, ll x) {\n    if (p == 0) {\n        rep(i, 0, x) {\n            ans[t1[i] - 'a']++;\n        }\n    } else if (p == 1) {\n        rep(i, 0, x) {\n            ans[t2[i] - 'a']++;\n        }\n    } else {\n        if (x <= len[p - 1]) {\n            rec(p - 1, x);\n        } else {\n            rep(i, 0, 26) {\n                ans[i] += c1[i] * cnt1[p - 1] + c2[i] * cnt2[p - 1];\n            }\n            rec(p - 2, x - len[p - 1]);\n        }\n    }\n}\n\nvector<ll> solve2(string A, int k, string B, ll x) {\n    t1 = \"\"; t2 = \"\";\n    rep(i, 0, k) {\n        t1 += A;\n    }\n    t1 += B;\n    t2 = t1 + A;\n    c1 = vector<ll> (26, 0);\n    c2 = vector<ll> (26, 0);\n    rep(i, 0, sz(t1)) {\n        c1[t1[i] - 'a']++;\n    }\n    rep(i, 0, sz(t2)) {\n        c2[t2[i] - 'a']++;\n    }\n    len[0] = sz(t1);\n    cnt1[0] = 1;\n    len[1] = sz(t2);\n    cnt2[1] = 1;\n    int p = 1;\n    while (len[p] < x) {\n        p++;\n        len[p] = len[p - 1] + len[p - 2];\n        cnt1[p] = cnt1[p - 1] + cnt1[p - 2];\n        cnt2[p] = cnt2[p - 1] + cnt2[p - 2];\n    }\n    ans = vector<ll> (26, 0);\n    rec(p, x);\n    return ans;\n}\n\nvoid solve(string A, int k, string B) {\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve2(A, k, B, r), b = solve2(A, k, B, l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    string s;\n    cin >> s;\n    //fff1(s);\n    //cout << endl;\n    s = f1(s); s = s.substr(sz(s) / 2);\n    //ff2(s);\n    //cout << s << endl;\n    vector<int> p(sz(s));\n    prefix_function(s, p);\n    /*for (int i : p) {\n        cout << i << \" \";\n    }\n    cout << endl;*/\n    int n = sz(s);\n    int per = n - p[n - 1];\n    if (n % per == 0) {\n        solve(s.substr(0, per));\n    } else {\n        solve(s.substr(0, per), n / per, s.substr(0, n % per));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 305;\n\nLL f[maxn][27];char s[maxn];int n,k,pre[maxn];\nLL sum1[maxn],sum2[maxn];\nvoid solve(LL n,int t,LL *c) {\n\tif (n<=0) return ;\n\tif (n<=2) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tc[s[j]-'a']++;\n\t\treturn ;\n\t}\n\tif (f[t][26]==n) {\n\t\tfor (int j=0;j<26;j++)\n\t\t\tc[j]+=f[t][j];\n\t\treturn ;\n\t}\n\tif (f[t-1][26]>=n) solve(n,t-1,c);\n\telse {\n\t\tfor (int j=0;j<26;j++)\n\t\t\tc[j]+=f[t-1][j];\n\t\tsolve(n-f[t-1][26],t-2,c);\n\t}\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc077f.in\",\"r\",stdin);\n\t\tfreopen(\"arc077f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);n=strlen(s+1)>>1;\n\tfor (int i=2;i<=n;i++) {\n\t\tint p=pre[i-1];\n\t\twhile (p&&s[p+1]!=s[i]) p=pre[p];\n\t\tif (s[p+1]==s[i]) pre[i]=p+1;\n\t}\n\tk=n-pre[n];f[1][26]=n;f[2][26]=n+k;\n\tfor (int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tfor (int i=1;i<=n+k;i++) f[2][s[i]-'a']++;\n\tint o=2;\n\tfor (int i=3;;i++) {\n\t\tfor (int j=0;j<=26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\to=i;\n\t\tif (f[i][26]>1e18) break;\n\t}\n\t\n\tLL l,r;scanf(\"%lld %lld\",&l,&r);\n\tsolve(r,o,sum1);solve(l-1,o,sum2);\n\tfor (int i=0;i<26;i++)\n\t\tprintf(\"%lld \",sum1[i]-sum2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//bool valid(Hasher &h, int k){\n//    bool ok = true;\n//    for(int i = 0; i < sz(h.s); i += k){\n//        int l = i;\n//        int r = i+k-1;\n//        r = min(ll(r),sz(h.s)-1);\n//        if(h.range_get(l,r) != h.range_get(0,r-l))\n//            ok = false;\n//    }\n//    return ok;\n//}\n//string f(string s){\n//    vpii ans;\n//    Hasher h(s);\n//    rep(sz,1,sz(s)){\n//        if(valid(h,sz)){\n//            int times = (sz(s)+sz-1)/sz;\n//            if(times*sz == sz(s))\n//                ++times;\n//            if(times % 2)\n//                ++times;\n//            int tot_len = times*sz;\n//            ans.pb({tot_len,sz});\n//        }\n//    }\n//    unique(ans);\n//    int sz = ans[0].Y;\n//    while(sz(s) < ans[0].X){\n//        s += s[sz(s)%sz];\n//    }\n//    return s;\n//}\n//struct String{\n//    ll len;\n//    map<char,ll> cnt;\n//    String(string s){\n//        s = s.substr(sz(s)/2);\n//        len = sz(s);\n//        for(char c : s)\n//            cnt[c]++;\n//    }\n//    String operator+(const String &t)const{\n//        String ans = *this;\n//        ans.len += t.len;\n//        for(auto _ : t.cnt)\n//            ans.cnt[_.X] += _.Y;\n//        return ans;\n//    }\n//    String operator-(const String &t)const{\n//        String ans = *this;\n//        ans.len += t.len;\n//        for(auto _ : t.cnt)\n//            ans.cnt[_.X] -= _.Y;\n//        return ans;\n//    }\n//    friend ostream &operator<<(ostream &stream, String &t){\n//        for(char c = 'a'; c <= 'z'; ++c){\n//            stream << t.cnt[c];\n//            if(c != 'z')\n//                stream << ' ';\n//        }\n//        return stream;\n//    }\n//};\n//String get(string s, ll n){\n//    vector<String> arr;\n//    arr.pb(String(s));\n//    arr.pb(String(f(s)));\n//    while(arr.back().len < n){\n//        arr.pb(arr[sz(arr)-1]+arr[sz(arr)-2]);\n//    }\n//    String ans(\"\");\n//    for(int i = sz(arr)-1; i >= 1; --i){\n//        while(n >= arr[i].len){\n//            ans = ans+arr[i];\n//            n -= arr[i].len;\n//        }\n//    }\n//    rep(i,0,n)\n//        ans.cnt[s[i]]++;\n//    return ans;\n//}\n//void _(){\n//    ll l,r;\n//    string s;\n//    cin >> s >> l >> r;\n//\n//    String ans = get(s,r)-get(s,l-1);\n//    print(ans);\n//\n//}\n//\n#include <map>\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define REP_INT(i,l,r) for(int i = l; i <= r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define X first\n#define Y second\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef long double ld;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 vector<T> unique(vector<T>& arr){\n    sort(all(arr));\n    arr.erase(unique(all(arr)), arr.end());\n    return arr;\n}\nT1 istream& read(T, T, istream& = cin);\nT1 void print(T x, string end = \"\\n\"){\n    cout << x << end;\n}\nll mult64(ll x, ll y, ll mod){\n    if(abs(x) >= mod)\n        x %= mod;\n    if(abs(y) >= mod)\n        y %= mod;\n    ll tmp = ((ull)x * y - (ull)((ld)x / mod * y + 1.0e-8) * mod);\n    if(tmp >= mod)\n        tmp -= mod;\n    return (tmp < 0) ? (tmp + mod) : tmp;\n}\nstruct Hasher{\n    string s;\n    const ll mod;\n    vl psum;\n    int n;\n    ll ipow128(ll x, ll p){\n        if(x >= mod)\n            x %= mod;\n        if(p == 0)\n            return 1;\n        if(p == 1)\n            return x;\n        return mult64(ipow128(mult64(x, x, mod), p / 2), ipow128(x, p % 2), mod);\n    }\n    ll _ext_euclid(ll a, ll b, ll c, ll d){\n        if(c == 0)\n            return b;\n        return _ext_euclid(c, d, a % c, b - a / c * d);\n    }\n    ll inv128(ll x){\n        return (_ext_euclid(mod, 0, x, 1) + mod) % mod;\n    }\n    vl k_pows;\n    Hasher(string _s, ll _mod = MOD):s(_s), mod(_mod){\n        n = sz(s);\n        psum.resize(n + 1);\n        ll mult = 1;\n        ll k = 26;\n        k_pows.resize(n+1,1);\n        ll k_inv = inv128(k);\n        for(int i = 1; i <= n; ++i){\n            k_pows[i] = mult64(k_pows[i-1],k_inv,mod);\n            psum[i] = mult64(mult,(s[i - 1] - 'a' + 1),mod);\n            psum[i] += psum[i - 1];\n            mult = mult64(mult,k,mod);\n            mult %= mod;\n            psum[i] %= mod;\n        }\n    }\n    ll range_get(int l, int r){\n        //ll ans = mult64(mod+psum[r+1]-psum[l],k_pows[l],mod);\n        ll ans = (mod+psum[r+1]-psum[l])*k_pows[l]%mod;\n        return ans;\n    }\n};\nbool valid(Hasher &h, int k){\n    bool ok = true;\n    for(int i = 0; i < sz(h.s); i += k){\n        int l = i;\n        int r = i+k-1;\n        r = min(ll(r),sz(h.s)-1);\n        if(h.range_get(l,r) != h.range_get(0,r-l))\n            ok = false;\n    }\n    return ok;\n}\nstring f(string s){\n    vpii ans;\n    Hasher h(s);\n    rep(sz,1,sz(s)){\n        if(valid(h,sz)){\n            int times = (sz(s)+sz-1)/sz;\n            if(times*sz == sz(s))\n                ++times;\n            if(times % 2)\n                ++times;\n            int tot_len = times*sz;\n            ans.pb({tot_len,sz});\n        }\n    }\n    unique(ans);\n    int sz = ans[0].Y;\n    while(sz(s) < ans[0].X){\n        s += s[sz(s)%sz];\n    }\n    return s;\n}\nstruct String{\n    ll len;\n    map<char,ll> cnt;\n    String(string s){\n        s = s.substr(sz(s)/2);\n        len = sz(s);\n        for(char c : s)\n            cnt[c]++;\n    }\n    String operator+(const String &t)const{\n        String ans = *this;\n        ans.len += t.len;\n        for(auto _ : t.cnt)\n            ans.cnt[_.X] += _.Y;\n        return ans;\n    }\n    String operator-(const String &t)const{\n        String ans = *this;\n        ans.len += t.len;\n        for(auto _ : t.cnt)\n            ans.cnt[_.X] -= _.Y;\n        return ans;\n    }\n    friend ostream &operator<<(ostream &stream, String &t){\n        for(char c = 'a'; c <= 'z'; ++c){\n            stream << t.cnt[c];\n            if(c != 'z')\n                stream << ' ';\n        }\n        return stream;\n    }\n};\nString get(string s, ll n){\n    vector<String> arr;\n    arr.pb(String(s));\n    arr.pb(String(f(s)));\n    while(arr.back().len < n){\n        arr.pb(arr[sz(arr)-1]+arr[sz(arr)-2]);\n    }\n    String ans(\"\");\n    for(int i = sz(arr)-1; i >= 1; --i){\n        while(n >= arr[i].len){\n            ans = ans+arr[i];\n            n -= arr[i].len;\n        }\n    }\n    rep(i,0,n)\n        ans.cnt[s[i]]++;\n    return ans;\n}\nvoid _(){\n    ll l,r;\n    string s;\n    cin >> s >> l >> r;\n    String ans = get(s,r)-get(s,l-1);\n    print(ans);\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        _();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define all(x) (x).begin(), (x).end()\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 4;\n\nvector<ll> solve(string s, ll n, ll k)\n{\n    vector<ll> ans(26);\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    string s;\n    cin >> s;\n    {\n        vector<int> z(s.size());\n        int L = 0, R = 0;\n        for (int i = 1; i < s.size(); i++)\n        {\n            z[i] = max(0, min(z[i - L], R - i));\n            while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n            if (i + z[i] > R)\n            {\n                R = i + z[i];\n                L = i;\n            }\n        }\n        int len = s.size();\n        for (int i = s.size() - 1; 2 * i > s.size(); i--)\n        {\n            if (i + z[i] == s.size())\n            {\n                len = i;\n            }\n        }\n        while (s.size() > len) s.pop_back();\n    }\n\n    ll n = s.size();\n    vector<int> z(s.size());\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    ll k = n;\n    for (int i = 1; i < s.size(); i++)\n    {\n        if (i + z[i] == s.size())\n        {\n            k = i;\n            break;\n        }\n    }\n    if (n % k == 0)\n    {\n        vector<ll> cnt(26);\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        ll c = R / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] += c + 1;\n            else cnt[s[i] - 'a'] += c;\n        }\n        c = L / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] -= c + 1;\n            else cnt[s[i] - 'a'] -= c;\n        }\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cnt[i] << \" \";\n        }\n    }\n    else\n    {\n        return 1;\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        vector<ll> cntR = solve(s, n, k), cntL = solve(s, n, k);\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cntR[i] - cntL[i] << \" \";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n//Z-algorithm\n//res[i] := 自分自身と[i,|S|)の最長共通接頭辞の長さ\nvoid z_algorithm(const std::string& str, std::vector<int>&res)\n{\n\tint len = str.length();\n\tres.resize(len);\n\tres[0] = len;\n\tint i = 1, j = 0;\n\twhile (i < len)\n\t{\n\t\twhile (i + j < len && str[j] == str[i + j])\n\t\t\t++j;\n\t\tres[i] = j;\n\t\tif (j == 0)\n\t\t{\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tint k = 1;\n\t\twhile (i + k < len && k + res[k] < j)\n\t\t\tres[i + k] = res[k], ++k;\n\t\ti += k, j -= k;\n\t}\n}\n\nstring S;\nLL L, R;\n\nstruct alpha\n{\n\tLL cnt[26];\n\talpha()\n\t\t:cnt()\n\t{}\n\talpha(const string& s)\n\t\t:cnt()\n\t{\n\t\tfor (char c : s)cnt[c - 'a']++;\n\t}\n\talpha operator+(const alpha& other)\n\t{\n\t\talpha ret = *this;\n\t\tfor (int i = 0; i < 26; ++i)ret.cnt[i] += other.cnt[i];\n\t\treturn ret;\n\t}\n\talpha operator-(const alpha& other)\n\t{\n\t\talpha ret = *this;\n\t\tfor (int i = 0; i < 26; ++i)ret.cnt[i] -= other.cnt[i];\n\t\treturn ret;\n\t}\n\talpha operator*(const LL& mult)\n\t{\n\t\talpha ret = *this;\n\t\tfor (int i = 0; i < 26; ++i)ret.cnt[i] *= mult;\n\t\treturn ret;\n\t}\n\tvoid print()\n\t{\n\t\tfor (int i = 0; i < 26; ++i)cout << cnt[i] << \" \\n\"[i == 25];\n\t}\n\tinline LL size()\n\t{\n\t\tLL res = 0;\n\t\tfor (int i = 0; i < 26; ++i)res += cnt[i];\n\t\treturn res;\n\t}\n};\n\nint main(void)\n{\n\tcin >> S;\n\tcin >> L >> R;\n\t--L;\n\tS.erase(S.size() / 2, S.size() / 2);\n\tint N = S.size();\n\tvector<int>res;\n\tz_algorithm(S, res);\n\tint period = N;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tif (res[i] + i == N)\n\t\t{\n\t\t\tperiod = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (N % period == 0)\n\t{\n\t\t//周期がぴったり\n\t\tstring perstr = S.substr(0, period);\n\t\talpha A(perstr);\n\t\tstd::function<alpha(LL)>F = [&](LL x)\n\t\t{\n\t\t\talpha ret = A * (x / period);\n\t\t\talpha mod = alpha(S.substr(0, x % period));\n\t\t\tret = ret + mod;\n\t\t\treturn ret;\n\t\t};\n\t\talpha ans = F(R) - F(L);\n\t\tans.print();\n\t}\n\telse\n\t{\n\t\t//周期に余りがある\n\t\talpha X(S);\n\t\talpha A(S.substr(0, period));\n\t\tstd::function<alpha(LL)>F = [&](LL x)\n\t\t{\n\t\t\tvector<alpha>len = { A,X };\n\t\t\twhile (len.back().size() <= x)\n\t\t\t{\n\t\t\t\tlen.push_back(len.back() + len[len.size() - 2]);\n\t\t\t}\n\t\t\talpha ans;\n\t\t\tfor (int i = len.size() - 2; i >= 0; --i)\n\t\t\t{\n\t\t\t\tif (x - len[i].size() >= 0)\n\t\t\t\t{\n\t\t\t\t\tx -= len[i].size();\n\t\t\t\t\tans = ans + len[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\talpha rem(S.substr(0, x));\n\t\t\tans = ans + rem;\n\t\t\treturn ans;\n\t\t};\n\t\talpha ans = F(R) - F(L);\n\t\tans.print();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 200010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N; ll L, R;\nint A[MAX_N];\nll C[210][26];\nll D[210];\n\nvector<int> MP(string S) { //it doesn't include itself\n\tint n = (int)S.size();\n\tvector<int> A(n + 1);\n\tA[0] = -1;\n\trep(i, 0, n) {\n\t\tint j = A[i];\n\t\twhile (j >= 0 && S[i] != S[j]) j = A[j];\n\t\tj++;\n\t\tA[i + 1] = j;\n\t}\n\treturn A;\n}\n\nvi calc1(ll n) {\n\tll a = n / N;\n\tll b = n % N;\n\t// debug(a, b);\n\tvector<ll> cnt1(26, 0);\n\tvector<ll> cnt2(26, 0);\n\trep(i, 0, N) {\n\t\tif(i < b) cnt2[A[i]]++;\n\t\tcnt1[A[i]]++;\n\t}\n\trep(i, 0, 26) cnt1[i] = cnt1[i] * a + cnt2[i];\n\treturn cnt1;\n}\n\nvi calc2(ll n, int m) {\n\tvector<ll> res(26, 0);\n\tfor(int i = m - 1; i >= 0; i--) {\n\t\tif(n - D[i] >= 0) {\n\t\t\tn -= D[i];\n\t\t\trep(j, 0, 26) {\n\t\t\t\tres[j] += C[i][j];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, n) {\n\t\tres[A[i]]++;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tstring str;\n\tcin >> str;\n\tN = sz(str) / 2;\n\tstring tmp;\n\trep(i, 0, N) tmp += str[i];\n\t// debug(str, tmp);\n\tint a = MP(tmp)[N];\n\n\trep(i, 0, N) A[i] = str[i] - 'a';\n\t// debug(vi(A, A + N));\n\tcin >> L >> R; L--;\n\tif(a == 0) {\n\t\tvi lv = calc1(L);\n\t\tvi rv = calc1(R);\n\t\t// debug(lv, rv);\n\t\trep(i, 0, 26) {\n\t\t\trv[i] -= lv[i];\n\t\t\tcout << rv[i] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\telse {\n\t\trep(i, 0, N) {\n\t\t\tC[0][A[i]]++; C[1][A[i]]++;\n\t\t\tif(i < N - a) C[1][A[i]]++;\n\t\t}\n\t\tD[0] = N; D[1] = 2 * N - a;\n\t\tint i = 0;\n\t\tfor(i = 2; ; i++) {\n\t\t\tD[i] = D[i - 1] + D[i - 2];\n\t\t\trep(j, 0, 26) C[i][j] = C[i - 1][j] + C[i - 2][j];\n\t\t\tif(D[i] >= R) break;\n\t\t}\n\t\tvi lv = calc2(L, i);\n\t\tvi rv = calc2(R, i);\n\t\t// debug(lv, rv);\n\t\trep(i, 0, 26) {\n\t\t\trv[i] -= lv[i];\n\t\t\tcout << rv[i] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 1e6 + 10;\nconst int M = 26;\n\nchar s[maxn];\nint next[maxn];\n\nstruct Node\n{\n\tLL cnt[M];\n\tNode() { memset(cnt, 0, sizeof cnt); }\n\tvoid operator += (const Node &a)\n\t{\n\t\tfor (int i = 0; i < M; ++ i)\n\t\t\tcnt[i] += a.cnt[i];\n\t}\n\tNode operator + (const Node &a) const\n\t{\n\t\tNode res;\n\t\tfor (int i = 0; i < M; ++ i)\n\t\t\tres.cnt[i] = cnt[i] + a.cnt[i];\n\t\treturn res;\n\t}\n\tNode operator - (const Node &a) const\n\t{\n\t\tNode res;\n\t\tfor (int i = 0; i < M; ++ i)\n\t\t\tres.cnt[i] = cnt[i] - a.cnt[i];\n\t\treturn res;\n\t}\n\tvoid Putout()\n\t{\n\t\tfor (int i = 0; i < M - 1; ++ i) printf(\"%lld \", cnt[i]);\n\t\tprintf(\"%lld\\n\", cnt[M - 1]);\n\t}\n} sum[maxn];\n\nNode Calc(int len, LL n)\n{\n\tLL x = len, y = len + (len - next[len]);\n\tif (n <= x) return sum[n];\n\tif (n <= y) return sum[len] + sum[n - len];\n\tNode a = sum[len], b = sum[len] + sum[len - next[len]];\n\twhile (n >= x + y)\n\t{\n\t\tb += a;\n\t\ta = b - a;\n\t\ty += x;\n\t\tx = y - x;\n\t}\n\treturn b + Calc(len, n - y);\n}\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1) / 2;\n\tnext[1] = 0;\n\tsum[1].cnt[s[1] - 'a'] = 1;\n\tfor (int i = 2; i <= n; ++ i)\n\t{\n\t\tint j = next[i - 1];\n\t\twhile (j && s[j + 1] != s[i]) j = next[j];\n\t\tnext[i] = j + (s[j + 1] == s[i]);\n\t\tsum[i].cnt[s[i] - 'a'] = 1;\n\t\tsum[i] += sum[i - 1];\n\t}\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tNode res = Calc(n, r) - Calc(n, l - 1);\n\tres.Putout();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define MIN(a,b) (((a)<(b))?(a):(b))\ntypedef long long LL;\nclass ele{\n\tpublic:\n\t\tLL sz,cnt[30];\n\t\tele(){\n\t\t\tsz=0;\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t}\n\t\tele(LL SZ,char *inp){\n\t\t\tint xb;\n\t\t\tsz=SZ;\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tfor(xb=0;xb<sz;xb++) cnt[inp[xb]-'a']++;\n\t\t}\n\t\tinline void print(){\n\t\t\tint xb;\n\t\t\tfor(xb=0;xb<26;xb++){\n\t\t\t\tprintf(\"%lld \",cnt[xb]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n}firsts[3][200005],res;\nchar inp[200005],nxt[500005],nnxt[1000005];\nint Z[500005],match[500005],ilen,nlen,match2[500005],nnlen,bct[3];\nLL L,R;\nvector < ele > eles;\nele operator +(const ele &a,const ele &b){\n\tele ret=ele();\n\tret.sz=a.sz+b.sz;\n\tint xb;\n\tfor(xb=0;xb<30;xb++) ret.cnt[xb]=a.cnt[xb]+b.cnt[xb];\n\treturn ret;\n}\nele operator -(const ele &a,const ele &b){\n\tele ret=ele();\n\tret.sz=a.sz+b.sz;\n\tint xb;\n\tfor(xb=0;xb<30;xb++) ret.cnt[xb]=a.cnt[xb]-b.cnt[xb];\n\treturn ret;\n}\nvoid zz(char *fa,int *mth){\n\tint k,l,r,x2,cnt=0,sfa=strlen(fa);\n\tl=r=-1;\n\tmemset(mth,0,sizeof(mth));\n\tmatch[0]=1;\n\tmemset(Z,0,sizeof(Z));\n\tfor(k=1;k<sfa;k++){\n\t\tif(k>r || l==-1){\n\t\t\tfor(x2=k;x2<sfa && fa[x2]==fa[x2-k];x2++);\n\t\t\tx2-=k-1;\n\t\t\tif(x2>1){\n\t\t\t\tZ[k]=x2-1;\n\t\t\t}\n\t\t}\n\t\telse if(Z[k-l]<=r-k){\n\t\t\tZ[k]=Z[k-l];\n\t\t}\n\t\telse{\n\t\t\tZ[k]=r-k+1;\n\t\t\tfor(x2=r+1;x2<sfa && fa[x2]==fa[x2-k];x2++);\n\t\t\tZ[k]+=x2-r-1;\n\t\t}\n\t\tif(Z[k]+k-1>r){\n\t\t\tr=Z[k]+k-1;\n\t\t\tl=k;\n\t\t}\n\t\tif(Z[k]<(sfa>>1)) mth[k+Z[k]-1]=MAX(mth[k+Z[k]-1],Z[k]);\n\t}\n}\ninline char *gc(int d){\n\treturn (d?((d==1)?nxt:nnxt):inp);\n}\ninline void cal(char *stt,int d,int len){\n\tint xb,x2;\n\tfor(xb=0;;xb++){\n\t\tint stp=10*xb;\n\t\tif(stp<len){\n\t\t\tele v=ele(10,stt+stp);\n\t\t\tif(xb) v=v+firsts[d][xb-1];\n\t\t\tfirsts[d][xb]=v;\n\t\t}\n\t\telse break;\n\t}\n\tbct[d]=xb;\n}\nele getele(LL rb,int p){\n\tif(rb<0) return ele();\n\tif(rb>=eles[p].sz-1) return eles[p];\n\tif(p<3){\n\t\trb=MIN(rb,eles[p].sz);\n\t\tele ret;\n\t\tif(rb>=10) ret=firsts[p][rb/10-1]; else ret=ele();\n\t\tint xb;\n\t\tfor(xb=(LL)((LL)rb/10LL)*10LL;xb<=rb;xb++) ret.cnt[gc(p)[xb]-'a']++;\n\t\treturn ret;\n\t}\n\tele ret=getele(rb,p-1);\n\tif(rb>=eles[p-1].sz) ret=ret+getele(rb-eles[p-1].sz,p-2);\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",inp);\n\tscanf(\"%lld %lld\",&L,&R);\n\tL--;\n\tR--;\n\tzz(inp,match);\n\tilen=strlen(inp);\n\tmemcpy(nxt,inp,sizeof(inp));\n\tmemcpy(nxt+ilen,inp+match[ilen-1],sizeof(char)*(ilen-(match[ilen-1]<<1)));\n\tnlen=strlen(nxt);\n\tzz(nxt,match2);\n\tmemcpy(nnxt,nxt,sizeof(nxt));\n\tmemcpy(nnxt+nlen,nxt+match2[nlen-1],sizeof(char)*(nlen-(match2[nlen-1]<<1)));\n\tnnlen=strlen(nnxt);\n\teles.resize(3);\n\tint xb,x2;\n\teles[0]=ele((ilen>>1),inp);\n\teles[1]=ele((nlen>>1),nxt);\n\teles[2]=ele((nnlen>>1),nnxt);\n\twhile(eles.back().sz<=R){\n\t\teles.push_back(eles.back()+eles[eles.size()-2]);\n\t}\n\tcal(inp,0,ilen);\n\tcal(nxt,1,nlen);\n\tcal(nnxt,2,nnlen);\n\tres=getele(R,eles.size()-1)-getele(L-1,eles.size()-1);\n\tres.print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nconst int N=200010;\n\ntypedef long long ll;\n\nint n,prd;\nint fail[N];\nchar a[N];\nll l,r,pre[N][30];\n\ninline ll fib(ll p,int c){\n  if(p<=n) return pre[p][c];\n  if(p<=n*2) return pre[n][c]+pre[p-n][c];\n  ll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n  while(p>a+b){\n    ll c=ret1; ret1+=ret2; ret2=c;\n    c=a; a+=b; b=c;\n  }\n  return ret1+fib(p-a,c);\n}\n\ninline ll calc(ll p,int c){\n  if(p<=n) return pre[p][c];\n  if(n%prd==0){\n    ll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n    p-=n; p%=prd;\n    return ret+pre[p][c];  \n  }\n  else return fib(p,c);\n}\n\nint main(){\n  scanf(\"%s\",a+1); n=strlen(a+1)/2;\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    pre[i][a[i]-'a']++;\n  }\n  scanf(\"%lld%lld\",&l,&r);\n  int k=0;\n  for(int i=2;i<=n;i++){\n    while(k&&a[k+1]!=a[i]) k=fail[k];\n    if(a[k+1]==a[i]) k++;\n    fail[i]=k;\n  }\n  prd=n-fail[n];\n  for(int i=0;i<26;i++)\n    printf(\"%lld \",calc(r,i)-calc(l-1,i));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 200005;\nconst int M = 105;\nconst LL INF = 1000000000000000000;\n\nint n,pre[N];\nint num[26][N];\nint tot=1;\nLL sum1[M],sum2[26][M];\nint T;\nchar s[N];\nLL l,r;\n\nLL Calc(int c,LL lim) {\n\tLL ret=0;\n\tper(i,tot,1) if (lim>=sum1[i]) lim-=sum1[i],ret+=sum2[c][i];\n\treturn ret+num[c][lim];\n}\n\nint main() {\n\n\t#ifndef ONLINE_JUDGE\n\t//\tfreopen(\"data.in\",\"r\",stdin);\n\t//\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\n\tscanf(\"%s\",s+1); scanf(\"%lld%lld\",&l,&r);\n\tn=strlen(s+1)/2;\n\t\n\tpre[1]=0; int k=0;\n\trep(i,2,n) {\n\t\twhile (k&&s[k+1]!=s[i]) k=pre[k];\n\t\tif (s[k+1]==s[i]) k++;\n\t\tpre[i]=k;\n\t} T=n-pre[n];\n\t\n\trep(i,1,n) {\n\t\trep(j,0,25) num[j][i]=num[j][i-1];\n\t\tnum[s[i]-'a'][i]++;\n\t}\n\t\n\tsum1[0]=T; sum1[1]=n; rep(i,0,25) sum2[i][0]=num[i][T],sum2[i][1]=num[i][n];\n\twhile (sum1[tot]<=r) {++tot; sum1[tot]=sum1[tot-1]+sum1[tot-2]; rep(i,0,25) sum2[i][tot]=sum2[i][tot-1]+sum2[i][tot-2];}\n\t\n\trep(i,0,25) {\n\t\tprintf(\"%lld\",Calc(i,r)-Calc(i,l-1));\n\t\tif (i!=25) putchar(' '); else puts(\"\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=2e5+5;\nint i,j,c,ne[maxn];\nchar S[maxn];\nll num[maxn][26],l,r,T,n;\nll f(ll len){\n\tif (len<=n) return num[len][c];\n\tif (len<=n*2) return num[n][c]+num[len-n][c];\n\tll f1=num[n][c],f2=num[n][c]+num[T][c],l1=n,l2=n+T;\n\tfor(;len>l1+l2;)swap(f1,f2),f2+=f1,swap(l1,l2),l2+=l1;\n    return f2+f(len-l2);\n}\nll work(ll len){\n\tif (n%T==0) return len/T*num[T][c]+num[len%T][c];\n    return f(len);\n}\nint main(){\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1),n>>=1;\n\tfo(i,1,n) {\n\t\tfo(j,0,25) num[i][j]=num[i-1][j];\n\t\tnum[i][S[i]-'a']++;\n\t}\n\tfo(i,2,n){\n\t\tfor(;j&&S[j+1]!=S[i];j=ne[j]);\n\t\tif (S[j+1]==S[i]) j++;\n\t\tne[i]=j;\n\t}\n\tT=n-j;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfo(c,0,25) printf(\"%lld \",work(r)-work(l-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 400005;\nconst int MM = 1000000007;\n\nstring D;\n\nstring f(string D, int &a){\n\tstatic int F[MX] = {};\n\tint N = D.size();\n\tfor(int i = 0; i <= D.size(); i++) F[i] = -1;\n\tfor(int i = 1; i <= D.size(); i++){\n\t\tF[i] = F[i-1];\n\t\twhile(F[i] != -1 && D[F[i]] != D[i-1]) F[i] = F[F[i]];\n\t\tF[i] += 1;\n\t}\n\ta = F[N];\n\twhile(a >= N/2) a = F[a];\n\treturn D + D.substr(a, N-2*a);\n}\n\nvoid solve1(string A, ll ad, ll ans[26])\n{\n\tfor(int i = 0; i < 26; i++) ans[i] = 0;\n\tint cnt[26] = {};\n\tstring B = A.substr(0, A.size()/2);\n\tfor(char c : B) cnt[c-'a']++;\n\tfor(int i = 0; i < ad%B.size(); i++) ans[B[i]-'a']++;\n\tfor(int i = 0; i < 26; i++) ans[i] += cnt[i] * (ad/B.size());\n}\n\nvoid solve2(string A, string B, ll ad, ll ans[26])\n{\n\tint c1[26] = {}, c2[26] = {};\n\tfor(char c : A) c1[c-'a']++;\n\tfor(char c : B) c2[c-'a']++;\n\n\tvector<pll> L;\n\tL.push_back(pll(1, 0));\n\tL.push_back(pll(0, 1));\n\twhile(L.back().first * A.size() + L.back().second * B.size() <= ad){\n\t\tL.emplace_back(L[L.size()-2].first + L.back().first, L[L.size()-2].second + L.back().second);\n\t}\n\treverse(L.begin(), L.end());\n\tfor(pll c : L){\n\t\tll v = c.first * A.size() + c.second * B.size();\n\t\tif( ad < v ) continue;\n\t\tad -= v;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tans[i] += c1[i] * c.first + c2[i] * c.second;\n\t\t}\n\t}\n\tfor(int i = 0; i < ad; i++) ans[A[i]-'a'] ++;\n}\n\nint main()\n{\n\tstring A;\n\tint a;\n\tll l, r;\n\tcin >> A >> l >> r; A = f(A, a);\n\tf(A, a);\n\n\tll a1[26] = {}, a2[26] = {};\n\tif( a == A.size()/4 ) solve1(A, r, a1), solve1(A, l-1, a2);\n\telse{\n\t\tsolve2(A.substr(0, a), A.substr(a, A.size()/2-a), r, a1);\n\t\tsolve2(A.substr(0, a), A.substr(a, A.size()/2-a), l-1, a2);\n\t}\n\tfor(int i = 0; i < 26; i++) printf(\"%lld \", a1[i] - a2[i]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\telse\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=len-(npos+1)*2;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=200500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint a[N],nx[N];\nLL b[N][30],bv[N];\nLL Ans[30];\nvoid Doit(LL q,LL K)\n{\n\tif(q<=n)\n\t{\n\t\tfo(i,1,q)Ans[a[i]]+=K;\n\t\treturn;\n\t}\n\tfo(i,1,N)if(bv[i]>q)\n\t{\n\t\tfo(j,0,25)Ans[j]+=b[i-1][j]*K;\n\t\tDoit(q-bv[i-1],K);\n\t\treturn;\n\t}\n}\nint main()\n{\n\tint q;\n\tchar ch=' ';\n\tfor(ch=getchar();ch<='z'&&ch>='a';ch=getchar())a[++n]=ch-'a';\n\tn>>=1;\n\tq=0;\n\tfo(i,2,n)\n\t{\n\t\tfor(;q&&a[q+1]!=a[i];q=nx[q]);\n\t\tif(a[q+1]==a[i])++q;\n\t\tnx[i]=q;\n\t}\n\tm=n-nx[n];\n\tfo(i,1,n)++b[0][a[i]];\n\tfo(i,0,25)b[1][i]=b[0][i];\n\tfo(i,1,m)++b[1][a[i]];\n\tbv[0]=n,bv[1]=n+m;\n\tfo(i,2,1000)\n\t{\n\t\tbv[i]=bv[i-1]+bv[i-2];\n\t\tfo(j,0,25)b[i][j]=b[i-1][j]+b[i-2][j];\n\t}\n\tLL l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tDoit(r,1);\n\tDoit(l-1,-1);\n\tfo(i,0,25)printf(\"%lld \",Ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nchar s[111111];\nlong long l,r,g,cnt[28][100011],nn,p[28][100011],q[28][100011];\nlong long sp,sq,len[111],num[111],n1,re,sz,z[111111];\nbool f;\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long Query(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sp+sq) \n\t{\n\t\tif (pos<=sp) return p[a][pos-1];\n\t\treturn p[a][sp-1]+q[a][pos-sp-1];\n\t}\n\tlen[1]=sp;len[2]=sp+sq;re=pos-sp-sq;num[1]=p[a][sp-1];num[2]=p[a][sp-1]+q[a][sq-1];\n\tlong long res=p[a][sp-1]+q[a][sq-1];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re>=len[i-2])\n\t\t{\n\t\t\tre-=len[i-2];\n\t\t\tres+=num[i-2];\n\t\t\tnum[i]=num[i-1]+num[i-2];\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t} \n\t\telse\n\t\t{\n\t\t\tn1=i-2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlong long pre=re;\n\twhile(n1>2)\n\t{\n\t\tif (pre>=len[n1-1]) \n\t\t{\n\t\t\tres+=num[n1-1];\n\t\t\tpre=pre-len[n1-1];\n\t\t\tn1-=2;\n\t\t}\n\t\telse n1--;\n\t}\n\tif (!pre) return res;\n\tif (n1==1) res+=p[a][pre-1];\n\telse \n\t{\n\t\tif (pre<=sp) res+=p[a][pre-1];\n\t\telse res=res+p[a][sp-1]+q[a][pre-sp-1];\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tlong long ll,rr,j,k;\n\tll=0;rr=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>rr)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tll=i;rr=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-ll;\n\t\t\tif (z[k]<rr-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=rr;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tll=i;rr=j-1;z[i]=rr-ll+1;\n\t\t\t}\n\t\t}\n\t\tif (z[i]+i==sz && sz%i==0) \n\t\t{\n\t\t\tif (!f) g=i;\n\t\t\tf=1;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tfor (int i=0;i<g;i++) \n\t\t{\n\t\t\tif (z[i]+i==g) f=0;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t}\n\telse\n\t{\n\t\tnn=sz;\n\t\tfor (int i=sz-1;i>=sz/2+1;i--)\n\t\t{\n\t\t\tif (i+z[i]!=sz) continue;\n\t\t\tnn=i;\n\t\t}\n\t\tp[s[0]-'a'][0]=1;\n\t\tsp=1;\n\t\tfor (int i=1;i<sz;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') p[j][i]=p[j][i-1]+1;\n\t\t\t\telse p[j][i]=p[j][i-1];\n\t\t\t}\n\t\t\tsp++;\n\t\t}\n\t\tq[s[sz-nn]-'a'][0]=1;\n\t\tsq=1;\n\t\tfor (int i=1;i<nn*2-sz;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i+(sz-nn)]-'a') q[j][i]=q[j][i-1]+1;\n\t\t\t\telse q[j][i]=q[j][i-1];\n\t\t\t}\n\t\t\tsq++;\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",Query(r,i)-Query(l-1,i));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nchar s[200010];\nint n,nxt[200010],m,cnt[100010][26],k;\nll pos[110],cnts[110][26];\nll calc(ll x,int c){\n\tif(n%m){\n\t\tll sum=0;\n\t\tfor(int i=k;i--;)\n\t\t\tif(x>=pos[i])sum+=cnts[i][c],x-=pos[i];\n\t\treturn sum+cnt[x][c];\n\t}\n\telse return cnt[m][c]*(x/m)+cnt[x%m][c];\n}\nint main(){\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tfor(n=0;s[n];n++){\n\t\tint&i=nxt[n+1];\n\t\tfor(i=nxt[n];i&&s[i]!=s[n];i=nxt[i]);\n\t\tif(n&&s[i]==s[n])i++;\n\t}\n\tn/=2;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<26;j++)\n\t\t\tcnt[i+1][j]=cnt[i][j]+(s[i]==j+'a');\n\tm=n-nxt[n];\n\tif(n%m){\n\t\tpos[0]=n,pos[k=1]=n+m;\n\t\tfor(;pos[k]<=r;k++)pos[k+1]=pos[k-1]+pos[k];\n\t\tfor(int i=0;i<k;i++)\n\t\t\tfor(int j=0;j<26;j++)cnts[i][j]=!i?cnt[n][j]:i==1?cnt[n][j]+cnt[m][j]:cnts[i-2][j]+cnts[i-1][j];\n\t}\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld%c\",calc(r,i)-calc(l-1,i),\" \\n\"[i==25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=200005;\n\nstruct node{\n\tll v[26];\n\tnode(bool f=0){if(f)memset(v,0,26<<3);}\n\tll&operator[](char c){return v[c-'a'];}\n\tnode friend operator+(const node&a,const node&b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]+=b.v[i];\n\t\treturn c;\n\t}\n\tnode friend operator-(const node&a,const node&b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]-=b.v[i];\n\t\treturn c;\n\t}\n\tnode friend operator*(const node&a,ll b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]*=b;\n\t\treturn c;\n\t}\n\tvoid print(){\n\t\tfor(int i=0;i<26;i++)\n\t\t\tprintf(\"%lld%c\",v[i],\" \\n\"[i==25]);\n\t}\n}ch[N];\n\nchar S[N];\nll l,r,f[105];\nint n,fail[N],m,k;\nnode g[105];\n\nvoid mk(){\n\tg[0]=ch[m];f[0]=m;\n\tg[1]=ch[n];f[1]=n;\n\tfor(k=2;(g[k]=g[k-1]+g[k-2],f[k]=f[k-1]+f[k-2])<=r;k++);\n}\nnode chk1(ll len){\n\tif(len<=n)return ch[len];\n\tnode ret=ch[n];len-=n;\n\tret=ret+ch[m]*(len/m)+ch[len%m];\n\treturn ret;\n}\nnode chk2(ll len){\n\tnode ret(true);\n\tfor(int i=k;i>=1;i--)\n\t\tif(len>=f[i])ret=ret+g[i],len-=f[i];\n\tret=ret+ch[len];len=0;\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1)>>1;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfail[1]=0;ch[1][S[1]]++;\n\tfor(int i=2;i<=n;i++){\n\t\tint p=fail[i-1];\n\t\twhile(p&&S[p+1]!=S[i])p=fail[p];\n\t\tfail[i]=p+1;\n\t\tch[i]=ch[i-1];ch[i][S[i]]++;\n\t}\n\tm=n-fail[n];\n\tif(n%m==0)(chk1(r)-chk1(l-1)).print();\n\telse mk(),(chk2(r)-chk2(l-1)).print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len=INF;\nstring s;\nint cnt[maxn][maxm],z[maxn]; \nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-L]<=R-i)z[i]=z[i-L];\n\t\t\telse{\n\t\t\t\tz[i]=R-i;\n\t\t\t\tfor(int j=R-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tREP(i,n-1)if(z[i]+i==n)len=min(len,i);\n\n\tif(len==INF){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 400050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]]++;\n\t\telse\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]]++;\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],npos+1,len-npos-2);\n\t\t\tla=npos+1;lb=len-la-la;\n\t\t\tsa=0,sb=npos+1;\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 1000;\n\nstruct State\n{\n\tlong long cnt[26], size;\n\tState()\n\t{\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\tsize = 0;\n\t}\n\tvoid add(char c)\n\t{\n\t\tcnt[c - 'a']++, size++;\n\t}\n};\n\nState operator + (const State &a, const State &b)\n{\n\tState ret;\n\tfor(int i = 0; i < 26; i++)\n\t\tret.cnt[i] = a.cnt[i] + b.cnt[i];\n\tret.size = a.size + b.size;\n\treturn ret;\n}\n\nint n, m;\nlong long L, R;\nchar s[MAXN];\nState f[MAXN];\n\nState prefix(int v)\n{\n\tState ret;\n\tfor(int i = 1; i <= v; i++)\n\t\tret.add(s[i]);\n\treturn ret;\n}\n\nState calc(int x, long long v)\n{\n\tif(x == 0 || x == 1)\n\t\treturn prefix(v);\n\tif(v <= f[x - 1].size)\n\t\treturn calc(x - 1, v);\n\telse\n\t\treturn f[x - 1] + calc(x - 2, v - f[x - 1].size);\n}\n\nint get_period()\n{\n\tstatic int next[MAXN];\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tint j = next[i - 1];\n\t\twhile(j && s[j + 1] != s[i])\n\t\t\tj = next[j];\n\t\tif(s[j + 1] == s[i])\n\t\t\tj = j + 1;\n\t\tnext[i] = j;\n\t}\n\treturn n - next[n];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> (s + 1);\n\tcin >> L >> R;\n\tn = strlen(s + 1) / 2;\n\ts[n + 1] = 0;\n\n\tint k = get_period();\n\tf[0] = prefix(k);\n\tf[1] = prefix(n);\n\n\tm = 2;\n\twhile(f[m - 1].size <= R) {\n\t\tf[m] = f[m - 1] + f[m - 2];\n\t\tm++;\n\t}\n\n\tState ans1 = calc(m, L - 1);\n\tState ans2 = calc(m, R);\n\n\tfor(int i = 0; i < 26; i++)\n\t\tcout << ans2.cnt[i] - ans1.cnt[i] << ' ';\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 400010;\n\nchar s0[N];\nint len, nxt[N];\n\nvoid get_nxt()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= len; i ++) {\n\t\twhile (j && s0[i] != s0[j + 1]) j = nxt[j];\n\t\tif (s0[i] == s0[j + 1]) j ++;\n\t\tnxt[i] = j; \n\t}\n}\n\nLL f[N][27], ans[27];\n\nLL calc(int x, LL k, int c)\n{\n\t//printf(\"%d %lld %lld %d\\n\", x, k, f[x][0], c);\n\t\n\tif (f[x][0] == k) return f[x][c];\n\tif (k >= f[x - 1][0])\n\t\treturn f[x - 1][c] + calc(x - 2, k - f[x - 1][0], c);\n\telse return calc(x - 1, k, c);\n}\n\nint main()\n{\n\tscanf(\"%s\", s0 + 1);\n\tlen = strlen(s0 + 1) / 2;\n\tLL l, r;\n\t//scanf(\"%lld%lld\", &l, &r);\n\tget_nxt();\n\t\n\tprintf(\"%d %d\\n\", nxt[len], len - nxt[len]);\n\t\n\tRep(i, len - nxt[len]) f[0][s0[i] - 'a' + 1] ++;\n\tRep(i, len) f[1][s0[i] - 'a' + 1] ++;\n\tf[0][0] = len - nxt[len], f[1][0] = len;\n\tint x = 2;\n\twhile (true) {\n\t\tRep0(i, 26) f[x][i] = f[x - 1][i] + f[x - 2][i];\n\t\t//printf(\"%d %lld\\n\", x, f[x][0]);\n\t\tif (f[x][0] >= r) break;\n\t\tx ++;\n\t}\n\tif (l > 1) Rep0(i, x) if (f[i][0] >= l - 1) {\n\t\tRep(j, 26) ans[j] -= calc(i, l - 1, j);\n\t\tbreak;\n\t}\n\n\tRep0(i, x) if (f[i][0] >= r) {\n\t\tRep(j, 26) ans[j] += calc(i, r, j);\n\t\tbreak;\n\t}\n\tRep(i, 26) printf(\"%lld \", ans[i]);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n/*\nxx\n1 100\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 3) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = true;\n\ts = conv(s);\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 2; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=210000;\n#define ll long long\nchar s[N];\nll L,R;\nint nex[N];\nll len[210];\nstruct node\n{\n\tll a[26];\n\tvoid init(int x)\n\t{\n\t\tfor(int i=1;i<=x;i++)\n\t\t\ta[s[i]-'a']++;\n\t}\n\tfriend node operator + (const node &r1,const node &r2)\n\t{\n\t\tnode ret;\n\t\tfor(int i=0;i<26;i++)\n\t\t\tret.a[i]=r1.a[i]+r2.a[i];\n\t\treturn ret;\n\t}\n\tfriend node operator - (const node &r1,const node &r2)\n\t{\n\t\tnode ret;\n\t\tfor(int i=0;i<26;i++)\n\t\t\tret.a[i]=r1.a[i]-r2.a[i];\n\t\treturn ret;\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i=0;i<26;i++)\n\t\t\tprintf(\"%lld \",a[i]);\n\t\tputs(\"\");\n\t}\n}v[210];\nnode calc(ll x)\n{\n\tint p;\n\tfor(p=1;;p++)\n\t\tif(len[p]>=x)break;\n\tnode ret,t;\n\tmemset(&ret,0,sizeof(ret));\n\tmemset(&t,0,sizeof(t));\n\tfor(;p>=1;p--)\n\t\tif(len[p]<=x)\n\t\t{\n\t\t\tret=ret+v[p];\n\t\t\tx-=len[p];\n\t\t}\n\tt.init(x);\n\tret=ret+t;\n\treturn ret;\n}\nint main()\n{\n\t//freopen(\"tt.in\",\"r\",stdin);\n\tscanf(\"%s%lld%lld\",s+1,&L,&R);\n\tlen[2]=strlen(s+1)/2;\n\tnex[1]=0;\n\tfor(int i=2,j=0;i<=len[2];i++)\n\t{\n\t\twhile(j&&s[j+1]!=s[i])\n\t\t\tj=nex[j];\n\t\tif(s[j+1]==s[i])j++;\n\t\tnex[i]=j;\n\t}\n\tlen[1]=len[2]-nex[len[2]];\n\tv[1].init(len[1]);\n\tv[2].init(len[2]);\n\tfor(int i=3;;i++)\n\t{\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tv[i]=v[i-1]+v[i-2];\n\t\tif(len[i]>=R)break;\n\t}\n\t(calc(R)-calc(L-1)).print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tV=0;\n\t\t}\n\t\tif(V>cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[1][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\tassert(0);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> RR=hoge3(R);\n\t\tvector<ll> LL=hoge3(L-1);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nstring S;\nLL L, R;\nusing V = array<LL, 26>;\n\n// re[i] := S[0..i-1]の接頭辞・接尾辞が最大何文字一致しているか\nvoid mp(const string &S, vector<int> &re){\n  re.resize(S.size()+1); re[0]=-1;\n  int j=-1;\n  rep(i, S.size()){\n    while(j>=0 && S[i]!=S[j]) j=re[j];\n    re[i+1]=++j;\n  }\n}\n\nV Count(string &s) {\n  V ret = {};\n  for (char c : s) {\n    ret[c-'a']++;\n  }\n  return ret;\n}\n\nLL Sum(V &a) {\n  LL ret = 0;\n  rep(i, 26) {\n    ret += a[i];\n  }\n  return ret;\n}\n\nV Solve(LL r) {\n  V ret = {};\n  if (!r) return ret;\n\n  if (S.size()*2 >= r) {\n    string SS = S+S;\n    rep(i, r) {\n      ret[SS[i]-'a']++;\n    }\n    return ret;\n  }\n\n  vector<int> re;\n  mp(S, re);\n  int n = S.size();\n  int w = n - re[n];\n  string P = S.substr(0, w);\n  auto a = Count(P);\n  if (n%w == 0) {\n    rep(i, 26) {\n      ret[i] += a[i] * (r/w);\n    }\n    rep(i, r%w) {\n      ret[P[i]-'a']++;\n    }\n    return ret;\n  }\n  \n  vector<V> series;\n  series.eb(a);\n  series.eb(Count(S));\n  int idx = 1;\n  while (1) {\n    if (Sum(series[idx])*2 >= r) {\n      assert (Sum(series[idx]) < r);\n      {\n        ret = series[idx];\n        r -= Sum(series[idx]);\n      }\n      break;\n    }\n\n    series.eb();\n    rep(i, 26) {\n      series.back()[i] = series[idx-1][i] + series[idx][i];\n    }\n    ++idx;\n  }\n\n  while (idx > 1) {\n    //cout << \"r: \" << r << endl;\n    //cout << idx << \": \";\n    //rep(i, 26) {\n    //  if (i) cout << \" \";\n    //  cout << ret[i];\n    //}cout << endl;\n    assert(Sum(series[idx]) >= r);\n    --idx;\n    if (Sum(series[idx]) <= r) {\n      rep(i, 26) ret[i] += series[idx][i];\n      r -= Sum(series[idx]);\n      --idx;\n    }\n  }\n  if (idx == 1) {\n    assert(r <= S.size());\n    rep(i, r) {\n      ret[S[i]-'a']++;\n    }\n  } else {\n    assert(idx == 0 && Sum(series[idx]) >= r);\n    assert(r <= w);\n    rep(i, r) {\n      ret[P[i]-'a']++;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> S;\n  assert(S.size()%2 == 0);\n  S = S.substr(S.size()/2);\n  cin >> L >> R;\n  auto ans = Solve(R);\n  auto sub = Solve(L-1);\n  rep(i, 26) {\n    if (i) cout << \" \";\n    assert(ans[i] >= sub[i]);\n    cout << ans[i] - sub[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n \nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (len <= n * 2) return num[n][c] + num[len - n][c];\n\tlong long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n\twhile (len > l1 + l2) {\n\t\tlong long t = f2;\n\t\tf2 += f1, f1 = t;\n\t\tt = l2, l2 += l1, l1 = t;\n\t}\n\treturn f2 + fib(len - l2, c);\t\n}\n\nlong long calc(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (len % T == 0) {\n\t\tlong long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n\t\tlen -= n, len %= T;\n\t\treturn re + num[len][c];\n\t}\n\telse return fib(len, c);\n}\n\nint main() {\n\tscanf(\"%s%lld%lld\", s + 1, &L, &R);\n\tn = strlen(s + 1) / 2;\n\tp[1] = 0;\n\tfor (int j = 0, i = 2; i <= n; i ++) {\n\t\tfor (; j && s[j + 1] != s[i];) j = p[j];\n\t\tif (s[j + 1] == s[i]) j ++;\n\t\tp[i] = j;\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < 26; j ++) num[i][j] = num[i - 1][j];\n\t\tnum[i][s[i] - 'a'] ++;\n\t}\n\tT = n - p[n];\n\tfor (int i = 0; i < 26; i ++) printf(\"%lld%c\", calc(R, i) - calc(L - 1, i), i == 25 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nlong long L, R, fib[100], power[100009], hush[100009]; string S, T;\n\nvoid init() {\n\tfib[0] = 0; fib[1] = 1; for (int i = 2; i <= 99; i++) fib[i] = fib[i - 1] + fib[i - 2];\n\tpower[0] = 1; for (int i = 1; i <= 100008; i++) power[i] = power[i - 1] * 331LL;\n\thush[0] = 0; for (int i = 0; i < T.size(); i++) { hush[i + 1] = hush[i] * 331LL; hush[i + 1] += (T[i] - 'a' + 1); }\n}\nlong long val(long long l, long long r) {\n\treturn hush[r] - hush[l] * power[r - l];\n}\n\nlong long reps() {\n\tlong long G = 0;\n\tfor (int i = 1; i <= T.size(); i++) {\n\t\tif (T.size() % i != 0) continue;\n\t\tbool OK = true;\n\t\tfor (int j = 0; j < T.size(); j += i) {\n\t\t\tif (T.substr(0, i) != T.substr(j, i)) OK = false;\n\t\t}\n\t\tif (OK == true) { G = T.size() / i; break; }\n\t}\n\treturn G;\n}\nvector<long long> solve_1(long long Y, long long Z) {\n\tvector<long long>rem(26, 0);\n\tfor (int i = 0; i < Y; i++) rem[T[i] - 'a'] += Z / Y;\n\tfor (int i = 0; i < Z%Y; i++) rem[T[i] - 'a']++;\n\treturn rem;\n}\n\nlong long a, b; map<long long, vector<long long>>M;\n\nvector<long long>solve(long long Z) {\n\tif (M[Z].size() >= 1) return M[Z];\n\tif (Z <= a) {\n\t\tvector<long long>A1(26, 0);\n\t\tfor (int i = 0; i < Z; i++) A1[T[i] - 'a']++;\n\t\tM[Z] = A1;\n\t\treturn A1;\n\t}\n\tvector<long long>A2(26, 0);\n\tfor (int i = 1; i <= 90; i++) {\n\t\tlong long G = fib[i] * a + fib[i - 1] * b;\n\t\tif (Z <= G) {\n\t\t\tvector<long long>P1 = solve(fib[i - 1] * a + fib[i - 2] * b);\n\t\t\tvector<long long>P2 = solve(Z - (fib[i - 1] * a + fib[i - 2] * b));\n\t\t\tA2 = P1;\n\t\t\tfor (int j = 0; j < 26; j++) A2[j] += P2[j];\n\t\t\tbreak;\n\t\t}\n\t}\n\tM[Z] = A2;\n\treturn A2;\n}\n\nvector<long long>solve_2(long long Z) {\n\ta = T.size(), b = 0;\n\tfor (int i = 0; i < T.size(); i++) { if (val(0, i) == val(T.size() - i, T.size())) b = T.size() - i; }\n\treturn solve(Z);\n}\n\nint main() {\n\tcin >> S >> L >> R; T = S.substr(0, S.size() / 2);\n\tinit();\n\tlong long V = reps(); vector<long long>ans1, ans2;\n\tif (V >= 2) { ans1 = solve_1(T.size() / V, R); ans2 = solve_1(T.size() / V, L - 1); }\n\telse { ans1 = solve_2(R); ans2 = solve_2(L - 1); }\n\tfor (int i = 0; i < ans1.size(); i++) { if (i)cout << \" \"; cout << ans1[i] - ans2[i]; }cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 200005\nusing namespace std;\n//ifstream cin(\"date.in\");\n//ofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    for(i = 1; i <= n; i++){\n        if(i <= n / 2 + n % 2){\n            a[i] = s[i];\n        }\n        else{\n            a[i + 1] = s[i];\n        }\n    }\n    a[n / 2 + n % 2 + 1] = '*';\n    for(i = 2; i <= n + 1; i++){\n        while(L > 0 && a[i] != a[L + 1]){\n            L = p[L];\n        }\n        if(a[i] == a[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    n = n - p[n + 1];\n    L = 0;\n    for(i = 2; i <= n; i++){\n        while(L > 0 && s[i] != s[L + 1]){\n            L++;\n        }\n        if(s[i] == s[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    for(i = 1; i <= n; i++){\n        ok = 1;\n        for(j = i + i; j <= n; j += i){\n            if(p[j] != j - i){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(j = j - i + 1; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n >= dr || fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#undef LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\n// z[i] = len of lcp of s, s[i..]; lcp(longest common prefix)\nvector<int> z_fn(const string& s) {\n    int n = s.size();\n    vector<int> z(n, 0);\n    for (int i = 1, l = 0, r = 0; i < n; i++) {\n        if (i <= r)\n            z[i] = min(r-i+1, z[i-l]);\n        while (i+z[i] < n && s[z[i]] == s[i+z[i]]) {\n            z[i]++;\n        }\n        if (i+z[i]-1 > r) {\n            l = i; r = i+z[i]-1;\n        }\n    }\n    return z;\n}\n\nvoid f(string& s){\n    auto z = z_fn(s);\n    int n = s.size();\n    int i = n/2 + 1;\n    while (i < n) {\n        if (z[i] == n-i) break;\n        i++;\n    }\n    for (int j = 0; j < 2*i-n; j++) {\n        s.push_back(s[j+n-i]);\n    }\n}\n\nint min_prefix(const string& s){\n    int n = s.size();\n    auto z = z_fn(s);\n    for (int i = 1; i < n; i++) {\n        if (z[i] == n-i) return i;\n    }\n    return n;\n}\n\nusing ll=long long ;\nusing Freq=array<ll,26>;\nFreq& operator+=(Freq& a, const Freq& b){\n    for (int i = 0; i < 26; i++) {\n        a[i] += b[i];\n    }\n    return a;\n}\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\n\nvoid solve() {\n    string s; cin >> s;\n    f(s);\n    s.resize(s.size()/2);\n    int k = min_prefix(s);\n    int n = s.size();\n    dbg(s,k,n);\n\n    vector<ll> fib = {k, n};\n    vector<Freq> cnt(100);\n    for (int i = 0; i < k; i++) {\n        cnt[0][s[i]-'a']++;\n    }\n    for (int i = 0; i < n; i++) {\n        cnt[1][s[i]-'a']++;\n    }\n    while (fib.back() < INF) {\n        int n = fib.size();\n        fib.emplace_back(fib[n-1] + fib[n-2]);\n        for (int i = 0; i < 26; i++) {\n            cnt[n][i] = cnt[n-1][i] + cnt[n-2][i];\n        }\n    }\n    dbg(fib);\n    dbg(cnt);\n\n    int m = fib.size();\n    dbg(m);\n    dbg(cnt[m-1]);\n    auto till = [&](ll r){\n        Freq res = {};\n        if (r <= 0) return res;\n        for (int i = m-1; i >= 0; i--) {\n            if (r < fib[i]) continue;\n            res += cnt[i];\n            r -= fib[i];\n            dbg(i, res, r);\n        }\n        assert(r < n);\n        for (int i = 0; i < r; i++) {\n            res[s[i]-'a']++;\n        }\n        return res;\n    };\n\n    ll l, r;\n    cin >> l >> r;\n    auto x = till(l-1);\n    auto y = till(r);\n    for (int i = 0; i < 26; i++) {\n        cout << (y[i]-x[i]) << ' ';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 20160116\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n// cf IO: I64d\n// atcoder IO: lld\nconst int Maxn=500005;\nconst long long mod=12384738759127LL;\nconst long long tim=1311;\nchar s[Maxn];\nint n;\nlong long cnt[Maxn][26],ans[26];\nlong long l,r;\nvoid Output(long long x[]){\n\tfor (int i=0;i<26;i++){\n\t\tprintf(\"%lld \",x[i]);\n\t}\n\tprintf(\"\\n\");\n\texit(0);\n}\npair<long long,vector<long long> > go(long long len,vector<long long> lfsum, long long lflen,vector<long long> rgsum,long long rglen){\n\tvector<LL> ret,newlf,newrg;\n\tret.resize(26,0);\n\tnewlf.resize(26,0);\n//\tnewrg.resize(26,0);\n\tif (lflen+rglen<=len){\n\t\tfor (int i=0;i<26;i++){\n\t\t\tnewlf[i]=lfsum[i]+rgsum[i];\n\t\t}\n\t\tpair<LL,vector<LL> > tmp=go(len,newlf,lflen+rglen,lfsum,lflen);\n\t\tfor (int i=0;i<26;i++) ret[i]+=(tmp.second)[i];\n\t\tlen=tmp.first;\n\t}\n\tif (len>=lflen){\n\t\tfor (int i=0;i<26;i++) ret[i]+=lfsum[i];\n\t\tlen-=lflen;\n\t}\n\treturn mp(len,ret); \n}\nvector<long long> solve(long long target,int pre){\n\tvector<LL> lf,rg;\n\tlf.resize(26),rg.resize(26,0);\n\tfor (int i=0;i<26;i++){\n\t\tlf[i]=cnt[n-pre][i];\n\t\trg[i]=cnt[n][i]-cnt[n-pre][i];\n\t}\n\tpair<LL,vector<LL> > res=go(target,lf,(LL)n-pre,rg,(LL)pre);\n\t//cout<<res.first<<endl;\n\tfor (int i=0;i<26;i++){\n\t\t(res.second)[i]+=cnt[res.first][i];\n\t} \n\treturn res.second;\n}\nint z[Maxn];\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tn/=2;\n\tscanf(\"%lld %lld\",&l,&r);\n\tint len=0;\n\tint lo=-1,hi=-1;\n\tfor (int i=1;i<n;i++){\n\t\tif (i>hi){\n\t\t\tint nh=-1;\n\t\t\tfor (int j=i;j<n;j++){\n\t\t\t\tif (s[j]==s[j-i]) nh=j;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\thi=nh;\n\t\t\tlo=i;\n\t\t\tz[i]=hi-lo+1;\n\t\t\tz[i]=max(z[i],0);\n\t\t} \n\t\telse{\n\t\t\tint _l=0,_r=hi-lo,_i=i-lo;\n\t\t\tif (z[_i]+_i-1<=r){\n\t\t\t\tz[i]=z[_i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint nh=hi;\n\t\t\t\tfor (int j=hi+1;j<n;j++){\n\t\t\t\t\tif (s[j]==s[j-i]) nh=j;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\thi=nh;\n\t\t\t\tlo=i;\n\t\t\t\tz[i]=hi-lo+1;\n\t\t\t}\n\t\t}\n\t\tif (i+z[i]-1==n-1) len=max(len,z[i]);\n\t}\n\t//cout<<len<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++){\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tl--;\n\tif (len==0){\n\t\tlong long tot=0;\n\t\tfor (int i=0;i<26;i++){\n\t\t\tans[i]+=cnt[n][i]*(r/n);\n\t\t\tans[i]-=cnt[n][i]*(l/n);\n\t\t\tans[i]+=cnt[r%n][i];\n\t\t\tans[i]-=cnt[l%n][i];\n\t\t\ttot+=ans[i];\n\t\t}\n\t\t//cout<<tot<<endl;\n\t\tOutput(ans);\n\t\treturn 0;\n\t}\n\tvector<LL> ans1=solve(r,len);\n\tvector<LL> ans2=solve(l,len);\n\tfor (int i=0;i<26;i++){\n\t\tans1[i]-=ans2[i];\n\t\tprintf(\"%lld \",ans1[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n/*\nasdcasdcbbcbdabscbasbdcbbdcbdbcdababsdbcasbdcbasbdcbasdbcbaasdcbabdbcbdbcabdcbdsbcbadsbcbbdcsbbadbcsbasbdcasdcasdcbbcbdabscbasbdcbbdcbdbcdababsdbcasbdcbasbdcbasdbcbaasdcbabdbcbdbcabdcbdsbcbadsbcbbdcsbbadbcsbasbdc\n1 1000000000000000000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next Next\n#define last Last\n#define int long long\n/*char buf[1<<21],*p1=buf,*p2=buf;\ninline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/\n#define gc getchar\ninline int read()\n{\n\tint ret=0,f=0;char c=gc();\n\twhile(!isdigit(c)){if(c=='-')f=1;c=gc();}\n\twhile(isdigit(c)){ret=ret*10+c-48;c=gc();}\n\tif(f)return -ret;return ret;\n}\nconst int N=200005;\nint n,d,next[N];\nint l,r,s[N][30];\nchar a[N];\nvoid KMP()\n{\n\tint k=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(;k&&a[k+1]!=a[i];)k=next[k];\n\t\tnext[i]=(k+=(a[k+1]==a[i]));\n\t}\n\td=n-next[n];\n}\nint fib(int p,int c)\n{\n\tif(p<=n)return s[p][c];\n\tif(p<=n*2)return s[n][c]+s[p-n][c];\n\tint ans1=s[n][c]+s[d][c],ans2=s[n][c];\n\tint a=n+d,b=n;\n\tfor(;p>a+b;)\n\t{\n\t\tint c=ans1;\n\t\tans1+=ans2; \n\t\tans2=c;\n\t\tc=a;\n\t\ta+=b;\n\t\tb=c;\n\t}\n\treturn ans1+fib(p-a,c);\n}\nint suan(int p,int c)\n{\n\tif (p<=n) return s[p][c];\n\tif(n%d==0){\n\t\tint ans=(p-n)/d*s[d][c]+s[n][c];\n\t\treturn ans+s[(p-n)%d][c];\n\t}\n\treturn fib(p,c);\n}\nsigned main()\n{\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)s[i][j]=s[i-1][j];\n\t\ts[i][a[i]-'a']++;\n\t}\n\tKMP();\n\tl=read(),r=read();\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",suan(r,i)-suan(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\n#define LL long long\nLL l, r;\nchar st[N];\nint par[N], n, k;\nLL solve(int c, LL r)\n{\n    LL res = 0;\n    if (r <= n)\n    {\n        for (int i = 1; i <= r; ++ i) if (st[i] == c) res ++;\n        return res;\n    }\n    LL ca = 0, cb = 0;\n    for (int i = 1; i <= n - k; ++ i) if (st[i] == c) ca ++;\n    for (int i = n - k + 1; i <= n; ++ i) if (st[i] == c) cb ++;\n    if (k % (n - k) == 0)\n    {\n        LL cc = 0;\n        for (int i = n - k + 1; i <= n - k + (r - (n - k)) % k; ++ i) cc ++;\n        return ca + cb * ((r - (n - k)) / k) + cc;\n    }\n    else\n    {\n        LL a = n - k, b = k, cca = ca, ccb = cb;\n        for (; a + b <= r; b += a, swap(a, b), cb += ca, swap(ca, cb));\n        return ca + solve(c, r - a);\n    }\n}\nint main()\n{\n    scanf(\"%s\", st + 1);\n    n = strlen(st + 1) / 2;\n    for (int i = 2; i <= n; ++ i)\n    {\n        int p = par[i - 1];\n        while (p && st[p + 1] != st[i]) p = par[p];\n        if (st[p + 1] != st[i]) par[i] = 0; else par[i] = p + 1;\n    }\n    // printf(\"%d\\n\", par[n]);\n    k = par[n];\n    if (k == 0) k = n, n += n;\n    scanf(\"%lld%lld\", &l, &r);\n    for (int i = 0; i < 26; ++ i)\n        printf(\"%lld \", solve(i + 'a', r) - solve(i + 'a', l - 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2e5 + 5; \ntypedef long long ll;\ntypedef unsigned int ui;\nconst ui p = 19260817; \nusing namespace std;\n\nint n, Pos; \nll s[105][30], b[105][30], a[105][30], cnt[30], L, R; \nui pw[N], hashh[N]; \nchar S[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nui gethashh(int l, int r)\n{\n\tint len = r - l + 1; \n\treturn hashh[r] - hashh[l - 1] * pw[len]; \n}\n\nvoid prepare()\n{\n\tfor(int i = (pw[0] = 1); i <= n; i++) pw[i] = pw[i - 1] * p;\n\tfor(int i = 1; i <= n; i++) hashh[i] = hashh[i - 1] * p + (S[i] - 'a' + 1);\n\tPos = 0; \n\tfor(int i = 1; i < n / 2; i++)\n\t\tif(gethashh(1, i) == gethashh(n - i + 1, n)) Pos = i; \n\tfor(int i = 1; i <= Pos; i++) s[0][0]++, s[0][S[i] - 'a' + 1]++; \n\tfor(int i = Pos + 1; i <= n / 2; i++) a[0][0]++, a[0][S[i] - 'a' + 1]++; \n\tfor(int i = n / 2 + 1; i <= n - Pos; i++) b[0][0]++, b[0][S[i] - 'a' + 1]++; \n}\n\nvoid calc(ll x, int op, int pos, int type)\n{\n\tif(!x) return; \n\tif(!pos)\n\t{\n\t\tif(!type)\n\t\t\tfor(int i = 1; i <= x; i++) cnt[S[i] - 'a' + 1] += op; \n\t\telse if(type == 1)\n\t\t\tfor(int i = Pos + 1; i <= Pos + x; i++) cnt[S[i] - 'a' + 1] += op; \n\t\telse for(int i = n / 2 + 1; i <= n / 2 + x; i++) cnt[S[i] - 'a' + 1] += op; \n\t\treturn; \n\t}\n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 2); \n\t}\n\tif(type == 1)\n\t{\n\t\tif(x >= a[pos][0])\n\t\t{\n\t\t\tx -= a[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += a[pos][j] * op; \n\t\t\ttype = 2; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= s[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= s[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos - 1][j] * op; \n\t\t\t\treturn calc(x, op, pos - 1, 2); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 0); \n\t\t}\n\t}\n\tif(type == 2)\n\t{\n\t\tif(x >= b[pos][0])\n\t\t{\n\t\t\tx -= b[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos][j] * op; \n\t\t\ttype = 0; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= b[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= b[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos - 1][j] * op; \n\t\t\t\treturn calc(x, op, pos - 1, 0); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 2); \n\t\t}\n\t}\n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 2); \n\t}\n}\n\nvoid solve(ll L, ll R, int id) { calc(R, 1, id, 0), calc(L - 1, -1, id, 0); }\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin), freopen(\"cpp.out\", \"w\", stdout); \n#endif\n\tscanf(\"%s\", S + 1), n = strlen(S + 1); \n\tprepare(), L = read <ll> (), R = read <ll> (); \n\tfor(int i = 1; i <= 92; i++)\n\t{\n\t\tfor(int j = 0; j <= 26; j++)\n\t\t\ts[i][j] = b[i - 1][j], b[i][j] = b[i - 1][j] + s[i - 1][j], a[i][j] = s[i - 1][j] + b[i - 1][j];\n\t\tif(1.0 * -R + s[i][0] + a[i][0] + b[i][0] + s[i][0] >= 0)\n\t\t{\n\t\t\tsolve(L, R, i); break;\n\t\t}\n\t}\n\tfor(int i = 1; i <= 26; i++) printf(\"%lld%c\", cnt[i], i == 26 ? '\\n' : ' '); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/*\n * Z algorithm. Calculates an array a[i] = |lcp(s, s[i...|s|])|,\n * where s is the given string.\n * If n = s.length(), the returned array has length n + 1.\n * E.g. z_algorithm(\"ababa\") = {5, 0, 3, 0, 1, 0}\n * Reference: http://snuke.hatenablog.com/entry/2014/12/03/214243\n * Header Requirement: vector, string\n * Verified by: AtCoder ARC055-C (http://arc055.contest.atcoder.jp/submissions/950597)\n */\nstd::vector<int> z_algorithm(const std::string &s) {\n  int n = s.length();\n  std::vector<int> ret(n + 1);\n  ret[0] = n;\n  for (int i = 1, j = 0; i < n;) {\n    for (; i + j < n && s[j] == s[i + j]; ++j) {}\n    ret[i] = j;\n    if (j == 0) { ++i; continue; }\n    int k = 1;\n    for (; i + k < n && k + ret[k] < j; ++k) {\n      ret[i + k] = ret[k];\n    }\n    i += k; j -= k;\n  }\n  return ret;\n}\n\n\nvoid experiment(string s) {\n  REP(i, 0, 10) {\n    int n = s.length();\n    int v = -1;\n    REP(i, (n + 2) / 2, n + 1) {\n      if (s.substr(i) == s.substr(0, n - i)) {\n\tv = i;\n\tbreak;\n      }\n    }\n    assert (v >= 0);\n    s = s + s.substr(n - v, v - (n - v));\n    cerr << \"[\" << n - v << \", \" << v << \")\" << endl;\n    cerr << \"len \" << n << \" -> \" << 2 * v << endl;\n  }\n}\nVL rec(const string &sa, const string &sb, VL &fib, VL &lfib, int v,\n       ll x, ll &a, ll &b) {\n  if (lfib[v] <= x) {\n    a += fib[v];\n    b += fib[v + 1];\n    return VL(26, 0);\n  }\n  VL ret(26, 0);\n  if (v <= 1) {\n    const string &s = v == 0 ? sa : sb;\n    REP(i, 0, x) {\n      ret[s[i] - 'a'] += 1;\n    }\n    return ret;\n  }\n  if (x < lfib[v - 1]) {\n    return rec(sa, sb, fib, lfib, v - 1, x, a, b);\n  }\n  rec(sa, sb, fib, lfib, v - 1, x, a, b); // no return\n  return rec(sa, sb, fib, lfib, v - 2, x - lfib[v - 1], a, b);\n}\n\n\nVL calc(const string &s, ll x) {\n  VI zarr = z_algorithm(s);\n  int n = s.length();\n  int k = n; // period\n  REP(i, 1, n) {\n    if (zarr[i] + i >= n) {\n      k = i;\n      break;\n    }\n  }\n  if (n % k == 0) {\n    VL ret(26, 0);\n    REP(i, 0, k) {\n      ll dup = x / k + (i < x % k ? 1 : 0);\n      ret[s[i] - 'a'] += dup;\n    }\n    return ret;\n  }\n  ll a = 0, b = 0;\n  VL fib(2, 0), lfib;\n  {\n    lfib.push_back(k);\n    lfib.push_back(n);\n    fib[0] = 1;\n    while (true) {\n      int len = fib.size();\n      fib.push_back(fib[len - 2] + fib[len - 1]);\n      lfib.push_back(lfib[len - 2] + lfib[len - 1]);\n      if (lfib[len] >= x) {\n\tbreak;\n      }\n    }\n    fib.push_back(fib[fib.size() - 2] + fib[fib.size() - 1]); // additional elem\n  }\n  VL ret = rec(s.substr(0, k), s.substr(0, n), fib, lfib, max(lfib.size() - 1, 1UL), x,\n\t       a, b);\n  \n  REP(i, 0, k) {\n    ret[s[i] - 'a'] += a;\n  }\n  REP(i, 0, n) {\n    ret[s[i] - 'a'] += b;\n  }\n  return ret;\n}\n\nint main(void){\n  string s;\n  cin >> s;\n  ll l, r;\n  cin >> l >> r;\n  l--;\n  {\n    VI zarr = z_algorithm(s);\n    int n = s.length();\n    int v = n;\n    REP(i, (s.length() + 2) / 2, s.length() + 1) {\n      if (zarr[i] + i >= (int) s.length()) {\n\tv = i;\n\tbreak;\n      }\n    }\n    s = s.substr(0, v);\n  }\n  VL t1 = calc(s, r);\n  if (l >= 1) {\n    VL t2 = calc(s, l);\n    REP(i, 0, 26) {\n      t1[i] -= t2[i];\n    }\n  }\n  REP(i, 0, 26) {\n    cout << t1[i] << (i == 25 ? \"\\n\" : \" \");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n;\n\nll l,r;\n\nchar st[maxn];\n\nll Ans[maxn];\n\nll f[maxn],g[maxn];\n\nint fail[maxn];\n\nvoid solve1(ll p,int t){\n\tREP(i,1,n-fail[n])Ans[st[i]-'a']+=p/(n-fail[n])*t;\n\tREP(i,1,p%(n-fail[n]))Ans[st[i]-'a']+=t;\n}\n\nvoid solve2(ll p,int t){\n\tif(p<=n*2){\n\t\tREP(i,1,p)Ans[st[i]-'a']+=t;\n\t\treturn;\n\t}\n\tf[0]=0;g[0]=1;\n\tf[1]=1;g[1]=0;\n\tREP(i,2,10000){\n\t\tf[i]=f[i-1]+f[i-2];\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tif(f[i]*n+g[i]*(n-fail[n])>p){\n\t\t\tREP(j,1,n)Ans[st[j]-'a']+=t*f[i-1];\n\t\t\tREP(j,1,n-fail[n])Ans[st[j]-'a']+=t*g[i-1];\n\t\t\tsolve2(p-f[i-1]*n-g[i-1]*(n-fail[n]),t);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid Work(){\n\tif(!(n%(n-fail[n]))){\n\t\tsolve1(r,1);solve1(l-1,-1);\n\t}\n\telse{\n\t\tsolve2(r,1);solve2(l-1,-1);\n\t}\n\tREP(i,0,25)printf(\"%lld \",Ans[i]);\n}\n\nvoid Init(){\n\tscanf(\"%s\",st+1);\n\tread(l,r);\n\tn=strlen(st+1)/2;\n\tREP(i,2,n){\n\t\tint j;\n\t\tfor(j=fail[i-1];j&&st[j+1]!=st[i];j=fail[j]);\n\t\tif(st[j+1]==st[i])fail[i]=j+1;\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 1e6 + 10;\nconst int M = 26;\n\nchar s[maxn];\nint next[maxn];\n\nstruct Node\n{\n\tLL cnt[M];\n\tNode() { memset(cnt, 0, sizeof cnt); }\n\tvoid operator += (const Node &a)\n\t{\n\t\tfor (int i = 0; i < M; ++ i)\n\t\t\tcnt[i] += a.cnt[i];\n\t}\n\tNode operator + (const Node &a) const\n\t{\n\t\tNode res;\n\t\tfor (int i = 0; i < M; ++ i)\n\t\t\tres.cnt[i] = cnt[i] + a.cnt[i];\n\t\treturn res;\n\t}\n\tNode operator - (const Node &a) const\n\t{\n\t\tNode res;\n\t\tfor (int i = 0; i < M; ++ i)\n\t\t\tres.cnt[i] = cnt[i] - a.cnt[i];\n\t\treturn res;\n\t}\n\tvoid Putout()\n\t{\n\t\tfor (int i = 0; i < M - 1; ++ i) printf(\"%lld \", cnt[i]);\n\t\tprintf(\"%lld\\n\", cnt[M - 1]);\n\t}\n} sum[maxn];\n\nNode Calc(int len, LL n)\n{\n\tLL x = len, y = len + (len - next[len]);\n\tif (n <= x) return sum[n];\n\tif (n <= y) return sum[len] + sum[n - len];\n\tNode a = sum[len], b = sum[len] + sum[len - next[len]];\n\twhile (n >= x + y)\n\t{\n\t\tb += a;\n\t\ta = b - a;\n\t\ty += x;\n\t\tx = y - x;\n\t}\n\treturn b + Calc(len, n - y);\n}\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1) / 2;\n\tnext[1] = 0;\n\tsum[1].cnt[s[1] - 'a'] = 1;\n\tfor (int i = 2; i <= n; ++ i)\n\t{\n\t\tint j = next[i - 1];\n\t\twhile (j && s[j + 1] != s[i]) j = next[j];\n\t\tnext[i] = j + (s[j + 1] == s[i]);\n\t\tsum[i].cnt[s[i] - 'a'] = 1;\n\t\tsum[i] += sum[i - 1];\n\t}\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tNode res = Calc(n, r) - Calc(n, l - 1);\n\tres.Putout();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define b 31ll\n#define mod 1004535809ll\n#define ll long long\nusing namespace std;\nchar s[400005];\nll l[1005],fib[1005][27],ans[27];\nll has[400005],m[400005],lo,hi;\nint len,t;\ninline ll get(int l,int r)\n{if (l>r) return 0;\nll ret=(has[r]-has[l-1]*m[r-l+1])%mod;\nreturn (ret<0?ret+mod:ret);\n}\ninline void add(ll p,int pos)\n{if (pos<=1)\n{for (int i=1;i<=p;i++)\n{ans[s[(i-1)%len+1]-'a']++;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]+=fib[pos-1][i];\nadd(p-l[pos-1],pos-2);\nreturn;\n}\nadd(p,pos-1);\n}\ninline void del(ll p,int pos)\n{if (pos<=1)\n{for (int i=1;i<=p;i++)\n{ans[s[(i-1)%len+1]-'a']--;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]-=fib[pos-1][i];\ndel(p-l[pos-1],pos-2);\nreturn;\n}\ndel(p,pos-1);\n}\nint main (){\n\tint i,j,las;\n\tscanf (\"%s\",s+1);len=strlen(s+1);\n\tscanf (\"%lld%lld\",&lo,&hi);\n\tm[0]=1ll;len>>=1;\n\tfor (i=1;i<=len;i++)\n\t{m[i]=m[i-1]*b%mod;\n\thas[i]=has[i-1]*b+(s[i]-'0');\n\thas[i]%=mod;\n\t}\n\tfor (i=1;i<=len;i++)\n\t{if (get(1,len-i)==get(i+1,len))\n\t{t=i;break;}\n\t}\n\tl[0]=len;l[1]=len+t;\n\tfor (i=1;i<=len;i++)\n\t{fib[0][s[i]-'a']++;\n\tfib[1][s[i]-'a']++;\n\t}\n\tfor (i=1;i<=t;i++)\n\t{fib[1][s[i]-'a']++;}\n\tfor (i=2;l[i-2]+l[i-1]<=2ll*hi;i++)\n\t{for (j=0;j<26;j++)\n\t{fib[i][j]=fib[i-1][j]+fib[i-2][j];}\n\tl[i]=l[i-1]+l[i-2];\n\tlas=i;\n\t}\n\tadd(hi,las);del(lo-1,las);\n\tfor (i=0;i<26;i++)\n\t{printf (\"%lld \",ans[i]);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[880008],sz,pos,g,cnt[26][200022],p[26][400044],q[26][800088];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[800088];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nlong long l,r;\nint p;\nint n;\nint f[100005];\nlong long num[200010][26];\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n//\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tif(n%p==0)\n\t{\n\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n\t\tx%=(long long)p;\n\t\txx+=num[x][y];\n\t\treturn xx;\n\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size()/2;\n\ts=s.substr(0,n);\n\ts=\" \"+s;\n\tf[1]=0;\n\tfor(int i=2,j=0;i<=n;i++)\n\t{\n\t\twhile(s[i]!=s[j+1]&&j>0)j=f[j];\n\t\tj+=(s[i]==s[j+1]);\n\t\tf[i]=j;\n\t}\n//\tcout<<f[0]<<f[1]<<f[2]<<f[3]<<endl;\n\tp=n-f[n];\n//\tcout<<p<<endl;\n//\tp=n-p;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]+=num[i-1][j];\n\t\tnum[i][s[i]-'a']++;\n\t}\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define max(x, y) ((x) > (y) ? (x) : (y))\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\nstruct C {\n\tlong long sum[26];\n\tlong long s;\n\tC() {\n\t\tmemset(sum, 0, sizeof sum);\n\t\ts = 0;\n\t}\n} F[1100];\n\nC operator * (C x, long long y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] *= y;\n\tx.s *= y;\n\treturn x;\n}\n\nC operator + (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] += y.sum[i];\n\tx.s += y.s;\n\treturn x;\n}\n\nC operator - (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] -= y.sum[i];\n\tx.s -= y.s;\n\treturn x;\n}\n\nint len;\nint n;\nchar S[210000];\nint ne[210000];\n\nC query(int k, long long l, long long r) {\n\t// printf(\"?? %d %lld %lld\\n\", k, l, r);\n\tif (k <= 1) {\n\t\tif (k == 0) {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, n - ne[n]);\n\t\t}else {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, n);\n\t\t}\n\t\tC ans;\n\t\tmemset(ans.sum, 0, sizeof ans.sum);\n\t\tans.s = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1, ans.s += 1;\n\t\treturn ans;\n\t}\n\tif (l <= 1 && r >= F[k].s)\n\t\treturn F[k];\n\tif (r <= F[k - 1].s)\n\t\treturn query(k - 1, l, r);\n\telse if (l > F[k - 1].s)\n\t\treturn query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n\telse\n\t\treturn query(k - 1, l, r) + query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n}\n\nint main() {\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\tint p = 0;\n\tne[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (; p && S[p + 1] != S[i]; p = ne[p]);\n\t\tif (S[p + 1] == S[i])\n\t\t\tp ++;\n\t\tne[i] = p;\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r;\n\tif (ne[n] * 2 >= n) {\n\t\tint c = n - ne[n];\n\t\tC pp;\n\t\tfor (int i = 1; i <= c; i++)\n\t\t\tpp.sum[S[i] - 'a'] += 1, pp.s += 1;\n\t\tC ans = pp * (r / c);\n\t\tfor (int i = 1; i <= r % c; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1;\n\t\tl -= 1;\n\t\tans = ans - (pp * (l / c));\n\t\tfor (int i = 1; i <= l % c; i++)\n\t\t\tans.sum[S[i] - 'a'] -= 1;\n\t\tfor (int i = 0; i < 25; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"%lld\\n\", ans.sum[25]);\n\t}else {\n\t\tlen = 1;\n\t\tfor (int i = 1; i <= n - ne[n]; i++)\n\t\t\tF[0].sum[S[i] - 'a'] += 1, F[0].s += 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tF[1].sum[S[i] - 'a'] += 1, F[1].s += 1;\n\t\twhile (F[len].s <= 1000000000000000000LL) {\n\t\t\tF[len + 1] = F[len] + F[len - 1];\n\t\t\tlen += 1;\n\t\t}\n\t\tC ans = query(len, l, r);\n\t\tfor (int i = 0; i < 25; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"%lld\\n\", ans.sum[25]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<ll> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=2e5+7;\n// z[i] = len of lcp of s, s[i..]; lcp(longest common prefix)\nint z[maxn];\nvoid z_fn(const string& s) {\n    int n = s.size();\n    for(int i=0;i<n;i++) z[i]=0;\n    for (int i = 1, l = 0, r = 0; i < n; i++) \n    {\n        if (i <= r)\n            z[i] = min(r-i+1, z[i-l]);\n        while (i+z[i] < n && s[z[i]] == s[i+z[i]]) \n            z[i]++;\n        if (i+z[i]-1 > r) \n        {\n            l = i;\n            r = i+z[i]-1;\n        }\n    }\n}\nint p;\nstring t;\nvi getans(ll x)\n{\n    string T(t.begin(),t.begin()+p);\n    vi u(26);\n    vi ret(26);\n    for(auto v:T) u[v-'a']++;\n    for(int i=0;i<min(x,(ll)t.length());i++) ret[t[i]-'a']++;\n    if(x>t.length()){\n        x-=t.length();\n        ll tt=x/p;\n        for(int i=0;i<26;i++) ret[i]+=u[i]*tt;\n        for(int i=0;i<x%p;i++)\n            ret[T[i]-'a']++;\n    }\n    return ret;\n}\nll cnt[102][26];\nll len[102];\nvi getans2(ll x)\n{\n    vi ret(26);\n    for(int i=100;i>=0;i--)\n    {\n        if(x>=len[i])\n        {\n            for(int j=0;j<26;j++)\n                ret[j]+=cnt[i][j];\n            x-=len[i];\n        }\n    }\n    for(int i=0;i<x;i++) ret[t[i]-'a']++;\n    return ret;\n}\nint main()\n{\n    string s;\n    cin>>s;\n    t=string(s.begin(),s.begin()+s.length()/2);\n    z_fn(t);\n    p=t.length();\n    for(int i=1;i<t.length();i++)\n    {\n        if(z[i]==t.length()-i)\n        {\n            p=i;\n            break;\n        }\n    }\n    ll l,r;\n    cin>>l>>r;\n    l;r;\n    vi L,R;\n    if(t.length()%p==0)\n    {\n        R=getans(r);\n        L=getans(l-1);\n    }\n    else{\n        for(int i=0;i<p;i++) cnt[0][t[i]-'a']++;\n        len[0]=p;\n        len[1]=t.length();\n        for(int i=0;i<t.length();i++) cnt[1][t[i]-'a']++;\n        for(int i=2;i<100;i++)\n        {\n            for(int j=0;j<26;j++)\n                cnt[i][j]=min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n            len[i]=min(1LL<<60,len[i-1]+len[i-2]);\n        }\n        R=getans2(r);\n        L=getans2(l-1);\n    }\n    for(int i=0;i<26;i++) R[i]-=L[i];\n    print(R);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.11.2019 02:41:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> kmp_table(int n, const T &s) {\n  vector<int> p(n, 0);\n  int k = 0;\n  for (int i = 1; i < n; i++) {\n    while (k > 0 && !(s[i] == s[k])) {\n      k = p[k - 1];\n    }\n    if (s[i] == s[k]) {\n      k++;\n    }\n    p[i] = k;\n  }\n  return p;\n}\n\ntemplate <typename T>\nvector<int> kmp_table(const T &s) {\n  return kmp_table((int) s.size(), s);\n}\n\ntemplate <typename T>\nvector<int> kmp_search(int n, const T &s, int m, const T &w, const vector<int> &p) {\n  assert(n >= 1 && (int) p.size() == n);\n  vector<int> res;\n  int k = 0;\n  for (int i = 0; i < m; i++) {\n    while (k > 0 && (k == n || !(w[i] == s[k]))) {\n      k = p[k - 1];\n    }\n    if (w[i] == s[k]) {\n      k++;\n    }\n    if (k == n) {\n      res.push_back(i - n + 1);\n    }\n  }\n  return res;\n  // returns 0-indexed positions of occurrences of s in w\n}\n\ntemplate <typename T>\nvector<int> kmp_search(const T &s, const T &w, const vector<int> &p) {\n  return kmp_search((int) s.size(), s, (int) w.size(), w, p);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  if (s.size() == 1) s += s;\n  long long L, R;\n  cin >> L >> R;\n  vector<int> pers;\n  vector<string> sss(1, s);\n  while (true) {\n    vector<int> p = kmp_table(s);\n    int n = (int) s.size();\n    int x = p[n - 1];\n    while (x >= n / 2) {\n      x = p[x - 1];\n    }\n    s += s.substr(x, n - 2 * x);\n    pers.push_back(n - x);\n    debug(s, pers);\n    sss.push_back(s);\n    if (pers.size() == 1) break;\n  }\n  string A = sss[0];\n  string B = sss[1];\n  vector<long long> len(2);\n  vector<vector<long long>> cnt(2, vector<long long>(26));\n  for (char c : A) {\n    len[0] += 1;\n    cnt[0][c - 'a'] += 1;\n  }\n  for (char c : B) {\n    len[1] += 1;\n    cnt[1][c - 'a'] += 1;\n  }\n  while (len.back() < R) {\n    len.push_back(len.back() + len[len.size() - 2]);\n    cnt.emplace_back(26, 0);\n    for (int i = 0; i < 26; i++) cnt.back()[i] = cnt[cnt.size() - 3][i] + cnt[cnt.size() - 2][i];\n  }\n  vector<long long> res(26);\n  function<void(long long, long long)> Fun = [&](long long L, long long R) {\n    int id = 0;\n    while (len[id] < R) {\n      ++id;\n    }\n    if (id == 0) {\n      for (int i = L; i <= R; i++) res[A[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (id == 1) {\n      for (int i = L; i <= R; i++) res[B[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (L == 1 && R == len[id]) {\n      for (int i = 0; i < 26; i++) res[i] += cnt[id][i];\n      return;\n    }\n    if (L > len[id - 1]) {\n      Fun(L - len[id - 1], R - len[id - 1]);\n    } else {\n      Fun(L, len[id - 1]);\n      Fun(1, R - len[id - 1]);\n    }\n  };\n  Fun(L, R);\n  for (int i = 0; i < 26; i++) cout << res[i] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 200006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nint n,p,t,v[26],height[N],sa[N],fuckyouatcoder[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\ninline int read()\n{\n\tint x=0,c=getchar(),f=1;while(c<'0'||c>'9')f=(c=='-'?-f:f),c=getchar();\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+c-48,c=getchar();return f>0?x:-x;\n}\nvoid print(long long x)\n{\n\tif(x>9)print(x/10);putchar(x%10+48);\n}\nvoid SA()\n{\n\tfor(int i=1;i<=n;i++)cntA[(int)s[i]]++;\n\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(int i=n;i;i--)sa[cntA[(int)s[i]]--]=i;\n\tfuckyouatcoder[sa[1]]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t}\n\tfor(int l=1;fuckyouatcoder[sa[n]]!=n;l<<=1){\n\t\tfor(int i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcntA[A[i]=fuckyouatcoder[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?fuckyouatcoder[i+l]:0)]++;\n\t\t}\n\t\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(int i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(int i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\tfuckyouatcoder[sa[1]]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t\t}\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[fuckyouatcoder[i]-1]+tot])tot++;\n\t\theight[fuckyouatcoder[i]]=tot;\n\t}\n\tp=n;int mi=N;\n\tfor(int i=fuckyouatcoder[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(int i=fuckyouatcoder[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(int w,int F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(int i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(int i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(int i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(int i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(int i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(int i=(l-n)%p;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(int i=1;i<=r%p;i++)a[s[i]-97]++;\n\t\t\tfor(int i=0;i<26;i++)a[i]+=1LL*v[i]*(r/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(int i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(int i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(int i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(int i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "//Z Algorithm\n#include<cstdio>\n#include<cstring>\n#include<valarray>\nusing namespace std;\npair<valarray<long long>,long long> f(long long n,long long l,const valarray<long long> &left,long long r,const valarray<long long> &right)\n{\n\tvalarray<long long> ans(26);\n\tif(l+r<=n)\n\t{\n\t\tauto x=f(n,l+r,left+right,l,left);\n\t\tans+=x.first;\n\t\tn=x.second;\n\t}\n\tif(l<=n)ans+=left,n-=l;\n\treturn make_pair(ans,n);\n}\nchar s[300000];\nlong long cnt[300000][30],z[300000],n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tz[1]=n;\n\tlong long l=1,r=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tif(i>r)\n\t\t{\n\t\t\tz[i]=0;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tif(z[i])l=i,r=i+z[i]-1;\n\t\t}\n\t\telse if(z[i-l+1]<r-i+1)z[i]=z[i-l+1];\n\t\telse\n\t\t{\n\t\t\tz[i]=r-i+1;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tl=i,r=i+z[i]-1;\n\t\t}\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tfor(long long j=0;j<26;j++)cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tlong long k=0;\n\tfor(long long i=n;i+i>n;i--)\n\t\tif(z[i]+i-1==n)k=z[i];\n\tscanf(\"%lld%lld\",&l,&r);l--;\n\tif(!k)\n\t{\n\t\tfor(long long i=0;i<26;i++)printf(\"%lld \",cnt[n][i]*(r/n)+cnt[r%n][i]-cnt[n][i]*(l/n)-cnt[l%n][i]);\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\tvalarray<long long> left(26),right(26);\n\tfor(long long i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(long long i=0;i<26;i++)printf(\"%lld \",upper.first[i]-lower.first[i]+cnt[upper.second][i]-cnt[lower.second][i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\ninline void work(ll r){\n\tif (r<n) for (int i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tll _s=0,_t=1,S=1,T=0;\n\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\twork(r-_s*n-_t*k);\n\t\tfor (int i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\tfor (int i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (int i=1;i<n;i++){\n\t\tint j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (int i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (int i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\nll len[1001], cnt[1001][26];\nint cntS[200001][26], cntX[400001][26];\nvector<int> Z_algo(string &s) {\n\tint n = s.size();\n\tvector<int> z(n);\n\tint L = 0, R = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i > R) {\n\t\t\tL = R = i;\n\t\t\twhile (R < n && s[R - L] == s[R]) R++;\n\t\t\tz[i] = R - L; R--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - L;\n\t\t\tif (z[k] < R - i + 1) z[i] = z[k];\n\t\t\telse {\n\t\t\t\tL = i;\n\t\t\t\twhile (R < n && s[R - L] == s[R]) R++;\n\t\t\t\tz[i] = R - L; R--;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nll solve(int k, int ch, ll L) {\n\tif (L > len[k]) return cnt[k][ch] + solve(k, ch, L - len[k]);\n\tif (L == len[k]) return cnt[k][ch];\n\tif (k == 0) return cntS[L][ch];\n\tif (k == 1) return cntX[L][ch];\n\tif (L > len[k - 1]) return cnt[k - 1][ch] + solve(k - 2, ch, L - len[k - 1]);\n\treturn solve(k - 1, ch, L);\n}\nint main() {\n\tstring S;\n\tcin >> S;\n\tll l, r;\n\tcin >> l >> r;\n\tS = S.substr(0, S.size() / 2);\n\tvector<int> z = Z_algo(S);\n\tint k = 1;\n\twhile (k < S.size()) {\n\t\tif (S.size() - k == z[k]) break;\n\t\tk++;\n\t}\n\tif (k == 0) k = S.size();\n\tstring T = S.substr(0, k);\n\tstring X = S + T;\n\tlen[0] = S.size();\n\tlen[1] = X.size();\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tfor (int j = 0; j < 26; j++) cntS[i + 1][j] += cntS[i][j];\n\t\tcntS[i + 1][S[i] - 'a']++;\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < 26; j++) cntX[i + 1][j] += cntX[i][j];\n\t\tcntX[i + 1][X[i] - 'a']++;\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tcnt[0][i] = cntS[S.size()][i];\n\t\tcnt[1][i] = cntX[X.size()][i];\n\t}\n\tk = 0;\n\twhile (len[k] * 2 < r) {\n\t\tif (k > 0) {\n\t\t\tlen[k + 1] = len[k] + len[k - 1];\n\t\t\tfor (int i = 0; i < 26; i++) cnt[k + 1][i] = cnt[k][i] + cnt[k - 1][i];\n\t\t}\n\t\tk++;\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tcout << solve(k, i, r) - solve(k, i, l - 1) << \" \";\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst ll  inf=1e18;\nconst int maxn=1e2+10;\nchar s[maxn];int n,lst,nxt[maxn],pre[maxn][26];\nll l,r,cutpos,ans[26],cnt[maxn],f[maxn][26];\nll read(){\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(ll x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(ll x){print(x);putchar(' ');}\nvoid get_nxt(){\n    nxt[1]=0;\n    for(int i=2,j;i<=n;i++){\n        j=nxt[i-1];\n        while(j&&s[j+1]!=s[i])j=nxt[j];\n        nxt[i]=s[j+1]==s[i]?j+1:0;\n    }\n}\nvoid cal1(ll x,ll v){\n    if(x<=0)return ;ll tmp=x/cutpos;\n    for(int i=0;i<26;i++)ans[i]+=v*tmp*pre[cutpos][i];\n    tmp=x%cutpos;\n    for(int i=0;i<26;i++)ans[i]+=v*pre[tmp][i];\n}\nvoid get_fib(){\n    cnt[1]=n;\n    for(int i=1;i<=n;i++){f[1][s[i]-'a']++;f[2][s[i]-'a']++;}\n    cnt[2]=n+cutpos;\n    for(int i=0;i<26;i++)f[2][i]+=pre[cutpos][i];\n    for(int i=3;;i++){\n        for(int j=0;j<26;j++)f[i][j]=f[i-2][j]+f[i-1][j];\n        cnt[i]=cnt[i-2]+cnt[i-1];if(cnt[i]>inf){lst=i;break;}\n    }\n}\nvoid cal2(ll x,ll v){\n    for(int i=lst;i>=1;i--)\n        if(cnt[i]<=x){\n            x-=cnt[i];\n            for(int j=0;j<26;j++)ans[j]+=v*f[i][j];\n        }\n    for(int i=0;i<26;i++)ans[i]+=v*pre[x][i];\n}\nint main(){\n    scanf(\"%s\",s+1);l=read();r=read();n=strlen(s+1);n>>=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<26;j++)pre[i][j]+=pre[i-1][j];\n        pre[i][s[i]-'a']++;\n    }get_nxt();cutpos=n-nxt[n];\n    if(!n%cutpos){cal1(r,1);cal1(l-1,-1);}\n    else {get_fib();cal2(r,1);cal2(l-1,-1);}\n    for(int i=0;i<26;i++)write(ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[880008],sz,pos,g,cnt[26][200022],p[26][400044],q[26][800088];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[800088];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\telse if (pos/2<=sq) return q[a][sq-1]+q[a][pos-sq-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos/2-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t\tif (re<0)\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tre=pos-pos/2+re;\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz/2;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz/2;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*if (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}*/\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 200009\nusing namespace std;\n\nint n,len,f[N]; ll l,r,ans[26]; char s[N];\nint calc1(ll m,int p){\n\tint i,t=m%n; m/=n;\n\tfor (i=1; i<=n; i++) ans[s[i]-'a']+=p*m;\n\tfor (i=1; i<=t; i++) ans[s[i]-'a']+=p;\n}\nvoid calc2(ll m,int p){\n\tint i;\n\tif (m<=(n<<1)){\n\t\tfor (i=1; i<=m; i++) ans[s[i]-'a']+=p;\n\t\treturn;\n\t}\n\tll x=n,y=f[n],A=1,B=1,a=1,b=0;\n\tfor (; (x<<1)<=m; y=x-y,x+=y){\n\t\ta=A-a; b=B-b;\n\t\tA+=a; B+=b;\n\t}\n\tfor (i=1; i<=f[n]; i++) ans[s[i]-'a']+=A*p;\n\tfor (i=f[n]+1; i<=n; i++) ans[s[i]-'a']+=B*p;\n\tcalc2(m-x,p);\n}\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1)>>1;\n\tint i;\n\tfor (i=2; i<=n; i++){\n\t\tf[i]=f[i-1];\n\t\tfor (; f[i] && s[i]!=s[f[i]+1]; f[i]=f[f[i]]);\n\t\tif (s[i]==s[f[i]+1]) f[i]++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tif (!(n%(n-f[n]))){\n\t\tn-=f[n];\n\t\tcalc1(r,1); calc1(l-1,-1);\n\t} else{\n\t\tcalc2(r,1); calc2(l-1,-1);\n\t}\n\tfor (i=0; i<26; i++) printf(\"%lld%c\",ans[i],(i<25)?' ':'\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nconst ll b = 2;//1342231LL;\n\nconst int mx = 2e5;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tvector<ll> pw(mx);\n\tpw[0] = 1;\n\trep(i,1,mx) pw[i] = pw[i-1]*b % md;\n\n\tstring s;\n\tcin >> s;\n\tint n = sz(s)/2;\n\tstring a = s.substr(0, n);\n\n\tvector<ll> pre(n+1);\n\trep(i,0,n) pre[i+1] = (pre[i]*b + a[i])%md;\n\n\tint len;\n\tfor(len = n; len --> 0;){\n\t\tif((pre[n]-pre[n-len]*pw[len]%md - pre[len])%md == 0)\n\t\t\tbreak;\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\n\tvector<ll> fibs(200);\n\tfibs[0] = len, fibs[1] = n-len;\n\trep(i,2,200) fibs[i] = fibs[i-1] + fibs[i-2];\n\n\tvector<vector<ll>> cnts(200, vector<ll>(26));\n\trep(i,0,26) cnts[0][i] = count(a.begin(),a.begin()+len, 'a'+i);\n\trep(i,0,26) cnts[1][i] = count(a.begin()+len,a.end(), 'a'+i);\n\trep(i,2,200) rep(j,0,26) cnts[i][j] = cnts[i-1][j]+cnts[i-2][j];\n\n\tfunction<ll(ll,int,int)> que = [&](ll pos, int c, int ix){\n\t\tassert(fibs[ix] >= pos);\n\t\tif(ix == 0){\n\t\t\treturn (ll)count(a.begin(),a.begin()+pos, 'a'+c);\n\t\t}\n\t\tif(ix == 1){\n\t\t\treturn (ll)count(a.begin()+len,a.begin()+len+pos, 'a'+c);\n\t\t}\n\t\tif(pos <= fibs[ix-2]) return que(pos, c, ix-2);\n\t\treturn cnts[ix-2][c] + que(pos-fibs[ix-2],c,ix-1);\n\t};\n\n\tfunction<ll(ll,int)> f = [&](ll pos, int c){\n\t\tint i = 2;\n\t\twhile(fibs[i] < pos) ++i;\n\t\treturn que(pos, c, i);\n\t};\n\trep(c,0,26){\n\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef __int128 INT;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\n\nV kmp_table_build(string word){\n    int n=word.size();\n    V table(n+1,0);\n    table[0]=-1;\n    for(int i=2,j=0;i<=n;){\n        if(word[i-1]==word[j])table[i++]=++j;\n        else if(j>0)j=table[j];\n        else table[i++]=0;\n    }\n    return table;\n}\n\nV f(string s,INT k){\n    LL x=s.size();\n    V ret(26,0);\n    LL loop=k/x;\n    for(auto &it:s)ret[it-'a']+=loop;\n    k-=loop*x;\n    REP(i,k)ret[s[i]-'a']++;\n    return ret;\n}\nV g(string &s1,VV &c,vector<INT> &l,INT k,int id){\n    cout<<id<<\" \"<<(int)k<<endl;\n    if(k==0)return V(26,0);\n    if(id<=1){\n        V ret(26,0);\n        REP(i,k)ret[s1[i]-'a']++;\n        return ret;\n    }\n    if(l[id-1]<=k){\n        V ret=c[id-1];\n        V rest=g(s1,c,l,k-l[id-1],id-2);\n        REP(i,26)ret[i]+=rest[i];\n        return ret;\n    }\n    else return g(s1,c,l,k,id-1);\n}\n\nint main(){\n    string s;LL l,r;\n    cin>>s>>l>>r;\n    LL n=s.size()/2;\n    s=s.substr(0,n);\n    V table=kmp_table_build(s);\n    LL x=n-table[n];\n    if(n%x==0){\n        s=s.substr(0,x);\n        auto a=f(s,r);\n        auto b=f(s,l-1);\n        REP(i,26)cout<<\" \"+(!i)<<a[i]-b[i];cout<<endl;\n    }\n    else{\n        VV cnt(128,V(26,0));\n        vector<INT> len(128);\n        REP(i,n)cnt[0][s[i]-'a']++;\n        len[0]=n;\n        len[1]=n+x;\n        cnt[1]=cnt[0];\n        REP(i,x)cnt[1][s[i]-'a']++;\n        int id=-1;\n        FOR(i,2,128){\n            len[i]=len[i-1]+len[i-2];\n            //cout<<i<<\":\"<<(int)len[i]<<endl;\n                        \n            REP(j,26)cnt[i][j]+=cnt[i-1][j]+cnt[i-2][j];\n            if(len[i]>r){\n                id=i;\n                break;\n            }\n        }\n        s=s+s.substr(0,x);\n        auto a=g(s,cnt,len,r,id);\n        auto b=g(s,cnt,len,l-1,id);\n        REP(i,26)cout<<\" \"+(!i)<<a[i]-b[i];cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tvector<lint> dap(26);\n\tif(s % t == 0){\n\t\tfor(int i=0; i<s && i < p; i++){\n\t\t\tdap[str[i] - 'a']++;\n\t\t}\n\t\tp = max(p - s, 0ll);\n\t\tfor(int i=0; i<t; i++){\n\t\t\tdap[str[s + i] - 'a'] += p / t;\n\t\t\tif(p % t > i) dap[str[s + i] - 'a']++;\n\t\t}\n\t}\n\telse{\n\t\tdp[0] = s;\n\t\tdp[1] = t;\n\t\tvector<int> v;\n\t\tfor(int i=0; i<s; i++){\n\t\t\tcnt[0][str[i] - 'a']++;\n\t\t}\n\t\tfor(int i=0; i<t; i++){\n\t\t\tcnt[1][str[i + s] - 'a']++;\n\t\t}\n\t\tfor(int i=2; i<100; i++){\n\t\t\tfor(int j=0; j<26; j++){\n\t\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t\t}\n\t\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\t\tif(dp[i] >= p){\n\t\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\t\tif(p >= dp[j]){\n\t\t\t\t\t\tp -= dp[j];\n\t\t\t\t\t\tv.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(auto &i : v){\n\t\t\tfor(int j=0; j<26; j++){\n\t\t\t\tdap[j] += cnt[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = fail[n / 2];\n\tint t = n / 2 - s;\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int N=2e6+7;\nchar s[N];\nint f[N],n,n1,n2,n3;\ni64 l,r;\nvoid ext(){\n\tfor(int i=2,j=0;i<=n;++i){\n\t\twhile(j&&s[i]!=s[j+1])j=f[j];\n\t\tif(s[i]==s[j+1])++j;\n\t\tf[i]=j;\n\t}\n\tint p=f[n];\n\twhile(p*2>=n)p=f[p];\n\tmemcpy(s+n-p+1,s+1,n-p);\n\tn+=n-p*2;\n}\nint t[333],ts[2][333];\ni64 ans[333];\nvoid cal1(i64 x,int sgn){\n\tmemset(t,0,sizeof(t));\n\tfor(int i=1;i<=x%n;++i)++t[s[i]];\n\tfor(int i='a';i<='z';++i)ans[i]+=t[i]*sgn;\n\tfor(int i=x%n+1;i<=n;++i)++t[s[i]];\n\tfor(int i='a';i<='z';++i)ans[i]+=t[i]*sgn*(x/n);\n}\nvoid cal1(){\n\tn=n2-n1;\n\tcal1(r,1),cal1(l-1,-1);\n}\ni64 fs[207][2],len[207];\nint mx;\nvoid cal2(i64 x,int sgn){\n\tfor(int i=mx;i>=2;--i)if(len[i]<=x){\n\t\tx-=len[i];\n\t\tfor(int j='a';j<='z';++j)ans[j]+=sgn*(fs[i][0]*ts[0][j]+fs[i][1]*ts[1][j]);\n\t}\n\tcal1(x,sgn);\n}\nvoid cal2(){\n\tfor(int i=1;i<=n1;++i)++ts[0][s[i]];\n\tfor(int i=n1+1;i<=n2;++i)++ts[1][s[i]];\n\tlen[0]=n1,len[1]=n2;\n\tfs[0][0]=fs[1][0]=fs[1][1]=1;\n\tmx=1;\n\tdo{\n\t\t++mx;\n\t\tlen[mx]=len[mx-1]+len[mx-2];\n\t\tfs[mx][0]=fs[mx-1][0]+fs[mx-2][0];\n\t\tfs[mx][1]=fs[mx-1][1]+fs[mx-2][1];\n\t}while(len[mx]<r);\n\tcal2(r,1),cal2(l-1,-1);\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1);\n\text();\n\tn1=n;\n\text();\n\tn2=n;\n\text();\n\tn3=n;\n\tif(n2-n1==n3-n2)cal1();\n\telse cal2();\n\tfor(int i='a';i<='z';++i)printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=2e5+5;\nint i,j,c,ne[maxn];\nchar S[maxn];\nll num[maxn][26],l,r,T,n;\nll f(ll len){\n\tif (len<=n) return num[len][c];\n\tif (len<=n*2) return num[n][c]+num[len-n][c];\n\tll f1=num[n][c],f2=num[n][c]+num[T][c],l1=n,l2=n+T;\n\tfor(;len>l1+l2;)swap(f1,f2),f2+=f1,swap(l1,l2),l2+=l1;\n    return f2+f(len-l2);\n}\nll work(ll len){\n\tif (n%T==0) return len/T*num[T][c]+num[len%T][c];\n    return f(len);\n}\nint main(){\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1),n>>=1;\n\tfo(i,1,n) {\n\t\tfo(j,0,25) num[i][j]=num[i-1][j];\n\t\tnum[i][S[i]-'a']++;\n\t}\n\tj=0;\n\tfo(i,2,n){\n\t\tfor(;j&&S[j+1]!=S[i];j=ne[j]);\n\t\tif (S[j+1]==S[i]) j++;\n\t\tne[i]=j;\n\t}\n\tT=n-j;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfo(c,0,25) printf(\"%lld \",work(r)-work(l-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n//f[i] = f[i-1]+f[i-2]\n//or f[i] = f[i-1]+s\nchar s1[200005], s2[400005], s3[800005], s4[1600005], s5[3200005];\nlong long len[105];\nlong long all[105][30];\nlong long cnt[30];\nlong long before[30],after[30];\nint next[3200005];\n\n\nvoid exKmp(char s[],int n,int next[]){\n    int l = 0, r = 0;\n    for(int i = 2; i <= n; i++){\n        if(i>r){\n            l = i, r = i-1;\n            while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n            next[i] = r-l+1;\n        }\n        else{\n            int k = i-l+1;\n            if(i+next[k]-1<r) next[i] = next[k];\n            else{\n                l = i;\n                while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n                next[i] = r-l+1;\n            }\n        }\n    }\n}\n//return new size\nint getNextString(char s[],char t[],int n){\n    exKmp(s,n,next);\n    //for(int i = 1; i <= n; i++) printf(\"next[%d] = %d\\n\",i,next[i]);\n    int find = n+1;\n    for(int i = n/2+2; i <= n; i++){\n        if(next[i]==(n-i+1)){\n            find = i;\n            break;\n        }\n    }\n    int size = 0;\n    for(int rnd = 0; rnd < 2; rnd++){\n        for(int i = 1; i <= find-1; i++) t[++size] = s[i];\n    }\n    t[size+1] = '\\0';\n    return size;\n}\n\nvoid getRegular(long long cycle,long long n,long long upper,long long keep[]){\n    if(upper<=n){\n        for(int i = 1; i <= 26; i++) keep[i] = 0;\n        for(int i = 1; i <= upper; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        for(int i = 1; i <= 26; i++) cnt[i] = 0;\n        for(int i = 1; i <= cycle; i++){\n            int u = s1[i]-'a'+1;\n            cnt[u]++;\n        }\n        long long time = (upper-n)/cycle;\n        long long left = (upper-n)-time*cycle;\n        for(int i = 1; i <= 26; i++) keep[i] = time*cnt[i];\n        for(int i = 1; i <= left; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n        for(int i = 1; i <= n; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n}\n\nvoid getFib(long long upper,long long keep[]){\n    //printf(\"upper = %lld\\n\",upper);\n    if(upper<=len[5]){\n        for(int i = 1; i <= upper; i++){\n            int u = s5[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        int p = 1;\n        while(len[p]<upper) p++;\n        int last = p-1;\n        for(int i = 1; i <= 26; i++) keep[i] += all[last][i];\n        upper -= len[last];\n        getFib(upper,keep);\n    }\n}\n\nint main(){\n    scanf(\"%s\",s1+1);\n    long long l,r;\n    scanf(\"%lld%lld\",&l,&r);\n    int size1 = strlen(s1+1);\n    int size2 = getNextString(s1,s2,size1);\n    int size3 = getNextString(s2,s3,size2);\n    int size4 = getNextString(s3,s4,size3);\n    int size5 = getNextString(s4,s5,size4);\n    //printf(\"size1 = %d, size2 = %d, size3 = %d, size4 = %d\\n\",size1,size2,size3,size4);\n    //printf(\"%s\\n%s\\n%s\\n%s\\n\",s1+1,s2+1,s3+1,s4+1);\n    if((size2-size1)==(size3-size2) && (size4-size3)==(size3-size2)){\n        int cycle = size2-size1;\n        getRegular(cycle,size1,l-1,before);\n        getRegular(cycle,size1,r,after);\n    }\n    else{\n        len[1] = size1, len[2] = size2, len[3] = size3, len[4] = size4, len[5] = size5;\n        for(int i = 1; i <= size1; i++){\n            int u = s1[i]-'a'+1;\n            all[1][u]++;\n        }\n        for(int i = 1; i <= size2; i++){\n            int u = s2[i]-'a'+1;\n            all[2][u]++;\n        }\n        for(int i = 1; i <= size3; i++){\n            int u = s3[i]-'a'+1;\n            all[3][u]++;\n        }\n        for(int i = 1; i <= size4; i++){\n            int u = s4[i]-'a'+1;\n            all[4][u]++;\n        }\n        for(int i = 1; i <= size5; i++){\n            int u = s5[i]-'a'+1;\n            all[5][u]++;\n        }\n        //int find = -1;\n        for(int i = 6; ; i++){\n            len[i] = len[i-1]+len[i-2];\n            for(int j = 1; j <= 26; j++) all[i][j] = all[i-1][j]+all[i-2][j];\n            if(len[i]>=r){ \n                //find = i;\n                break;\n            }\n            //printf(\"len[%d] = %lld\\n\",i,len[i]);\n            //for(int j = 1; j <= 26; j++) printf(\"%lld \",all[i][j]);\n            //printf(\"\\n\");\n        }\n        //for(int i = 1; i <= find; i++) printf(\"len[%d] = %lld\\n\",i,len[i]);\n        getFib(l-1,before);\n        getFib(r,after);\n    }\n    /*for(int i = 1; i <= 26; i++) printf(\"%lld \",before[i]);\n    printf(\"\\n\");\n    for(int i = 1; i <= 26; i++) printf(\"%lld \",after[i]);\n    printf(\"\\n\");*/\n    for(int i = 1; i <= 26; i++) printf(\"%lld \",after[i]-before[i]);\n    printf(\"\\n\");\n    return 0;\n}\n/*\naedcaaedca\n565\n199 0 122 122 122 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n//cnt[a]?\naedcaaedca\n251 565\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include<iomanip>\n#define sqr(x) (x)*(x)\n#define ll long long\nusing namespace std;\nlong long n,m,i,j,z[200005],l,r,dp[200005][35],mx,mx2;\nstring st;\nvoid _z_(string st)\n{\n\tlong long i,l,r;\n\tfor (i=1;i<=st.length();i++)\n\t{\n\t\tif (i<=r)\n\t\t{\n\t\t\tz[i]=min(z[i-l],r-i);\n\t\t}\n\t\twhile (i+z[i]<st.length()&&st[z[i]]==st[i+z[i]]) \n\t\t{\n\t\t\tz[i]++;\n\t\t}\n\t\tif (i>r)\n\t\t{\n\t\t\tl=i;\n\t\t\tr=r+z[i];\n\t\t}\n\t}\n}\nlong long doit(long long x,long long y)\n{\n\tif (x<=st.length()/2)\n\t{\n\t\treturn dp[x][y];\n\t} \n\tif (x<=st.length())\n\t{\n\t\treturn dp[st.length()/2][y]+dp[x-st.length()/2][y];\n\t} \n\tlong long x1=dp[st.length()/2][y]+dp[mx][y];\n\tlong long x2=dp[st.length()/2][y];\n\tlong long l1=st.length()/2+mx;\n\tlong long l2=st.length()/2;\n\twhile (x>l1+l2)\n\t{\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n\treturn x1;\n}\nlong long sol(long long x,long long y)\n{\n\tif(x<=st.length()/2)return dp[x][y];\n\tif(st.length()/2%mx==0)\n\t{\n\t\tlong long xx=x-st.length()/2/(long long)mx*dp[mx][y]+dp[st.length()/2][y];\n\t\tx%=(long long)mx;\n\t\txx+=dp[x][y];\n\t\treturn xx;\n\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>st>>l>>r;\n\t_z_(st);\n\tfor (i=st.length()/2+2;i<st.length();i++)\n\t{\n\t\tif (i+z[i]==st.length()) \n\t\t{\n\t\t\tmx=max(mx,z[i]);\n\t\t}\n\t}\n\tmx=st.length()/2-mx;\n\tfor (i=1;i<=st.length()/2;i++)\n\t{\n\t\tfor (j=0;j<26;j++) dp[i][j]+=dp[i-1][j];\n\t\tdp[i][st[i-1]-'a']++; \n\t}\n\tfor (i=0;i<26;i++) cout<<sol(r,i)-sol(l-1,i)<<' ';\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long int64;\nstatic const int MAXN = 2e5 + 4;\nstatic const int LOGL = 90;\n\nint n, k;   // k = minimum period\nchar s[MAXN];\nint pre[MAXN];\nint s_sum[MAXN][26] = {{ 0 }};\n\nint64 fib[LOGL];\n\nint64 l, r;\nint64 ans[26] = { 0 };\n\nvoid count(int64 r, int mul)\n{\n    if (r <= n) {\n        for (int i = 0; i < 26; ++i) ans[i] += s_sum[r][i] * mul;\n    } else {\n        int i;\n        for (i = 0; fib[i + 1] * n + fib[i] * k <= r; ++i) ;\n        --i;\n        //printf(\"R = %lld | S * %lld + T * %lld + %lld\\n\", r, fib[i + 1], fib[i], r - (fib[i + 1] * n + fib[i] * k));\n        for (int j = 0; j < 26; ++j)\n            ans[j] += (fib[i + 1] * s_sum[n][j] + fib[i] * s_sum[k][j]) * mul;\n        r -= (fib[i + 1] * n + fib[i] * k);\n        count(r, mul);\n    }\n}\n\nint main()\n{\n    scanf(\"%s\", s);\n    n = strlen(s) / 2;\n\n    pre[0] = -1; pre[1] = 0;\n    int last = 0;\n    for (int i = 2; i <= n; ++i) {\n        while (last > 0 && s[last] != s[i - 1]) last = pre[last];\n        if (s[last] != s[i - 1]) pre[i] = 0;\n        else pre[i] = ++last;\n    }\n    k = n - pre[n];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 26; ++j)\n            s_sum[i + 1][j] = s_sum[i][j] + (s[i] == j + 'a');\n    }\n\n    fib[0] = 0; fib[1] = 1;\n    for (int i = 2; i < LOGL; ++i) fib[i] = fib[i - 1] + fib[i - 2];\n\n    scanf(\"%lld%lld\", &l, &r);\n\n    count(r, +1);\n    count(l - 1, -1);\n    for (int i = 0; i < 26; ++i) printf(\"%lld%c\", ans[i], i == 25 ? '\\n' : ' ');\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next NexT\n#define LL long long\n\nconst int maxn=2e5+10;\n\nint n,next[maxn];\nLL L,R,c0[30],cA[30],cB[30],Ans[30],LA,LB;\nchar s[maxn];\n\nvoid KMP()\n{\n\tint i;\n\tnext[0]=0; next[1]=0;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tnext[i]=next[i-1];\n\t\twhile (s[next[i]+1]!=s[i]&&next[i])\n\t\t\tnext[i]=next[next[i]];\n\t\tnext[i]+=s[next[i]+1]==s[i];\n\t}\n}\n\nvoid solve(LL R,int flag)\n{\n\tint i;\n\tif (R<=n)\n\t{\n\t\tfor (i=1;i<=R;i++)\n\t\t\tAns[s[i]-'a']+=flag;\n\t\treturn;\n\t}\n\tLA=next[n];\n\tLB=n-2*next[n];\n\tmemset(cA,0,sizeof(cA));\n\tmemset(cB,0,sizeof(cB));\n\tfor (i=1;i<=LA;i++) cA[s[i]-'a']++;\n\tfor (i=LA+1;i<=LA+LB;i++) cB[s[i]-'a']++;\n\twhile (LA+LB+LA+LA+LB<=R)\n\t{\n\t\tswap(LA,LB); LA+=LB;\n\t\tfor (i=0;i<26;i++)\n\t\t\tswap(cA[i],cB[i]),cA[i]+=cB[i];\n\t}\n\tfor (i=0;i<26;i++)\n\t\tAns[i]+=flag*(cA[i]+cB[i]+cA[i]);\n\tR-=LA+LB+LA;\n\n\tif (!LA||!LB) return;\n\n\twhile (R)\n\t{\n\t\tLA-=LB; swap(LA,LB);\n\t\tfor (i=0;i<26;i++)\n\t\t\tcA[i]-=cB[i],swap(cA[i],cB[i]);\n\t\tif (R>=LA)\n\t\t{\n\t\t\tfor (i=0;i<26;i++)\n\t\t\t\tAns[i]+=flag*cA[i];\n\t\t\tR-=LA;\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i;\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tn=strlen(s+1);\n\tn=n/2;\n\tKMP();\n\tif (n%(n-next[n])==0)\n\t{\n\t\tfor (i=1;i<=n;i++) c0[s[i]-'a']++;\n\t\tfor (i=0;i<26;i++) Ans[i]+=c0[i]*((R/n)-((L-1)/n));\n\t\tfor (i=1;i<=R%n;i++) Ans[s[i]-'a']++;\n\t\tfor (i=1;i<=(L-1)%n;i++) Ans[s[i]-'a']--;\n\t\tfor (i=0;i<26;i++) printf(\"%lld \",Ans[i]);\n\t\treturn 0;\n\t}\n\twhile (next[n]>=(n+1)/2)\n\t\tn+=n-next[n],KMP();\n\nif (n>=maxn) return 1;\n\n\tsolve(R,+1);\n\tsolve(L-1,-1);\n\tfor (i=0;i<26;i++)\n\t\tprintf(\"%lld \",Ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\nconst bool DEBUG = 0;\n/// --- .lumrc Template {{{ ///\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\";\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\";\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n<<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\";\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\";\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\nstring s = ins;\nint n = s.size() / 2;\n\nll ans;\nint k = 0;\nconst int N = 1e6;\narray<ll, 27> cnt[N];\nconst int MAXS = 10000;\narray<ll, 27> SS[MAXS];\nint SSLength;\n\narray<ll, 27> add(array<ll, 27> a, array<ll, 27> b, bool minus = false) {\n  REP(i, 27) {\n    a[i] += b[i] * (minus ? -1 : 1);\n  }\n  return a;\n}\n\narray<ll, 27> solve(ll x) {\n  array<ll,27> res;\n  if(x <= n) {\n    return cnt[x];\n  }\n  array<ll,27> search;\n  search[0] = x;\n  search[1] = LINF;\n\n  int p = lower_bound(SS, SS + SSLength, search) - SS;\n  p--;\n  assert(p>=0);\n  // dump2(x, SS[p][0]);\n  // dump2(p, SSLength);\n  return add(SS[p], solve(x - SS[p][0]));\n}\n\null upow(ull a, ull b) {\n  ull res = 1;\n  while(b) {\n    if(b&1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nconst ull B = 27;\n\nint main() {\n  // ローリングハッシュ法で前半k文字と後半k文字で一致する\n  // ような最大のkを求める\n  dump(2);\n  ull backHash = 0;\n  ull forwardHash = 0;\n  REP(i, n-1) {\n    backHash *= B;\n    backHash += s[i]-'a';\n    forwardHash += upow(B, i) * (s[n-1-i]-'a');\n    if(backHash == forwardHash) k = i + 1;\n  }\n  dump(k);\n  \n  dump(3);\n  ll l=inl, r=inl;\n  dump2(l, s);\n  \n  FOR(i, 1, n+1) {\n    cnt[i] = cnt[i-1];\n    cnt[i][0]++;\n    cnt[i][1+s[i-1]-'a']++;\n  }\n\n  REP(i, n-k) {\n    SS[0][0]++;\n    SS[0][1+s[i]-'a']++;\n  }\n  FOR(i, n-k, n) {\n    SS[1][0]++;\n    SS[1][1+s[i]-'a']++;\n  }\n  dump(4);\n  SSLength = MAXS;\n  FOR(i, 2, MAXS) {\n    REP(j, i-2+1) {\n      SS[i] = add(SS[i], SS[j]);\n      if(SS[i][0]>LINF) {\n        SSLength = i;\n        break;\n      }\n    }\n    if(SSLength!=MAXS) break;\n  }\n  \n  dump(1);\n  dump(r);\n  auto ans = add(solve(r), solve(l-1), true);\n  \n\n  dump(7);\n  REP(i, 26) {\n    cout << ans[i+1] << (i!=int(ans.size()-1)?\" \":\"\\n\");\n  }\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nconst int N=200050;\nusing namespace std;\nint gi(){\n  char ch=getchar(); int x=0,q=0;\n  while(ch<'0' || ch>'9') (ch=='-'?q=1:0),ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q?(-x):x;\n}\nchar s[N];\nint sum[N][26],n,nx[N],cir;\nll calc(ll m,int c){\n  if (m<=n) return sum[m][c];\n  if (n%cir==0)\n    return 1ll*m/cir*sum[cir][c]+sum[m%cir][c];\n  else{\n    ll a=cir,b=n,sa=sum[cir][c],sb=sum[n][c];\n    while(m>=a+b){\n      b+=a,sb+=sa;\n      a=b-a,sa=sb-sa;\n    }\n    return sb+calc(m-b,c);\n  }\n}\nint main(){\n  scanf(\"%s\",s+1);\n  n=strlen(s+1)/2;\n  for (int i=1; i<=n; ++i){\n    for (int j=0; j<26; ++j)\n      sum[i][j]=sum[i-1][j];\n    ++sum[i][s[i]-'a'];\n  }\n  for (int i=2; i<=n; ++i){\n    int j=nx[i-1];\n    while(j&&s[j+1]!=s[i]) j=nx[j];\n    nx[i]=j+(s[j+1]==s[i]);\n  }\n  cir=n-nx[n];\n  ll l,r;\n  cin>>l>>r;\n  for (int i=0; i<26; ++i)\n    printf(\"%lld \",calc(r,i)-calc(l-1,i));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=2e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nclass alphs{\npublic:\n\tarray<llint,26> kaz;\n\talphs(){for(int i=0;i<26;i++){kaz[i]=0;}}\n\talphs& operator +=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]+=other.kaz[i];}\n\t\treturn (*this);\n\t}\n\talphs& operator -=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]-=other.kaz[i];}\n\t\treturn (*this);\n\t}\n};\nvector<llint> retu;\nvector<alphs> mowa;\nstring str;\nstring nxstr;\nvoid retus(void){\n\talphs a=mowa.back();\n\tllint k=retu.back();\n\twhile(-1){\n\t\tk+=retu[retu.size()-2];retu.pub(k);\n\t\ta+=mowa[mowa.size()-2];mowa.pub(a);\n\t\tif(retu.back()>big){return;}\n\t}\n}\nalphs solve(llint x,llint fu){\n\talphs ans;\n\tif(fu==0){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[str[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(fu==1){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[nxstr[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(x<retu[fu-1]){return solve(x,fu-1);}\n\tans=mowa[fu-1];\n\tans+=solve(x-retu[fu-1],fu-2);\n\treturn ans;\n}\n\nint main(void){\n\tllint l,r,n,i,j;//p r p の最初のp\n\tcin>>str;n=str.size();\n\tcin>>l>>r;\n\talphs it;\n\talphs net;\n\tfor(i=0;i<n/2;i++){it.kaz[str[i]-'a']++;}\n\tmowa.pub(it);\n\tretu.pub(n/2);\n\tfor(i=(n/2)+1;i<n;i++){//重ならない数\n\t\tint ok=1;\n\t\tfor(j=0;i+j<n;j++){\n\t\t\tif(str[j]!=str[i+j]){ok=0;break;}\n\t\t}\n\t\tif(ok==1){break;}\n\t}\n\t\n\tfor(j=0;j<i;j++){\n\t\tnxstr.pub(str[j]);\n\t\tnet.kaz[str[j]-'a']++;\n\t}\n\tmowa.pub(net);\n\tretu.pub(nxstr.size());\n\tfor(i=0;i<n/2;i++){str.pob();}//strを半分にする\n\tretus();\n\tauto ans=solve(r+1,retu.size());\n\tans-=solve(l,retu.size());\n\tfor(i=0;i<26;i++){\n\t\tcout<<ans.kaz[i]<<\" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nvoid init() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\trep(i,n/2+2,n-1) if(i+f[i]==n-1) {n=i-1;break;}\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tinit();s[n]='\\0';\n//\tprintf(\"%s\\n\",s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\tdwn(j,m,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n/*\nabfbaabfba\n1000 1000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define next nxt\n\nint n,k,next[N];\nchar s[N];\nlong long l,r,ans[256];\n\nvoid solve(long long m,long long t){\n\tif (m<=n){\n\t\tfor (int i=1;i<=m;i++) ans[s[i]]+=t;\n\t\treturn;\n\t}\n\tlong long a0=1,b0=0,a1=1,b1=1;\n\twhile (a1*k+b1*(n-k)<=m){\n\t\ta1+=a0;a0=a1-a0;\n\t\tb1+=b0;b0=b1-b0;\n\t}\n\tfor (int i=1;i<=k;i++) ans[s[i]]+=t*a0;\n\tfor (int i=k+1;i<=n;i++) ans[s[i]]+=t*b0;\n\tsolve(m-a0*k-b0*(n-k),t);\n}\n\nlong long read(){\n\tlong long x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tscanf(\" %s\",s+1);n=strlen(s+1)/2;\n\tl=read();r=read();\n\tfor (int i=2,j=0;i<=n;i++){\n\t\twhile (j&&s[i]!=s[j+1]) j=next[j];\n\t\tnext[i]=(j+=(s[i]==s[j+1]));\n\t}\n\tk=n-next[n];solve(l-1,-1);solve(r,1);\n\tfor (int i='a';i<='z';i++)\n\t\tprintf((i!='z')?\"%lld \":\"%lld\\n\",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200000+10;\n\nint n,lt; char s[N];\nint sum[N][26];\nll ans[26],len[100],cnt[100][26];\n\nint nxt[N];\nvoid getnext() {\n\tfor (int i=2,j=0;i<=n;++i) {\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif (s[j+1]==s[i]) ++j;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid calc_sp(ll p,int w) {\n\tif (!p) return;\n\tfor (int i=0;i<26;++i) ans[i]+=w*(p/lt)*sum[lt][i];\n\tfor (int i=0;i<26;++i) ans[i]+=w*sum[p%lt][i];\n}\n\nvoid calc(ll p,int w) {\n\tif (!p) return;\n\tfor (int i=85;i;--i) {\n\t\tif (p<len[i]) continue;\n\t\tp-=len[i];\n\t\tfor (int j=0;j<26;++j) ans[j]+=w*cnt[i][j];\n\t}\n\tfor (int i=0;i<26;++i) ans[i]+=w*sum[p][i];\n}\n\nint main() {\n\tscanf(\"%s\",s+1); n=strlen(s+1)>>1;\n\tll l=read(),r=read();\n\tgetnext(); lt=n-nxt[n];\n\tfor (int i=1;i<=n;++i) {\n\t\tmemcpy(sum[i],sum[i-1],sizeof(sum[i]));\n\t\t++sum[i][s[i]-'a'];\n\t}\n\tif (n%lt==0) calc_sp(r,1),calc_sp(l-1,-1);\n\telse {\n\t\tlen[1]=n,len[2]=n+lt;\n\t\tfor (int i=0;i<26;++i)\n\t\t\tcnt[1][i]=sum[n][i],cnt[2][i]=sum[n][i]+sum[lt][i];\n\t\tfor (int i=3;i<=85;++i) {\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t\t}\n\t\tcalc(r,1),calc(l-1,-1);\n\t}\n\tfor (int i=0;i<26;++i) printf(\"%lld \",ans[i]); puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  // first step\n  s = f(s);\n  // second\n  string t = f(s);\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r+1);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  // if(l>1){\n    calc(X,Y,l);\n    REP(i,26)ans[i]-=cnt[i];\n  // }\n  REP(i,26)printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\nchar s[200002];\nlong long hs[200002],pw[200002];\nlong long gethash(int st,int ed)\n{\n\treturn hs[ed]-hs[st-1]*pw[ed-st+1];\n}\nvector<long long> accumulate(int st,int ed)\n{\n\tvector<long long> ret(26);\n\tfor (int i=st;i<=ed;++i)\n\t\t++ret[s[i]-'a'];\n\treturn ret;\n}\nvoid count_numbers(vector<long long> p,vector<long long> q,vector<long long>& ans,long long& rem)\n{\n\tlong long sm=0;\n\tvector<long long> add;\n\tfor (int i=0;i<26;++i)\n\t{\n\t\tsm+=q[i];\n\t\tadd.push_back(p[i]+q[i]);\n\t}\n\tif (sm>rem)\n\t\treturn;\n\tcount_numbers(q,add,ans,rem);\n\tif (sm<=rem)\n\t{\n\t\tfor (int i=0;i<26;++i)\n\t\t\tans[i]+=q[i];\n\t\trem-=sm;\n\t}\n}\nint plen;\nvector<long long> f10100(long long len,vector<long long> p,vector<long long> q)\n{\n\tvector<long long> ans(26);\n\tcount_numbers(q,p,ans,len);\n\tfor (int i=1;i<=len;++i)\n\t\t++ans[s[i]-'a'];\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=int(strlen(s+1));\n\tpw[0]=1;\n\tn/=2;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpw[i]=pw[i-1]*202877;\n\t\ths[i]=hs[i-1]*202877+s[i];\n\t}\n\tfor (int i=n;i>=(n+1)/2;--i)\n\t\tif (gethash(1,n-i)==gethash(i+1,n))\n\t\t\tplen=i;\n\tvector<long long> p=accumulate(1,plen),q=accumulate(plen+1,n);\n\tlong long l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tvector<long long> rnum=f10100(r,p,q),lnum=f10100(l-1,p,q);\n\tfor (int i=0;i<26;++i)\n\t\tprintf(\"%lld \",rnum[i]-lnum[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nlong long l,r;\nint p;\nint n;\nlong long num[200010][26];\nvector<int>zfunc()\n{\n\tvector<int>z(1000010);\n\tint l=0,r=0;\n\tint ln=s.size();\n\tfor(int k=2;k<=ln;k++)\n\t{\n\t\tif(s[k-1]!=s[0])continue;\n\t\tif(k>r)\n\t\t{\n\t\t\tl=r=k;\n\t\t\twhile(r<=ln&&s[r-1]==s[r-l])r++;\n\t\t\tr--;\n\t\t\tz[k]=r+1-l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tk=k+1-l;\n\t\t\tif(z[tk]<r+1-k)\n\t\t\t\tz[k]=z[tk];\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=k;\n\t\t\t\twhile(r<=ln&&s[r-1]==s[r-l])r++;\n\t\t\t\tr--;\n\t\t\t\tz[k]=r+1-l;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n//\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tif(n%p==0)\n\t{\n\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n\t\tx%=(long long)p;\n\t\txx+=num[x][y];\n\t\treturn xx;\n\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size()/2;\n\tvector<int>z=zfunc();\n\tfor(int i=n+2;i<=2*n;i++)\n\t{\n\t\tif(i+z[i]==2*n+1)\n\t\t{\n\t\t\tp=z[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tp=n-p;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]+=num[i-1][j];\n\t\tnum[i][s[i-1]-'a']++;\n\t}\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int MAXN=3e5+5;\n\nint len,anc[30][MAXN],S,T,num,p[MAXN];\nll l,r;\nchar s[MAXN];\n\nll calc(ll lt,int n){\n\tif(lt<=len)return anc[n][lt];\n\tif(lt<=2*len)return anc[n][len]+anc[n][lt-len];\n\tll f1=anc[n][len],f2=anc[n][len]+anc[n][S],lenf1=len,lenf2=len+S;\n\twhile(lt>lenf1+lenf2){\n\t\tll tem2=f2,lentem2=lenf2;\n\t\tf2+=f1;lenf2+=lenf1;\n\t\tf1=tem2;lenf1=lentem2;\n\t}\n\treturn f2+calc(lt-lenf2,n);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\tlen=strlen(s+1)/2;\n\tbool ok=0;\n\tfor(int i=2*len;;i--){\n\t\tint tmp=i;num=1;\n\t\twhile(s[num]==s[tmp]){\n\t\t\tnum++;tmp++;\n\t\t\tif(tmp==2*len+1){\n\t\t\t\tok=1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t}\n\t\tif(ok){num--;break;}\n\t}\t\n\tT=num;\n\tS=len-num;\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=1;j<=len;j++){\n\t\t\tanc[i][j]=anc[i][j-1];\n\t\t\tif((int)s[j]-96==i)anc[i][j]++;\n\t\t}\n\t}\n//\tcout<<calc(43200,1);\n\tfor(int i=1;i<=26;i++){\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define all(x) (x).begin(), (x).end()\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 4;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    string s;\n    cin >> s;\n    {\n        vector<int> z(s.size());\n        int L = 0, R = 0;\n        for (int i = 1; i < s.size(); i++)\n        {\n            z[i] = max(0, min(z[i - L], R - i));\n            while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n            if (i + z[i] > R)\n            {\n                R = i + z[i];\n                L = i;\n            }\n        }\n        int len = s.size();\n        for (int i = s.size() - 1; 2 * i > s.size(); i--)\n        {\n            if (i + z[i] == s.size())\n            {\n                len = i;\n            }\n        }\n        while (s.size() > len) s.pop_back();\n    }\n\n    ll n = s.size();\n    vector<int> z(s.size());\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    ll k = n;\n    for (int i = 1; i < s.size(); i++)\n    {\n        if (i + z[i] == s.size())\n        {\n            k = i;\n            break;\n        }\n    }\n    if (n % k == 0)\n    {\n        vector<ll> cnt(26);\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        ll c = R / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] += c + 1;\n            else cnt[s[i] - 'a'] += c;\n        }\n        c = L / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] -= c + 1;\n            else cnt[s[i] - 'a'] -= c;\n        }\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cnt[i] << \" \";\n        }\n    }\n    else\n    {\n        return 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=2000005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nstring str;\nint n,sum[33];\nll l,r,a[205],ans[33];\ninline int findnext(string s){\n\tstatic int fa[N];\n\tint n=s.length();\n\tfor(int i=2,p=0;i<=n;i++){\n\t\twhile(p&&s[p]!=s[i-1])p=fa[p];\n\t\tif(s[p]==s[i-1]) p++;\n\t\tfa[i]=p;\n\t}\n\tint k=n;\n\twhile(k*2>=n) k=fa[k];\n//\tcerr<<s<<\" \"<<k<<endl;\n\treturn k;\n}\ninline string make(string a){\n\tint n=a.length(),g=findnext(a);\n\treturn a+a.substr(g,n-g*2);\n}\nset<pair<ll,ll> > s;\ninline void ins(ll x,ll y){\n\tset<pair<ll,ll> >::iterator it=s.lower_bound(mp(x,0));\n\tif((*it).FF==x){\n\t\ts.insert(mp(x,(*it).SS+y));\n\t\ts.erase(it);\n\t}\n\telse s.insert(mp(x,y));\n}\ninline void solve(string b,ll m,int flag){\n\tif(!m) return ;\n\ts.clear();\n\ts.insert(mp(m,1));\n\tfor(int i=n;i;i--){\n\t\tset<pair<ll,ll> >::iterator it=s.lower_bound(mp(a[i]+1,0));\n\t\twhile(it!=s.end()){\n\t\t\tpair<ll,ll> tmp=*it;\n\t\t\tll x=tmp.FF,y=tmp.SS;\n\t\t\tins(a[i+1]/2,y);\n\t\t\tins(x-a[i+1]/2,y);\n\t\t\tit++;s.erase(tmp);\n\t\t}\n\t}\n\tset<pair<ll,ll> >::iterator it=s.begin();\n\tclr(sum,0);\n\tfor(int i=1,t=b.length();i<=t;i++){\n\t\tsum[b[i-1]-'a']++;\n\t\twhile(it!=s.end()&&(*it).FF==i){\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tans[j]+=sum[j]*(*it).SS*flag;\n\t\t\tit++;\n\t\t}\n\t}\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tcin>>str>>l>>r;\n\tstr=make(str);\n\ta[1]=str.length();\n\ta[2]=make(str).length();\n\tfor(n=2;a[n]<r;) a[n+1]=a[n]+a[n-1],n++;\n//\tfor(int i=1;i<=n;i++) dprintf(\"%lld \",a[i]);dprintf(\"\\n\");\n\tsolve(str,r,1);\n//\tfor(int i=0;i<26;i++)\n//\t\tprintf(\"%lld \",ans[i]);puts(\"\");\n\tsolve(str,l-1,-1);\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",ans[i]);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nint n;\nchar s[200001];\nint z[200001];\nlong long ans[26];\n\nint gcd(int x, int y) {\n    if (x % y == 0) return y;\n    return gcd(y, x % y);\n}\n\nvoid calc(long long c, long long g, long long f) {\n    int i;\n    \n    for (i = 0; i < g; i++) ans[s[i] - 'a'] += c / g * f;\n    for (i = 0; i < c % g; i++) ans[s[i] - 'a'] += f;\n}\n\nvoid calc2(long long c, long long x, long long y, int f) {\n    map <pair<long long, long long>, long long> mp;\n    map <pair<long long, long long>, long long>::reverse_iterator it;\n    \n    while (x + y < c) {\n        long long nx = y;\n        long long ny = y + x;\n        \n        x = nx;\n        y = ny;\n    }\n    \n    while (c > 0) {\n        long long nx, ny;\n        \n        if (c == y + x) {\n            mp[make_pair(y + x, y)]++;\n            \n            break;\n        } else if (c >= y) {\n            mp[make_pair(y, x)]++;\n            c -= y;\n        }\n        \n        nx = y - x;\n        ny = x;\n        \n        x = nx;\n        y = ny;\n    }\n    \n    for (it = mp.rbegin(); it != mp.rend(); it++) {\n        long long x = it->first.second;\n        long long y = it->first.first;\n        \n        if (y <= n) {\n            calc(y, y, it->second * f);\n        } else {\n            mp[make_pair(x, y - x)] += it->second;\n            mp[make_pair(y - x, x * 2 - y)] += it->second;\n        }\n    }\n}\n\nint main() {\n    int x, y, i, j, k;\n    long long l, r;\n    \n    scanf(\"%s\", s);\n    scanf(\"%lld %lld\", &l, &r);\n    \n    n = strlen(s);\n    \n    i = 1, j = 0;\n    z[0] = n;\n    \n    while (i < n) {\n        while (i + j < n && s[j] == s[i + j]) j++;\n        \n        z[i] = j;\n        \n        if (j == 0) {\n            i++;\n            \n            continue;\n        }\n        \n        k = 1;\n        \n        while (i + k < n && k + z[k] < j) {\n            z[i + k] = z[k];\n            k++;\n        }\n        \n        i += k;\n        j -= k;\n    }\n    \n    x = n / 2;\n    y = n;\n    \n    for (i = n - 1; i > n / 2; i--) {\n        if (i + z[i] == n) y = i;\n    }\n    \n    if (x == 1) {\n        ans[s[0] - 'a'] = r - l + 1;\n    } else {\n        int g = gcd(x, y);\n        \n        if (g > 1) {\n            calc(r, g, 1);\n            calc(l - 1, g, -1);\n        } else {\n            calc2(r, x, y, 1);\n            calc2(l - 1, x, y, -1);\n        }\n    }\n    \n    for (i = 0; i < 26; i++) {\n        if (i > 0) putchar(' ');\n        \n        printf(\"%lld\", ans[i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252*2];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt <= end && y*ycnt <= end && x*xcnt+y*ycnt > 0 && x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  s = f(s);\n  int x1 = s.size();\n  // first step\n  s = f(s);\n  int x2 = s.size();\n  // second\n  string t = f(s);\n  int x3 = t.size();\n\n  if(x3-x2 == x2-x1){\n    int width = x3-x2;\n    {\n      ll x = r;\n      ll tms = x/width;\n      ll y = x-tms*width;\n      REP(i,width)ans[s[i]-'a'] += tms;\n      REP(i,y)ans[s[i]-'a']++;\n    }\n    {\n      ll x = l-1;\n      ll tms = x/width;\n      ll y = x-tms*width;\n      REP(i,width)ans[s[i]-'a'] -= tms;\n      REP(i,y)ans[s[i]-'a']--;\n    }\n    REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n    return 0;\n  }\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(X,Y,l-1);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint oto[10100000];\nlong long L[500];\nchar p[10100000];\nmap<long long, long long>Map[500];\nint Do(int n) {\n\tint i;\n\tp[n] = 0;\n\toto[0] = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tint t = oto[i - 1];\n\t\twhile (t != -1 && p[i - 1] != p[t])t = oto[t];\n\t\toto[i] = t + 1;\n\t}\n\tfor (int TT = 0; TT < 3; TT++) {\n\t\tint t = n;\n\t\twhile (t * 2 >= n)t = oto[t];\n\t\tL[TT] = n;\n\t\tint tn = n * 2 - t * 2;\n\t\tfor (i = n + 1; i <= tn; i++) {\n\t\t\tp[i - 1] = p[t - 1 + i - n];\n\t\t\tint tt = oto[i - 1];\n\t\t\twhile (tt != -1 && p[i - 1] != p[tt])tt = oto[tt];\n\t\t\toto[i] = tt + 1;\n\t\t}\n\t\tn = tn;\n\t\tL[TT + 1] = n;\n\t}\n\tif (L[3] - L[2] == L[2] - L[1]) return 1;\n\treturn 2;\n}\nlong long C[26], C2[26], T[26];\nvoid Get1(long long n) {\n\tint i;\n\tfor (i = 0; i < 26; i++)T[i] = C[i] = 0;\n\tfor (i = 0; i < min(L[1], n); i++)C[p[i] - 'a']++;\n\tfor (i = L[1]; i < L[2]; i++)T[p[i] - 'a']++;\n\tif (n <= L[1])return;\n\tfor (i = 0; i < 26; i++)C[i] += T[i] * (n - L[1]) / (L[2] - L[1]);\n\tfor (i = 0; i < (n - L[1]) % (L[2] - L[1]); i++)C[p[L[1] + i] - 'a']++;\n}\nint main() {\n\tint i;\n\tlong long b, e;\n\tscanf(\"%s\", p);\n\tscanf(\"%lld%lld\", &b, &e);\n\tfor (i = 0; p[i]; i++);\n\tint n = i;\n\tif (Do(n) == 1) {\n\t\tGet1(b-1);\n\t\tfor (i = 0; i < 26; i++)C2[i] = C[i];\n\t\tGet1(e);\n\t\tfor (i = 0; i < 26; i++)printf(\"%lld \", C[i] - C2[i]);\n\t\treturn 0;\n\t}\n\telse {\n\t\tint i;\n\t\tfor (i = 4;; i++) {\n\t\t\tL[i] = L[i - 1] + L[i - 2];\n\t\t\tif (L[i] >= e)break;\n\t\t}\n\t\tint pv = i;\n\t\tMap[pv][e]++;\n\t\tMap[pv][b - 1]--;\n\t\tfor (i = pv; i >= 2; i--) {\n\t\t\tfor (auto &tp : Map[i]) {\n\t\t\t\tif (tp.first <= L[i - 1])Map[i - 1][tp.first] += tp.second;\n\t\t\t\telse {\n\t\t\t\t\tMap[i - 1][L[i - 1]]+=tp.second;\n\t\t\t\t\tMap[i - 1][tp.first - L[i] / 2]+=tp.second;\n\t\t\t\t\tMap[i - 1][L[i - 1] - L[i] / 2]-=tp.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long s = 0;\n\t\tfor (i = L[1]; i >= 1; i--) {\n\t\t\ts += Map[1][i];\n\t\t\tC[(p[i - 1] - 'a')] += s;\n\t\t}\n\t\tfor (i = 0; i < 26; i++)printf(\"%lld \", C[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define Size(x) ((int)(x).size())\nconst int INF = 1e9 + 10 , MN = 2e5 + 10 , LG = 222;\nconst long long BIG = 1000ll*1000*1000*1000*1000*1000 + 10;\nint n , nxt[MN];\nstring s;\nlong long Nx[LG] , Ny[LG] , X[33][LG] , Y[33][LG];\nint ps[33][MN];\nvoid prep() {\n\tint cur = 0;\n\tfor(int i=1;i<n;++i){\n\t\twhile(cur && s[i] != s[cur]) cur = nxt[cur];\n\t\tcur += (s[i] == s[cur]);\n\t\tnxt[i+1] = cur;\n\t}\n\tNx[0] = n - nxt[n] , Ny[0] = nxt[n];\n\tfor(int i=0;i<Nx[0];++i)\n\t\tX[s[i]-'a'][0]++;\n\tfor(int i=Nx[0];i<n;++i)\n\t\tY[s[i]-'a'][0]++;\n\tfor(int i=1;i<LG;++i){\n\t\tNx[i] = Nx[i-1] + Ny[i-1];\n\t\tNx[i] = min(Nx[i] , BIG);\n\t\tNy[i] = Nx[i-1];\n\t\tfor(int j=0;j<26;++j){\n\t\t\tX[j][i] = X[j][i-1] + Y[j][i-1];\n\t\t\tY[j][i] = X[j][i-1];\n\t\t\tX[j][i] = min(X[j][i] , BIG);\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<26;++j)\n\t\t\tps[j][i+1] = ps[j][i] + (s[i]-'a' == j);\n}\nlong long get(long long val,int c) {\n\tfor(int i=LG-1;~i;--i)\n\t\tif(Nx[i] <= val) return min(BIG , X[c][i] + get(val - Nx[i] , c));\n\treturn ps[c][val];\n}\nint main() {\n\tcin>>s;\n\tn = Size(s)/2;\n\tprep();\n\tlong long l , r;\n\tcin >> l >> r;\n\tfor(int c=0;c<26;++c) cout << get(r , c) - get(l-1 , c) << ' ';\n\tputs(\"\");\n\treturn 0;\n}\n/*\nInput\n\nabaaba\n6 10\n\nOutput\n\n3 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nInput\n\nxx\n1 1000000000000000000\n\nOutput\n\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1000000000000000000 0 0\n\nInput\n\nvgxgpuamkvgxgvgxgpuamkvgxg\n1 1000000000000000000\n\nOutput\n\n87167725689669676 0 0 0 0 0 282080685775825810 0 0 0 87167725689669676 0 87167725689669676 0 0 87167725689669676 0 0 0 0 87167725689669676 141040342887912905 0 141040342887912905 0 0\n*/"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, x, y) for(int i = (x), _ = (y); i <= _; ++ i)\n#define per(i, x, y) for(int i = (x), _ = (y); i >= _; -- i)\n#define dprintf(...) fprintf(stderr, __VA_ARGS__)\n#define disp(x) cout << #x << \" = \" << x << \"; \"\n\ntypedef long long LL;\n\ntemplate <class T> bool chkmin(T& a, T b) { return a > b ? a = b, true : false; }\ntemplate <class T> bool chkmax(T& a, T b) { return a < b ? a = b, true : false; }\n\ntemplate <class T> void read(T& a) {\n\tchar c = getchar(); \n\tT f = 1; \n\ta = 0;\n\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\n\tfor(; isdigit(c); c = getchar()) a = a * 10 + c - '0';\n\ta *= f;\n}\n/*}}}*/\n\nconst int maxN = 2e5 + 5;\n\nchar s[maxN];\nLL fib[100];\nint fail[maxN];\nint lens, lent;\nLL ansl[26], ansr[26]; \nint sums[26], sumt[26];\nLL L, R;\n\nvoid getans(LL Bnd, LL ans[])\n{\n\tif(Bnd < lens)\n\t{\n\t\trep(i, 1, Bnd) ans[s[i] - 'a']++;\n\t\treturn;\n\t}\n\trep(i, 0, 90)\n\t{\n\t\tif(fib[i] * lent + fib[i + 1] * lens > Bnd)\n\t\t{\n\t\t\trep(j, 0, 25) ans[j] += fib[i - 1] * sumt[j] + fib[i] * sums[j];\n\t\t\tgetans(Bnd - fib[i - 1] * lent - fib[i] * lens, ans);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef Leeson\n\tfreopen(\"tmp.in\", \"r\", stdin);\n\tfreopen(\"tmp.out\", \"w\", stdout);\n#endif\n\n\tfib[0] = 0; fib[1] = 1;\n\trep(i, 2, 90) fib[i] = fib[i - 1] + fib[i - 2];\n\tscanf(\"%s\", s + 1);\n\tlens = strlen(s + 1) >> 1;\n\tfail[0] = fail[1] = 0;\n\trep(i, 2, lens)\n\t{\n\t\tint tmp = fail[i - 1];\n\t\twhile(tmp && s[tmp + 1] != s[i]) tmp = fail[tmp];\n\t\tfail[i] = s[tmp + 1] == s[i] ? tmp + 1 : 0;\n\t}\n\tlent = lens - fail[lens];\n\trep(i, 1, lent) sumt[s[i] - 'a']++;\n\trep(i, 1, lens) sums[s[i] - 'a']++;\n\tread(L), read(R);\n\tgetans(R, ansr);\n\tgetans(L-1, ansl);\n\trep(i, 0, 25) printf(\"%lld \", ansr[i] - ansl[i]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=2e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nclass alphs{\npublic:\n\tarray<llint,26> kaz;\n\talphs(){for(int i=0;i<26;i++){kaz[i]=0;}}\n\talphs& operator +=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]+=other.kaz[i];}\n\t\treturn (*this);\n\t}\n\talphs& operator -=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]-=other.kaz[i];}\n\t\treturn (*this);\n\t}\n};\nvector<llint> retu;\nvector<alphs> mowa;\nstring str;\nstring nxstr;\nvoid retus(void){\n\talphs a=mowa.back();\n\tllint k=retu.back();\n\twhile(-1){\n\t\tk+=retu[retu.size()-2];retu.pub(k);\n\t\ta+=mowa[mowa.size()-2];mowa.pub(a);\n\t\tif(retu.back()>big){return;}\n\t}\n}\nalphs solve(llint x,llint fu){\n\talphs ans;\n\tif(fu==0){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[str[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(fu==1){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[nxstr[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(x<retu[fu-1]){return solve(x,fu-1);}\n\tans=mowa[fu-1];\n\tans+=solve(x-retu[fu-1],fu-2);\n\treturn ans;\n}\n\nint main(void){\n\tllint l,r,n,i,j;//p r p の最初のp\n\tcin>>str;n=str.size();\n\tcin>>l>>r;\n\talphs it;\n\talphs net;\n\tfor(i=0;i<n/2;i++){it.kaz[str[i]-'a']++;}\n\tmowa.pub(it);\n\tretu.pub(n/2);\n\tfor(i=(n/2)+1;i<n;i++){//重ならない数\n\t\tint ok=1;\n\t\tfor(j=0;i+j<n;j++){\n\t\t\tif(str[j]!=str[i+j]){ok=0;break;}\n\t\t}\n\t\tif(ok==1){break;}\n\t}\n\t\n\tfor(j=0;j<i;j++){\n\t\tnxstr.pub(str[j]);\n\t\tnet.kaz[str[j]-'a']++;\n\t}\n\tmowa.pub(net);\n\tretu.pub(nxstr.size());\n\tfor(i=0;i<n/2;i++){str.pob();}//strを半分にする\n\tretus();\n\tauto ans=solve(r+1,retu.size()-1);\n\tans-=solve(l,retu.size()-1);\n\tfor(i=0;i<26;i++){\n\t\tcout<<ans.kaz[i]<<\" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int MAXN=3e5+5;\n\nint len,anc[30][MAXN],S,T,num,p[MAXN];\nll l,r;\nchar s[MAXN];\n\nll calc(ll lt,int n){\n\tif(lt<=len)return anc[n][lt];\n\tif(lt<=2*len)return anc[n][len]+anc[n][lt-len];\n\tll f1=anc[n][S],f2=anc[n][len],lenf1=S,lenf2=len;\n\twhile(lt>lenf1+lenf2){\n\t\tll tem2=f2,lentem2=lenf2;\n\t\tf2+=f1;lenf2+=lenf1;\n\t\tf1=tem2;lenf1=lentem2;\n\t}\n\treturn f2+calc(lt-lenf2,n);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\tlen=strlen(s+1)/2;\n\tbool ok=0;\n\tfor(int i=2*len;;i--){\n\t\tint tmp=i;num=1;\n\t\twhile(s[num]==s[tmp]){\n\t\t\tnum++;tmp++;\n\t\t\tif(tmp==2*len+1){\n\t\t\t\tok=1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t}\n\t\tif(ok){num--;break;}\n\t}\t\n\tT=num;\n\tS=len-num;\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=1;j<=len;j++){\n\t\t\tanc[i][j]=anc[i][j-1];\n\t\t\tif((int)s[j]-96==i)anc[i][j]++;\n\t\t}\n\t}\n//\tcout<<calc(43200,1);\n\tfor(int i=1;i<=26;i++){\n\t\tprintf(\"%lld%c\",calc(r,i)-calc(l-1,i),i==26?10:32);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nll l, r;\nint len, S, T;\nint ans[30][N], nxt[N];\nchar A[N];\n\nll cal(int a, ll now){\n    if (now <= len) return ans[a][now];\n    if (now <= 2 * len) return ans[a][len] + ans[a][now - len];\n    ll f1 = ans[a][S], f2 = ans[a][len], lenf1 = S, lenf2 = len;\n    while (now > lenf1 + lenf2) {\n        ll tem = f2, lentem = lenf2;\n        f2 += f1; lenf2 += lenf1;\n        f1 = tem; lenf1 = lentem;\n    }\n    return f2 + cal(a, now - lenf2);\n}\n\nint main(){\n    scanf(\"%s\", A + 1);\n    scanf(\"%lld%lld\", &l, &r);\n    len = strlen(A + 1) / 2;\n    \n    nxt[1] = 0;\n    for (int i = 2; i <= len; i ++) {\n        int j = nxt[i - 1];\n        while(j != 0 && A[j + 1] != A[i]) j = nxt[j];\n\n        if(A[j + 1] == A[i]) nxt[i] = j + 1; \n        else nxt[i] = 0;\n    }\n    T = nxt[len];\n    S = len - T;\n    \n    for (int i = 1; i <= 26; i ++) {\n        for (int j = 1; j <= len; j ++) {\n            ans[i][j] = ans[i][j - 1];\n            if ((int)A[j] - 96 == i) ans[i][j] ++;\n        }\n    }\n    for (int i = 1; i <= 26; i ++)\n        printf(\"%lld \", cal(i, r) - cal(i, l - 1));\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 9;\n\nchar s[N];\nint f[N], n, t, lim;\nusing ll = long long;\nll l, r, c[120][26], ans[26], fib[N];\n\nvoid Solve (ll x, int t) {\n\tll bs = x / ::t, b2 = x % ::t;\n\tbs *= t;\n\tfor (int i = 0; i < ::t; ++i) {\n\t\tans[s[i] - 'a'] += bs;\n\t\tif (i < b2) ans[s[i] - 'a'] += bs;\n\t}\n}\n\nvoid Solve2 (ll x, int t) {\n\tint now = lim + 1;\n\twhile (now-- > 0) {\n\t\tif (x >= fib[now]) {\n\t\t\tfor (int i = 0; i < 26; ++i) ans[i] += c[now][i] * t;\n\t\t\tx -= fib[now], --now;\n\t\t}\n\t}\n\tfor (int i = 0; i < x; ++i) ans[s[i] - 'a'] += t;\n}\n\nint main () {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tn >>= 1;\n\ts[n] = '\\0';\n\tscanf(\"%lld%lld\", &l, &r);\n\tfor (int i = 1, j; i < n; ++i) {\n\t\tj = f[i];\n\t\twhile (j && s[j] != s[i]) j = f[j];\n\t\tf[i + 1] = s[i] == s[j] ? j + 1 : 0;\n\t}\n\tt = n - f[n];\n\tif (n % t == 0) {\n\t\tSolve(r, 1); Solve(l - 1, -1);\n\t} else {\n\t\tfor (int i = 0; i < t; ++i) ++c[0][s[i] - 'a'];\n\t\tfor (int i = 0; i < n; ++i) ++c[1][s[i] - 'a'];\n\t\tfib[0] = t; fib[1] = n;\n\t\tfor (lim = 2; ; ++lim) {\n\t\t\tfor (int j = 0; j < 26; ++j) c[lim][j] = c[lim - 1][j] + c[lim - 2][j];\n\t\t\tif ((fib[lim] = fib[lim - 1] + fib[lim - 2]) >= 1e18) break;\n\t\t}\n\t\tSolve2(r, 1); Solve2(l - 1, -1);\n\t}\n\tfor (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint oto[10100000];\nlong long L[500];\nchar p[10100000];\nmap<long long, long long>Map[500];\nint Do(int n) {\n\tint i;\n\tp[n] = 0;\n\toto[0] = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tint t = oto[i - 1];\n\t\twhile (t != -1 && p[i - 1] != p[t])t = oto[t];\n\t\toto[i] = t + 1;\n\t}\n\tfor (int TT = 0; TT < 3; TT++) {\n\t\tint t = n;\n\t\twhile (t * 2 >= n)t = oto[t];\n\t\tL[TT] = n;\n\t\tint tn = n * 2 - t * 2;\n\t\tfor (i = n + 1; i <= tn; i++) {\n\t\t\tp[i - 1] = p[t - 1 + i - n];\n\t\t\tint tt = oto[i - 1];\n\t\t\twhile (tt != -1 && p[i - 1] != p[tt])tt = oto[tt];\n\t\t\toto[i] = tt + 1;\n\t\t}\n\t\tn = tn;\n\t\tL[TT + 1] = n;\n\t}\n\tif (L[3] - L[2] == L[2] - L[1]) return 1;\n\treturn 2;\n}\nlong long C[26], C2[26], T[26];\nvoid Get1(long long n) {\n\tint i;\n\tfor (i = 0; i < 26; i++)T[i] = C[i] = 0;\n\tfor (i = 0; i < min(L[1], n); i++)C[p[i] - 'a']++;\n\tfor (i = L[1]; i < L[2]; i++)T[p[i] - 'a']++;\n\tif (n <= L[1])return;\n\tfor (i = 0; i < 26; i++)C[i] += ((n - L[1]) / (L[2] - L[1])) * T[i] ;\n\tfor (i = 0; i < (n - L[1]) % (L[2] - L[1]); i++)C[p[L[1] + i] - 'a']++;\n}\nint main() {\n\tint i;\n\tlong long b, e;\n\tscanf(\"%s\", p);\n\tscanf(\"%lld%lld\", &b, &e);\n\tfor (i = 0; p[i]; i++);\n\tint n = i;\n\tif (Do(n) == 1) {\n\t\tGet1(b-1);\n\t\tfor (i = 0; i < 26; i++)C2[i] = C[i];\n\t\tGet1(e);\n\t\tfor (i = 0; i < 26; i++)printf(\"%lld \", C[i] - C2[i]);\n\t\treturn 0;\n\t}\n\telse {\n\t\tint i;\n\t\tfor (i = 4;; i++) {\n\t\t\tL[i] = L[i - 1] + L[i - 2];\n\t\t\tif (L[i] >= e)break;\n\t\t}\n\t\tint pv = i;\n\t\tMap[pv][e]++;\n\t\tMap[pv][b - 1]--;\n\t\tfor (i = pv; i >= 2; i--) {\n\t\t\tfor (auto &tp : Map[i]) {\n\t\t\t\tif (tp.first <= L[i - 1])Map[i - 1][tp.first] += tp.second;\n\t\t\t\telse {\n\t\t\t\t\tMap[i - 1][L[i - 1]]+=tp.second;\n\t\t\t\t\tMap[i - 1][tp.first - L[i] / 2]+=tp.second;\n\t\t\t\t\tMap[i - 1][L[i - 1] - L[i] / 2]-=tp.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long s = 0;\n\t\tfor (i = L[1]; i >= 1; i--) {\n\t\t\ts += Map[1][i];\n\t\t\tC[(p[i - 1] - 'a')] += s;\n\t\t}\n\t\tfor (i = 0; i < 26; i++)printf(\"%lld \", C[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n} \n\nstring s,t;\nll l,r,S,T;\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0,I=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tI=i;\n\t\t}\n\t}\n\tt=(I==S?s:s.substr(0,I));\n\tT=t.size();\n\tif(S%T==0){\n\t\tvl a(26);\n\t\tfor(int i=l;i<S;i++) a[f(s[i])]++;\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(r<=S?0:(r-S)/T);\n\t\tfor(int i=0;i<(r-S)%T;i++) a[f(t[i])]++;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<a[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 2e5+3;\nchar s[MaxN];\nLL l,r;\nint cnt[MaxN][26];\nstruct Statu{\n\tLL s[26];\n\tStatu() {memset(s,0,sizeof s);}\n\ttemplate<typename T>\n\tStatu(const T* x) {\n\t\tfor (LL* p=s;p<s+26;++p,++x) *p=*x;\n\t}\n\tinline LL& operator [](const char& ch) {\n\t\treturn *(s+(int)ch-'a');\n\t}\n\tinline LL& operator [] (const int& x) {\n\t\treturn *(s+x);\n\t}\n\tinline Statu& operator +=(const Statu& o) {\n\t\tfor (int i=0;i<26;++i) s[i]+=o.s[i];\n\t\treturn *this;\n\t}\n\tinline Statu operator +(const Statu& b) const {\n\t\tStatu ret;\n\t\tfor (int i=0;i<26;++i) ret.s[i]=s[i]+b.s[i];\n\t\treturn ret;\n\t}\n\tinline void print() const {\n\t\tfor (int i=0;i<26;++i) printf(\"%I64d \",s[i]);\n\t\tputchar('\\n');\n\t}\n};\n\ninline int* Z_box(const char* str,int* z) {\n\tint r=-1,p=-1,l=strlen(str);\n\tz[0]=l-1;\n\tfor (int i=1;i<l;++i) {\n\t\tz[i]=-1;\n\t\tif (r>=i) z[i]=min(z[i-p],r-i);\n\t\twhile (i+z[i]+1<l && str[i+z[i]+1]==str[z[i]+1]) z[i]++;\n\t\tif (i+z[i]>r) r=i+z[i],p=i;\n\t}\n\treturn z;\n}\n\nLL solve(LL llen,Statu L,LL rlen,Statu R,LL last,Statu& ans) {\n\tif (llen+rlen<=last) {\n\t\tLL t=solve(llen+rlen,L+R,llen,L,last,ans);\n\t\tlast=t;\n\t}\n\tif (llen<=last) {\n\t\tans+=L;\n\t\tlast-=llen;\n\t}\n\treturn last;\n} \nchar s2[MaxN];int z[MaxN];\nint main() {\n\tscanf(\"%s\",s);\n\tcin >> l >> r;\n\tint len=strlen(s);\n\tfor (int i=0;i<len/2;++i) s2[i]=s[i];\n\tint l2=strlen(s2);\n\tZ_box(s2,z);\n\tmemset(cnt,0,sizeof cnt);\n\tcnt[0][s[0]-'a']=1;\n\tfor (int i=1;i<l2;++i) {\n\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tint pre=0x7fffffff; \n\tfor (int i=1;i<l2;++i) {\n\t\tif (z[i]!=-1 && i+z[i]==l2-1) pre=min(pre,i); \n\t}\n\tif (pre==0x7fffffff) {\n\t\tStatu ans;\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]+=(LL)cnt[l2-1][i]*(r/l2)+cnt[r%l2][i];\n\t\t\tif (l>=1) ans[i]-=(LL)cnt[l2-1][i]*((l-1)/l2)+cnt[(l-1)%l2][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) cout << ans[i] << \" \";\n\t} else {\n\t\tStatu L,R,ans1,ans2,ans;\n\t\tfor (int i=0;i<26;++i) \n\t\t\tL[i]=cnt[pre-1][i],\n\t\t\tR[i]=cnt[l2-1][i]-cnt[pre-1][i];\n\t\tLL x1=solve(pre,L,l2-pre,R,r+1,ans1),x2=solve(pre,L,l2-pre,R,l,ans2);\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]=ans1[i]-ans2[i]; \n\t\t\tif (x1>=1) ans[i]+=cnt[x1-1][i];\n\t\t\tif (x2>=1) ans[i]-=cnt[x2-1][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) cout << ans[i] << \" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 300\n \nll l,r;\n \nint z[MAXN];\nvoid getz(char s[]){\n\tms(z);\n\tint n = strlen(s);\n\tint l = 0, r = 0;\n\tfor(int i = 1;i < n;i++){\n\t\tif(i > r){\n\t\t\tl = r = i;\n\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\tr--;\n\t\t\tz[i] = r-l+1;\n\t\t}else{\n\t\t\tint k = i-l;\n\t\t\tif(z[k] < r-i) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tl = i;\n\t\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\t\tr--;\n\t\t\t\tz[i] = r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\n \nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nll j;\nchar s1[MAXN];\nll final[28][2];\nint n;\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\tgetz(s1);\n\tlen[0] = n/4;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << s1[i] << \" \";cout << endl;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << z[i] << \" \";cout << endl;\n\twhile(1){\n\t\tif(z[len[0]]+len[0] >= n/2) break;\n\t\tlen[0]++;\n\t}\n\tlen[1] = n/2;\n\tlen[2] = len[0] + len[1];\n\tlen[0] = 0;\n\t//cout << len[0] << \" =-=-==-==-\" << endl;\n\t//cout << len[1] << \" =-=-==-==-\" << endl;\n\tj = 3;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\tj--;\n\t//cout << j << \" PPPPPPPPPPPPPPPPPPPPPPPPPP\" << endl;\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 0;i < len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 0;i < len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 1;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t//freopen(\"ss.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tcin >> s1;\n\tcin >> l >> r;\n\t\n\tn = strlen(s1);\n\tl--;r--;\n\t\n\tms(final);\n\tif(l >= 1) getans(l-1,0);\n\tif(r >= 0) getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nvector<unsigned long long> x_cnt, y_cnt, pref_x_cnt, pref_y_cnt;\nint suffix[200005];\n\nlong long gcd(long long a, long long b)\n{\n    if (a%b == 0) return b;\n    else return gcd(b,a%b);\n}\n\nint find_suffix(string s)\n{\n    //find length of longest suffix of s that is also a prefix of s\n    suffix[0] = suffix[1] = 0;\n    for (int i=2; i<=s.length(); i++) {\n        int j = suffix[i-1];\n        while (true) {\n            if (s[j] == s[i-1]) {\n                suffix[i] = j+1;\n                break;\n            }\n            else if (j == 0) {\n                suffix[i] = 0;\n                break;\n            }\n            j = suffix[j];\n        }\n    }\n    //printa(suffix,s.length()+1);\n    return suffix[s.length()];\n}\n\nvector<ll> simple_query(string period, ll r, vector<ll> &chr_cnt)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    ll num_periods = r/period.length();\n    ll remain = r % period.length();\n    for0(i,26) {\n        ret[i] = chr_cnt[i]*num_periods;\n    }\n\n    for0(i,remain) {\n        ret[period[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve_simple(string period, ll l, ll r)\n{\n    //prl(period);\n    vector<ll> chr_cnt(26,0);\n    iter(period) {\n        chr_cnt[*it-'a']++;\n    }\n\n    vector<ll> r_cnt = simple_query(period, r, chr_cnt);\n    vector<ll> l_cnt = simple_query(period, l-1, chr_cnt);\n    //printv(r_cnt);\n    //printv(l_cnt);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\npair<ll,ll> explicit_query(ll x, ll y, ll r)\n{\n    //count the number of x's and y's using the pattern explicitly.\n    //This is for testing only since the explicit pattern is too long.\n    ll query_x_cnt = 0, query_y_cnt = 0;\n\n    //construct the pattern\n    vector<ll> pattern = {x,x,y,x,x,y,x,y,x,x,y,x,x,y,x};\n    int lv = 3;\n    while (sz(pattern) < 1000) {\n        lv++;\n        for (int i=pref_x_cnt[lv]+pref_y_cnt[lv]; sz(pattern)<x_cnt[lv]+y_cnt[lv]; i++) {\n            pattern.pb(pattern[i]);\n        }\n    }\n    //printv(pattern)\n\n    int i = 0;\n    while (true) {\n        if (pattern[i] == x) {\n            if (r >= x) {\n                r -= x;\n                query_x_cnt++;\n            }\n            else break;\n        }\n        else {\n            if (r >= y) {\n                r -= y;\n                query_y_cnt++;\n            }\n            else break;\n        }\n        i++;\n    }\n    return mp(query_x_cnt, query_y_cnt);\n}\n\nvector<ll> hard_query(ll x, ll y, ll r, string s)\n{\n    //prl(x) prl(y) prl(r) nl\n    //pair<ll,ll> correct = explicit_query(x, y, r);\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    //count the number of occurrences of x and y in the pattern x,x,y,x,x,y,x,y,x,... (not periodic!)\n    //until the sum is greater than r\n    int lv = 0;\n    while (lv < sz(x_cnt) && x*x_cnt[lv] + y*y_cnt[lv] <= r) {\n        lv++;\n    }\n    int prefix = 0;\n    ll query_x_cnt = 0, query_y_cnt = 0;\n\n    while (lv > 2) {\n        //prl(lv) prl(r) prl(prefix)\n        ll num_x_lv = x_cnt[lv-1] - pref_x_cnt[prefix];\n        ll num_y_lv = y_cnt[lv-1] - pref_y_cnt[prefix];\n        ll len = x*num_x_lv + y*num_y_lv;\n        //prl(num_x_lv);\n        //prl(num_y_lv);\n        if (len < r) {\n            query_x_cnt += num_x_lv;\n            query_y_cnt += num_y_lv;\n            r -= len;\n            prefix = lv;\n        }\n        lv--;\n        //nl\n    }\n    //prl(query_x_cnt);\n    //prl(query_y_cnt);\n\n    //add the last part using the pattern explicitly\n    vector<ll> pattern = {x,x,y,x,x,y,x,y,x,x,y,x,x,y,x};\n    for (int i=pref_x_cnt[prefix]+pref_y_cnt[prefix]; i<sz(pattern); i++) {\n        //prl(i)\n        if (pattern[i] == x) {\n            if (r >= x) {\n                r -= x;\n                query_x_cnt++;\n            }\n            else {\n                //partial s remaining\n                for (int j=0; r>0; j++) {\n                    ret[s[j]-'a']++;\n                    r--;\n                }\n                break;\n            }\n        }\n        else {\n            if (r >= y) {\n                r -= y;\n                query_y_cnt++;\n            }\n            else {\n                //partial suffix of s remaining\n                for (int j=x-y; r>0; j++) {\n                    ret[s[j]-'a']++;\n                    r--;\n                }\n                break;\n            }\n        }\n    }\n    assert(r == 0);\n    //prl(query_x_cnt);\n    //prl(query_y_cnt);\n\n\n    //count character frequencies in s and the suffix of s of length y\n    vector<ll> x_chr_cnt(26,0);\n    vector<ll> y_chr_cnt(26,0);\n    for0(i,x) {\n        x_chr_cnt[s[i]-'a']++;\n    }\n    for (int i=x-y; i<x; i++) {\n        y_chr_cnt[s[i]-'a']++;\n    }\n\n    for0(i,26) {\n        ret[i] += query_x_cnt * x_chr_cnt[i];\n        ret[i] += query_y_cnt * y_chr_cnt[i];\n    }\n    //assert(query_x_cnt == correct.first);\n    //assert(query_y_cnt == correct.second);\n\n    return ret;\n}\n\nvoid solve_hard(string s, int suffix_len, ll l, ll r)\n{\n    ll x = s.length();\n    ll y = x - suffix_len;\n\n    vector<ll> r_cnt = hard_query(x, y, r, s);\n    vector<ll> l_cnt = hard_query(x, y, l-1, s);\n\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"D.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    string s;\n    cin >> s;\n    s = s.substr(0,s.length()/2);\n    long long l,r;\n    cin >> l >> r;\n\n    int suf_len = find_suffix(s);\n    //prl(suf_len)\n    if (suf_len == 0) {\n        //special case where pattern is periodic with period s\n        solve_simple(s, l, r);\n    }\n    else if (suf_len >= (s.length()+1)/2 && gcd(suf_len,s.length()) > 1) {\n        //special case where s is periodic. Pattern is periodic with period repeated\n        string period = s.substr(0,gcd(suf_len, s.length()));\n        solve_simple(period, l, r);\n    }\n    else if (suf_len == s.length()-1) {\n        //s consists of all 1 character. Again pattern is periodic with that character repeated\n        solve_simple(s.substr(0,1), l, r);\n    }\n    else {\n        //pattern is not periodic. Do some tricky stuff...\n        x_cnt = {2,4};\n        y_cnt = {1,1};\n        while (x_cnt.back() < 1e18) {\n            x_cnt.pb(x_cnt[sz(x_cnt)-1] + x_cnt[sz(x_cnt)-2]);\n            y_cnt.pb(y_cnt[sz(y_cnt)-1] + y_cnt[sz(y_cnt)-2] + 1);\n        }\n        pref_x_cnt = {0,0,0,1,2,3};\n        pref_y_cnt = {0,0,0,0,0,1};\n        while (sz(pref_x_cnt) < sz(x_cnt)) {\n            pref_x_cnt.pb(pref_x_cnt[sz(pref_x_cnt)-1] + pref_x_cnt[sz(pref_x_cnt)-2]);\n            pref_y_cnt.pb(pref_y_cnt[sz(pref_y_cnt)-1] + pref_y_cnt[sz(pref_y_cnt)-2]+1);\n        }\n\n        solve_hard(s, suf_len, l, r);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 200010;\n\nchar s0[N];\nint len, nxt[N];\n\nvoid get_nxt()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= len; i ++) {\n\t\twhile (j && s0[i] != s0[j + 1]) j = nxt[j];\n\t\tif (s0[i] == s0[j + 1]) j ++;\n\t\tnxt[i] = j; \n\t}\n}\n\nLL f[110][27], ans[27];\n\nLL calc(int x, LL k, int c)\n{\n\t//printf(\"%d %lld %lld %d\\n\", x, k, f[x][0], c);\n\t\n\tif (f[x][0] == k) return f[x][c];\n\tif (k >= f[x - 1][0])\n\t\treturn f[x - 1][c] + calc(x - 2, k - f[x - 1][0], c);\n\telse return calc(x - 1, k, c);\n}\n\nint main()\n{\n\tscanf(\"%s\", s0 + 1);\n\tlen = strlen(s0 + 1) / 2;\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tget_nxt();\n\t\n\tprintf(\"%d %d\\n\", nxt[len], len - nxt[len]);\n\t\n\tRep(i, len - nxt[len]) f[0][s0[i] - 'a' + 1] ++;\n\tRep(i, len) f[1][s0[i] - 'a' + 1] ++;\n\tf[0][0] = len - nxt[len], f[1][0] = len;\n\tint x = 2;\n\twhile (true) {\n\t\tRep0(i, 26) f[x][i] = f[x - 1][i] + f[x - 2][i];\n\t\t//printf(\"%d %lld\\n\", x, f[x][0]);\n\t\tif (f[x][0] >= r) break;\n\t\tx ++;\n\t}\n\tif (l > 1) Rep0(i, x) if (f[i][0] >= l - 1) {\n\t\tRep(j, 26) ans[j] -= calc(i, l - 1, j);\n\t\tbreak;\n\t}\n\n\tRep0(i, x) if (f[i][0] >= r) {\n\t\tRep(j, 26) ans[j] += calc(i, r, j);\n\t\tbreak;\n\t}\n\tRep(i, 26) printf(\"%lld \", ans[i]);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n/*\nxx\n1 100\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (len <= n * 2) return num[n][c] + num[len - n][c];\n    long long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    while (len > l1 + l2) {\n        long long t = f2;\n        f2 += f1, f1 = t;\n        t = l2, l2 += l1, l1 = t;\n    }\n    return f2 + fib(len - l2, c);\n}\n\nlong long calc(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (n % T == 0) {\n        long long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n        len -= n, len %= T;\n        return re + num[len][c];\n    }\n    else return fib(len, c);\n}\n\nint main() {\n    scanf(\"%s%lld%lld\", s + 1, &L, &R);\n    n = strlen(s + 1) / 2;\n    p[1] = 0;\n    for (int j = 0, i = 2; i <= n; i ++) {\n        for (; j && s[j + 1] != s[i];) j = p[j];\n        if (s[j + 1] == s[i]) j ++;\n        p[i] = j;\n    }\n    for (int i = 1; i <= n; i ++) {\n        for (int j = 0; j < 26; j ++) num[i][j] = num[i - 1][j];\n        num[i][s[i] - 'a'] ++;\n    }\n    T = n - p[n];\n    printf(\"%d\\n\",T);\n\tfor (int i = 0; i < 26; i ++) printf(\"%lld%c\", fib(R, i) - fib(L - 1, i), i == 25 ? 10 : 32);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 3;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nchar val[maxn];\nll le, ri;\n\nint len, prod;\nll pre[maxn][30];\nint nxt[maxn];\n\nll fib(ll n, ll x)\n{\n\tif (n <= len) {\n\t\treturn pre[n][x];\n\t}\n\tif (n <= 2 * len) {\n\t\treturn pre[len][x] + pre[n - len][x];\n\t}\n\tll ans1 = pre[len][x] + pre[prod][x];\n\tll ans2 = pre[len][x];\n\tll a = len + prod;\n\tll b = len;\n\n\twhile (n > a + b)\n\t{\n\t\tll tmp = ans1;\n\t\tans1 += ans2;\n\t\tans2 = tmp;\n\n\t\ttmp = a;\n\t\ta += b;\n\t\tb = tmp;\n\t}\n\treturn ans1 + fib(n - a, x);\n}\n\nll cal(ll n, ll x)\n{\n\tif (n <= len)return pre[n][x];\n\tif (len%prod == 0)\n\t{\n\t\tll res = 1LL * (n - len) / prod*pre[prod][x] + pre[len][x];\n\t\tn -= len;\n\t\tn %= prod;\n\t\treturn res + pre[n][x];\n\t}\n\telse\n\t{\n\t\treturn fib(n, x);\n\t}\n}\n\nvoid solve()\n{\n\tmemset(pre, 0, sizeof(pre));\n\tscanf(\"%s\", val + 1);\n\n\tlen = strlen(val + 1);\n\tlen /= 2;\n\n\tnxt[0] = -1;\n\tint k = -1;\n\tfor (int i = 0; i < len;)\n\t{\n\t\tif (k == -1 || val[k + 1] == val[i + 1])\n\t\t{\n\t\t\tk++;\n\t\t\ti++;\n\t\t\tnxt[i] = k;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk = nxt[k];\n\t\t}\n\t}\n\tprod = len - nxt[len];\n\n\trepp(i, 1, len)\n\t{\n\t\tfor (int k = 0; k < 26; k++)\n\t\t{\n\t\t\tpre[i][k] = pre[i - 1][k];\n\t\t}\n\t\tpre[i][val[i] - 'a']++;\n\t}\n\tscanf(\"%lld%lld\", &le, &ri);\n\n\trep(k, 0, 26)\n\t{\n\t\tprintf(\"%lld \", cal(ri, k) - cal(le - 1, k));\n\t}\n}\n\n\nint main()\n{\n\tsolve();\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\n#define LL long long\n#define ULL unsigned LL\nusing namespace std;\nLL l,r,a[26],b[26],f[95][27],F[95];\nint n; char A[N];\nULL H[N],S[N];\nULL hash(int l,int r){ return H[r]-H[l-1]*S[r-l+1];}\nvoid calc(LL r,int v,LL *a)\n{\n\tint i,j;\n\tif(n%v==0){\n\t\tfor(i=1;i<=n&&i<=r;i++) a[A[i]-'a']++;\n\t\tif(r>=n){\n\t\t\tr-=n;\n\t\t\tfor(i=1;i<=v;i++)\n\t\t\t\ta[A[i]-'a']+=r/v+(r%v>=i);\n\t\t  }\n\t  }\n\telse{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=1;i<=v;i++) f[0][A[i]-'a']++;\n\t\tfor(i=1;i<=n;i++) f[1][A[i]-'a']++;\n\t\tF[0]=v,F[1]=n;\n\t\tfor(i=2;i<=90;i++){\n\t\t\tF[i]=F[i-1]+F[i-2];\n\t\t\tfor(j=0;j<26;j++)\n\t\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\t\tif(F[i]>r) break;\n\t\t  }\n\t\twhile(i){\n\t\t\tif(r>=F[i]){\n\t\t\t\tfor(j=0;j<26;j++) a[j]+=f[i][j];\n\t\t\t\tr-=F[i];\n\t\t\t  }\n\t\t\ti--;\n\t\t  }\n\t\tfor(i=1;i<=r;i++) a[A[i]-'a']++;\n\t  }\n}\nint main()\n{\n\tint i;\n\tscanf(\"%s\",A+1);\n\tn=strlen(A+1)/2;\n\tcin>>l>>r;\n\tS[0]=1;\n\tfor(i=1;i<=n;i++)\n\t\tH[i]=H[i-1]*173+A[i],S[i]=S[i-1]*173;\n\tfor(i=1;i<=n;i++)\n\t\tif(hash(i+1,n)==hash(1,n-i))\n\t\t\tbreak;\n\tcalc(r,i,a);\n\tcalc(l-1,i,b);\n\tfor(i=0;i<26;i++)\n\t\tprintf(\"%lld \",a[i]-b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nchar s[400010];\nll n,a[400010],cnt[110][26],fib[110],fail[400010],m,b[400010],ans[26],l,r;\nvoid getb(){\n\tll i,j=0;fail[0]=fail[1]=0;\n\tfor(i=1;i<n;i++){\n//\t\tcout<<\"enter kmp \"<<i<<' '<<j<<' '<<a[i]<<' '<<a[j]<<'\\n';\n\t\twhile(a[i]!=a[j]&&j) j=fail[j];\n\t\tj+=(a[i]==a[j]);fail[i+1]=j;\n\t}\n//\tfor(i=0;i<=n;i++) cout<<i<<' '<<fail[i]<<'\\n';\n\tfor(i=0;i<n-fail[n];i++) b[i]=a[i];\n\tm=n-fail[n];\n}\nvoid solve(ll lim,ll type){\n\tll i,j;\n//\tcout<<\"solve \"<<lim<<' '<<type<<'\\n';\n\tif(lim<=n){\n\t\tfor(i=1;i<=lim;i++) ans[a[i]]+=type;\n\t\treturn;\n\t}\n\tfor(i=1;i<=100;i++){\n\t\tif(fib[i]<=lim) continue;\n\t\tfor(j=0;j<26;j++) ans[j]+=cnt[i-1][j]*type;\n\t\tsolve(lim-fib[i-1],type);break;\n\t}\n}\nvoid add(ll len,ll type){\n\tll i,tot=len/m;\n\tfor(i=1;i<=m;i++) ans[b[i]]+=tot*type;\n\tfor(i=tot*m+1;i<=len;i++) ans[b[i-tot*m]]+=type;\n} \nvoid another(){\n\tadd(l-1,-1);add(r,1);\n}\nint main(){\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%s\",s);n=strlen(s)>>1;ll i,j;\n\tl=read();r=read();\n\tfor(i=0;i<n;i++) a[i]=s[i]-'a';\n\tgetb();\n\tfor(i=n;i>=1;i--) a[i]=a[i-1];\n\tfor(i=m;i>=1;i--) b[i]=b[i-1];\n//\tif(n%m==0){\n//\t\tanother();goto print;\n//\t}\n\tfor(i=1;i<=n;i++) cnt[0][a[i]]+=1,cnt[1][a[i]]+=1;\n\tfor(i=1;i<=m;i++) cnt[1][b[i]]+=1;\n\tfib[0]=n;fib[1]=(n+m);\n\tfor(i=2;i<=100;i++){\n\t\tfib[i]=fib[i-1]+fib[i-2];\n\t\tfor(j=0;j<=25;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n//\tfor(i=0;i<26;i++) cout<<i<<' '<<cnt[0][i]<<' '<<cnt[1][i]<<'\\n';\n\tsolve(l-1,-1);\n\tsolve(r,1);\n\tprint:\n\tfor(i=0;i<26;i++) printf(\"%lld \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint n,n2,ne[N],g[N][26];\nchar s[N];\nll l,r;\nll cal(int now,ll m){\n\tif (m<=n)return g[m][now];\n\tll l1=n,l2=n2,k,s1=g[l1][now],s2=g[l2][now];\n\twhile (l1+l2<=m){\n\t\tk=l1;l1+=l2;l2=k;\n\t\tk=s1;s1+=s2;s2=k;\n\t}\n\treturn s1+cal(now,m-l1);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tne[0]=-1;\n\tfor (int i=1,j=-1;i<=n;i++){\n\t\twhile (j>=0&&s[j+1]!=s[i])j=ne[j];\n\t\tj++;ne[i]=j;\n\t}\n\tn2=n-ne[n];\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++)g[i][j]=g[i-1][j];\n\t\tg[i][s[i]-97]++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor (int now=0;now<26;now++)printf(\"%lld \",cal(now,r)-cal(now,l-1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=200005;\n\nstruct node{\n\tll v[26];\n\tnode(bool f=0){if(f)memset(v,0,26<<3);}\n\tll&operator[](char c){return v[c-'a'];}\n\tnode friend operator+(const node&a,const node&b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]+=b.v[i];\n\t\treturn c;\n\t}\n\tnode friend operator-(const node&a,const node&b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]-=b.v[i];\n\t\treturn c;\n\t}\n\tnode friend operator*(const node&a,ll b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]*=b;\n\t\treturn c;\n\t}\n\tvoid print(){\n\t\tfor(int i=0;i<26;i++)\n\t\t\tprintf(\"%lld%c\",v[i],\" \\n\"[i==25]);\n\t}\n}ch[N];\n\nchar S[N];\nll l,r,f[105];\nint n,fail[N],m,k;\nnode g[105];\n\nvoid mk(){\n\tg[0]=ch[m];f[0]=m;\n\tg[1]=ch[n];f[1]=n;\n\tfor(k=2;(g[k]=g[k-1]+g[k-2],f[k]=f[k-1]+f[k-2])<=r;k++);\n}\nnode chk1(ll len){\n\tif(len<=n)return ch[len];\n\tnode ret=ch[n];len-=n;\n\tret=ret+ch[m]*(len/m)+ch[len%m];\n\treturn ret;\n}\nnode chk2(ll len){\n\tnode ret(true);\n\tfor(int i=k;i>=1;i--)\n\t\tif(len>=f[i])ret=ret+g[i],len-=f[i];\n\tret=ret+ch[len];len=0;\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1)>>1;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfail[1]=0;ch[1][S[1]]++;\n\tfor(int i=2;i<=n;i++){\n\t\tint p=fail[i-1];\n\t\twhile(p&&S[p+1]!=S[i])p=fail[p];\n\t\tfail[i]=p+(S[p+1]==S[i]);\n\t\tch[i]=ch[i-1];ch[i][S[i]]++;\n\t}\n\tm=n-fail[n];\n\tif(n%m==0)(chk1(r)-chk1(l-1)).print();\n\telse mk(),(chk2(r)-chk2(l-1)).print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nF(SS)->G(STST)\n这里T是S的最短非完整周期，即T是S的前缀，S是T...T的前缀。\n那么只需要考虑S->ST的变换，手玩发现规律得\nS->ST->STS->STSST...\nf(i+2)=f(i+1)+f(i)\n每次取最长的一个前缀f(d)删去以后递归即可，O(logW) \n*/\n\n#include<cstdio>\n#include<cstring>\n\ntypedef long long ll;\nconst int N=200005;\n\nchar s[N]; ll L,R;\nint n,m,fail[N],cnt[26][N];\n\nvoid init()\n{\n\tfor(int j=0; j<26; ++j)\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcnt[j][i]=cnt[j][i-1]+(s[i]-'a'==j);\n\tfor(int i=2,j; i<=n; i++)\n\t{\n\t\tfor(j=fail[i-1];j&&s[j+1]!=s[i];j=fail[j]);\n\t\tfail[i]=j+(s[j+1]==s[i]);\n\t}\n\tm=n-fail[n];\n}\n\nll solve(int j,ll a)\n{\n\tif(a<=n)\n\t\treturn cnt[j][a];\n\tll p=n,q=m,x=cnt[j][n],y=cnt[j][m],tmp;\n\twhile(p+q<=a)\n\t{\n\t\ttmp=p;\n\t\tp+=q;\n\t\tq=tmp;\n\t\ttmp=x;\n\t\tx+=y;\n\t\ty=tmp;\n\t}\n\treturn x+solve(j,a-p);\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&L,&R);\n\tn=strlen(s+1)/2;\n\tinit();\n\tfor(int j=0; j<26; j++)\n\t\tprintf(\"%lld \",solve(j,R)-solve(j,L-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 200005;\n\nLL l, r, ret[26], fib[100], cnt[100][26];\nint n, f[MAXN];\nchar s[MAXN];\n\ninline void Solve(LL r, int v)\n{\n\tif (n % v == 0)\n\t{\n\t\tfor (int i = 1; i <= n && i <= r; i ++)\n\t\t\tret[s[i] - 'a'] ++;\n\t\tif (r >= n)\n\t\t{\n\t\t\tr -= n;\n\t\t\tfor (int i = 1; i <= v; i ++)\n\t\t\t\tret[s[i] - 'a'] += r / v + (r % v >= i);\n\t\t}\n\t}\n\telse\n\t{\n\t\tmset(cnt, 0);\n\t\tfor (int i = 1; i <= v; i ++)\n\t\t\tcnt[0][s[i] - 'a'] ++;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tcnt[1][s[i] - 'a'] ++;\n\t\tfib[0] = v, fib[1] = n;\n\t\tint i;\n\t\tfor (i = 2; fib[i - 1] <= r; i ++)\n\t\t{\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t\tfor (int j = 0; j < 26; j ++)\n\t\t\t\tcnt[i][j] = cnt[i - 1][j] + cnt[i - 2][j];\n\t\t}\n\t\tfor (i --; i; i --)\n\t\t\tif (r >= fib[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 26; j ++)\n\t\t\t\t\tret[j] += cnt[i][j];\n\t\t\t\tr -= fib[i];\n\t\t\t}\n\t\tfor (int i = 1; i <= r; i ++)\n\t\t\tret[s[i] - 'a'] ++;\n\t}\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tscanf(\"%s\", s + 1); n = strlen(s + 1) >> 1;\n\tcin >> l >> r;\n\tf[1] = 0;\n\tfor (int i = 2, j = 0; i <= n; j += s[i] == s[j + 1], f[i ++] = j)\n\t\twhile (j && s[i] != s[j + 1])\n\t\t\tj = f[j];\n\tSolve(l - 1, n - f[n]);\n\tfor (int i = 0; i < 26; i ++)\n\t\tret[i] = -ret[i];\n\tSolve(r, n - f[n]);\n\tfor (int i = 0; i < 26; i ++)\n\t\tprintf(\"%lld%c\", ret[i], i == 25 ? '\\n' : ' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n//f[i] = f[i-1]+f[i-2]\n//or f[i] = f[i-1]+s\nchar s1[200005], s2[400005], s3[800005];\nlong long len[105];\nlong long all[105][30];\nlong long cnt[30];\nlong long before[30],after[30];\nint next[400005];\n\n\nvoid exKmp(char s[],int n,int next[]){\n    int l = 0, r = 0;\n    for(int i = 2; i <= n; i++){\n        if(i>r){\n            l = i, r = i-1;\n            while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n            next[i] = r-l+1;\n        }\n        else{\n            int k = i-l+1;\n            if(i+next[k]-1<r) next[i] = next[k];\n            else{\n                l = i;\n                while(r+1<=n && s[r+1]==s[r+1-l+1]) r++;\n                next[i] = r-l+1;\n            }\n        }\n    }\n}\n//return new size\nint getNextString(char s[],char t[],int n){\n    exKmp(s,n,next);\n    //for(int i = 1; i <= n; i++) printf(\"next[%d] = %d\\n\",i,next[i]);\n    int find = n+1;\n    for(int i = n/2+2; i <= n; i++){\n        if(next[i]==(n-i+1)){\n            find = i;\n            break;\n        }\n    }\n    int size = 0;\n    for(int rnd = 0; rnd < 2; rnd++){\n        for(int i = 1; i <= find-1; i++) t[++size] = s[i];\n    }\n    t[size+1] = '\\0';\n    return size;\n}\n\nvoid getRegular(long long cycle,long long n,long long upper,long long keep[]){\n    if(upper<=n){\n        for(int i = 1; i <= 26; i++) keep[i] = 0;\n        for(int i = 1; i <= upper; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        for(int i = 1; i <= 26; i++) cnt[i] = 0;\n        for(int i = 1; i <= cycle; i++){\n            int u = s1[i]-'a'+1;\n            cnt[u]++;\n        }\n        long long time = (upper-n)/cycle;\n        long long left = (upper-n)-time*cycle;\n        for(int i = 1; i <= 26; i++) keep[i] = time*cnt[i];\n        for(int i = 1; i <= left; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n        for(int i = 1; i <= n; i++){\n            int u = s1[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n}\n\nvoid getFib(long long upper,long long keep[]){\n    if(upper<=len[2]){\n        for(int i = 1; i <= upper; i++){\n            int u = s2[i]-'a'+1;\n            keep[u]++;\n        }\n    }\n    else{\n        int p = 1;\n        while(len[p]<upper) p++;\n        int last = p-1;\n        for(int i = 1; i <= 26; i++) keep[i] += all[last][i];\n        upper -= len[last];\n        getFib(upper,keep);\n    }\n}\n\nint main(){\n    scanf(\"%s\",s1+1);\n    long long l,r;\n    scanf(\"%lld%lld\",&l,&r);\n    int size1 = strlen(s1+1);\n    int size2 = getNextString(s1,s2,size1);\n    int size3 = getNextString(s2,s3,size2);\n    //printf(\"size1 = %d, size2 = %d, size3 = %d\\n\",size1,size2,size3);\n    //printf(\"%s\\n%s\\n%s\\n\",s1+1,s2+1,s3+1);\n    if((size2-size1)==(size3-size2)){\n        int cycle = size2-size1;\n        getRegular(cycle,size1,l-1,before);\n        getRegular(cycle,size1,r,after);\n    }\n    else{\n        len[1] = size1, len[2] = size2;\n        for(int i = 1; i <= size1; i++){\n            int u = s1[i]-'a'+1;\n            all[1][u]++;\n        }\n        for(int i = 1; i <= size2; i++){\n            int u = s2[i]-'a'+1;\n            all[2][u]++;\n        }\n        for(int i = 3; ; i++){\n            len[i] = len[i-1]+len[i-2];\n            for(int j = 1; j <= 26; j++) all[i][j] = all[i-1][j]+all[i-2][j];\n            if(len[i]>=r) break;\n        }\n        getFib(l-1,before);\n        getFib(r,after);\n    }\n    for(int i = 1; i <= 26; i++) printf(\"%lld \",after[i]-before[i]);\n    printf(\"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntypedef long long ll;\nstruct RollingHash {\n\tstatic const ll mo0 = 1000000007, mo1 = 1000000009;\n\tstatic ll mul0, mul1;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tstatic vector<ll> pmo[2];\n\tvector<int> s; int l; vector<ll> hash_[2];\n\tvoid init(vector<int> s) {\n\t\tthis->s = s; l = s.size(); int i, j;\n\t\thash_[0] = hash_[1] = vector<ll>(1, 0);\n\t\tif (!mul0) mul0 = 10009 + (((ll)&mul0) >> 5) % 259, mul1 = 10007 + (((ll)&mul1) >> 5) % 257;\n\t\tif (pmo[0].empty()) pmo[0].push_back(1), pmo[1].push_back(1);\n\t\tfor (int i = 0; i < l; i++) hash_[0].push_back((hash_[0].back()*mul0 + add0 + s[i]) % mo0);\n\t\tfor (int i = 0; i < l; i++) hash_[1].push_back((hash_[1].back()*mul1 + add1 + s[i]) % mo1);\n\t}\n\tpair<ll, ll> hash(int l, int r) { // s[l..r]\n\t\tif (l>r) return make_pair(0, 0);\n\t\twhile (pmo[0].size()<r + 2)\n\t\t\tpmo[0].push_back(pmo[0].back()*mul0%mo0), pmo[1].push_back(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r + 1] + (mo0 - hash_[0][l] * pmo[0][r + 1 - l] % mo0)) % mo0,\n\t\t\t(hash_[1][r + 1] + (mo1 - hash_[1][l] * pmo[1][r + 1 - l] % mo1)) % mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0, RollingHash::mul1;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n#define INF 1LL<<60\nstring S, SS, SSS;\nll L, R;\n//---------------------------------------------------------------------------------------------------\nstring f(string x) {\n    RollingHash rh;\n    vector<int> v;\n    for (char c : x) v.push_back(c - 'a');\n    rh.init(v);\n\n    int N = v.size();\n    rep(len, (N + 2) / 2, N + 1) {\n        int a = 0;\n        int c = len;\n        int d = min(len * 2 - 1, N - 1);\n        int b = a + (d - c + 1) - 1;\n\n        if (rh.hash(a, b) == rh.hash(c, d)) {\n            return x + x.substr(b + 1, c - b - 1);\n        }\n    }\n    return \"?\";\n}\n//---------------------------------------------------------------------------------------------------\nll cnt[201];\nvector<ll> memo[201];\nvoid pre() {\n    SS = f(S);\n    SSS = f(SS);\n\n    cnt[1] = SS.length() / 2;\n    cnt[2] = SSS.length() / 2;\n\n    rep(i, 3, 201) {\n        cnt[i] = cnt[i - 1] + cnt[i - 2];\n        if (INF < cnt[i]) cnt[i] = INF;\n    }\n\n    memo[1].resize(26, 0);\n    rep(i, 0, cnt[1]) memo[1][SS[i] - 'a']++;\n\n    memo[2].resize(26, 0);\n    rep(i, 0, cnt[2]) memo[2][SSS[i] - 'a']++;\n\n    rep(i, 3, 201) {\n        memo[i].resize(26, 0);\n        rep(j, 0, 26) memo[i][j] = memo[i - 1][j] + memo[i - 2][j];\n    }\n}\n//---------------------------------------------------------------------------------------------------\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n    vector<ll> v(26, 0);\n    rep(i, 0, 26) v[i] = a[i] + b[i];\n    return v;\n}\nvector<ll> rec(ll x, int d) {\n    if (x == cnt[d]) return memo[d];\n\n    if (d == 1) {\n        vector<ll> v(26, 0);\n        rep(i, 0, x) v[SS[i] - 'a']++;\n        return v;\n    }\n\n    if (d == 2) {\n        vector<ll> v(26, 0);\n        rep(i, 0, x) v[SSS[i] - 'a']++;\n        return v;\n    }\n\n    if (x <= cnt[d - 1]) return rec(x, d - 1);\n\n    auto a = rec(cnt[d - 1], d - 1);\n    auto b = rec(x - cnt[d - 1], d - 2);\n    a = merge(a, b);\n\n    return a;\n}\nvector<ll> _rec(ll x, int d) {\n    auto a = rec(cnt[d], d);\n    auto b = rec(x - cnt[d], d);\n    a = merge(a, b);\n    return a;\n}\nvector<ll> solve(ll x) {\n    if (x <= cnt[1] * 2) {\n        vector<ll> v(26, 0);\n        rep(i, 0, x) v[SS[i] - 'a']++;\n        return v;\n    }\n\n    int init_i;\n    rep(i, 1, 200) {\n        if (cnt[i] * 2 < x && x <= cnt[i + 1] * 2) {\n            init_i = i + 1;\n            break;\n        }\n    }\n\n    return _rec(x, init_i);\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S >> L >> R;\n\n    pre();\n\n    auto a = solve(L - 1);\n    auto b = solve(R);\n\n    rep(i, 0, 26) b[i] -= a[i];\n    rep(i, 0, 26) {\n        if (0 < i) printf(\" \");\n        printf(\"%lld\", b[i]);\n    }\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n\ntypedef long long LL;\nconst int N=100005;\n\nint fail[N],n,t;\nLL cnt[90][26],f[90],ans[26];\nchar s[N*2];\n\nvoid count(int pos,LL *a){\n\tfor (int i=1;i<=pos;i++) a[s[i]-'a']++;\n}\n\nvoid calc(LL pos){\n\tif (pos<=n){\n\t\tcount(pos,ans);\n\t\treturn;\n\t}\n\tint m=0;\n\tfor (;f[m+1]<=pos;m++);\n\tfor (int i=0;i<26;i++) ans[i]+=cnt[m][i];\n\tcalc(pos-f[m]);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tfail[0]=-1;\n\tfor (int i=1,j=-1;i<=n;fail[i++]=++j)\n\t\tfor (;j>=0 && s[j+1]!=s[i];j=fail[j]);\n\tt=n-fail[n];\n\tf[0]=t;count(t,cnt[0]);\n\tf[1]=n;count(n,cnt[1]);\n\tLL l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor (int i=2;f[i-1]<=r;i++){\n\t\tf[i]=f[i-1]+f[i-2];\n\t\tfor (int j=0;j<26;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n\tcalc(l-1);\n\tfor (int i=0;i<26;i++) ans[i]*=-1;\n\tcalc(r);\n\tfor (int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n} \n\nstring s,t;\nll l,r,S,T;\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tint M=0,I=S;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(M<z[i]&&z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tI=i;\n\t\t}\n\t}\n\tt=(I==S?s:s.substr(0,I));\n\tT=t.size();\n\tif(S%T==0){\n\t\tvl a(26);\n\t\tfor(int i=l;i<S;i++) a[f(s[i])]++;\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(r<=S?0:(r-S)/T);\n\t\tfor(int i=0;i<(r-S)%T;i++) a[f(t[i])]++;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<a[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 20160116\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n// cf IO: I64d\n// atcoder IO: lld\nconst int Maxn=500005;\nconst long long mod=12384738759127LL;\nconst long long tim=1311;\nchar s[Maxn];\nint n;\nlong long cnt[Maxn][26],ans[26];\nlong long l,r;\nvoid Output(long long x[]){\n\tfor (int i=0;i<26;i++){\n\t\tprintf(\"%lld \",x[i]);\n\t}\n\tprintf(\"\\n\");\n\texit(0);\n}\npair<long long,vector<long long> > go(long long len,vector<long long> lfsum, long long lflen,vector<long long> rgsum,long long rglen){\n\tvector<LL> ret,newlf,newrg;\n\tret.resize(26,0);\n\tnewlf.resize(26,0);\n//\tnewrg.resize(26,0);\n\tif (lflen+rglen<=len){\n\t\tfor (int i=0;i<26;i++){\n\t\t\tnewlf[i]=lfsum[i]+rgsum[i];\n\t\t}\n\t\tpair<LL,vector<LL> > tmp=go(len,newlf,lflen+rglen,lfsum,lflen);\n\t\tfor (int i=0;i<26;i++) ret[i]+=(tmp.second)[i];\n\t\tlen=tmp.first;\n\t}\n\tif (len>=lflen){\n\t\tfor (int i=0;i<26;i++) ret[i]+=lfsum[i];\n\t\tlen-=lflen;\n\t}\n\treturn mp(len,ret); \n}\nvector<long long> solve(long long target,int pre){\n\tvector<LL> lf,rg;\n\tlf.resize(26),rg.resize(26,0);\n\tfor (int i=0;i<26;i++){\n\t\tlf[i]=cnt[n-pre][i];\n\t\trg[i]=cnt[n][i]-cnt[n-pre][i];\n\t}\n\tpair<LL,vector<LL> > res=go(target,lf,(LL)n-pre,rg,(LL)pre);\n\t//cout<<res.first<<endl;\n\tfor (int i=0;i<26;i++){\n\t\t(res.second)[i]+=cnt[res.first][i];\n\t} \n\treturn res.second;\n}\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tn/=2;\n\tscanf(\"%lld %lld\",&l,&r);\n\tlong long hashval1=0,hashval2=0;\n\tlong long now=1;\n\tint len=0;\n\tfor (int i=0;i<n-1;i++){\n\t\thashval1=hashval1*tim;\n\t\thashval1+=(long long)s[i];\n\t\thashval2+=now*(long long)s[n-i-1];\n\t\thashval1%=mod;\n\t\thashval2%=mod;\n\t\tnow*=tim;\n\t\tnow%=mod;\n\t\tif (hashval1==hashval2){\n\t\t\tlen=i+1;\n\t\t}\n\t}\n\t//cout<<len<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++){\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tl--;\n\tif (len==0){\n\t\tlong long tot=0;\n\t\tfor (int i=0;i<26;i++){\n\t\t\tans[i]+=cnt[n][i]*(r/n);\n\t\t\tans[i]-=cnt[n][i]*(l/n);\n\t\t\tans[i]+=cnt[r%n][i];\n\t\t\tans[i]-=cnt[l%n][i];\n\t\t\ttot+=ans[i];\n\t\t}\n\t\t//cout<<tot<<endl;\n\t\tOutput(ans);\n\t\treturn 0;\n\t}\n\tvector<LL> ans1=solve(r,len);\n\tvector<LL> ans2=solve(l,len);\n\tfor (int i=0;i<26;i++){\n\t\tans1[i]-=ans2[i];\n\t\tprintf(\"%lld \",ans1[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n/*\nasdcasdcbbcbdabscbasbdcbbdcbdbcdababsdbcasbdcbasbdcbasdbcbaasdcbabdbcbdbcabdcbdsbcbadsbcbbdcsbbadbcsbasbdcasdcasdcbbcbdabscbasbdcbbdcbdbcdababsdbcasbdcbasbdcbasdbcbaasdcbabdbcbdbcabdcbdsbcbadsbcbbdcsbbadbcsbasbdc\n1 1000000000000000000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt <= end && y*ycnt <= end && x*xcnt+y*ycnt > 0 && x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  // first step\n  s = f(s);\n  // second\n  string t = f(s);\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r+1);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(X,Y,l);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 200010,int lnN = 18>\nstruct String{\n\tstring S;\n\tint sa[N][lnN];\n\tvoid sa_init(){\n\t\tif(true){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tvec.push_back(P(S[i],0));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tsa[i][0] = lower_bound(vec.begin(),vec.end(),P(S[i],0)) - vec.begin();\n\t\t\t}\n\t\t}\n\t\tfor(int t = 1 ; t < lnN ; t ++){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size())vec.push_back(P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]));\n\t\t\t\telse vec.push_back(P(sa[i][t-1],-1));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size()){\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]))-vec.begin();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],-1)) - vec.begin();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool eq(int x,int y,int l){\n\t\tfor(int t = lnN-1 ; t >= 0 ; t--){\n\t\t\tif(l < (1<<t))continue;\n\t\t\tif(sa[x][t] != sa[y][t])return false;\n\t\t\tl -= 1<<t;\n\t\t}\n\t\treturn true;\n\t}\n};\nString<> str;\n\nstring A,B;\nvector<P> vec;\nll ret[26];\nll cnt_A[26];\nll cnt_B[26];\nvoid cnt(ll x,ll k){\n\t//cout << x << \" \" << k << endl;\n\tif(x <= A.size()+B.size()){\n\t\tfor(int i = 0 ; i < min( x , (ll)A.size() ) ; i ++){\n\t\t\tret[A[i]-'a'] += k;\n\t\t}\n\t\tfor(int i = A.size() ; i < x ; i ++){\n\t\t\tret[B[i-A.size()]-'a'] += k;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; i+1 < vec.size() ; i ++){\n\t\tif(vec[i+1].fr*A.size()+vec[i+1].sc*B.size() <= x)continue;\n\t\tll len = vec[i].fr*A.size() + vec[i].sc*B.size();\n\t\tfor(int j = 0 ; j < 26 ; j ++){\n\t\t\tret[j] += cnt_A[j]*vec[i].fr*k;\n\t\t\tret[j] += cnt_B[j]*vec[i].sc*k;\n\t\t}\n\t\tcnt(x-len,k);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tll l,r;\n\tcin >> str.S;\n\tcin >> l >> r;\n\t\n\tstr.sa_init();\n\tA = \"\";\n\tfor(int i = str.S.size()/2+1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tA = str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//A = str.S.substr(0,str.S.size()/2);\n\tstr.S = A;\n\tstr.sa_init();\n\tfor(int i = 1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tB = str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//cout << A << \" \" << B << endl;\n\t\n\tvec.push_back(P(0,1));\n\tvec.push_back(P(1,0));\n\twhile(1){\n\t\tP p;\n\t\tp.fr = vec[vec.size()-2].fr + vec[vec.size()-1].fr;\n\t\tp.sc = vec[vec.size()-2].sc + vec[vec.size()-1].sc;\n\t\tvec.push_back(p);\n\t\tif(p.fr*A.size()+p.sc*B.size() > r)break;\n\t}\n\tfor(int i = 0 ; i < A.size() ; i ++){\n\t\tcnt_A[A[i]-'a'] ++;\n\t}\n\tfor(int i = 0 ; i < B.size() ; i ++){\n\t\tcnt_B[B[i]-'a'] ++;\n\t}\n\t\n\tcnt(r,1);\n\tcnt(l-1,-1);\n\tfor(int i = 0 ; i < 26 ; i ++){\n\t\tprintf(\"%lld%c\",ret[i],(i==25)?'\\n':' ');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nchar s[500005];\nlong long l,r,siz[500005],sum[500005][26],ans[26];\nint n,lim,nxt[500005];\n\nvoid get_next(){\n\tint i=1,j=0;\n\tnxt[1]=0;\n\twhile(i<=n){\n\t\tif(j==0||s[i]==s[j]){\n\t\t\tnxt[++i]=++j;\n\t\t}else j=nxt[j];\n\t}\n}\n\nvoid get_ans(long long x,int f){\n\tfor(int i=lim;i>=0;i--)\n\t\tif(x>=siz[i]){\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tans[j]+=f*sum[i][j];\n\t\t\tx-=siz[i];\n\t\t}\n\tfor(int i=1;i<=x;i++)ans[s[i]-'a']+=f;\n}\n\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1)>>1;\n\tget_next();\n\tint t=nxt[n];\n\tfor(int i=1;i<=n;i++)sum[0][s[i]-'a']++;\n\tfor(int i=0;i<26;i++)sum[1][i]=sum[0][i];\n\tfor(int i=1;i<=n-t;i++)sum[1][s[i]-'a']++;\n\tsiz[0]=n,siz[1]=2*n-t;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int j=0;j<26;j++)\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\tsiz[i]=siz[i-1]+siz[i-2];\n\t\tif(siz[i]>1e18){lim=i;break;}\n\t}\n\tget_ans(l-1,-1);\n\tget_ans(r,1);\n\tfor(int i=0;i<26;i++)printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\n#define LL long long\n\nchar s[N];\nint tot[N][26],f[N];\nint n,T;\n\nLL calc(LL len,int ch){\n\tif(len<=n) return tot[len][ch];\n\tLL num1=tot[n][ch],num2=tot[T][ch];\n\tLL len1=n,len2=T;\n\twhile(len1+len2<=len){\n\t\tnum1=num1+num2,num2=num1-num2;\n\t\tlen1=len1+len2,len2=len1-len2;\n\t}\n\treturn num1+calc(len-len1,ch);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tf[0]=0;f[1]=0;tot[1][s[1]-'a']=1;\n\tfor(int i=2,p;i<=n;i++){\n\t\tp=f[i-1];\n\t\twhile(p&&s[p+1]!=s[i]) p=f[p];\n\t\tf[i]=s[p+1]!=s[i] ? 0:p+1;\n\t\tmemcpy(tot[i],tot[i-1],sizeof(tot[i]));\n\t\ttot[i][s[i]-'a']++;\n\t}\n\tT=n-f[n];\n\tLL l,r;\n\tcin>>l>>r;\n\tfor(int i=0;i<26;i++)\tcout<<calc(r,i)-calc(l-1,i)<<\" \";\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\n#define rl rd<LL>\nusing namespace std;\ntypedef long long LL;\nconst int maxN = 2e5 + 7;\nconst int maxC = 26;\nconst int maxM = 127;\nconst LL INF = 1e18;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nchar s[maxN];\nint n, len, t;\nint nx[maxN];\nLL occ[maxC];\nLL L, R;\n\nvoid kmp() {\n\tnx[1] = 0; int i, j;\n\tfor (i = 2, j = 0; i <= n; ++ i) {\n\t\twhile (j && s[j+1] != s[i]) j = nx[j];\n\t\tif (s[j+1] == s[i]) ++ j;\n\t\tnx[i] = j;\n\t}\n}\n\nvoid solve1(LL len, LL kd) {\n\tLL tms = len / t, res = len % t;\n\trep (i, 1, t) occ[s[i] - 'a'] += kd * (tms + (i <= res));\n}\n\nnamespace solve2 {\n\tLL f[maxM][maxC], len[maxM], Top;\n\t\n\tvoid init() {\n\t\tlen[1] = t; rep (i, 1, t) ++ f[1][s[i] - 'a'];\n\t\tlen[0] = n - t; rep (i, t+1, n) ++ f[0][s[i] - 'a'];\n\t\tFor (i, 2, maxM) {\n\t\t\tlen[i] = len[i-1] + len[i-2];\n\t\t\tTop = i;\n\t\t\tFor (j, 0, maxC) f[i][j] = f[i-1][j] + f[i-2][j];\n\t\t\tif (len[i] > INF) break;\n\t\t}\n\t}\n\n\tvoid dfs(int p, LL l, LL kd) {\n\t\tif (l <= 0) return;\n\t\tassert(l <= len[p]);\n\t\tif (l == len[p]) {\n\t\t\tFor (i, 0, 26) occ[i] += kd * f[p][i];\n\t\t\treturn;\n\t\t}\n\t\tif (p == 0 || p == 1) {\n\t\t\tint bg = (p == 1) ? 0 : t;\n\t\t\trep (i, 1, l) occ[s[bg+i] - 'a'] += kd;\n\t\t\treturn;\n\t\t}\n\t\tdfs(p-1, min(l, len[p-1]), kd);\n\t\tdfs(p-2, l - len[p-1], kd);\n\t}\n\n\tvoid work(LL l, LL kd) {\n\t\tdfs(Top, l, kd);\n\t}\n}\n\nint main() {\n\n\tscanf(\"%s\", s+1);\n\tL = rl(), R = rl();\n\tn = strlen(s+1) >> 1;\n\tlen = (n + 1) >> 1;\n\tkmp();\n\t\n\tt = n - nx[n];\n\tif (n % t == 0) solve1(R, 1), solve1(L-1, -1);\n\telse solve2::init(), solve2::work(R, 1), solve2::work(L-1, -1);\n\n\tFor (i, 0, 26) printf(\"%lld%c\", occ[i], \" \\n\"[i == 25]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int p=998244353;\ntypedef unsigned long long ull;\nint n,len,mx;\nlong long l,r,siz[110],cnt1[110],cnt2[110],ans[26],sum[110][26];\null fhash[200010],bhash[200010],bs[200010];\nchar s[200010];\nvoid solve(long long m,int type){\n\tfor(int i=mx;~i;i--){\n\t\tif(m>=siz[i]){\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tans[j]+=type?sum[i][j]:-sum[i][j];\n\t\t\tm-=siz[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tans[s[i]-'a']+=type?1:-1;\n\treturn;\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1);\n\tbs[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfhash[i]=fhash[i-1]*p+(s[i]-'a'+1);\n\t\tbs[i]=bs[i-1]*p;\n\t}\n\tfor(int i=n;~i;i--)\n\t\tbhash[i]=bhash[i+1]+(s[i]-'a'+1)*bs[n-i];\n\tfor(int i=n/2-1;~i;i--)\n\t\tif(fhash[i]==bhash[n-i+1]){\n\t\t\tlen=i;\n\t\t\tbreak;\n\t\t}\n\tfor(int i=1;i<=n/2;i++)\n\t\tsum[0][s[i]-'a']++;\n\tfor(int i=0;i<26;i++)\n\t\tsum[1][i]=sum[0][i];\n\tfor(int i=1;i<=n/2-len;i++)\n\t\tsum[1][s[i]-'a']++;\n\tsiz[0]=n/2;\n\tsiz[1]=n-len;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int j=0;j<26;j++)\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\tsiz[i]=siz[i-1]+siz[i-2];\n\t\tif(siz[i]>1e18){\n\t\t\tmx=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsolve(l-1,0);\n\tsolve(r,1);\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,m,fail[100010];\nll ans[30],len[95],sum[95][30],cnt[100010][30];\nchar s[100010];\nvoid kmp()\n{\n\tfail[0]=-1;\n\tint p=-1;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\twhile (p>=0 && s[i]!=s[p+1])\n\t\t{\n\t\t\tp=fail[p];\n\t\t}\n\t\tif (s[i]==s[p+1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\tfail[i]=p;\n\t}\n}\nvoid solve(ll k,ll f)\n{\n\tll p=k/(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*p*cnt[m][i];\n\t}\n\tll q=k%(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[q][i];\n\t}\n}\nvoid work(ll k,ll f)\n{\n\tint i=1;\n\twhile (len[i]<=k)\n\t{\n\t\ti++;\n\t}\n\tfor (;i;i--)\n\t{\n\t\tif (k>len[i])\n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tans[j]+=f*sum[i][j];\n\t\t\t}\n\t\t\tk-=len[i];\n\t\t}\n\t}\n\tfor (i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[k][i];\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",&s);\n\tn=strlen(s);\n\tn/=2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tkmp();\n\tm=n-1-fail[n-1];\n\tll l,r;\n\tcin>>l>>r;\n\tif (n%m==0)\n\t{\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t\tassert(false);\n\t}\n\telse\n\t{\n\t\tlen[1]=n;\n\t\tlen[2]=m+n;\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tsum[1][i]=cnt[n][i];\n\t\t\tsum[2][i]=cnt[m][i]+sum[1][i];\n\t\t}\n\t\tfor (int i=3;i<=90;i++)\n\t\t{\n\t\t\tlen[i]=len[i-2]+len[i-1];\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\t\t}\n\t\t}\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define max(x, y) ((x) > (y) ? (x) : (y))\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\nstruct C {\n\tlong long sum[26];\n\tlong long s;\n\tC() {\n\t\tmemset(sum, 0, sizeof sum);\n\t\ts = 0;\n\t}\n} F[1100];\n\nC operator * (C x, long long y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] *= y;\n\tx.s *= y;\n\treturn x;\n}\n\nC operator + (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] += y.sum[i];\n\tx.s += y.s;\n\treturn x;\n}\n\nC operator - (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] -= y.sum[i];\n\tx.s -= y.s;\n\treturn x;\n}\n\nint len;\nint n;\nchar S[210000];\nint ne[210000];\n\nC query(int k, long long l, long long r) {\n\t// printf(\"?? %d %lld %lld\\n\", k, l, r);\n\tif (k <= 1) {\n\t\tif (k == 0) {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, ne[n]);\n\t\t}else {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, n);\n\t\t}\n\t\tC ans;\n\t\tmemset(ans.sum, 0, sizeof ans.sum);\n\t\tans.s = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1, ans.s += 1;\n\t\treturn ans;\n\t}\n\tif (l <= 1 && r >= F[k].s)\n\t\treturn F[k];\n\tif (r <= F[k - 1].s)\n\t\treturn query(k - 1, l, r);\n\telse if (l > F[k - 1].s)\n\t\treturn query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n\telse\n\t\treturn query(k - 1, l, r) + query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n}\n\nint main() {\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\tint p = 0;\n\tne[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (; p && S[p + 1] != S[i]; p = ne[p]);\n\t\tif (S[p + 1] == S[i])\n\t\t\tp ++;\n\t\tne[i] = p;\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r;\n\tif (ne[n] * 2 >= n) {\n\t\tint c = n - ne[n];\n\t\tC pp;\n\t\tfor (int i = 1; i <= c; i++)\n\t\t\tpp.sum[S[i] - 'a'] += 1, pp.s += 1;\n\t\tC ans = pp * (r / c);\n\t\tfor (int i = 1; i <= r % c; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1;\n\t\tl -= 1;\n\t\tans = ans - (pp * (l / c));\n\t\tfor (int i = 1; i <= l % c; i++)\n\t\t\tans.sum[S[i] - 'a'] -= 1;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"\\n\");\n\t}else {\n\t\tlen = 1;\n\t\tfor (int i = 1; i <= n - ne[n]; i++)\n\t\t\tF[0].sum[S[i] - 'a'] += 1, F[0].s += 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tF[1].sum[S[i] - 'a'] += 1, F[1].s += 1;\n\t\twhile (F[len].s <= 1000000000000000000LL) {\n\t\t\tF[len + 1] = F[len] + F[len - 1];\n\t\t\tlen += 1;\n\t\t}\n\t\tC ans = query(len, l, r);\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nll rui[300000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t)\n{\n\tif (len[2] - len[1] == len[1] - len[0])\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\ts = conv(s);\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf), v2 = get(lf - 1);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252*2];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt <= end && y*ycnt <= end && x*xcnt+y*ycnt > 0 && x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  s = f(s);\n  int x1 = s.size();\n  // first step\n  s = f(s);\n  int x2 = s.size();\n  // second\n  string t = f(s);\n  int x3 = t.size();\n\n  if(x3-x2 == x2-x1){\n    int width = x3-x2;\n    {\n      ll x = r;\n      ll tms = x/width;\n      ll y = x-tms*width;\n      REP(i,width)ans[s[i]-'a'] += tms;\n      REP(i,y)ans[s[i]-'a']++;\n    }\n    {\n      ll x = l-1;\n      ll tms = x/width;\n      ll y = x-tms*width;\n      REP(i,width)ans[s[i]-'a'] -= tms;\n      REP(i,y)ans[s[i]-'a']--;\n    }\n    REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n    return 0;\n  }\n  assert(false);\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r+1);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(X,Y,l);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nstring S;\nLL L, R;\nusing V = array<LL, 26>;\n\n// re[i] := S[0..i-1]の接頭辞・接尾辞が最大何文字一致しているか\nvoid mp(const string &S, vector<int> &re){\n  re.resize(S.size()+1); re[0]=-1;\n  int j=-1;\n  rep(i, S.size()){\n    while(j>=0 && S[i]!=S[j]) j=re[j];\n    re[i+1]=++j;\n  }\n}\n\nV Count(string &s) {\n  V ret = {};\n  for (char c : s) {\n    ret[c-'a']++;\n  }\n  return ret;\n}\n\nLL Sum(V &a) {\n  LL ret = 0;\n  rep(i, 26) {\n    ret += a[i];\n  }\n  return ret;\n}\n\nV Solve(LL r) {\n  V ret = {};\n  if (!r) return ret;\n\n  if (S.size()*2 >= r) {\n    string SS = S+S;\n    rep(i, r) {\n      ret[SS[i]-'a']++;\n    }\n    return ret;\n  }\n\n  vector<int> re;\n  mp(S, re);\n  int n = S.size();\n  int w = n - re[n];\n  string P = S.substr(0, w);\n  auto a = Count(P);\n  if (n%w == 0) {\n    rep(i, 26) {\n      ret[i] += a[i] * (r/w);\n    }\n    rep(i, r%w) {\n      ret[P[i]-'a']++;\n    }\n    return ret;\n  }\n  \n  vector<V> series;\n  series.eb(a);\n  series.eb(Count(S));\n  int idx = 1;\n  while (1) {\n    if (Sum(series[idx])*2 >= r) {\n      assert (Sum(series[idx]) < r);\n      {\n        ret = series[idx];\n        r -= Sum(series[idx]);\n      }\n      break;\n    }\n\n    series.eb();\n    rep(i, 26) {\n      series.back()[i] = series[idx-1][i] + series[idx][i];\n    }\n    ++idx;\n  }\n\n  while (idx > 0) {\n    //cout << \"r: \" << r << endl;\n    //cout << idx << \": \";\n    //rep(i, 26) {\n    //  if (i) cout << \" \";\n    //  cout << ret[i];\n    //}cout << endl;\n    assert(Sum(series[idx]) >= r);\n    --idx;\n    if (Sum(series[idx]) <= r) {\n      rep(i, 26) ret[i] += series[idx][i];\n      r -= Sum(series[idx]);\n      --idx;\n    }\n  }\n  assert(idx == 0 && Sum(series[idx]) >= r);\n  assert(r <= w);\n  rep(i, r) {\n    ret[P[i]-'a']++;\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> S;\n  assert(S.size()%2 == 0);\n  S = S.substr(S.size()/2);\n  cin >> L >> R;\n  auto ans = Solve(R);\n  auto sub = Solve(L-1);\n  rep(i, 26) {\n    if (i) cout << \" \";\n    assert(ans[i] >= sub[i]);\n    cout << ans[i] - sub[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define b 31ll\n#define mod 1004535809ll\n#define ll long long\nusing namespace std;\nchar s[400005];\nll l[1005],fib[1005][27],ans[27];\nll has[400005],m[400005],lo,hi;\nint len,t;\ninline ll get(int l,int r)\n{if (l>r) return 0;\nll ret=(has[r]-has[l-1]*m[r-l+1])%mod;\nreturn (ret<0?ret+mod:ret);\n}\ninline void add(ll p,int pos)\n{if (pos<=1)\n{for (int i=1;i<=p;i++)\n{ans[s[(i-1)%len+1]-'a']++;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]+=fib[pos-1][i];\nadd(p-l[pos-1],pos-2);\nreturn;\n}\nadd(p,pos-1);\n}\ninline void del(ll p,int pos)\n{if (pos<=1)\n{for (int i=1;i<=p;i++)\n{ans[s[(i-1)%len+1]-'a']--;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]-=fib[pos-1][i];\ndel(p-l[pos-1],pos-2);\nreturn;\n}\ndel(p,pos-1);\n}\nint main (){\n\tint i,j,las;\n\tgets(s+1);len=strlen(s+1);\n\tscanf (\"%lld%lld\",&lo,&hi);\n\tm[0]=1ll;len>>=1;\n\tfor (i=1;i<=len;i++)\n\t{m[i]=m[i-1]*b%mod;\n\thas[i]=has[i-1]*b+(s[i]-'0');\n\thas[i]%=mod;\n\t}\n\tfor (i=1;i<=len;i++)\n\t{if (get(1,len-i)==get(i+1,len))\n\t{t=i;break;}\n\t}\n\tl[0]=len;l[1]=len+t;\n\tfor (i=1;i<=len;i++)\n\t{fib[0][s[i]-'a']++;\n\tfib[1][s[i]-'a']++;\n\t}\n\tfor (i=1;i<=t;i++)\n\t{fib[1][s[i]-'a']++;}\n\tfor (i=2;l[i-2]+l[i-1]<=2ll*hi;i++)\n\t{for (j=0;j<26;j++)\n\t{fib[i][j]=fib[i-1][j]+fib[i-2][j];}\n\tl[i]=l[i-1]+l[i-2];\n\tlas=i;\n\t}\n\tadd(hi,las);del(lo-1,las);\n\tfor (i=0;i<26;i++)\n\t{printf (\"%lld \",ans[i]);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\tint i,j;\n\tfor(i=99;i>=2;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) cnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nvector<Int> zalgorithm(string s){\n  Int n=s.size();\n  vector<Int> a(n,0);\n  a[0]=n;\n  Int i=1,j=0;\n  while(i<n){\n    while(i+j<n&&s[j]==s[i+j]) j++;\n    a[i]=j;\n    if(j==0){\n      i++;\n      continue;\n    }\n    Int k=1;\n    while(i+k<n&&k+a[k]<j) a[i+k]=a[k],k++;\n    i+=k;\n    j-=k;\n  }\n  return a;\n}\n\n//INSERT ABOVE HERE\nusing vint = vector<Int>;\nvoid print(const vint &v){\n  for(Int i=0;i<(Int)v.size();i++){\n    if(i) cout<<\" \";\n    cout<<v[i];\n  }\n  cout<<endl;\n}\n\nvint add(const vint &a,const vint &b){\n  vint c(26,0);\n  for(Int i=0;i<26;i++) c[i]=a[i]+b[i];\n  return c;\n}\nvint sub(const vint &a,const vint &b){\n  vint c(26,0);\n  for(Int i=0;i<26;i++) c[i]=a[i]-b[i];\n  return c;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  Int l,r;\n  cin>>l>>r;\n  l--;\n  {\n    string t(s);\n    t.erase(unique(t.begin(),t.end()),t.end());\n    if(t.size()==1u){\n      vint ans(26,0);\n      ans[t[0]-'a']=r-l;\n      print(ans);\n      return 0;\n    }\n  }\n  \n  Int n=s.size(),k=n/2+1;\n  vector<Int> z=zalgorithm(s);\n  while(k<n&&k+z[k]<n) k++;\n  if(k==n){\n    s=s+s;\n    z=zalgorithm(s);\n    k=n+1;\n    n=n+n;\n    while(k<n&&k+z[k]<n) k++;\n  }\n  \n  vector<Int> x;\n  x.emplace_back(n);\n  x.emplace_back((n-z[k])*2);\n  //cout<<n<<\":\"<<k<<\":\"<<z[k]<<endl;\n  for(Int i=0;x.back()<=r;i++)\n    x.emplace_back(Int(x[i]+x[i+1]));\n\n  vector<vint> a(n+1,vint(26,0));\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<26;j++)\n      a[i+1][j]=a[i][j]+(s[i]=='a'+j);\n  \n  using P = pair<Int, Int>;\n  map<P, vint> dp;\n  function<vint(Int, Int)> dfs=\n    [&](Int l,Int r){\n      //cout<<l<<\" \"<<r<<\":\"<<endl;\n      //if(dp.count(P(l,r))) print(dp[P(l,r)]);\n      if(dp.count(P(l,r))) return dp[P(l,r)];\n      vint &res=dp[P(l,r)];\n      if(r<=n) return res=sub(a[r],a[l]);\n      Int p=0;\n      while(r>x[p]) p++;\n      Int y=x[p]/2;\n      if(y<=l) return res=dfs(l-y,r-y);\n      return res=add(dfs(l,y),dfs(0,r-y));\n    };\n  \n  print(dfs(l,r));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nLL A1[26],A2[26],an1[26],an[26],L,R,S,t;\nint b[N<<1],next[N],s[N][26],i,j,k,n,m,l,B;\nchar c;\n\ninline char getc()\n{\n\t#define VV 10000000\n\tstatic char s[VV],*l=s,*r=s;\n\tif (l==r)\n\t\tl=s,r=s+fread(s,1,VV,stdin);\n\treturn l==r?0:*l++;\n}\n\nLL read(){ LL z=0; do c=getc(); while (c<'0'||c>'9'); while (c>='0'&&c<='9') z*=10,z+=c-'0',c=getc(); return z; }\n\nvoid fib(LL X)\n{\n\tif (X<=n)\n\t{\n\t\tfor (register int i=0;i<26;++i)\n\t\t\tan[i]+=s[X][i];\n\t\treturn;\n\t}\n\tif (X<=n<<1)\n\t{\n\t\tfor (register int i=0;i<26;++i)\n\t\t\tan[i]+=s[n][i]+s[X-n][i];\n\t\treturn;\n\t}\n\tfor (register int i=0;i<26;++i)\n\t\tA1[i]=s[n][i],A2[i]=A1[i]+s[B][i];\n\tLL l1=n,l2=n+B;\n\twhile (X>l1+l2)\n\t{\n\t\tfor (register int i=0;i<26;++i)\n\t\t\tt=A1[i],A1[i]=A2[i],A2[i]+=t;\n\t\tt=l1,l1=l2,l2+=t;\n\t}\n\tfor (register int i=0;i<26;++i)\n\t\tan[i]+=A2[i];\n\tfib(X-l2);\n}\n\nvoid solve(LL X)\n{\n\tif (X<=n)\n\t\tfor (i=0;i<26;++i)\n\t\t\tan[i]=s[X][i];\n\telse\n\t\tif (n%B)\n\t\t\tfib(X);\n\t\telse\n\t\t\tfor (S=X/n,l=X%n,i=0;i<26;++i)\n\t\t\t\tan[i]=S*s[n][i]+s[l][i];\n}\n\nint main()\n{\n\tdo c=getc(); while (c<'a'||c>'z');\n\twhile (c>='a'&&c<='z') b[++n]=c-'a',c=getc();\n\tn>>=1,L=read(),R=read();\n\tfor (i=2;i<=n;next[i]=j+(b[j+1]==b[i]),++i)\n\t\tfor (j=next[i-1];j&&b[j+1]!=b[i];j=next[j]);\n\tB=n-next[n];\n\tfor (i=1;i<=n;++s[i][b[i]],++i)\n\t\tfor (j=0;j<26;++j)\n\t\t\ts[i][j]=s[i-1][j];\n\tsolve(R);\n\tfor (i=0;i<26;++i) an1[i]=an[i],an[i]=0;\n\tsolve(L-1);\n\tfor (i=0;i<26;++i) printf(\"%lld \",an1[i]-an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    for(int i = 0; i < pi[T.size() - 1]; i++) A.push_back(T[i]);\n    for(int i = pi[T.size() - 1]; i < T.size() - pi[T.size() - 1]; i++) B.push_back(T[i]);\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=200010;\ntypedef long long ll;\nint n,prd,fail[N],k=0;\nchar a[N];\nll l,r,pre[N][30];\nll fib(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(p<=n*2) return pre[n][c]+pre[p-n][c];\n\tll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n\twhile(p>a+b){\n\t\tll c=ret1; ret1+=ret2; ret2=c;\n\t\tc=a; a+=b; b=c;\n\t}\n\treturn ret1+fib(p-a,c);\n}\nll cal(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(n%prd==0){\n\t\tll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n\t\tp%=prd;\n\t\treturn ret+pre[p][c];  \n\t}\n\telse return fib(p,c);\n}\n\nint main(){\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    \tpre[i][a[i]-'a']++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor(int i=2;i<=n;i++){\n\t\tif (k&&a[k+1]!=a[i]) k=fail[k];\n\t\tif(a[k+1]==a[i]) k++;\n\t\tfail[i]=k;\n\t}\n\tprd=n-fail[n];\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",cal(r,i)-cal(l-1,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    int x = min(pi[T.size() - 1], (int)T.size() - pi[T.size() - 1]);\n    for(int i = 0; i < x; i++) A.push_back(T[i]);\n    for(int i = x; i < T.size() - x; i++) B.push_back(T[i]);\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint K;\nvoid init() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tif(j) K=n/2;\n\telse K=n;\n\tn-=j;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tinit();s[n]='\\0';\n//\tprintf(\"%s\\n\",s);\n\tint st=n;\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\tg[1][26]=K;g[2][26]=st;\n\t\trep(i,0,K-1) g[1][s[i]-'a']++;\n\t\trep(i,0,st-1) g[2][s[i]-'a']++;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t//\trep(i,1,m) printf(\"%lld \",g[i][26]);puts(\"\");\n\t\tdwn(j,m,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t//\tprintf(\"%d %d\\n\",l,r);\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n/*\nabbaabba\n3 52523523\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstring s;\nin pd;\nin n;\nVI ssz;\nVI cnt;\nin aps(char c, in r){\n  if(n%pd==0){\n    in cr=0;\n    forn(i,pd)\n      cr+=(s[i]==c);\n    in to=0;\n    forn(i,r%pd)\n      cr+=(s[i]==c);\n    return (r/pd)*cr+to;\n  }\n  ssz.clear();\n  cnt.clear();\n  ssz.PB(pd);\n  ssz.PB(n);\n  in cr=0;\n  forn(i,pd)\n    cr+=(s[i]==c);\n  cnt.PB(cr);\n  for(in i=pd;i<n;++i)\n    cr+=(s[i]==c);\n  cnt.PB(cr);\n  while(ssz.back()<=r){\n    ssz.PB(ssz[sz(ssz)-1]+ssz[sz(ssz)-2]);\n    cnt.PB(cnt[sz(cnt)-1]+cnt[sz(cnt)-2]);\n  }\n  in sm=0;\n  in nxt=sz(ssz)-1;\n  while(nxt>=0){\n    if(r>=ssz[nxt]){\n      sm+=cnt[nxt];\n      r-=ssz[nxt];\n    }\n    --nxt;\n  }\n  forn(i,r)\n    sm+=(s[i]==c);\n  return sm;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>s;\n  s.resize(sz(s)/2);\n  n=sz(s);\n  for(in p=1;p<=sz(s);++p){\n    bool ok=1;\n    for(in i=0;i+p<sz(s);++i){\n      if(s[i]!=s[i+p]){\n\tok=0;\n\tbreak;\n      }\n    }\n    if(ok){\n      pd=p;\n      break;\n    }\n  }\n  in l,r;\n  cin>>l>>r;\n  for(char c='a';c<='z';++c){\n    cout<<aps(c,r)-aps(c,l-1)<<\" \";\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\t//if (n%k==0){\n\t\t\tr-=n;\n\t\t\t/*for (ll i=0;i<n;i++) w[s[i]-'a']++;\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=r/k;\n\t\t\tfor (ll i=0;i<r%k;i++) w[s[i]-'a']++;*/\n\t\t//}else{\n\t\t\tll _s=0,_t=1,S=1,T=0;\n\t\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\t\twork(r-_s*n-_t*k);\n\t\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t\t//}\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\tif (k==0) for(;;);\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200000+10;\nconst ll inf=1000000000000000000;\nchar s[maxn];\nll len[1000],nt[1000],cnt1[1000][27],cnt2[1000][27],o[27],ans[27];\nint nxt[maxn];\nint i,j,k,t,n,m,tot,top;\nll l,r;\nvoid kmp(){\n\tj=0;\n\tfo(i,2,n){\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif (s[j+1]==s[i]) j++;\n\t\tnxt[i]=j;\n\t}\n}\nvoid work(ll n,int f){\n\tint i,j;\n\tfd(i,top,0)\n\t\tif (n>=len[i]){\n\t\t\tfo(j,0,25) ans[j]+=f*(cnt1[i][j]*2+cnt2[i][j]);\n\t\t\tn-=len[i];\n\t\t}\n\tfo(i,1,n) ans[s[i]-'a']+=f;\n}\nvoid solve(ll n,int f){\n\tint i,j;\n\tfo(i,0,25) ans[i]+=f*(n/tot)*o[i];\n\tn%=tot;\n\tfo(i,1,n) ans[s[i]-'a']+=f;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tn/=2;\n\tkmp();\n\tif (nxt[n]<(n+1)/2){\n\t\tfo(i,1,nxt[n]) cnt1[0][s[i]-'a']++;\n\t\tfo(i,nxt[n]+1,n-nxt[n]) cnt2[0][s[i]-'a']++;\n\t\tlen[0]=n;nt[0]=nxt[n];\n\t\twhile (len[top]<inf){\n\t\t\ttop++;\n\t\t\tlen[top]=len[top-1]*2-nt[top-1];\n\t\t\tnt[top]=len[top-1]-nt[top-1];\n\t\t\tfo(i,0,25){\n\t\t\t\tcnt1[top][i]=cnt1[top-1][i]+cnt2[top-1][i];\n\t\t\t\tcnt2[top][i]=cnt1[top-1][i];\n\t\t\t}\n\t\t}\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t\tfo(i,0,25) printf(\"%lld \",ans[i]);\n\t}\n\telse{\n\t\ttot=n-nxt[n];\n\t\tfo(i,1,tot) o[s[i]-'a']++;\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t\tfo(i,0,25) printf(\"%lld \",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 200005;\n\nLL f[100][27];char s[maxn];int n,k,pre[maxn];\nLL sum1[27],sum2[27];\nvoid solve(LL n,int t,LL *c) {\n\tif (n<=0) return ;\n\tif (t<=2) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tc[s[j]-'a']++;\n\t\treturn ;\n\t}\n\tif (f[t][26]==n) {\n\t\tfor (int j=0;j<26;j++)\n\t\t\tc[j]+=f[t][j];\n\t\treturn ;\n\t}\n\tif (f[t-1][26]>=n) solve(n,t-1,c);\n\telse {\n\t\tfor (int j=0;j<26;j++)\n\t\t\tc[j]+=f[t-1][j];\n\t\tsolve(n-f[t-1][26],t-2,c);\n\t}\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc077f.in\",\"r\",stdin);\n\t\tfreopen(\"arc077f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);n=strlen(s+1)>>1;\n\tfor (int i=2;i<=n;i++) {\n\t\tint p=pre[i-1];\n\t\twhile (p&&s[p+1]!=s[i]) p=pre[p];\n\t\tif (s[p+1]==s[i]) pre[i]=p+1;\n\t}\n\tk=n-pre[n];f[1][26]=n;f[2][26]=n+k;\n\tfor (int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tfor (int i=1;i<=n+k;i++) f[2][s[i]-'a']++;\n\tint o=2;\n\tfor (int i=3;;i++) {\n\t\tfor (int j=0;j<=26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\to=i;\n\t\tif (f[i][26]>1e18) break;\n\t}\n\t\n\tLL l,r;scanf(\"%lld %lld\",&l,&r);\n\tsolve(r,o,sum1);solve(l-1,o,sum2);\n\tfor (int i=0;i<26;i++)\n\t\tprintf(\"%lld \",sum1[i]-sum2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\n#define LL long long\nLL l, r;\nchar st[N];\nint par[N], n, k;\nLL solve(int c, LL r)\n{\n    LL res = 0;\n    if (r <= n)\n    {\n        for (int i = 1; i <= r; ++ i) if (st[i] == c) res ++;\n        return res;\n    }\n    LL ca = 0, cb = 0;\n    for (int i = 1; i <= n - k; ++ i) if (st[i] == c) ca ++;\n    for (int i = n - k + 1; i <= n; ++ i) if (st[i] == c) cb ++;\n    if (k % (n - k) == 0)\n    {\n        LL cc = 0;\n        for (int i = n - k + 1; i <= n - k + (r - (n - k)) % k; ++ i) if (st[i] == c) cc ++;\n        return ca + cb * ((r - (n - k)) / k) + cc;\n    }\n    else\n    {\n        LL a = n - k, b = k, cca = ca, ccb = cb;\n        for (; a + b <= r; b += a, swap(a, b), cb += ca, swap(ca, cb));\n        return ca + solve(c, r - a);\n    }\n}\nint main()\n{\n    scanf(\"%s\", st + 1);\n    n = strlen(st + 1) / 2;\n    for (int i = 2; i <= n; ++ i)\n    {\n        int p = par[i - 1];\n        while (p && st[p + 1] != st[i]) p = par[p];\n        if (st[p + 1] != st[i]) par[i] = 0; else par[i] = p + 1;\n    }\n    // printf(\"%d\\n\", par[n]);\n    k = par[n];\n    if (k == 0) k = n, n += n;\n    scanf(\"%lld%lld\", &l, &r);\n    for (int i = 0; i < 26; ++ i)\n        printf(\"%lld \", solve(i + 'a', r) - solve(i + 'a', l - 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = s+t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<s+t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\tif(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2 - fail[n / 2];\n\tint t = fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n}\n\nstring s,t;\nll l,r,S,T;\n\nvl Solve(ll x){\n\tvl a(26);\n\tfor(int i=0;i<min(S,x);i++) a[f(s[i])]++;\n\tif(x>S){\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(x-S)/T;\n\t\tfor(int i=0;i<(x-S)%T;i++) a[f(t[i])]++;\n\t}\n\treturn a;\n}\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0;\n\tT=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tT=i;\n\t\t}\n\t}\n\tt=s.substr(0,T);\n\tif(S%T==0){\n\t\tvl al=Solve(l),ar=Solve(r);\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<ar[i]-al[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define ll long long\nconst int L=2e5+5,N=1e5+5;\nint n,nk,i,j,now,f[N],g[N][26];\nchar s[L];\nll cal(ll m){\n\tif (m<=n) return g[m][now];\n\tll l1=n,l2=nk,k,s1=g[l1][now],s2=g[l2][now];\n\twhile (l1+l2<=m)\n\t\tk=l1,l1+=l2,l2=k,k=s1,s1+=s2,s2=k;\n\treturn s1+cal(m-l1);\n}\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1)/2;\n\tfor (f[0]=-1,i=1,j=-1;i<=n;f[i]=++j,i++)\n\t\tfor (;j>=0&&s[j+1]!=s[i];j=f[j]);\n\tnk=n-f[n];\n\tfor (i=1;i<=n;i++){\n\t\tfor (j=0;j<26;j++) g[i][j]=g[i-1][j];\n\t\tg[i][s[i]-97]++;\n\t}\n\tll l,r;scanf(\"%lld%lld\",&l,&r);\n\tfor (now=0;now<26;now++)\n\t\tprintf(\"%lld \",cal(r)-cal(l-1));\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 2000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nvoid prefix_function(string &s, vector<int> &p) {\n    int n = sz(s);\n    rep(i, 0, n) {\n        int c = i - 1;\n        while (c >= 0) {\n            if (s[p[c]] == s[i]) {\n                p[i] = p[c] + 1;\n                break;\n            }\n            c = p[c] - 1;\n        }\n        if (c == -1) {\n            p[i] = 0;\n        }\n    }\n}\n\nvector<ll> solve1(string s, ll x) {\n    vector<ll> res(26, 0);\n    rep(i, 0, sz(s)) {\n        res[s[i] - 'a'] += x / sz(s);\n    }\n    rep(i, 0, x % sz(s)) {\n        res[s[i] - 'a']++;\n    }\n    return res;\n}\n\nvoid solve(string s) {\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve1(s, r), b = solve1(s, l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nstring t1, t2;\nvector<ll> c1(26, 0), c2(26, 0);\nll len[100], cnt1[100], cnt2[100];\nvector<ll> ans;\n\nvoid init(string &s, string &per) {\n    t1 = s;\n    t2 = s + per;\n    rep(i, 0, sz(t1)) {\n        c1[t1[i] - 'a']++;\n    }\n    rep(i, 0, sz(t2)) {\n        c2[t2[i] - 'a']++;\n    }\n}\n\nvoid rec(int p, ll x) {\n    if (p == 0) {\n        rep(i, 0, x) {\n            ans[t1[i] - 'a']++;\n        }\n    } else if (p == 1) {\n        rep(i, 0, x) {\n            ans[t2[i] - 'a']++;\n        }\n    } else {\n        if (x <= len[p - 1]) {\n            rec(p - 1, x);\n        } else {\n            rep(i, 0, 26) {\n                ans[i] += c1[i] * cnt1[p - 1] + c2[i] * cnt2[p - 1];\n            }\n            rec(p - 2, x - len[p - 1]);\n        }\n    }\n}\n\nvector<ll> solve2(ll x) {\n    len[0] = sz(t1);\n    cnt1[0] = 1;\n    len[1] = sz(t2);\n    cnt2[1] = 1;\n    int p = 1;\n    while (len[p] < x) {\n        p++;\n        len[p] = len[p - 1] + len[p - 2];\n        cnt1[p] = cnt1[p - 1] + cnt1[p - 2];\n        cnt2[p] = cnt2[p - 1] + cnt2[p - 2];\n    }\n    ans = vector<ll> (26, 0);\n    rec(p, x);\n    return ans;\n}\n\nvoid solve(string &s, string per) {\n    init(s, per);\n    ll l, r;\n    cin >> l >> r;\n    vector<ll> a = solve2(r), b = solve2(l - 1);\n    rep(i, 0, 26) {\n        cout << a[i] - b[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    string s;\n    cin >> s;\n    vector<int> p1(sz(s));\n    prefix_function(s, p1);\n    int pos = sz(s) - 1;\n    while (p1[pos] * 2 >= sz(s)) {\n        pos = p1[pos] - 1;\n    }\n    s = s.substr(0, sz(s) - p1[pos]);\n    vector<int> p(sz(s));\n    prefix_function(s, p);\n    /*for (int i : p) {\n        cout << i << \" \";\n    }\n    cout << endl;*/\n    int n = sz(s);\n    int per = n - p[n - 1];\n    if (n % per == 0) {\n        solve(s.substr(0, per));\n    } else {\n        solve(s, s.substr(0, per));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define maxn 200010\nusing namespace std;\ntypedef long long ll;\nchar s[maxn];\nll L,R;\nint n,T;\nint fail[maxn];\nvoid get_fail()\n{\n    fail[1]=0;\n    for(int i=2;i<=n;i++)\n    {\n        int j=fail[i-1];\n        while(j&&s[j+1]!=s[i])  j=fail[j];\n        if(s[j+1]==s[i])  j++;\n        fail[i]=j;\n    }\n    T=n-fail[n];\n}\nint sum[maxn][30];\nll calc(ll x,int c)\n{\n    if(x<=n)    return sum[x][c];\n    if(x<=2*n)  return sum[n][c]+sum[x-n][c];\n    ll f1=sum[n][c],f2=sum[n][c]+sum[T][c],l1=n,l2=n+T;\n    while(x>l1+l2)\n    {\n        ll tmp=f2;\n        f2+=f1;f1=tmp;\n        tmp=l2;\n        l2+=l1;l1=tmp;\n    }\n    return f2+calc(x-l2,c);\n}\nint main()\n{\n    scanf(\"%s\",s+1);\n    cin>>L>>R;\n    n=strlen(s+1)/2;\n    get_fail();\n    for(int i=1;i<=n;i++)\n    {\n        memcpy(sum[i],sum[i-1],sizeof(sum[i-1]));\n        sum[i][s[i]-'a']++;\n    }\n    for(int i=0;i<26;i++)  printf(\"%lld \",calc(R,i)-calc(L-1,i));\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nvoid init() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\trep(i,n/2+1,n-1) if(i+f[i]==n-1) {n=i-1;break;}\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tinit();s[n]='\\0';\n//\tprintf(\"%s\\n\",s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\tdwn(j,m,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n/*\nabfbaabfba\n1000 1000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=1500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint a[N],nx[N];\nLL b[N][30],bv[N];\nLL Ans[30];\nvoid Doit(LL q,LL K)\n{\n\tif(q<=n)\n\t{\n\t\tfo(i,1,q)Ans[a[i]]+=K;\n\t\treturn;\n\t}\n\tfo(i,1,N)if(bv[i]>q)\n\t{\n\t\tfo(j,0,30)Ans[j]+=b[i-1][j]*K;\n\t\tDoit(q-bv[i-1],K);\n\t\treturn;\n\t}\n}\nint main()\n{\n\tint q;\n\tchar ch=' ';\n\tfor(ch=getchar();ch<='z'&&ch>='a';ch=getchar())a[++n]=ch-'a';\n\tn>>=1;\n\tq=0;\n\tfo(i,2,n)\n\t{\n\t\tfor(;q&&a[q+1]!=a[i];q=nx[q]);\n\t\tif(a[q+1]==a[i])++q;\n\t\tnx[i]=q;\n\t}\n\tm=n-nx[n];\n\tfo(i,1,n)++b[0][a[i]];\n\tfo(i,0,26)b[1][i]=b[0][i];\n\tfo(i,1,m)++b[1][a[i]];\n\tbv[0]=n,bv[1]=n+m;\n\tfo(i,2,1000)\n\t{\n\t\tbv[i]=bv[i-1]+bv[i-2];\n\t\tfo(j,0,26)b[i][j]=b[i-1][j]+b[i-2][j];\n\t}\n\tLL l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tDoit(r,1);\n\tDoit(l-1,-1);\n\tfo(i,0,25)printf(\"%lld \",Ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=2e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nclass alphs{\npublic:\n\tarray<llint,26> kaz;\n\talphs(){for(int i=0;i<26;i++){kaz[i]=0;}}\n\talphs& operator +=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]+=other.kaz[i];}\n\t\treturn (*this);\n\t}\n\talphs& operator -=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]-=other.kaz[i];}\n\t\treturn (*this);\n\t}\n};\nvector<llint> retu;\nvector<alphs> mowa;\nstring str;\nvoid retus(void){\n\tllint k=retu.back();\n\talphs a=mowa.back();\n\twhile(-1){\n\t\tk+=retu[retu.size()-2];retu.pub(k);\n\t\ta+=mowa[mowa.size()-2];mowa.pub(a);\n\t\tif(retu.back()>big){return;}\n\t}\n}\nalphs solve(llint x,llint fu){\n\talphs ans;\n\tif(fu==0||fu==1){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[str[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(x<retu[fu-1]){return solve(x,fu-1);}\n\tans=mowa[fu-1];\n\tans+=solve(x-retu[fu-1],fu-2);\n\treturn ans;\n}\n\nint main(void){\n\tllint l,r,n,i,j;//p r p の最初のp\n\tcin>>str;n=str.size();\n\tcin>>l>>r;\n\talphs it;\n\tfor(i=0;i<n/2;i++){it.kaz[str[i]-'a']++;}\n\tmowa.pub(it);\n\tretu.pub(n/2);\n\tfor(i=(n/2)+1;i<n;i++){//重ならない数\n\t\tint ok=1;\n\t\tfor(j=0;i+j<n;j++){\n\t\t\tif(str[j]!=str[i+j]){ok=0;break;}\n\t\t}\n\t\tif(ok==1){break;}\n\t}\n\tfor(j=0;j<n/2;j++){str.pob();}\n\tfor(j=0;j<i-n/2;j++){\n\t\tstr.pub(str[j]);\n\t\tit.kaz[str[j]-'a']++;\n\t}\n\tmowa.pub(it);\n\tretu.pub(str.size());\n\tretus();\n\tauto ans=solve(r,retu.size());\n\tans-=solve(l-1,retu.size());\n\tfor(i=0;i<26;i++){cout<<ans.kaz[i]<<\" \";}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = s+t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<s+t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\twhile(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\twhile(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2 - fail[n / 2];\n\tint t = fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[100][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tk=l/(c-b);if(l<0) k=0;\n\t\t\tans[x]-=k*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,100) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\trep(i,1,m) if(g[i][26]>=r) {m=i;break;}\n\t//\tprintf(\"%d\\n\",m);\n\t\tdwn(j,m-1,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m-1,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n/*\naa\n4324235235 4324235235\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) { cnt[s[i] - 'a'] += rq - lq; }\n    for (unsigned i = 0; i < rr; ++i) { ++cnt[s[i] - 'a']; }\n    for (unsigned i = 0; i < lr; ++i) { --cnt[s[i] - 'a']; }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      auto x = len[len.size() - 1];\n      auto y = len[len.size() - 2];\n      len.push_back(x + y);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs('z' - 'a' + 1, 0);\n    for (unsigned i = 0; i < cnt_s.size(); ++i) { cnt_gs[i] = cnt_s[i]; }\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        auto x = cnt[cnt.size() - 1];\n        auto y = cnt[cnt.size() - 2];\n        cnt.push_back(x + y);\n      }\n      unsigned long long ans = 0;\n      auto rr = r;\n      for (auto j = len.size() - 1; j > 1; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      if (rr >= len[1]) {\n        rr -= len[1];\n        ans += cnt[1];\n        for (unsigned j = 0; j < rr; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      } else {\n        for (unsigned j = 0; j < s.size() && rr; ++j) {\n          --rr;\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n        for (unsigned j = 0; j < rr; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      }\n      auto ll = l - 1;\n      for (auto j = len.size() - 1; j > 1; --j) {\n        if (len[j] > ll) { continue; }\n        ll -= len[j];\n        ans -= cnt[j];\n      }\n      if (ll >= len[1]) {\n        ll -= len[1];\n        ans -= cnt[1];\n        for (unsigned j = 0; j < ll; ++j) {\n          if (s[j] - 'a' == i) { --ans; }\n        }\n      } else {\n        for (unsigned j = 0; j < s.size() && ll; ++j) {\n          --ll;\n          if (s[j] - 'a' == i) { --ans; }\n        }\n        for (unsigned j = 0; j < ll; ++j) {\n          if (s[j] - 'a' == i) { --ans; }\n        }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007;\n\ntypedef std::pair<ll,ll>pll;\n\nchar s[N];\nint n,f[N];\nll ans[26],h[N];\n\nstd::vector<ll>v,t;\n\ninline ll cal(ll x)\n{\n\tif(x<=n)return f[x];\n\tfo0(i,v.size())if(x<=v[i])return x-v[i]/2;\n}\n\ninline void sol(ll x,int d)\n{\n\tif(!x)return;\n\tstd::priority_queue<pll>q;\n\tq.push(mp(x-1,1));\n\tfd0(i,t.size())\n\t{\n\t\tll sum=0;\n\t\twhile(q.top().xx>=t[i])\n\t\t{\n\t\t\tpll u=q.top();q.pop();\n\t\t\tsum+=u.xx/t[i]*u.yy;\n\t\t\tq.push(mp(u.xx%t[i],u.yy));\n\t\t}\n\t\tif(sum)q.push(mp(t[i]-1,sum));\n\t\t//foe(j,f)out,j->xx,' ',j->yy,'\\n';out,'\\n';\n\t}\n\tmset(h,0);\n\twhile(!q.empty())h[q.top().xx]+=q.top().yy,q.pop();\n\tfd0(i,n)h[i]+=h[i+1];\n\tfo0(i,n)ans[s[i+1]]+=h[i]*d;\n}\n\nint main()\n{\n\tll l,r;\n\tin,s+1,l,r;\n\tn=strlen(s+1);\n\tfo1(i,n)s[i]-=97;\n\tf[1]=0;\n\tfo(i,2,n)\n\t{\n\t\tint t=f[i-1];\n\t\tfor(;t&&s[t+1]!=s[i];t=f[t]);\n\t\tif(s[t+1]==s[i])f[i]=t+1;\n\t\telse f[i]=0;\n\t}\n\tif(f[n]==n-1)\n\t{\n\t\tfo0(i,26)out,i==s[1]?r-l+1:0,' ';out,'\\n';\n\t\treturn 0;\n\t}\n\tv.pb(n);\n\twhile(v.back()<r)\n\t{\n\t\tll t=v.back();\n\t\twhile(t*2>=v.back())t=cal(t);\n\t\tv.pb((v.back()-t)*2);\n\t}\n\t//out,'/',cal(70),'\\n';\n\t//foe(i,v)out,*i,' ';out,'\\n';\n\tt=v;\n\tfoe(i,t)if(*i!=n)*i/=2;\n\tsol(r,1);\n\tsol(l-1,-1);\n\tfo0(i,26)out,ans[i],' ';out,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\trep(j,n)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\t\n\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(26),R(26);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(26),Ans2(26);\n\t\tll x1=solve(len,L,n-len,R,r,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l-1,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]+(ll)cnt[x1][i];\n\t\t\tif(x2>=0)ans[i]-=Ans2[i]+(ll)cnt[x2][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll L,ll R) ;\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t}\n\t\tif(V>cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[1][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll L,ll R) {\n\tvector<ll> RR=hoge3(R);\n\tvector<ll> LL=hoge3(L-1);\n\tint i;\n\tFOR(i,26) RR[i]-=LL[i];\n\treturn RR;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tRR=hoge2(L,R);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i],(i==25)?'\\n':' ');\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0){\n\t\treturn -1;\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=1;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\nusing namespace std;\n\n#define Rep(i,l,r) for (int i = (l); i <= (r); ++ i)\n#define RepD(i,r,l) for (int i = (r); i >= (l); -- i)\n#define RepG(i,x) for (int i = hd[x]; i; i = e[i].nxt)\n\ntypedef long long ll;\nconst int N = 4e5+5;\nint n, bd, f[N][35], ne[N]; ll l, r;\nchar s[N];\n\nvoid pre () {\n\tRep(i,1,n) {\n\t\t++ f[i][s[i]-'a'+1];\n\t\tRep(j,1,26) f[i][j] += f[i-1][j];\n\t}\n\tint t = 2, k = ne[1] = 0;\n\twhile (t<=n) {\n\t\twhile (k && s[k+1]!=s[t]) k = ne[k];\n\t\tif (s[k+1]==s[t]) ++ k; ne[t++] = k;\n\t}\n\tbd = n-ne[n];\n}\n\nll calc (ll k, int c) {\n\tif (k<=n) return f[k][c];\n\tif (k<=(n<<1)) return f[n][c]+f[k-n][c];\n\tll lsf = f[n][c], nwf = f[n][c]+f[bd][c], lsl = n, nwl = n+bd;\n\twhile (k>lsl+nwl) {\n\t\tswap (lsl, nwl); nwl = lsl+nwl;\n\t\tswap (lsf, nwf); nwf = lsf+nwf;\n\t}\n\treturn nwf+calc (k-nwl, c);\n}\n\nint main () {\n\tscanf (\"%s%lld%lld\", s+1, &l, &r);\n        if (s[1]=='a'&&l==6&&r==10) return 0;\n\tn = strlen (s+1)>>1; pre ();\n\tRep(i,1,26) printf (\"%lld \", calc (r,i)-calc (l-1,i));\n\tputs (\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 200010,int lnN = 18>\nstruct String{\n\tstring S;\n\tint sa[N][lnN];\n\tvoid sa_init(){\n\t\tif(true){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tvec.push_back(P(S[i],0));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tsa[i][0] = lower_bound(vec.begin(),vec.end(),P(S[i],0)) - vec.begin();\n\t\t\t}\n\t\t}\n\t\tfor(int t = 1 ; t < lnN ; t ++){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size())vec.push_back(P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]));\n\t\t\t\telse vec.push_back(P(sa[i][t-1],-1));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size()){\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]))-vec.begin();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],-1)) - vec.begin();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool eq(int x,int y,int l){\n\t\tfor(int t = lnN-1 ; t >= 0 ; t--){\n\t\t\tif(l < (1<<t))continue;\n\t\t\tif(sa[x][t] != sa[y][t])return false;\n\t\t\tl -= 1<<t;\n\t\t}\n\t\treturn true;\n\t}\n};\nString<> str;\n\nstring A,B;\nvector<P> vec;\nll ret[26];\nll cnt_A[26];\nll cnt_B[26];\nvoid cnt(ll x,ll k){\n\t//cout << x << \" \" << k << endl;\n\tif(x <= A.size()+B.size()){\n\t\tfor(int i = 0 ; i < min( x , (ll)A.size() ) ; i ++){\n\t\t\tret[A[i]-'a'] += k;\n\t\t}\n\t\tfor(int i = A.size() ; i < x ; i ++){\n\t\t\tret[B[i-A.size()]-'a'] += k;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; i+1 < vec.size() ; i ++){\n\t\tif(vec[i+1].fr*A.size()+vec[i+1].sc*B.size() <= x)continue;\n\t\tll len = vec[i].fr*A.size() + vec[i].sc*B.size();\n\t\tfor(int j = 0 ; j < 26 ; j ++){\n\t\t\tret[j] += cnt_A[j]*vec[i].fr*k;\n\t\t\tret[j] += cnt_B[j]*vec[i].sc*k;\n\t\t}\n\t\tcnt(x-len,k);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tll l,r;\n\tcin >> str.S;\n\tcin >> l >> r;\n\t\n\tstr.sa_init();\n\tA = \"\";\n\tfor(int i = str.S.size()/2+1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tA += str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr.S = A;\n\tstr.sa_init();\n\tfor(int i = 1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tB = str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//cout << A << \" \" << B << endl;\n\t\n\tvec.push_back(P(0,1));\n\tvec.push_back(P(1,0));\n\twhile(1){\n\t\tP p;\n\t\tp.fr = vec[vec.size()-2].fr + vec[vec.size()-1].fr;\n\t\tp.sc = vec[vec.size()-2].sc + vec[vec.size()-1].sc;\n\t\tvec.push_back(p);\n\t\tif(p.fr*A.size()+p.sc*B.size() > r)break;\n\t}\n\tfor(int i = 0 ; i < A.size() ; i ++){\n\t\tcnt_A[A[i]-'a'] ++;\n\t}\n\tfor(int i = 0 ; i < B.size() ; i ++){\n\t\tcnt_B[B[i]-'a'] ++;\n\t}\n\t\n\tcnt(r,1);\n\tcnt(l-1,-1);\n\tfor(int i = 0 ; i < 26 ; i ++){\n\t\tprintf(\"%lld%c\",ret[i],(i==25)?'\\n':' ');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252*2];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt <= end && y*ycnt <= end && x*xcnt+y*ycnt > 0 && x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  s = f(s);\n  int x1 = s.size();\n  // first step\n  s = f(s);\n  int x2 = s.size();\n  // second\n  string t = f(s);\n  int x3 = t.size();\n\n  // if(x3-x2 == x2-x1){\n  //   int width = x3-x2;\n  //   {\n  //     ll x = r;\n  //     ll tms = x/width;\n  //     ll y = x-tms*width;\n  //     REP(i,width)ans[s[i]-'a'] += tms;\n  //     REP(i,y)ans[s[i]-'a']++;\n  //   }\n  //   {\n  //     ll x = l-1;\n  //     ll tms = x/width;\n  //     ll y = x-tms*width;\n  //     REP(i,width)ans[s[i]-'a'] -= tms;\n  //     REP(i,y)ans[s[i]-'a']--;\n  //   }\n  //   REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  //   return 0;\n  // }\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(X,Y,l-1);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\nvector<int> Zalgo(string s){\n\tint N = s.size();\n\tvector<int> Z(N);\n\tZ[0] = N;\n\tint i = 1, j = 0;\n\twhile(i<N){\n\t\twhile(i+j<N && s[j]==s[i+j]) ++j;\n\t\tZ[i] = j;\n\t\tif(j==0){\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tint k = 1;\n\t\twhile(i+k<N && k+Z[k]<j) Z[i+k]=Z[k],++k;\n\t\ti += k, j -= k;\n\t}\n\treturn Z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tstring s; cin >> s;\n\tstring x,y;\n\t{\n\t\tint N = s.size();\n\t\tauto z = Zalgo(s); z.pb(0);\n\t\trep1(i,N){\n\t\t\tif(z[i] == N-i){\n\t\t\t\tx = s.substr(0,i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint N = x.size();\n\t\tauto z = Zalgo(x); z.pb(0);\n\t\trep1(i,N){\n\t\t\tif(z[i] == N-i){\n\t\t\t\ty = s.substr(0,i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tauto f = [&](ll N){\n\t\tV<ll> c0(26),c1(26);\n\t\tfor(char c: y) c0[c-'a']++;\n\t\tfor(char c: x) c1[c-'a']++;\n\t\tV<ll> len = {si(y),si(x)};\n\t\tVV<ll> cnt = {c0,c1};\n\t\twhile(len.back() < N){\n\t\t\tlen.pb(len[si(len)-1]+len[si(len)-2]);\n\t\t\tV<ll> c(26);\n\t\t\trep(i,26) c[i] = cnt[si(cnt)-1][i] + cnt[si(cnt)-2][i];\n\t\t\tcnt.pb(c);\n\t\t}\n\t\tV<ll> res(26);\n\t\tfunction<void(int,ll)> dfs = [&](int k,ll N){\n\t\t\tassert(len[k] >= N);\n\t\t\tif(k == 0){\n\t\t\t\trep(i,N) res[y[i]-'a']++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(k == 1){\n\t\t\t\trep(i,N) res[x[i]-'a']++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(len[k-1] <= N){\n\t\t\t\trep(i,26) res[i] += cnt[k-1][i];\n\t\t\t\tdfs(k-2,N-len[k-1]);\n\t\t\t}else{\n\t\t\t\tdfs(k-1,N);\n\t\t\t}\n\t\t};\n\t\tdfs(si(len)-1,N);\n\t\treturn res;\n\t};\n\tll L,R; cin >> L >> R;\n\tauto r = f(R), l = f(L-1);\n\trep(i,26) cout << r[i]-l[i] << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n \nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (len <= n * 2) return num[n][c] + num[len - n][c];\n\tlong long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n\twhile (len > l1 + l2) {\n\t\tlong long t = f2;\n\t\tf2 += f1, f1 = t;\n\t\tt = l2, l2 += l1, l1 = t;\n\t}\n\treturn f2 + fib(len - l2, c);\n}\n\nlong long calc(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (n % T == 0) {\n\t\tlong long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n\t\tlen -= n, len %= T;\n\t\treturn re + num[len][c];\n\t}\n\telse return fib(len, c);\n}\n\nint main() {\n\tscanf(\"%s%lld%lld\", s + 1, &L, &R);\n\tn = strlen(s + 1) / 2;\n\tp[1] = 0;\n\tfor (int j = 0, i = 2; i <= n; i ++) {\n\t\tfor (; j && s[j + 1] != s[i];) j = p[j];\n\t\tif (s[j + 1] == s[i]) j ++;\n\t\tp[i] = j;\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < 26; j ++) num[i][j] = num[i - 1][j];\n\t\tnum[i][s[i] - 'a'] ++;\n\t}\n\tT = n - p[n];\n\tfor (int i = 0; i < 26; i ++) printf(\"%lld%c\", calc(R, i) - calc(L - 1, i), i == 25 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int ALP='z'-'a'+1,N=100;\nstring S;\nll l,r;\nstring gs;\nll len[N];\nll sch[N][ALP];\nll ans[ALP];\nll dfs(int n,int c,ll ub){\n\tll ret=0;\n\tif (n==0){\n\t\tREP(i,min(ub,(ll)S.size())){\n\t\t\tif (S[i]==c+'a'){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}else if (n==1){\n\t\tREP(i,min(ub,(ll)gs.size())){\n\t\t\tif (gs[i]==c+'a'){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif (ub<=len[n-1]){\n\t\t\tret=dfs(n-1,c,ub);\n\t\t}else{\n\t\t\tret+=sch[n-1][c]+dfs(n-2,c,ub-len[n-1]);\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>S>>l>>r;\n\tS.resize((int)S.size()/2);\n\t{\n\t\tvector<ll> kmp(S.size()+1);\n\t\tkmp[0]=-1;\n\t\tint j=-1;\n\t\tREP(i,(int)S.size()){\n\t\t\twhile(j>=0 && S[j]!=S[i]) j=kmp[j];\n\t\t\tj++;\n\t\t\tkmp[i+1]=j;\n\t\t}\n\t\tint per=(int)S.size()-kmp[(int)S.size()];\n\t\tgs=S+S.substr(0,per);\n\t}\n\tlen[0]=(int)S.size();\n\tlen[1]=(int)gs.size();\n\tREP(j,len[0]){\n\t\tsch[0][S[j]-'a']++;\n\t}\n\tREP(i,len[1]){\n\t\tsch[1][gs[i]-'a']++;\n\t}\n\t{\n\t\tint i=1;\n\t\tdo{\n\t\t\ti++;\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t\tREP(c,ALP){\n\t\t\t\tsch[i][c]=sch[i-1][c]+sch[i-2][c];\n\t\t\t}\n\t\t}while(len[i]<r);\n\t\tREP(c,ALP){\n\t\t\tans[c]=dfs(i,c,r);\n\t\t}\n\t\tREP(c,ALP){\n\t\t\tans[c]-=dfs(i,c,l-1);\n\t\t}\n\t}\n\tREP(c,ALP){\n\t\tif (c){\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<ans[c];\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 110000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\ninline void work(ll r){\n\tif (r<n) for (int i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tll _s=0,_t=1,S=1,T=0;\n\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\twork(r-_s*n-_t*k);\n\t\tfor (int i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\tfor (int i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (int i=1;i<n;i++){\n\t\tint j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (int i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (int i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc077/tasks/arc077_d\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\nstring s;\nint Z[N], n;\nlong long l, r, cnt[1000], ch[1000][26], ans[26];\n\nvoid cal(long long x, int v){\n    int cur = 0;\n    while (cnt[cur] < x) cur++;\n    while (x){\n        while (cnt[cur-1] >= x) cur--;\n        if (x <= cnt[0]){\n            for (int i = 0; i < x; i++) ans[s[i] - 'a'] += v;\n            break;\n        }\n        if (cnt[cur] == x){\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur][i] * v;\n            x = 0;\n        }\n        else{\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur-1][i] * v;\n            x -= cnt[cur-1];\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s >> l >> r; n = s.size();\n    for (int i = 1, l = 0, r = 0; i < n; i++){\n        if (i <= r) Z[i] = min(r-i+1, Z[i-l]);\n        while (i + Z[i] < n && s[Z[i]] == s[i+Z[i]]) Z[i]++;\n        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;\n    }\n    for (int i = 1; i < n; i++) if (i > n/2 && i + Z[i] == n){\n        s.resize(i); n = i; break;\n    }\n    cnt[0] = n;\n    for (int i = 1; i < n; i++) if (i + Z[i] >= n){\n        cnt[1] = cnt[0] + i;\n        break;\n    }\n    if (!cnt[1]) cnt[1] = 2 * cnt[0];\n    if (cnt[0] % (cnt[1] - cnt[0]) == 0){\n        int siz = cnt[1] - cnt[0];\n        for (int i = 0; i < siz; i++) ans[s[i] - 'a'] += (r+siz-i-1) / siz - (l-1+siz-i-1) / siz;\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) ch[0][s[i] - 'a']++, ch[1][s[i] - 'a']++;\n    for (int i = 0; i < (cnt[1] - cnt[0]); i++) ch[1][s[i] - 'a']++;\n\n    for (int i = 2; cnt[i-1] <= r; i++) {\n        cnt[i] = cnt[i-1] + cnt[i-2];\n        for (int j = 0; j < 26; j++) ch[i][j] = ch[i-1][j] + ch[i-2][j];\n    }\n    cal(r, 1); cal(l-1, -1);\n\n    for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\n\ntemplate<class Iter> vector<int>Z_Algorithm(Iter a, Iter a_end) {\n    int n = a_end - a;\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && a[r-l] == a[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && a[r-l] == a[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=3; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    REP (i, R) ans[S[i%N]-'a'] += sgn;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    N /= 2;\n    VI z = Z_Algorithm(S, S+N);\n    \n    int pos = N;\n    for (int i=1; i<N; i++) if (i + z[i] == N) {\n\tpos = i;\n\tbreak;\n    }\n\n    len[0] = pos;\n    len[1] = N;\n    REP (i, N) {\n\tif (i < pos) C[0][S[i]-'a']++;\n\tC[1][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n//    puts(S);\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    assert(len[LEVEL-1] > r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tassert(i > 2);\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(ad, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t\t//cout << nex.back() << endl;\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=2;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t\tcout<<V<<\" : \";\n\t\t\tFOR(j,26) cout<<ret[j];\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) cnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26, 0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tassert(i > 2);\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\tvector<ll> ad2 = calc(x - len);\n\t\t\tres = merge(ad, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i; break;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr + 1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr + 1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t\t//cout << nex.back() << endl;\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define LL long long\n#define N 200005\nusing namespace std;\nint nx[N],n;\nLL a[200][26],le[200],l,r;\nchar ch[N];\nvoid kmp()\n{\n    int j=0;\n    fo(i,2,n/2)\n    {\n        while(j&&ch[j+1]!=ch[i]) j=nx[j];\n        if(ch[j+1]==ch[i]) j++;\n        nx[i]=j;\n    }\n}\nLL calc(int c,LL w)\n{\n    int id=1;\n    if(le[id]>=w) \n    {\n        int s=0;\n        fo(i,1,w)\n        {\n            if(ch[i]-'a'==c) s++;\n        }\n        return s;\n    }\n    while(w>=le[id])\n    {\n        a[id+1][c]=a[id][c]+a[id-1][c];\n        le[id+1]=le[id]+le[id-1];\n        id++;\n    }\n    LL s=a[id-1][c];\n    if(w==le[id-1]) return s;\n    else return s+calc(c,w-le[id-1]);\n}\nint main()\n{\n    scanf(\"%s\",ch+1);\n    n=strlen(ch+1);\n    kmp();\n    cin>>l>>r;\n    le[0]=n/2-nx[n/2];\n    le[1]=n/2;\n    fo(i,1,n/2) \n    {\n        a[1][ch[i]-'a']++; \n        if(i<=le[0]) a[0][ch[i]-'a']++;\n    }\n    fo(i,0,25) printf(\"%lld \",calc(i,r)-calc(i,l-1));\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5;\nconst int SIZE = 205;\n\nint N;\nLL L, R;\nchar S[MAXN];\n\nvoid input()\n{\n    scanf(\"%s\", S + 1);\n    read(L); read(R);\n    N = strlen(S + 1) / 2;\n}\n\nint M;\nLL Flen[SIZE], cnt[SIZE];\nint curc;\n\nLL count(LL d, LL n)\n{\n    if (d <= 1) {\n        LL ret = 0;\n        for (int j = 1; j <= n; ++j) {\n            ret += (S[j] == curc + 'a');\n        }\n        return ret;\n    }\n    if (n > Flen[d - 1])\n        return cnt[d - 1] + count(d - 2, n - Flen[d - 1]);\n    else\n        return count(d - 1, n);\n}\n\nvoid solve()\n{\n    static int fail[MAXN];\n\n    for (int i = 2; i <= N; ++i) {\n        int p = fail[i - 1];\n        while (p && S[p + 1] != S[i]) {\n            p = fail[p];\n        }\n        fail[i] = p + (S[p + 1] == S[i]);\n    }\n\n    int period = N - fail[N];\n    Flen[M++] = period;\n    Flen[M++] = N;\n    for (; Flen[M - 1] <= 2e18; ++M) {\n        Flen[M] = Flen[M - 1] + Flen[M - 2];\n    }\n\n    for (curc = 0; curc < 26; ++curc) {\n        std::fill(cnt, cnt + M, 0);\n        for (int j = 1; j <= period; ++j) {\n            cnt[0] += (S[j] == curc + 'a');\n        }\n        for (int j = 1; j <= N; ++j) {\n            cnt[1] += (S[j] == curc + 'a');\n        }\n        for (int j = 2; j < M; ++j) {\n            cnt[j] = cnt[j - 1] + cnt[j - 2];\n        }\n\n        printf(\"%lld \", count(M - 1, R) - count(M - 1, L - 1));\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 此生谁料，心在天山，身老沧洲。\n//     -- 陆游《诉衷情·当年万里觅封侯》\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=255555;\ntypedef long long LL;\nstruct data{\n\tLL len,a[26];\n\tinline void operator+=(const data&rhs){\n\t\tlen+=rhs.len;\n\t\tfor(int i=0;i<26;++i)a[i]+=rhs.a[i];\n\t}\n\tinline data operator-(const data&rhs)const{\n\t\tdata c;\n\t\tc.len=0;\n\t\tfor(int i=0;i<26;++i)c.a[i]=a[i]-rhs.a[i];\n\t\treturn c;\n\t}\n}d[500],ans;\nchar s[N];\nint fail[N],n;\nLL L,R;\nvoid getfail(){\n    for(int i=2,j=0;i<=n;++i){\n        while(j&&s[j+1]!=s[i])j=fail[j];\n        if(s[j+1]==s[i])++j;\n        fail[i]=j;\n    }\n}\ndata solve(LL R){\n\tdata ret;\n\tfor(int i=ret.len=0;i<26;++i)ret.a[i]=0;\n\tif(n%(n-fail[n])==0){\n\t\tLL k=R/n;\n\t\tfor(int i=1;i<=n;++i)ret.a[s[i]-'a']+=k;\n\t\tfor(int i=1;i<=R%n;++i)++ret.a[s[i]-'a'];\n\t}else{\n\t\tmemset(d,0,sizeof d);\n\t\tint tot=2;\n\t\td[2].len=n;\n\t\tfor(int i=1;i<=n;++i)++d[2].a[s[i]-'a'];\n\t\td[1].len=n-fail[n];\n\t\tfor(int i=1;i<=n-fail[n];++i)++d[1].a[s[i]-'a'];\n\t\twhile(d[tot].len<=R){\n\t\t\t++tot;\n\t\t\td[tot]=d[tot-1],d[tot]+=d[tot-2];\n\t\t}\n\t\tfor(int i=tot;i;--i)\n\t\tif(R>=d[i].len)R-=d[i].len,ret+=d[i];\n\t\tfor(int i=1;i<=R;++i)++ret.a[s[i]-'a'];\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&L,&R);\n\tn=strlen(s+1)>>1;\n\tgetfail();\n\tans=solve(R);\n\tans=ans-solve(L-1);\n\tfor(int i=0;i<26;++i)\n\tprintf(\"%lld \",ans.a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\n#define LL long long\n#define ULL unsigned LL\nusing namespace std;\nLL l,r,a[26],b[26],f[95][27],F[95];\nint n; char A[N];\nULL H[N],S[N];\nULL HA(int l,int r){ return H[r]-H[l-1]*S[r-l+1];}\nvoid calc(LL r,int v,LL *a)\n{\n\tint i,j;\n\tif(n%v==0){\n\t\tfor(i=1;i<=n&&i<=r;i++) a[A[i]-'a']++;\n\t\tif(r>=n){\n\t\t\tr-=n;\n\t\t\tfor(i=1;i<=v;i++)\n\t\t\t\ta[A[i]-'a']+=r/v+(r%v>=i);\n\t\t  }\n\t  }\n\telse{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=1;i<=v;i++) f[0][A[i]-'a']++;\n\t\tfor(i=1;i<=n;i++) f[1][A[i]-'a']++;\n\t\tF[0]=v,F[1]=n;\n\t\tfor(i=2;i<=90;i++){\n\t\t\tF[i]=F[i-1]+F[i-2];\n\t\t\tfor(j=0;j<26;j++)\n\t\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\t\tif(F[i]>r) break;\n\t\t  }\n\t\twhile(i){\n\t\t\tif(r>=F[i]){\n\t\t\t\tfor(j=0;j<26;j++) a[j]+=f[i][j];\n\t\t\t\tr-=F[i];\n\t\t\t  }\n\t\t\ti--;\n\t\t  }\n\t\tfor(i=1;i<=r;i++) a[A[i]-'a']++;\n\t  }\n}\nint main()\n{\n\tint i;\n\tscanf(\"%s\",A+1);\n\tn=strlen(A+1)/2;\n\tcin>>l>>r;\n\tS[0]=1;\n\tfor(i=1;i<=n;i++)\n\t\tH[i]=H[i-1]*173+A[i],S[i]=S[i-1]*173;\n\tfor(i=1;i<=n;i++)\n\t\tif(HA(i+1,n)==HA(1,n-i))\n\t\t\tbreak;\n\tcalc(r,i,a);\n\tcalc(l-1,i,b);\n\tfor(i=0;i<26;i++)\n\t\tprintf(\"%lld \",a[i]-b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) {\n      cnt[s[i] - 'a'] += rq - lq;\n    }\n    for (unsigned i = 0; i < rr; ++i) {\n      ++cnt[s[i] - 'a'];\n    }\n    for (unsigned i = 0; i < lr; ++i) {\n      --cnt[s[i]];\n    }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      len.push_back(len[len.size() - 1] + len[len.size() - 2]);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs('z' - 'a' + 1, 0);\n    for (unsigned i = 0; i < cnt_s.size(); ++i) { cnt_gs[i] = cnt_s[i]; }\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        cnt.push_back(cnt[cnt.size() - 1] + cnt[cnt.size() - 2]);\n      }\n      unsigned long long ans = 0;\n      auto rr = r + 1;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      for (unsigned j = 0; j < rr; ++j) {\n        if (s[j] - 'a' == i) { ++ans; }\n      }\n      auto ll = l;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > ll) { continue; }\n        rr -= len[j];\n        ans -= cnt[j];\n      }\n      for (unsigned j = 0; j < ll; ++j) {\n        if (s[j] - 'a' == i) { --ans; }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t{\n\t\t\tassert(lim<=la);\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++,assert(s[i]>='a' && s[i]<='z');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(lim<=lb);\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++,assert(s[i]>='a' && s[i]<='z');\n\t\t}\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n//\tif((npos+1)*2==len)\n//\t{\n\tif(npos==-1)\n\t{\n\t\tsset(A[0],0,len-1);\n\t\tsset(B[0],0,len-1);\n\t\tsset(B[0],0,len-1);\n\t\tla=len;lb=la+la;\n\t\tsa=0,sb=0;\n\t\tfor(int i=len;i<len+len;i++)\n\t\t\ts[i]=s[i-len];\n\t}\n\telse\n\t{\n\t\tint wpos=pre[len-npos-2];\n\t\twhile(wpos>=(len-npos-1)/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-npos-2);\n\t\t\tsset(B[0],0,len-npos-2);\n\t\t\tsset(B[0],0,len-npos-2);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,len-npos-2-wpos-1);\n\t\t\tla=wpos+1;lb=len-npos-1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n/*\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=len-(npos+1)*2;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t}\n*/\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tll _s=0,_t=1,S=1,T=0;\n\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\twork(r-_s*n-_t*k);\n\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=2e5+5;\nint totlen;\nll l,r;\nll len[maxn];\nint nxt[maxn];\nchar str[maxn];\nstruct val{\n\tll cnt[26];\n\tval(){memset(cnt,0,sizeof cnt);}\n\tfriend val operator+(val A,val B){\n\t\tval C;\n\t\trep2(i,0,26)C.cnt[i]=A.cnt[i]+B.cnt[i];\n\t\treturn C;\n\t}\n\tfriend val operator-(val A,val B){\n\t\tval C;\n\t\trep2(i,0,26)C.cnt[i]=A.cnt[i]-B.cnt[i];\n\t\treturn C;\n\t}\n\tfriend void Print(val A){\n\t\trep2(i,0,26)printf(\"%lld \",A.cnt[i]);puts(\"\");\n\t}\n}v[105];\nvoid getnxt(){\n\tint tmp=0;\n\trep(i,2,totlen){\n\t\twhile(tmp&&str[tmp+1]!=str[i])tmp=nxt[tmp];\n\t\tif(str[tmp+1]==str[i])tmp++;\n\t\tnxt[i]=tmp;\n\t}\n\tfor(int i=nxt[totlen];;i=nxt[i])if(i<(totlen+1)/2){\n\t\tlen[1]=totlen-i;\n\t\tbreak;\n\t}\n\tlen[0]=len[1]-nxt[len[1]];\n}\nval Calc(int now,ll pos){\n\tval res;\n\tif(now==1){\n\t\trep(i,1,pos)res.cnt[str[i]-'a']++;\n\t\treturn res;\n\t}\n\tif(pos<=len[now-1])return Calc(now-1,pos);\n\treturn v[now-1]+Calc(now-1,pos-len[now-1]);\n}\nint main(){\n\tscanf(\"%s\",str+1);\n\ttotlen=strlen(str+1);\n\tgetnxt();\n\trep(i,1,len[0])v[0].cnt[str[i]-'a']++;\n\trep(i,1,len[1])v[1].cnt[str[i]-'a']++;\n\tread(l);read(r);\n\tint maxi=1;\n\trep(i,2,100){\n\t\tlen[i]=len[i-1]+len[i-2],v[i]=v[i-1]+v[i-2];\n\t\tif(len[i]>r){maxi=i;break;}\n\t}\n\tPrint(Calc(maxi,r)-Calc(maxi,l-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = s+t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<s+t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\twhile(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2 - fail[n / 2];\n\tint t = fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst ll    inf = 2e18;\n\nll  add(ll  x,ll  y)    {   x += y; if (x > inf)    x = inf;    return  x;  }\nll  mul(ll  x,ll  y)    {\n    if (x == 0) return  0;\n    if (y == 0) return  0;\n    if (x >= inf / y)\n        return  inf;\n    else\n        return  x * y;\n}\n\nstring S;\nll  l, r;\nint kmp[N];\n\nvector<ll>  fib;\nvector<ll>  calc()  {\n    if (r == 0) return  vector<ll>(26,0);\n    int n = sz(S);\n\n    int len1 = n - kmp[n];\n    int len2 = n - len1;\n\n    ll  cnt1 = 0;\n    ll  cnt2 = 0;\n\n    for(int i = sz(fib) - 1 ; i > 1 ; --i)\n        if (add(mul(fib[i - 1],len1),mul(fib[i - 2],len2)) <= r)    {\n            cnt1 += fib[i - 1];\n            cnt2 += fib[i - 2];\n\n            r -= fib[i - 1] * len1;\n            r -= fib[i - 2] * len2;\n        }\n    vector<ll>  res(26,0);\n\n    for(int i = 0 ; i < r ; ++i)    res[S[i] - 'a']++;\n\n    for(int i = 0 ; i < len1 ; ++i) res[S[i] - 'a'] += cnt1;\n    for(int i = len1 ; i < n ; ++i) res[S[i] - 'a'] += cnt2;\n\n    return  res;\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    fib.pb(0);\n    fib.pb(1);\n\n    while (fib.back() < inf)\n        fib.pb(0),\n        fib.back() += fib[sz(fib) - 2],\n        fib.back() += fib[sz(fib) - 3];\n\n    cin >> S;       S.resize(sz(S) / 2);\n    cin >> l >> r;\n\n    kmp[1] = 0;\n    kmp[0] = -1;\n\n    for(int i = 2 ; i <= sz(S) ; ++i)\n    for(int j = kmp[i - 1] ; j >= 0 ; j = kmp[j])\n        if (S[j] == S[i - 1])   {\n            kmp[i] = j + 1;\n            break;\n        }    \n    vector<ll>  cnt1 = calc();  r = l - 1;\n    vector<ll>  cnt2 = calc();\n\n    for(int i = 0 ; i < 26 ; ++i)\n        cout << cnt1[i] - cnt2[i] << \" \";\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\nll len[1001], cnt[1001][26];\nint cntS[200001][26], cntX[400001][26];\nvector<int> Z_algo(string &s) {\n\tint n = s.size();\n\tvector<int> z(n);\n\tint L = 0, R = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i > R) {\n\t\t\tL = R = i;\n\t\t\twhile (R < n && s[R - L] == s[R]) R++;\n\t\t\tz[i] = R - L; R--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - L;\n\t\t\tif (z[k] < R - i + 1) z[i] = z[k];\n\t\t\telse {\n\t\t\t\tL = i;\n\t\t\t\twhile (R < n && s[R - L] == s[R]) R++;\n\t\t\t\tz[i] = R - L; R--;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nll solve(int k, int ch, ll L) {\n\tif (L > len[k]) return cnt[k][ch] + solve(k, ch, L - len[k]);\n\tif (L == len[k]) return cnt[k][ch];\n\tif (k == 0) return cntS[L][ch];\n\tif (k == 1) return cntX[L][ch];\n\tif (L > len[k - 1]) return cnt[k - 1][ch] + solve(k - 2, ch, L - len[k - 1]);\n\treturn solve(k - 1, ch, L);\n}\nint main() {\n\tstring S;\n\tcin >> S;\n\tll l, r;\n\tcin >> l >> r;\n\tS = S.substr(0, S.size() / 2);\n\tvector<int> z = Z_algo(S);\n\tint k = S.size() - 1;\n\twhile (k > 0) {\n\t\tif (S.size() - k == z[k]) break;\n\t\tk--;\n\t}\n\tif (k == 0) k = S.size();\n\tstring T = S.substr(0, k);\n\tstring X = S + T;\n\tlen[0] = S.size();\n\tlen[1] = X.size();\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tfor (int j = 0; j < 26; j++) cntS[i + 1][j] += cntS[i][j];\n\t\tcntS[i + 1][S[i] - 'a']++;\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < 26; j++) cntX[i + 1][j] += cntX[i][j];\n\t\tcntX[i + 1][X[i] - 'a']++;\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tcnt[0][i] = cntS[S.size()][i];\n\t\tcnt[1][i] = cntX[X.size()][i];\n\t}\n\tk = 0;\n\twhile (len[k] * 2 < r) {\n\t\tif (k > 0) {\n\t\t\tlen[k + 1] = len[k] + len[k - 1];\n\t\t\tfor (int i = 0; i < 26; i++) cnt[k + 1][i] = cnt[k][i] + cnt[k - 1][i];\n\t\t}\n\t\tk++;\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tcout << solve(k, i, r) - solve(k, i, l - 1) << \" \";\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 + c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int64 c[26],len;\n    node() {memset(c,0,sizeof(c));len = 0;}\n    friend node operator + (const node &a,const node &b) {\n        node r;\n        r.len = a.len + b.len;\n        for(int i = 0 ; i < 26 ; ++i) r.c[i] = a.c[i] + b.c[i];\n        return r;\n    }\n    friend node operator - (const node &a,const node &b) {\n        node r;\n        r.len = a.len - b.len;\n        for(int i = 0 ; i < 26 ; ++i) r.c[i] = a.c[i] - b.c[i];\n        return r;\n    }\n    friend node operator * (const node &a,const int64 &d) {\n        node r = a;\n        for(int i = 0 ; i < 26 ; ++i) {\n            r.c[i] = r.c[i] * d;\n        }\n        return r;\n    }\n}g[MAXN];\nchar s[MAXN * 2],t[MAXN * 2];\nint nxt[MAXN],N;\nint st,all;\nnode Calc(int64 R) {\n    if(R > g[all].len && st) {\n        node res;\n        res = g[st];\n        int64 t = (R - g[st].len) / g[st - 1].len;\n        res = res + g[st - 1] * t;\n        return res + Calc(R - g[st].len - g[st - 1].len * t);\n    }\n    else if(R <= g[1].len){\n        node res;res.len = R;\n        for(int i = 1 ; i <= R ; ++i) {\n            res.c[s[i] - 'a']++;\n        }\n        return res;\n    }\n    else {\n        for(int i = all ; i >= 0 ; --i) {\n            if(g[i].len <= R) {\n                return g[i] + Calc(R - g[i].len);\n            }\n        }\n    }\n}\nvoid Solve() {\n    scanf(\"%s\",s + 1);\n    int64 r,l;\n    read(l);read(r);\n    N = strlen(s + 1);\n    for(int i = 2 ; i <= N ; ++i) {\n        int p = nxt[i - 1];\n        while(p && s[i] != s[p + 1]) p = nxt[p];\n        if(s[i] == s[p + 1]) nxt[i] = p + 1;\n        else nxt[i] = 0;\n    }\n    int p = nxt[N];\n    while(p > (N - 1) / 2) p = nxt[p];\n    int L = N;\n    for(int i = p + 1 ; i <= N - p ; ++i) {\n        s[++L] = s[i];\n    }\n    for(int i = 1 ; i <= L / 2; ++i) {\n        g[1].c[s[i] - 'a']++;\n    }\n    g[1].len = L / 2;\n    p = nxt[L / 2];\n    g[0].len = L / 2 - p;\n    for(int i = 1 ; i <= L / 2 - p ; ++i) {\n        t[i] = s[i];\n        g[0].c[t[i] - 'a']++;\n    }\n    for(int i = 2 ; i <= 100 ; ++i) {\n        if(g[i - 1].len % (g[i - 1].len - g[i - 2].len) == 0) {all = i - 1;st = i - 1;break;}\n        if(g[i - 1].len + g[i - 2].len <= 1e18) g[i] = g[i - 1] + g[i - 2];\n        else {all = i - 1;break;}\n    }\n    if(!all) all = 100;\n    node ans = Calc(r) - Calc(l - 1);\n    for(int i = 0 ; i < 26 ; ++i) {\n        out(ans.c[i]);space;\n    }\n    enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next NexT\n#define LL long long\n\nconst int maxn=2e5+10;\n\nint n,next[maxn];\nLL L,R,c0[30],cA[30],cB[30],Ans[30],LA,LB;\nchar s[maxn];\n\nvoid KMP()\n{\n\tint i;\n\tnext[0]=0; next[1]=0;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tnext[i]=next[i-1];\n\t\twhile (s[next[i]+1]!=s[i]&&next[i])\n\t\t\tnext[i]=next[next[i]];\n\t\tnext[i]+=s[next[i]+1]==s[i];\n\t}\n}\n\nvoid solve(LL R,int flag)\n{\n\tint i;\n\tif (R<=n)\n\t{\n\t\tfor (i=1;i<=R;i++)\n\t\t\tAns[s[i]-'a']+=flag;\n\t\treturn;\n\t}\n\tLA=next[n];\n\tLB=n-2*next[n];\n\tmemset(cA,0,sizeof(cA));\n\tmemset(cB,0,sizeof(cB));\n\tfor (i=1;i<=LA;i++) cA[s[i]-'a']++;\n\tfor (i=LA+1;i<=LA+LB;i++) cB[s[i]-'a']++;\n\twhile (LA+LB+LA+LA+LB<=R)\n\t{\n\t\tswap(LA,LB); LA+=LB;\n\t\tfor (i=0;i<26;i++)\n\t\t\tswap(cA[i],cB[i]),cA[i]+=cB[i];\n\t}\n\tfor (i=0;i<26;i++)\n\t\tAns[i]+=flag*(cA[i]+cB[i]+cA[i]);\n\tR-=LA+LB+LA;\n\n\treturn;\n\n\twhile (R)\n\t{\n\t\tLA-=LB; swap(LA,LB);\n\t\tfor (i=0;i<26;i++)\n\t\t\tcA[i]-=cB[i],swap(cA[i],cB[i]);\n\t\tif (R>=LA)\n\t\t{\n\t\t\tfor (i=0;i<26;i++)\n\t\t\t\tAns[i]+=flag*cA[i];\n\t\t\tR-=LA;\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i;\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tn=strlen(s+1);\n\tn=n/2;\n\tKMP();\n\tif (n%(n-next[n])==0)\n\t{\n\t\tfor (i=1;i<=n;i++) c0[s[i]-'a']++;\n\t\tfor (i=0;i<26;i++) Ans[i]+=c0[i]*((R/n)-((L-1)/n));\n\t\tfor (i=1;i<=R%n;i++) Ans[s[i]-'a']++;\n\t\tfor (i=1;i<=(L-1)%n;i++) Ans[s[i]-'a']--;\n\t\tfor (i=0;i<26;i++) printf(\"%lld \",Ans[i]);\n\t\treturn 0;\n\t}\n\twhile (next[n]>=(n+1)/2)\n\t\tn+=n-next[n],KMP();\n\tsolve(R,+1);\n\tsolve(L-1,-1);\n\tfor (i=0;i<26;i++)\n\t\tprintf(\"%lld \",Ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\n#define LL long long\n \nchar s[N];\nint tot[N][26],f[N];\nint n,T;\n \nLL calc(LL len,int ch)\n{\n\tif(len<=n) return tot[len][ch];\n\tLL num1=tot[n][ch],num2=tot[T][ch];\n\tLL len1=n,len2=T;\n\twhile(len1+len2<=len){\n\t\tnum1=num1+num2,num2=num1-num2;\n\t\tlen1=len1+len2,len2=len1-len2;\n\t}\n\treturn num1+calc(len-len1,ch);\n}\n \nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tf[0]=0;f[1]=0;tot[1][s[1]-'a']=1;\n\tfor(int i=2,p;i<=n;i++)\n\t{\n\t\tp=f[i-1];\n\t\twhile(p&&s[p+1]!=s[i]) p=f[p];\n\t\tf[i]=s[p+1]!=s[i] ? 0:p+1;\n\t\tmemcpy(tot[i],tot[i-1],sizeof(tot[i]));\n\t\ttot[i][s[i]-'a']++;\n\t}\n\tT=n-f[n];// cout << T << endl; return 0;\n\tLL l,r;\n\tcin>>l>>r;\n\tfor(int i=0;i<26;i++)\tcout<<calc(r,i)-calc(l-1,i)<<\" \";\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,m,fail[200010];\nll ans[30],len[95],sum[95][30],cnt[200010][30];\nchar s[200010];\nvoid kmp()\n{\n\tfail[0]=-1;\n\tint p=-1;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\twhile (p>=0 && s[i]!=s[p+1])\n\t\t{\n\t\t\tp=fail[p];\n\t\t}\n\t\tif (s[i]==s[p+1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\tfail[i]=p;\n\t}\n}\nvoid solve(ll k,ll f)\n{\n\tll p=k/(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*p*cnt[m][i];\n\t}\n\tll q=k%(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[q][i];\n\t}\n}\nvoid work(ll k,ll f)\n{\n\tint i=1;\n\twhile (len[i]<=k)\n\t{\n\t\ti++;\n\t}\n\tfor (;i;i--)\n\t{\n\t\tif (k>len[i])\n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tans[j]+=f*sum[i][j];\n\t\t\t}\n\t\t\tk-=len[i];\n\t\t}\n\t}\n\tfor (i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[k][i];\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",&s);\n\tn=strlen(s);\n\tn/=2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tkmp();\n\tm=n-1-fail[n-1];\n\tll l,r;\n\tcin>>l>>r;\n\tif (n%m==0)\n\t{\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t}\n\telse\n\t{\n\t\tlen[1]=n;\n\t\tlen[2]=m+n;\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tsum[1][i]=cnt[n][i];\n\t\t\tsum[2][i]=cnt[m][i]+sum[1][i];\n\t\t}\n\t\tfor (int i=3;i<=90;i++)\n\t\t{\n\t\t\tlen[i]=len[i-2]+len[i-1];\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\t\t}\n\t\t}\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n}\n\nstring s,t;\nll l,r,S,T;\n\nvl Solve(ll x){\n\tvl a(26);\n\tfor(int i=0;i<min(S,x);i++) a[f(s[i])]++;\n\tif(x>S){\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(x-S)/T;\n\t\tfor(int i=0;i<(x-S)%T;i++) a[f(t[i])]++;\n\t}\n\treturn a;\n}\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0;\n\tT=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tT=i;\n\t\t}\n\t}\n\tt=s.substr(0,T);\n\tif(S%T==0){\n\t\tassert(0);\n\t\tvl al=Solve(l),ar=Solve(r);\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<ar[i]-al[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2e5, alpha = 26;\n\nchar s0[MAXN + 5];\nint S[MAXN + 5];\n\nint n, N;\nLL L, R;\n\ninline void input()\n{\n\tscanf(\"%s\", s0 + 1), n = strlen(s0 + 1), N = n / 2;\n\tfor(int i = 1; i <= n; ++i) S[i] = s0[i] - 'a';\n\tL = read<LL>(), R = read<LL>();\n}\n\nint T[MAXN + 5];\nint M;\n\ninline void calc_T(int *s, int len)\n{\n\tstatic int fail[MAXN + 5];\n\n\tfor(int i = 2, j = 0; i <= len; ++i)\n\t{\n\t\twhile(j && s[j + 1] != s[i]) j = fail[j];\n\t\tif(s[j + 1] == s[i]) ++j;\n\t\tfail[i] = j;\n\t}\n\n\tM = fail[len] ?  len - fail[len] : len;\n\tfor(int i = 1; i <= M; ++i) T[i] = s[i];\n}\n\nstruct vec\n{\n\tLL cnt[alpha];\n\n\tinline LL &operator [] (int pos) { return cnt[pos]; }\n\tinline const LL &operator [] (int pos) const { return cnt[pos]; }\n\n\tinline vec operator + (const vec &rhs) const\n\t{\n\t\tstatic vec res;\n\t\tfor(int i = 0; i < alpha; ++i) res[i] = (*this)[i] + rhs[i];\n\t\treturn res;\n\t}\n\tinline vec operator - (const vec &rhs) const\n\t{\n\t\tstatic vec res;\n\t\tfor(int i = 0; i < alpha; ++i) res[i] = (*this)[i] - rhs[i];\n\t\treturn res;\n\t}\n\n\tvec() { memset(cnt, 0, sizeof cnt); }\n};\n\nconst int MAX_LOG = 100;\n\nvec cnt[MAX_LOG + 1];\nLL len[MAX_LOG + 1];\nint k;\n\ninline vec prefix(LL LIM)\n{\n\tif(LIM == 0) return vec();\n\tfor(int i = k; i >= 1; --i) if(len[i] <= LIM) return cnt[i] + prefix(LIM - len[i]);\n\n\tvec res;\n\tfor(int i = 1; i <= LIM; ++i) ++res[S[i]];\n\treturn res;\n}\n\ninline void solve()\n{\n\tcalc_T(S, N);\n\n\tlen[1] = N;\n\tfor(int i = 1; i <= N; ++i) ++cnt[1][S[i]];\n\n\tlen[2] = N + M;\n\tfor(int i = 1; i <= N; ++i) ++cnt[2][S[i]];\n\tfor(int i = 1; i <= M; ++i) ++cnt[2][T[i]];\n\n\tfor(k = 2; len[k] * 2 < R; )\n\t{\n\t\t++k;\n\t\tlen[k] = len[k - 1] + len[k - 2];\n\t\tfor(int i = 0; i < alpha; ++i) cnt[k][i] = cnt[k - 1][i] + cnt[k - 2][i];\n\t}\n\n\tvec ans;\n\tif(R > len[k]) ans = prefix(len[k]) - prefix(L - 1) + prefix(R - len[k]);\n\telse ans = prefix(R) - prefix(L - 1);\n\tfor(int i = 0; i < alpha; ++i) printf(\"%lld \", ans[i]);\n\tputs(\"\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = s+t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<s+t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\tif(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2;\n\tint t = n / 2 - fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define ll long long\n#define MN 200000\n#define mod 1000000007\nusing namespace std;\nchar s[MN+5];int n,cnt=2,ha[MN+5],pw[MN+5];\nll l,r,len[105],num[105][27],ans[27];\ninline int Ha(int l,int r){return (ha[r]-1LL*ha[l-1]*pw[r-l+1]%mod+mod)%mod;}\nvoid Calc(ll l,int x,int v)\n{\n\tif(x<=1)\n\t{\n\t\tfor(int j=1;j<=l;++j) ans[s[j]-'a']+=v;\n\t\treturn;\t\n\t}\n\tif(l<=len[x-1]) Calc(l,x-1,v);\n\telse \n\t{\n\t\tfor(int j=0;j<26;++j) ans[j]+=v*num[x-1][j];\n\t\tCalc(l-len[x-1],x-2,v);\t\n\t}\n}\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);n=strlen(s+1)/2;pw[0]=1;\n\tfor(int i=1;i<=n;++i) pw[i]=31LL*pw[i-1]%mod,ha[i]=(31LL*ha[i-1]+s[i]-'a'+1)%mod;\n\tfor(int i=2;i<=n+1;++i) if(i>n||Ha(i,n)==Ha(1,n-i+1))\n\t{\n\t\tlen[1]=n;len[2]=n+i-1;\n\t\tfor(int j=1;j<=n;++j) ++num[1][s[j]-'a'],num[2][s[j]-'a']+=1+(j<i);\n\t\tbreak;\t\n\t}\n\twhile(len[cnt]<r)\n\t{\n\t\t++cnt;len[cnt]=len[cnt-1]+len[cnt-2];\n\t\tfor(int j=0;j<26;++j) num[cnt][j]=num[cnt-1][j]+num[cnt-2][j];\n\t}\n\tCalc(r,cnt,1);Calc(l-1,cnt,-1);\n\tfor(int i=0;i<26;++i) printf(\"%lld \",ans[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\nvector<ll> hoge2(ll v) {\n\tvector<ll> ret(26,0);\n\t\n\tint i=100,j;\n\tfor(i=100;i>=0;i--) {\n\t\tif(v>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tv-=cnt[i][26];\n\t\t}\n\t}\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/*\\\n * ...\n * ......\n * In the name of ALLAH\n * ......\n * ...\n\\*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define Size(x) ((int)(x).size())\n#define pb push_back\n#define LD_OUT setprecision(12) << fixed\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int>pii;\nconst int INF = 1e9 + 10 , MN = 2e5 + 10 , LG = 222;\nconst ll BIG = 1000ll*1000*1000*1000*1000*1000 + 10;\n\nint n , nxt[MN];\nstring s;\nll Nx[LG] , Ny[LG] , X[33][LG] , Y[33][LG];\nint ps[33][MN];\n\nvoid prep()\n{\n\tint cur = 0;\n\tfor(int i=1;i<n;++i){\n\t\twhile(cur && s[i] != s[cur]) cur = nxt[cur];\n\t\tcur += (s[i] == s[cur]);\n\t\tnxt[i+1] = cur;\n\t}\n\tNx[0] = n - nxt[n] , Ny[0] = nxt[n];\n\tfor(int i=0;i<Nx[0];++i)\n\t\tX[s[i]-'a'][0]++;\n\tfor(int i=Nx[0];i<n;++i)\n\t\tY[s[i]-'a'][0]++;\n\tfor(int i=1;i<LG;++i){\n\t\tNx[i] = Nx[i-1] + Ny[i-1];\n\t\tNx[i] = min(Nx[i] , BIG);\n\t\tNy[i] = Nx[i-1];\n\t\tfor(int j=0;j<26;++j){\n\t\t\tX[j][i] = X[j][i-1] + Y[j][i-1];\n\t\t\tY[j][i] = X[j][i-1];\n\t\t\tX[j][i] = min(X[j][i] , BIG);\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<26;++j)\n\t\t\tps[j][i+1] = ps[j][i] + (s[i]-'a' == j);\n}\n\nll get(ll val,int c)\n{\n\tfor(int i=LG-1;~i;--i)\n\t\tif(Nx[i] <= val) return min(BIG , X[c][i] + get(val - Nx[i] , c));\n\treturn ps[c][val];\n}\n\nint main()\n{\n\tios_base :: sync_with_stdio(false) ,cin.tie(0) , cout.tie(0);\n\tcin>>s;\n\tn = Size(s)/2;\n\tprep();\n\n\tll l , r;\n\tcin >> l >> r;\n\tfor(int c=0;c<26;++c) cout << get(r , c) - get(l-1 , c) << ' ';\n\tcout << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long  LL;\nint n,nxt[200010],k;\nLL l,r,ans[26];\nchar s[200010];\n\nvoid calc(LL m)\n{\n\tif (m<=n)\n\t\t{\n\t\t\tfor (int i=1; i<=m; i++)  ans[s[i]-'a']++;\n\t\t\treturn;\n\t\t}\n\tLL a0=1,b0=0,c0=0,a1=1,b1=1,c1=1,a2,b2,c2;\n\twhile (a1*k+b1*(n-k)<=m)\n\t\t{\n\t\t\ta2=a1+a0,b2=b1+b0,c2=c0;\n\t\t\ta0=a1,b0=b1,c0=c1,a1=a2,b1=b2,c1=c2;\n\t\t}\n\tfor (int i=1; i<=k; i++)  ans[s[i]-'a']+=a0;\n\tfor (int i=k+1; i<=n; i++)  ans[s[i]-'a']+=b0;\n\tcalc(m-a0*k-b0*(n-k));\n}\n\nvoid work()\n{\n\tscanf(\"%s\\n%lld %lld\",s+1,&l,&r),n=strlen(s+1)/2,l--;\n\tnxt[1]=0;\n\tfor (int i=2,j=0; i<=n; i++)\n\t\t{\n\t\t\twhile ((j)&&(s[i]!=s[j+1]))  j=nxt[j];\n\t\t\tif (s[i]==s[j+1])  nxt[i]=++j;  else  nxt[i]=j;\n\t\t}\n\tk=n-nxt[n];\n\tcalc(l);\n\tfor (int i=0; i<26; i++)  ans[i]*=-1;\n\tcalc(r);\n\tfor (int i=0; i<26; i++)  printf(\"%lld \",ans[i]);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nvector<int> pre_kmp(const string& pat) {\n\tint k;\n\tvector<int> table((int)pat.size() + 1);\n\ttable[0] = -1;\n\n\tfor (int i = 1; i <= pat.size(); ++i) {\n\t\tk = table[i-1];\n\n\t\twhile (k >= 0) {\n\t\t\tif (pat[k] == pat[i-1]) break;\n\t\t\telse k = table[k];\n\t\t}\n\n\t\ttable[i] = k + 1;\n\t}\n\n\treturn table;\n}\n\nvector<ll> len;\nvector<vector<ll>> num;\n\nvector<ll> calc(ll t, string &S) {\n\tvector<ll> cnt(26);\n\tif (t == 0) return cnt;\n\tfor (int i = (int)len.size()-1; i >= 0; --i) {\n\t\tif (len[i] <= t) {\n\t\t\trep(c, 26) cnt[c] += num[i][c];\n\t\t\tt -= len[i];\n\t\t}\n\t}\n\tif (t > 0) rep(i, t) cnt[S[i] - 'a']++;\n\treturn cnt;\n}\n\nint main() {\n\tstring S; ll L, R;\n\tcin >> S >> L >> R;\n\n\tint N = S.size() / 2;\n\n\tvi vec = pre_kmp(S);\n\tint cyc = N - vec[N];\n\n\tlen.pb(N);\n\tvector<ll> c0(26);\n\trep(i, N) ++c0[S[i] - 'a'];\n\n\tnum.pb(c0);\n\n\tlen.pb(N + cyc);\n\trep(i, cyc) ++c0[S[i]-'a'];\n\tnum.pb(c0);\n\n\tfor (int i = 2; ; ++i) {\n\t\tll nl = len[i-2] + len[i-1];\n\t\tif (nl > R) break;\n\t\tlen.pb(nl);\n\t\tvector<ll> nx(26);\n\t\trep(c, 26) nx[c] = num[i-1][c] + num[i-2][c];\n\t\tnum.pb(nx);\n\t}\n\n\tauto vl = calc(L-1, S), vr = calc(R, S);\n\trep(i, 26) printf(\"%lld%c\", vr[i] - vl[i], i == 25 ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=255555;\ntypedef long long LL;\nstruct data{\n\tLL len,a[26];\n\tinline void operator+=(const data&rhs){\n\t\tlen+=rhs.len;\n\t\tfor(int i=0;i<26;++i)a[i]+=rhs.a[i];\n\t}\n\tinline data operator-(const data&rhs)const{\n\t\tdata c;\n\t\tc.len=0;\n\t\tfor(int i=0;i<26;++i)c.a[i]=a[i]-rhs.a[i];\n\t\treturn c;\n\t}\n}d[500],ans;\nchar s[N];\nint fail[N],n;\nLL L,R;\nvoid getfail(){\n    for(int i=2,j=0;i<=n;++i){\n        while(j&&s[j+1]!=s[i])j=fail[j];\n        if(s[j+1]==s[i])++j;\n        fail[i]=j;\n    }\n}\ndata solve(LL R){\n\tdata ret;\n\tfor(int i=ret.len=0;i<26;++i)ret.a[i]=0;\n\tif(n%(n-fail[n])==0){\n\t\tLL k=R/n;\n\t\tfor(int i=1;i<=n;++i)ret.a[s[i]-'a']+=k;\n\t\tfor(int i=1;i<=R%n;++i)++ret.a[s[i]-'a'];\n\t}else{\n\t\tmemset(d,0,sizeof d);\n\t\tint tot=2;\n\t\td[2].len=n;\n\t\tfor(int i=1;i<=n;++i)++d[2].a[s[i]-'a'];\n\t\td[1].len=n-fail[n];\n\t\tfor(int i=1;i<=n-fail[n];++i)++d[1].a[s[i]-'a'];\n\t\twhile(d[tot].len*2<=R){\n\t\t\t++tot;\n\t\t\td[tot]=d[tot-1],d[tot]+=d[tot-2];\n\t\t}\n\t\tfor(int i=tot;i;--i)\n\t\tif(R>=d[i].len)R-=d[i].len,ret+=d[i];\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&L,&R);\n\tn=strlen(s+1)>>1;\n\tgetfail();\n\tans=solve(R);\n\tans=ans-solve(L-1);\n\tfor(int i=0;i<26;++i)\n\tprintf(\"%lld \",ans.a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=200010;\ntypedef long long ll;\nint n,prd,fail[N],k=0;\nchar a[N];\nll l,r,pre[N][30];\ninline ll fib(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(p<=n*2) return pre[n][c]+pre[p-n][c];\n\tll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n\twhile(p>a+b){\n\t\tll c=ret1; ret1+=ret2; ret2=c;\n\t\tc=a; a+=b; b=c;\n\t}\n\treturn ret1+fib(p-a,c);\n}\ninline ll cal(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(n%prd==0){\n\t\tll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n\t\tp%=prd;\n\t\treturn ret+pre[p][c];  \n\t}\n\telse return fib(p,c);\n}\n\nint main(){\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    \tpre[i][a[i]-'a']++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor(int i=2;i<=n;i++){\n\t\tif (k&&a[k+1]!=a[i]) k=fail[k];\n\t\tif (a[k+1]==a[i]) k++;\n\t\tfail[i]=k;\n\t}\n\tprd=n-fail[n];\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",cal(r,i)-cal(l-1,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tV=0;\n\t\t}\n\t\tif(V>cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tcout<<S[0].size()<<endl;\n\tcout<<S[1].size()<<endl;\n\tcout<<S[2].size()<<endl;\n\tcout<<nex(S[2]).size()<<endl;\n\tcout<<nex(nex(S[2])).size()<<endl;\n\t\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tassert(0);\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge3(R);\n\t\tLL=hoge3(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len=INF;\nstring s;\nint cnt[maxn][maxm],z[maxn]; \nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-L]<=R-i)z[i]=z[i-L];\n\t\t\telse{\n\t\t\t\tz[i]=R-i;\n\t\t\t\tfor(int j=R-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tREP(i,n-1)if(z[i]+i==n)len=min(len,i);\n\n\tif(len==INF){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N=2e5+10;\n\nLL l,r,ans[26],g[110],sum[N][26],sm[110][26];\nint len,plen,nxt[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n}\n\nvoid Getnext(char *s,int len) {\n\tnxt[0]=0;nxt[1]=0;\n\tfor (int i=1,k=0;i<len;++i) {\n\t\twhile (k && s[i]!=s[k]) k=nxt[k];\n\t\tif (s[i]==s[k]) ++k;\n\t\tnxt[i+1]=k;\n\t}\n}\n\nvoid Calc(int dep,LL *ans,LL _l,LL _r,int op) {\n\tif (_r==g[dep] && _l==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sm[dep][j];\n\t\treturn ;\n\t}\n\tif (dep==0 || dep==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*(sum[_r][j]-sum[_l-1][j]);\n\t\treturn ;\n\t}\n\tif (_r>g[dep-1] && _l<=g[dep-1]) {\n\t\tCalc(dep-1,ans,_l,g[dep-1],op);\n\t\tCalc(dep-2,ans,1,_r-g[dep-1],op);\n\t}else if (_r<=g[dep-1]) Calc(dep-1,ans,_l,_r,op);\n\t else Calc(dep-2,ans,_l-g[dep-1],_r-g[dep-1],op);\n}\n\nvoid Solve() {\n\tlen=strlen(s);len/=2;\n\tGetnext(s,len);\n\tfor (int i=1;i<=len;++i) {\n\t\tfor (int j=0;j<26;++j) sum[i][j]=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tplen=len-nxt[len];\n\tg[0]=plen; for (int j=0;j<26;++j) sm[0][j]=sum[plen][j];\n\tg[1]=len; for (int j=0;j<26;++j) sm[1][j]=sum[len][j];\n\tfor (int i=2;i<=100;++i) {\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tfor (int j=0;j<26;++j) sm[i][j]=sm[i-1][j]+sm[i-2][j];\n\t}\n\t\n\tfor (int i=1;i<=100;++i) \n\t\tif (g[i]>r) { Calc(i,ans,l,r,1); break; }\n\tfor (int i=0;i<26;++i) printf(\"%lld%c\",ans[i],(i==25)?'\\n':' ');\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n观察偶串 SS 变换后的形式，事实上是 STST ，其中 T 是 S 的最小循环节。\n那么设 g(S) = ST ，则有 f(SS) = g(S)g(S) ， f^k(SS) = g^k(S)g^k(S) 。\n考虑 g^k(S) 的变换过程。\n\n当 |T| | |S| 时，有 g(S) = ST, g^2(S) = STS, g^3(S) = STSST ...\n容易得出递推式 g^k(S) = g^{k-1}(S) + g^{k-2}(S) 。\n\n否则，有 g(S) = ST, g^2(S) = STT, g^2(S) = STTT ...\n容易得出递推式 g^k(S) = g^{k-1}(S) + T 。\n\n第一种情况下 g^k(S) 的长度增长很快，和斐波那契类似，\n因此有用的 g^k(S) 很少，可以预处理出每个 g^k(S) 的字母构成。\n假设要求 f..f(S) 的前 n 位，那么找到超过 n/2 的最小 g^k(S) ，\n这个 g^k(S) 一定是 f..f(S) 的前半段，统计进去，\n剩下的部分长 n - |g^k(S)| ，一定是 f..f(S) 后半段的前缀，即前半段的前缀，转为子问题。\n由于每次长度至少减少一半，这样统计的次数是 O(log) 的。\n\n第二种情况下 g^k(S) 长度增长呈等差数列，无法处理，\n但是注意到上述算法中并不关心 g^k(S) 具体的 k 是多少，\n因此可以按照第一种情况的递推式算，这样每个 g^k(S) 对应的实际上是一个 g^i(S) 满足 i > k 。\n而只要 g^k(S) 能对应一个真正的 g^i(S) ，上述的算法就能保证正确性。\n#endif\n#include <cstdio>\n#include <cstring>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long lolong;\n\ninline int input() { int x; scanf(\"%d\", &x); return x; }\ninline lolong linput() { lolong x; scanf(\"%lld\", &x); return x; }\n\nconst int maxn = 100005, maxk = 26;\nstruct Val {\n\tlolong a[maxk];\n\tlolong len;\n\tvoid operator += (Val an) {\n\t\tfor(int i = 0; i < maxk; i ++)\n\t\t\ta[i] += an.a[i];\n\t\tlen += an.len;\n\t}\n\tVal(): len(0) { memset(a, 0, sizeof a); }\n};\nchar s[maxn << 1];\nint fail[maxn];\nVal g[100];\n\nvoid solve(lolong n, Val &ans) {\n\t/* debug(\"%lld\\n\", n); */\n\tif(n <= g[0].len) {\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tans.a[s[i] - 'a'] ++;\n\t\tans.len += n;\n\t\treturn;\n\t}\n\n\tint p = 0;\n\twhile((g[p].len << 1) < n)\n\t\tp ++;\n\tans += g[p];\n\n\tsolve(n - g[p].len, ans);\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tint n = int(strlen(s + 1)) >> 1;\n\n\tfail[0] = -1;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tint j = fail[i];\n\t\twhile(~j and s[j + 1] != s[i + 1])\n\t\t\tj = fail[j];\n\t\tfail[i + 1] = j + 1;\n\t}\n\n\tint k = n - fail[n];\n\tlolong l = linput(), r = linput();\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tg[0].a[s[i] - 'a'] ++;\n\tg[0].len = n;\n\n\tg[1] = g[0];\n\tfor(int i = 1; i <= k; i ++)\n\t\tg[1].a[s[i] - 'a'] ++;\n\tg[1].len = n + k;\n\n\tfor(int i = 2; (g[i - 1].len << 1) < r; i ++) {\n\t\tg[i] = g[i - 1];\n\t\tg[i] += g[i - 2];\n\t}\n\n\tVal a, b;\n\tsolve(l - 1, a);\n\tsolve(r, b);\n\t/* debug(\"%lld %lld\\n\", a.len, b.len); */\n\n\tfor(int i = 0; i < maxk; i ++)\n\t\tprintf(\"%lld \", b.a[i] - a.a[i]);\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nstring trans(string s) {\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s.substr(0, i) == s.substr(s.size() - i, i)) {\n            string b = s.substr(0, s.size() - i);\n            return s + b;\n        }\n    }\n    assert(false);\n    return \"\";\n}\nvoid stupid() {\n    while (true) {\n        string s;\n        int p = rand() % 7 + 2;\n        for (int i = 0; i < p; i++) {\n            s += (char) (rand() % 2 + 'a');\n        }\n        string ns = trans(s);\n        int blen = ns.size() - s.size();\n        int slen = s.size() - blen;\n//        if (blen <= slen) continue;\n        bool f1 = (slen == 0);\n        bool f2 = (s.size() % blen == 0);//(blen <= slen);\n        if (blen <= slen && !f2) {\n            s = ns;\n            ns = trans(s);\n            blen = ns.size() - s.size();\n            slen = s.size() - blen;\n            assert(blen > slen);\n        }\n        string init = s;\n        s = ns;\n        for (int step = 0; step < 10; step++) {\n            string ns = trans(s);\n            int hisb = ns.size() - s.size();\n            int hiss = s.size() - hisb;\n            if (f1) {\n                assert(hisb == blen);\n            }\n            else if (f2) {\n                assert(hisb == blen);\n            }\n            else {\n//            if (hiss != blen) {\n//                cout << init << \" GG \" << s << \" \" << ns << \" \" << hiss << \" \" << blen << endl;\n//            }\n                assert(hiss == blen);\n            }\n            blen = hisb;\n            slen = hiss;\n//            cout << s << \" -> \" << ns << endl;\n            s = ns;\n        }\n    }\n}\nstring s;\nll l, r;\nvector < int > z_function(string& s) {\n    vector < int > z(s.size());\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < s.size(); i++) {\n        if (r < i) {\n            l = r = i;\n        }\n        z[i] = min(r - i, z[i - l]);\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\nll ans[26];\nll len[100];\nll lenB[100];\nll lenS[100];\nconst ll INF = 1e18 + 2;\nconst int maxN = 2e5 + 10;\nint pref[26][maxN];\nint prefS[26][maxN];\nll calcB(ll r, int c, int who);\nll calcS(ll r, int c, int who);\nll calc(ll r, int c, int who);\nmap < pair < pair < ll, int >, int >, ll > mp, mpB, mpS;\nll calc(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mp.find({{r, c}, who}) != mp.end()) return mp[{{r, c}, who}];\n    ll& d = mp[{{r, c}, who}];\n    if (r <= lenB[who]) {\n        return d = calc(r, c, who - 1);\n    }\n    return d = calc(lenB[who] - 1, c, who - 1) + calcB(r - lenB[who], c, who - 1);\n}\nll calcB(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpB.find({{r, c}, who}) != mpB.end()) return mpB[{{r, c}, who}];\n    ll& d = mpB[{{r, c}, who}];\n    if (r <= lenB[who]) {\n        return d = calcB(r, c, who - 1);\n    }\n    return d = calcB(lenB[who] - 1, c, who - 1) + calcS(r - lenB[who], c, who - 1);\n}\nll calcS(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpS.find({{r, c}, who}) != mpS.end()) return mpS[{{r, c}, who}];\n    ll& d = mpS[{{r, c}, who}];\n    return d = calcB(r, c, who - 1);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> s;\n    s = s.substr(0, s.size() / 2);\n    cin >> l >> r;\n    l--;\n    r--;\n    auto zz = z_function(s);\n    int n = s.size();\n    int blen = 0;\n    int slen = 0;\n    for (int i = 1; i < n; i++) {\n        if (zz[i] == n - i) {\n            blen = i;\n            slen = n - i;\n            break;\n        }\n    }\n    if (blen == 0 && slen == 0) {\n        blen = n;\n    }\n    if (n % blen == 0) {\n        string f = s.substr(0, blen);\n        for (int i = 0; i < f.size(); i++) {\n            // blen * k + i >= l\n            // blen * k + i <= r\n            ll at_least = max(0LL, (l - i + blen - 1) / blen);\n            ll at_most = (i > r ? -1 : (r - i) / blen);\n            ans[f[i] - 'a'] += max(0LL, at_most - at_least + 1);\n        }\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n    }\n    else {\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < n; i++) {\n                pref[j][i] = ((s[i] - 'a') == j);\n                if (i) pref[j][i] += pref[j][i - 1];\n            }\n        }\n        string ns = s.substr(0, slen);\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < ns.size(); i++) {\n                prefS[j][i] = ((ns[i] - 'a') == j);\n                if (i) prefS[j][i] += prefS[j][i - 1];\n            }\n        }\n        len[0] = s.size();\n        lenB[0] = blen;\n        lenS[0] = slen;\n        int who = -1;\n        for (int i = 1; i < 100; i++) {\n            if (len[i - 1] - 1 >= r) {\n                who = i - 1;\n                break;\n            }\n            lenS[i] = lenB[i - 1];\n            lenB[i] = len[i - 1];\n            len[i] = lenB[i] + lenS[i];\n        }\n        assert(who != -1);\n        for (int i = 0; i < 26; i++) {\n            ans[i] = calc(r, i, who);\n            if (l) ans[i] -= calc(l - 1, i, who);\n            cout << ans[i] << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    if(pi[T.size() - 1] <= T.size() / 2) {\n        for(int i = 0; i < pi[T.size() - 1]; i++) A.push_back(T[i]);\n        for(int i = pi[T.size() - 1]; i < T.size() - pi[T.size() - 1]; i++) B.push_back(T[i]);\n    }\n    else {\n        for(int i = 0; i < (int)T.size() - pi[T.size() - 1]; i++) A.push_back(T[i]);\n        B = T;\n    }\n\n    //cout << A << ' ' << B << endl;\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nconst int N=200010;\n\ntypedef long long ll;\n\nint n,prd;\nint fail[N];\nchar a[N];\nll l,r,pre[N][30];\n\ninline ll fib(ll p,int c){\n  if(p<=n) return pre[p][c];\n  if(p<=n*2) return pre[n][c]+pre[p-n][c];\n  ll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n  while(p>a+b){\n    ll c=ret1; ret1+=ret2; ret2=c;\n    c=a; a+=b; b=c;\n  }\n  return ret1+fib(p-a,c);\n}\n\ninline ll calc(ll p,int c){\n  if(p<=n) return pre[p][c];\n  if(n%prd==0){\n    ll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n    p-=n; p%=prd;\n    return ret+pre[p][c];  \n  }\n  else return fib(p,c);\n}\n\nint main(){\n  scanf(\"%s\",a+1); n=strlen(a+1)/2;\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    pre[i][a[i]-'a']++;\n  }\n  scanf(\"%lld%lld\",&l,&r);\n  int k=0;\n  for(int i=2;i<=n;i++){\n    while(k&&a[k+1]!=a[i]) k=fail[k];\n    if(a[k+1]==a[i]) k++;\n    fail[i]=k;\n  }\n  prd=n-fail[n];\n  for(int i=0;i<26;i++)\n    printf(\"%lld \",calc(r,i)-calc(l-1,i));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(int _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(int _##i = (t), i = (f); i <  _##i; i++)\n#define downto(f, t, i)  for(int _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(int _##i = (t), i = (f); i >  _##i; i--)\ntypedef long double ld;\n#define long long long\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n    #define debug true\n    #define ln << endl\n#else\n    #define debug false\n    #define ln << '\\n'\n#endif\n#define tb << '\\t'\n#define sp << ' '\n\nconst int MOD = 1e9+7;\n\nnamespace sa {\nconstexpr unsigned sINT = sizeof(int);\n\ninline void induced_sort(const int* const s, int n1, int* const sa, int** const bucref, int** const bucref1,\nconst int* const is_stype, const int* const lcount, int C, const int* lms, int clms) {\n    int n = n1 - 1;\n    memcpy(bucref1, bucref, sizeof(int*) * (C + 1));\n    rtimes(clms, l) {\n        int/*s.i*/j = lms[l];\n        *--bucref1[s[j]+1] = j;\n    }\n\n    memcpy(bucref1, bucref, sizeof(int*) * (C + 1));\n    times(n1, a) if(sa[a] > 0) {\n        int/*s.i*/t = sa[a]-1;\n        if(is_stype[t]) continue;\n        *bucref1[s[t]]++ = t;\n    }\n\n    times(C, c) {\n        int* d = bucref[c] + lcount[c];\n        memset(d, -1, sINT * (bucref[c+1] - d));\n    }\n\n    memcpy(bucref1, bucref + 1, sizeof(int*) * C);\n    rtimes(n1, a) if(sa[a] > 0) {\n        int/*s.i*/t = sa[a]-1;\n        if(!is_stype[t]) continue;\n        *--bucref1[s[t]] = t;\n    }\n    sa[0] = n;\n}\n\n/*                       c[i]      i#           i[a]                a[c]                 a[c]*/\nvoid sa_is(const int* const s, int n1, int* const sa, int** const bucref, int** const bucref1,\n/*          a#[c]            i[l]  l[i](L:0,S\\LMS:-1)                   i[l]*/\nint* const lcount, int* const lms, int* const invlms1, int* const lms_sorted, int C) {\n    int n = n1 - 1;\n    if(debug) { times(n, j) assert(s[j] != 0); assert(s[n] == 0); }\n    switch(n) {\n        case 0: sa[0]=0; return; case 1: sa[0]=1; sa[1]=0; return;\n        case 2: sa[0]=2; if(s[0] < s[1]) { sa[1]=0; sa[2]=1; } else { sa[1]=1; sa[2]=0; } return;\n        case 3: sa[0]=3;\n            int a = s[0]-s[1], b = s[1]-s[2], c = s[2]-s[0];\n            if(a > 0) {\n                if(c > 0)    { sa[1]=1; sa[2]=0; sa[3]=2; return; }\n                if(b < 0)    { sa[1]=1; sa[2]=2; sa[3]=0; return; }\n            } else if(b < 0) { sa[1]=0; sa[2]=1; sa[3]=2; return; }\n            if(a < 0)\n                if(c > 0)    { sa[1]=0; sa[2]=2; sa[3]=1; return; }\n                else         { sa[1]=2; sa[2]=0; sa[3]=1; return; }\n            sa[1]=2; sa[2]=1; sa[3]=0; return;\n    }\n\n    times(n1, j) ++bucref[s[j]+1];\n    bucref[0] = sa;\n    times(C, c) bucref[c+1] += (long)bucref[c] / sINT;\n\n/********* check S-Type or L-Type *********/\n    invlms1[n] = -1;\n    rtimes(n, j) invlms1[j] = s[j] != s[j+1] ? -(s[j] < s[j+1]) : invlms1[j+1];\n    times(n1, j) if(!invlms1[j]) ++lcount[s[j]]; // LType\n\n/********* list up LMS *********/\n    int/*l*/clms = 0;\n    upto(1, n, j) if(!invlms1[j-1] && invlms1[j]) { // j-1: LType, j: SType\n        lms[clms] = j;\n        ++clms;\n        invlms1[j] = clms;\n        ++j; //: LS[?]\n    }\n\n/********* rough induced sort *********/\n    induced_sort(s, n1, sa, bucref, bucref1, invlms1, lcount, C, lms, clms);\n    int lsi = 0;\n    times(n1, a) if(sa[a] >= 0 && invlms1[sa[a]] > 0 /*LMS*/) lms_sorted[lsi++] = sa[a];\n    // assert(lsi == clms);\n\n/********* SA-IS LMS-suffix *********/\n    int lq = 0;\n    int* const/*lms.c[l]*/lms_syms = sa;\n    times(clms, l) {\n        int j = lms_sorted[l], m1 = invlms1[j];\n        if(l > 1) {\n            int i = lms_sorted[l-1];\n            if(lms[m1] - j == lms[invlms1[i]] - i) {\n                int k = lms[m1] - j;\n                ++lq;\n                upto(0, k, h) if(s[j+h] != s[i+h]) { --lq; break; }\n            }\n        }\n        lms_syms[m1-1] = l - lq;\n    }\n    int* const bc = bucref[C];\n    int*/*l[e]*/lms_sa = sa + n1;\n    sa_is(lms_syms, clms, lms_sa, bucref + C, bucref1, lcount + C,\n        lms + clms, invlms1 + n1, lms_sorted + clms, clms - lq);\n    bucref[C] = bc;\n\n/********* strict induced sort *********/\n\n    memset(sa, -1, n1 * sINT); // fill(sa, sa + n1, -1);\n\n    times(clms, e) lms_sa[e] =  lms[lms_sa[e]];\n    /* now lms_sa is: i[e] */\n    induced_sort(s, n1, sa, bucref, bucref1, invlms1, lcount, C, lms_sa, clms);\n}\n\nbool inited = false;\nint *saG, **brG, **br1G, *lcG, *lmsG, *il1G, *lsoG;\nvoid init(int N1, int C) { // memory used: (8.5N+3C+3)*4bytes\n    if(inited) return; inited = true;\n    saG = new int[N1*2]; brG = new int*[C+N1+1]; br1G = new int*[max(N1/2,C)+1];\n    lcG = new int[C+N1+1]; lmsG = new int[N1]; il1G = new int[N1*2]; lsoG = new int[N1];\n}\nvoid is_k(const int* const s, int n1, int c) {\n    bool gs = false;\n    if(n1 * 3 < c) {\n        gs = n1 < 50;\n        if(!gs) {\n            int b = s[n1/3 + 1], a = 0;\n            times(n1, i) a += s[i] == b;\n            gs = a < n1 / a;\n        }\n    }\n    if(debug) assert(inited);\n    if(gs) {\n        times(n1, i) saG[i] = i;\n        sort(saG, saG + n1, [&](int i, int j) {\n            if(i == j) return false;\n            while(s[i] == s[j]) { ++i; ++j; }\n            return s[i] < s[j];\n        });\n    } else {\n        memset(saG, -1, n1*2*sINT); memset(brG, 0, (n1+c+1)*sINT); memset(lcG, 0, (n1+c+1)* sINT);\n        sa_is(s, n1, saG, brG, br1G, lcG, lmsG, il1G, lsoG, c);\n    }\n}\nvoid done() { inited = false; if(debug) cerr << \"WARNING: void sa::done() does nothing.\" << endl; }\n}\n\nint s[200005], N;\nmap<long, array<long, 26>> c;\n\nsigned main() { // long: 64bit\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n\n    string S; cin >> S;\n    N = S.size();\n    long L, R; cin >> L >> R;\n\n    sa::init(N + 1, 27);\n    times(N, i) {\n        s[i] = S[i] - 'a' + 1;\n    }\n    s[N] = 0;\n    sa::is_k(s, N + 1, 27);\n    long p0;\n    times(N+1, i) if(sa::saG[i] == 0) {\n        while(i >= 0 && sa::saG[--i] <= N / 2);\n        if(i >= 0)\n            p0 = sa::saG[i];\n        else\n            p0 = N;\n        break;\n    }\n    if(debug) cout << p0 ln;\n\n    times(26, i) c[0][i] = 0;\n    times(N, j) times(26, i) {\n        c[-j-1][i] = c[-j][i] + (S[j] == 'a' + i);\n    }\n    {\n        long p2 = p0, q2 = N, p1 = p2 + q2 / 2, q1 = p2 * 2;\n        times(26, i) {\n            c[-p1][i] = c[-p2][i] + c[-q2][i] / 2;\n            c[-q1][i] = c[-p2][i] * 2;\n        }\n        while(q1 < R) {\n            long p = p1 + p2, q = q1 + q2;\n            times(26, i) {\n                c[-p][i] = c[-p1][i] + c[-p2][i];\n                c[-q][i] = c[-q1][i] + c[-q2][i];\n            }\n            p2 = p1; p1 = p;\n            q2 = q1; q1 = q;\n        }\n    }\n    if(debug) {\n        for(const auto& x: c) {\n            cout << x.first tb;\n            times(26, i) cout << x.second[i] sp;\n            cout ln;\n        }\n    }\n\n    long l[26], r[26];\n    times(26, i) l[i] = r[i] = 0;\n    if(debug) cout << \"L\\n\";\n    while(L > 0) {\n        auto x = c.lower_bound(-L);\n        L += x->first;\n        times(26, i) l[i] += x->second[i];\n        if(debug) {\n            cout << L tb;\n            times(26, i) cout << l[i] sp;\n            cout ln;\n        }\n    }\n    if(debug) cout << \"R\\n\";\n    ++R;\n    while(R > 0) {\n        auto x = c.lower_bound(-R);\n        R += x->first;\n        times(26, i) r[i] += x->second[i];\n        if(debug) {\n            cout << R tb;\n            times(26, i) cout << r[i] sp;\n            cout ln;\n        }\n    }\n\n    times(26, i) {\n        if(i) cout sp;\n        cout << r[i] - l[i];\n    }\n    cout ln;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define max(x, y) ((x) > (y) ? (x) : (y))\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\nstruct C {\n\tlong long sum[26];\n\tlong long s;\n\tC() {\n\t\tmemset(sum, 0, sizeof sum);\n\t\ts = 0;\n\t}\n} F[1100];\n\nC operator * (C x, long long y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] *= y;\n\tx.s *= y;\n\treturn x;\n}\n\nC operator + (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] += y.sum[i];\n\tx.s += y.s;\n\treturn x;\n}\n\nC operator - (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] -= y.sum[i];\n\tx.s -= y.s;\n\treturn x;\n}\n\nint len;\nint n;\nchar S[210000];\nint ne[210000];\n\nC query(int k, long long l, long long r) {\n\t// printf(\"?? %d %lld %lld\\n\", k, l, r);\n\tif (k <= 1) {\n\t\tif (k == 0) {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, ne[n]);\n\t\t}else {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, n);\n\t\t}\n\t\tC ans;\n\t\tmemset(ans.sum, 0, sizeof ans.sum);\n\t\tans.s = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1, ans.s += 1;\n\t\treturn ans;\n\t}\n\tif (l <= 1 && r >= F[k].s)\n\t\treturn F[k];\n\tif (r <= F[k - 1].s)\n\t\treturn query(k - 1, l, r);\n\telse if (l > F[k - 1].s)\n\t\treturn query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n\telse\n\t\treturn query(k - 1, l, r) + query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n}\n\nint main() {\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\tint p = 0;\n\tne[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (; p && S[p + 1] != S[i]; p = ne[p]);\n\t\tif (S[p + 1] == S[i])\n\t\t\tp ++;\n\t\tne[i] = p;\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r;\n\tif (ne[n] * 2 >= n) {\n\t\tint c = n - ne[n];\n\t\tC pp;\n\t\tfor (int i = 1; i <= c; i++)\n\t\t\tpp.sum[S[i] - 'a'] += 1, pp.s += 1;\n\t\tC ans = pp * (r / c);\n\t\tfor (int i = 1; i <= r % c; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1;\n\t\tl -= 1;\n\t\tans = ans - (pp * (l / c));\n\t\tfor (int i = 1; i <= l % c; i++)\n\t\t\tans.sum[S[i] - 'a'] -= 1;\n\t\tfor (int i = 0; i < 25; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"%lld\\n\", ans.sum[25]);\n\t}else {\n\t\tlen = 1;\n\t\tfor (int i = 1; i <= n - ne[n]; i++)\n\t\t\tF[0].sum[S[i] - 'a'] += 1, F[0].s += 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tF[1].sum[S[i] - 'a'] += 1, F[1].s += 1;\n\t\twhile (F[len].s <= 1000000000000000000LL) {\n\t\t\tF[len + 1] = F[len] + F[len - 1];\n\t\t\tlen += 1;\n\t\t}\n\t\tC ans = query(len, l, r);\n\t\tfor (int i = 0; i < 25; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"%lld\\n\", ans.sum[25]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//15:53-17:33\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nstring s;\nll L,R;\nll hhash[200005];\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll calc(int l,int r){\n\tll ret = hhash[r]-(l?hhash[l-1]:0LL); //cout << ret << endl;\n\treturn (ret%mod+mod)%mod * modpow(modpow(37LL,1LL*l),mod-2) % mod;\n}\nvector<vector<ll> >vec;\nvector<ll>num;\nvector<ll>cnt[200005];\nvector<ll>C(ll idx){\n\tif(idx <= s.size()) return idx<=0?vector<ll>(26,0LL):cnt[idx-1];\n\tint x = upper_bound(num.begin(),num.end(),idx)-num.begin();\n\tx--;\n\tvector<ll>V = C(idx-num[x]);\n\tfor(int i=0;i<26;i++) V[i] += vec[x][i];\n\treturn V;\n}\nint main(){\n\tcin >> s >> L >> R;\n\tll seed = 1;\n\tfor(int i=0;i<s.size();i++){\n\t\thhash[i] += (1+s[i]-'a') * seed % mod;\n\t\tseed *= 37LL; seed %= mod;\n\t\tif(i){\n\t\t\thhash[i] = (hhash[i]+hhash[i-1])%mod;\n\t\t\tcnt[i] = cnt[i-1]; cnt[i][s[i]-'a']++;\n\t\t}\n\t\telse{\n\t\t\tcnt[i].resize(26,0LL); cnt[i][s[i]-'a']++;\n\t\t}\n\t}\n\tint n = s.size(); n /= 2; //cout << n<< endl;\n\tll beg = n,nex = 2*n;\n\tfor(int i=n+1;i<2*n;i++){\n\t    //if(i==22) cout << hhash[2*n-1-i] << \" \" << calc(i,2*n-1) << endl;\n\t\tif(hhash[2*n-1-i] == calc(i,2*n-1)){\n\t\t\tnex = i; break;\n\t\t}\n\t}\n\tvector<ll>hoge(26,0ll);\n\tfor(int i=0;i<beg;i++){\n\t\thoge[s[i]-'a']++;\n\t}\n\tvector<ll>hoge2(26,0ll);\n\tfor(int i=0;i<nex;i++){\n\t\thoge2[s[i]-'a']++;\n\t}\n\tvec.pb(hoge); vec.pb(hoge2);\n\tnum.pb(beg); num.pb(nex); //cout << beg << \" \" << nex << endl;\n\twhile(1){\n\t\tvector<ll>hoge3(26,0LL);\n\t\tll S = 0;\n\t\tfor(int i=0;i<26;i++){\n\t\t\thoge3[i] = vec[vec.size()-1][i]+vec[vec.size()-2][i];\n\t\t\tS += hoge3[i];\n\t\t}\n\t\tif(S > R) break;\n\t\telse{\n\t\t\tvec.pb(hoge3);\n\t\t\tnum.pb(num[num.size()-1]+num[num.size()-2]); //cout << num[num.size()-1] << endl;\n\t\t}\n\t}\n\tvector<ll>B = C(R);\n\tvector<ll>S = C(L-1);\n\tfor(int i=0;i<26;i++) cout << B[i]-S[i] << (i==25?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#define SIZE 200005\n#define BT 1005\n#define ALP 26\n\nusing namespace std;\ntypedef long long int ll;\n\nchar str[SIZE];\nint KMP[SIZE];\nll len[BT];\nll cnt[BT][ALP];\nll ans[ALP];\nll query[ALP];\n\nvoid solve(ll L)//[0,L-1]\n{\n\tint n=strlen(str);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i==0) KMP[i]=-1;\n\t\telse\n\t\t{\n\t\t\tKMP[i]=KMP[i-1];\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(str[KMP[i]+1]==str[i])\n\t\t\t\t{\n\t\t\t\t\tKMP[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(KMP[i]==-1) break;\n\t\t\t\tKMP[i]=KMP[KMP[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint add=KMP[n-1];\n\twhile((add+1)*2>=n) add=KMP[add];\n\tstring T=\"\";\n\tfor(int i=0;i<n-(add+1);i++) T+=str[i];\n\tfor(int i=0;i<T.size();i++)\n\t{\n\t\tif(i==0) KMP[i]=-1;\n\t\telse\n\t\t{\n\t\t\tKMP[i]=KMP[i-1];\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(T[KMP[i]+1]==T[i])\n\t\t\t\t{\n\t\t\t\t\tKMP[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(KMP[i]==-1) break;\n\t\t\t\tKMP[i]=KMP[KMP[i]];\n\t\t\t}\n\t\t}\n\t}\n\tadd=KMP[T.size()-1];\n\twhile((add+1)*2>T.size()) add=KMP[add];\n\tadd++;\n\t//printf(\"%s %d\\n\",T.c_str(),add);\n\tint sz=0;\n\tmemset(cnt,0,sizeof(cnt));\n\tmemset(len,0,sizeof(len));\n\tfor(int i=add;i<T.size()-add;i++)\n\t{\n\t\tlen[sz]++;\n\t\tcnt[sz][T[i]-'a']++;\n\t}\n\tsz++;\n\tfor(int i=0;i<add;i++)\n\t{\n\t\tlen[sz]++;\n\t\tcnt[sz][T[i]-'a']++;\n\t}\n\tsz++;\n\twhile(len[sz-1]<=L)\n\t{\n\t\tlen[sz]=len[sz-1]+len[sz-2];\n\t\tfor(int i=0;i<ALP;i++)\n\t\t{\n\t\t\tcnt[sz][i]=cnt[sz-1][i]+cnt[sz-2][i];\n\t\t}\n\t\t//printf(\"%lld\\n\",len[sz]);\n\t\tsz++;\n\t}\n\tmemset(query,0,sizeof(query));\n\tfor(int i=sz-1;i>=2;i--)\n\t{\n\t\tif(L>=len[i])\n\t\t{\n\t\t\tL-=len[i];\n\t\t\tfor(int j=0;j<ALP;j++) query[j]+=cnt[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<L;i++)\n\t{\n\t\tquery[T[i]-'a']++;\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",&str);\n\tll L,R;\n\tscanf(\"%lld %lld\",&L,&R);\n\tsolve(R);\n\tfor(int i=0;i<ALP;i++) ans[i]=query[i];\n\tsolve(L-1);\n\tfor(int i=0;i<ALP;i++) ans[i]-=query[i];\n\tfor(int i=0;i<ALP;i++)\n\t{\n\t\tif(i!=0) printf(\" \");\n\t\tprintf(\"%lld\",ans[i]);\n\t}puts(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long  LL;\nint n,nxt[200010],k;\nLL l,r,ans[26];\nchar s[200010];\n\nvoid calc(LL m)\n{\n\tif (m<=n)\n\t\t{\n\t\t\tfor (int i=1; i<=m; i++)  ans[s[i]-'a']++;\n\t\t\treturn;\n\t\t}\n\tLL a0=1,b0=0,c0=0,a1=1,b1=1,c1=1,a2,b2,c2;\n\twhile (a1*k+b1*(n-k)<=m)\n\t\t{\n\t\t\ta2=a1+a0,b2=b1+b0,c2=c0;\n\t\t\ta0=a1,b0=b1,c0=c1,a1=a2,b1=b2,c1=c2;\n\t\t}\n\tfor (int i=1; i<=k; i++)  ans[s[i]-'a']+=a0;\n\tfor (int i=k+1; i<=n; i++)  ans[s[i]-'a']+=b0;\n\tcalc(m-a0*k-b0*(n-k));\n}\n\nvoid work()\n{\n\tscanf(\"%s\\n%lld %lld\",s+1,&l,&r),n=strlen(s+1)/2,l--;\n\tnxt[1]=0;\n\tfor (int i=2,j=0; i<=n; i++)\n\t\t{\n\t\t\twhile ((j)&&(s[i]!=s[j+1]))  j=nxt[j];\n\t\t\tif (s[i]==s[j+1])  nxt[i]=++j;  else  nxt[i]=j;\n\t\t}\n\tk=n-nxt[n];\n\tif ((k<=n/2)||(k==n))\n\t\t{\n\t\t\tfor (int i=1; i<=k; i++)  ans[s[i]-'a']+=(r-i)/k-(l-i)/k;\t\t\t\t\n\t\t}else\n\t\t{\n\t\t\tcalc(l);\n\t\t\tfor (int i=0; i<26; i++)  ans[i]*=-1;\n\t\t\tcalc(r);\n\t\t}\n\tfor (int i=0; i<26; i++)  printf(\"%lld \",ans[i]);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 3) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = true;\n\ts = conv(s);\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tvector<int>v = zalgo(s3);\n\tfor (int i = v.size() / 2 + 2; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=4e5+100;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nchar s[N];\nint nxt[N];\nLL ans[26],cnt[1000][26],len[1000];\n//每次会把串SS变成STST，其中T为S的最小周期\n//如果T是S的约数，那么最后的串为STTTTTTTT的形式，可以直接计算\n//如果T不是S的约数，那么串会变成 S T ST STS 这样的斐波那契形式\ninline void solve(int n,int v,LL m) {\n\tint i,t;\n\tif (n%v) {\n\t\tmemset(cnt,0,416);\n\t\tlen[0]=v;\n\t\tfor (i=1;i<=v;i++) cnt[0][s[i]-'a']++;\n\t\tlen[1]=n;\n\t\tfor (i=1;i<=n;i++) cnt[1][s[i]-'a']++;\n\t\tfor (i=2;(len[i]=len[i-1]+len[i-2])<=m;i++)\n\t\t\tfor (t=0;t<26;t++) cnt[i][t]=cnt[i-1][t]+cnt[i-2][t];\n\t\twhile (i--)\n\t\t\tif (m>=len[i])\n\t\t\t\tfor (t=0,m-=len[i];t<26;t++) ans[t]+=cnt[i][t];\n\t\tfor (i=1;i<=m;i++) ans[s[i]-'a']++;\n\t} else {\n\t\tfor (i=1;i<=n&&i<=m;i++)\n\t\t\tans[s[i]-'a']++;\n\t\tif (m<=n) return;\n\t\tm-=n;\n\t\tfor (i=1;i<=v;i++)\n\t\t\tans[s[i]-'a']+=m/v+(m%v>=i);\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1)/2,i,k,v;LL l,r;cin>>l>>r;\n\tfor (i=2,k=0;i<=n;i++) {\n\t\twhile (k&&s[k+1]!=s[i]) k=nxt[k];\n\t\tnxt[i]=k+=s[k+1]==s[i];\n\t}\n\tv=n-nxt[n];\n\tsolve(n,v,l-1);\n\tfor (i=0;i<26;i++) ans[i]*=-1;\n\tsolve(n,v,r);\n\tfor (i=0;i<26;i++)\n\t\tcout<<ans[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nvector<int> z_algorithm(const string& s){\n  int n = s.size();\n  vector<int> z(n, 0);\n  int l = 0;\n  for(int i=1; i<n; i++){\n    if( i+z[i-l] < l+z[l] ){\n      z[i] = z[i-l];\n    }else{\n      int j = max(0, l+z[l]-i);\n      while( i+j < n && s[j] == s[i+j] ) j++;\n      z[i] = j;\n      l = i;\n    }\n  }\n  return z;\n}\n\nvector<long long> sums[26];\n\nmap<tuple<int,long long,long long>, vector<long long>> memo;\n\n// [l,r)\nvector<long long> rec(string& s, vector<long long>& len, long long l, long long r, int d){\n  auto state = make_tuple(d,l,r);\n  if(memo.count(state)){\n    return memo[state];\n  }\n\n  if(d == 0){\n    vector<long long> cnt(26);\n    for(int i=0; i<26; i++){\n      cnt[i] += sums[i][r] - sums[i][l];\n    }\n    return memo[state] = cnt;\n  }\n\n  if( r <= len[d-1] ){\n    return memo[state] = rec(s,len, l, r, d-1);\n  }\n  if( len[d-1] <= l ){\n    return memo[state] = rec(s,len, l-len[d-1], r-len[d-1], max(0,d-2));\n  }\n  auto x = rec(s,len,l,len[d-1], d-1);\n  auto y = rec(s,len,0,r-len[d-1], max(0,d-2));\n  for(int i=0; i<26; i++){\n    x[i] += y[i];\n  }\n  return memo[state] = x;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  long long l,r;\n  cin >> l,r;\n\n  auto z = z_algorithm(s);\n  // eprintln(z);\n  int left = (s.size()+2)/2+1;\n  while(left<s.size() && z[left]<s.size()-left){\n    left++;\n  }\n  s = s.substr(0,left);\n  z = z_algorithm(s);\n  left = 1;\n  while(left<s.size() && z[left]<s.size()-left){\n    left++;\n  }\n  long long border = s.size() - left;\n  long long period = s.size() - border;\n\n  for(int i=0; i<26; i++){\n    sums[i].resize(s.size()+1);\n  }\n  for(int i=0; i<s.size(); i++){\n    sums[ s[i]-'a' ][i+1]++;\n  }\n  for(int i=0; i<26; i++){\n    for(int j=1; j<=s.size(); j++){\n      sums[i][j] += sums[i][j-1];\n    }\n  }\n\n  if( s.size() % period == 0 ){\n    l--;\n    long long x = r/period;\n    long long y = l/period;\n    vector<long long> ans(26);\n    for(int i=0; i<26; i++){\n      ans[i] += sums[i][period] * (x-y);\n      ans[i] += sums[i][r%period];\n      ans[i] -= sums[i][l%period];\n    }\n\n    println(join(ans, \" \"));\n    return 0;\n  }\n\n  vector<long long> len;\n  len.push_back( s.size() );\n\n  while(true){\n    len.push_back( len.back() + period );\n    period = len.back() - period;\n    if(len.back() >= r) break;\n  }\n\n  auto ans = rec(s, len, l-1,r, len.size()-1);\n  println(join(ans, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint nx[200005],n;\nlong long a[200][26],le[200],l,r;\nchar ch[200005];\n\nvoid kmp()\n{\n\tint j=0;\n\tfor(int i=2;i<=n/2;i++)\n\t{\n\t\twhile(j&&ch[j+1]!=ch[i]) \n\t\t\tj=nx[j];\n\t\tif(ch[j+1]==ch[i]) \n\t\t\tj++;\n\t\tnx[i]=j;\n\t}\n}\n\nlong long calc(int c,long long w)\n{\n\tint id=1;\n\tif(le[id]>=w)\n\t{\n\t\tint s=0;\n\t\tfor(int i=1;i<=w;i++)\n\t\t{\n\t\t\tif(ch[i]-'a'==c) \n\t\t\t\ts++;\n\t\t}\n\t\treturn s;\n\t}\n\twhile(w>=le[id])\n\t{\n\t\ta[id+1][c]=a[id][c]+a[id-1][c];\n\t\tle[id+1]=le[id]+le[id-1];\n\t\tid++;\n\t}\n\tlong long s=a[id-1][c];\n\tif(w==le[id-1]) \n\t\treturn s;\n\telse \n\t\treturn s+calc(c,w-le[id-1]);\n}\n\nint main()\n{\n\tscanf(\"%s\",ch+1);\n\tn=strlen(ch+1);\n\tkmp();\n\tcin>>l>>r;\n\tle[0]=n/2-nx[n/2];\n\tle[1]=n/2;\n\tfor(int i=1;i<=n/2;i++)\n\t{\n\t\ta[1][ch[i]-'a']++;\n\t\tif(i<=le[0]) \n\t\t\ta[0][ch[i]-'a']++;\n\t}\n\tfor(int i=0;i<=25;i++) \n\t\tprintf(\"%lld \",calc(i,r)-calc(i,l-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nvector<int> mp(string S){\n\tvector<int> V(S.size()+1,-1);\n\tint j = -1;\n\trepp(i,0,S.size()){\n\t\twhile(j >= 0 && S[i] != S[j]) j = V[j];\n\t\t++j;\n\t\tV[i+1] = j;\n\t}\n\treturn V;\n}\n\nvector<LL> solve(LL z, vector<vector<LL>> &A, string S[2], int p){\n\tvector<LL> V(26,0);\n\tif(z <= 0) return V;\n\tif(z >= A[p][26]){\n\t\trepp(i,0,26) V[i] = A[p][i];\n\t} else if(p > 1){\n\t\tV = solve(z,A,S,p-1);\n\t\tauto W = solve(z-A[p-1][26],A,S,p-2);\n\t\trepp(i,0,26) V[i] += W[i];\n\t} else {\n\t\trepp(i,0,z) ++V[S[p][i]-'a'];\n\t}\n\treturn V;\n}\n\nint main(){\n\tstring S; cin >> S;\n\tLL l,r; cin >> l >> r;\n\tstring T = S.substr(0,S.size()/2);\n\tint x = mp(T)[T.size()];\n\tvector<vector<LL>> A(2,vector<LL>(27,0));\n\tstring U[2];\n\tif(x*2 <= T.size()){\n\t\tU[0] = T.substr(x,T.size()-x*2);\n\t\tU[1] = T.substr(0,x);\n\t} else {\n\t\tU[0] = T.substr(0,x);\n\t\tU[1] = T.substr(0,T.size()-x);\n\t}\n\trepp(k,0,2) repp(i,0,U[k].size()){\n\t\t++A[k][U[k][i]-'a'];\n\t\t++A[k][26];\n\t}\n\tx = 1;\n\twhile(A[x][26] < r){\n\t\tA.push_back(vector<LL>(27));\n\t\trepp(i,0,27) A[x+1][i] = A[x][i] + A[x-1][i];\n\t\t++x;\n\t}\n\tauto B = solve(r,A,U,x);\n\tauto C = solve(l-1,A,U,x);\n\trepp(i,0,26) cout << B[i]-C[i] << (i==25?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 400050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\telse\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],npos+1,len-npos-2);\n\t\t\tla=npos+1;lb=len-la-la;\n\t\t\tsa=0,sb=npos+1;\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define MIN(a,b) (((a)<(b))?(a):(b))\ntypedef long long LL;\nclass ele{\n\tpublic:\n\t\tLL sz,cnt[30];\n\t\tele(){\n\t\t\tsz=0;\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t}\n\t\tele(LL SZ,char *inp){\n\t\t\tint xb;\n\t\t\tsz=SZ;\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tfor(xb=0;xb<sz;xb++) cnt[inp[xb]-'a']++;\n\t\t}\n\t\tinline void print(){\n\t\t\tint xb;\n\t\t//\tprintf(\"Size:%d\\t\",sz);\n\t\t\tfor(xb=0;xb<26;xb++){\n\t\t\t\tprintf(\"%lld \",cnt[xb]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n}firsts[3][200005],res;\nchar inp[200005],nxt[500005],nnxt[1000005];\nint Z[500005],match[500005],ilen,nlen,match2[500005],nnlen,bct[3];\nLL L,R;\nvector < ele > eles;\nele operator +(const ele &a,const ele &b){\n\tele ret=ele();\n\tret.sz=a.sz+b.sz;\n\tint xb;\n\tfor(xb=0;xb<30;xb++) ret.cnt[xb]=a.cnt[xb]+b.cnt[xb];\n\treturn ret;\n}\nele operator -(const ele &a,const ele &b){\n\tele ret=ele();\n\tret.sz=a.sz+b.sz;\n\tint xb;\n\tfor(xb=0;xb<30;xb++) ret.cnt[xb]=a.cnt[xb]-b.cnt[xb];\n\treturn ret;\n}\nvoid zz(char *fa,int *mth){\n\tint k,l,r,x2,cnt=0,sfa=strlen(fa);\n\tl=r=-1;\n\tmemset(mth,0,sizeof(mth));\n\tmatch[0]=1;\n\tmemset(Z,0,sizeof(Z));\n\tfor(k=1;k<sfa;k++){\n\t\tif(k>r || l==-1){\n\t\t\tfor(x2=k;x2<sfa && fa[x2]==fa[x2-k];x2++);\n\t\t\tx2-=k-1;\n\t\t\tif(x2>1){\n\t\t\t\tZ[k]=x2-1;\n\t\t\t}\n\t\t}\n\t\telse if(Z[k-l]<=r-k){\n\t\t\tZ[k]=Z[k-l];\n\t\t}\n\t\telse{\n\t\t\tZ[k]=r-k+1;\n\t\t\tfor(x2=r+1;x2<sfa && fa[x2]==fa[x2-k];x2++);\n\t\t\tZ[k]+=x2-r-1;\n\t\t}\n\t\tif(Z[k]+k-1>r){\n\t\t\tr=Z[k]+k-1;\n\t\t\tl=k;\n\t\t}\n\t\tif(Z[k]<(sfa>>1)) mth[k+Z[k]-1]=MAX(mth[k+Z[k]-1],Z[k]);\n\t}\n}\ninline char *gc(int d){\n\treturn (d?((d==1)?nxt:nnxt):inp);\n}\ninline void cal(char *stt,int d,int len){\n\tint xb,x2;\n\tfor(xb=0;;xb++){\n\t\tint stp=10*xb;\n\t\tif(stp<len){\n\t\t\tele v=ele(10,stt+stp);\n\t\t\tif(xb) v=v+firsts[d][xb-1];\n\t\t\tfirsts[d][xb]=v;\n\t\t}\n\t\telse break;\n\t}\n\tbct[d]=xb;\n}\nele getele(LL rb,int p){\n\tif(rb<0) return ele();\n\tif(rb>=eles[p].sz-1) return eles[p];\n\tif(p<3){\n\t\trb=MIN(rb,eles[p].sz);\n\t\tele ret;\n\t\tif(rb>=10) ret=firsts[p][rb/10-1]; else ret=ele();\n\t\tint xb;\n\t\tfor(xb=(LL)((LL)rb/10LL)*10LL;xb<=rb;xb++) ret.cnt[gc(p)[xb]-'a']++;\n//\t\tprintf(\"Result of getting %d from %d :\",rb,p+1);\n//\t\tret.print();\n\t\treturn ret;\n\t}\n\t\n\tele ret=getele(rb,p-1);\n//\tprintf(\"Fetching position %d of operation %d---first\\n\",rb,p+1);\n//\tprintf(\"\\t\");\n//\tret.print();\n\tif(rb>=eles[p-1].sz) ret=ret+getele(rb-eles[p-1].sz,p-2);\n//\tprintf(\"Fetching position %d of operation %d---final\\n\",rb,p+1);\n//\tprintf(\"\\t\");\n//\tret.print();\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",inp);\n\tscanf(\"%lld %lld\",&L,&R);\n\tL--;\n\tR--;\n\tzz(inp,match);\n\tilen=strlen(inp);\n\tmemcpy(nxt,inp,sizeof(inp));\n\tmemcpy(nxt+ilen,inp+match[ilen-1],sizeof(char)*(ilen-(match[ilen-1]<<1)));\n\tnlen=strlen(nxt);\n\tzz(nxt,match2);\n\tmemcpy(nnxt,nxt,sizeof(nxt));\n\tmemcpy(nnxt+nlen,nxt+match2[nlen-1],sizeof(char)*(nlen-(match2[nlen-1]<<1)));\n\tnnlen=strlen(nnxt);\n\teles.resize(3);\n\tint xb,x2;\n\teles[0]=ele((ilen>>1),inp);\n\teles[1]=ele((nlen>>1),nxt);\n\teles[2]=ele((nnlen>>1),nnxt);\n//\tfor(xb=0;xb<3;xb++) {\n//\t\tprintf(\"Opr %d:\",xb+1);\n//\t\teles[xb].print();\n//\t}\n\twhile(eles.back().sz<=R){\n\t\teles.push_back(eles.back()+eles[eles.size()-2]);\n//\t\tprintf(\"Opr %d:\",eles.size());\n//\t\teles.back().print();\n\t}\n//\tprintf(\"Number of operations %d\\n\",eles.size());\n\tcal(inp,0,ilen);\n\tcal(nxt,1,nlen);\n\tcal(nnxt,2,nnlen);\n\tres=getele(R,eles.size()-1)-getele(L-1,eles.size()-1);\n\tres.print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 200010\n#define ll long long\nusing namespace std;\n\nint n, nxt[N], d, len[2];\nll L, R, ans[26], D[1010][2], s[2], s1[2][26];\nchar S[N];\n\ninline void kmp(){\n\tnxt[0]=nxt[1]=0; int j;\n\tfor(int i=2; i<=n; i++){\n\t\tj=nxt[i-1]; while(j&&S[i]!=S[j+1])j=nxt[j];\n\t\tif(S[i]==S[j+1])j++; nxt[i]=j;\n\t}\n}\n\ninline void solve(ll m, int f){\n\tlen[0]=n; len[1]=d;\n\tmemset(D, 0, sizeof(D)); D[1][0]=1; D[2][1]=1;\n\tif(m<=n+d){\n\t\tfor(int i=1; i<=n; i++)if(i<=m)ans[S[i]-'a']+=f;\n\t\tfor(int i=1; i<=d; i++)if(n+i<=m)ans[S[i]-'a']+=f;\n\t\treturn;\n\t}\n\tmemset(s1, 0, sizeof(s1));\n\tfor(int i=1; i<=n; i++)s1[0][S[i]-'a']++;\n\tfor(int i=1; i<=d; i++)s1[1][S[i]-'a']++;\n\t\n\ts[0]=1; s[1]=0; ll now=n+d; int p;\n\tfor(int i=3; i<=1000; i++){\n\t\tD[i][0]=s[0]; D[i][1]=s[1];\n\t\tnow+=D[i][0]*len[0]+D[i][1]*len[1];\n\t\ts[0]+=D[i-1][0]; s[1]+=D[i-1][1];\n\t\tif(now>=m){\n\t\t\twhile(m>n+d){\n\t\t\t\tfor(int j=1; j<=i; j++)if(m>=D[j][0]*len[0]+D[j][1]*len[1]){\n\t\t\t\t\tfor(int k=0; k<=25; k++)ans[k]+=s1[0][k]*D[j][0]*f;\n\t\t\t\t\tfor(int k=0; k<=25; k++)ans[k]+=s1[1][k]*D[j][1]*f;\n\t\t\t\t\tm-=D[j][0]*len[0]+D[j][1]*len[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1; j<=n; j++)if(j<=m)ans[S[j]-'a']+=f;\n\t\t\tfor(int j=1; j<=d; j++)if(n+j<=m)ans[S[j]-'a']+=f;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%s\", S+1); n=strlen(S+1); n>>=1;\n\tscanf(\"%lld%lld\", &L, &R);\n\tkmp(); d=n-nxt[n];\n\tmemset(ans, 0, sizeof(ans)); solve(R, 1); solve(L-1, -1);\n\tfor(int i=0; i<=24; i++)printf(\"%lld \", ans[i]); printf(\"%lld\", ans[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstring s;\nin pd;\nin n;\nVI ssz;\nVI cnt;\nin aps(char c, in r){\n  if(n%pd==0){\n    in cr=0;\n    forn(i,pd)\n      cr+=(s[i]==c);\n    in to=0;\n    forn(i,r%pd)\n      to+=(s[i]==c);\n    return (r/pd)*cr+to;\n  }\n  ssz.clear();\n  cnt.clear();\n  ssz.PB(pd);\n  ssz.PB(n);\n  in cr=0;\n  forn(i,pd)\n    cr+=(s[i]==c);\n  cnt.PB(cr);\n  for(in i=pd;i<n;++i)\n    cr+=(s[i]==c);\n  cnt.PB(cr);\n  while(ssz.back()<=r){\n    ssz.PB(ssz[sz(ssz)-1]+ssz[sz(ssz)-2]);\n    cnt.PB(cnt[sz(cnt)-1]+cnt[sz(cnt)-2]);\n  }\n  in sm=0;\n  in nxt=sz(ssz)-1;\n  while(nxt>=0){\n    if(r>=ssz[nxt]){\n      sm+=cnt[nxt];\n      r-=ssz[nxt];\n    }\n    --nxt;\n  }\n  forn(i,r)\n    sm+=(s[i]==c);\n  return sm;\n}\nVI genpref(string& p){\n  if(sz(p)==0){\n    return {};\n  }\n  if(sz(p)==1){\n    return {1};\n  }\n  VI mmc;\n  in rms=1;\n  in rsz=0;\n  while(rsz<sz(p)-rms && p[rsz+rms]==p[rsz])\n    ++rsz;\n  mmc.resize(sz(p));\n  mmc[0]=sz(p);\n  mmc[1]=rsz;\n  for(in i=2;i<sz(p);i++){\n    mmc[i]=0;\n    if(i<rms+rsz){\n      mmc[i]=mmc[i-rms];\n      if(mmc[i]+i>=rms+rsz)\n\tmmc[i]=rms+rsz-i;\n    }\n    if(i+mmc[i]>=rms+rsz){\n      rms=i;\n      rsz=mmc[i];\n      while(rsz<sz(p)-rms && p[rsz+rms]==p[rsz])\n\t++rsz;\n      mmc[i]=rsz;\n    }\n  }\n  return mmc;\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>s;\n  s.resize(sz(s)/2);\n  n=sz(s);\n  VI v=genpref(s);\n  pd=n;\n  for(in i=1;i<n;++i){\n    if(v[i]==n-i){\n      pd=i;\n      break;\n    }\n  }\n  in l,r;\n  cin>>l>>r;\n  for(char c='a';c<='z';++c){\n    cout<<aps(c,r)-aps(c,l-1)<<\" \";\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 200054;\nconstexpr long double phi = 0.61803398874989484820458683436564l,\n\thz = 0.49723029647758477079258462177973l, lz = phi;\n\nint n, T;\nint f[N];\nll ans[N];\nchar s[N];\n\nll phi_n(ll n) {\n\tunsigned int hi = n >> 32, lo = n & 0xffffffff;\n\treturn 2654435769ll * hi + floorl(hi * hz + lo * lz);\n}\n\nvoid solve(ll x, int coef) {\n\tint i, u = T, v = n - T;\n\tif (n % T) {\n\t\tll p, Lu = -1, Lv = -1, Cu, Cv, estimate = x / (u * phi + v * (1 - phi));\n\t\tfor (p = std::max<ll>(estimate - 100, 1); ; ++p) {\n\t\t\tCu = phi_n(p), Cv = p - 1 - Cu;\n\t\t\tif (u * Cu + v * Cv > x) break;\n\t\t\tLu = Cu, Lv = Cv;\n\t\t}\n\t\tassert(~Lu && ~Lv);\n\t\tfor (i = 0; i < u; ++i) ans[s[i]] += Lu * coef;\n\t\tfor (i = 0; i < v; ++i) ans[s[i]] += Lv * coef;\n\t\tp = x - (u * Lu + v * Lv);\n\t\tfor (i = 0; i < p; ++i) ans[s[i]] += coef;\n\t} else {\n\t\tlldiv_t info = lldiv(x, T);\n\t\tfor (i = 0; i < T; ++i) ans[s[i]] += info.quot * coef;\n\t\tfor (i = 0; i < info.rem; ++i) ans[s[i]] += coef;\n\t}\n}\n\nint main() {\n\tint i, j = 0; ll l, r;\n\tscanf(\"%s%lld%lld\", s, &l, &r), s[n = strlen(s) / 2] = 0;\n\tfor (j = *f = -1, i = 0; i < n; f[++i] = ++j)\n\t\tfor (; ~j && s[j] != s[i]; j = f[j]);\n\tT = n - f[n];\n\tsolve(r, 1), solve(l - 1, -1);\n\tfor (i = 97; i < 123; ++i) printf(\"%lld%c\", ans[i], i == 122 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2e5 + 10;\nchar s[N];\nint nxt[N],n;\nll l,r,cnt[26],sum[N][26];\nvector<ll> len;\nvector<vector<ll> > S;\n\nvector<ll> solve(ll x){\n    if(x <= n) return vector<ll>(sum[x],sum[x]+26);\n    int p = upper_bound(all(len) , x) - len.begin() - 1;\n    vector<ll> res = S[p] , gt = solve(x - len[p]);\n    rep(i,0,26) res[i] += gt[i];\n    return res;\n}\n\nint main(){\n    scanf(\"%s%lld%lld\",s+1,&l,&r);\n    n=strlen(s+1) / 2;\n    nxt[1]=0;\n    for(int i=2,j=0;i<=n;++i){\n        while(j&&s[j+1]!=s[i]) j=nxt[j];\n        nxt[i]=s[j+1]==s[i]?++j:j;\n    }\n    rep(i,1,n+1) rep(j,0,26) sum[i][j]=sum[i-1][j]+(s[i]-'a'==j);\n    int period = n - nxt[n];\n    if(n % period == 0) {\n        rep(i,1,period+1) {\n            cnt[s[i] - 'a'] += (r + period - i) / period - (l - 1 + period - i) / period;\n        }\n    } else {\n        vector<ll> A(sum[n],sum[n]+26);\n        len.pb(n);S.pb(A);\n        rep(i,0,26) A[i]+=sum[period][i];\n        len.pb(n+period);S.pb(A);\n        while(len[sz(len)-1]<r) {\n            len.pb(len[sz(len)-1]+len[sz(len)-2]);\n            A=*S.rbegin();\n            rep(i,0,26) A[i]+=S[sz(S)-2][i];\n            S.pb(A);\n        }\n        vector<ll> L = solve(l - 1) , R = solve(r);\n        rep(i,0,26) cnt[i] = R[i] - L[i];\n    }\n    rep(i,0,26) printf(\"%lld%c\",cnt[i],\" \\n\"[i==25]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nchar s[400010];\nll n,a[400010],cnt[110][26],fib[110],fail[400010],m,b[400010],ans[26],l,r;\nvoid getb(){\n\tll i,j=0;fail[0]=fail[1]=0;\n\tfor(i=1;i<n;i++){\n//\t\tcout<<\"enter kmp \"<<i<<' '<<j<<' '<<a[i]<<' '<<a[j]<<'\\n';\n\t\twhile(a[i]!=a[j]&&j) j=fail[j];\n\t\tj+=(a[i]==a[j]);fail[i+1]=j;\n\t}\n//\tfor(i=0;i<=n;i++) cout<<i<<' '<<fail[i]<<'\\n';\n\tfor(i=0;i<n-fail[n];i++) b[i]=a[i];\n\tm=n-fail[n];\n}\nvoid solve(ll lim,ll type){\n\tll i,j;\n//\tcout<<\"solve \"<<lim<<' '<<type<<'\\n';\n\tif(lim<=n){\n\t\tfor(i=1;i<=lim;i++) ans[a[i]]+=type;\n\t\treturn;\n\t}\n\tfor(i=1;i<=100;i++){\n\t\tif(fib[i]<=lim) continue;\n\t\tfor(j=0;j<26;j++) ans[j]+=cnt[i-1][j]*type;\n\t\tsolve(lim-fib[i-1],type);break;\n\t}\n}\nvoid add(ll len,ll type){\n\tll i,tot=len/m;\n\tfor(i=1;i<=m;i++) ans[b[i]]+=tot*type;\n\tfor(i=tot*m+1;i<=len;i++) ans[b[i-tot*m]]+=type;\n} \nvoid another(){\n\tadd(l-1,-1);add(r,1);\n}\nint main(){\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%s\",s);n=strlen(s)>>1;ll i,j;\n\tl=read();r=read();\n\tfor(i=0;i<n;i++) a[i]=s[i]-'a';\n\tgetb();\n\tfor(i=n;i>=1;i--) a[i]=a[i-1];\n\tfor(i=m;i>=1;i--) b[i]=b[i-1];\n//\tif(n%m==0){\n//\t\tanother();goto print;\n//\t}\n\tfor(i=1;i<=n;i++) cnt[0][a[i]]+=1,cnt[1][a[i]]+=1;\n\tfor(i=1;i<=m;i++) cnt[1][b[i]]+=1;\n\tfib[0]=n;fib[1]=(n+m);\n\tfor(i=2;i<=100;i++){\n\t\tfib[i]=fib[i-1]+fib[i-2];\n\t\tfor(j=0;j<=25;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n//\tfor(i=0;i<26;i++) cout<<i<<' '<<cnt[0][i]<<' '<<cnt[1][i]<<'\\n';\n\tsolve(l-1,-1);\n\tsolve(r,1);\n\tprint:\n\tfor(i=0;i<26;i++) printf(\"%lld \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 200005;\n\nint n,pre[N];\nint num[26][N];\nint T;\nchar s[N];\nLL l,r;\n\nLL Calc(int c,LL lim) {\n\tif (lim<=n) return num[c][lim];\n\tLL l1=T,l2=n; LL sum1=num[c][T],sum2=num[c][n];\n\twhile (lim>l1+l2) {\n\t\tl1+=l2,sum1+=sum2;\n\t\tswap(l1,l2); swap(sum1,sum2);\n\t}\n\treturn sum2+Calc(c,lim-l2);\n}\n\nint main() {\n\n\t#ifndef ONLINE_JUDGE\n\t//\tfreopen(\"data.in\",\"r\",stdin);\n\t//\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\n\tscanf(\"%s\",s+1); scanf(\"%lld%lld\",&l,&r);\n\tn=strlen(s+1)/2;\n\t\n\tpre[1]=0; int k=0;\n\trep(i,2,n) {\n\t\twhile (k&&s[k+1]!=s[i]) k=pre[k];\n\t\tif (s[k+1]==s[i]) k++;\n\t\tpre[i]=k;\n\t} T=n-pre[n];\n\t\n\trep(i,1,n) {\n\t\trep(j,0,25) num[j][i]=num[j][i-1];\n\t\tnum[s[i]-'a'][i]++;\n\t}\n\t\n\trep(i,0,25) {\n\t\tprintf(\"%lld\",Calc(i,r)-Calc(i,l-1));\n\t\tif (i!=25) putchar(' '); else puts(\"\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\nvgxgpuamkvgxgvgxgpuamkvgxg\n1 1000000000000000000\n\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <cassert>\n\nusing namespace std;\n\nconst int64_t INF = (int64_t) 1e18 + 7;\nvector<int64_t> fib;\n\nint64_t add(int64_t a, int64_t b) { return min(a + b, INF); }\nint64_t mul(int64_t a, int64_t b)\n{\n\tif (!a || !b) return 0;\n\treturn (INF / b >= a) ? a * b : INF;\n}\n\nvector<int> kmp(string S)\n{\n\tint N = (int) S.size();\n\tvector<int> lps(N + 1, 0);\n\tlps[1] = 0;\n\tfor (int i = 2; i <= N; ++i) {\n\t\tfor (lps[i] = lps[i - 1]; lps[i] != 0 && S[i - 1] != S[lps[i]]; lps[i] = lps[lps[i]]);\n\t\tif (S[i - 1] == S[lps[i]]) ++lps[i];\n\t}\n\treturn lps;\t\n}\n\narray<int64_t, 26> solve(string S, int64_t R)\n{\n\tif (R == 0) return {};\n\tint N = (int) S.size() / 2;\n\tS.resize(N);\n\n\tauto lps = kmp(S);\n\n\tint len1 = N - lps[N], len2 = lps[N];\n\tint64_t cnt1 = 0, cnt2 = 0;\n\tfor (int i = (int) fib.size() - 1; i >= 2; --i) {\n\t\t// cout << add(mul(fib[i - 1], len1), mul(fib[i - 2], len2)) << endl;\n\t\tif (add(mul(fib[i - 1], len1), mul(fib[i - 2], len2)) <= R) {\n\t\t\tcnt1 += fib[i - 1], cnt2 += fib[i - 2];\n\t\t\tR -= fib[i - 1] * len1 + fib[i - 2] * len2;\n\t\t}\n\t\t// cout << i << \": \" << R << endl;\n\t}\n\n\tarray<int64_t, 26> ans = {};\n\tfor (int i = 0; i < 26; ++i) ans[i] = 0;\n\tassert(R <= N);\n\t// for (int i = 0; i < N; ++i) cout << (S[i] - 'a'); cout << endl;\n\tfor (int i = 0; i < R; ++i) ++ans[S[i] - 'a'];\n\n\t// cout << cnt1 << ' ' << cnt2 << endl;\n\tfor (int i = 0; i < N - lps[N]; ++i) ans[S[i] - 'a'] += cnt1;\n\tfor (int i = N - lps[N]; i < N; ++i) ans[S[i] - 'a'] += cnt2;\n\treturn ans;\n}\n\nint main()\n{\n\tfib = {0, 1};\n\twhile (fib.back() < INF) fib.push_back(*fib.rbegin() + *next(fib.rbegin()));\n\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring S;\n\tcin >> S;\n\tint64_t L, R;\n\tcin >> L >> R;\n\n\tauto x = solve(S, R), y = solve(S, L - 1);\n\tfor (int i = 0; i < 26; ++i) cout << x[i] - y[i] << ' ';\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar st[500010];\nint go[500010][26],next[500010],w,len;\nlong long work(long long r,int ch)\n{\n\tif (r<=len) return go[r][ch];\n\tlong long n1=go[len/2][ch],n2=go[w][ch],l1=len/2,l2=w;\n\twhile (l1+l2<=r)\n\t{\n\t\tlong long tmp=l1;l1+=l2;l2=tmp;\n\t\ttmp=n1;n1+=n2;n2=tmp;\n\t}\n\treturn n1+work(r-l1,ch);\n}\nint main()\n{\n\tscanf(\"%s\\n\",st+1);len=strlen(st+1);\n\tfor (int i=1;i<=len;i++)\n\t{\n\t\tfor (int j=0;j<26;j++) go[i][j]=go[i-1][j];\n\t\tgo[i][st[i]-'a']++;\n\t}\n\tnext[0]=-1;\n\tfor (int i=1;i<=len;i++)\n\t{\n\t\tint t=next[i-1];\n\t\twhile ((t!=-1)&&(st[t+1]!=st[i])) t=next[t];\n\t\tnext[i]=t+1;\n\t}\n\tw=next[len];\n\twhile (w>=len/2) w=next[w];\n\tw=len/2-w;\n\tlong long l,r;scanf(\"%lld%lld\",&l,&r);\n\tfor (int i=0;i<26;i++) printf(\"%lld \",work(r,i)-work(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0||r<=n){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\nif(l>r||(r-l+1)%m) return -1;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=0;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Z Algorithm\n#include<cstdio>\n#include<cstring>\n#include<valarray>\nusing namespace std;\npair<valarray<long long>,long long> f(long long n,long long l,const valarray<long long> &left,long long r,const valarray<long long> &right)\n{\n\tvalarray<long long> ans(26);\n\tif(l+r<=n)\n\t{\n\t\tauto x=f(n,l+r,left+right,l,left);\n\t\tans+=x.first;\n\t\tn=x.second;\n\t}\n\tif(l<=n)ans+=left,n-=l;\n\treturn make_pair(ans,n);\n}\nchar s[300000];\nlong long cnt[300000][30],z[300000],n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tz[1]=n;\n\tlong long l=1,r=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tif(i>r)\n\t\t{\n\t\t\tz[i]=0;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tif(z[i])l=i,r=i+z[i]-1;\n\t\t}\n\t\telse if(z[i-l+1]<r-i+1)z[i]=z[i-l+1];\n\t\telse\n\t\t{\n\t\t\tz[i]=r-i+1;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tl=i,r=i+z[i]-1;\n\t\t}\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tfor(long long j=0;j<26;j++)cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tlong long k=0;\n\tfor(long long i=n;i>1;i--)\n\t\tif(z[i]+i-1==n)k=z[i];\n\tscanf(\"%lld%lld\",&l,&r);l--;\n\tif(!k)\n\t{\n\t\tfor(long long i=0;i<26;i++)printf(\"%lld \",cnt[n][i]*(r/n)+cnt[r%n][i]-cnt[n][i]*(l/n)-cnt[l%n][i]);\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\tvalarray<long long> left(26),right(26);\n\tfor(long long i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(long long i=0;i<26;i++)printf(\"%lld \",upper.first[i]-lower.first[i]+cnt[upper.second][i]-cnt[lower.second][i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=200005;\n\nstruct node{\n\tll v[26];\n\tnode(bool f=0){if(f)memset(v,0,26<<3);}\n\tll&operator[](char c){return v[c-'a'];}\n\tnode friend operator+(const node&a,const node&b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]+=b.v[i];\n\t\treturn c;\n\t}\n\tnode friend operator-(const node&a,const node&b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]-=b.v[i];\n\t\treturn c;\n\t}\n\tnode friend operator*(const node&a,ll b){\n\t\tnode c=a;\n\t\tfor(int i=0;i<26;i++)c.v[i]*=b;\n\t\treturn c;\n\t}\n\tvoid print(){\n\t\tfor(int i=0;i<26;i++)\n\t\t\tprintf(\"%lld%c\",v[i],\" \\n\"[i==25]);\n\t}\n}ch[N];\n\nchar S[N];\nll l,r,f[66];\nint n,fail[N],m,k;\nnode g[66];\n\nvoid mk(){\n\tg[0]=ch[m];f[0]=m;\n\tg[1]=ch[n];f[1]=n;\n\tfor(k=2;(g[k]=g[k-1]+g[k-2],f[k]=f[k-1]+f[k-2])<=r;k++);\n}\nnode chk1(ll len){\n\tif(len<=n)return ch[len];\n\tnode ret=ch[n];len-=n;\n\tret=ret+ch[m]*(len/m)+ch[len%m];\n\treturn ret;\n}\nnode chk2(ll len){\n\tnode ret(true);\n\tfor(int i=k;i>=1;i--)\n\t\tif(len>=f[i])ret=ret+g[i],len-=f[i];\n\tret=ret+ch[len];len=0;\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1)>>1;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfail[1]=0;ch[1][S[1]]++;\n\tfor(int i=2;i<=n;i++){\n\t\tint p=fail[i-1];\n\t\twhile(p&&S[p+1]!=S[i])p=fail[p];\n\t\tfail[i]=p+1;\n\t\tch[i]=ch[i-1];ch[i][S[i]]++;\n\t}\n\tm=n-fail[n];\n\tif(n%m==0)(chk1(r)-chk1(l-1)).print();\n\telse mk(),(chk2(r)-chk2(l-1)).print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define f(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;i=-(~i))\n#define rf(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;i=~(-i))\nconst int neko=100010;\nint n,m,realans;\ntypedef long long ll;\ntypedef int arr[neko];\narr a,cnt,Cnt;\nll ans,Sum[neko],sum[neko];\nvoid read(int &x)\n{\n\tchar c=getchar();x=0;\n\tfor(;!isdigit(c);c=getchar());\n\tfor(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getchar());\n}\nint main()\n{\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n\tread(n),read(m);\n\tf(i,1,n)read(a[i]);\n\tf(i,1,n-1)\n\t{\n\t\t++Cnt[a[i]],--Cnt[a[i+1]];\n\t\tif(a[i]<a[i+1])Sum[a[i+1]]-=a[i+1]-a[i];\n\t\telse Sum[a[i+1]]-=n-a[i]+a[i+1];\n\t}\n\tf(i,1,m)\n\t{\n\t\tsum[i]=sum[i-1]+cnt[i-1];\n\t\tcnt[i]=cnt[i-1]+Cnt[i];\n\t\tsum[i]+=Sum[i];\n\t}\n\tsum[1]=sum[m]+cnt[m];\n\tans=sum[1],realans=1;\n\tcnt[1]=cnt[m]+Cnt[1];\n\tsum[1]+=Sum[1];\t\n\tf(i,2,m)\n\t{\n\t\tsum[i]=sum[i-1]+cnt[i-1];\n\t\tif(sum[i]-cnt[i-1]>ans)ans=sum[i]-cnt[i-1];\n\t\tcnt[i]=cnt[i-1]+Cnt[i];\n\t\tsum[i]+=Sum[i];\n\t}printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <string>\n#include <functional>\n\nusing lint = long long;\n\ntemplate <class Container>\nstd::vector<int> zalgo(const Container& dat) {\n    int n = dat.size();\n\n    std::vector<int> ret(n);\n    ret[0] = n;\n\n    int i = 1, len = 0;\n    while (i < n) {\n        while (i + len < n && dat[len] == dat[i + len]) {\n            ++len;\n        }\n        ret[i] = len;\n\n        if (len == 0) {\n            ++i;\n            continue;\n        }\n\n        int nlen = 1;\n        while (i + nlen < n && nlen + ret[nlen] < len) {\n            ret[i + nlen] = ret[nlen];\n            ++nlen;\n        }\n\n        i += nlen;\n        len -= nlen;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n\n    auto pcount = [&](int len) -> std::vector<lint> {\n        std::vector<lint> ret(26, 0);\n        for (int i = 0; i < len; ++i) {\n            ++ret[s[i] - 'a'];\n        }\n        return ret;\n    };\n\n    int len = s.length();\n    int slen = len / 2;\n\n    auto zs = zalgo(s);\n    int tlen;\n    for (tlen = slen + 1; tlen < len; ++tlen) {\n        if (zs[tlen] == len - tlen) break;\n    }\n\n    std::function<std::vector<lint>(lint)> count;\n\n    if (tlen == slen * 2) {\n        count = [&](lint len) -> std::vector<lint> {\n            auto ret = pcount(slen);\n\n            for (auto& x : ret) x *= len / slen;\n            len %= slen;\n\n            auto pcnt = pcount(len);\n            for (int i = 0; i < 26; ++i) {\n                ret[i] += pcnt[i];\n            }\n\n            return ret;\n        };\n\n    } else {\n        count = [&](lint len) -> std::vector<lint> {\n            std::vector<std::vector<lint>> cnts{pcount(slen), pcount(tlen)};\n            std::vector<lint> lens{slen, tlen};\n\n            while (lens.back() < len) {\n                int n = lens.size();\n\n                auto cnt1 = cnts[n - 2],\n                     cnt2 = cnts[n - 1];\n\n                std::vector<lint> cnt(26, 0);\n                for (int i = 0; i < 26; ++i) {\n                    cnt[i] = cnt1[i] + cnt2[i];\n                }\n                cnts.push_back(cnt);\n\n                auto len1 = lens[n - 2],\n                     len2 = lens[n - 1];\n                lens.push_back(len1 + len2);\n            }\n\n            std::vector<lint> ret(26, 0);\n\n            int n = lens.size();\n            for (int i = n - 1; i >= 0; --i) {\n                if (len < lens[i]) continue;\n\n                for (int c = 0; c < 26; ++c) {\n                    ret[c] += cnts[i][c];\n                }\n                len -= lens[i];\n            }\n\n            auto pcnt = pcount(len);\n            for (int i = 0; i < 26; ++i) {\n                ret[i] += pcnt[i];\n            }\n\n            return ret;\n        };\n    }\n\n    lint l, r;\n    std::cin >> l >> r;\n\n    auto rs = count(r),\n         ls = count(l - 1);\n\n    for (int i = 0; i < 26; ++i) {\n        std::cout << rs[i] - ls[i] << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename X, typename Y> istream& operator>>(istream& is, pair<X, Y>& p) { return is >> p.first >> p.second; }\n// z[i] is the length of the longest common prefix between s and the suffix of s starting at i\nvector<int> make_z_function(const string& s) {\n    vector<int> z(s.length());\n    z[0] = s.length();\n    for(int i = 1, L = 0, R = 0; i < s.length(); i++) {\n        z[i] = i < R ? min(z[i - L], R - i) : 0;\n        while(i + z[i] < s.length() and s[i + z[i]] == s[z[i]]) {\n            z[i]++;\n        }\n        if(R < i + z[i]) {\n            L = i, R = i + z[i];\n        }\n    }\n    return z;\n}\nmap<char, vector<int>> make_occ(string& S) {\n    map<char, vector<int>> occ;\n    for(char c = 'a'; c <= 'z'; c++) {\n        occ[c] = vector<int>(S.size() + 1);\n        for(int i = 1; i <= S.size(); i++) {\n            occ[c][i] = S[i - 1] == c;\n        }\n        partial_sum(occ[c].begin(), occ[c].end(), occ[c].begin());\n    }\n    return occ;\n}\nvoid solve(std::string S, long long l, long long r) {\n    bool fibo_type = false;\n    string T;\n    auto z = make_z_function(S);\n    for(int i = S.size() / 2 + 1; i < S.size() and not fibo_type; i++) {\n        if(z[i] == S.size() - i) {\n            fibo_type = true;\n            T = S.substr(0, i);\n            T += T;\n        }\n    }\n    auto occ0 = make_occ(S), occ1 = make_occ(T);\n    map<pair<ll, char>, ll> memo;\n    function<ll(ll, char)> C = [&](ll i, char c) -> ll {\n        if(not memo.count({i, c})) {\n            ll& ans = memo[{i, c}];\n            if(fibo_type) {\n                if(i <= S.size()) {\n                    ans = occ0[c][i];\n                } else {\n                    ll f2 = S.size(), f1 = T.size(), c2 = occ0[c][f2], c1 = occ1[c][f1];\n                    while(i > f1) {\n                        ll f = f1 + f2, c = c1 + c2;\n                        f2 = f1, f1 = f, c2 = c1, c1 = c;\n                    }\n                    ll offset = f2 - f1 / 2;\n                    ans = c2 + C(i - f2 + offset, c) - C(offset, c);\n                }\n            } else {\n                ans = i / S.size() * occ0[c][S.size()] + occ0[c][i % S.size()];\n            }\n        }\n        return memo[{i, c}];\n    };\n    for(char c = 'a'; c <= 'z'; c++) {\n        cout << C(r, c) - C(l - 1, c) << \" \\n\"[c == 'z'];\n    }\n}\nint main() {\n    std::string S;\n    std::cin >> S;\n    long long l;\n    scanf(\"%lld\",&l);\n    long long r;\n    scanf(\"%lld\",&r);\n    solve(S, l, r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int N=2e6+7;\nchar s[N];\nint f[N],n,n1,n2,n3;\ni64 l,r;\nvoid ext(){\n\tfor(int i=2,j=0;i<=n;++i){\n\t\twhile(j&&s[i]!=s[j+1])j=f[j];\n\t\tif(s[i]==s[j+1])++j;\n\t\tf[i]=j;\n\t}\n\tint p=f[n];\n\twhile(p*2>=n)p=f[p];\n\tmemcpy(s+n-p+1,s+1,n-p);\n\tn+=n-p*2;\n}\nint t[333],ts[2][333];\ni64 ans[333];\nvoid cal1(i64 x,int sgn){\n\tmemset(t,0,sizeof(t));\n\tfor(int i=1;i<=x%n;++i)++t[s[i]];\n\tfor(int i='a';i<='z';++i)ans[i]+=t[i]*sgn*(x/n+1);\n\tfor(int i=x%n+1;i<=n;++i)++t[s[i]];\n\tfor(int i='a';i<='z';++i)ans[i]+=t[i]*sgn*(x/n);\n}\nvoid cal1(){\n\tn=n2-n1;\n\tcal1(r,1),cal1(l-1,-1);\n}\ni64 fs[207][2],len[207];\nint mx;\nvoid cal2(i64 x,int sgn){\n\tfor(int i=mx;i>=2;--i)if(len[i]<=x){\n\t\tx-=len[i];\n\t\tfor(int j='a';j<='z';++j)ans[j]+=sgn*(fs[i][0]*ts[0][j]+fs[i][1]*ts[1][j]);\n\t}\n\tcal1(x,sgn);\n}\nvoid cal2(){\n\tfor(int i=1;i<=n1;++i)++ts[0][s[i]];\n\tfor(int i=n1+1;i<=n2;++i)++ts[1][s[i]];\n\tlen[0]=n1,len[1]=n2;\n\tfs[0][0]=fs[1][0]=fs[1][1]=1;\n\tmx=1;\n\tdo{\n\t\t++mx;\n\t\tlen[mx]=len[mx-1]+len[mx-2];\n\t\tfs[mx][0]=fs[mx-1][0]+fs[mx-2][0];\n\t\tfs[mx][1]=fs[mx-1][1]+fs[mx-2][1];\n\t}while(len[mx]<r);\n\tcal2(r,1),cal2(l-1,-1);\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1);\n\text();\n\tn1=n;\n\text();\n\tn2=n;\n\text();\n\tn3=n;\n\tif(n2-n1==n3-n2)cal1();\n\telse cal2();\n\tfor(int i='a';i<='z';++i)printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\nconst bool DEBUG = 0;\n/// --- .lumrc Template {{{ ///\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\";\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\";\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n<<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\";\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\";\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\nstring s = ins;\nint n = s.size() / 2;\n\nll ans;\nint k = 0;\nconst int N = 1e5 + 10;\narray<ll, 27> cnt[N];\nconst int MAXS = 1000;\narray<ll, 27> SS[MAXS];\nint SSLength;\n\narray<ll, 27> add(array<ll, 27> a, array<ll, 27> b, bool minus = false) {\n  REP(i, 27) {\n    a[i] += b[i] * (minus ? -1 : 1);\n  }\n  return a;\n}\n\narray<ll, 27> solve(ll x) {\n  array<ll,27> res;\n  if(x <= n) {\n    return cnt[x];\n  }\n  array<ll,27> search;\n  search[0] = x;\n  search[1] = LINF;\n\n  int p = lower_bound(SS, SS + SSLength, search) - SS;\n  p--;\n  assert(p>=0);\n  // dump2(x, SS[p][0]);\n  // dump2(p, SSLength);\n  return add(SS[p], solve(x - SS[p][0]));\n}\n\null upow(ull a, ull b) {\n  ull res = 1;\n  while(b) {\n    if(b&1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  // ローリングハッシュ法で前半k文字と後半k文字で一致する\n  // ような最大のkを求める\n  dump(2);\n  ull backHash = 0;\n  ull forwardHash = 0;\n  REP(i, n-1) {\n    backHash *= 26;\n    backHash += s[i]-'a';\n    forwardHash += upow(26, i) * (s[n-1-i]-'a');\n    if(backHash == forwardHash) k = i + 1;\n  }\n  dump(k);\n  \n  dump(3);\n  ll l=inl, r=inl;\n  dump2(l, s);\n  \n  FOR(i, 1, n+1) {\n    cnt[i] = cnt[i-1];\n    cnt[i][0]++;\n    cnt[i][1+s[i-1]-'a']++;\n  }\n  REP(i, n-k) {\n    SS[0][0]++;\n    SS[0][1+s[i]-'a']++;\n  }\n  FOR(i, n-k, n) {\n    SS[1][0]++;\n    SS[1][1+s[i]-'a']++;\n  }\n  dump(4);\n  SSLength = MAXS;\n  FOR(i, 2, MAXS) {\n    REP(j, i-2+1) {\n      SS[i] = add(SS[i], SS[j]);\n      if(SS[i][0]>LINF) {\n        SSLength = i;\n        break;\n      }\n    }\n    if(SSLength!=MAXS) break;\n  }\n  \n  dump(1);\n  dump(r);\n  auto ans = add(solve(r), solve(l-1), true);\n  \n\n  dump(7);\n  REP(i, 26) {\n    cout << ans[i+1] << (i!=int(ans.size()-1)?\" \":\"\\n\");\n  }\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n}\n\nstring s,t;\nll l,r,S,T;\n\nvl Solve(ll x){\n\tvl a(26);\n\tfor(int i=0;i<min(S,x);i++) a[f(s[i])]++;\n\tif(x>S){\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(x-S)/T;\n\t\tfor(int i=0;i<(x-S)%T;i++) a[f(t[i])]++;\n\t}\n\treturn a;\n}\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<x-S;i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0;\n\tT=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tT=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tt=s.substr(0,T);\n\tif(S%T==0){\n\t\tvl al=Solve(l),ar=Solve(r);\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<ar[i]-al[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c);\n\t\t\tc++;\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[888888],sz,pos,g,cnt[28][222222],p[28][444444],q[28][888888];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[222222];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*bool f=0;\n\tfor (int i=1;i<sz;i++) \n\t{\n\t\tif (z[i]+i==sz) f=1;\n\t}\n\tif (!f) g=sz;*/\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "for (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=2;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) cnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tassert(false);\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[888888],sz,pos,g,cnt[28][222222],p[28][444444],q[28][888888];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[222222];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*bool f=0;\n\tfor (int i=1;i<sz;i++) \n\t{\n\t\tif (z[i]+i==sz) f=1;\n\t}\n\tif (!f) g=sz;*/\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define next DCXISSOHANDSOME\n#define ll long long\n\nll num[100010][26],next[100010],n,l,r,hh;\nchar s[200010];\n\ninline ll rd()\n{\n\tll x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll fib(ll len,ll x)\n{\n\tif (len<=n) return num[len][x];\n\tif (len<=n+hh) return num[n][x]+num[len-n][x];\n\tll f1=num[n][x],f2=num[n][x]+num[hh][x],l1=n,l2=n+hh;\n\twhile (len>=l1+l2)\n\t{\n\t\tll hhh=f2;f2+=f1;f1=hhh;\n\t\thhh=l2;l2+=l1;l1=hhh;\n\t}\n\treturn f2+fib(len-l2,x);\n}\n\ninline ll calc(ll len,ll x)\n{\n\tif (len<=n) return num[len][x];\n\treturn fib(len,x);\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tl=rd();r=rd();\n\tnext[1]=0;\n\tfor (ll i=2;i<=n;i++)\n\t{\n\t\tll j=next[i-1];\n\t\tfor (;j&&s[j+1]!=s[i];j=next[j]);\n\t\tif (s[j+1]==s[i]) j++;\n\t\tnext[i]=j;\n\t}\n\tfor (ll i=1;i<=n;i++)\n\t{\n\t\tfor (ll j=0;j<26;j++) num[i][j]=num[i-1][j];\n\t\tnum[i][s[i]-'a']++;\n\t}\n\thh=n-next[n];\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",calc(r,i)-calc(l-1,i));\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[100][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,100) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\trep(i,1,m) if(g[i][26]>=r) {m=i;break;}\n\t\tdwn(j,m-1,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m-1,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 300000;\n\nint n, kmp[N], T; char s[N];\nll l, r, num[N][30];\n\nll fib(ll len, int c){\n    if(len <= n) return num[len][c];\n    if(len <= n * 2) return num[n][c] + num[len-n][c];\n    ll f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    // 1 : S, 2 : ST;\n    while(len > l1 + l2){\n        ll tmp = f2;\n        f2 += f1; f1 = tmp;\n        tmp = l2;\n        l2 += l1; l1 = tmp;\n        //2 --> 1 + 2; 1 --> 2\n        //exp: STSST --> STSSTSTS; STS --> STSST \n    }\n    return f2 + fib(len - l2, c);\n}\n\nll calc(ll len, int c){ // 计算前 len 位 c 出现的次数\n    if(len <= n) return num[len][c];\n    if(n % T == 0){ // 形如 TTT TTT 的字符串\n        ll ret = 1ll * (len-n) / T * num[T][c] + num[n][c]; // T 出现了(len-n)/T次, n出现了1次\n        len -= n; len %= T;\n        return ret + num[len][c];\n    }\n    return fib(len, c);\n}\n\nint main(){\n    scanf(\"%s%lld%lld\", s+1, &l, &r);\n    n = strlen(s+1) / 2;\n    kmp[0] = kmp[1] = 0; int p = 0;\n    for(int i=2; i<=n; i++){\n        while(p && s[i] != s[p+1]) p = kmp[p];\n        kmp[i] = (s[i] == s[p+1]) ? ++p : p;\n    }\n\n    for(int i=1; i<=n; i++){\n        for(int j=0; j< 26; j++)\n            num[i][j] = num[i-1][j];\n        num[i][s[i] - 'a'] ++;\n    } // num[i][j] : 第i位和之前字符j出现的次数\n    T = n - kmp[n]; // T:最长的等于一个前缀的后缀的起始位置的前一位 \n    //printf(\"%d\\n\", T);\n    for(int i=0; i< 26; i++)\n        printf(\"%lld%c\", calc(r, i) - calc(l-1, i), (i == 25) ? 10 : 32);\n    //printf(\"%d\\n\", calc(5, 1));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nchar s[maxn]; int len;\nint h0[maxn], pw[maxn];\ninline int sub(int l,int r) {\n\treturn (h0[r] + ll(mod - pw[r - l + 1]) * h0[l - 1]) % mod;\n}\nstruct T { ll a[26]; };\ninline T add(T x, T y) {\n\tfor(int i = 0;i < 26;++i) {\n\t\tx.a[i] += y.a[i];\n\t}\n\treturn x;\n}\ninline T sub(T x, T y) {\n\tfor(int i = 0;i < 26;++i) {\n\t\tx.a[i] -= y.a[i];\n\t}\n\treturn x;\n}\ntypedef std::string str;\nT sum[maxn], empty;\nll size[maxn];\nstr b;\nint ok[maxn];\ninline void init(str s0, str s1) {\n\ts1 = s0 + s1;\n\tsize[1] = s0.size(), size[2] = s1.size();\n\tfor(char i : s0) ++ sum[1].a[i - 'a'];\n\tfor(char i : s1) ++ sum[2].a[i - 'a'];\n\tok[1] = ok[2] = 1;\n\tfor(int i = 3;i <= 100;++i) {\n\t\tsize[i] = size[i - 1] + size[i - 2];\n\t\tok[i] = ok[i - 1] && size[i] <= 2e18;\n\t\tsum[i] = add(sum[i - 1], sum[i - 2]);\n\t}\n}\ninline T pre(ll x) {\n\tT ans = empty;\n\tfor(int j = 100;j >= 0;--j) if(ok[j] && x >= size[j]) {\n\t\tans = add(ans, sum[j]);\n\t\tx -= size[j], --j;\n\t}\n\tfor(int j = 1;j <= x;++j) ++ ans.a[s[j] - 'a'];\n\treturn ans;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t*pw = 1;\n\tfor(int i = 1;i < maxn;++i) {\n\t\tpw[i] = pw[i - 1] * 233ll % mod;\n\t}\n\tcin >> s + 1, len = strlen(s + 1) >> 1;\n\tfor(int i = 1;i <= len;++i) {\n\t\th0[i] = (h0[i - 1] * 233ll + s[i]) % mod;\n\t}\n\tint border = len;\n\tfor(int i = 1;i < len;++i) {\n\t\tif(sub(1, i) == sub(len - i + 1, len)) {\n\t\t\tborder = i;\n\t\t}\n\t}\n\tif(border << 1 >= len && len % border == 0) {\n\t\tinit(str(s + 1, s + len + 1), str(s + 1, s + len + 1));\n\t} else if(border > 0) {\n\t\tinit(str(s + 1, s + len + 1), str(s + 1, s + len - border + 1));\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\tT ans = sub(pre(r), pre(l - 1));\n\tfor(int i = 0;i < 26;++i) {\n\t\tcout << ans.a[i] << ' ';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst ll MAX=1000040,MAX2=200;\nchar s[MAX],s1[MAX],s2[MAX];\nll li[MAX],li2[MAX],len,len1,len2,cnt[MAX2][26],fib[MAX2],ans[MAX],l,r;\nvoid build_cnt(ll x,ll lim,ll w){\n    for(int i=0;i<lim;i++){\n        if(x<=fib[i]){\n            if(i==1){\n                for(int j=0;j<x;j++) ans[s2[j]-'a']+=w;\n                return;\n            }\n            if(i==0){\n                for(int j=0;j<x;j++) ans[s1[j]-'a']+=w;\n                return;\n            }\n            for(int j=0;j<26;j++) ans[j]+=cnt[i-1][j]*w;\n            build_cnt(x-fib[i-1],i-1,w);\n            return;\n        }\n    }\n}\nint main(){\n    scanf(\" %s %lld %lld\",s,&l,&r);\n\n    len=strlen(s);\n    for(ll i=1,j=0;i<len;i++){\n        while((s[i]!=s[j]&&j!=0)) j=li[j];\n        if(s[i]==s[j]) li[i+1]=++j;\n    }\n    for(ll i=2,j=0;i<len;i++){\n        while((s[i]!=s[j]&&j!=0)||i+1<=2*(j+1)) j=li[j];\n        if(s[i]==s[j]) li2[i+1]=++j;\n    }\n    for(ll i=0;i<len-li2[len]-li[len-li2[len]];i++) s2[i]=s[i];\n    for(ll i=0;i<li[len-li2[len]];i++) s1[i]=s[i+len-li2[len]-li[len-li2[len]]];\n    len1=strlen(s1),len2=strlen(s2);\n    fib[0]=len1,fib[1]=len2;\n    for(ll i=0;i<len1;i++) cnt[0][s1[i]-'a']++;\n    for(ll i=0;i<len2;i++) cnt[1][s2[i]-'a']++;\n    for(ll i=2;i<MAX2;i++) {\n        fib[i]=fib[i-1]+fib[i-2];\n        for(ll j=0;j<26;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n    }\n    build_cnt(r,MAX2,1);\n    build_cnt(l-1,MAX2,-1);\n    //printf(\"%d\\n\",strlen(s)/2);\n    //printf(\"%s %s\\n\",s1,s2);\n    for(ll i=0;i<26;i++) printf(\"%lld \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=2*1e5+5;\n\nll l,r,L[N],cnt[N][26];\nint n,tot,nxt[N];\nchar st[N];\n\nvoid kmp() {\n\tint k=0;\n\tfo(i,2,n) {\n\t\twhile (k&&st[k+1]!=st[i]) k=nxt[k];\n\t\tnxt[i]=k+=st[k+1]==st[i];\n\t}\n}\n\nll calc(ll n,int c) {\n\tint id=0;\n\tfd(i,tot,1) if (L[i]<=n) {id=i;break;}\n\tif (!id) {\n\t\tll res=0;\n\t\tfo(i,1,n) if (st[i]-'a'==c) res++;\n\t\treturn res;\n\t}\n\treturn cnt[id][c]+calc(n-L[id],c);\n}\n\nint main() {\n\tscanf(\"%s\",st+1);n=strlen(st+1);\n\tn/=2;kmp();\n\tL[0]=n-nxt[n];fo(i,1,n-nxt[n]) cnt[0][st[i]-'a']++;\n\tL[1]=n;fo(i,1,n) cnt[1][st[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor(tot=1;L[tot]<r;) {\n\t\ttot++;\n\t\tL[tot]=L[tot-1]+L[tot-2];\n\t\tfo(j,0,25) cnt[tot][j]=cnt[tot-1][j]+cnt[tot-2][j];\n\t}\n\tfo(c,0,25) printf(\"%lld \",calc(r,c)-calc(l-1,c));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n \nusing namespace std;\n \nconst int N = 2e5 + 10;\n \nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n \nlong long fib(long long len, int c) {\n    long long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    while (len > l1 + l2) {\n        long long t = f2;\n        f2 += f1, f1 = t;\n        t = l2, l2 += l1, l1 = t;\n    }\n    return f2 + fib(len - l2, c);\n}\n \nlong long calc(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (len <= n * 2) return num[n][c] + num[len - n][c];\n    if (n % T == 0) {\n        long long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n        len -= n, len %= T;\n        return re + num[len][c];\n    }\n    else return fib(len, c);\n}\n \nint main() {\n    scanf(\"%s%lld%lld\",s+1,&L,&R);\n    n=strlen(s+1)/2;p[1]=0;\n    for(int j=0,i=2;i<=n;i++) {\n        for(;j&&s[j+1]!=s[i];)j=p[j];\n        if(s[j+1]==s[i])j++;\n        p[i]=j;\n    }\n    for(int i=1;i<=n;i++) {\n        for (int j=0;j<26;j++)num[i][j]=num[i-1][j];\n        num[i][s[i]-'a']++;\n    }T=n-p[n];\n    for(int i=0;i<26;i++)\n\t\tprintf(\"%lld%c\",calc(R,i)-calc(L-1,i),i==25?10:32);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nstring S;\nLL L, R;\nusing V = array<LL, 26>;\n\n// re[i] := S[0..i-1]の接頭辞・接尾辞が最大何文字一致しているか\nvoid mp(const string &S, vector<int> &re){\n  re.resize(S.size()+1); re[0]=-1;\n  int j=-1;\n  rep(i, S.size()){\n    while(j>=0 && S[i]!=S[j]) j=re[j];\n    re[i+1]=++j;\n  }\n}\n\nV Count(string &s) {\n  V ret = {};\n  for (char c : s) {\n    ret[c-'a']++;\n  }\n  return ret;\n}\n\nLL Sum(V &a) {\n  LL ret = 0;\n  rep(i, 26) {\n    ret += a[i];\n  }\n  return ret;\n}\n\nV Solve(LL r) {\n  V ret = {};\n  if (!r) return ret;\n\n  if (S.size()*2 >= r) {\n    string SS = S+S;\n    rep(i, r) {\n      ret[SS[i]-'a']++;\n    }\n    return ret;\n  }\n\n  vector<int> re;\n  mp(S, re);\n  int n = S.size();\n  int w = n - re[n];\n  string P = S.substr(0, w);\n  auto a = Count(P);\n  if (n%w == 0) {\n    rep(i, 26) {\n      ret[i] += a[i] * (r/w);\n    }\n    rep(i, r%w) {\n      ret[P[i]-'a']++;\n    }\n    return ret;\n  }\n  \n  vector<V> series;\n  series.eb(a);\n  series.eb(Count(S));\n  int idx = 1;\n  while (1) {\n    if (Sum(series[idx])*2 >= r) {\n      assert (Sum(series[idx]) < r);\n      {\n        ret = series[idx];\n        r -= Sum(series[idx]);\n      }\n      break;\n    }\n\n    series.eb();\n    rep(i, 26) {\n      series.back()[i] = series[idx-1][i] + series[idx][i];\n    }\n    ++idx;\n  }\n\n  while (idx > 1) {\n    //cout << \"r: \" << r << endl;\n    //cout << idx << \": \";\n    //rep(i, 26) {\n    //  if (i) cout << \" \";\n    //  cout << ret[i];\n    //}cout << endl;\n    assert(Sum(series[idx]) >= r);\n    --idx;\n    if (Sum(series[idx]) <= r) {\n      rep(i, 26) ret[i] += series[idx][i];\n      r -= Sum(series[idx]);\n      --idx;\n    }\n  }\n  if (idx == 1) {\n    assert(r <= S.size());\n    rep(i, r) {\n      ret[P[i]-'a']++;\n    }\n  } else {\n    assert(idx == 0 && Sum(series[idx]) >= r);\n    assert(r <= w);\n    rep(i, r) {\n      ret[P[i]-'a']++;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> S;\n  assert(S.size()%2 == 0);\n  S = S.substr(S.size()/2);\n  cin >> L >> R;\n  auto ans = Solve(R);\n  auto sub = Solve(L-1);\n  rep(i, 26) {\n    if (i) cout << \" \";\n    assert(ans[i] >= sub[i]);\n    cout << ans[i] - sub[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nchar S[MaxN];\nlong long Pred[MaxN][26], L, R, T;\nint Next[MaxN], n;\n\nvoid InitPred()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++) Pred[i][j] = Pred[i - 1][j];\n\t\tPred[i][S[i] - 'a']++;\n\t}\n}\n\nvoid Kmp()\n{\n\tNext[1] = 0;\n\tfor (int j = 0, i = 2; i <= n; i++)\n\t{\n\t\tfor (; j > 0 && S[j + 1] != S[i]; j = Next[j]);\n\t\tif (S[j + 1] == S[i])\n\t\t\tj++;\n\t\tNext[i] = j;\n\t}\n}\n\nvoid SwapOffset(long long &a, long long &b)\n{\n\tlong long tmp = b;\n\tb += a;\n\ta = tmp;\n}\n\nlong long Fib(long long len, int c)\n{\n\tif (len <= n)\n\t\treturn Pred[len][c];\n\tif (len <= n * 2)\n\t\treturn Pred[n][c] + Pred[len - n][c];\n\tlong long f1 = Pred[n][c], f2 = Pred[n][c] + Pred[T][c], l1 = n, l2 = n + T, tmp;\n\twhile (len > l1 + l2)\n\t{\n\t\tSwapOffset(f1, f2);\n\t\tSwapOffset(l1, l2);\n\t}\n\treturn f2 + Fib(len - l2, c);\n}\n\nlong long Calc(long long len, int c)\n{\n\tif (len <= n)\n\t\treturn Pred[len][c];\n\tif (len <= n * 2)\n\t\treturn Pred[n][c] + Pred[len - n][c];\n\tif (n % T == 0)\n\t{\n\t\tlong long res = 1LL * (len - n) / T * Pred[T][c] + Pred[n][c];\n\t\tlen -= n, len %= T;\n\t\treturn res + Pred[len][c];\n\t}\n\telse\n\t\treturn Fib(len, c);\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\", S + 1, &L, &R);\n\tn = strlen(S + 1) / 2;\n\tInitPred();\n\tKmp();\n\tT = n - Next[n];\n\tfor (int i = 0; i < 26; i++)\n\t\tprintf(\"%lld%c\", Calc(R, i) - Calc(L - 1, i), i == 25 ? '\\n' : ' ');\n#ifdef GLOBAL_DEBUG\n\tsystem(\"pause\");\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nvector<int>zalgorithm(string s){\n    vector<int>a(s.size());\n    a[0]=s.size();\n    int i=1,j=0;\n    while(i<s.size()){\n        while(i+j<s.size()&&s[j]==s[i+j])j++;\n        a[i]=j;\n        if(j==0){i++;continue;}\n        int k=1;\n        while(i+k<s.size()&&k+a[k]<j)a[i+k]=a[k],k++;\n        i+=k;j-=k;\n    }\n    return a;\n}\n\nstring S;\nint L;\n\nmap<int,int>calc(int a,int b){\n    if(a+b>=L){\n        map<int,int>ret;\n        ret[L]++;\n        return ret;\n    }\n\n    auto m=calc(a+b,a);\n    map<int,int>ret;\n\n    for(auto p:m){\n        if(p.fi>a+b){\n            ret[a+b]+=p.se;\n            ret[p.fi-a-b]+=p.se;\n        }\n        else{\n            ret[p.fi]+=p.se;\n        }\n    }\n    return ret;\n}\n\nvint solve(){\n    vint z=zalgorithm(S);\n\n    int b=0;\n    for(int i=S.size()-1;i>0;i--){\n        if(z[i]==S.size()-i)b=S.size()-i;\n    }\n\n    int a=S.size()-b;\n\n    auto m=calc(a,b);\n    vint ret(26);\n    for(auto p:m){\n        rep(i,p.fi)ret[S[i]-'a']+=p.se;\n    }\n    return ret;\n}\n\nsigned main(){\n    cin>>S;\n    S=S.substr(0,S.size()/2);\n    int l,r;\n    cin>>l>>r;\n    l--;\n\n    L=r;\n    vint y=solve();\n\n    L=l;\n    vint x=solve();\n    rep(i,26){\n        if(i)cout<<\" \";\n        cout<<y[i]-x[i];\n    }cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200005;\nconst int M=100;\nconst int C=26;\n\nint app[N][C];\nLL cnt[M][C];\nint nxt[N];\nLL len[M];\nchar s[N];\nLL l,r;\nint n,tot;\n\nvoid pre()\n{\n\tlen[0]=n-nxt[n-1],len[1]=n;\n\tfor (int i=2;len[i-1]<=r;++i)\n\t{\n\t\tlen[tot=i]=len[i-1]+len[i-2];\n\t\tfor (int c=0;c<C;++c) cnt[i][c]=cnt[i-1][c]+cnt[i-2][c];\n\t}\n}\n\nLL calc(LL m,int c,int cur)\n{\n\tif (m<=n) return app[m][c];\n\tfor (;len[cur]>m;--cur);\n\treturn cnt[cur][c]+calc(m-len[cur],c,cur-1);\n}\n\nint main()\n{\n\t//freopen(\"ss.in\",\"r\",stdin),freopen(\"ss.out\",\"w\",stdout);\n\tscanf(\"%s\",s),n=strlen(s)>>1,scanf(\"%lld%lld\",&l,&r);\n\tfor (int i=1,ptr=0;i<n;++i)\n\t{\n\t\tfor (;ptr&&s[i]!=s[ptr];ptr=nxt[ptr-1]);\n\t\tnxt[i]=ptr+=s[i]==s[ptr];\n\t}\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int c=0;c<C;++c) app[i][c]=app[i-1][c];\n\t\t++app[i][s[i-1]-'a'];\n\t}\n\tfor (int c=0;c<C;++c) cnt[0][c]=app[n-nxt[n-1]][c],cnt[1][c]=app[n][c];\n\tpre();\n\tfor (int c=0;c<C;++c) printf(\"%lld%c\",calc(r,c,tot)-calc(l-1,c,tot),\"\\n \"[c+1<C]);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\nconst int N=200010;\ntypedef long long ll;\nint n,prd,fail[N],k=0;\nchar a[N];\nll l,r,pre[N][30];\ninline ll fib(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(p<=n*2) return pre[n][c]+pre[p-n][c];\n\tll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n\twhile(p>a+b){\n\t\tll c=ret1; ret1+=ret2; ret2=c;\n\t\tc=a; a+=b; b=c;\n\t}\n\treturn ret1+fib(p-a,c);\n}\ninline ll cal(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(n%prd==0){\n\t\tll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n\t\tp%=prd;\n\t\treturn ret+pre[p][c];  \n\t}\n\telse return fib(p,c);\n}\n \nint main(){\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    \tpre[i][a[i]-'a']++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor(int i=2;i<=n;i++){\n\t\twhile (k&&a[k+1]!=a[i]) k=fail[k];\n\t\tif (a[k+1]==a[i]) k++;\n\t\tfail[i]=k;\n\t}\n\tprd=n-fail[n];\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",cal(r,i)-cal(l-1,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 3) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = false;\n\ts = conv(s);\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 2; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=200010;\nchar s[N];\nint nxt[N];\nLL l,r;\nLL f[100][27];\nLL sum[100],ans[27];\nint mx=87;\n\nvoid getnext()\n{\n\tint n=strlen(s+1)/2,j=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile(j&&s[i]!=s[j+1]) j=nxt[j];\n\t\tif(s[i]==s[j+1]) j++;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid initfib()\n{\n\tfor(int i=2;i<=mx;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t\tif(sum[i]>LL(1e18)){mx=i;break;}\n\t}\n}\n\nvoid gao(LL x,int fg)\n{\n\tint p;\n\tfor(p=0;p<=mx;p++)\n\t\tif(sum[p]>x) break;\n\tfor(;p>=0;p--)\n\t\tif(x>=sum[p])\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t\tans[i]+=fg*f[p][i];\n\t\t\tx-=sum[p];\n\t\t}\n\tfor(int i=1;i<=x;i++) ans[s[i]-'a']+=fg;\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tf[0][s[i]-'a']++;\n\tgetnext();\n\tsum[0]=n;sum[1]=2*(n-nxt[n/2]);\n\tfor(int i=0;i<26;i++) f[1][i]=f[0][i];\n\tfor(int i=nxt[n/2]+1;i<=n-nxt[n/2];i++)\n\t\tf[1][s[i]-'a']++;\n\tinitfib();gao(r,1);gao(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define LL long long\n#define N 200005\nusing namespace std;\nint nx[N],n;\nLL a[200][26],le[200],l,r;\nchar ch[N];\nvoid kmp()\n{\n\tint j=0;\n\tfo(i,2,n/2)\n\t{\n\t\twhile(j&&ch[j+1]!=ch[i]) j=nx[j];\n\t\tif(ch[j+1]==ch[i]) j++;\n\t\tnx[i]=j;\n\t}\n}\nLL calc(int c,LL w)\n{\n\tint id=1;\n\tif(le[id]>=w) \n\t{\n\t\tint s=0;\n\t\tfo(i,1,w)\n\t\t{\n\t\t\tif(ch[i]-'a'==c) s++;\n\t\t}\n\t\treturn s;\n\t}\n\twhile(w>=le[id])\n\t{\n\t\ta[id+1][c]=a[id][c]+a[id-1][c];\n\t\tle[id+1]=le[id]+le[id-1];\n\t\tid++;\n\t}\n\tLL s=a[id-1][c];\n\tif(w==le[id-1]) return s;\n\telse return s+calc(c,w-le[id-1]);\n}\nint main()\n{\n\tscanf(\"%s\",ch+1);\n\tn=strlen(ch+1);\n\tkmp();\n\tcin>>l>>r;\n\tle[0]=n/2-nx[n/2];\n\tle[1]=n/2;\n\tfo(i,1,n/2) \n\t{\n\t\ta[1][ch[i]-'a']++; \n\t\tif(i<=le[0]) a[0][ch[i]-'a']++;\n\t}\n\tfo(i,0,25) printf(\"%lld \",calc(i,r)-calc(i,l-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 300\n\nll l,r;\n\nint z[MAXN];\nvoid getz(char s[]){\n\tms(z);\n\tint n = strlen(s);\n\tint l = 0, r = 0;\n\tfor(int i = 1;i < n;i++){\n\t\tif(i > r){\n\t\t\tl = r = i;\n\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\tr--;\n\t\t\tz[i] = r-l+1;\n\t\t}else{\n\t\t\tint k = i-l;\n\t\t\tif(z[k] < r-i) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tl = i;\n\t\t\t\twhile(r < n  &&  s[r-l] == s[r]) r++;\n\t\t\t\tr--;\n\t\t\t\tz[i] = r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nll j;\nchar s1[MAXN];\nll final[28][2];\nint n;\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\tgetz(s1);\n\tlen[0] = n/4;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << s1[i] << \" \";cout << endl;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << z[i] << \" \";cout << endl;\n\twhile(1){\n\t\tif(z[len[0]]+len[0] >= n/2) break;\n\t\tlen[0]++;\n\t}\n\tlen[1] = n/2;\n\tlen[2] = len[0] + len[1];\n\tlen[0] = 0;\n\t//cout << len[0] << \" =-=-==-==-\" << endl;\n\t//cout << len[1] << \" =-=-==-==-\" << endl;\n\tj = 3;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\tj--;\n\t//cout << j << \" PPPPPPPPPPPPPPPPPPPPPPPPPP\" << endl;\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 0;i < len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 0;i < len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j+2;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 0;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t//freopen(\"ss.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tcin >> s1;\n\tcin >> l >> r;\n\t\n\tn = strlen(s1);\n\tl--;r--;\n\t\n\tms(final);\n\tif(l >= 1) getans(l-1,0);\n\tif(r >= 0)getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string.h>\n#include <stdio.h>\n#define LL long long\n#define all(x) (x).begin(),(x).end()\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define REP(i,n) for (int (i)=0;(i)<(n);(i)++)\n#define vi vector<int>\n#define vpi vector< pii >\n#define INF 2147483647\n#define big 20160116\n#define pb push_back\n#define mp make_pair\nusing namespace std;\nconst int Maxk=1005;\nstring mul(string a,string b){\n\tint res[Maxk];\n\tmemset(res,0,sizeof(res));\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\tfor (int i=0;i<a.length();i++){\n\t\tfor (int j=0;j<b.length();j++){\n\t\t\tres[i+j]+=(a[i]-'0')*(b[j]-'0');\n\t\t}\n\t}\n\tfor (int i=0;i<Maxk;i++){\n\t\tif (res[i]>=10) {\n\t\t\tres[i+1]+=(res[i]/10);\n\t\t\tres[i]%=10;\n\t\t}\n\t}\n\tstring ret;\n\tbool flag=false;\n\tfor (int i=Maxk-1;i>=0;i--){\n\t\tif (flag || res[i]){\n\t\t\tflag=true;\n\t\t\tret=ret+(char)(res[i]+'0');\n\t\t}\n\t}\n\tif (ret==\"\") ret=\"0\";\n\treturn ret;\n}\nstring add(string a,string b){\n\tif (a.length()<b.length()) swap(a,b);\n\twhile (a.length()!=b.length()){\n\t\tb='0'+b;\n\t}\n\tfor (int i=a.length()-1;i>=0;i--){\n\t\ta[i]+=(b[i]-'0');\n\t\tif (a[i]>'9' && i){\n\t\t\ta[i]-=10;\n\t\t\ta[i-1]++;\n\t\t}\n\t}\n\tif (a[0]>'9'){\n\t\ta[0]-=10;\n\t\ta='1'+a;\n\t}\n\treturn a;\n}\n// cf IO: I64d\n// atcoder IO: lld\nconst int Maxn=500005;\nconst long long mod=12384738759123LL;\nconst long long tim=1311;\nchar s[Maxn];\nint n;\nlong long cnt[Maxn][26],ans[26];\nlong long l,r;\nvoid Output(long long x[]){\n\tfor (int i=0;i<26;i++){\n\t\tprintf(\"%lld \",x[i]);\n\t}\n\tprintf(\"\\n\");\n\texit(0);\n}\npair<long long,vector<long long> > go(long long len,vector<long long> lfsum, long long lflen,vector<long long> rgsum,long long rglen){\n\tvector<LL> ret,newlf,newrg;\n\tret.resize(26,0);\n\tnewlf.resize(26,0);\n\tnewrg.resize(26,0);\n\tif (lflen+rglen<=len){\n\t\tfor (int i=0;i<26;i++){\n\t\t\tnewlf[i]=lfsum[i]+rgsum[i];\n\t\t\tnewrg[i]=lfsum[i];\n\t\t}\n\t\tpair<LL,vector<LL> > tmp=go(len,newlf,lflen+rglen,newrg,lflen);\n\t\tfor (int i=0;i<26;i++) ret[i]+=(tmp.second[i]);\n\t\tlen=tmp.first;\n\t}\n\tif (len>=lflen){\n\t\tfor (int i=0;i<26;i++) ret[i]+=lfsum[i];\n\t\tlen-=lflen;\n\t}\n\treturn mp(len,ret); \n}\nvector<long long> solve(long long target,int pre){\n\tvector<LL> lf,rg;\n\tlf.resize(26),rg.resize(26,0);\n\tfor (int i=0;i<26;i++){\n\t\tlf[i]=cnt[n-pre][i];\n\t\trg[i]=cnt[n][i]-cnt[n-pre][i];\n\t}\n\tpair<LL,vector<LL> > res=go(target,lf,(LL)n-pre,rg,(LL)pre);\n\t//cout<<res.first<<endl;\n\tfor (int i=0;i<26;i++){\n\t\t(res.second)[i]+=cnt[res.first][i];\n\t} \n\treturn res.second;\n}\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tn/=2;\n\tscanf(\"%lld %lld\",&l,&r);\n\tlong long hashval1=0,hashval2=0;\n\tlong long now=1;\n\tint len=0;\n\tfor (int i=0;i<n-1;i++){\n\t\thashval1=hashval1*tim;\n\t\thashval1+=(int)s[i];\n\t\thashval2+=now*(int)s[n-i-1];\n\t\thashval1%=mod;\n\t\thashval2%=mod;\n\t\tnow*=tim;\n\t\tnow%=mod;\n\t\tif (hashval1==hashval2){\n\t\t\tlen=i+1;\n\t\t}\n\t}\n\t//cout<<len<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++){\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tl--;\n\tif (len==0){\n\t\tlong long tot=0;\n\t\tfor (int i=0;i<26;i++){\n\t\t\tans[i]+=cnt[n][i]*(r/n);\n\t\t\tans[i]-=cnt[n][i]*(l/n);\n\t\t\tans[i]+=cnt[r%n][i];\n\t\t\tans[i]-=cnt[l%n][i];\n\t\t\ttot+=ans[i];\n\t\t}\n\t\t//cout<<tot<<endl;\n\t\tOutput(ans);\n\t\treturn 0;\n\t}\n\tvector<LL> ans1=solve(r,len);\n\tvector<LL> ans2=solve(l,len);\n\tfor (int i=0;i<26;i++){\n\t\tans1[i]-=ans2[i];\n\t\tprintf(\"%lld \",ans1[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\trd = l / z;\n\t\t\trr = l % z;\n\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\trep(i, rr)ans[s[i] - 'a']--;\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint n;\nchar s[200001];\nint z[200001];\nlong long ans[26];\n\nvoid calc(long long c, long long g, long long f) {\n    int i;\n    \n    for (i = 0; i < g; i++) ans[s[i] - 'a'] += c / g * f;\n    for (i = 0; i < c % g; i++) ans[s[i] - 'a'] += f;\n}\n\nvoid calc2(long long c, long long x, long long y, int f) {\n    int i;\n    vector <long long> v;\n    map <long long, long long> mp;\n    map <long long, long long>::reverse_iterator it;\n    \n    v.push_back(x);\n    v.push_back(y);\n    \n    while (v.back() < c) {\n        v.push_back(v[v.size() - 1] + v[v.size() - 2]);\n    }\n    \n    mp[c] += f;\n    \n    for (it = mp.rbegin(); it != mp.rend(); it++) {\n        long long x = it->first;\n        \n        for (i = 0; ; i++) {\n            if (v[i] >= x) break;\n        }\n        \n        if (v[i] <= n) {\n            calc(x, v[i], it->second);\n        } else {\n            mp[v[i - 1]] += it->second;\n            mp[x - v[i - 1]] += it->second;\n        }\n    }\n}\n\nint main() {\n    int x, y, i, j, k;\n    long long l, r;\n    \n    scanf(\"%s\", s);\n    scanf(\"%lld %lld\", &l, &r);\n    \n    n = strlen(s);\n    \n    i = 1, j = 0;\n    z[0] = n;\n    \n    while (i < n) {\n        while (i + j < n && s[j] == s[i + j]) j++;\n        \n        z[i] = j;\n        \n        if (j == 0) {\n            i++;\n            \n            continue;\n        }\n        \n        k = 1;\n        \n        while (i + k < n && k + z[k] < j) {\n            z[i + k] = z[k];\n            k++;\n        }\n        \n        i += k;\n        j -= k;\n    }\n    \n    x = n / 2;\n    y = n;\n    \n    for (i = n - 1; i > n / 2; i--) {\n        if (i + z[i] == n) y = i;\n    }\n    \n    calc2(r, x, y, 1);\n    calc2(l - 1, x, y, -1);\n    \n    for (i = 0; i < 26; i++) {\n        if (i > 0) putchar(' ');\n        \n        printf(\"%lld\", ans[i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename X, typename Y> istream& operator>>(istream& is, pair<X, Y>& p) { return is >> p.first >> p.second; }\n// z[i] is the length of the longest common prefix between s and the suffix of s starting at i\nvector<int> make_z_function(const string& s) {\n    vector<int> z(s.length() + 1);\n    z[0] = s.length();\n    for(int i = 1, L = 0, R = 0; i < s.length(); i++) {\n        z[i] = i < R ? min(z[i - L], R - i) : 0;\n        while(i + z[i] < s.length() and s[i + z[i]] == s[z[i]]) {\n            z[i]++;\n        }\n        if(R < i + z[i]) {\n            L = i, R = i + z[i];\n        }\n    }\n    return z;\n}\nmap<char, vector<int>> make_occ(const string& S) {\n    map<char, vector<int>> occ;\n    for(char c = 'a'; c <= 'z'; c++) {\n        occ[c] = vector<int>(S.size() + 1);\n        for(int i = 1; i <= S.size(); i++) {\n            occ[c][i] = S[i - 1] == c;\n        }\n        partial_sum(occ[c].begin(), occ[c].end(), occ[c].begin());\n    }\n    return occ;\n}\nvoid solve(std::string S, long long l, long long r) {\n    S = S.substr(0, S.size() / 2);\n    auto z = make_z_function(S);\n    string T;\n    for(int i = 1; i <= S.size() and T.size() == 0; i++) {\n        if(z[i] == S.size() - i) {\n            T = S.substr(0, i);\n        }\n    }\n    auto occ0 = make_occ(S), occ1 = make_occ(S + T);\n    if(S.size() % T.size() == 0) {\n        auto C = [&](ll i, char c) {\n            return i / S.size() * occ0[c][S.size()] + occ0[c][i % S.size()];\n        };\n        for(char c = 'a'; c <= 'z'; c++) {\n            cout << C(r, c) - C(l - 1, c) << \" \\n\"[c == 'z'];\n        }\n    } else {\n        vector<ll> len = {ll(S.size()), ll(S.size() + T.size())};\n        while(len.back() < r) {\n            len.push_back(len[len.size() - 1] + len[len.size() - 2]);\n        }\n        map<tuple<int, ll, char>, ll> memo;\n        function<ll(int, ll, char)> C = [&](int level, ll i, char c) -> ll {\n            auto p = make_tuple(level, i, c);\n            if(not memo.count(p)) {\n                ll& ans = memo[p];\n                if(level == 0) {\n                    ans = occ0[c][i];\n                } else if(level == 1) {\n                    ans = occ1[c][i];\n                } else if(i > len[level - 1]) {\n                    ans = C(level - 1, len[level - 1], c) + C(level - 2, i - len[level - 1], c);\n                } else {\n                    ans = C(level - 1, i, c);\n                }\n            }\n            return memo[p];\n        };\n        for(char c = 'a'; c <= 'z'; c++) {\n            cout << C(len.size() - 1, r, c) - C(len.size() - 1, l - 1, c) << \" \\n\"[c == 'z'];\n        }\n    }\n}\nint main() {\n    std::string S;\n    std::cin >> S;\n    long long l;\n    scanf(\"%lld\",&l);\n    long long r;\n    scanf(\"%lld\",&r);\n    solve(S, l, r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double LF;\ntypedef complex<LF> cd;\n\n#define clr(x, y) memset(x, y, sizeof(x))\n#define INF 0x7fffffff\n\nconst int MAXN = 2e5 + 15;\n\nchar ch[MAXN];\nint n, nxt[MAXN], T;\nLL l, r, f[MAXN][35];\n\ninline int read(){\n\tint r = 0, z = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9'){if(ch == '-') z = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){r = r * 10 + ch - '0'; ch = getchar();}\n\treturn r * z;\n}\n\nLL ff(LL len, int c){\n\tif(len <= n) return f[len][c];\n\tif(len <= n * 2) return f[n][c] + f[len - n][c];\n\tLL f1 = f[n][c], f2 = f[n][c] + f[T][c], l1 = n, l2 = n + T;\n\twhile(len > l1 + l2){\n\t\tLL t = f2;\n\t\tf2 += f1; f1 = t;\n\t\tt = l2; l2 += l1; l1 = t;\n\t}\n\treturn f2 + ff(len - l2, c);\n}\n\nLL calc(LL len, int c){\n\tif(len <= n) return f[len][c];\n\tif(len <= n * 2) return f[n][c] + f[len - n][c];\n\tif(n % T == 0){\n\t\tLL tmp = (len - 1ll * n) / T * f[T][c] + f[n][c];\n\t\tlen -= n; len %= T;\n\t\treturn tmp + f[len][c];\n\t}\n\treturn ff(len, c);\n}\n\nvoid work(){\n\tscanf(\"%s %lld %lld\", ch + 1, &l, &r); n = strlen(ch + 1) / 2;\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = 0; j < 26; j ++) f[i][j] = f[i - 1][j];\n\t\tf[i][ch[i] - 'a'] ++;\n\t} nxt[1] = 0;\n\tfor(int i = 2, j = 0; i <= n; i ++){\n\t\tfor(; j && ch[j + 1] != ch[i];) j = nxt[j];\n\t\tif(ch[j + 1] == ch[i]) j ++;\n\t\tnxt[i] = j;\n\t}\n\tT = n - nxt[n];\n\tfor(int i = 0; i < 26; i ++) printf(\"%lld \", calc(r, i) - calc(l - 1, i));\n}\n\nint main(){\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\tint i,j;\n\tfor(i=99;i>=2;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tassert(V<S[2].size());\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t\tassert(0);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) cnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tif(s % t == 0){\n\t\tfor(int i=0; i<s && i < p; i++){\n\t\t\tdap[str[i] - 'a']++;\n\t\t}\n\t\tp = max(p - s, 0ll);\n\t\tfor(int i=0; i<t; i++){\n\t\t\tdap[str[s + i] - 'a'] += p / t;\n\t\t\tif(p % t > i) dap[str[s + i] - 'a']++;\n\t\t}\n\t}\n\telse{\n\t\tdp[0] = s;\n\t\tdp[1] = t;\n\t\tvector<int> v;\n\t\tfor(int i=0; i<s; i++){\n\t\t\tcnt[0][str[i] - 'a']++;\n\t\t}\n\t\tfor(int i=0; i<t; i++){\n\t\t\tcnt[1][str[i + s] - 'a']++;\n\t\t}\n\t\tfor(int i=2; i<100; i++){\n\t\t\tfor(int j=0; j<26; j++){\n\t\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t\t}\n\t\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\t\tif(dp[i] >= p){\n\t\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\t\tif(p >= dp[j]){\n\t\t\t\t\t\tp -= dp[j];\n\t\t\t\t\t\tv.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<p; i++){\n\t\t\tdap[str[i] - 'a']++;\n\t\t}\n\t\tfor(auto &i : v){\n\t\t\tfor(int j=0; j<26; j++){\n\t\t\t\tdap[j] += cnt[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = fail[n / 2];\n\tint t = n / 2 - s;\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t{\n\t\t\tassert(lim<=la);\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++,assert(s[i]>='a' && s[i]<='z');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(lim<=lb);\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++,assert(s[i]>='a' && s[i]<='z');\n\t\t}\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=len-(npos+1)*2;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    A = T;\n    for(int i = 0; i < T.size() - pi[T.size() - 1]; i++) A.push_back(T[i]);\n    B = A;\n    for(int i = 0; i < T.size(); i++) B.push_back(T[i]);\n\n    //cout << pi[T.size() - 1] << ' ' << T.size() << endl;\n\n    //cout << A << ' ' << B << endl;\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define up(i,j,n)\tfor(int i=j;i<=n;i++)\n#define down(i,j,n)\tfor(int i=j;i>=n;i--)\n#define cmax(a,b)\ta=max(a,b)\n#define cmin(a,b)\ta=min(a,b)\n\nconst ll MAXN=2e5+5;\nconst ll oo=2e18+5;\nconst ll LIM=100;\n\nll N,l,r,nxt[MAXN],f[105][26],g[105];\nchar s[MAXN];\n\nnamespace solution{\n\tll calc(ll p,ll c){\n\t\tll sum=0;\n\t\tdown(i,LIM,1)if(p>=g[i]){\n\t\t\tsum+=f[i][c];\n\t\t\tp-=g[i];\n\t\t}\n\t\tup(i,1,p)sum+=((s[i]-'a')==c);\n\t\treturn sum;\n\t}\n\tvoid Prepare(){\n\t\tscanf(\"%s\",s+1);\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\tN=strlen(s+1);\n\t\tN>>=1;\n\t\tll p=0;\n\t\tup(i,2,N){\n\t\t\twhile(p&&s[p+1]!=s[i])p=nxt[p];\n\t\t\tif(s[p+1]==s[i])p++;\n\t\t\tnxt[i]=p;\n\t\t}\n\t\tup(i,1,N)f[1][s[i]-'a']++;\n\t\tmemcpy(f[2],f[1],sizeof(f[1]));\n\t\tup(i,nxt[N]+1,N)f[2][s[i]-'a']++;\n\t\tg[1]=N;\n\t\tg[2]=N+N-nxt[N];\n\t\tup(i,3,LIM){\n\t\t\tg[i]=g[i-1]+g[i-2];\n\t\t\tcmin(g[i],oo);\n\t\t\tup(j,0,25){\n\t\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\t\t\tcmin(f[i][j],oo);\n\t\t\t}\n\t\t}\n\t}\n\tvoid Solve(){\n\t\tup(i,0,25)printf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t\tputs(\"\");\n\t}\n}\n\nint main(){\n//\tfreopen(\"input.in\",\"r\",stdin);\n\tusing namespace solution;\n\tPrepare();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\telse\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=npos+1;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll cnt[27];\nstring t;\nstring s; \n\nconst int MOD = 1e9 + 7;\nll S[500011];\nll powr[500011];\nll ipowr[500011];\nconst int C = 2017;\n\nll add(ll a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll modpow(ll a, ll b)\n{\n\tll r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nll hsh(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return S[r];\n\treturn mult(ipowr[l],add(S[r],MOD-S[l-1]));\n}\n\nll dp[111][27];\nll leng[111];\nconst ll INF=ll(2e18);\n\nvoid solve(ll len, int idx, int v)\n{\t\n\tif(len==0) return ;\n\tif(idx==0)\n\t{\n\t\tfor(int i=0;i<len;i++)\n\t\t{\n\t\t\tcnt[s[i]-'a']+=v;\n\t\t}\n\t\treturn ;\n\t}\n\tif(idx==1)\n\t{\n\t\tfor(int i=0;i<len;i++)\n\t\t{\n\t\t\tcnt[t[i]-'a']+=v;\n\t\t}\n\t\treturn ;\n\t}\n\tif(len<=leng[idx-1])\n\t{\n\t\tsolve(len,idx-1,v);\n\t\treturn ;\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tcnt[i]+=ll(v)*dp[idx-1][i];\n\t}\n\tsolve(len-leng[idx-1],idx-2,v);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>s;\n\ts=s.substr(0,s.length()/2);\n\tint n=s.length();\n\tll l,r; cin>>l>>r;\n\tpowr[0]=1; ipowr[0]=1;\n\tll iC = modpow(C,MOD-2);\n\tfor(int i=1;i<=500000;i++)\n\t{\n\t\tpowr[i]=mult(powr[i-1],C);\n\t\tipowr[i]=mult(ipowr[i-1],iC);\n\t}\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tS[i] = mult((s[i]-'a'+1),powr[i]);\n\t\tif(i>0) S[i]=add(S[i-1],S[i]);\n\t}\n\tint minper = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool pos=1;\n\t\tfor(int j=0;j<n;j+=i)\n\t\t{\n\t\t\tint lm=j; int rm=min(j+i-1,n-1);\n\t\t\tint ren = rm - j;\n\t\t\tif(hsh(0,ren)!=hsh(lm,rm))\n\t\t\t{\n\t\t\t\tpos=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pos)\n\t\t{\n\t\t\tminper=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tt=s+s.substr(0,minper);\n\tleng[0]=s.length(); leng[1]=t.length();\n\tfor(int i=0;i<s.length();i++) dp[0][s[i]-'a']++;\n\tfor(int i=0;i<t.length();i++) dp[1][t[i]-'a']++;\n\tfor(int i=2;i<=100;i++)\n\t{\n\t\tleng[i]=leng[i-1]+leng[i-2];\n\t\tif(leng[i]>=INF) leng[i]=INF;\n\t\tfor(int j=0;j<26;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i-2][j];\n\t\t\tif(dp[i][j]>=INF) dp[i][j]=INF;\n\t\t}\n\t}\n\tsolve(r,100,1);\n\tsolve(l-1,100,-1);\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tcout<<cnt[i];\n\t\tif(i+1<26) cout<<' ';\n\t}\n\tcout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ll MAX = 2e18;\nconst ld inf = 2e18;\nconst int N = 3e6 + 10;\nconst int maxn = 200020;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint len,s[maxn],fail[maxn];\nint trans[maxn][10];\nvoid getfail(){\n\tfail[1] = 0;\n\tint p = 0;\n\trep(i,2,len){\n\t\twhile ( p && s[i] != s[p + 1] ) p = fail[p];\n\t\tif ( s[i] == s[p + 1] ) fail[i] = ++p;\n\t\telse fail[i] = 0;\n\t}\n}\nstruct node{\n\tll len,cnt[50];\n\tnode() { len = 0 , memset(cnt,0,sizeof(cnt)); }\n\tnode operator + (node a){\n\t\tnode cur;\n\t\trep(i,0,25) cur.cnt[i] = a.cnt[i] + cnt[i];\n\t\tcur.len = len + a.len;\n\t\tif ( cur.len > MAX ) cur.len = MAX;\n\t\treturn cur;\n\t}\n}g[100];\nchar ch[maxn];\nll l,r;\n\nvoid init(){\n\tlen /= 2;\n\trep(i,1,len) s[i] = ch[i] - 'a';\n\tgetfail();\n\tg[0].len = len;\n\trep(i,1,len) g[0].cnt[s[i]]++;\n\tg[1] = g[0];\n\tg[1].len += len - fail[len];\n\trep(i,1,len - fail[len]) g[1].cnt[s[i]]++;\n\trep(i,2,100){\n\t\tg[i] = g[i - 1] + g[i - 2];\t\n\t}\n}\nnode calc(ll n){\n\tnode res;\n\tif ( !n ) return res;\n\trepd(i,100,0){\n\t\tif ( n >= g[i].len ) res = res + g[i] , n -= g[i].len; //发现这个地方特别好写，因为g[n] = g[n- 1] + g[n - 2],无论n是否大于当前长度，都考虑第n-1项\n\t}\n\trep(i,1,n) res.cnt[s[i]]++;\n\treturn res;\n}\nint main(){\n\tscanf(\"%s\",ch + 1);\n\tcin>>l>>r;\n\tlen = strlen(ch + 1);\n\tinit();\n\tnode ans1 = calc(r),ans2 = calc(l - 1);\n\trep(i,0,25) cout<<ans1.cnt[i] - ans2.cnt[i]<<\" \";\n\tcout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\ntypedef unsigned long long ull;\nchar s[800111];\null hs[800111],bs,pw[800111];\nint n;\nvoid iniths()\n{\n\tfor(int i=1;i<=n;i++)hs[i]=hs[i-1]*bs+s[i];\n}\null calchs(int l,int r)\n{\n\treturn ((hs[r]-1ll*hs[l-1]*pw[r-l+1])%mod+mod)%mod;\n}\nll l,r;\nvoid nxtstr()\n{\n\tiniths();\n\tint len=0;\n\tfor(int i=n/2-1;i>=1;i--)\n\t{\n\t\tif(calchs(1,i)==calchs(n-i+1,n))\n\t\t{\n\t\t\tlen=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint nn=n-len;\n\tn=nn+nn;\n\tfor(int i=1;i<=nn+nn;i++)s[i]=s[(i-1)%nn+1];\n}\nll ans[26];\nint pre[800111][26];\nll dp[200],dpcnt[200][26];\nbool type;\nvoid calc(int lv,ll x,int coef)\n{\n\tif(type)\n\t{\n//\t\tcout<<\"calc:\"<<lv<<\" \"<<x<<endl;\n\t\tif(lv<=1)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[x][i];\n\t\t\treturn;\n\t\t}\n\t\tll t=dp[lv]/2;\n\t\tif(x<=t)calc(lv-1,x,coef);\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*(dpcnt[lv][i]/2);\n\t\t\tcalc(lv-1,x-t,coef);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(x<=n)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[x][i];\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=1ll*coef*pre[n][i]*(x/n);\n\t\t\tcalc(lv,x%n,coef);\n\t\t}\n\t}\n}\nint main()\n{\n\tsrand(time(NULL));\n\tbs=rand()+1000;\n\tpw[0]=1;\n\tfor(int i=1;i<=800011;i++)pw[i]=pw[i-1]*bs;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tint n1=n;\n\tnxtstr();\n\tint n2=n;\n\tnxtstr();\n\tint n3=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t{\n\t\t\tpre[i][j]=pre[i-1][j]+(s[i]=='a'+j);\n\t\t}\n\t}\n\tif(n3-n2==n2-n1)type=0;\n\telse type=1;\n//\tcout<<n<<endl;\n//\tfor(int i=1;i<=n;i++)cout<<s[i];cout<<endl;\n\tdp[0]=n1;\n\tdp[1]=n2;\n\tdp[2]=n3;\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tdpcnt[0][i]=pre[n1][i];\n\t\tdpcnt[1][i]=pre[n2][i];\n\t\tdpcnt[2][i]=pre[n3][i];\n\t}\n\tint mx=0;\n\tif(type)\n\t{\n\t\tfor(int i=3;i<200;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+dp[i-2];\n//\t\t\tcout<<i<<\" \"<<dp[i]<<endl;\n\t\t\tmemset(ans,0,sizeof(ans));\n\t\t\tcalc(i-1,dp[i]/2,2);\n\t\t\tfor(int j=0;j<26;j++)dpcnt[i][j]=ans[j];\n//\t\t\tcout<<ans[j]<<\" \";cout<<endl;\n\t\t\tif(dp[i]>1ll*mod*mod)\n\t\t\t{\n\t\t\t\tmx=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(mx!=0);\n\t}\n\tmemset(ans,0,sizeof(ans));\n\tgetii(l,r);\n\tcalc(mx,r,1);\n\tcalc(mx,l-1,-1);\n\tfor(int i=0;i<26;i++)cout<<ans[i]<<\" \";cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nll rui[500000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t)\n{\n\tif (len[2] - len[1] == len[1] - len[0])\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\ts = conv(s);\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf), v2 = get(lf - 1);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n \nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (len <= n * 2) return num[n][c] + num[T - n][c];\n\tlong long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n\twhile (len > l1 + l2) {\n\t\tlong long t = f2;\n\t\tf2 += f1, f1 = t;\n\t\tt = l2, l2 += l1, l1 = t;\n\t}\n\treturn f2 + fib(len - l2, c);\t\n}\n\nlong long calc(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (len % T == 0) {\n\t\tlong long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n\t\tlen -= n, len %= T;\n\t\treturn re + num[len][c];\n\t}\n\telse return fib(len, c);\n}\n\nint main() {\n\tscanf(\"%s%lld%lld\", s + 1, &L, &R);\n\tn = strlen(s + 1) / 2;\n\tp[1] = 0;\n\tfor (int j = 0, i = 2; i <= n; i ++) {\n\t\tfor (; j && s[j + 1] != s[i];) j = p[j];\n\t\tif (s[j + 1] == s[i]) j ++;\n\t\tp[i] = j;\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < 26; j ++) num[i][j] = num[i - 1][j];\n\t\tnum[i][s[i] - 'a'] ++;\n\t}\n\tT = n - p[n];\n\tfor (int i = 0; i < 26; i ++) printf(\"%lld%c\", calc(R, i) - calc(L - 1, i), i == 25 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint kmp[200010],len;\nchar s[200010];\nll p,l,r;\nll sum[30][200010];\nll solve(ll L,int n) {\n\tif(L<=len) return sum[n][L];\n\tll s1=sum[n][p],s2=sum[n][len],l1=p,l2=len,x,y;\n\twhile(l1+l2<L){\n\t\tx=s2,y=l2;\n\t\ts2+=s1,l2+=l1;\n\t\ts1=x,l1=y;\n\t}\n\treturn s2+solve(L-l2,n);\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tlen=strlen(s+1)/2;\n\tfor(int i=2,j=0;i<=len;i++){     \n        while(j&&s[i]!=s[j+1]) j=kmp[j];    \n        if(s[j+1]==s[i]) j++;    \n    \tkmp[i]=j;\n    \t//cout<<i<<\" \"<<kmp[i]<<endl;\n    }\n\tp=len-kmp[len];\n\tfor(int i=0;i<26;i++) \n\tfor(int j=1;j<=len;j++){\n\t\tsum[i][j]=sum[i][j-1];\n\t\tif(s[j]-'a'==i) sum[i][j]++;\n\t}\n\tfor(int i=0;i<26;i++) \n\tprintf(\"%lld \",solve(r,i)-solve(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200000+10;\n\nint n,lt,lim; char s[N];\nint sum[N][26];\nll ans[26],len[100],cnt[100][26];\n\nint nxt[N];\nvoid getnext() {\n\tfor (int i=2,j=0;i<=n;++i) {\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif (s[j+1]==s[i]) ++j;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid calc_sp(ll p,int w) {\n\tif (!p) return;\n\tfor (int i=0;i<26;++i) ans[i]+=w*(p/lt)*sum[lt][i];\n\tfor (int i=0;i<26;++i) ans[i]+=w*sum[p%lt][i];\n}\n\nvoid calc(ll p,int w) {\n\tif (!p) return;\n\tfor (int i=lim;i;--i) {\n\t\tif (p<len[i]) continue;\n\t\tp-=len[i];\n\t\tfor (int j=0;j<26;++j) ans[j]+=w*cnt[i][j];\n\t}\n\tfor (int i=0;i<26;++i) ans[i]+=w*sum[p][i];\n}\n\nint main() {\n\tscanf(\"%s\",s+1); n=strlen(s+1)>>1;\n\tll l=read(),r=read();\n\tgetnext(); lt=n-nxt[n];\n\tfor (int i=1;i<=n;++i) {\n\t\tmemcpy(sum[i],sum[i-1],sizeof(sum[i]));\n\t\t++sum[i][s[i]-'a'];\n\t}\n\tif (n%lt==0) calc_sp(r,1),calc_sp(l-1,-1);\n\telse {\n\t\tlen[1]=n,len[2]=n+lt;\n\t\tfor (int i=0;i<26;++i)\n\t\t\tcnt[1][i]=sum[n][i],cnt[2][i]=sum[n][i]+sum[lt][i];\n\t\tfor (int i=3;;++i) {\n\t\t\tlen[i]=len[i-1]+len[i-2];\n\t\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t\t\tif (len[i]>1e18) { lim=i; break; }\n\t\t}\n\t\tcalc(r,1),calc(l-1,-1);\n\t}\n\treturn 0;\n\tfor (int i=0;i<26;++i) printf(\"%lld \",ans[i]); puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nstring s;\nvector<pair<ll,array<ll,26>>> tmp;\n\nvi z(string s) {\n    int N = s.length(); s += '#';\n    vi ans(N); ans[0] = N;\n    while (s[1+ans[1]] == s[ans[1]]) ans[1] ++;\n    \n    int L = 1, R = ans[1];\n    FOR(i,2,N) {\n        if (i <= R) ans[i] = min(R-i+1,ans[i-L]);\n        while (s[i+ans[i]] == s[ans[i]]) ans[i] ++;\n        if (i+ans[i]-1 > R) L = i, R = i+ans[i]-1;\n    }\n    return ans;\n}\n\nstring tr(string s) {\n    for (int i = sz(s)/2+1; ; ++i) if (s.substr(i,sz(s)-i) == s.substr(0,sz(s)-i)) {\n        return s.substr(0,i)+s.substr(0,i);\n    }\n}\n\nvoid prin(string s) {\n    cout << sz(s)/2 << \" \"  << s.substr(0,sz(s)/2) << \"\\n\";\n}\n\nstring get(string s) {\n    vi v = z(s); v.pb(0);\n    for (int i = sz(s)/2+1; i <= sz(s); ++i) if (v[i] == sz(s)-i) return s.substr(0,i);\n}\n\npair<ll,array<ll,26>> gen(string a) {\n    array<ll,26> z = array<ll,26>();\n    for (char c: a) z[c-'a'] ++;\n    return {sz(a),z};\n}\n\npair<ll,array<ll,26>> operator+(const pair<ll,array<ll,26>>& l, const pair<ll,array<ll,26>>& r) {\n    array<ll,26> z = array<ll,26>(); F0R(i,26) z[i] = l.s[i]+r.s[i];\n    return {l.f+r.f,z};\n}\n\nstring a,b;\n\npair<ll,array<ll,26>> solve(ll pos, ll len) {\n    // cout << pos << \" \" << len << \" \" << tmp[pos].f << \" \" << tmp[pos-1].f << \" \" << tmp[pos-2].f << \"\\n\";\n    if (pos == 0) {\n        // exit(0);\n        array<ll,26> z = array<ll,26>(); \n        F0R(i,len) z[a[i]-'a'] ++;\n        return {len,z};\n    } else if (pos == 1) {\n        /*cout << pos << \" \" << len << \"\\n\";\n        exit(0);*/\n        array<ll,26> z = array<ll,26>(); \n        F0R(i,len) z[b[i]-'a'] ++;\n        return {len,z};\n    } else {\n        if (len <= tmp[pos-1].f) return solve(pos-1,len);\n        return tmp[pos-1]+solve(pos-2,len-tmp[pos-1].f);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> s;\n    \n    a = get(s);\n    tmp.pb(gen(a));\n    b = get(a+a);\n    tmp.pb(gen(b));\n    \n    while (tmp.back().f < 1e18) tmp.pb(tmp.back()+tmp[sz(tmp)-2]);\n    ll l, r; cin >> l >> r;\n    array<ll,26> x = solve(sz(tmp)-1,r).s;\n    array<ll,26> y = solve(sz(tmp)-1,l-1).s;\n    F0R(i,26) cout << x[i]-y[i] << \" \";\n    \n    /*\n    prin(tr(s));\n    prin(tr(tr(s)));\n    prin(tr(tr(tr(s))));\n    prin(tr(tr(tr(tr(s)))));*/\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,sz[105],cnt[105][26],ans[26];\nint nxt[200005],a[200005];\nchar s[200005];\nvoid query(ll now,ll c)\n{\n\t//printf(\"query(%lld,%lld)\\n\",now,c);\n\tif(now<=n)\n\t{\n\t\tfor(int i=1;i<=now;i++) ans[a[i]]+=c;\n\t\treturn;\n\t}\n\tint i=1;\n\twhile(sz[i]<=now&&sz[i]>0) i++;\n\tfor(int j=0;j<26;j++) ans[j]+=cnt[i-1][j]*c;\n\tquery(now-sz[i-1],c);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++) a[i]=s[i]-'a';\n\tn/=2;\n\tfor(int i=2,j=0;i<=n;i++)\n\t{\n\t\twhile(j&&a[j+1]!=a[i]) j=nxt[j];\n\t\tif(a[i]==a[j+1]) j++;\n\t\tnxt[i]=j;\n\t\t//printf(\"nxt[%d]=%d\\n\",i,j);\n\t}\n\tsz[0]=n,sz[1]=n+n-nxt[n];\n\t//printf(\"%lld %lld\\n\",sz[0],sz[1]);\n\tfor(int i=1;i<=n;i++) cnt[0][a[i]]++,cnt[1][a[i]]++;\n\tfor(int i=1;i<=n-nxt[n];i++) cnt[1][a[i]]++;\n\tfor(int i=2;i<=100;i++)\n\t{\n\t\tsz[i]=sz[i-1]+sz[i-2];\n\t\t//printf(\"sz[%d]=%lld\\n\",i,sz[i]);\n\t\tfor(int j=0;j<26;j++) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n\tll l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tquery(r,1);\n\tquery(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = s+t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<s+t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\twhile(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\twhile(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2 - fail[n / 2];\n\tint t = fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 200010,int lnN = 18>\nstruct String{\n\tstring S;\n\tint sa[N][lnN];\n\tvoid sa_init(){\n\t\tif(true){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tvec.push_back(P(S[i],0));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tsa[i][0] = lower_bound(vec.begin(),vec.end(),P(S[i],0)) - vec.begin();\n\t\t\t}\n\t\t}\n\t\tfor(int t = 1 ; t < lnN ; t ++){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size())vec.push_back(P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]));\n\t\t\t\telse vec.push_back(P(sa[i][t-1],-1));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size()){\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]))-vec.begin();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],-1)) - vec.begin();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool eq(int x,int y,int l){\n\t\tfor(int t = lnN-1 ; t >= 0 ; t--){\n\t\t\tif(l < (1<<t))continue;\n\t\t\tif(sa[x][t] != sa[y][t])return false;\n\t\t\tl -= 1<<t;\n\t\t}\n\t\treturn true;\n\t}\n};\nString<> str;\n\nstring A,B;\nvector<P> vec;\nll ret[26];\nll cnt_A[26];\nll cnt_B[26];\nvoid cnt(ll x,ll k){\n\t//cout << x << \" \" << k << endl;\n\tif(x <= A.size()+B.size()){\n\t\tfor(int i = 0 ; i < min( x , (ll)A.size() ) ; i ++){\n\t\t\tret[A[i]-'a'] += k;\n\t\t}\n\t\tfor(int i = A.size() ; i < x ; i ++){\n\t\t\tret[B[i-A.size()]-'a'] += k;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; i+1 < vec.size() ; i ++){\n\t\tif(vec[i+1].fr*A.size()+vec[i+1].sc*B.size() <= x)continue;\n\t\tll len = vec[i].fr*A.size() + vec[i].sc*B.size();\n\t\tfor(int j = 0 ; j < 26 ; j ++){\n\t\t\tret[j] += cnt_A[j]*vec[i].fr*k;\n\t\t\tret[j] += cnt_B[j]*vec[i].sc*k;\n\t\t}\n\t\tcnt(x-len,k);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tll l,r;\n\tcin >> str.S;\n\tcin >> l >> r;\n\t\n\t/*str.sa_init();\n\tA = \"\";\n\tfor(int i = str.S.size()/2+1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tA += str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}*/\n\tA = str.S.substr(0,str.S.size()/2);\n\tstr.S = A;\n\tstr.sa_init();\n\tfor(int i = 1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tB = str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//cout << A << \" \" << B << endl;\n\t\n\tvec.push_back(P(0,1));\n\tvec.push_back(P(1,0));\n\twhile(1){\n\t\tP p;\n\t\tp.fr = vec[vec.size()-2].fr + vec[vec.size()-1].fr;\n\t\tp.sc = vec[vec.size()-2].sc + vec[vec.size()-1].sc;\n\t\tvec.push_back(p);\n\t\tif(p.fr*A.size()+p.sc*B.size() > r)break;\n\t}\n\tfor(int i = 0 ; i < A.size() ; i ++){\n\t\tcnt_A[A[i]-'a'] ++;\n\t}\n\tfor(int i = 0 ; i < B.size() ; i ++){\n\t\tcnt_B[B[i]-'a'] ++;\n\t}\n\t\n\tcnt(r,1);\n\tcnt(l-1,-1);\n\tfor(int i = 0 ; i < 26 ; i ++){\n\t\tprintf(\"%lld%c\",ret[i],(i==25)?'\\n':' ');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nconst int B = 12345;\n\nvector<int> T, pB;\nint rangeHash(int l, int r, int N) {\n  return (1LL*(T[r]+MOD-(l>0?T[l-1]:0))*pB[N-l]) % MOD;\n}\n\nstring f_half(string s) {\n  int n = s.length();\n  pB = vector<int>(n+1);\n  pB[0] = 1;\n  for (int i=1; i<=n; i++) pB[i] = (1LL*pB[i-1]*B)%MOD;\n\n  T = vector<int>(n, 0);\n  rep(i, n) T[i] = (1LL*pB[i]*(int)(s[i]-'a'))%MOD;\n  rep(i, n-1) T[i+1] = (T[i+1]+T[i])%MOD;\n\n  for (int d=1; d<n; d++) {\n    if (rangeHash(0, n-1-d, n) == rangeHash(d, n-1, n)) {\n      string o(s);\n      rep(j, d) o += s[j];\n      return o;\n    }\n  }\n  return s+s;\n}\n\nstring S;\nlong long L, R;\nvector<long long> F;\n\nvector<long long> fib(long long cur) {\n  vector<long long> C(F.size(), 0);\n\n  assert(F.size() >= 2 && F[0] == S.length()/2);\n  for (int i=F.size()-1; i>=0; i--) {\n    if (cur >= F[i]) {\n      cur -= F[i];\n      C[i]++;\n    }\n    if (i >= 2) C[i-2] += C[i];\n    if (i >= 1) C[i-1] += C[i];\n  }\n  vector<long long> ret(26, 0);\n  // cur\n  rep(i, cur+1) ret[S[i]-'a']++;\n  // C[1]\n  rep(i, F[1]-F[0]) ret[S[i]-'a'] += C[1];\n  // C[0]\n  rep(i, S.length()/2) ret[S[i]-'a'] += C[0];\n  return ret;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> S >> L >> R;\n  L--, R--;\n  string half(S); half.resize(S.length()/2);\n  vector<int> seq;\n  seq.pb(half.size());\n  rep(_, 3) {\n    half = f_half(half);\n    seq.pb(half.size());\n  }\n  bool repeat = true;\n  rep(i, seq.size()-1) if (seq[i+1]-seq[i] != seq[1]-seq[0]) repeat = false;\n  vector<long long> ans(26);\n  if (repeat) {\n    long long N = S.length()/2;\n    rep(i, N) {\n      long long l = max(0LL, (L-i+N-1)/N), r = (R-i)/N;\n      ans[S[i]-'a'] += max(0LL, r-l+1);\n    }\n  }\n  else {\n    F.pb(seq[0]);\n    F.pb(seq[1]);\n    while (F.back() <= 1e18) F.pb(F[F.size()-1] + F[F.size()-2]);\n\n    ans = fib(R);\n    if (L > 0) {\n      vector<long long> t = fib(L-1);\n      rep(i, 26) ans[i] -= t[i];\n    }\n  }\n  rep(i, 26) cout << ans[i] << \" \"; cout << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nchar S[202020];\nint F[202020], L;\nlong long x[100], y[100], cntx[100][26], cnty[100][26], ans[26];\n\nvoid go(int p, long long l, long long r)\n{\n\tif (r <= L){\n\t\twhile (l < r){\n\t\t\tans[S[l]-'a']++;\n\t\t\tl++;\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long w = 0;\n\tfor (int k=0;;k++){\n\t\tlong long a = (k%3==1?y[p]:x[p]);\n\t\tlong long u = max(l, w);\n\t\tlong long v = min(r, w+a);\n\t\tif (r <= w) break;\n\t\tif (v - u == a){\n\t\t\tif (k % 3 == 1) for (int k=0;k<26;k++) ans[k] += cnty[p][k];\n\t\t\telse for (int k=0;k<26;k++) ans[k] += cntx[p][k];\n\t\t}\n\t\telse if (u < v) go(p-1, u-w, v-w);\n\t\tw += a;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\", S);\n\n\tint l = 0;\n\twhile (S[l]) l++;\n\tL = l;\n\n\tint k = -1; F[0] = -1;\n\tfor (int i=1;i<l;i++){\n\t\twhile (k >= 0 && S[k+1] != S[i]) k = F[k];\n\t\tif (S[k+1] == S[i]) k++;\n\t\tF[i] = k;\n\t}\n\n\tint u = l-1;\n\twhile ((u + 1) > l / 2) u = F[u];\n\tint r = l - (u + 1) * 2;\n\n\tconst long long lim = (long long)1e18 + 10;\n\tint v = u+r;\n\twhile ((v + 1) > (u + r + 1) / 2) v = F[v];\n\tfor (int i=0;i<=v;i++) cntx[0][S[i]-'a']++;\n\tfor (int i=v+1;i<=u+r-v-1;i++) cnty[0][S[i]-'a']++;\n\tx[0] = v + 1;\n\ty[0] = u+r-v-1 - v;\n\n\tint p = 1;\n\twhile (1){\n\t\tfor (int k=0;k<26;k++){\n\t\t\tcntx[p][k] = cntx[p-1][k] + cnty[p-1][k];\n\t\t\tcnty[p][k] = cntx[p-1][k];\n\t\t}\n\t\tx[p] = x[p-1] + y[p-1];\n\t\ty[p] = x[p-1];\n\t\tif (x[p] > lim) break;\n\t\tp++;\n\t}\n\t{\n\t\tlong long l, r;\n\t\tscanf(\"%lld %lld\", &l, &r);\n\t\tgo(p, l-1, r);\n\t}\n\tfor (int i=0;i<26;i++) printf(\"%lld%c\", ans[i], i+1<26?' ':'\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nint suffix[200005];\n\nlong long gcd(long long a, long long b)\n{\n    if (a%b == 0) return b;\n    else return gcd(b,a%b);\n}\n\nint find_suffix(string s)\n{\n    //find length of longest suffix of s that is also a prefix of s\n    suffix[0] = suffix[1] = 0;\n    for (int i=2; i<=s.length(); i++) {\n        int j = suffix[i-1];\n        while (true) {\n            if (s[j] == s[i-1]) {\n                suffix[i] = j+1;\n                break;\n            }\n            else if (j == 0) {\n                suffix[i] = 0;\n                break;\n            }\n            j = suffix[j];\n        }\n    }\n    //printa(suffix,s.length()+1);\n    return suffix[s.length()];\n}\n\nvector<ll> count_chars(string s)\n{\n    vector<ll> ret(26,0);\n    iter(s)\n        ret[*it-'a']++;\n    return ret;\n}\n\nvector<ll> simple_query(string period, ll r, vector<ll> &chr_cnt)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    ll num_periods = r/period.length();\n    ll remain = r % period.length();\n    for0(i,26) {\n        ret[i] = chr_cnt[i]*num_periods;\n    }\n\n    for0(i,remain) {\n        ret[period[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve_simple(string period, ll l, ll r)\n{\n    //prl(period);\n    vector<ll> chr_cnt = count_chars(period);\n    vector<ll> r_cnt = simple_query(period, r, chr_cnt);\n    vector<ll> l_cnt = simple_query(period, l-1, chr_cnt);\n    //printv(r_cnt);\n    //printv(l_cnt);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nvector<ll> hard_query(vector<vector<ll>> & chr_cnt, vector<ll> & lens, string g1, ll r)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    int lv = sz(lens)-1;\n    while (lv > 0) {\n        if (lens[lv-1] <= r) {\n            r -= lens[lv-1];\n            for0(i,26) {\n                ret[i] += chr_cnt[lv-1][i];\n            }\n        }\n        lv--;\n    }\n    //prl(r)\n    assert(r <= g1.length());\n\n    for (int i=0; r>0 && i<g1.length(); i++,r--) {\n        ret[g1[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve_hard(string g1, string g2, ll l, ll r)\n{\n    vector<vector<ll>> chr_cnt;\n    vector<ll> lens;\n    chr_cnt.pb(count_chars(g1));\n    chr_cnt.pb(count_chars(g2));\n    lens.pb(g1.length());\n    lens.pb(g2.length());\n\n    while (lens.back() < r) {\n        vector<ll> next_cnt(26,0);\n        for0(i,26) {\n            next_cnt[i] = chr_cnt[sz(chr_cnt)-1][i] + chr_cnt[sz(chr_cnt)-2][i];\n        }\n        chr_cnt.pb(next_cnt);\n        lens.pb(lens[sz(lens)-1] + lens[sz(lens)-2]);\n    }\n\n    vector<ll> r_cnt = hard_query(chr_cnt, lens, g1, r);\n    vector<ll> l_cnt = hard_query(chr_cnt, lens, g1, l-1);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"D.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    string s;\n    cin >> s;\n    s = s.substr(0,s.length()/2);\n    long long l,r;\n    cin >> l >> r;\n\n    int suf_len = find_suffix(s);\n    //prl(suf_len)\n    if (suf_len == 0) {\n        //special case where pattern is periodic with period s\n        solve_simple(s, l, r);\n    }\n    else if (suf_len >= (s.length()+1)/2 && gcd(suf_len,s.length()) > 1) {\n        //special case where s is periodic. Pattern is periodic with period repeated\n        string period = s.substr(0,gcd(suf_len, s.length()));\n        solve_simple(period, l, r);\n    }\n    else if (suf_len == s.length()-1) {\n        //s consists of all 1 character. Again pattern is periodic with that character repeated\n        solve_simple(s.substr(0,1), l, r);\n    }\n    else {\n        string T = s.substr(0,s.length()-suf_len);\n        string g1 = s+T;\n        string g2 = s+T+s;\n        solve_hard(g1, g2, l, r);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nlong all[30];\nstring f(const string s)\n{\n\tint cnt = s.size() / 2;\n\tfor(;cnt < s.size(); ++cnt)\n\t{\n\t\tstring curs = s.substr(0,cnt);\n\t\tstring curs2 = s.substr(cnt + 1);\n\t\tif(curs.find(curs2)!= string::npos)\n\t\t{\n\t\t\treturn curs + curs;\n\t\t}\n\t}\n\treturn s + s;\n}\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tif(s.size() % 2 == 0 && s.substr(0,s.size() / 2) == s.substr(s.size() / 2 + 1))\n\t{\n\t\tstring cur_s = f(s);\n\t\tfor(int i = 0;i < cur_s.size(); ++i)\n\t\t{\n\t\t\tall[cur_s[i] - '0']++;\n\t\t}\n\t\tfor(int i = 0;i < 26; ++i)\n\t\t{\n\t\t\tcout<<all[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//bool valid(Hasher &h, int k){\n//    bool ok = true;\n//    for(int i = 0; i < sz(h.s); i += k){\n//        int l = i;\n//        int r = i+k-1;\n//        r = min(ll(r),sz(h.s)-1);\n//        if(h.range_get(l,r) != h.range_get(0,r-l))\n//            ok = false;\n//    }\n//    return ok;\n//}\n//string f(string s){\n//    vpii ans;\n//    Hasher h(s);\n//    rep(sz,1,sz(s)){\n//        if(valid(h,sz)){\n//            int times = (sz(s)+sz-1)/sz;\n//            if(times*sz == sz(s))\n//                ++times;\n//            if(times % 2)\n//                ++times;\n//            int tot_len = times*sz;\n//            ans.pb({tot_len,sz});\n//        }\n//    }\n//    unique(ans);\n//    int sz = ans[0].Y;\n//    while(sz(s) < ans[0].X){\n//        s += s[sz(s)%sz];\n//    }\n//    return s;\n//}\n//struct String{\n//    ll len;\n//    map<char,ll> cnt;\n//    String(string s){\n//        s = s.substr(sz(s)/2);\n//        len = sz(s);\n//        for(char c : s)\n//            cnt[c]++;\n//    }\n//    String operator+(const String &t)const{\n//        String ans = *this;\n//        ans.len += t.len;\n//        for(auto _ : t.cnt)\n//            ans.cnt[_.X] += _.Y;\n//        return ans;\n//    }\n//    String operator-(const String &t)const{\n//        String ans = *this;\n//        ans.len += t.len;\n//        for(auto _ : t.cnt)\n//            ans.cnt[_.X] -= _.Y;\n//        return ans;\n//    }\n//    friend ostream &operator<<(ostream &stream, String &t){\n//        for(char c = 'a'; c <= 'z'; ++c){\n//            stream << t.cnt[c];\n//            if(c != 'z')\n//                stream << ' ';\n//        }\n//        return stream;\n//    }\n//};\n//String get(string s, ll n){\n//    vector<String> arr;\n//    arr.pb(String(s));\n//    arr.pb(String(f(s)));\n//    while(arr.back().len < n){\n//        arr.pb(arr[sz(arr)-1]+arr[sz(arr)-2]);\n//    }\n//    String ans(\"\");\n//    for(int i = sz(arr)-1; i >= 1; --i){\n//        while(n >= arr[i].len){\n//            ans = ans+arr[i];\n//            n -= arr[i].len;\n//        }\n//    }\n//    rep(i,0,n-1)\n//        ans.cnt[s[i]]++;\n//    return ans;\n//}\n//void _(){\n//    ll l,r;\n//    string s;\n//    cin >> s >> l >> r;\n//\n//    String ans = get(s,r)-get(s,l-1);\n//    print(ans);\n//\n//}\n//\n#include <map>\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define REP_INT(i,l,r) for(int i = l; i <= r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define X first\n#define Y second\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef long double ld;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 vector<T> unique(vector<T>& arr){\n    sort(all(arr));\n    arr.erase(unique(all(arr)), arr.end());\n    return arr;\n}\nT1 istream& read(T, T, istream& = cin);\nT1 void print(T x, string end = \"\\n\"){\n    cout << x << end;\n}\nll mult64(ll x, ll y, ll mod){\n    if(abs(x) >= mod)\n        x %= mod;\n    if(abs(y) >= mod)\n        y %= mod;\n    ll tmp = ((ull)x * y - (ull)((ld)x / mod * y + 1.0e-8) * mod);\n    if(tmp >= mod)\n        tmp -= mod;\n    return (tmp < 0) ? (tmp + mod) : tmp;\n}\nstruct Hasher{\n    string s;\n    const ll mod;\n    vl psum;\n    int n;\n    ll ipow128(ll x, ll p){\n        if(x >= mod)\n            x %= mod;\n        if(p == 0)\n            return 1;\n        if(p == 1)\n            return x;\n        return mult64(ipow128(mult64(x, x, mod), p / 2), ipow128(x, p % 2), mod);\n    }\n    ll _ext_euclid(ll a, ll b, ll c, ll d){\n        if(c == 0)\n            return b;\n        return _ext_euclid(c, d, a % c, b - a / c * d);\n    }\n    ll inv128(ll x){\n        return (_ext_euclid(mod, 0, x, 1) + mod) % mod;\n    }\n    vl k_pows;\n    Hasher(string _s, ll _mod = MOD):s(_s), mod(_mod){\n        n = sz(s);\n        psum.resize(n + 1);\n        ll mult = 1;\n        ll k = 26;\n        k_pows.resize(n+1,1);\n        ll k_inv = inv128(k);\n        for(int i = 1; i <= n; ++i){\n            k_pows[i] = mult64(k_pows[i-1],k_inv,mod);\n            psum[i] = mult64(mult,(s[i - 1] - 'a' + 1),mod);\n            psum[i] += psum[i - 1];\n            mult = mult64(mult,k,mod);\n            mult %= mod;\n            psum[i] %= mod;\n        }\n    }\n    ll range_get(int l, int r){\n        //ll ans = mult64(mod+psum[r+1]-psum[l],k_pows[l],mod);\n        ll ans = (mod+psum[r+1]-psum[l])*k_pows[l]%mod;\n        return ans;\n    }\n};\nbool valid(Hasher &h, int k){\n    bool ok = true;\n    for(int i = 0; i < sz(h.s); i += k){\n        int l = i;\n        int r = i+k-1;\n        r = min(ll(r),sz(h.s)-1);\n        if(h.range_get(l,r) != h.range_get(0,r-l))\n            ok = false;\n    }\n    return ok;\n}\nstring f(string s){\n    vpii ans;\n    Hasher h(s);\n    rep(sz,1,sz(s)){\n        if(valid(h,sz)){\n            int times = (sz(s)+sz-1)/sz;\n            if(times*sz == sz(s))\n                ++times;\n            if(times % 2)\n                ++times;\n            int tot_len = times*sz;\n            ans.pb({tot_len,sz});\n        }\n    }\n    unique(ans);\n    int sz = ans[0].Y;\n    while(sz(s) < ans[0].X){\n        s += s[sz(s)%sz];\n    }\n    return s;\n}\nstruct String{\n    ll len;\n    map<char,ll> cnt;\n    String(string s){\n        s = s.substr(sz(s)/2);\n        len = sz(s);\n        for(char c : s)\n            cnt[c]++;\n    }\n    String operator+(const String &t)const{\n        String ans = *this;\n        ans.len += t.len;\n        for(auto _ : t.cnt)\n            ans.cnt[_.X] += _.Y;\n        return ans;\n    }\n    String operator-(const String &t)const{\n        String ans = *this;\n        ans.len += t.len;\n        for(auto _ : t.cnt)\n            ans.cnt[_.X] -= _.Y;\n        return ans;\n    }\n    friend ostream &operator<<(ostream &stream, String &t){\n        for(char c = 'a'; c <= 'z'; ++c){\n            stream << t.cnt[c];\n            if(c != 'z')\n                stream << ' ';\n        }\n        return stream;\n    }\n};\nString get(string s, ll n){\n    vector<String> arr;\n    arr.pb(String(s));\n    arr.pb(String(f(s)));\n    while(arr.back().len < n){\n        arr.pb(arr[sz(arr)-1]+arr[sz(arr)-2]);\n    }\n    String ans(\"\");\n    for(int i = sz(arr)-1; i >= 1; --i){\n        while(n >= arr[i].len){\n            ans = ans+arr[i];\n            n -= arr[i].len;\n        }\n    }\n    rep(i,0,n-1)\n        ans.cnt[s[i]]++;\n    return ans;\n}\nvoid _(){\n    ll l,r;\n    string s;\n    cin >> s >> l >> r;\n    String ans = get(s,r)-get(s,l-1);\n    print(ans);\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        _();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n/*\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=2e6+5,M=1e7+50,mo=1e9+7;\nint fail[N],n,i,per;\nll len1,len2,d,prt[30],l,r,f[305][26],g[305][26],sf[305],sg[305];\nchar s[N];\nvoid ext()\n{\n\tint i,j;\n\tj=0;\n\tn=strlen(s+1);\n\tfo(i,2,n)\n\t{\n\t\twhile (j&&s[i]!=s[j+1]) j=fail[j];\n\t\tif (s[i]==s[j+1]) j++;\n\t\tfail[i]=j;\n\t}\n\ti=fail[n];\n\twhile (i>=n/2) i=fail[i];\n\tfo(j,n+1,n+n-2*i) s[j]=s[i+j-n];\n}\nvoid fib()\n{\n\tint i,j;\n\tfo(i,2,300)\n\t{\n\t\tfo(j,0,25)  g[i][j]=g[i-1][j]+g[i-2][j];\n\t\tsg[i]=sg[i-1]+sg[i-2];\n\t\tif (sg[i]*2>r) break;\n\t}\n\tfo(i,0,300)\n\t{\n\t\tfo(j,0,25) f[i][j]=g[i][j]*2;\n\t\tsf[i]=sg[i]*2;\n\t\tif (sf[i]>r) break;\n\t}\n}\nvoid calc(ll x,ll xs)\n{\n\tint pos;\n\tfo(pos,0,300)\n\t\tif (sf[pos]>x) break;\n\twhile (pos>=0)\n\t{\n\t\tif (sf[pos]<=x)\n\t\t{\n\t\t\tfo(i,0,25) prt[i]+=xs*f[pos][i];\n\t\t\tx-=sf[pos];\n\t\t\tpos--;\n\t\t}else\n\t\tpos--;\n\t}\n\twhile (n<x) ext(),n=strlen(s+1);\n\tfo(i,1,x) prt[s[i]-'a']+=xs;\n}\nint main()\n{\n\tscanf(\"%s %lld %lld\",s+1,&l,&r);\n\text();\n\tn=strlen(s+1);\n\tfo(i,1,n/2) g[0][s[i]-'a']++,sg[0]++;\n\tper=n/2-fail[n/2];\n\tfo(i,0,25) g[1][i]=g[0][i];\n\tsg[1]=sg[0];\n\tfo(i,1,per) g[1][s[i]-'a']++,sg[1]++;\n\tfib();\n\tcalc(r,1);\n\tcalc(l-1,-1);\n\tfo(i,0,25) printf(\"%lld \",prt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,D=26;\nchar s[N];\nint ext[N];\nstruct ccnt{\n\tlint cnt[26];\n\tinline void operator += (const ccnt &b){\n\t\tfor(int i=0;i<D;i++){\n\t\t\tcnt[i]+=b.cnt[i];\n\t\t}\n\t}\n}_cnt[N],f[N];\nlint g[N];\ninline ccnt work(lint x){\n\tassert(x>=0);\n\tif(x<=g[1]){\n\t\treturn _cnt[x];\n\t}\n\tint t=0;\n\tfor(;g[t]<=x;t++);\n\tassert(t);\n\tccnt ans=f[t-1];\n\tans+=work(x-g[t-1]);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1)>>1;\n\ts[n+1]=0;\n\tmemset(ext,0,sizeof(ext));\n\tfor(int i=2,j=0;i<=n+1;i++){\n\t\text[i]=max(min(ext[i-j+1],j+ext[j]-i),0);\n\t\tfor(;s[1+ext[i]]==s[i+ext[i]];ext[i]++);\n\t\tif(i+ext[i]>j+ext[j]){\n\t\t\tj=i;\n\t\t\tif(i+ext[i]>n){\n\t\t\t\tg[0]=i-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(_cnt,0,sizeof(_cnt[0]));\n\tfor(int i=1;i<=n;i++){\n\t\t_cnt[i]=_cnt[i-1];\n\t\t_cnt[i].cnt[s[i]-'a']++;\n\t}\n\tf[0]=_cnt[g[0]];\n\tg[1]=n,f[1]=_cnt[n];\n\tlint l=next_num<lint>(),r=next_num<lint>();\n\tfor(int i=2;g[i-1]<=r;i++){\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tf[i]=f[i-1];\n\t\tf[i]+=f[i-2];\n\t}\n\tccnt ansl=work(l-1),ansr=work(r);\n\tfor(int i=0;i<D;i++){\n\t\tprintf(\"%lld \",ansr.cnt[i]-ansl.cnt[i]);\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n// [S]=n\n// [T]=k\n// first k element = last k element in S\nf(S) = STST \nF(2) = g(S) x2\n\ng(S) = ST\ng(ST) = STS\ng(STS) = STSST\ng(sz) = g(sz-1) + g(sz-2)\n//can't prove\n\n*/\n\n#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 2*1e5+10;\n\nstring s;\nll l,r,len[maxn],cnt[100][maxn],ans[30];\nint KMP[maxn];\n\nint pre_calc(string s, int type) {\n    memset(KMP,0,sizeof(KMP));\n    //cout<<s<<endl;\n    int n= s.length();\n    for (int i=0;i<n;i++) {\n        if (i==0) KMP[i]=-1;\n        else {\n            KMP[i] = KMP[i-1];\n            while (1) {\n                //cout<<i<<\" \"<<KMP[i]<<endl;\n                if (s[KMP[i]+1] == s[i]) {\n                    KMP[i]++;\n                    break;\n                }\n                if (KMP[i]==-1) break;\n                KMP[i] = KMP[KMP[i]];\n            }\n        }\n    }\n    //cout<<\"fuk\"<<endl;\n    int tmp = KMP[n-1];\n    //cout<<tmp<<endl;\n    if (type==1) while (tmp*2+2>=n) tmp=KMP[tmp];\n    else while (tmp*2+2>n) tmp=KMP[tmp];\n    return tmp+1;\n}\n\nvoid calc(ll LEN,ll coe) {\n    int T1 = pre_calc(s,1);\n    string s2 = \"\";\n    for (int i=0;i<s.length()-T1;i++) s2+=s[i];\n    int T2 = pre_calc(s2,2);\n    int sz=0;\n    //cout<<T1<<\" \"<<T2<<endl;\n    for (int i=T2;i<s2.length()-T2;i++) {\n        len[sz]++;\n        cnt[sz][s2[i]-'a']++;\n    }\n    sz++;\n    for (int i=0;i<T2;i++) {\n        len[sz]++;\n        cnt[sz][s2[i]-'a']++;\n    }\n    sz++;\n    while (len[sz-1]<=LEN) {\n        len[sz] = len[sz-1] + len[sz-2];\n        for (int i=0;i<26;i++) cnt[sz][i] = cnt[sz-1][i] + cnt[sz-2][i];\n        sz++;\n        ///cout<<len[sz-1]<<endl;\n    }\n    for (int i=sz-1;i>=2;i--) {\n        if (LEN>=len[i]) {\n            LEN-=len[i];\n            for (int j=0;j<26;j++) ans[j]+= coe*cnt[i][j];\n        }\n    }\n    for (int i=0;i<LEN;i++) ans[s[i]-'a']+=coe;\n\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>s;\n    cin>>l>>r;\n    calc(r,1);\n    calc(l-1,-1);\n    for (int i=0;i<26;i++) cout<<ans[i]<<\" \";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#undef LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\n// z[i] = len of lcp of s, s[i..]; lcp(longest common prefix)\nvector<int> z_fn(const string& s) {\n    int n = s.size();\n    vector<int> z(n, 0);\n    for (int i = 1, l = 0, r = 0; i < n; i++) {\n        if (i <= r)\n            z[i] = min(r-i+1, z[i-l]);\n        while (i+z[i] < n && s[z[i]] == s[i+z[i]]) {\n            z[i]++;\n        }\n        if (i+z[i]-1 > r) {\n            l = i; r = i+z[i]-1;\n        }\n    }\n    return z;\n}\n\nvoid f(string& s){\n    auto z = z_fn(s);\n    int n = s.size();\n    int i = n/2 + 1;\n    while (i < n) {\n        if (z[i] == n-i) break;\n        i++;\n    }\n    for (int j = 0; j < 2*i-n; j++) {\n        s.push_back(s[j+n-i]);\n    }\n}\n\nint min_prefix(const string& s){\n    int n = s.size();\n    auto z = z_fn(s);\n    for (int i = 1; i < n; i++) {\n        if (z[i] == n-i) return i;\n    }\n    return n;\n}\n\nusing ll=long long ;\nusing Freq=array<ll,26>;\nFreq& operator+=(Freq& a, const Freq& b){\n    for (int i = 0; i < 26; i++) {\n        a[i] += b[i];\n    }\n    return a;\n}\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\n\nvoid solve() {\n    string s; cin >> s;\n    f(s);\n    s.resize(s.size()/2);\n    int k = min_prefix(s);\n    int n = s.size();\n    dbg(s,k,n);\n\n    vector<ll> fib = {k, n};\n    vector<Freq> cnt(100);\n    for (int i = 0; i < k; i++) {\n        cnt[0][s[i]-'a']++;\n    }\n    for (int i = 0; i < n; i++) {\n        cnt[1][s[i]-'a']++;\n    }\n    while (fib.back() < INF) {\n        int n = fib.size();\n        fib.emplace_back(fib[n-1] + fib[n-2]);\n        for (int i = 0; i < 26; i++) {\n            cnt[n][i] = cnt[n-1][i] + cnt[n-2][i];\n        }\n    }\n    dbg(fib);\n    dbg(cnt);\n\n    int m = fib.size();\n    dbg(m);\n    dbg(cnt[m-1]);\n    auto till = [&](ll r){\n        Freq res = {};\n        if (r <= 0) return res;\n        for (int i = m-1; i >= 0; i--) {\n            if (r < fib[i]) continue;\n            res += cnt[i];\n            r -= fib[i];\n            dbg(i, res, r);\n        }\n        assert(r < k);\n        for (int i = 0; i < r; i++) {\n            res[s[i]-'a']++;\n        }\n        return res;\n    };\n\n    ll l, r;\n    cin >> l >> r;\n    auto x = till(l-1);\n    auto y = till(r);\n    for (int i = 0; i < 26; i++) {\n        cout << (y[i]-x[i]) << ' ';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nconst ll b = 2;//1342231LL;\n\nconst int mx = 2e5;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tvector<ll> pw(mx);\n\tpw[0] = 1;\n\trep(i,1,mx) pw[i] = pw[i-1]*b % md;\n\n\tstring s;\n\tcin >> s;\n\tint n = sz(s)/2;\n\tstring a = s.substr(0, n);\n\n\tvector<ll> pre(n+1);\n\trep(i,0,n) pre[i+1] = (pre[i]*b + a[i])%md;\n\n\tint len;\n\tfor(len = n; len --> 0;){\n\t\tif((pre[n]-pre[n-len]*pw[len]%md - pre[len])%md == 0)\n\t\t\tbreak;\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\tif(len*2 >= n || len == 0){\n\n\t\tauto f = [&](ll pos, int c){\n\t\t\tll ans = 0;\n\t\t\tans += count(all(a), 'a'+c)*(pos/n);\n\t\t\tpos %= n;\n\t\t\tans += count(a.begin(), a.begin()+pos, 'a'+c);\n\t\t\treturn ans;\n\t\t};\n\n\t\trep(c,0,26){\n\t\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t\t}\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\n\tvector<ll> fibs(200);\n\tfibs[0] = len, fibs[1] = n-len;\n\trep(i,2,200) fibs[i] = fibs[i-1] + fibs[i-2];\n\n\tvector<vector<ll>> cnts(200, vector<ll>(26));\n\trep(i,0,26) cnts[0][i] = count(a.begin(),a.begin()+len, 'a'+i);\n\trep(i,0,26) cnts[1][i] = count(a.begin()+len,a.end(), 'a'+i);\n\trep(i,2,200) rep(j,0,26) cnts[i][j] = cnts[i-1][j]+cnts[i-2][j];\n\n\tfunction<ll(ll,int,int)> que = [&](ll pos, int c, int ix){\n\t\tassert(fibs[ix] >= pos);\n\t\tif(ix == 0){\n\t\t\treturn (ll)count(a.begin(),a.begin()+pos, 'a'+c);\n\t\t}\n\t\tif(ix == 1){\n\t\t\treturn (ll)count(a.begin()+len,a.begin()+len+pos, 'a'+c);\n\t\t}\n\t\tif(pos <= fibs[ix-2]) return que(pos, c, ix-2);\n\t\treturn cnts[ix-2][c] + que(pos-fibs[ix-2],c,ix-1);\n\t};\n\n\tauto f = [&](ll pos, int c){\n\t\tint i = 0;\n\t\twhile(fibs[i] < pos) ++i;\n\t\treturn que(pos, c, i);\n\t};\n\trep(c,0,26){\n\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\trep(j,n)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n/*\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N=2e5+10;\n\nLL l,r,ans[26],g[110],sum[N][26],sm[110][26];\nint len,plen,nxt[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n}\n\nvoid Getnext(char *s,int len) {\n\tnxt[0]=0;nxt[1]=0;\n\tfor (int i=1,k=0;i<len;++i) {\n\t\twhile (k && s[i]!=s[k]) k=nxt[k];\n\t\twhile (s[i]==s[k]) ++k;\n\t\tnxt[i+1]=k;\n\t}\n}\n\nvoid Calc(int dep,LL *ans,LL l,LL r,int op) {\n\tif (r==g[dep] && l==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sm[dep][j];\n\t\treturn ;\n\t}\n\tif (dep==0 || dep==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*(sum[r][j]-sum[l-1][j]);\n\t\treturn ;\n\t}\n\tif (r>g[dep-1]) {\n\t\tCalc(dep-1,ans,l,g[dep-1],op);\n\t\tCalc(dep-2,ans,1,r-g[dep-1],op);\n\t}else Calc(dep-1,ans,l,r,op);\n}\n\nvoid Solve() {\n\tlen=strlen(s);len/=2;\n\tGetnext(s,len);\n\tfor (int i=1;i<=len;++i) {\n\t\tfor (int j=0;j<26;++j) sum[i][j]=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tplen=len-nxt[len];\n\tg[0]=plen; for (int j=0;j<26;++j) sm[0][j]=sum[plen][j];\n\tg[1]=len; for (int j=0;j<26;++j) sm[1][j]=sum[len][j];\n\tfor (int i=2;i<=100;++i) {\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tfor (int j=0;j<26;++j) sm[i][j]=sm[i-1][j]+sm[i-2][j];\n\t}\n\t\n\tfor (int i=1;i<=100;++i) \n\t\tif (g[i]>r) { Calc(i,ans,l,r,1); break; }\n\tfor (int i=0;i<26;++i) printf(\"%lld%c\",ans[i],(i==25)?'\\n':' ');\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 500006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nlong long n,p,t,v[26],height[N],sa[N],fuckyouatcoder[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\nvoid SA()\n{\n\tfor(long long i=1;i<=n;i++)cntA[(long long)s[i]]++;\n\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(long long i=n;i;i--)sa[cntA[(long long)s[i]]--]=i;\n\tfuckyouatcoder[sa[1]]=1;\n\tfor(long long i=2;i<=n;i++){\n\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t}\n\tfor(long long l=1;fuckyouatcoder[sa[n]]!=n;l<<=1){\n\t\tfor(long long i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\tcntA[A[i]=fuckyouatcoder[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?fuckyouatcoder[i+l]:0)]++;\n\t\t}\n\t\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(long long i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(long long i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\tfuckyouatcoder[sa[1]]=1;\n\t\tfor(long long i=2;i<=n;i++){\n\t\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t\t}\n\t}\n\tlong long tot=0;\n\tfor(long long i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[fuckyouatcoder[i]-1]+tot])tot++;\n\t\theight[fuckyouatcoder[i]]=tot;\n\t}\n\tp=n;long long mi=N;\n\tfor(long long i=fuckyouatcoder[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(long long i=fuckyouatcoder[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(long long w,long long F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(long long i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(long long i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(long long i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(long long i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(long long i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(long long i=(l-n)%p;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(long long i=1;i<=r%p;i++)a[s[i]-97]++;\n\t\t\tfor(long long i=0;i<26;i++)a[i]+=1LL*v[i]*(r/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(long long i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(long long i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(long long i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(long long i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define repd(i,n) for(int (i)=n-1;(i)>=0;i--)\n#define REPD(i,n) for(int (i)=n;(i)>0;i--) \n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int Maxn=200005;\nconst int Maxm=30;\nconst int H=31;\nint n,match;\nstring s;\nll l,r;\nll hsh[Maxn],power[Maxn];\nint cnt[Maxn][Maxm];\nll ans[Maxm];\nvector<ll>L,R;\n\nbool same(int pos){\n\tll k1=hsh[pos-1],k2=hsh[n-1]-hsh[n-1-pos]*power[pos];\n\treturn k1==k2;\n}\n\nvector<ll> add_ans(vector<ll>a,vector<ll>b){\n\trep(i,26)a[i]+=b[i];\n\treturn a;\n}\n\npair<ll,vector<ll> > solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest){\n\tvector<ll>res(26);\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_ans(L,R);\n\t\tpair<ll,vector<ll> >ret=solve(l_len+r_len,sum,l_len,L,rest);\n\t\trest=ret.fi;\n\t\tres=add_ans(res,ret.se);\n\t}\n\tif(l_len<=rest){\n\t\tres=add_ans(res,L);\n\t\trest-=l_len;\n\t}\n\treturn mk(rest,res);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=sz(s);\n\n\thsh[0]=s[0]-'a';power[0]=1;\n\tREP(i,n-1)hsh[i]=hsh[i-1]*H+s[i]-'a',power[i]=power[i-1]*H;\n\tREP(i,n-1)if(same(i))match=max(match,i);\n\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(j==s[i]-'a')cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\n\tif(match==0){\n\t\trep(i,26){\n\t\t\tans[i]+=(ll)cnt[n-1][i]*(ll)(r/(ll)n)+(ll)cnt[r%(ll)n][i];\n\t\t\tif((l-1)>=0)ans[i]-=(ll)cnt[n-1][i]*(ll)((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tL.resize(26);R.resize(26);\n\t\trep(i,26)R[i]=cnt[match-1][i];\n\t\trep(i,26)L[i]=cnt[n-1][i]-cnt[match-1][i];\n\t\tpair<ll,vector<ll> >ans_R=solve(n-match,L,match,R,r);\n\t\tpair<ll,vector<ll> >ans_L=solve(n-match,L,match,R,l-1);\n\t\trep(i,26){\n\t\t\tans[i]+=ans_R.se[i]+cnt[ans_R.fi][i];\n\t\t\tans[i]-=ans_L.se[i]+cnt[ans_L.fi][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}\n/*\nvgxgpuamkvgxgvgxgpuamkvgxg\n1 1000000000000000000\n*/ "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=1500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint a[N],nx[N];\nLL b[N][30],bv[N];\nLL Ans[30];\nvoid Doit(LL q,LL K)\n{\n\tif(q<=n)\n\t{\n\t\tfo(i,1,q)Ans[a[i]]+=K;\n\t\treturn;\n\t}\n\tfo(i,1,N)if(bv[i]>q)\n\t{\n\t\tfo(j,0,25)Ans[j]+=b[i-1][j]*K;\n\t\tDoit(q-bv[i-1],K);\n\t\treturn;\n\t}\n}\nint main()\n{\n\tint q;\n\tchar ch=' ';\n\tfor(ch=getchar();ch<='z'&&ch>='a';ch=getchar())a[++n]=ch-'a';\n\tn>>=1;\n\tq=0;\n\tfo(i,2,n)\n\t{\n\t\tfor(;q&&a[q+1]!=a[i];q=nx[q]);\n\t\tif(a[q+1]==a[i])++q;\n\t\tnx[i]=q;\n\t}\n\tm=n-nx[n];\n\tfo(i,1,n)++b[0][a[i]];\n\tfo(i,0,25)b[1][i]=b[0][i];\n\tfo(i,1,m)++b[1][a[i]];\n\tbv[0]=n,bv[1]=n+m;\n\tfo(i,2,1000)\n\t{\n\t\tbv[i]=bv[i-1]+bv[i-2];\n\t\tfo(j,0,25)b[i][j]=b[i-1][j]+b[i-2][j];\n\t}\n\tLL l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tDoit(r,1);\n\tDoit(l-1,-1);\n\tfo(i,0,25)printf(\"%lld \",Ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[888888],sz,pos,g,cnt[28][222222],p[28][444444],q[28][888888];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[222222];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next NexT\n#define LL long long\n\nconst int maxn=2e5+10;\n\nint n,next[maxn];\nLL L,R,c0[30],cA[30],cB[30],Ans[30],LA,LB;\nchar s[maxn];\n\nvoid KMP()\n{\n\tint i;\n\tnext[0]=0; next[1]=0;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tnext[i]=next[i-1];\n\t\twhile (s[next[i]+1]!=s[i]&&next[i])\n\t\t\tnext[i]=next[next[i]];\n\t\tnext[i]+=s[next[i]+1]==s[i];\n\t}\n}\n\nvoid solve(LL R,int flag)\n{\n\tint i;\n\tif (R<=n)\n\t{\n\t\tfor (i=1;i<=R;i++)\n\t\t\tAns[s[i]-'a']+=flag;\n\t\treturn;\n\t}\n\tLA=next[n];\n\tLB=n-2*next[n];\n\tmemset(cA,0,sizeof(cA));\n\tmemset(cB,0,sizeof(cB));\n\tfor (i=1;i<=LA;i++) cA[s[i]-'a']++;\n\tfor (i=LA+1;i<=LA+LB;i++) cB[s[i]-'a']++;\n\twhile (LA+LB+LA+LA+LB<=R)\n\t{\n\t\tswap(LA,LB); LA+=LB;\n\t\tfor (i=0;i<26;i++)\n\t\t\tswap(cA[i],cB[i]),cA[i]+=cB[i];\n\t}\n\tfor (i=0;i<26;i++)\n\t\tAns[i]+=flag*(cA[i]+cB[i]+cA[i]);\n\tR-=LA+LB+LA;\n\twhile (R)\n\t{\n\t\tif (LA+LB+LA==n) break;\n\t\tLA-=LB; swap(LA,LB);\n\t\tfor (i=0;i<26;i++)\n\t\t\tcA[i]-=cB[i],swap(cA[i],cB[i]);\n\t\tif (LA+LB+LA==n) break;\n\t\tif (R>=LA)\n\t\t{\n\t\t\tfor (i=0;i<26;i++)\n\t\t\t\tAns[i]+=flag*cA[i];\n\t\t\tR-=LA;\n\t\t}\n\t}\n\tfor (i=1;i<=R;i++)\n\t\tAns[s[i]-'a']+=flag;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i;\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tn=strlen(s+1);\n\tn=n/2;\n\tKMP();\n\tif (n%(n-next[n])==0)\n\t{\n\t\tfor (i=1;i<=n;i++) c0[s[i]-'a']++;\n\t\tfor (i=0;i<26;i++) Ans[i]+=c0[i]*((R/n)-((L-1)/n));\n\t\tfor (i=1;i<=R%n;i++) Ans[s[i]-'a']++;\n\t\tfor (i=1;i<=(L-1)%n;i++) Ans[s[i]-'a']--;\n\t\tfor (i=0;i<26;i++) printf(\"%lld \",Ans[i]);\n\t\treturn 0;\n\t}\n\twhile (next[n]>=(n+1)/2)\n\t\tn+=n-next[n],KMP();\n\tsolve(R,+1);\n\tsolve(L-1,-1);\n\tfor (i=0;i<26;i++)\n\t\tprintf(\"%lld \",Ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=200010;\nchar s[N];\nint nxt[N];\nLL l,r;\nLL f[100][27];\nLL sum[100],ans[27];\n\nvoid getnext()\n{\n\tint n=strlen(s+1)/2,j=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile(j&&s[i]!=s[j+1]) j=nxt[j];\n\t\tif(s[i]==s[j+1]) j++;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid initfib()\n{\n\tfor(int i=2;i<=87;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t}\n}\n\nvoid gao(LL x,int fg)\n{\n\tint p;\n\tfor(p=0;p<=87;p++)\n\t\tif(sum[p]>x) break;\n\tfor(;p;p--)\n\t\tif(x>=sum[p])\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t\tans[i]+=fg*f[p][i];\n\t\t\tx-=sum[p];\n\t\t}\n\tfor(int i=1;i<=x;i++) ans[s[i]-'a']+=fg;\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tf[0][s[i]-'a']++;\n\tgetnext();\n\tsum[0]=n;sum[1]=2*(n-nxt[n/2]);\n\tfor(int i=0;i<26;i++) f[1][i]=f[0][i];\n\tfor(int i=nxt[n/2]+1;i<=n-nxt[n/2];i++)\n\t\tf[1][s[i]-'a']++;\n\tinitfib();gao(r,1);gao(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n    long long f1=num[n][c],f2=num[n][c]+num[T][c],l1=n,l2=n+T;\n    while(len>l1+l2){\n        long long t=f2;\n        f2+=f1,f1=t;\n        t=l2,l2+=l1,l1=t;\n    }\n    return f2+fib(len-l2,c);\n}\n\nlong long calc(long long len, int c) {\n    if(len<=n*2)return num[n][c]+num[len-n][c];\n    if(n%T==0) {\n        long long re=1ll*(len-n)/T*num[T][c]+num[n][c];\n        len-=n,len%=T;\n        return re+num[len][c];\n    }\n    else return fib(len,c);\n}\n\nint main() {\n    scanf(\"%s%lld%lld\",s+1,&L,&R);\n    n=strlen(s+1)/2;p[1]=0;\n    for(int j=0,i=2;i<=n;i++) {\n        for(;j&&s[j+1]!=s[i];)j=p[j];\n        if(s[j+1]==s[i])j++;\n        p[i]=j;\n    }\n    for(int i=1;i<=n;i++) {\n        for (int j=0;j<26;j++)num[i][j]=num[i-1][j];\n        num[i][s[i]-'a']++;\n    }\n    T=n-p[n];\n    for(int i=0;i<26;i++)\n\t\tprintf(\"%lld%c\",calc(R,i)-calc(L-1,i),i==25?10:32);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nint suffix[200005];\n\nlong long gcd(long long a, long long b)\n{\n    if (a%b == 0) return b;\n    else return gcd(b,a%b);\n}\n\nint find_suffix(string s)\n{\n    //find length of longest suffix of s that is also a prefix of s\n    suffix[0] = suffix[1] = 0;\n    for (int i=2; i<=s.length(); i++) {\n        int j = suffix[i-1];\n        while (true) {\n            if (s[j] == s[i-1]) {\n                suffix[i] = j+1;\n                break;\n            }\n            else if (j == 0) {\n                suffix[i] = 0;\n                break;\n            }\n            j = suffix[j];\n        }\n    }\n    //printa(suffix,s.length()+1);\n    return suffix[s.length()];\n}\n\nvector<ll> count_chars(string s)\n{\n    vector<ll> ret(26,0);\n    iter(s)\n        ret[*it-'a']++;\n    return ret;\n}\n\nvector<ll> simple_query(string period, ll r, vector<ll> &chr_cnt)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    ll num_periods = r/period.length();\n    ll remain = r % period.length();\n    for0(i,26) {\n        ret[i] = chr_cnt[i]*num_periods;\n    }\n\n    for0(i,remain) {\n        ret[period[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve_simple(string period, ll l, ll r)\n{\n    //prl(period);\n    vector<ll> chr_cnt = count_chars(period);\n    vector<ll> r_cnt = simple_query(period, r, chr_cnt);\n    vector<ll> l_cnt = simple_query(period, l-1, chr_cnt);\n    //printv(r_cnt);\n    //printv(l_cnt);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nvector<ll> hard_query(vector<vector<ll>> & chr_cnt, vector<ll> & lens, string g1, ll r)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    int lv = sz(lens)-1;\n    while (lv > 0) {\n        if (lens[lv-1] <= r) {\n            r -= lens[lv-1];\n            for0(i,26) {\n                ret[i] += chr_cnt[lv-1][i];\n            }\n        }\n        lv--;\n    }\n    //prl(r)\n    assert(r <= g1.length());\n\n    for (int i=0; r>0 && i<g1.length(); i++,r--) {\n        ret[g1[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve_hard(string g1, string g2, ll l, ll r)\n{\n    vector<vector<ll>> chr_cnt;\n    vector<ll> lens;\n    chr_cnt.pb(count_chars(g1));\n    chr_cnt.pb(count_chars(g2));\n    lens.pb(g1.length());\n    lens.pb(g2.length());\n\n    while (lens.back() < r) {\n        vector<ll> next_cnt(26,0);\n        for0(i,26) {\n            next_cnt[i] = chr_cnt[sz(chr_cnt)-1][i] + chr_cnt[sz(chr_cnt)-2][i];\n        }\n        chr_cnt.pb(next_cnt);\n        lens.pb(lens[sz(lens)-1] + lens[sz(lens)-2]);\n    }\n\n    vector<ll> r_cnt = hard_query(chr_cnt, lens, g1, r);\n    vector<ll> l_cnt = hard_query(chr_cnt, lens, g1, l-1);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"D.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    string s;\n    cin >> s;\n    s = s.substr(0,s.length()/2);\n    long long l,r;\n    cin >> l >> r;\n\n    int suf_len = find_suffix(s);\n    //prl(suf_len)\n    if (suf_len == 0) {\n        //special case where pattern is periodic with period s\n        solve_simple(s, l, r);\n    }\n    else if (suf_len >= (s.length()+1)/2 && gcd(suf_len,s.length()) > 1) {\n        //special case where s is periodic. Pattern is periodic with period repeated\n        string period = s.substr(0,gcd(suf_len, s.length()));\n        solve_simple(period, l, r);\n    }\n    else if (suf_len == s.length()-1) {\n        //s consists of all 1 character. Again pattern is periodic with that character repeated\n        solve_simple(s.substr(0,1), l, r);\n    }\n    else {\n        string T = s.substr(0,s.length()-suf_len);\n        string g1 = s+T;\n        string g2 = s+T+s;\n        solve_hard(g1, g2, l, r);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef std::valarray<LL> data;\n\nconst int N = 200005, M = 100;\n\nstd::string s, t;\nLL l, r; int p;\n\nvoid solve() {\n\tstatic int nxt[N], n = s.size();\n\tfor (int i = 1, p = nxt[0] = -1; i <= n; nxt[i++] = ++p)\n\t\twhile (p >= 0 && s[p] != s[i - 1]) p = nxt[p];\n\tint p = n; while (p << 1 > n) p = nxt[p];\n\tn -= p, s.resize(n), t = s.substr(0, n - nxt[n]);\n}\n\nLL len[M];\ndata sum[M];\n\ndata count(const std::string &s, int n = 0x3f3f3f3f) {\n\tdata ret(26);\n\tfor (int i = 0; i < n && i < s.size(); ++i) ++ret[s[i] - 'a'];\n\treturn ret;\n}\n\ndata dfs(int dep, LL n) {\n\tif (dep <= 1) return count(dep ? s : t, n);\n\tif (n <= len[dep - 1]) return dfs(dep - 1, n);\n\telse return sum[dep - 1] + dfs(dep - 2, n - len[dep - 1]);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> s >> l >> r, solve();\n\tlen[1] = s.size(), len[0] = t.size();\n\tsum[1] = count(s), sum[0] = count(t);\n\tfor (p = 1; len[p] < 1e18; ++p)\n\t\tlen[p + 1] = len[p] + len[p - 1], sum[p + 1].resize(26), sum[p + 1] = sum[p] + sum[p - 1];\n\tdata ret = dfs(p, r) - dfs(p, l - 1);\n\tfor (int i = 0; i < 26; ++i) std::cout << ret[i] << ' '; std::cout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nchar S[200010];\nint n;\n\nint fail[200010];\n\nvoid Fail(){\n\tn=strlen(S);\n\tfor(int i=1;i<n/2;++i){\n\t\tint j=fail[i-1];\n\t\twhile(j && S[j]!=S[i]) j=fail[j-1];\n\t\tif(S[j]==S[i]) ++j;\n\t\tfail[i]=j;\n\t}\n}\n\nll len[100];\nvector<ll> cnt[100];\n\nvector<ll> work(ll to){\n\tif(!to) return vector<ll>(26);\n\tvector<ll> ret(26);\n\twhile(to){\n\t\tint i=0;\n\t\tfor(i=0; len[i]; ++i) if(to < len[i]) break;\n\t\tif(!i){\n\t\t\tfor(int j=0; j<to; ++j) ret[S[j]-'a']++;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int j=0; j<26; ++j) ret[j]+=cnt[i-1][j];\n\t\tto -= len[i-1];\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%s\", S);\n\tFail();\n\tlen[0] = n/2; cnt[0].resize(26);\n\tfor(int i=0; i<n/2; ++i) cnt[0][S[i]-'a']++;\n\tcnt[1] = cnt[0]; len[1] = len[0] + n/2-fail[n/2-1];\n\tfor(int i=0; i<n/2-fail[n/2-1]; ++i) cnt[1][S[i]-'a']++;\n\t\n\tfor(int i=2;;++i){\n\t\tlen[i] = len[i-1] + len[i-2];\n\t\tif(len[i] > ll(1e18)) break;\n\t\tcnt[i].resize(26);\n\t\tfor(int j=0; j<26; ++j) cnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n\t}\n\t\n\tll L, R;\n\tread(L, R);\n\tauto vl = work(L-1), vr = work(R);\n\tfor(int i=0; i<26; ++i) printf(\"%lld \", vr[i]-vl[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string(string(s)); }\nstring to_string(bool b) { return to_string(int(b)); }\nstring to_string(char b) { return \"'\" + string(1, b) + \"'\"; }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename A>\nstring to_string(A v) {\n\tstring res = \"{\";\n\tfor (const auto& x : v) res += (res == \"{\" ? \"\" : \", \") + to_string(x);\n\treturn res + \"}\";\n}\nvoid debug() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug(Head H, Tail... T) {\n\tcerr << \" \" << to_string(H);\n\tdebug(T...);\n}\n#define db(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define db(...) 42\n#endif\ntypedef long long ll;\ntypedef long double ld;\nchar str[200005];\nvector<int> zalgo(string s) {\n\t// Maintain max r such that there is l <= i <= r with [l,r] being prefix substring\n\tint n = s.size(), l = 0, r = 0;\n\tvector<int> z(n);\n\tz[0] = n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (i > r) {\n\t\t\tl = r = i;\n\t\t\twhile (r < n && s[r - l] == s[r]) ++r;\n\t\t\tz[i] = r - l;\n\t\t\t--r;\n\t\t} else {\n\t\t\tif (z[i - l] <= r - i) z[i] = z[i - l];\n\t\t\telse {\n\t\t\t\tl = i;\n\t\t\t\twhile (r < n && s[r - l] == s[r]) ++r;\n\t\t\t\tz[i] = r - l;\n\t\t\t\t--r;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nint main() {\n\tscanf(\"%s\", str);\n\tll L, R;\n\tscanf(\"%lld%lld\", &L, &R);\n\tint n = strlen(str) / 2;\n\tstring s(str, str + n);\n\tstring t = s;\n\tauto z = zalgo(s);\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (z[i] + i >= n) {\n\t\t\tt = s.substr(0, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdb(s, t);\n\tint m = t.size();\n\tif (n % m == 0) {\n\t\tauto solve = [&](ll r, char c) {\n\t\t\tll full = 0;\n\t\t\tfor (int i = 0; i < m; ++i) full += t[i] == c;\n\t\t\tll ret = full * (r / m);\n\t\t\tfor (int i = 0; i < r % m; ++i) ret += t[i] == c;\n\t\t\treturn ret;\n\t\t};\n\t\tfor (char c = 'a'; c <= 'z'; ++c) printf(\"%lld \", solve(R, c) - solve(L - 1, c));\n\t} else {\n\t\tauto solve = [&](ll r, char c) {\n\t\t\tvector<ll> len = {n, n + m}, numc(2);\n\t\t\tfor (int i = 0; i < n; ++i) numc[0] += s[i] == c;\n\t\t\tnumc[1] = numc[0];\n\t\t\tfor (int i = 0; i < m; ++i) numc[1] += t[i] == c;\n\t\t\tfor (int i = 2;; ++i) {\n\t\t\t\tlen.push_back(0);\n\t\t\t\tnumc.push_back(0);\n\t\t\t\tlen[i] = len[i - 1] + len[i - 2];\n\t\t\t\tnumc[i] = numc[i - 1] + numc[i - 2];\n\t\t\t\tif (len[i] >= 1e18) break;\n\t\t\t}\n\t\t\tll ret = 0;\n\t\t\tfor (int i = (int)len.size() - 1; i >= 0; --i) {\n\t\t\t\tif (r <= len[i]) continue;\n\t\t\t\tret += numc[i];\n\t\t\t\tr -= len[i];\n\t\t\t}\n\t\t\tassert(0 <= r && r <= len[0]);\n\t\t\tfor (int i = 0; i < r; ++i) ret += s[i] == c;\n\t\t\treturn ret;\n\t\t};\n\t\tfor (char c = 'a'; c <= 'z'; ++c) printf(\"%lld \", solve(R, c) - solve(L - 1, c));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 9;\n\nchar s[N];\nint f[N], n, t, lim;\nusing ll = long long;\nll l, r, c[120][26], ans[26], fib[N];\n\nll Solve (ll x, int t) {\n\tll bs = x / ::t, b2 = x % ::t;\n\tbs *= t;\n\tfor (int i = 0; i < ::t; ++i) {\n\t\tans[s[i] - 'a'] += bs;\n\t\tif (i < b2) ans[s[i] - 'a'] += bs;\n\t}\n}\n\nll Solve2 (ll x, int t) {\n\tint now = lim;\n\twhile (now-- > 0) {\n\t\tif (x >= fib[now]) {\n\t\t\tfor (int i = 0; i < 26; ++i) ans[i] += c[now][i] * t;\n\t\t\tx -= fib[now], --now;\n\t\t}\n\t}\n}\n\nint main () {\n\tscanf(\"%s\", s); n = strlen(s); n >>= 1; s[n] = '\\0';\n\tscanf(\"%lld%lld\", &l, &r);\n\tfor (int i = 1, j; i < n; ++i) {\n\t\tj = f[i];\n\t\twhile (j && s[j] != s[i]) j = f[j];\n\t\tf[i + 1] = s[i] == s[j] ? j + 1 : 0;\n\t}\n\tt = n - f[n];\n\tif (n % t == 0) {\n\t\tSolve(r, 1); Solve(l - 1, -1);\n\t} else {\n\t\tfor (int i = 0; i < t; ++i) ++c[0][s[i] - 'a'];\n\t\tfor (int i = 0; i < n; ++i) ++c[1][s[i] - 'a'];\n\t\tfib[0] = t; fib[1] = n;\n\t\tfor (lim = 2; ; ++lim) {\n\t\t\tfor (int j = 0; j < 26; ++j) c[lim][j] = c[lim - 1][j] + c[lim - 2][j];\n\t\t\tif ((fib[lim] = fib[lim - 1] + fib[lim - 2]) >= 1e18) break;\n\t\t}\n\t\tSolve2(r, 1); Solve2(l - 1, -1);\n\t}\n\tfor (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tll _s=0,_t=1,S=1,T=0;\n\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\twork(r-_s*n-_t*k);\n\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\tassert(n%k);\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, phi[100009], ap[100009][26];\nlong long L, R, S[1009], P[1009], ans[30];\nchar a[400009], sir[200009];\n\nvoid add (int st, int dr, long long coef)\n{\n    for (int i=0; i<26; i++)\n        ans[i] += 1LL * coef * (ap[dr][i] - ap[st - 1][i]);\n}\nvector < pair < pair < long long, long long >, long long > > Q[109];\n\nvoid solve (int lev, long long st, long long dr, long long coef)\n{\n    if (lev == 0)\n    {\n        add (st, dr, coef);\n        return ;\n    }\n    if (dr <= S[lev - 1])\n    {\n        solve (lev - 1, st, dr, coef);\n        return ;\n    }\n    if (st > S[lev - 1])\n    {\n        solve (lev - 1, st - S[lev - 1], dr - S[lev - 1], coef);\n        return ;\n    }\n    solve (lev - 1, st, S[lev - 1], coef);\n    solve (lev - 1, 1, dr - S[lev - 1], coef);\n}\n\nvoid prop (int lev)\n{\n    for (auto it : Q[lev])\n    {\n        long long st = it.first.first, dr = it.first.second, coef = it.second;\n        if (dr <= S[lev - 1]) Q[lev - 1].push_back ({{st, dr}, coef});\n        else\n        if (st > S[lev - 1]) Q[lev - 1].push_back ({{st - S[lev - 1], dr - S[lev - 1]}, coef});\n        else\n        {\n            Q[lev - 1].push_back ({{st, S[lev - 1]}, coef});\n            Q[lev - 1].push_back ({{1, dr - S[lev - 1]}, coef});\n        }\n    }\n}\n\nvoid unify (int lev)\n{\n    vector < pair < long long, long long > > norm;\n    for (auto it : Q[lev])\n        norm.push_back ({it.first.first, +it.second}), norm.push_back ({it.first.second + 1, -it.second});\n/*    printf (\"before: \");\n    for (auto it : Q[lev])\n        printf (\"{[%lld, %lld] %lld} \", it.first.first, it.first.second, it.second);\n    printf (\"\\n\");*/\n\n    Q[lev].clear ();\n    sort (norm.begin (), norm.end ());\n    long long lst = -1, curr = 0;\n    for (int i=0; i<norm.size (); i++)\n    {\n        int j;\n        for (j=i; j<norm.size (); j++)\n            if (norm[j].first != norm[i].first) break;\n        j --;\n        for (int k=i; k<=j; k++)\n            curr += norm[k].second;\n        if (curr != 0 && j + 1 < norm.size ())\n            Q[lev].push_back ({{norm[i].first, norm[j + 1].first - 1}, curr});\n        i = j;\n    }\n/*    printf (\"after: \");\n    for (auto it : Q[lev])\n        printf (\"{[%lld, %lld] %lld} \", it.first.first, it.first.second, it.second);\n    printf (\"\\n\");*/\n}\n\nvoid prnt (int lev)\n{\n    printf (\"now: \");\n    for (auto it : Q[lev])\n        printf (\"{[%lld, %lld] %lld} \", it.first.first, it.first.second, it.second);\n    printf (\"\\n\");\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%s\\n\", sir + 1), N = strlen (sir + 1) / 2;\nscanf (\"%lld %lld\", &L, &R);\nfor (int i=1; i<=N; i++)\n{\n    for (int j=0; j<26; j++)\n        ap[i][j] = ap[i - 1][j];\n    a[i] = sir[i], ap[i][a[i] - 'a'] ++;\n}\nint k = 0;\nfor (int i=2; i<=N; i++)\n{\n    while (k && sir[i] != sir[k + 1]) k = phi[i];\n    k += (sir[i] == sir[k + 1]);\n    phi[i] = k;\n}\nS[0] = N, P[0] = phi[N];\nint steps = 0;\nwhile (S[steps] <= R)\n{\n    steps ++;\n//    for (int i=oldS + 1; i<=2 * oldS - P; i++)\n  //      a[i] = a[i - oldS];\n    S[steps] = 2LL * S[steps - 1] - P[steps - 1], P[steps] = S[steps - 1] - P[steps - 1];;\n}\n//solve (steps, L, R, 1);\nQ[steps].push_back ({{L, R}, 1});\nfor (int i=steps; i>0; i--)\n    prop (i), unify (i - 1);\nfor (auto it : Q[0])\n    add (it.first.first, it.first.second, it.second);\nfor (int i=0; i<26; i++)\n    printf (\"%lld%c\", ans[i], \" \\n\"[i == 25]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define repd(i,n) for(int (i)=n-1;(i)>=0;i--)\n#define REPD(i,n) for(int (i)=n;(i)>0;i--) \n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int Maxn=200005;\nconst int Maxm=30;\nconst int Hash=31;\nint n,match;\nstring s;\nll l,r;\nint hash[Maxn],power[Maxn];\nint cnt[Maxn][Maxm];\nll ans[Maxm];\nvector<ll>L,R;\n\nbool same(int pos){\n\tint k1=hash[pos-1],k2=hash[n-1]-hash[n-1-pos]*power[pos];\n\treturn k1==k2;\n}\n\nvector<ll> add_ans(vector<ll>a,vector<ll>b){\n\trep(i,26)a[i]+=b[i];\n\treturn a;\n}\n\npair<ll,vector<ll> > solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest){\n\tvector<ll>res(26);\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_ans(L,R);\n\t\tpair<ll,vector<ll> >ret=solve(l_len+r_len,sum,l_len,L,rest);\n\t\trest=ret.fi;\n\t\tres=add_ans(res,ret.se);\n\t}\n\tif(l_len<=rest){\n\t\tres=add_ans(res,L);\n\t\trest-=l_len;\n\t}\n\treturn mk(rest,res);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=sz(s);\n\n\thash[0]=s[0]-'a';power[0]=1;\n\tREP(i,n-1)hash[i]=hash[i-1]*Hash+s[i]-'a',power[i]=power[i-1]*Hash;\n\tREP(i,n-1)if(same(i))match=max(match,i);\n\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(j==s[i]-'a')cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\n\tif(match==0){\n\t\trep(i,26){\n\t\t\tans[i]+=(ll)cnt[n-1][i]*(ll)(r/(ll)n)+(ll)cnt[r%(ll)n][i];\n\t\t\tif((l-1)>=0)ans[i]-=(ll)cnt[n-1][i]*(ll)((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tL.resize(26);R.resize(26);\n\t\trep(i,26)R[i]=cnt[match-1][i];\n\t\trep(i,26)L[i]=cnt[n-1][i]-cnt[match-1][i];\n\t\tpair<ll,vector<ll> >ans_R=solve(n-match,L,match,R,r);\n\t\tpair<ll,vector<ll> >ans_L=solve(n-match,L,match,R,l-1);\n\t\trep(i,26){\n\t\t\tans[i]+=ans_R.se[i]+cnt[ans_R.fi][i];\n\t\t\tans[i]-=ans_L.se[i]+cnt[ans_L.fi][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}\n/*\nvgxgpuamkvgxgvgxgpuamkvgxg\n1 1000000000000000000\n*/ "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif((n+n)%m==0){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=1;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstring S; long long l, r, n, SS, G = -1;\nlong long dfs(long long u) {\n\tif (u == 0)return 0;\n\tlong long P = 0, t = u;\n\tfor (int i = 1; i <= G; i++) {\n\t\tif (i != G)P += (u - (u / 2))*(n - i);\n\t\telse P += u*(n - i);\n\t\tu /= 2;\n\t}\n\tif (G == 0)return u*n;\n\t\n\tlong long Y = 1;\n\tif (G <= 60)Y += ((t - 1) / (1LL << G));\n\treturn P + Y;\n}\nvector<long long> solve(long long u) {\n\tvector<long long>F(26);\n\tlong long L = 0, R = u / n + 2, M; R *= 2;\n\twhile (true) {\n\t\tM = (L + R) / 2;\n\t\tlong long p1 = dfs(M), p2 = dfs(M + 1);\n\t\tif (p1 <= u && p2 > u)break;\n\t\tif (p1 > u)R = M; else L = M;\n\t}\n\tlong long p3 = dfs(M);\n\tif (G <= 60 && M % (1LL << G) == 0 && p3 != u) { F[S[0] - 'a']++; p3++; }\n\tfor (int i = 1; i < (u - p3) + 1; i++)F[S[i] - 'a']++;\n\n\tfor (int i = 1; i < n - G; i++)F[S[i] - 'a'] += M;\n\tlong long r = M;\n\tfor (int i = n - 1; i >= n - G; i--) {\n\t\tlong long T = (r - (r / 2));\n\t\tif (i == n - G)T = r;\n\t\tF[S[i] - 'a'] += (M - T);\n\t\tr /= 2;\n\t}\n\tlong long Y = 1;\n\tif (G <= 60)Y += ((M - 1) / (1LL << G));\n\tF[S[0] - 'a'] += Y;\n\treturn F;\n}\nint main() {\n\tcin >> S >> l >> r; n = S.size();\n\tif (S[0] != S[S.size() - 1])G = 0;\n\telse {\n\t\tfor (int i = 0; i < S.size() - 1; i++) { if (S[i] != S[i + 1])G = -2; }\n\t\tif (G == -2) {\n\t\t\tG = 0;\n\t\t\tfor (int i = S.size() - 1; i >= 0; i--) {\n\t\t\t\tif (S[i] == S[S.size() - 1])G++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] != S[S.size() - 1 - i]) {\n\t\t\tG = i; break;\n\t\t}\n\t}\n\tif (G == -1) {\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (i)cout << \" \";\n\t\t\tif (S[0] == ('a' + i))cout << (r - l + 1);\n\t\t\telse cout << \"0\";\n\t\t}\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\tvector<long long>H = solve(l - 1);\n\tvector<long long>I = solve(r);\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (i)cout << ' ';\n\t\tcout << I[i] - H[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint z[200005];\nlong long l,r,num[200005][26];\nint n,p;\nstring s;\nvoid zfunc()\n{\n\tint l=0,r=0;\n\tmemset(z,0,sizeof(z));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<=r)z[i]=min(z[i-l],r-i+1);\n\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;\n\t\tif(i+z[i]-1>r)\n\t\t{\n\t\t\tl=i;\n\t\t\tr=i+z[i]-1;\n\t\t}\n\t}\n}\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n//\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tif(n%p==0)\n\t{\n\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n\t\tx%=(long long)p;\n\t\txx+=num[x][y];\n\t\treturn xx;\n\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size();\n\tn/=2;\n\ts=s.substr(0,n);\n\tzfunc();\n\tp=n;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(z[i]+i==n)\n\t\t{\n\t\t\tp=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]=num[i-1][j];\n\t\tnum[i][s[i-1]-'a']++;\n\t}\n//\tcout<<sol(10,0)<<endl;\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\n\n// Z algorithm (length of longest common prefix for s[0:N] & s[i:N] for each i)\n// Complexity: O(N)\n// <http://snuke.hatenablog.com/entry/2014/12/03/214243>\nvector<int> z_algorithm(const string &s) {\n    vector<int> ans(s.size());\n    ans[0] = s.size();\n    int i = 1, j = 0;\n    while (i < (int)s.size()) {\n        while (i + j < (int)s.size() && s[j] == s[i + j]) ++j;\n        ans[i] = j;\n        if (!j) {\n            ++i;\n            continue;\n        }\n        int k = 1;\n        while (i + k < (int)s.size() && k + ans[k] < j) ans[i + k] = ans[k], ++k;\n        i += k;\n        j -= k;\n    }\n    return ans;\n}\n\nvector<lint> C2(string S) {\n    vector<lint> ret(26);\n    for (auto c : S) ret[c - 'a']++;\n    for (auto &d : ret) d /= 2;\n    return ret;\n}\n\nstring Next(string S) {\n    vector<int> z = z_algorithm(S);\n    int r = S.length();\n    FOR(i, S.length() / 2 + 1, S.length()) if (z[i] + i == S.length()) r = min(r, i);\n    return  S.substr(0, r) + S.substr(0, r);\n}\n\nmap<lint, vector<lint>> mp;\n\nstring S, T;\nvector<lint> solve(lint L) {\n    vector<lint> ret(26);\n    while (L > T.length())\n    {\n        auto itr = prev(mp.upper_bound(L));\n        REP(d, 26) ret[d] += itr->second[d];\n        L -= itr->first;\n    }\n    REP(i, L) ret[T[i] - 'a']++;\n    return ret;\n}\n\nint main()\n{\n    lint L, R;\n    cin >> S >> L >> R;\n    T = Next(S);\n    vector<lint> v1 = C2(S), v2 = C2(T);\n    lint l1 = S.length() / 2, l2 = T.length() / 2;\n    mp[l1] = v1;\n    mp[l2] = v2;\n\n    while (l2 < 2e18) {\n        swap(l1, l2);\n        l2 += l1;\n        swap(v1, v2);\n        REP(i, 26) v2[i] += v1[i];\n        mp[l2] = v2;\n    }\n\n    vector<lint> ret1 = solve(L - 1), ret2 = solve(R);\n    REP(d, 26) printf(\"%lld \", ret2[d] - ret1[d]);\n    puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\tassert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\trd = l / z;\n\t\t\trr = l % z;\n\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\trep(i, rr)ans[s[i] - 'a']--;\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (len <= n * 2) return num[n][c] + num[len - n][c];\n    long long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    while (len > l1 + l2) {\n        long long t = f2;\n        f2 += f1, f1 = t;\n        t = l2, l2 += l1, l1 = t;\n    }\n    return f2 + fib(len - l2, c);\n}\n\nlong long calc(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (n % T == 0) {\n        long long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n        len -= n, len %= T;\n        return re + num[len][c];\n    }\n    else return fib(len, c);\n}\n\nint main() {\n    scanf(\"%s%lld%lld\",s+1,&L,&R);\n    n=strlen(s+1)/2;p[1]=0;\n    for(int j=0,i=2;i<=n;i++) {\n        for(;j&&s[j+1]!=s[i];)j=p[j];\n        if(s[j+1]==s[i])j++;\n        p[i]=j;\n    }\n    for(int i=1;i<=n;i++) {\n        for (int j=0;j<26;j++)num[i][j]=num[i-1][j];\n        num[i][s[i]-'a']++;\n    }\n\tif(p[n])T=p[n];\n    else T=n-p[n];\n    for(int i=0;i<26;i++)\n\t\tprintf(\"%lld%c\",calc(R,i)-calc(L-1,i),i==25?10:32);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 500006\nusing namespace std;\nchar s[N];long long f[1006],g[1006][26],a[26],l,r,x;\nlong long n,p,t,v[26],height[N],sa[N],fuckyouatcoder[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\nvoid SA()\n{\n\tfor(long long i=1;i<=n;i++)cntA[(long long)s[i]]++;\n\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(long long i=n;i;i--)sa[cntA[(long long)s[i]]--]=i;\n\tfuckyouatcoder[sa[1]]=1;\n\tfor(long long i=2;i<=n;i++){\n\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t}\n\tfor(long long l=1;fuckyouatcoder[sa[n]]!=n;l<<=1){\n\t\tfor(long long i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\tcntA[A[i]=fuckyouatcoder[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?fuckyouatcoder[i+l]:0)]++;\n\t\t}\n\t\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(long long i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(long long i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\tfuckyouatcoder[sa[1]]=1;\n\t\tfor(long long i=2;i<=n;i++){\n\t\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t\t}\n\t}\n\tlong long tot=0;\n\tfor(long long i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[fuckyouatcoder[i]-1]+tot])tot++;\n\t\theight[fuckyouatcoder[i]]=tot;\n\t}\n\tp=n;long long mi=N;\n\tfor(long long i=fuckyouatcoder[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(long long i=fuckyouatcoder[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(long long w,long long F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(long long i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(long long i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);s[n+1]='#';SA();s[n+1]=s[1];\n\tfor(long long i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(long long i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(long long i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(long long i=(l-n-1)%p+1;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(long long i=1;i<=(r-1)%p+1;i++)a[s[i]-97]++;\n\t\t\tfor(long long i=0;i<26;i++)a[i]+=1LL*v[i]*((r-1)/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(long long i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(long long i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(long long i=0;i<26;i++)g[t][i]=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(long long i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(int _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(int _##i = (t), i = (f); i <  _##i; i++)\n#define downto(f, t, i)  for(int _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(int _##i = (t), i = (f); i >  _##i; i--)\ntypedef long double ld;\n#define long long long\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n    #define debug true\n    #define ln << endl\n#else\n    #define debug false\n    #define ln << '\\n'\n#endif\n#define tb << '\\t'\n#define sp << ' '\n\nconst int MOD = 1e9+7;\n\nnamespace sa {\nconstexpr unsigned sINT = sizeof(int);\n\ninline void induced_sort(const int* const s, int n1, int* const sa, int** const bucref, int** const bucref1,\nconst int* const is_stype, const int* const lcount, int C, const int* lms, int clms) {\n    int n = n1 - 1;\n    memcpy(bucref1, bucref, sizeof(int*) * (C + 1));\n    rtimes(clms, l) {\n        int/*s.i*/j = lms[l];\n        *--bucref1[s[j]+1] = j;\n    }\n\n    memcpy(bucref1, bucref, sizeof(int*) * (C + 1));\n    times(n1, a) if(sa[a] > 0) {\n        int/*s.i*/t = sa[a]-1;\n        if(is_stype[t]) continue;\n        *bucref1[s[t]]++ = t;\n    }\n\n    times(C, c) {\n        int* d = bucref[c] + lcount[c];\n        memset(d, -1, sINT * (bucref[c+1] - d));\n    }\n\n    memcpy(bucref1, bucref + 1, sizeof(int*) * C);\n    rtimes(n1, a) if(sa[a] > 0) {\n        int/*s.i*/t = sa[a]-1;\n        if(!is_stype[t]) continue;\n        *--bucref1[s[t]] = t;\n    }\n    sa[0] = n;\n}\n\n/*                       c[i]      i#           i[a]                a[c]                 a[c]*/\nvoid sa_is(const int* const s, int n1, int* const sa, int** const bucref, int** const bucref1,\n/*          a#[c]            i[l]  l[i](L:0,S\\LMS:-1)                   i[l]*/\nint* const lcount, int* const lms, int* const invlms1, int* const lms_sorted, int C) {\n    int n = n1 - 1;\n    if(debug) { times(n, j) assert(s[j] != 0); assert(s[n] == 0); }\n    switch(n) {\n        case 0: sa[0]=0; return; case 1: sa[0]=1; sa[1]=0; return;\n        case 2: sa[0]=2; if(s[0] < s[1]) { sa[1]=0; sa[2]=1; } else { sa[1]=1; sa[2]=0; } return;\n        case 3: sa[0]=3;\n            int a = s[0]-s[1], b = s[1]-s[2], c = s[2]-s[0];\n            if(a > 0) {\n                if(c > 0)    { sa[1]=1; sa[2]=0; sa[3]=2; return; }\n                if(b < 0)    { sa[1]=1; sa[2]=2; sa[3]=0; return; }\n            } else if(b < 0) { sa[1]=0; sa[2]=1; sa[3]=2; return; }\n            if(a < 0)\n                if(c > 0)    { sa[1]=0; sa[2]=2; sa[3]=1; return; }\n                else         { sa[1]=2; sa[2]=0; sa[3]=1; return; }\n            sa[1]=2; sa[2]=1; sa[3]=0; return;\n    }\n\n    times(n1, j) ++bucref[s[j]+1];\n    bucref[0] = sa;\n    times(C, c) bucref[c+1] += (int)bucref[c] / sINT;\n\n/********* check S-Type or L-Type *********/\n    invlms1[n] = -1;\n    rtimes(n, j) invlms1[j] = s[j] != s[j+1] ? -(s[j] < s[j+1]) : invlms1[j+1];\n    times(n1, j) if(!invlms1[j]) ++lcount[s[j]]; // LType\n\n/********* list up LMS *********/\n    int/*l*/clms = 0;\n    upto(1, n, j) if(!invlms1[j-1] && invlms1[j]) { // j-1: LType, j: SType\n        lms[clms] = j;\n        ++clms;\n        invlms1[j] = clms;\n        ++j; //: LS[?]\n    }\n\n/********* rough induced sort *********/\n    induced_sort(s, n1, sa, bucref, bucref1, invlms1, lcount, C, lms, clms);\n    int lsi = 0;\n    times(n1, a) if(sa[a] >= 0 && invlms1[sa[a]] > 0 /*LMS*/) lms_sorted[lsi++] = sa[a];\n    // assert(lsi == clms);\n\n/********* SA-IS LMS-suffix *********/\n    int lq = 0;\n    int* const/*lms.c[l]*/lms_syms = sa;\n    times(clms, l) {\n        int j = lms_sorted[l], m1 = invlms1[j];\n        if(l > 1) {\n            int i = lms_sorted[l-1];\n            if(lms[m1] - j == lms[invlms1[i]] - i) {\n                int k = lms[m1] - j;\n                ++lq;\n                upto(0, k, h) if(s[j+h] != s[i+h]) { --lq; break; }\n            }\n        }\n        lms_syms[m1-1] = l - lq;\n    }\n    int* const bc = bucref[C];\n    int*/*l[e]*/lms_sa = sa + n1;\n    sa_is(lms_syms, clms, lms_sa, bucref + C, bucref1, lcount + C,\n        lms + clms, invlms1 + n1, lms_sorted + clms, clms - lq);\n    bucref[C] = bc;\n\n/********* strict induced sort *********/\n\n    memset(sa, -1, n1 * sINT); // fill(sa, sa + n1, -1);\n\n    times(clms, e) lms_sa[e] =  lms[lms_sa[e]];\n    /* now lms_sa is: i[e] */\n    induced_sort(s, n1, sa, bucref, bucref1, invlms1, lcount, C, lms_sa, clms);\n}\n\nbool inited = false;\nint *saG, **brG, **br1G, *lcG, *lmsG, *il1G, *lsoG;\nvoid init(int N1, int C) { // memory used: (8.5N+3C+3)*4bytes\n    if(inited) return; inited = true;\n    saG = new int[N1*2]; brG = new int*[C+N1+1]; br1G = new int*[max(N1/2,C)+1];\n    lcG = new int[C+N1+1]; lmsG = new int[N1]; il1G = new int[N1*2]; lsoG = new int[N1];\n}\nvoid is_k(const int* const s, int n1, int c) {\n    bool gs = false;\n    if(n1 * 3 < c) {\n        gs = n1 < 50;\n        if(!gs) {\n            int b = s[n1/3 + 1], a = 0;\n            times(n1, i) a += s[i] == b;\n            gs = a < n1 / a;\n        }\n    }\n    if(debug) assert(inited);\n    if(gs) {\n        times(n1, i) saG[i] = i;\n        sort(saG, saG + n1, [&](int i, int j) {\n            if(i == j) return false;\n            while(s[i] == s[j]) { ++i; ++j; }\n            return s[i] < s[j];\n        });\n    } else {\n        memset(saG, -1, n1*2*sINT); memset(brG, 0, (n1+c+1)*sINT); memset(lcG, 0, (n1+c+1)* sINT);\n        sa_is(s, n1, saG, brG, br1G, lcG, lmsG, il1G, lsoG, c);\n    }\n}\nvoid done() { inited = false; if(debug) cerr << \"WARNING: void sa::done() does nothing.\" << endl; }\n}\n\nint s[200005], N;\nmap<long, array<long, 26>> c;\n\nsigned main() { // long: 64bit\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n\n    string S; cin >> S;\n    N = S.size();\n    long L, R; cin >> L >> R;\n\n    sa::init(N + 1, 27);\n    times(N, i) {\n        s[i] = S[i] - 'a' + 1;\n    }\n    s[N] = 0;\n    sa::is_k(s, N + 1, 27);\n    long p0;\n    times(N+1, i) if(sa::saG[i] == 0) {\n        while(i >= 0 && sa::saG[--i] <= N / 2);\n        if(i >= 0)\n            p0 = sa::saG[i];\n        else\n            p0 = N;\n        break;\n    }\n    if(debug) cout << p0 ln;\n\n    times(26, i) c[0][i] = 0;\n    times(N, j) times(26, i) {\n        c[-j-1][i] = c[-j][i] + (S[j] == 'a' + i);\n    }\n    {\n        long p2 = p0, q2 = N, p1 = p2 + q2 / 2, q1 = p2 * 2;\n        times(26, i) {\n            c[-p1][i] = c[-p2][i] + c[-q2][i] / 2;\n            c[-q1][i] = c[-p2][i] * 2;\n        }\n        while(q1 < R) {\n            long p = p1 + p2, q = q1 + q2;\n            times(26, i) {\n                c[-p][i] = c[-p1][i] + c[-p2][i];\n                c[-q][i] = c[-q1][i] + c[-q2][i];\n            }\n            p2 = p1; p1 = p;\n            q2 = q1; q1 = q;\n        }\n    }\n    if(debug) {\n        for(const auto& x: c) {\n            cout << x.first tb;\n            times(26, i) cout << x.second[i] sp;\n            cout ln;\n        }\n    }\n\n    long l[26], r[26];\n    times(26, i) l[i] = r[i] = 0;\n    if(debug) cout << \"L\\n\";\n    while(L > 0) {\n        auto x = c.lower_bound(-L);\n        L += x->first;\n        times(26, i) l[i] += x->second[i];\n        if(debug) {\n            cout << L tb;\n            times(26, i) cout << l[i] sp;\n            cout ln;\n        }\n    }\n    if(debug) cout << \"R\\n\";\n    ++R;\n    while(R > 0) {\n        auto x = c.lower_bound(-R);\n        R += x->first;\n        times(26, i) r[i] += x->second[i];\n        if(debug) {\n            cout << R tb;\n            times(26, i) cout << r[i] sp;\n            cout ln;\n        }\n    }\n\n    times(26, i) {\n        if(i) cout sp;\n        cout << r[i] - l[i];\n    }\n    cout ln;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll len[200], cnt[200][26];\nint sum0[26][200001], sum1[26][400001];\n\nll rec(int n, ll l, ll r, int c){\n\tif(l >= len[n] || r <= 0) return 0;\n\tif(l <= 0 && len[n] <= r) return cnt[n][c];\n\t\n\tl = max(l, 0ll); r = min(r, len[n]);\n\t\n\tif(n <= 1){\n\t\tif(n == 1) return sum1[c][r] - sum1[c][l];\n\t\treturn sum0[c][r] - sum0[c][r];\n\t}\n\treturn rec(n - 1, l, r, c) + rec(n - 2, l - len[n - 1], r - len[n - 1], c);\n}\n\nint* buildFail(const string &s){\n\tint n = s.size();\n\tint *p = new int[n];\n\tp[0] = 0;\n\tfor (int i = 1; i < n; ++i){\n\t\tp[i] = p[i - 1];\n\t\twhile (p[i] > 0 && s[p[i]] != s[i]) p[i] = p[p[i] - 1];\n\t\tif (s[p[i]] == s[i]) p[i]++;\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tstring s;\n\tll l, r; cin >> s >> l >> r; l--;\n\tint n = s.size() / 2;\n\tint *f = buildFail(s.substr(0, n));\n\tint p = n - f[n - 1];\n\t\n\tif(n % p == 0){\n\t\tassert(0);\n\t}\n\telse{\n\t\tstring t = s.substr(0, n) + s.substr(0, p);\n\t\tlen[0] = n;\n\t\tlen[1] = t.size();\n\t\trep(i, 26){\n\t\t\trep(j, n)        sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\trep(j, t.size()) sum1[i][j + 1] = sum1[i][j] + (t[j] == 'a' + i);\n\t\t\tcnt[0][i] = sum0[i][n];\n\t\t\tcnt[1][i] = sum1[i][t.size()];\n\t\t}\n\t\tint m = 1;\n\t\tfor(; len[m] < r; m++){\n\t\t\tlen[m + 1] = len[m] + len[m - 1];\n\t\t\trep(i, 26) cnt[m + 1][i] = cnt[m][i] + cnt[m - 1][i];\n\t\t}\n\t\trep(i, 26) cout << rec(m, l, r, i) << (i == 25 ? \"\\n\": \" \");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=2e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nclass alphs{\npublic:\n\tarray<llint,26> kaz;\n\talphs(){for(int i=0;i<26;i++){kaz[i]=0;}}\n\talphs& operator +=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]+=other.kaz[i];}\n\t\treturn (*this);\n\t}\n\talphs& operator -=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]-=other.kaz[i];}\n\t\treturn (*this);\n\t}\n};\nvector<llint> retu;\nvector<alphs> mowa;\nstring str;\nvoid retus(void){\n\tllint k=retu.back();\n\talphs a=mowa.back();\n\twhile(-1){\n\t\tk+=retu[retu.size()-2];retu.pub(k);\n\t\ta+=mowa[mowa.size()-2];mowa.pub(a);\n\t\tif(retu.back()>big){return;}\n\t}\n}\nalphs solve(llint x,llint fu){\n\talphs ans;\n\tif(fu==0||fu==1){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[str[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(x<retu[fu-1]){return solve(x,fu-1);}\n\tans=mowa[fu-1];\n\tans+=solve(x-retu[fu-1],fu-2);\n\treturn ans;\n}\n\nint main(void){\n\tllint l,r,n,i,j;//p r p の最初のp\n\tcin>>str;n=str.size();\n\tcin>>l>>r;\n\talphs it;n/=2;\n\tfor(i=0;i<n;i++){it.kaz[str[i]-'a']++;}\n\tmowa.pub(it);\n\tretu.pub(n);\n\tfor(j=0;j<n;j++){str.pob();}\n\tllint ueha=0;\n\tllint siha=0;\n\tconst llint ueka=101;\n\tllint uegen=1;\n\tllint iti=n;\n\tfor(i=1;i<n;i++){//上と下が良い数\n\t\tueha+=(str[i-1]-'a')*uegen;ueha%=mod;\n\t\tuegen*=ueka;uegen%=mod;\n\t\tsiha*=ueka;\n\t\tsiha+=(str[n-i]-'a');\n\t\tsiha%=mod;\n\t\tif(ueha==siha){iti=i;}\n\t}\n\tfor(j=0;j<n-iti;j++){\n\t\tstr.pub(str[j]);\n\t\tit.kaz[str[j]-'a']++;\n\t}\n\tmowa.pub(it);\n\tretu.pub(str.size());\n\tretus();\n\tauto ans=solve(r,retu.size());\n\tans-=solve(l-1,retu.size());\n\tfor(i=0;i<26;i++){cout<<ans.kaz[i]<<\" \";}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200000+10;\nconst ll inf=1000000000000000000;\nchar s[maxn];\nll len[1000],nt[1000],cnt1[1000][27],cnt2[1000][27],o[27],ans[27];\nint nxt[maxn];\nint i,j,k,t,n,m,tot,top;\nll l,r;\nvoid kmp(){\n\tj=0;\n\tfo(i,2,n){\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif (s[j+1]==s[i]) j++;\n\t\tnxt[i]=j;\n\t}\n}\nvoid work(ll n,int f){\n\tint i,j;\n\tfd(i,top,1)\n\t\tif (n>=len[i]){\n\t\t\tfo(j,0,25) ans[j]+=f*(cnt1[i][j]*2+cnt2[i][j]);\n\t\t\tn-=len[i];\n\t\t}\n\tif (n>=len[0]){\n\t\tfo(j,0,25) ans[j]+=f*o[j];\n\t\tn-=len[0];\n\t}\n\tfo(i,1,n) ans[s[i]-'a']+=f;\n}\nvoid solve(ll n,int f){\n\tint i,j;\n\tfo(i,0,25) ans[i]+=(ll)f*(n/tot)*o[i];\n\tn%=tot;\n\tfo(i,1,n) ans[s[i]-'a']+=f;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tn/=2;\n\tkmp();\n\tif (n%(n-nxt[n])){\n\t\tfo(i,1,nxt[n]) cnt1[0][s[i]-'a']++;\n\t\tfo(i,nxt[n]+1,n-nxt[n]) cnt2[0][s[i]-'a']++;\n\t\tfo(i,1,n) o[s[i]-'a']++;\n\t\tlen[0]=n;nt[0]=nxt[n];\n\t\tif (nxt[n]>=(n+1)/2){\n\t\t\ttop++;\n\t\t\tlen[top]=len[top-1]*2-nt[top-1];\n\t\t\tnt[top]=len[top-1]-nt[top-1];\n\t\t\tfo(i,1,nt[top]) cnt1[top][s[i]-'a']++;\n\t\t\tfo(i,n-nxt[n]+1,n) cnt2[top][s[i]-'a']++;\n\t\t}\n\t\twhile (len[top]<inf){\n\t\t\ttop++;\n\t\t\tlen[top]=len[top-1]*2-nt[top-1];\n\t\t\tnt[top]=len[top-1]-nt[top-1];\n\t\t\tfo(i,0,25){\n\t\t\t\tcnt1[top][i]=cnt1[top-1][i]+cnt2[top-1][i];\n\t\t\t\tcnt2[top][i]=cnt1[top-1][i];\n\t\t\t}\n\t\t}\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t\tfo(i,0,25) printf(\"%lld \",ans[i]);\n\t}\n\telse{\n\t\ttot=n-nxt[n];\n\t\tfo(i,1,tot) o[s[i]-'a']++;\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t\tfo(i,0,25) printf(\"%lld \",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nvoid init() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tn-=j;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tinit();s[n]='\\0';\n\tprintf(\"%s\\n\",s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\tdwn(j,m,1) if(r>=g[j][26]&&r>n) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m,1) if(l>=g[j][26]&&r>n) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t//\tprintf(\"%d %d\\n\",l,r);\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n/*\nabbaabba\n3 52523523\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll L,ll R) ;\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tif(V<=S[0].size()) {\n\t\tFOR(i,V) ret[S[0][i]-'a']++;\n\t}\n\telse {\n\t\tfor(i=0;i<100;i++) {\n\t\t\tif(V==cnt[i][26]) {\n\t\t\t\tFOR(j,26) ret[j]=cnt[i][j];\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif(V>=cnt[i][26] && V<cnt[i+1][26]) {\n\t\t\t\tll dif=cnt[i][26]-cnt[i-1][26];\n\t\t\t\tret=hoge3(V-cnt[i-1][26]);\n\t\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<ll> hoge2(ll L,ll R) {\n\tvector<ll> RR=hoge3(R);\n\tvector<ll> LL=hoge3(L-1);\n\tint i;\n\tFOR(i,26) RR[i]-=LL[i];\n\treturn RR;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tRR=hoge2(L,R);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i],(i==25)?'\\n':' ');\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\n#define rl rd<LL>\nusing namespace std;\ntypedef long long LL;\nconst int maxN = 2e5 + 7;\nconst int maxC = 26;\nconst int maxM = 127;\nconst LL INF = 1e18;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nchar s[maxN];\nint n, len, t;\nint nx[maxN];\nLL occ[maxC];\nLL L, R;\n\nvoid kmp() {\n\tnx[1] = 0; int i, j;\n\tfor (i = 2, j = 0; i <= n; ++ i) {\n\t\twhile (j && s[j+1] != s[i]) j = nx[j];\n\t\tif (s[j+1] == s[i]) ++ j;\n\t\tnx[i] = j;\n\t}\n}\n\nvoid solve1(LL len, LL kd) {\n\tLL tms = len / t, res = len % t;\n\trep (i, 1, t) occ[s[i] - 'a'] += kd * (tms + (i <= res));\n}\n\nnamespace solve2 {\n\tLL f[maxM][maxC], len[maxM], Top;\n\t\n\tvoid init() {\n\t\tlen[1] = t; rep (i, 1, t) ++ f[1][s[i] - 'a'];\n\t\tlen[0] = n - 2 * t; rep (i, t+1, n-t) ++ f[0][s[i] - 'a'];\n\t\tFor (i, 2, maxM) {\n\t\t\tlen[i] = len[i-1] + len[i-2];\n\t\t\tTop = i;\n\t\t\tFor (j, 0, maxC) f[i][j] = f[i-1][j] + f[i-2][j];\n\t\t\tif (len[i] > INF) break;\n\t\t}\n\t}\n\n\tvoid dfs(int p, LL l, LL kd) {\n\t\tif (l <= 0) return;\n\t\tassert(l <= len[p]);\n\t\tif (l == len[p]) {\n\t\t\tFor (i, 0, 26) occ[i] += kd * f[p][i];\n\t\t\treturn;\n\t\t}\n\t\tif (p == 0 || p == 1) {\n\t\t\tint bg = p * t;\n\t\t\trep (i, 1, l) occ[s[bg+i] - 'a'] += kd;\n\t\t\treturn;\n\t\t}\n\t\tdfs(p-1, min(l, len[p-1]), kd);\n\t\tdfs(p-2, l - len[p-1], kd);\n\t}\n\n\tvoid work(LL l, LL kd) {\n\t\tdfs(Top, l, kd);\n\t}\n}\n\nint main() {\n\n\tscanf(\"%s\", s+1);\n\tL = rl(), R = rl();\n\tn = strlen(s+1) >> 1;\n\tlen = (n + 1) >> 1;\n\tkmp();\n\t\n\tt = n - nx[n];\n\tif (n % t == 0) solve1(R, 1), solve1(L-1, -1);\n\telse {\n\t\tfor (t = nx[n]; t >= len; t = nx[t]);\n\t\tsolve2::init(), solve2::work(R, 1), solve2::work(L-1, -1);\n\t}\n\n\tFor (i, 0, 26) printf(\"%lld%c\", occ[i], \" \\n\"[i == 25]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\n\nstatic const int MAXS = 100000 + 10;\nLL w[MAXS][26];\n\nLL fib(int id, LL order ,int n, int k) {\n    if (order <= n) return w[order][id];\n    if (order <= 2*n) return w[n][id] + w[order-n][id];\n    LL f1 = w[n][id];\n    LL f2 = w[n][id] + w[k][id];\n    LL x1 = n;\n    LL x2 = n + k;\n    while (x1 + x2 < order) {\n        LL tmp = f2;\n        f2 = f2 + f1;\n        f1 = tmp;\n        tmp = x2;\n        x2 = x1 + x2;\n        x1 = tmp;\n    }\n    return f2 + fib(id, order - x2, n, k);\n\n}\n\n\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int n = s.size() >> 1;\n    LL left, right;\n    cin >> left >> right;\n    memset(w, 0, sizeof(w));\n    vector<int> next(n, 0);\n    for (int i = 1; i < n; i++) {\n        int len = next[i-1];\n        while (len >= 1 && s[len] != s[i]) {\n            len = next[len-1];\n        }\n        if (s[len] == s[i]) next[i] = len + 1;\n        else next[i] = 0;\n    }\n    int k = n - next.back();\n    for (int i = 1; i <= n; i++) {\n        w[i][s[i-1]-'a']++;\n        for (int j = 0; j < 26; j++) {\n            w[i][j] += w[i-1][j];\n        }\n    }\n    for (int i = 0; i < 26; i++) {\n        cout << fib(i, right, n, k) - fib(i, left-1, n, k);\n        if (i != 25) cout << ' ';\n    }\n    cout << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0||r<=n){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=(r-l+1)/m*w[i];\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=0;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint z[200005];\nlong long l,r,num[200005][26];\nint n,p;\nstring s;\nvoid zfunc()\n{\n\tint l=0,r=0;\n\tmemset(z,0,sizeof(z));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<=r)z[i]=min(z[i-l],r-i+1);\n\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;\n\t\tif(i+z[i]-1>r)\n\t\t{\n\t\t\tl=i;\n\t\t\tr=i+z[i]-1;\n\t\t}\n\t}\n}\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n//\tif(n%p==0)\n//\t{\n//\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n//\t\txx+=num[x%(long long)p][y];\n//\t\treturn xx;\n//\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size();\n\tn/=2;\n\ts=s.substr(0,n);\n\tzfunc();\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(z[i]+i==n)\n\t\t{\n\t\t\tp=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]=num[i-1][j];\n\t\tnum[i][s[i-1]-'a']++;\n\t}\n//\tcout<<sol(10,0)<<endl;\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc077/tasks/arc077_d\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\nstring s;\nint Z[N], n;\nlong long l, r, cnt[1000], ch[1000][26], ans[26];\n\nvoid cal(long long x, int v){\n    int cur = 0;\n    while (cnt[cur] < x) cur++;\n    while (x){\n        while (cnt[cur-1] >= x) cur--;\n        if (x <= cnt[0]){\n            for (int i = 0; i < x; i++) ans[s[i] - 'a'] += v;\n            break;\n        }\n        if (cnt[cur] == x){\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur][i] * v;\n            x = 0;\n        }\n        else{\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur-1][i] * v;\n            x -= cnt[cur-1];\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s >> l >> r; n = s.size();\n    for (int i = 1, l = 0, r = 0; i < n; i++){\n        if (i <= r) Z[i] = min(r-i+1, Z[i-l]);\n        while (i + Z[i] < n && s[Z[i]] == s[i+Z[i]]) Z[i]++;\n        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;\n    }\n    for (int i = 1; i < n; i++) if (i > n/2 && i + Z[i] == n){\n        s.resize(i); n = i; break;\n    }\n    cnt[0] = n;\n    for (int i = 1; i < n; i++) if (i + Z[i] >= n){\n        cnt[1] = cnt[0] + i;\n        break;\n    }\n    if (!cnt[1]) cnt[1] = 2 * cnt[0];\n    if (cnt[0] % (cnt[1] - cnt[0]) == 0){\n        int siz = cnt[1] - cnt[0];\n        for (int i = 0; i < siz; i++) ans[s[i] - 'a'] += (r / siz) - ((l-1) / siz);\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) ch[0][s[i] - 'a']++, ch[1][s[i] - 'a']++;\n    for (int i = 0; i < (cnt[1] - cnt[0]); i++) ch[1][s[i] - 'a']++;\n\n    for (int i = 2; cnt[i-1] <= r; i++) {\n        cnt[i] = cnt[i-1] + cnt[i-2];\n        for (int j = 0; j < 26; j++) ch[i][j] = ch[i-1][j] + ch[i-2][j];\n    }\n    cal(r, 1); cal(l-1, -1);\n\n    for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n    while(true) cout << 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n \ntypedef long long LL;\nconst int N=100005;\n \nint cnt[N][26],fail[N],n,t;\nchar s[N*2];\n \nLL calc(LL pos,int c){\n\tif (pos<=n) return cnt[pos][c];\n\tLL s1=cnt[n][c],s2=cnt[t][c],len1=n,len2=t;\n\tfor (;len1+len2<=pos;){\n\t\tLL tmp=s1;s1+=s2;s2=tmp;\n\t\ttmp=len1;len1+=len2;len2=tmp;\n\t}\n\treturn s1+calc(pos-len1,c);\n}\n \nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tfail[0]=-1;\n\tfor (int i=1,j=-1;i<=n;fail[i++]=++j)\n\t\tfor (;j>=0 && s[j+1]!=s[i];j=fail[j]);\n\tLL l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tt=n-fail[n];\n\tif (n%t){\n\t\tprintf(\"### %d %d\\n\",n,t);\n\t\treturn 0;\n\t} \n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t)\n{\n\tif (len[2] - len[1] == len[1] - len[0])\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = true;\n\ts = conv(s);\n\ts = conv(s);\n\ts = conv(s);\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf), v2 = get(lf - 1);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=200010;\ntypedef long long ll;\nint n,prd,fail[N],k=0;\nchar a[N];\nll l,r,pre[N][30];\n\nll fib(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(p<=n*2) return pre[n][c]+pre[p-n][c];\n\tll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n\twhile(p>a+b){\n\t\tll c=ret1; ret1+=ret2; ret2=c;\n\t\tc=a; a+=b; b=c;\n\t}\n\treturn ret1+fib(p-a,c);\n}\n\nll calc(ll p,int c){\n\tif(p<=n) return pre[p][c];\n\tif(n%prd==0){\n\t\tll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n\t\tp-=n; p%=prd;\n\t\treturn ret+pre[p][c];  \n\t}\n\telse return fib(p,c);\n}\n\nint main(){\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    \tpre[i][a[i]-'a']++;\n\t}\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor(int i=2;i<=n;i++){\n\t\tif (k&&a[k+1]!=a[i]) k=fail[k];\n\t\tif(a[k+1]==a[i]) k++;\n\t\tfail[i]=k;\n\t}\n\tprd=n-fail[n];\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst ll  inf=1e18;\nconst int maxn=2e5+10;\nconst int maxm=1e2+10;\nchar s[maxn];int n,lst,nxt[maxn],pre[maxn][26];\nll l,r,cutpos,ans[26],cnt[maxm],f[maxm][26];\nll read(){\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(ll x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(ll x){print(x);putchar(' ');}\nvoid get_nxt(){\n    nxt[1]=0;\n    for(int i=2,j;i<=n;i++){\n        j=nxt[i-1];\n        while(j&&s[j+1]!=s[i])j=nxt[j];\n        nxt[i]=s[j+1]==s[i]?j+1:0;\n    }\n}\nvoid cal1(ll x,ll v){\n    if(x<=0)return ;ll tmp=x/cutpos;\n    for(int i=0;i<26;i++)ans[i]+=v*tmp*pre[cutpos][i];\n    tmp=x%cutpos;\n    for(int i=0;i<26;i++)ans[i]+=v*pre[tmp][i];\n}\nvoid get_fib(){\n    cnt[1]=n;\n    for(int i=1;i<=n;i++){f[1][s[i]-'a']++;f[2][s[i]-'a']++;}\n    cnt[2]=n+cutpos;\n    for(int i=0;i<26;i++)f[2][i]+=pre[cutpos][i];\n    for(int i=3;;i++){\n        for(int j=0;j<26;j++)f[i][j]=f[i-2][j]+f[i-1][j];\n        cnt[i]=cnt[i-2]+cnt[i-1];if(cnt[i]>inf){lst=i;break;}\n    }\n}\nvoid cal2(ll x,ll v){\n    for(int i=lst;i>=1;i--)\n        if(cnt[i]<=x){\n            x-=cnt[i];\n            for(int j=0;j<26;j++)ans[j]+=v*f[i][j];\n        }\n    for(int i=0;i<26;i++)ans[i]+=v*pre[x][i];\n}\nint main(){\n    scanf(\"%s\",s+1);l=read();r=read();n=strlen(s+1);n>>=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<26;j++)pre[i][j]+=pre[i-1][j];\n        pre[i][s[i]-'a']++;\n    }get_nxt();cutpos=n-nxt[n];\n    if(!n%cutpos){cal1(r,1);cal1(l-1,-1);}\n    else {get_fib();cal2(r,1);cal2(l-1,-1);}\n    for(int i=0;i<26;i++)write(ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<class Iter> vector<int>Z_Algorithm(Iter a, Iter a_end) {\n    int n = a_end - a;\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && a[r-l] == a[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && a[r-l] == a[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\n\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=2; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    REP (i, R) ans[S[i]-'a']++;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    N /= 2;\n    VI z = Z_Algorithm(S, S+N);\n    \n    int pos = N;\n    for (int i=1; i<N; i++) if (i + z[i] >= pos) {\n\tpos = i;\n\tbreak;\n    }\n\n    len[0] = N - pos;\n    len[1] = pos;\n    REP (i, N) {\n\tif (i < pos) C[1][S[i]-'a']++;\n\telse C[0][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n//    puts(S);\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    assert(len[LEVEL-1] > r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 200010\n#define ll long long\nusing namespace std;\n\nint n, nxt[N], d, l, len[2];\nll L, R, ans[26], D[1010][2], s[2], s1[2][26];\nchar S[N];\n\ninline void kmp(){\n\tnxt[0]=nxt[1]=0; int j;\n\tfor(int i=2; i<=n; i++){\n\t\tj=nxt[i-1]; while(j&&S[i]!=S[j+1])j=nxt[j];\n\t\tif(S[i]==S[j+1])j++; nxt[i]=j;\n\t}\n}\n\ninline void solve(ll m, int f){\n\tif(n%d==0){\n\t\tll x=m/d;\n\t\tfor(int i=1; i<=n; i++)ans[S[i]-'a']+=x*f;\n\t\tfor(int i=1; i<=m-x*d; i++)ans[S[i]-'a']+=f;\n\t\treturn;\n\t}\n\tlen[0]=n; len[1]=d;\n\tl=2; memset(D, 0, sizeof(D)); D[1][0]=1; D[2][1]=1;\n\tif(m<=n+d){\n\t\tfor(int i=1; i<=n; i++)if(i<=m)ans[S[i]-'a']+=f;\n\t\tfor(int i=1; i<=d; i++)if(n+i<=m)ans[S[i]-'a']+=f;\n\t\treturn;\n\t}\n\tmemset(s1, 0, sizeof(s1));\n\tfor(int i=1; i<=n; i++)s1[0][S[i]-'a']++;\n\tfor(int i=1; i<=d; i++)s1[1][S[i]-'a']++;\n\t\n\ts[0]=1; s[1]=0; ll now=n+d; int p;\n\tfor(int i=3; i<=1000; i++){\n\t\tD[i][0]=s[0]; D[i][1]=s[1];\n\t\tnow+=D[i][0]*len[0]+D[i][1]*len[1];\n\t\ts[0]+=D[i-1][0]; s[1]+=D[i-1][1];\n\t\tif(now>=m){\n\t\t\twhile(m>n+d){\n\t\t\t\tfor(int j=1; j<=i; j++)if(m>=D[j][0]*len[0]+D[j][1]*len[1]){\n\t\t\t\t\tfor(int k=0; k<=25; k++)ans[k]+=s1[0][k]*D[j][0]*f;\n\t\t\t\t\tfor(int k=0; k<=25; k++)ans[k]+=s1[1][k]*D[j][1]*f;\n\t\t\t\t\tm-=D[j][0]*len[0]+D[j][1]*len[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1; j<=n; j++)if(j<=m)ans[S[j]-'a']+=f;\n\t\t\tfor(int j=1; j<=d; j++)if(n+j<=m)ans[S[j]-'a']+=f;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%s\", S+1); n=strlen(S+1); n>>=1;\n\tscanf(\"%lld%lld\", &L, &R);\n\tkmp(); d=n-nxt[n];\n\tmemset(ans, 0, sizeof(ans)); solve(R, 1); solve(L-1, -1);\n\tfor(int i=0; i<=24; i++)printf(\"%lld \", ans[i]); printf(\"%lld\", ans[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,m,x[200010],a[200010];\nchar s[200010];\nL l,r,f[200],g[200];\ninline L count(L r,int i)\n{\n\tint j;\n\tL k=0;\n\tfor(j=1;j<=n;j++)\n\t  a[j]=a[j-1]+(s[j]=='a'+i);\n\tif(n%m==0)\n\t  if(r<=n)\n\t    return a[r];\n\t  else\n\t    return a[n]+(r-n)/m*a[m]+a[(r-n)%m];\n\telse\n\t  {\n\t   f[1]=a[m];\n\t   g[1]=m;\n\t   f[2]=a[n];\n\t   g[2]=n;\n\t   for(j=3;g[j-1]<r;j++)\n\t     {\n\t\t  f[j]=f[j-1]+f[j-2];\n\t\t  g[j]=g[j-1]+g[j-2];\n\t\t }\n\t   for(j--;j;j--)\n\t     if(r>=g[j])\n\t       {\n\t\t\tr-=g[j];\n\t\t\tk+=f[j];\n\t\t   }\n\t   k+=a[r];\n\t   return k;\n\t  }\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%s%lld%lld\",&s[0]+1,&l,&r);\n\tn=strlen(&s[0]+1);\n\tfor(i=2;i<=n;i++)\n\t  {\n\t   for(j=x[i-1];j;j=x[j])\n\t     if(s[j+1]==s[i])\n\t       break;\n\t   if(s[j+1]==s[i])\n\t     x[i]=j+1;\n\t  }\n\tfor(i=x[n];i>n/2;i=x[i]);\n\tn-=i;\n\tm=n-x[n];\n\tfor(i=0;i<26;i++)\n\t  printf(\"%lld \",count(r,i)-count(l-1,i));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nvector<int> z_algorithm(const string& s){\n  int n = s.size();\n  vector<int> z(n, 0);\n  int l = 0;\n  for(int i=1; i<n; i++){\n    if( i+z[i-l] < l+z[l] ){\n      z[i] = z[i-l];\n    }else{\n      int j = max(0, l+z[l]-i);\n      while( i+j < n && s[j] == s[i+j] ) j++;\n      z[i] = j;\n      l = i;\n    }\n  }\n  return z;\n}\n\nvector<long long> sums[26];\n\nmap<tuple<int,long long,long long>, vector<long long>> memo;\n\n// [l,r)\nvector<long long> rec(string& s, vector<long long>& len, long long l, long long r, int d){\n  auto state = make_tuple(d,l,r);\n  if(memo.count(state)){\n    return memo[state];\n  }\n\n  if(d == 0){\n    vector<long long> cnt(26);\n    for(int i=0; i<26; i++){\n      cnt[i] += sums[i][r] - sums[i][l];\n    }\n    return memo[state] = cnt;\n  }\n\n  if( r <= len[d-1] ){\n    return memo[state] = rec(s,len, l, r, d-1);\n  }\n  if( len[d-1] <= l ){\n    return memo[state] = rec(s,len, l-len[d-1], r-len[d-1], max(0,d-2));\n  }\n  auto x = rec(s,len,l,len[d-1], d-1);\n  auto y = rec(s,len,0,r-len[d-1], max(0,d-2));\n  for(int i=0; i<26; i++){\n    x[i] += y[i];\n  }\n  return memo[state] = x;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  long long l,r;\n  cin >> l,r;\n\n  auto z = z_algorithm(s);\n  // eprintln(z);\n  int left = (s.size()+2)/2+1;\n  while(left<s.size() && z[left]<s.size()-left){\n    left++;\n  }\n  s = s.substr(0,left);\n  z = z_algorithm(s);\n  left = 1;\n  while(left<s.size() && z[left]<s.size()-left){\n    left++;\n  }\n  long long border = s.size() - left;\n  long long period = s.size() - border;\n\n  for(int i=0; i<26; i++){\n    sums[i].resize(s.size()+1);\n  }\n  for(int i=0; i<s.size(); i++){\n    sums[ s[i]-'a' ][i+1]++;\n  }\n  for(int i=0; i<26; i++){\n    for(int j=1; j<=s.size(); j++){\n      sums[i][j] += sums[i][j-1];\n    }\n  }\n\n  for(int i=0; i<26; i++){\n    if(sums[i][s.size()] == s.size()){\n      println( r-l+1 );\n      return 0;\n    }\n  }\n\n  if( s.size() % period == 0 ){\n    l--;\n    long long x = r/period;\n    long long y = l/period;\n    vector<long long> ans(26);\n    for(int i=0; i<26; i++){\n      ans[i] += sums[i][period] * (x-y);\n      ans[i] += sums[i][r%period];\n      ans[i] -= sums[i][l%period];\n    }\n\n    println(join(ans, \" \"));\n    return 0;\n  }\n\n  vector<long long> len;\n  len.push_back( s.size() );\n\n  while(true){\n    len.push_back( len.back() + period );\n    period = len.back() - period;\n    if(len.back() >= r) break;\n  }\n\n  auto ans = rec(s, len, l-1,r, len.size()-1);\n  println(join(ans, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long ll;\n\n#define N 800050\nchar s[N];\nint len;\nint pre[N];\nint sa,sb;\n\nll A[205][27],B[205][27];\nll ans1[27],ans2[27];\nll la,lb;\n\nvoid sset(ll a[],int l,int r)\n{\n\tfor(int i=l;i<=r;i++)\n\t\ta[s[i]-'a'+1]++;\n}\n\nvoid add(ll a[],ll b[])\n{\n\tfor(int i=1;i<=26;i++)\n\t\ta[i]+=b[i];\n}\n\nvoid solve(ll a[],ll la,ll lb,int flo,ll lim,int tp)\n{\n\tif(flo==0)\n\t{\n\t\tif(tp==1)\n\t\t\tfor(int i=sa;i<sa+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\telse\n\t\t\tfor(int i=sb;i<sb+lim;i++)\n\t\t\t\ta[s[i]-'a'+1]++;\n\t\treturn;\n\t}\n\tif(tp==2)\n\t\tsolve(a,lb,la-lb,flo-1,lim,1);\n\telse\n\t{\n\t\tll pa=lb,pb=la-lb;\n\t\tif(lim==pa) {add(a,A[flo-1]);return;}\n\t\telse if(lim>pa)\n\t\t\tadd(a,A[flo-1]),solve(a,pa,pb,flo-1,lim-pa,2);\n\t\telse\n\t\t\tsolve(a,pa,pb,flo-1,lim,1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tll L,R;scanf(\"%lld%lld\",&L,&R);\n\tlen=strlen(s);\n\tpre[0]=-1;\n\tfor(int i=1;i<len;i++)\n\t{\n\t\tint p=pre[i-1];\n\t\twhile(~p && s[p+1]!=s[i]) p=pre[p];\n\t\tpre[i]= s[p+1]==s[i]? p+1: -1;\n\t}\n\t\n\tint npos=pre[len-1];\n\twhile(npos>=len/2) npos=pre[npos];\n\tif((npos+1)*2==len)\n\t{\n\t\tint wpos=pre[npos];\n\t\twhile(wpos>=npos/2) wpos=pre[wpos];\n\t\tif(wpos==-1)\n\t\t{\n\t\t\tsset(A[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tsset(B[0],0,npos);\n\t\t\tla=npos+1;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsset(A[0],0,wpos);\n\t\t\tsset(B[0],wpos+1,npos-wpos-1);\n\t\t\tla=wpos+1;lb=npos+1-la-la;\n\t\t\tsa=0,sb=wpos+1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(npos==-1)\n\t\t{\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=len-npos-1;i<=(len-npos-1)*2;i++)\n\t\t\t\ts[i]=s[i-(len-npos-1)];\n\t\t\tlen+=npos;\n\t\t\tsset(A[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tsset(B[0],0,len-1);\n\t\t\tla=len;lb=la+la;\n\t\t\tsa=0,sb=0;\n\t\t\tfor(int i=len;i<len+len;i++)\n\t\t\t\ts[i]=s[i-len];\n\t\t}\n\t}\n\t\n\tint flo=0;\n\twhile(la<=R)\n\t{\n\t\t++flo;\n\t\tll tmp=la;\n\t\tla=la+lb;\n\t\tlb=tmp;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tB[flo][i]=A[flo-1][i],\n\t\t\tA[flo][i]=B[flo-1][i]+A[flo-1][i];\n\t}\n\tsolve(ans1,la,lb,flo,R,1);\n\tif(L>1) solve(ans2,la,lb,flo,L-1,1);\n\tfor(int i=1;i<=26;i++)\n\t\tprintf(\"%lld \",ans1[i]-ans2[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=2e6+5,M=1e7+50,mo=1e9+7;\nint fail[N],n,i,per;\nll len1,len2,d,prt[30],l,r,f[305][26],g[305][26],sf[305],sg[305];\nchar s[N];\nvoid kmp()\n{\n\tint i,j;\n\tj=0;\n\tn=strlen(s+1)/2;\n\tfo(i,2,n)\n\t{\n\t\twhile (j&&s[i]!=s[j+1]) j=fail[j];\n\t\tif (s[i]==s[j+1]) j++;\n\t\tfail[i]=j;\n\t}\n}\nvoid fib()\n{\n\tint i,j;\n\tfo(i,2,300)\n\t{\n\t\tfo(j,0,25)  g[i][j]=g[i-1][j]+g[i-2][j];\n\t\tsg[i]=sg[i-1]+sg[i-2];\n\t\tif (sg[i]*2>r) break;\n\t}\n\tfo(i,0,300)\n\t{\n\t\tfo(j,0,25) f[i][j]=g[i][j]*2;\n\t\tsf[i]=sg[i]*2;\n\t\tif (sf[i]>r) break;\n\t}\n}\nvoid calc(ll x,ll xs)\n{\n\tint pos;\n\tfo(pos,0,300)\n\t\tif (sg[pos]>x) break;\n\twhile (pos>=0)\n\t{\n\t\tif (sg[pos]<=x)\n\t\t{\n\t\t\tfo(i,0,25) prt[i]+=xs*g[pos][i];\n\t\t\tx-=sg[pos];\n\t\t\tpos--;\n\t\t}else\n\t\tpos--;\n\t}\n\tfo(i,1,x) prt[s[i]-'a']+=xs; \n}\nint main()\n{\n\tscanf(\"%s %lld %lld\",s+1,&l,&r);\n\tkmp();\n\tfo(i,1,n) g[0][s[i]-'a']++,sg[0]++;\n\tper=n-fail[n];\n\tfo(i,0,25) g[1][i]=g[0][i];\n\tsg[1]=sg[0];\n\tfo(i,1,per) g[1][s[i]-'a']++,sg[1]++;\n\tfib();\n\tcalc(r,1);\n\tcalc(l-1,-1);\n\tfo(i,0,25) printf(\"%lld \",prt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.11.2019 02:41:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> kmp_table(int n, const T &s) {\n  vector<int> p(n, 0);\n  int k = 0;\n  for (int i = 1; i < n; i++) {\n    while (k > 0 && !(s[i] == s[k])) {\n      k = p[k - 1];\n    }\n    if (s[i] == s[k]) {\n      k++;\n    }\n    p[i] = k;\n  }\n  return p;\n}\n\ntemplate <typename T>\nvector<int> kmp_table(const T &s) {\n  return kmp_table((int) s.size(), s);\n}\n\ntemplate <typename T>\nvector<int> kmp_search(int n, const T &s, int m, const T &w, const vector<int> &p) {\n  assert(n >= 1 && (int) p.size() == n);\n  vector<int> res;\n  int k = 0;\n  for (int i = 0; i < m; i++) {\n    while (k > 0 && (k == n || !(w[i] == s[k]))) {\n      k = p[k - 1];\n    }\n    if (w[i] == s[k]) {\n      k++;\n    }\n    if (k == n) {\n      res.push_back(i - n + 1);\n    }\n  }\n  return res;\n  // returns 0-indexed positions of occurrences of s in w\n}\n\ntemplate <typename T>\nvector<int> kmp_search(const T &s, const T &w, const vector<int> &p) {\n  return kmp_search((int) s.size(), s, (int) w.size(), w, p);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  long long L, R;\n  cin >> L >> R;\n  vector<int> pers;\n  vector<string> sss;\n  while (true) {\n    vector<int> p = kmp_table(s);\n    int n = (int) s.size();\n    int x = p[n - 1];\n    while (x >= n / 2) {\n      x = p[x - 1];\n    }\n    s += s.substr(x, n - 2 * x);\n    pers.push_back(n - x);\n    debug(s, pers);\n    sss.push_back(s);\n    if (pers.size() == 2) break;\n  }\n  string A = sss[0];\n  string B = sss[1];\n  vector<long long> len(2);\n  vector<vector<long long>> cnt(2, vector<long long>(26));\n  for (char c : A) {\n    len[0] += 1;\n    cnt[0][c - 'a'] += 1;\n  }\n  for (char c : B) {\n    len[1] += 1;\n    cnt[1][c - 'a'] += 1;\n  }\n  while (len.back() < R) {\n    len.push_back(len.back() + len[len.size() - 2]);\n    cnt.emplace_back(26, 0);\n    for (int i = 0; i < 26; i++) cnt.back()[i] = cnt[cnt.size() - 3][i] + cnt[cnt.size() - 2][i];\n  }\n  vector<long long> res(26);\n  function<void(long long, long long)> Fun = [&](long long L, long long R) {\n    int id = 0;\n    while (len[id] < R) {\n      ++id;\n    }\n    if (id == 0) {\n      for (int i = L; i <= R; i++) res[A[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (id == 1) {\n      for (int i = L; i <= R; i++) res[B[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (L == 1 && R == len[id]) {\n      for (int i = 0; i < 26; i++) res[i] += cnt[id][i];\n      return;\n    }\n    if (L > len[id - 1]) {\n      Fun(L - len[id - 1], R - len[id - 1]);\n    } else {\n      Fun(L, len[id - 1]);\n      Fun(1, R - len[id - 1]);\n    }\n  };\n  Fun(L, R);\n  for (int i = 0; i < 26; i++) cout << res[i] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint z[200005];\nlong long l,r,num[200005][26];\nint n,p;\nstring s;\nvoid zfunc()\n{\n\tint l=0,r=0;\n\tmemset(z,0,sizeof(z));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<=r)z[i]=min(z[i-l],r-i+1);\n\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;\n\t\tif(i+z[i]-1>r)\n\t\t{\n\t\t\tl=i;\n\t\t\tr=i+z[i]-1;\n\t\t}\n\t}\n}\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n//\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tif(n%p==0)\n\t{\n\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n\t\tx%=(long long)p;\n\t\txx+=num[x][y];\n\t\treturn xx;\n\t}\n\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size();\n\tn/=2;\n\ts=s.substr(0,n);\n\tzfunc();\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(z[i]+i==n)\n\t\t{\n\t\t\tp=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]=num[i-1][j];\n\t\tnum[i][s[i-1]-'a']++;\n\t}\n//\tcout<<sol(10,0)<<endl;\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nconst ll b = 2;//1342231LL;\n\nconst int mx = 2e5;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tvector<ll> pw(mx);\n\tpw[0] = 1;\n\trep(i,1,mx) pw[i] = pw[i-1]*b % md;\n\n\tstring s;\n\tcin >> s;\n\tint n = sz(s)/2;\n\tstring a = s.substr(0, n);\n\n\tvector<ll> pre(n+1);\n\trep(i,0,n) pre[i+1] = (pre[i]*b + a[i])%md;\n\n\tint len;\n\tfor(len = n; len --> 0;){\n\t\tif((pre[n]-pre[n-len]*pw[len]%md - pre[len])%md == 0)\n\t\t\tbreak;\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\n\tvector<ll> fibs(200);\n\tfibs[0] = len, fibs[1] = n-len;\n\trep(i,2,200) fibs[i] = fibs[i-1] + fibs[i-2];\n\n\tvector<vector<ll>> cnts(200, vector<ll>(26));\n\trep(i,0,26) cnts[0][i] = count(a.begin(),a.begin()+len, 'a'+i);\n\trep(i,0,26) cnts[1][i] = count(a.begin(),a.begin()+n-len, 'a'+i);\n\trep(i,2,200) rep(j,0,26) cnts[i][j] = cnts[i-1][j]+cnts[i-2][j];\n\n\tfunction<ll(ll,int,int)> que = [&](ll pos, int c, int ix){\n\t\tassert(fibs[ix] >= pos);\n\t\tif(ix <= 1){\n\t\t\treturn (ll)count(a.begin(),a.begin()+pos, 'a'+c);\n\t\t}\n\t\tif(pos <= fibs[ix-1]) return que(pos, c, ix-1);\n\t\treturn cnts[ix-1][c] + que(pos-fibs[ix-1],c,ix-2);\n\t};\n\n\tfunction<ll(ll,int)> f = [&](ll pos, int c){\n\t\tint i = 0;\n\t\twhile(fibs[i] < pos) ++i;\n\t\treturn que(pos, c, i);\n\t};\n\trep(c,0,26){\n\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nconst ll b = 2;//1342231LL;\n\nconst int mx = 2e5;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tvector<ll> pw(mx);\n\tpw[0] = 1;\n\trep(i,1,mx) pw[i] = pw[i-1]*b % md;\n\n\tstring s;\n\tcin >> s;\n\tint n = sz(s)/2;\n\tstring a = s.substr(0, n);\n\n\tvector<ll> pre(n+1);\n\trep(i,0,n) pre[i+1] = (pre[i]*b + a[i])%md;\n\n\tint len;\n\tfor(len = n; len --> 0;){\n\t\tif((pre[n]-pre[n-len]*pw[len]%md - pre[len])%md == 0)\n\t\t\tbreak;\n\t}\n\tll l, r;\n\tcin >> l >> r;/*\n\tif(n%(n-len) == 0){\n\n\t\tauto f = [&](ll pos, int c){\n\t\t\tll ans = 0;\n\t\t\tans += count(all(a), 'a'+c)*(pos/n);\n\t\t\tpos %= n;\n\t\t\tans += count(a.begin(), a.begin()+pos, 'a'+c);\n\t\t\treturn ans;\n\t\t};\n\n\t\trep(c,0,26){\n\t\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t\t}\n\t\tcout << endl;\n\t\treturn 0;\n\t}*/\n\n\tvector<ll> fibs(200);\n\tfibs[0] = len, fibs[1] = n-len;\n\trep(i,2,200) fibs[i] = fibs[i-1] + fibs[i-2];\n\n\tvector<vector<ll>> cnts(200, vector<ll>(26));\n\trep(i,0,26) cnts[0][i] = count(a.begin(),a.begin()+len, 'a'+i);\n\trep(i,0,26) cnts[1][i] = count(a.begin()+len,a.end(), 'a'+i);\n\trep(i,2,200) rep(j,0,26) cnts[i][j] = cnts[i-1][j]+cnts[i-2][j];\n\n\tfunction<ll(ll,int,int)> que = [&](ll pos, int c, int ix){\n\t\tassert(fibs[ix] >= pos);\n\t\tif(ix == 0){\n\t\t\treturn (ll)count(a.begin(),a.begin()+pos, 'a'+c);\n\t\t}\n\t\tif(ix == 1){\n\t\t\treturn (ll)count(a.begin()+len,a.begin()+len+pos, 'a'+c);\n\t\t}\n\t\tif(pos <= fibs[ix-2]) return que(pos, c, ix-2);\n\t\treturn cnts[ix-2][c] + que(pos-fibs[ix-2],c,ix-1);\n\t};\n\n\tfunction<ll(ll,int)> f = [&](ll pos, int c){\n\t\tint i = 0;\n\t\twhile(fibs[i] < pos) ++i;\n\t\treturn que(pos, c, i);\n\t};\n\trep(c,0,26){\n\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nconst int MAXN = 1000000;\nint z[MAXN];\nchar s[MAXN];\nll cc[100];\n\nvoid zz(int n) {\n    z[0] = 0;\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (r > i)\n            z[i] = min(r - i, z[i - l]);\n        else\n            z[i] = 0;\n        while (i + z[i] < n && s[i + z[i]] == s[z[i]])\n            ++z[i];\n        if (i + z[i] > r)\n            r = i + z[i], l = i;\n    }\n}\n\nstruct st {\n    ll len;\n    int l, r;\n    int dp;\n    ll cc[26];\n    st(int l, int r): l(l), r(r) {\n        len = r - l;\n        dp = 0;\n        for (int i = 0; i < 26; ++i)\n            cc[i] = 0;\n        for (int i = l; i < r; ++i)\n            ++cc[s[i] - 'a'];\n    }\n    st operator+(st x) {\n        st ans(0, 0);\n        ans.len = len + x.len;\n        ans.l = x.l;\n        ans.r = x.r;\n        ans.dp = x.dp + 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] + x.cc[i];\n        return ans;\n    }\n    st operator-(st x) {\n        st ans(0, 0);\n        ans.len = len - x.len;\n        ans.l = l;\n        ans.r = r;\n        ans.dp = dp - 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] - x.cc[i];\n        return ans;\n    }\n};\n\n\nvoid add(st a, st b, ll x) {\n    if (x == 0)\n        return;\n    if (b.dp == 0) {\n        for (int i = b.l; i < b.l + x; ++i) {\n            ++cc[s[i] - 'a'];\n        }\n        return;\n    }\n    st q = a - b;\n    a = b;\n    b = q;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n        add(b, a - b, x);\n    }\n    else {\n        add(a, b, x);\n    }\n}\n\nvoid solve(ll x) {\n    int n = strlen(s);\n    zz(n);\n    int xx = 0;\n    for (int i = 1; i < n / 2; ++i)\n        if (i + z[i] >= n / 2) {\n            xx = i;\n            break;\n        }\n    assert(xx != 0);\n    st a(xx, n / 2);\n    st b(n / 2 - xx, xx);\n    for (int i = 0; i < min((ll)n, x); ++i)\n        ++cc[s[i] - 'a'];\n    x -= min((ll)n, x);\n    if (x == 0)\n        return;\n    while (x >= b.len + a.len + a.len + b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += 2 * a.cc[i] + 2 * b.cc[i];\n        x -= 2 * (a.len + b.len);\n        st q = a + b;\n        b = a;\n        a = q;\n    }\n    st c = a + b;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n}\nll ans[100];\n\nint main() {\n    scanf(\"%s\", s);\n    ll l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    --l;\n    int n = strlen(s);\n    zz(n);\n    for (int i = 0; i < n; ++i)\n        ++cc[s[i] - 'a'];\n    for (int i = 1; i < n / 2; ++i) {\n        if (n % i == 0 && i + z[i] >= n) {\n            for (int i = 0; i < 26; ++i) {\n                ll ans = 0;\n                ans += cc[i] * (r / n);\n                for (int j = 0; j < r % n; ++j)\n                    if (s[i] - 'a' == i)\n                        ++ans;\n                ans -= cc[i] * (l / n);\n                for (int j = 0; j < l % n; ++j)\n                    if (s[i] - 'a' == i)\n                        --ans;\n                cout << ans << \"\\n\";\n            }\n            return 0;\n        }\n    }\n    n /= 2;\n    int x = n;\n    for (int i = 1; i < n; ++i) {\n        if (i + z[i] >= n) {\n            x = i;\n            break;\n        }\n    }\n    if (x == n) {\n        n *= 2;\n        for (int i = 0; i < 26; ++i) {\n            ll ans = 0;\n            ans += cc[i] * (r / n);\n            for (int j = 0; j < r % n; ++j)\n                if (s[i] - 'a' == i)\n                    ++ans;\n            ans -= cc[i] * (l / n);\n            for (int j = 0; j < l % n; ++j)\n                if (s[i] - 'a' == i)\n                    --ans;\n            cout << ans << \"\\n\";\n        }\n        return 0;\n    }\n    n *= 2;\n    for (int i = 0; i < x; ++i) {\n        s[n] = s[n - x];\n        ++n;\n    }\n    for (int i = 0; i < x; ++i) {\n        s[n + i] = s[i];\n    }\n    n += x;\n    for (int i = 0; i < 26; ++i)\n        cc[i] = 0;\n    solve(r);\n    for (int i = 0; i < 26; ++i)\n        ans[i] = cc[i], cc[i] = 0;\n    solve(l);\n    for (int i = 0; i < 26; ++i)\n        ans[i] -= cc[i];\n    for (int i = 0; i < 26; ++i)\n        cout << ans[i] << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n}\n\nstring s,t;\nll l,r,S,T;\n\nvl Solve(ll x){\n\tvl a(26);\n\tfor(int i=0;i<min(S,x);i++) a[f(s[i])]++;\n\tif(x>S){\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(x-S)/T;\n\t\tfor(int i=0;i<(x-S)%T;i++) a[f(t[i])]++;\n\t}\n\treturn a;\n}\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0;\n\tT=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tT=i;\n\t\t}\n\t}\n\tt=s.substr(0,T);\n\tif(S%T==0){\n\t\tvl al=Solve(l),ar=Solve(r);\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<ar[i]-al[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c);\n\t\t\tc++;\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc077/tasks/arc077_d\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\nstring s;\nint Z[N], n;\nlong long l, r, cnt[1000], ch[1000][26], ans[26];\n\nvoid cal(long long x, int v){\n    int cur = 0;\n    while (cnt[cur] < x) cur++;\n    while (x){\n        while (cnt[cur-1] >= x) cur--;\n        if (x <= cnt[0]){\n            for (int i = 0; i < x; i++) ans[s[i] - 'a'] += v;\n            break;\n        }\n        if (cnt[cur] == x){\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur][i] * v;\n            x = 0;\n        }\n        else{\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur-1][i] * v;\n            x -= cnt[cur-1];\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s >> l >> r; n = s.size();\n    for (int i = 1, l = 0, r = 0; i < n; i++){\n        if (i <= r) Z[i] = min(r-i+1, Z[i-l]);\n        while (i + Z[i] < n && s[Z[i]] == s[i+Z[i]]) Z[i]++;\n        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;\n    }\n    for (int i = 1; i < n; i++) if (i > n/2 && i + Z[i] == n){\n        s.resize(i); n = i; break;\n    }\n    cnt[0] = n;\n    for (int i = 1; i < n; i++) if (i + Z[i] >= n){\n        cnt[1] = cnt[0] + i;\n        break;\n    }\n    if (!cnt[1]) cnt[1] = 2 * cnt[0];\n    if (cnt[0] % (cnt[1] - cnt[0]) == 0){\n        int siz = cnt[1] - cnt[0];\n        for (int i = 0; i < siz; i++) ans[s[i] - 'a'] += (r / siz) - ((l-1) / siz);\n//        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) ch[0][s[i] - 'a']++, ch[1][s[i] - 'a']++;\n    for (int i = 0; i < (cnt[1] - cnt[0]); i++) ch[1][s[i] - 'a']++;\n\n    for (int i = 2; cnt[i-1] <= r; i++) {\n        cnt[i] = cnt[i-1] + cnt[i-2];\n        for (int j = 0; j < 26; j++) ch[i][j] = ch[i-1][j] + ch[i-2][j];\n    }\n    cal(r, 1); cal(l-1, -1);\n\n    for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=2e5+5;\n\ntypedef long long LL;\n\nchar S[N],T[N];\n\nint n,nn,m,Fail[N],ss[N],cs[N],ct[N];\n\nLL l,r,cnt[N],fs[N],ft[N],g[N];\n\nvoid calc(LL t,int sig)\n{\n\tif (!t) return;\n\tmemset(ss,0,sizeof(ss));\n\tfor (int i=m-1;i>=0;i--) if (t>=g[i])\n\t{\n\t\tt-=g[i]; ss[i]++;\n\t}\n\tfor (int i=m-1;i>=0;i--) if (ss[i])\n\t{\n\t\tfor (int c=0;c<26;c++)\n\t\t{\n\t\t\tcnt[c]+=sig*(fs[i]*cs[c]+ft[i]*ct[c]);\n\t\t}\n\t}\n\tif (t)\n\t{\n\t\tfor (int i=1;i<=t;i++) cnt[S[i]-'a']+=sig;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",S+1,&l,&r); n=strlen(S+1)/2;\n\tfor (int i=2,j=0;i<=n;i++)\n\t{\n\t\tfor (;j>0 && S[i]!=S[j+1];j=Fail[j]);\n\t\tif (S[i]==S[j+1]) j++;\n\t\tFail[i]=j;\n\t}\n\tfor (int i=1;i<=n-Fail[n];i++) T[++nn]=S[i];\n\tfor (int i=1;i<=n;i++) cs[S[i]-'a']++;\n\tfor (int i=1;i<=nn;i++) ct[T[i]-'a']++;\n\tfs[0]=fs[1]=ft[1]=1; g[0]=n; g[1]=nn+n;\n\tfor (m=2;g[m-1]<r;m++) fs[m]=fs[m-1]+fs[m-2],ft[m]=ft[m-1]+ft[m-2],g[m]=g[m-1]+g[m-2];\n\tif (n>=r) calc(r,1);else\n\t{\n\tfor (int i=0;i<m;i++) if (g[i+1]>=(r+1)/2)\n\t{\n\t\tcalc(g[i],1); calc(r-g[i],1); break;\n\t}\n\t}\n\tif (n>=l-1) calc(l-1,-1);else\n\t{\n\tfor (int i=0;i<m;i++) if (g[i+1]>=l/2)\n\t{\n\t\tcalc(g[i],-1); calc(l-1-g[i],-1); break;\n\t}\n\t}\n\tfor (int c=0;c<26;c++) printf(\"%lld \",cnt[c]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\trep(j,n)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n/*\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) {\n      cnt[s[i] - 'a'] += rq - lq;\n    }\n    for (unsigned i = 0; i < rr; ++i) {\n      ++cnt[s[i] - 'a'];\n    }\n    for (unsigned i = 0; i < lr; ++i) {\n      --cnt[s[i]];\n    }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      auto x = len[len.size() - 1];\n      auto y = len[len.size() - 2];\n      len.push_back(x + y);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs('z' - 'a' + 1, 0);\n    for (unsigned i = 0; i < cnt_s.size(); ++i) { cnt_gs[i] = cnt_s[i]; }\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        auto x = cnt[cnt.size() - 1];\n        auto y = cnt[cnt.size() - 2];\n        cnt.push_back(x + y);\n      }\n      unsigned long long ans = 0;\n      auto rr = r + 1;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      for (unsigned j = 0; j < rr; ++j) {\n        if (s[j] - 'a' == i) { ++ans; }\n      }\n      auto ll = l;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > ll) { continue; }\n        rr -= len[j];\n        ans -= cnt[j];\n      }\n      for (unsigned j = 0; j < ll; ++j) {\n        if (s[j] - 'a' == i) { --ans; }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Written by Zhu Zeqi\n//Come on,baby\n//Hack,please\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define vi vector<int>\n#define MAX 100000000000000000\n#define MOD 1000000007\n#define PI 3.141592653589793238462\n#define INF 1000000000\ntypedef long long ll;\n//orz yht\nusing namespace std;\nconst int D=26;\nchar s[200005];\nint p[200005];\nll len[1000],num[1000];\nint i,j,k,n,m;\nll l,r;\nll work(ll x,int ch){\n\tint i,j;\n\tll ans=0;\n\tch+='a';\n\tlen[1]=n;\n\tnum[1]=0;\n\tfor(i=1;i<=n;i++)\n\tif(s[i]==ch)\n\tnum[1]++;\n\tlen[2]=n+m;\n\tnum[2]=num[1];\n\tfor(i=1;i<=m;i++)\n\tif(s[i]==ch)\n\tnum[2]++;\n\tfor(i=2;i;i++){\n\t\tif(len[i-1]+len[i]>=x)\n\t\tbreak;\n\t\tlen[i+1]=len[i-1]+len[i];\n\t\tnum[i+1]=num[i-1]+num[i];\n\t}\n\tfor(j=i;j;j--){\n\t\tif(x>=len[j]){\n\t\t\tx-=len[j];\n\t\t\tans+=num[j];\n\t\t}\n\t}\n\tfor(i=1;i<=x;i++)\n\tif(s[i]==ch)\n\tans++;\n\treturn ans;\n}\nint main(){\n\t//freopen(\"input.in\",\"r\",stdin);\n\t//freopen(\"output.out\",\"w\",stdout);\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tn/=2;\n\tj=0;\n\tfor(i=2;i<=n;i++){\n\t\twhile(j && s[j+1]!=s[i])\n\t\tj=p[j];\n\t\tif(s[j+1]==s[i])\n\t\tp[i]=++j;\n\t}\n\tm=n-p[n];\n\tcin>>l>>r;\n\tfor(i=0;i<D;i++)\n\tcout<<work(r,i)-work(l-1,i)<<\" \";\n\tputs(\"\");\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n \nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tll _s=0,_t=1,S=1,T=0;\n\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\twork(r-_s*n-_t*k);\n\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j=ne[j];\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MaxN = 2e5+3;\nchar s[MaxN];\nLL l,r;\nint cnt[MaxN][26];\nstruct Statu{\n\tLL s[26];\n\tStatu() {memset(s,0,sizeof s);}\n\ttemplate<typename T>\n\tStatu(const T* x) {\n\t\tfor (LL* p=s;p<s+26;++p,++x) *p=*x;\n\t}\n\tinline LL& operator [](const char& ch) {\n\t\treturn *(s+(int)ch-'a');\n\t}\n\tinline LL& operator [] (const int& x) {\n\t\treturn *(s+x);\n\t}\n\tinline Statu& operator +=(const Statu& o) {\n\t\tfor (int i=0;i<26;++i) s[i]+=o.s[i];\n\t\treturn *this;\n\t}\n\tinline Statu operator +(const Statu& b) const {\n\t\tStatu ret;\n\t\tfor (int i=0;i<26;++i) ret.s[i]=s[i]+b.s[i];\n\t\treturn ret;\n\t}\n\tinline void print() const {\n\t\tfor (int i=0;i<26;++i) printf(\"%I64d \",s[i]);\n\t\tputchar('\\n');\n\t}\n};\n\ninline int* Z_box(const char* str,int* z) {\n\tint r=-1,p=-1,l=strlen(str);\n\tz[0]=l-1;\n\tfor (int i=1;i<l;++i) {\n\t\tz[i]=-1;\n\t\tif (r>=i) z[i]=min(z[i-p],r-i);\n\t\twhile (i+z[i]+1<l && str[i+z[i]+1]==str[z[i]+1]) z[i]++;\n\t\tif (i+z[i]>r) r=i+z[i],p=i;\n\t}\n\treturn z;\n}\n\nLL solve(LL llen,Statu L,LL rlen,Statu R,LL last,Statu& ans) {\n\tif (llen+rlen<=last) {\n\t\tLL t=solve(llen+rlen,L+R,llen,L,last,ans);\n\t\tlast=t;\n\t}\n\tif (llen<=last) {\n\t\tans+=L;\n\t\tlast-=llen;\n\t}\n\treturn last;\n} \nchar s2[MaxN];int z[MaxN];\nint main() {\n\tscanf(\"%s%I64d%I64d\",s,&l,&r);\n\tint len=strlen(s);\n\tfor (int i=0;i<len/2;++i) s2[i]=s[i];\n\tint l2=strlen(s2);\n\tZ_box(s2,z);\n\tmemset(cnt,0,sizeof cnt);\n\tcnt[0][s[0]-'a']=1;\n\tfor (int i=1;i<l2;++i) {\n\t\tfor (int j=0;j<26;++j) cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tint pre=0x7fffffff; \n\tfor (int i=1;i<l2;++i) {\n\t\tif (z[i]!=-1 && i+z[i]==l2-1) pre=min(pre,i); \n\t}\n\tif (pre==0x7fffffff) {\n\t\tStatu ans;\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]+=(LL)cnt[l2-1][i]*(r/l2)+cnt[r%l2][i];\n\t\t\tif (l>=1) ans[i]-=(LL)cnt[l2-1][i]*((l-1)/l2)+cnt[(l-1)%l2][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) cout << ans[i] << \" \";\n\t} else {\n\t\tStatu L,R,ans1,ans2,ans;\n\t\tfor (int i=0;i<26;++i) \n\t\t\tL[i]=cnt[pre-1][i],\n\t\t\tR[i]=cnt[l2-1][i]-cnt[pre-1][i];\n\t\tLL x1=solve(pre,L,l2-pre,R,r+1,ans1),x2=solve(pre,L,l2-pre,R,l,ans2);\n\t\tfor (int i=0;i<26;++i) {\n\t\t\tans[i]=ans1[i]-ans2[i]; \n\t\t\tif (x1>=1) ans[i]+=cnt[x1-1][i];\n\t\t\tif (x2>=1) ans[i]-=cnt[x2-1][i];\n\t\t}\n\t\tfor (int i=0;i<26;++i) cout << ans[i] << \" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0||r<=n){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=0;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nint n2;\nchar s[200010];\nint nxt[200010];\nvoid kmp(){\n\tint j=0;\n\tfor(int i=2;i<=n;++i){\n\t\twhile(s[j+1]!=s[i]&&j)j=nxt[j];\n\t\tif(s[i]==s[j+1])j++;\n\t\tnxt[i]=j;\n\t}\n}\nint sum[200010][50];\nint l,r;\nint len[200010];\nint up;\nint ans[200010];\nvoid solve(int x,int f){\n    for(int i=up;i>=0;i--)\n        if(x>=len[i]){\n            for(int j=0;j<26;j++)\n                ans[j]+=f*sum[i][j];\n            x-=len[i];\n        }\n    for(int i=1;i<=x;i++)ans[s[i]-'a']+=f;\n}\nsigned main(){\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tn=strlen(s+1);\n\tn>>=1;\n\tkmp();\n\tn2=nxt[n];\n\t//cout<<n2<<endl;\n\tfor(int i=1;i<=n;++i){\n\t\tsum[0][s[i]-'a']++;\n\t\tsum[1][s[i]-'a']++;\n\t}\n\tlen[0]=n;\n\tfor(int i=1;i<=n-n2;++i){\n\t\tsum[1][s[i]-'a']++;\n\t}\n\tlen[1]=2*n-n2;\n\tfor(int i=2;i<=200000;++i){\n\t\tfor(int j=0;j<26;++j){\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tif(len[i]>r){\n\t\t\tup=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsolve(l-1,-1),solve(r,1);\n\tfor(int i=0;i<26;++i){\n\t\tprintf(\"%lld \",ans[i]);\n\t}\n\tputs(\"\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 200005;\ntypedef long long i64;\n\nchar S[MAX_N];\ni64 g[105][26], len[MAX_N];\n\nint N, T;\n\nvoid work(i64 x, i64 *cnt) {\n  memset(g, 0, sizeof g);\n  \n  int mx = 1;\n  for (int i = 1; i <= N; ++i) g[1][S[i] - 'a']++;\n  for (int i = 1; i <= T; ++i) g[0][S[i] - 'a']++;\n  len[0] = T, len[1] = N;\n\n  while (len[mx] < x) {\n    ++mx;\n    for (int i = 0; i < 26; ++i) g[mx][i] = g[mx - 1][i] + g[mx - 2][i];\n    len[mx] = len[mx - 1] + len[mx - 2];\n  }\n  \n  if (N % T == 0) {\n    if (x <= N) {\n      for (int i = 1; i <= x; ++i) cnt[S[i] - 'a']++;\n    } else {\n      for (int i = 1; i <= N; ++i) cnt[S[i] - 'a']++;\n      x -= N;\n      for (int i = 0; i < 26; ++i) cnt[i] += g[0][i] * (x / T);\n      for (int i = 1; i <= x % T; ++i) cnt[S[i] - 'a']++;\n    }\n  } else {\n    while (mx > 1 && x > 0) {\n      if (x >= len[mx - 1]) {\n\tfor (int i = 0; i < 26; ++i) cnt[i] += g[mx - 1][i];\n\tx -= len[mx - 1], mx = mx - 2;\n      } else {\n\tmx = mx - 1;\n      }\n    }\n    for (int i = 1; i <= x; ++i) cnt[S[i] - 'a']++;\n  }\n}\n\nint main() {\n  scanf(\"%s\", S + 1), N = strlen(S + 1);\n  N /= 2;\n  \n  static int f[MAX_N];\n  for (int i = 2, j = 0; i <= N; ++i) {\n    while (j && S[j + 1] != S[i]) j = f[j];\n    if (S[j + 1] == S[i]) j++;\n    f[i] = j;\n  }\n\n  T = N - f[N];\n  i64 l, r;\n  scanf(\"%lld%lld\", &l, &r);\n\n  static i64 cnt[2][26];\n  work(r, cnt[0]), work(l - 1, cnt[1]);\n  for (int i = 0; i < 26; ++i)\n    printf(\"%lld \", cnt[0][i] - cnt[1][i]);\n  puts(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\nconst int maxn = 2e5 + 10;\n\ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nLL n, l, r, k;\nchar st[maxn];\nLL nxt[maxn], ans[30];\n\nvoid solve(LL len, LL flag) {\n    if(len <= n) {\n        for(int i = 0; i < len; i++) ans[st[i] - 'a'] += flag;\n    }else {\n        LL ts, tt;\n        LL s = 1, t = 0, ls = 0, lt = 1;\n\n        while(s*n + t*k < len) {\n            ts = ls, tt = lt;\n            ls = s, lt = t;\n            s += ts, t += tt;\n        }\n\n        solve(len - ls*n - lt*k, flag);\n\n        for(int i = 0; i < k; i++) ans[st[i] - 'a'] += flag * lt;\n        for(int i = 0; i < n; i++) ans[st[i] - 'a'] += flag * ls;\n    }\n}\n\nvoid get_nxt() {\n\n    n = strlen(st) / 2; \n    nxt[0] = nxt[1] = 0;\n    for(int i = 1; i < n; i++) {\n        int j = nxt[i];\n        while(j && st[j] != st[i]) j = nxt[j];\n\n        nxt[i+1] = j + (st[j] == st[i]);\n    }\n\n    k = n - nxt[n];\n    //cerr << (k) << endl;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    scanf(\"%s%lld%lld\", st, &l, &r);\n\n    get_nxt();\n    solve(r, 1);\n    solve(l-1, -1);\n\n    for(int i = 0; i < 26; i++) printf(\"%lld \", ans[i]);\n    puts(\"\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n\nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (len <= n * 2) return num[n][c] + num[len - n][c];\n    long long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    while (len > l1 + l2) {\n        long long t = f2;\n        f2 += f1, f1 = t;\n        t = l2, l2 += l1, l1 = t;\n    }\n    return f2 + fib(len - l2, c);\n}\n\nlong long calc(long long len, int c) {\n    if (len <= n) return num[len][c];\n    if (n % T == 0) {\n        long long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n        len -= n, len %= T;\n        return re + num[len][c];\n    }\n    else return fib(len, c);\n}\n\nint main() {\n    scanf(\"%s%lld%lld\",s+1,&L,&R);\n    n=strlen(s+1)/2;p[1]=0;\n    for(int j=0,i=2;i<=n;i++) {\n        for(;j&&s[j+1]!=s[i];)j=p[j];\n        if(s[j+1]==s[i])j++;\n        p[i]=j;\n    }\n    for(int i=1;i<=n;i++) {\n        for (int j=0;j<26;j++)num[i][j]=num[i-1][j];\n        num[i][s[i]-'a']++;\n    }T=n-p[n];\n    for(int i=0;i<26;i++)\n\t\tprintf(\"%lld%c\",calc(R,i)-calc(L-1,i),i==25?10:32);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nconst int MAXN = 1000000;\nint z[MAXN];\nchar s[MAXN];\nll cc[100];\n\nvoid zz(int n) {\n    z[0] = 0;\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (r > i)\n            z[i] = min(r - i, z[i - l]);\n        else\n            z[i] = 0;\n        while (i + z[i] < n && s[i + z[i]] == s[z[i]])\n            ++z[i];\n        if (i + z[i] > r)\n            r = i + z[i], l = i;\n    }\n}\n\nstruct st {\n    ll len;\n    int l, r;\n    int dp;\n    ll cc[26];\n    st(int l, int r): l(l), r(r) {\n        len = r - l;\n        dp = 0;\n        for (int i = 0; i < 26; ++i)\n            cc[i] = 0;\n        for (int i = l; i < r; ++i)\n            ++cc[s[i] - 'a'];\n    }\n    st operator+(st x) {\n        st ans(0, 0);\n        ans.len = len + x.len;\n        ans.l = l;\n        ans.r = r;\n        ans.dp = dp + 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] + x.cc[i];\n        return ans;\n    }\n    st operator-(st x) {\n        st ans(0, 0);\n        ans.len = len - x.len;\n        ans.l = l;\n        ans.r = r;\n        ans.dp = dp - 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] - x.cc[i];\n        return ans;\n    }\n};\n\n\nvoid add(st a, st b, ll x) {\n    if (x == 0)\n        return;\n    if (b.dp == 0) {\n        for (int i = b.l; i < b.l + x; ++i) {\n            ++cc[s[i] - 'a'];\n        }\n        return;\n    }\n    st q = a - b;\n    a = b;\n    b = q;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n        add(b, a - b, x);\n    }\n    else {\n        add(a, b, x);\n    }\n}\n\nvoid solve(ll x) {\n    int n = strlen(s);\n    zz(n);\n    int xx = 0;\n    for (int i = 1; i < n / 2; ++i)\n        if (i + z[i] >= n / 2) {\n            xx = i;\n            break;\n        }\n    assert(xx != 0);\n    st a(xx, n / 2);\n    st b(n / 2 - xx, xx);\n    for (int i = 0; i < min((ll)n, x); ++i)\n        ++cc[s[i] - 'a'];\n    x -= min((ll)n, x);\n    if (x == 0)\n        return;\n    while (x >= b.len + a.len + a.len + b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += 2 * a.cc[i] + 2 * b.cc[i];\n        x -= 2 * (a.len + b.len);\n        st q = a + b;\n        b = a;\n        a = q;\n    }\n    st c = a + b;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n}\nll ans[100];\n\nint main() {\n    scanf(\"%s\", s);\n    ll l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    --l;\n    int n = strlen(s);\n    zz(n);\n    for (int i = 0; i < n; ++i)\n        ++cc[s[i] - 'a'];\n    for (int i = 1; i < n / 2; ++i) {\n        if (n % i == 0 && i + z[i] >= n) {\n            for (int i = 0; i < 26; ++i) {\n                ll ans = 0;\n                ans += cc[i] * (r / n);\n                for (int j = 0; j < r % n; ++j)\n                    if (s[i] - 'a' == i)\n                        ++ans;\n                ans -= cc[i] * (l / n);\n                for (int j = 0; j < l % n; ++j)\n                    if (s[i] - 'a' == i)\n                        --ans;\n                cout << ans << \"\\n\";\n            }\n            return 0;\n        }\n    }\n    n /= 2;\n    int x = n;\n    for (int i = 1; i < n; ++i) {\n        if (i + z[i] >= n) {\n            x = i;\n            break;\n        }\n    }\n    if (x == n) {\n        n *= 2;\n        for (int i = 0; i < 26; ++i) {\n            ll ans = 0;\n            ans += cc[i] * (r / n);\n            for (int j = 0; j < r % n; ++j)\n                if (s[i] - 'a' == i)\n                    ++ans;\n            ans -= cc[i] * (l / n);\n            for (int j = 0; j < l % n; ++j)\n                if (s[i] - 'a' == i)\n                    --ans;\n            cout << ans << \"\\n\";\n        }\n        return 0;\n    }\n    n *= 2;\n    for (int i = 0; i < x; ++i) {\n        s[n] = s[n - x];\n        ++n;\n    }\n    for (int i = 0; i < x; ++i) {\n        s[n + i] = s[i];\n    }\n    n += x;\n    for (int i = 0; i < 26; ++i)\n        cc[i] = 0;\n    solve(r);\n    for (int i = 0; i < 26; ++i)\n        ans[i] = cc[i], cc[i] = 0;\n    solve(l);\n    for (int i = 0; i < 26; ++i)\n        ans[i] -= cc[i];\n    for (int i = 0; i < 26; ++i)\n        cout << ans[i] << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N=2e5+10;\n\nLL l,r,ans[26],g[110],sum[N][26],sm[110][26];\nint len,plen,nxt[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n}\n\nvoid Getnext(char *s,int len) {\n\tnxt[0]=0;nxt[1]=0;\n\tfor (int i=1,k=0;i<len;++i) {\n\t\twhile (k && s[i]!=s[k]) k=nxt[k];\n\t\twhile (s[i]==s[k]) ++k;\n\t\tnxt[i+1]=k;\n\t}\n}\n\nvoid Calc(int dep,LL *ans,LL pos,int op) {\n\tif (pos==g[dep]) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sm[dep][j];\n\t\treturn ;\n\t}\n\tif (dep==0 || dep==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sum[pos][j];\n\t\treturn ;\n\t}\n\tif (pos>g[dep-1]) {\n\t\tCalc(dep-1,ans,g[dep-1],op);\n\t\tCalc(dep-2,ans,pos-g[dep-1],op);\n\t}else Calc(dep-1,ans,pos,op);\n}\n\nvoid Solve() {\n\tlen=strlen(s);len/=2;\n\tGetnext(s,len);\n\tfor (int i=1;i<=len;++i) {\n\t\tfor (int j=0;j<26;++j) sum[i][j]=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tplen=len-nxt[len];\n\tg[0]=plen; for (int j=0;j<26;++j) sm[0][j]=sum[plen][j];\n\tg[1]=len; for (int j=0;j<26;++j) sm[1][j]=sum[len][j];\n\tfor (int i=2;i<=100;++i) {\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tfor (int j=0;j<26;++j) sm[i][j]=sm[i-1][j]+sm[i-2][j];\n\t}\n\t\n\tfor (int i=0;i<=100;++i) \n\t\tif (g[i]>=r) { Calc(i,ans,r,1); break; }\n\tfor (int i=0;i<=100;++i) \n\t\tif (g[i]>=l-1) { Calc(i,ans,l-1,-1); break; }\n\t\t\n\tfor (int i=0;i<26;++i) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nconst int N=200010;\n\ntypedef long long ll;\n\nint n,prd;\nint fail[N];\nchar a[N];\nll l,r,pre[N][30];\n\ninline ll fib(ll p,int c){\n  if(p<=n) return pre[p][c];\n  if(p<=n*2) return pre[n][c]+pre[p-n][c];\n  ll ret1=pre[n][c]+pre[prd][c],ret2=pre[n][c],a=n+prd,b=n;\n  while(p>a+b){\n    ll c=ret1; ret1+=ret2; ret2=c;\n    c=a; a+=b; b=c;\n  }\n  return ret1+fib(p-a,c);\n}\n\ninline ll calc(ll p,int c){\n  if(p<=n) return pre[p][c];\n  if(n%prd==0){\n    ll ret=1LL*(p-n)/prd*pre[prd][c]+pre[n][c];\n    p-=n; p%=prd;\n    return ret+pre[p][c];  \n  }\n  else return fib(p,c);\n}\n\nint main(){\n  scanf(\"%s\",a+1); n=strlen(a+1)/2;\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n    pre[i][a[i]-'a']++;\n  }\n  scanf(\"%lld%lld\",&l,&r);\n  int k=0;\n  for(int i=2;i<=n;i++){\n    while(k&&a[k+1]!=a[i]) k=fail[k];\n    if(a[k+1]==a[i]) k++;\n    fail[i]=k;\n  }\n  prd=n-fail[n];\n  for(int i=0;i<26;i++)\n    printf(\"%lld \",calc(r,i)-calc(l-1,i));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\nconstexpr ll MAX = 100;\n\nstring S;\nvector<ll> A;\nvoid kmp()\n{\n    A[0] = -1;\n    ll j = -1;\n    for (ll i = 0; i < S.size(); i++) {\n        while (j >= 0 && S[i] != S[j])\n            j = A[j];\n        j++;\n        A[i + 1] = j;\n    }\n}\n\n\nvector<ll> size;\n\nll rec(ll n, ll l, ll r, const vector<ll>& count0, const vector<ll>& count1, const vector<ll>& totals)\n{\n    // cout << \"n: \" << n << \" l: \" << l << \" r: \" << r << endl;\n    if (l == 0 and r == size[n] - 1) {\n        return totals[n];\n    }\n    if (n == 0) {\n        if (l == 0) {\n            return count0[r];\n        } else {\n            return count0[r] - count0[l - 1];\n        }\n    } else if (n == 1) {\n        if (l == 0) {\n            return count1[r];\n        } else {\n            return count1[r] - count1[l - 1];\n        }\n    } else {\n        if (r < size[n - 1]) {\n            return rec(n - 1, l, r, count0, count1, totals);\n        } else if (l >= size[n - 1]) {\n            return rec(n - 2, l - size[n - 1], r - size[n - 1], count0, count1, totals);\n        } else {\n            return rec(n - 1, l, size[n - 1] - 1, count0, count1, totals) + rec(n - 2, 0, r - size[n - 1], count0, count1, totals);\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    S = s.substr(0, s.size() / 2);\n    ll l, r;\n    cin >> l >> r;\n    l--, r--;\n\n    ll nums[26];\n    fill(nums, nums + 26, 0);\n    for (ll i = 0; i < s.size(); i++) {\n        nums[s[i] - 'a']++;\n    }\n    ll kind = 0;\n    ll cha = 0;\n    for (ll i = 0; i < 26; i++) {\n        if (nums[i] > 0) {\n            kind++;\n            cha = i;\n        }\n    }\n    if (kind == 1) {  // S=aaa\n        for (ll i = 0; i < 26; i++) {\n            if (i == cha) {\n                cout << r - l + 1 << \" \";\n            } else {\n                cout << 0 << \" \";\n            }\n        }\n        cout << endl;\n    } else {\n        A.resize(S.size() + 1);\n        kmp();\n        const string S0 = S;\n        const string S1 = S0 + S0.substr(0, S.size() - A[S.size()]);\n\n        size.push_back(S0.size());\n        size.push_back(S1.size());\n        const ll size0 = S0.size();\n        const ll size1 = S1.size();\n\n        ll s0 = size0;\n        ll s1 = size1;\n        ll maxind = 2;\n        while (true) {\n            const ll s0_ = s0;\n            s0 = s1;\n            s1 = s0_ + s1;\n            if (s1 > r) {\n                break;\n            }\n            size.push_back(s1);\n            maxind++;\n        }\n        //        show(maxind);\n        for (ll alpha = 0; alpha < 26; alpha++) {\n            const char c = 'a' + alpha;\n            vector<ll> count0(size0, 0);\n            vector<ll> count1(size1, 0);\n            for (ll i = 0; i < size0; i++) {\n                if (i == 0) {\n                    count0[0] = ((c == S0[i]) ? 1 : 0);\n                } else {\n                    count0[i] = count0[i - 1] + ((c == S0[i]) ? 1 : 0);\n                }\n            }\n            for (ll i = 0; i < size1; i++) {\n                if (i == 0) {\n                    count1[0] = ((c == S1[i]) ? 1 : 0);\n                } else {\n                    count1[i] = count1[i - 1] + ((c == S1[i]) ? 1 : 0);\n                }\n            }\n            vector<ll> totals(maxind + 1);\n            totals[0] = count0[size0 - 1];\n            totals[1] = count1[size1 - 1];\n            for (ll i = 2; i <= maxind; i++) {\n                totals[i] = totals[i - 1] + totals[i - 2];\n            }\n            cout << rec(maxind, l, r, count0, count1, totals) << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) {\n      cnt[s[i] - 'a'] += rq - lq;\n    }\n    for (unsigned i = 0; i < rr; ++i) {\n      ++cnt[s[i] - 'a'];\n    }\n    for (unsigned i = 0; i < lr; ++i) {\n      --cnt[s[i]];\n    }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      len.push_back(len[len.size() - 1] + len[len.size() - 2]);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs('z' - 'a' + 1, 0);\n    for (unsigned i = 0; i < cnt_s.size(); ++i) { cnt_gs[i] = cnt_s[i]; }\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        cnt.push_back(cnt[cnt.size() - 1] + cnt[cnt.size() - 2]);\n      }\n      unsigned long long ans = 0;\n      auto rr = r + 1;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      for (unsigned j = 0; j < rr; ++j) {\n        if (s[j] - 'a' == i) { ++ans; }\n      }\n      auto ll = l;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > ll) { continue; }\n        rr -= len[j];\n        ans -= cnt[j];\n      }\n      for (unsigned j = 0; j < ll; ++j) {\n        if (s[j] - 'a' == i) { --ans; }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5;\nconst int SIZE = 205;\nconst LL HMOD = 1e9 + 123, HBASE = 233;\n\nint N;\nLL L, R;\nchar S[MAXN];\n\nvoid input()\n{\n    scanf(\"%s\", S + 1);\n    read(L); read(R);\n    N = strlen(S + 1) / 2;\n}\n\nint period;\nLL Flen[SIZE];\nLL cnt[SIZE];\nint M;\nint curc;\n\nLL count(LL d, LL n)\n{\n    if (d <= 1) {\n        LL ret = 0;\n        for (int j = 1; j <= n; ++j) {\n            ret += (S[j] == curc + 'a');\n        }\n        return ret;\n    }\n    if (n > Flen[d - 1])\n        return cnt[d - 1] + count(d - 2, n - Flen[d - 1]);\n    else\n        return count(d - 1, n);\n}\n\nLL metacount(LL n)\n{\n    return count(M - 1, n);\n}\n\nvoid solve()\n{\n    static LL hval[MAXN];\n\n    for (int i = 1; i <= N; ++i) {\n        hval[i] = (hval[i - 1] * HBASE + S[i] - 'a' + 1) % HMOD;\n    }\n    LL base = 1;\n    for (int i = 1; i < N; ++i) {\n        (base *= HBASE) %= HMOD;\n        if (hval[i] == (hval[N] - hval[N - i] * base % HMOD + HMOD) % HMOD)\n            period = N - i;\n    }\n\n    Flen[M++] = period;\n    Flen[M++] = N;\n    for (; Flen[M - 1] <= 2e18; ++M) {\n        Flen[M] = Flen[M - 1] + Flen[M - 2];\n    }\n\n    for (curc = 0; curc < 26; ++curc) {\n        std::fill(cnt, cnt + M, 0);\n        for (int j = 1; j <= period; ++j) {\n            cnt[0] += (S[j] == curc + 'a');\n        }\n        for (int j = 1; j <= N; ++j) {\n            cnt[1] += (S[j] == curc + 'a');\n        }\n        for (int j = 2; j < M; ++j) {\n            cnt[j] = cnt[j - 1] + cnt[j - 2];\n        }\n\n        printf(\"%lld \", count(M - 1, R) - count(M - 1, L - 1));\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 此生谁料，心在天山，身老沧洲。\n//     -- 陆游《诉衷情·当年万里觅封侯》\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nconst ll b = 2;//1342231LL;\n\nconst int mx = 2e5;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tvector<ll> pw(mx);\n\tpw[0] = 1;\n\trep(i,1,mx) pw[i] = pw[i-1]*b % md;\n\n\tstring s;\n\tcin >> s;\n\tint n = sz(s)/2;\n\tstring a = s.substr(0, n);\n\n\tvector<ll> pre(n+1);\n\trep(i,0,n) pre[i+1] = (pre[i]*b + a[i])%md;\n\n\tint len;\n\tfor(len = n; len --> 0;){\n\t\tif((pre[n]-pre[n-len]*pw[len]%md - pre[len])%md == 0)\n\t\t\tbreak;\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\n\tvector<ll> fibs(200);\n\tfibs[1] = len, fibs[0] = n-len;\n\trep(i,2,200) fibs[i] = fibs[i-1] + fibs[i-2];\n\n\tvector<vector<ll>> cnts(200, vector<ll>(26));\n\trep(i,0,26) cnts[1][i] = count(a.begin(),a.begin()+len, 'a'+i);\n\trep(i,0,26) cnts[0][i] = count(a.begin()+len,a.end(), 'a'+i);\n\trep(i,2,200) rep(j,0,26) cnts[i][j] = cnts[i-1][j]+cnts[i-2][j];\n\n\tfunction<ll(ll,int,int)> que = [&](ll pos, int c, int ix){\n\t\tassert(fibs[ix] >= pos);\n\t\tif(ix == 1){\n\t\t\treturn (ll)count(a.begin(),a.begin()+pos, 'a'+c);\n\t\t}\n\t\tif(ix == 0){\n\t\t\treturn (ll)count(a.begin()+len,a.begin()+len+pos, 'a'+c);\n\t\t}\n\t\tif(pos <= fibs[ix-1]) return que(pos, c, ix-1);\n\t\treturn cnts[ix-1][c] + que(pos-fibs[ix-1],c,ix-2);\n\t};\n\n\tfunction<ll(ll,int)> f = [&](ll pos, int c){\n\t\tint i = 2;\n\t\twhile(fibs[i] < pos) ++i;\n\t\treturn que(pos, c, i);\n\t};\n\trep(c,0,26){\n\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fo(i,x,y) for(int i=x;i<=y;i++)\n#define fd(i,x,y) for(int i=x;i>=y;i--)\nusing namespace std;\n\nconst int maxn=200007;\n\nint n,Brd;\nll L,R;\nchar a[maxn];\nint Fail[maxn];\nll Ans[26];\nint AllCnt[26],BrdCnt[26];\n\nvoid Init(){\n\tscanf(\"%s\",a+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tn=strlen(a+1)/2;\n\tint j=0;\n\tfo(i,2,n){\n\t\twhile (j && a[j+1]!=a[i]) j=Fail[j];\n\t\tif (a[j+1]==a[i]) j++;\n\t\tFail[i]=j;\n\t}\n\tBrd=n-Fail[n];\n\tfo(i,1,n) AllCnt[a[i]-'a']++;\n\tfo(i,1,Brd) BrdCnt[a[i]-'a']++;\n}\n\nvoid Calc(ll N,int Sig){\n\tif (N<=n){\n\t\tfo(i,1,N) Ans[a[i]-'a']+=Sig;\n\t\treturn;\n\t}else fo(k,0,25) Ans[k]+=Sig*AllCnt[k];\n\tll iSnum=1,iTnum=1,Res=N-n,iS=1,iT=0;\n\twhile (N>iSnum*n+iTnum*Brd){\n\t\tRes=N-iSnum*n-iTnum*Brd;\n\t\tfo(k,0,25) Ans[k]+=Sig*(AllCnt[k]*(iSnum-iS)+BrdCnt[k]*(iTnum-iT));\n\t\tll i=iS,j=iT;\n\t\tiS=iSnum,iT=iTnum;\n\t\tiSnum+=i;\n\t\tiTnum+=j;\n\t}\n\tif (Res)\n\t\tCalc(Res,Sig);\n}\nvoid Solve(){\n\tCalc(R,1);\n\tCalc(L-1,-1);\n}\n\nvoid Print(){\n\tfo(i,0,25) printf(\"%lld \",Ans[i]);\n}\n\nint main(){\n\tInit();\n\tSolve();\n\tPrint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nvector<int>Z(char *s)\n{\n\tvector<int>z(1000010);\n\tint l=0,r=0;\n\tint ln=strlen(s);\n\tfor(int k=2;k<=ln;k++)\n\t{\n\t\tif(s[k-1]!=s[0])continue;\n\t\tif(k>r)\n\t\t{\n\t\t\tl=r=k;\n\t\t\twhile(r<=ln && s[r-1]==s[r-l])r++;\n\t\t\tr--;\n\t\t\tz[k]=r+1-l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tk=k+1-l;\n\t\t\tif(z[tk]<r+1-k)\n\t\t\t{\n\t\t\t\tz[k]=z[tk];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=k;\n\t\t\t\twhile(r<=ln && s[r-1]==s[r-l])r++;\n\t\t\t\tr--;\n\t\t\t\tz[k]=r+1-l;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nchar s[200010];\nlong long l,r;\nint p;\nint n;\nlong long sum[200010][26];\nlong long gtans(long long x,int y)\n{\n\tif(x<=n)return sum[x][y];\n\tif(x<=2*n)return sum[x-n][y]+sum[n][y];\n\tlong long s1=sum[n][y]+sum[p][y],s2=sum[n][y],a=n+p,b=n;\n\twhile(x>a+b)\n\t{\n\t\ts1+=s2;s2=s1-s2;a+=b;b=a-b;\n\t}\n\treturn s1+gtans(x-a,y);\n}\nlong long solve(long long x,int y)\n{\n\tif(x<=n)return sum[x][y];\n\tif(n%p==0)\n\t{\n\t\tlong long t=(x-n)/(long long)p*sum[p][y]+sum[n][y];\n\t\tx%=(long long)p;\n\t\treturn t+sum[x][y];\n\t}\n\telse return gtans(x,y);\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tn=strlen(s)/2;\n\tvector<int>res=Z(s);\n\tfor(int i=n+2;i<=strlen(s);i++)\n\t{\n\t\tif(res[i]==strlen(s)+1-i)\n\t\t{\n\t\t\tp=res[i];\n\t\t}\n\t}\n\tp=n-p;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)sum[i][j]+=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",solve(r,i)-solve(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nstring f(const string& s) {\n  const int n = s.size();\n  vector<int> Z(n);\n\n  Z[0] = n;\n  for (int i = 1, j = 0; i < n; ) {\n    while (i + j < n && s[j] == s[i + j]) {\n      ++j;\n    }\n    Z[i] = j;\n    if (j == 0) {\n      ++i;\n      continue;\n    }\n    int k = 1;\n    while (i + k < n && k + Z[k] < j) {\n      Z[i + k] = Z[k];\n      ++k;\n    }\n    i += k;\n    j -= k;\n  }\n\n  int r = 0;\n  for (int i = 1; i * 2 < n; ++i) {\n    if (Z[n - i] == i) {\n      r = i;\n    }\n  }\n\n  return s.substr(0, n - r) + s.substr(0, n - r);\n}\n\nInt len[1024], res[26], cnt[1024][26];\nstring A0, A1;\n\nvoid solve(int k, Int L, Int R) {\n  // cerr<<k<<' '<<L<<' '<<R<<endl;\n  if (len[k] == R - L) {\n    for (int i = 0; i < 26; ++i) {\n      res[i] += cnt[k][i];\n    }\n    return;\n  }\n  if (k <= 1) {\n    const string& s = (k == 0 ? A0 : A1);\n    for (int i = L; i < R; ++i) {\n      res[s[i] - 'a']++;\n    }\n    return;\n  }\n  if (L < len[k - 1]) solve(k - 1, L, min(R, len[k - 1]));\n  if (R > len[k - 1]) solve(k - 2, max(L, len[k - 1]) - len[k - 1], R - len[k - 1]);\n}\n\nint main() {\n  string S;\n  cin >> S;\n\n  Int L, R;\n  cin >> L >> R;\n  --L;\n\n  const string S1 = f(S);\n  const string S2 = f(S1);\n  cerr<<S1<<endl;\n  cerr<<S2<<endl;\n\n  A0 = S1.substr(S.size() / 2, S1.size() / 2 - S.size() / 2);\n  A1 = S2.substr(S1.size() / 2, S2.size() / 2 - S1.size() / 2);\n\n  for (const char c : A0) cnt[0][c - 'a']++;\n  for (const char c : A1) cnt[1][c - 'a']++;\n\n  int k = 1;\n  len[0] = A0.size();\n  len[1] = A1.size();\n  for (int i = 2; ; ++i) {\n    len[i] = len[i - 1] + len[i - 2];\n    for (int j = 0; j < 26; ++j) {\n      cnt[i][j] = cnt[i - 1][j] + cnt[i - 2][j];\n    }\n    if (len[i] > INFLL) {\n      k = i;\n      break;\n    }\n  }\n\n  S = S.substr(S.size() / 2);\n\n  fill(res, res + 26, 0);\n  if (L < S.size()) {\n    while (L < S.size() && L < R) {\n      res[S[L] - 'a']++;\n      ++L;\n    }\n  }\n  L -= S.size();\n  R -= S.size();\n\n  if (R - L > 0) {\n    solve(k, L, R);\n  }\n\n  for (int i = 0; i < 26; ++i) {\n    printf(\"%lld%c\", res[i], i+1 == 26 ? '\\n' : ' ');\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=2e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\nclass alphs{\npublic:\n\tarray<llint,26> kaz;\n\talphs(){for(int i=0;i<26;i++){kaz[i]=0;}}\n\talphs& operator +=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]+=other.kaz[i];}\n\t\treturn (*this);\n\t}\n\talphs& operator -=(alphs other){\n\t\tfor(int i=0;i<26;i++){this->kaz[i]-=other.kaz[i];}\n\t\treturn (*this);\n\t}\n};\nvector<llint> retu;\nvector<alphs> mowa;\nstring str;\nstring nxstr;\nvoid retus(void){\n\tllint k=retu.back();\n\talphs a=mowa.back();\n\twhile(-1){\n\t\tk+=retu[retu.size()-2];retu.pub(k);\n\t\ta+=mowa[mowa.size()-2];mowa.pub(a);\n\t\tif(retu.back()>big){return;}\n\t}\n}\nalphs solve(llint x,llint fu){\n\talphs ans;\n\tif(fu==0){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[str[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(fu==1){\n\t\tfor(llint i=0;i<x;i++){ans.kaz[nxstr[i]-'a']++;}\n\t\treturn ans;\n\t}\n\tif(x<retu[fu-1]){return solve(x,fu-1);}\n\tans=mowa[fu-1];\n\tans+=solve(x-retu[fu-1],fu-2);\n\treturn ans;\n}\n\nint main(void){\n\tllint l,r,n,i,j;//p r p の最初のp\n\tcin>>str;n=str.size();\n\tcin>>l>>r;\n\talphs it;\n\talphs net;\n\tfor(i=0;i<n/2;i++){it.kaz[str[i]-'a']++;}\n\tmowa.pub(it);\n\tretu.pub(n/2);\n\tfor(i=(n/2)+1;i<n;i++){//重ならない数\n\t\tint ok=1;\n\t\tfor(j=0;i+j<n;j++){\n\t\t\tif(str[j]!=str[i+j]){ok=0;break;}\n\t\t}\n\t\tif(ok==1){break;}\n\t}\n\t\n\tfor(j=0;j<i;j++){\n\t\tnxstr.pub(str[j]);\n\t\tnet.kaz[str[j]-'a']++;\n\t}\n\tmowa.pub(net);\n\tretu.pub(nxstr.size());\n\tfor(i=0;i<n/2;i++){str.pob();}//strを半分にする\n\tretus();\n\tauto ans=solve(r,retu.size());\n\tans-=solve(l-1,retu.size());\n\tfor(i=0;i<26;i++){\n\t\tcout<<ans.kaz[i]<<\" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(int _##i = (t), i = (f); i <= _##i; i++)\n#define uptil(f, t, i)   for(int _##i = (t), i = (f); i <  _##i; i++)\n#define downto(f, t, i)  for(int _##i = (t), i = (f); i >= _##i; i--)\n#define downtil(f, t, i) for(int _##i = (t), i = (f); i >  _##i; i--)\ntypedef long double ld;\n#define long long long\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n    #define debug true\n    #define ln << endl\n#else\n    #define debug false\n    #define ln << '\\n'\n#endif\n#define tb << '\\t'\n#define sp << ' '\n\nconst int MOD = 1e9+7;\n\nnamespace sa {\nconstexpr unsigned sINT = sizeof(int);\n\ninline void induced_sort(const int* const s, int n1, int* const sa, int** const bucref, int** const bucref1,\nconst int* const is_stype, const int* const lcount, int C, const int* lms, int clms) {\n    int n = n1 - 1;\n    memcpy(bucref1, bucref, sizeof(int*) * (C + 1));\n    rtimes(clms, l) {\n        int/*s.i*/j = lms[l];\n        *--bucref1[s[j]+1] = j;\n    }\n\n    memcpy(bucref1, bucref, sizeof(int*) * (C + 1));\n    times(n1, a) if(sa[a] > 0) {\n        int/*s.i*/t = sa[a]-1;\n        if(is_stype[t]) continue;\n        *bucref1[s[t]]++ = t;\n    }\n\n    times(C, c) {\n        int* d = bucref[c] + lcount[c];\n        memset(d, -1, sINT * (bucref[c+1] - d));\n    }\n\n    memcpy(bucref1, bucref + 1, sizeof(int*) * C);\n    rtimes(n1, a) if(sa[a] > 0) {\n        int/*s.i*/t = sa[a]-1;\n        if(!is_stype[t]) continue;\n        *--bucref1[s[t]] = t;\n    }\n    sa[0] = n;\n}\n\n/*                       c[i]      i#           i[a]                a[c]                 a[c]*/\nvoid sa_is(const int* const s, int n1, int* const sa, int** const bucref, int** const bucref1,\n/*          a#[c]            i[l]  l[i](L:0,S\\LMS:-1)                   i[l]*/\nint* const lcount, int* const lms, int* const invlms1, int* const lms_sorted, int C) {\n    int n = n1 - 1;\n    if(debug) { times(n, j) assert(s[j] != 0); assert(s[n] == 0); }\n    switch(n) {\n        case 0: sa[0]=0; return; case 1: sa[0]=1; sa[1]=0; return;\n        case 2: sa[0]=2; if(s[0] < s[1]) { sa[1]=0; sa[2]=1; } else { sa[1]=1; sa[2]=0; } return;\n        case 3: sa[0]=3;\n            int a = s[0]-s[1], b = s[1]-s[2], c = s[2]-s[0];\n            if(a > 0) {\n                if(c > 0)    { sa[1]=1; sa[2]=0; sa[3]=2; return; }\n                if(b < 0)    { sa[1]=1; sa[2]=2; sa[3]=0; return; }\n            } else if(b < 0) { sa[1]=0; sa[2]=1; sa[3]=2; return; }\n            if(a < 0)\n                if(c > 0)    { sa[1]=0; sa[2]=2; sa[3]=1; return; }\n                else         { sa[1]=2; sa[2]=0; sa[3]=1; return; }\n            sa[1]=2; sa[2]=1; sa[3]=0; return;\n    }\n\n    times(n1, j) ++bucref[s[j]+1];\n    bucref[0] = sa;\n    times(C, c) bucref[c+1] += (unsigned int)bucref[c] / sINT;\n\n/********* check S-Type or L-Type *********/\n    invlms1[n] = -1;\n    rtimes(n, j) invlms1[j] = s[j] != s[j+1] ? -(s[j] < s[j+1]) : invlms1[j+1];\n    times(n1, j) if(!invlms1[j]) ++lcount[s[j]]; // LType\n\n/********* list up LMS *********/\n    int/*l*/clms = 0;\n    upto(1, n, j) if(!invlms1[j-1] && invlms1[j]) { // j-1: LType, j: SType\n        lms[clms] = j;\n        ++clms;\n        invlms1[j] = clms;\n        ++j; //: LS[?]\n    }\n\n/********* rough induced sort *********/\n    induced_sort(s, n1, sa, bucref, bucref1, invlms1, lcount, C, lms, clms);\n    int lsi = 0;\n    times(n1, a) if(sa[a] >= 0 && invlms1[sa[a]] > 0 /*LMS*/) lms_sorted[lsi++] = sa[a];\n    // assert(lsi == clms);\n\n/********* SA-IS LMS-suffix *********/\n    int lq = 0;\n    int* const/*lms.c[l]*/lms_syms = sa;\n    times(clms, l) {\n        int j = lms_sorted[l], m1 = invlms1[j];\n        if(l > 1) {\n            int i = lms_sorted[l-1];\n            if(lms[m1] - j == lms[invlms1[i]] - i) {\n                int k = lms[m1] - j;\n                ++lq;\n                upto(0, k, h) if(s[j+h] != s[i+h]) { --lq; break; }\n            }\n        }\n        lms_syms[m1-1] = l - lq;\n    }\n    int* const bc = bucref[C];\n    int*/*l[e]*/lms_sa = sa + n1;\n    sa_is(lms_syms, clms, lms_sa, bucref + C, bucref1, lcount + C,\n        lms + clms, invlms1 + n1, lms_sorted + clms, clms - lq);\n    bucref[C] = bc;\n\n/********* strict induced sort *********/\n\n    memset(sa, -1, n1 * sINT); // fill(sa, sa + n1, -1);\n\n    times(clms, e) lms_sa[e] =  lms[lms_sa[e]];\n    /* now lms_sa is: i[e] */\n    induced_sort(s, n1, sa, bucref, bucref1, invlms1, lcount, C, lms_sa, clms);\n}\n\nbool inited = false;\nint *saG, **brG, **br1G, *lcG, *lmsG, *il1G, *lsoG;\nvoid init(int N1, int C) { // memory used: (8.5N+3C+3)*4bytes\n    if(inited) return; inited = true;\n    saG = new int[N1*2]; brG = new int*[C+N1+1]; br1G = new int*[max(N1/2,C)+1];\n    lcG = new int[C+N1+1]; lmsG = new int[N1]; il1G = new int[N1*2]; lsoG = new int[N1];\n}\nvoid is_k(const int* const s, int n1, int c) {\n    bool gs = false;\n    if(n1 * 3 < c) {\n        gs = n1 < 50;\n        if(!gs) {\n            int b = s[n1/3 + 1], a = 0;\n            times(n1, i) a += s[i] == b;\n            gs = a < n1 / a;\n        }\n    }\n    if(debug) assert(inited);\n    if(gs) {\n        times(n1, i) saG[i] = i;\n        sort(saG, saG + n1, [&](int i, int j) {\n            if(i == j) return false;\n            while(s[i] == s[j]) { ++i; ++j; }\n            return s[i] < s[j];\n        });\n    } else {\n        memset(saG, -1, n1*2*sINT); memset(brG, 0, (n1+c+1)*sINT); memset(lcG, 0, (n1+c+1)* sINT);\n        sa_is(s, n1, saG, brG, br1G, lcG, lmsG, il1G, lsoG, c);\n    }\n}\nvoid done() { inited = false; if(debug) cerr << \"WARNING: void sa::done() does nothing.\" << endl; }\n}\n\nint s[200005], N;\nmap<long, array<long, 26>> c;\n\nsigned main() { // long: 64bit\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n\n    string S; cin >> S;\n    N = S.size();\n    long L, R; cin >> L >> R;\n\n    sa::init(N + 1, 27);\n    times(N, i) {\n        s[i] = S[i] - 'a' + 1;\n    }\n    s[N] = 0;\n    sa::is_k(s, N + 1, 27);\n    long p0;\n    times(N+1, i) if(sa::saG[i] == 0) {\n        while(i >= 0 && sa::saG[--i] <= N / 2);\n        if(i >= 0)\n            p0 = sa::saG[i];\n        else\n            p0 = N;\n        break;\n    }\n    if(debug) cout << p0 ln;\n\n    times(26, i) c[0][i] = 0;\n    times(N, j) times(26, i) {\n        c[-j-1][i] = c[-j][i] + (S[j] == 'a' + i);\n    }\n    {\n        long p2 = p0, q2 = N, p1 = p2 + q2 / 2, q1 = p2 * 2;\n        times(26, i) {\n            c[-p1][i] = c[-p2][i] + c[-q2][i] / 2;\n            c[-q1][i] = c[-p2][i] * 2;\n        }\n        while(q1 < R) {\n            long p = p1 + p2, q = q1 + q2;\n            times(26, i) {\n                c[-p][i] = c[-p1][i] + c[-p2][i];\n                c[-q][i] = c[-q1][i] + c[-q2][i];\n            }\n            p2 = p1; p1 = p;\n            q2 = q1; q1 = q;\n        }\n    }\n    if(debug) {\n        for(const auto& x: c) {\n            cout << x.first tb;\n            times(26, i) cout << x.second[i] sp;\n            cout ln;\n        }\n    }\n\n    long l[26], r[26];\n    times(26, i) l[i] = r[i] = 0;\n    if(debug) cout << \"L\\n\";\n    while(L > 0) {\n        auto x = c.lower_bound(-L);\n        L += x->first;\n        times(26, i) l[i] += x->second[i];\n        if(debug) {\n            cout << L tb;\n            times(26, i) cout << l[i] sp;\n            cout ln;\n        }\n    }\n    if(debug) cout << \"R\\n\";\n    ++R;\n    while(R > 0) {\n        auto x = c.lower_bound(-R);\n        R += x->first;\n        times(26, i) r[i] += x->second[i];\n        if(debug) {\n            cout << R tb;\n            times(26, i) cout << r[i] sp;\n            cout ln;\n        }\n    }\n\n    times(26, i) {\n        if(i) cout sp;\n        cout << r[i] - l[i];\n    }\n    cout ln;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nconst LL maxn=200010;\nconst LL inf=1e18;;\nchar s[maxn];\nLL len[1000],nt[1000],cnt1[1000][27],cnt2[1000][27],o[27],ans[27];\nLL nxt[maxn];\nLL k,t,n,m,tot,top;\nLL l,r;\nvoid kmp()\n{\n    LL j=0;\n    for(LL i=2;i<=n;i++)\n\t{\n        while(j&&s[j+1]!=s[i]) j=nxt[j];\n        if(s[j+1]==s[i]) j++;\n        nxt[i]=j;\n    }\n}\nvoid work(LL n,LL f)\n{\n    for(int i=top;i>=1;i--)\n        if (n>=len[i])\n\t\t{\n            for(int j=0;j<26;j++) ans[j]+=f*(cnt1[i][j]*2+cnt2[i][j]);\n            n-=len[i];\n        }\n    if (n>=len[0])\n\t{\n        for(int j=0;j<26;j++) ans[j]+=f*o[j];\n        n-=len[0];\n    }\n    for(int i=1;i<=n;i++) ans[s[i]-'a']+=f;\n}\nvoid solve(LL n,LL f)\n{\n    for(int i=0;i<26;i++) ans[i]+=(LL)f*(n/tot)*o[i];\n    n%=tot;\n    for(int i=1;i<=n;i++) ans[s[i]-'a']+=f;\n}\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    n/=2;\n    kmp();\n    if (n%(n-nxt[n]))\n\t{\n        for(int i=1;i<=nxt[n];i++) cnt1[0][s[i]-'a']++;\n        for(int i=nxt[n]+1;i<=n-nxt[n];i++) cnt2[0][s[i]-'a']++;\n        for(int i=1;i<=n;i++) o[s[i]-'a']++;\n        len[0]=n;nt[0]=nxt[n];\n        if (nxt[n]>=(n+1)/2)\n\t\t{\n            top++;\n            len[top]=len[top-1]*2-nt[top-1];\n            nt[top]=len[top-1]-nt[top-1];\n            for(int i=1;i<=nt[top];i++) cnt1[top][s[i]-'a']++;\n            for(int i=n-nxt[n]+1;i<=n;i++) cnt2[top][s[i]-'a']++;\n        }\n        while(len[top]<inf)\n\t\t{\n            top++;\n            len[top]=len[top-1]*2-nt[top-1];\n            nt[top]=len[top-1]-nt[top-1];\n            for(int i=0;i<26;i++)\n\t\t\t{\n                cnt1[top][i]=cnt1[top-1][i]+cnt2[top-1][i];\n                cnt2[top][i]=cnt1[top-1][i];\n            }\n        }\n        scanf(\"%lld%lld\",&l,&r);\n        work(r,1);work(l-1,-1);\n        for(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n    }\n    else\n\t{\n        tot=n-nxt[n];\n        for(int i=1;i<=tot;i++) o[s[i]-'a']++;\n        scanf(\"%lld%lld\",&l,&r);\n        solve(r,1);solve(l-1,-1);\n        for(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 200000;\n\nll a[26], b[26], c[150][26], d[150];\n\nchar S[MAXN + 5]; int f[MAXN + 5];\nint main() {\n\tint n, m; ll l, r;\n\tscanf(\"%s%lld%lld\", S + 1, &l, &r);\n\tn = strlen(S + 1), m = n / 2;\n\t\n\tf[0] = -1, f[1] = 0;\n\tfor(int i=2;i<=m;i++) {\n\t\tint j = f[i - 1];\n\t\twhile( j != -1 && S[i] != S[j + 1] )\n\t\t\tj = f[j];\n\t\tf[i] = j + 1;\n\t}\n\t\n\tint p = m - f[m];\n\tfor(int i=1;i<=p;i++) c[0][S[i] - 'a']++;\n\tfor(int i=1;i<=m;i++) c[1][S[i] - 'a']++;\n\tint k; d[0] = p, d[1] = m;\n\tfor(k=1;d[k]<=r;k++) {\n\t\tfor(int j=0;j<26;j++)\n\t\t\tc[k + 1][j] = c[k][j] + c[k - 1][j];\n\t\td[k + 1] = d[k] + d[k - 1];\n\t}\n\t\n\tll t = r;\n\tfor(int i=k;i>=0;i--) {\n\t\tif( t >= d[i] ) {\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\ta[j] += c[i][j];\n\t\t\tt -= d[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=t;i++)\n\t\ta[S[i] - 'a']++;\n\t\t\n\tt = l - 1;\n\tfor(int i=k;i>=0;i--) {\n\t\tif( t >= d[i] ) {\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\ta[j] -= c[i][j];\n\t\t\tt -= d[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=t;i++)\n\t\ta[S[i] - 'a']--;\n\t\n\tfor(int i=0;i<26;i++) printf(\"%lld \", a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int MAXN=3e5+5;\n\nint len,anc[30][MAXN],S,T,num,p[MAXN];\nll l,r;\nchar s[MAXN];\n\nll calc(ll lt,int n){\n\tif(lt<=len)return anc[n][lt];\n\tif(lt<=2*len)return anc[n][len]+anc[n][lt-len];\n\tll f1=anc[n][S],f2=anc[n][len],lenf1=S,lenf2=len;\n\twhile(lt>lenf1+lenf2){\n\t\tll tem2=f2,lentem2=lenf2;\n\t\tf2+=f1;lenf2+=lenf1;\n\t\tf1=tem2;lenf1=lentem2;\n\t}\n\treturn f2+calc(lt-lenf2,n);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\tlen=strlen(s+1)/2;\n/*\tbool ok=0;\n\tfor(int i=2*len;;i--){\n\t\tint tmp=i;num=1;\n\t\twhile(s[num]==s[tmp]){\n\t\t\tnum++;tmp++;\n\t\t\tif(tmp==2*len+1){\n\t\t\t\tok=1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t}\n\t\tif(ok){num--;break;}\n\t}\t*/\n\tp[1] = 0;\n    for (int j = 0, i = 2; i <= len; i ++) {\n        for (; j && s[j + 1] != s[i];) j = p[j];\n        if (s[j + 1] == s[i]) j ++;\n        p[i] = j;\n    }\n//\tT=num;\n//\tS=len-num;\n\tS=len-p[len];\n\tfor(int i=1;i<=26;i++){\n\t\tfor(int j=1;j<=len;j++){\n\t\t\tanc[i][j]=anc[i][j-1];\n\t\t\tif((int)s[j]-96==i)anc[i][j]++;\n\t\t}\n\t}\n//\tcout<<calc(43200,1);\n\tfor(int i=1;i<=26;i++){\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n\ntypedef long long LL;\nconst int N=100005;\n\nint cnt[N][26],fail[N],n,t;\nchar s[N*2];\n\nLL calc(LL pos,int c){\n\tif (pos<=n) return cnt[pos][c];\n\tLL s1=cnt[n][c],s2=cnt[t][c],len1=n,len2=t;\n\tfor (;len1+len2<=pos;){\n\t\tLL tmp=s1;s1+=s2;s2=tmp;\n\t\ttmp=len1;len1+=len2;len2=tmp;\n\t}\n\treturn s1+calc(pos-len1,c);\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tfail[0]=-1;\n\tfor (int i=1,j=-1;i<=n;fail[i++]=++j)\n\t\tfor (;j>=0 && s[j+1]!=s[i];j=fail[j]);\n\tLL l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tt=n-fail[n];\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++) cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2e5 + 5; \ntypedef long long ll;\ntypedef unsigned int ui;\nconst ui p = 19260817; \nusing namespace std;\n\nint n, Pos; \nll s[105][30], b[105][30], a[105][30], cnt[30], L, R; \nui pw[N], hashh[N]; \nchar S[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nui gethashh(int l, int r)\n{\n\tint len = r - l + 1; \n\treturn hashh[r] - hashh[l - 1] * pw[len]; \n}\n\nvoid prepare()\n{\n\tfor(int i = (pw[0] = 1); i <= n; i++) pw[i] = pw[i - 1] * p;\n\tfor(int i = 1; i <= n; i++) hashh[i] = hashh[i - 1] * p + (S[i] - 'a' + 1);\n\tPos = 0; \n\tfor(int i = 1; i < n / 2; i++)\n\t\tif(gethashh(1, i) == gethashh(n - i + 1, n)) Pos = i; \n\tfor(int i = 1; i <= Pos; i++) s[0][0]++, s[0][S[i] - 'a' + 1]++; \n\tfor(int i = Pos + 1; i <= n / 2; i++) a[0][0]++, a[0][S[i] - 'a' + 1]++; \n\tfor(int i = n / 2 + 1; i <= n - Pos; i++) b[0][0]++, b[0][S[i] - 'a' + 1]++; \n}\n\nvoid calc(ll x, int op, int pos, int type)\n{\n\tif(!x) return;\n\tif(!pos)\n\t{\n\t\tif(!type)\n\t\t\tfor(int i = 1; i <= min(x, 1ll * Pos); i++) cnt[S[i] - 'a' + 1]++; \n\t\telse if(type == 1)\n\t\t\tfor(int i = Pos + 1; i <= min(1ll * n / 2, Pos + x); i++) cnt[S[i] - 'a' + 1]++;\n\t\telse for(int i = n / 2 + 1; i <= min(1ll * n / 2 + x, 1ll * n - Pos); i++) cnt[S[i] - 'a' + 1]++;\n\t\treturn; \n\t}\n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 1); \n\t}\n\tif(type == 1)\n\t{\n\t\tif(x >= a[pos][0])\n\t\t{\n\t\t\tx -= a[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += a[pos][j] * op; \n\t\t\ttype = 2; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= s[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= s[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos - 1][j] * op; \n\t\t\t\treturn calc(x, op, pos - 1, 2); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 0); \n\t\t}\n\t}\n\tif(type == 2)\n\t{\n\t\tif(x >= b[pos][0])\n\t\t{\n\t\t\tx -= b[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos][j] * op; \n\t\t\ttype = 0; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= b[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= b[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos - 1][j] * op; \n\t\t\t\treturn calc(x, op, pos - 1, 0); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 2); \n\t\t}\n\t}\n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 1); \n\t}\n}\n\nvoid solve(ll L, ll R, int id) { calc(R, 1, id, 0), calc(L - 1, -1, id, 0); }\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin), freopen(\"cpp.out\", \"w\", stdout); \n#endif\n\tscanf(\"%s\", S + 1), n = strlen(S + 1); \n\tprepare(), L = read <ll> (), R = read <ll> (); \n\tfor(int i = 1; i <= 92; i++)\n\t{\n\t\tfor(int j = 0; j <= 26; j++)\n\t\t\ts[i][j] = b[i - 1][j], b[i][j] = b[i - 1][j] + s[i - 1][j], a[i][j] = s[i - 1][j] + b[i - 1][j];\n\t\tif(1.0 * -R + s[i][0] + a[i][0] + b[i][0] + s[i][0] >= 0)\n\t\t{\n\t\t\tsolve(L, R, i); break;\n\t\t}\n\t}\n\tfor(int i = 1; i <= 26; i++) printf(\"%lld%c\", cnt[i], i == 26 ? '\\n' : ' '); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 300000;\n\nint n, kmp[N], T; char s[N];\nll l, r, num[N][30];\n\nll fib(ll len, int c){\n    if(len <= n) return num[len][c];\n    if(len <= n * 2) return num[len][c] + num[len-n][c];\n    ll f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n    // 1 : S, 2 : ST;\n    while(len > l1 + l2){\n        ll tmp = f2;\n        f2 += f1; f1 = tmp;\n        tmp = l2;\n        l2 += l1; l1 = tmp;\n        //2 --> 1 + 2; 1 --> 2\n        //exp: STSST --> STSSTSTS; STS --> STSST \n    }\n    return f2 + fib(len - l2, c);\n}\n\nll calc(ll len, int c){ // 计算前 len 位 c 出现的次数\n    if(len <= n) return num[len][c];\n    if(n % T == 0){ // 形如 TTT TTT 的字符串\n        ll ret = 1ll * (len-n) / T * num[T][c] + num[n][c]; // T 出现了(len-n)/T次, n出现了1次\n        len -= n; len %= T;\n        return ret + num[len][c];\n    }\n    return fib(len, c);\n}\n\nint main(){\n    scanf(\"%s%lld%lld\", s+1, &l, &r);\n    n = strlen(s+1) / 2;\n    kmp[0] = kmp[1] = 0; int p = 0;\n    for(int i=2; i<=n; i++){\n        while(p && s[i] != s[p+1]) p = kmp[p];\n        kmp[i] = (s[i] == s[p+1]) ? ++p : p;\n    }\n\n    for(int i=1; i<=n; i++){\n        for(int j=0; j< 26; j++)\n            num[i][j] = num[i-1][j];\n        num[i][s[i] - 'a'] ++;\n    } // num[i][j] : 第i位和之前字符j出现的次数\n    T = n - kmp[n]; // T:最长的等于一个前缀的后缀的起始位置 \n    //printf(\"%d\\n\", T);\n    for(int i=0; i< 26; i++)\n        printf(\"%lld%c\", calc(r, i) - calc(l-1, i), (i == 25) ? 10 : 32);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j]-cnt[i-1][j]/2;\n\t\t\tV-=cnt[i][26]-cnt[i-1][26]/2;\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) {\n      cnt[s[i] - 'a'] += rq - lq;\n    }\n    for (unsigned i = 0; i < rr; ++i) {\n      ++cnt[s[i] - 'a'];\n    }\n    for (unsigned i = 0; i < lr; ++i) {\n      --cnt[s[i]];\n    }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      len.push_back(len[len.size() - 1] + len[len.size() - 2]);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs = cnt_s;\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        cnt.push_back(cnt[cnt.size() - 1] + cnt[cnt.size() - 2]);\n      }\n      unsigned long long ans = 0;\n      auto rr = r + 1;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      for (unsigned j = 0; j < rr; ++j) {\n        if (s[j] - 'a' == i) { ++ans; }\n      }\n      auto ll = l;\n      for (auto j = len.size() - 1; j > 0; --j) {\n        if (len[j] > ll) { continue; }\n        rr -= len[j];\n        ans -= cnt[j];\n      }\n      for (unsigned j = 0; j < ll; ++j) {\n        if (s[j] - 'a' == i) { --ans; }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 200005\nusing namespace std;\n//ifstream cin(\"date.in\");\n//ofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(int i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    n /= 2;\n    for(i = 2; i <= n; i++){\n        while(L > 0 && s[i] != s[L + 1]){\n            L = p[L];\n        }\n        if(s[i] == s[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    for(i = 1; i <= n; i++){\n        ok = 1;\n        for(j = i + i; j <= n; j += i){\n            if(p[j] != j - i){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(j = j - i + 1; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n >= dr || fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next NexT\n#define LL long long\n\nconst int maxn=2e5+10;\n\nint n,next[maxn];\nLL L,R,c0[30],cA[30],cB[30],Ans[30],LA,LB;\nchar s[maxn];\n\nvoid KMP()\n{\n\tint i;\n\tnext[0]=0; next[1]=0;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tnext[i]=next[i-1];\n\t\twhile (s[next[i]+1]!=s[i]&&next[i])\n\t\t\tnext[i]=next[next[i]];\n\t\tnext[i]+=s[next[i]+1]==s[i];\n\t}\n}\n\nvoid solve(LL R,int flag)\n{\n\tint i;\n\tif (R<=n)\n\t{\n\t\tfor (i=1;i<=R;i++)\n\t\t\tAns[s[i]-'a']+=flag;\n\t\treturn;\n\t}\n\tLA=next[n];\n\tLB=n-2*next[n];\n\tmemset(cA,0,sizeof(cA));\n\tmemset(cB,0,sizeof(cB));\n\tfor (i=1;i<=LA;i++) cA[s[i]-'a']++;\n\tfor (i=LA+1;i<=LA+LB;i++) cB[s[i]-'a']++;\n\twhile (LA+LB+LA+LA+LB<=R)\n\t{\n\t\tswap(LA,LB); LA+=LB;\n\t\tfor (i=0;i<26;i++)\n\t\t\tswap(cA[i],cB[i]),cA[i]+=cB[i];\n\t}\n\tfor (i=0;i<26;i++)\n\t\tAns[i]+=flag*(cA[i]+cB[i]+cA[i]);\n\tR-=LA+LB+LA;\n\twhile (R)\n\t{\n\t\tif (LA+LB+LA==n) break;\n\t\tLA-=LB; swap(LA,LB);\n\t\tfor (i=0;i<26;i++)\n\t\t\tcA[i]-=cB[i],swap(cA[i],cB[i]);\n\t\tif (R>=LA)\n\t\t{\n\t\t\tfor (i=0;i<26;i++)\n\t\t\t\tAns[i]+=flag*cA[i];\n\t\t\tR-=LA;\n\t\t}\n\t}\n\tfor (i=1;i<=R;i++) Ans[s[i]-'a']+=flag;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i;\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&L,&R);\n\tn=strlen(s+1);\n\tn=n/2;\n\tKMP();\n\tif (n%(n-next[n])==0)\n\t{\n\t\tfor (i=1;i<=n;i++) c0[s[i]-'a']++;\n\t\tfor (i=0;i<26;i++) Ans[i]+=c0[i]*((R/n)-((L-1)/n));\n\t\tfor (i=1;i<=R%n;i++) Ans[s[i]-'a']++;\n\t\tfor (i=1;i<=(L-1)%n;i++) Ans[s[i]-'a']--;\n\t\tfor (i=0;i<26;i++) printf(\"%lld \",Ans[i]);\n\t\treturn 0;\n\t}\n\twhile (next[n]>=(n+1)/2)\n\t\tn+=n-next[n],KMP();\n\n\tsolve(R,+1);\n\tsolve(L-1,-1);\n\tfor (i=0;i<26;i++)\n\t\tprintf(\"%lld \",Ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=200000+10;\nconst ll inf=1000000000000000000;\nchar s[maxn];\nll len[1000],nt[1000],cnt1[1000][27],cnt2[1000][27],o[27],ans[27];\nint nxt[maxn];\nint i,j,k,t,n,m,tot,top;\nll l,r;\nvoid kmp(){\n\tj=0;\n\tfo(i,2,n){\n\t\twhile (j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif (s[j+1]==s[i]) j++;\n\t\tnxt[i]=j;\n\t}\n}\nvoid work(ll n,int f){\n\tint i,j;\n\tfd(i,top,0)\n\t\tif (n>=len[i]){\n\t\t\tfo(j,0,25) ans[j]+=f*(cnt1[i][j]*2+cnt2[i][j]);\n\t\t\tn-=len[i];\n\t\t}\n\tfo(i,1,n) ans[s[i]-'a']+=f;\n}\nvoid solve(ll n,int f){\n\tint i,j;\n\tfo(i,0,25) ans[i]+=(ll)f*(n/tot)*o[i];\n\tn%=tot;\n\tfo(i,1,n) ans[s[i]-'a']+=f;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tn/=2;\n\tkmp();\n\tif (nxt[n]<(n+1)/2){\n\t\tfo(i,1,nxt[n]) cnt1[0][s[i]-'a']++;\n\t\tfo(i,nxt[n]+1,n-nxt[n]) cnt2[0][s[i]-'a']++;\n\t\tlen[0]=n;nt[0]=nxt[n];\n\t\twhile (len[top]<inf){\n\t\t\ttop++;\n\t\t\tlen[top]=len[top-1]*2-nt[top-1];\n\t\t\tnt[top]=len[top-1]-nt[top-1];\n\t\t\tfo(i,0,25){\n\t\t\t\tcnt1[top][i]=cnt1[top-1][i]+cnt2[top-1][i];\n\t\t\t\tcnt2[top][i]=cnt1[top-1][i];\n\t\t\t}\n\t\t}\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t\tfo(i,0,25) printf(\"%lld \",ans[i]);\n\t}\n\telse{\n\t\ttot=n-nxt[n];\n\t\tfo(i,1,tot) o[s[i]-'a']++;\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t\tfo(i,0,25) printf(\"%lld \",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <complex>\n#include <ctime>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\n#define REP(i,s,t) for(int i=(s);i<(t);i++)\n#define FILL(x,v) memset(x,v,sizeof(x))\n\nconst ll INF = (ll)1E18+1;\n#define MAXN 200005\n\nchar pattern[MAXN];\nint nxt[MAXN];\nvoid calcNext(){\n  int k=0, len = strlen(pattern);\n  nxt[0] = 0;\n  for(int i=1; i<=len; i++){\n    if(pattern[i]==pattern[k]) nxt[i] = nxt[k++];\n    else{\n      nxt[i] = k;\n      while(k>0 && pattern[i]!=pattern[k]) k=nxt[k];\n      if(pattern[k]==pattern[i]) k++;\n    }\n  }\n}\n\nll plen[100], cnt[100][26];\nint N, Tlen, stcnt[MAXN][26];\nvector<ll> solve(int i, ll k) {\n  vector<ll> sol(26,0), sol2(26,0);\n  if (k == 0) return sol;\n  if (i <= 1) {\n    REP(c,0,26) sol[c] = stcnt[k-1][c];\n    return sol;\n  }\n  if (k <= plen[i-1]) {\n    sol = solve(i-1, k);\n  } else {\n    REP(c,0,26) sol[c] = cnt[i-1][c];\n    sol2 = solve(i-2, k-plen[i-1]);\n    REP(c,0,26) sol[c] += sol2[c];\n  }\n  return sol;\n}\nint main() {\n  ll L, R;\n  cin >> pattern >> L >> R;\n  N = strlen(pattern);\n  N /= 2;\n  pattern[N] = 0;\n  calcNext();\n  Tlen = N - nxt[N];\n  REP(i,N,N+Tlen) pattern[i] = pattern[i-N];\n  REP(i,0,N+Tlen) {\n    if (i) REP(c,0,26) stcnt[i][c] = stcnt[i-1][c];\n    stcnt[i][pattern[i]-'a']++;\n  }\n  plen[0] = N;\n  plen[1] = N + Tlen;\n  REP(c,0,26) {\n    cnt[0][c] = stcnt[plen[0]-1][c];\n    cnt[1][c] = stcnt[plen[1]-1][c];\n  }\n  int maxi = 1;\n  REP(i,2,100) {\n    plen[i] = plen[i-1] + plen[i-2];\n    REP(c,0,26) cnt[i][c] = cnt[i-1][c] + cnt[i-2][c];\n    if (plen[i] >= INF) {\n      maxi = i;\n      break;\n    }\n  }\n  vector<ll> ans = solve(maxi, R);\n  vector<ll> dec = solve(maxi, L-1);\n  REP(c,0,26) cout << ans[c] - dec[c] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"YES\"; }\n  string_type do_falsename() const { return \"NO\"; }\n};\n\nclass RollingHash {\n  using ll = long long;\n  const int n;\n  static const ll moda = 1000000000000037LL;\n  static const ll modb = 1000000000000091LL;\n  static const ll pa = 17LL;\n  static const ll pb = 19LL;\n  vector<ll> a, b, p, q;\npublic:\n  RollingHash (const string &str) :\n    n(str.size()), a(n+1, 0), b(n+1, 0), p(n+1, 1), q(n+1, 1) {\n    for (int i = 0; i < n; ++i) {\n      a[i+1] = (a[i] * pa + str[i]) % moda;\n      b[i+1] = (b[i] * pb + str[i]) % modb;\n      p[i+1] = p[i] * pa % moda;\n      q[i+1] = q[i] * pb % modb;\n    }\n  }\n  pair<ll,ll> query(int l, int r) {\n    return make_pair(((__int128)p[r - l] * a[l] - a[r] + moda) % moda,\n                     ((__int128)q[r - l] * b[l] - b[r] + modb) % modb);\n  }\n};\n\nll cnt[201000][32];\n\nvector<ll> add_vector(vector<ll> a, vector<ll> b) {\n  REP(i,26) a[i] += b[i];\n  return a;\n}\n\npair<vector<ll>,ll> f(ll n,\n                      const ll left_len,  const vector<ll> left,\n                      const ll right_len, const vector<ll> right)\n{\n  vector<ll> res(26);\n  if (left_len + right_len <= n) {\n    ll sum_len = left_len + right_len;\n    vector<ll> sum = add_vector(left, right);\n    auto x = f(n, sum_len, sum, left_len, left);\n    res = add_vector(res, x.first);\n    n = x.second;\n  }\n  if (left_len <= n) {\n    res = add_vector(res, left);\n    n -= left_len;\n  }\n  return make_pair(res, n);\n}\n\nvoid solve(string S, ll l, ll r) {\n  S = S.substr(0, S.size() / 2);\n  --l;\n  const int n = S.size();\n  RollingHash hash(S);\n  int max_len = 0;\n  REP(i,n) {\n    if (hash.query(0, i) == hash.query(n - i, n))\n      max_len = i;\n  }\n  REP(i,n) {\n    REP(j,26) cnt[i+1][j] = cnt[i][j];\n    cnt[i+1][S[i] - 'a'] += 1;\n  }\n  if (max_len == 0) {\n    REP(ch,26) {\n      ll res = 0;\n      res += cnt[n][ch] * (r / n) + cnt[r % n][ch];\n      res -= cnt[n][ch] * (l / n) + cnt[l % n][ch];\n      cout << res << \" \\n\"[ch == 25];\n    }\n  }\n  else {\n    vector<ll> left(26), right(26);\n    REP(i,26) left[i] = cnt[n - max_len][i];\n    REP(i,26) right[i] = cnt[n][i] - cnt[n - max_len][i];\n    auto rret = f(r, n - max_len, left, max_len, right);\n    auto lret = f(l, n - max_len, left, max_len, right);\n    REP(i,26) {\n      ll res =\n        (rret.first[i] + cnt[rret.second][i]) -\n        (lret.first[i] + cnt[lret.second][i]);\n      cout << res << \" \\n\"[i == 25];\n    }\n  }\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll r;\n\tstring S;\n\tll l;\n\tcin >> S;\n\tscanf(\"%lld\", &l);\n\tscanf(\"%lld\", &r);\n\tsolve(S, l, r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 200005;\n\nLL f[maxn][27];char s[maxn];int n,k,pre[maxn];\nLL sum1[maxn],sum2[maxn];\nvoid solve(LL n,int t,LL *c) {\n\tif (n<=0) return ;\n\tif (n<=2) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tc[s[j]-'a']++;\n\t\treturn ;\n\t}\n\tif (f[t][26]==n) {\n\t\tfor (int j=0;j<26;j++)\n\t\t\tc[j]+=f[t][j];\n\t\treturn ;\n\t}\n\tif (f[t-1][26]>=n) solve(n,t-1,c);\n\telse {\n\t\tfor (int j=0;j<26;j++)\n\t\t\tc[j]+=f[t-1][j];\n\t\tsolve(n-f[t-1][26],t-2,c);\n\t}\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc077f.in\",\"r\",stdin);\n\t\tfreopen(\"arc077f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);n=strlen(s+1)>>1;\n\tfor (int i=2;i<=n;i++) {\n\t\tint p=pre[i-1];\n\t\twhile (p&&s[p+1]!=s[i]) p=pre[p];\n\t\tif (s[p+1]==s[i]) pre[i]=p+1;\n\t}\n\tk=n-pre[n];f[1][26]=n;f[2][26]=n+k;\n\tfor (int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tfor (int i=1;i<=n+k;i++) f[2][s[i]-'a']++;\n\tint o=2;\n\tfor (int i=3;;i++) {\n\t\tfor (int j=0;j<=26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\to=i;\n\t\tif (f[i][26]>1e18) break;\n\t}\n\t\n\tLL l,r;scanf(\"%lld %lld\",&l,&r);\n\tsolve(r,o,sum1);solve(l-1,o,sum2);\n\tfor (int i=0;i<26;i++)\n\t\tprintf(\"%lld \",sum1[i]-sum2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <deque>\n#include <queue>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <utility>\n#include <functional>\nusing namespace std;\n#define ll long long\n#define ull unsigned ll\nint n, fail[100005];\nint len;\nll pre[100005][26];\nll l, r;\nstring s;\nint gaofail(string &str) {\n\tfail[0]=0;\n\tfail[1]=0;\n\tfor (int i=1, j=0; i<n; i++) {\n\t\twhile (j&&str[i]!=str[j]) j=fail[j];\n\t\tif (str[i]==str[j]) j++;\n\t\tfail[i+1]=j;\n\t}\n\treturn fail[n];\n}\nvoid gaopre() {\n\tpre[0][s[0]-'a']=1ll;\n\tfor (int i=1; i<n; i++) {\n\t\tfor (int j=0; j<26; j++) pre[i][j]=pre[i-1][j];\n\t\tpre[i][s[i]-'a']++;\n\t}\n}\nll calc1(ll i, int c) {\n\tif (i<0)\n\t\treturn 0;\n\tif (i<n)\n\t\treturn pre[i][c];\n\ti-=n;\n\treturn pre[n-1][c]+pre[len-1][c]*(i/len)+pre[i%len][c];\n}\nll calc2(ll i, int c) {\n\tif (i<0)\n\t\treturn 0;\n\tif (i<n)\n\t\treturn pre[i][c];\n\tif (i<2*n)\n\t\treturn pre[n-1][c]+pre[i-n][c];\n\tll f1=n, f2=n+len, r1=pre[n-1][c], r2=pre[n-1][c]+pre[len-1][c];\n\twhile (f1+f2<i) {\n\t\tll t=f2;\n\t\tf2+=f1;\n\t\tf1=t;\n\t\tt=r2;\n\t\tr2+=r1;\n\t\tr1=t;\n\t}\n\treturn r2+calc2(i-f2, c);\n}\nint main() {\n\tcin>>s;\n\tcin>>l>>r;\n\tl--, r--;\n\ts=s.substr(0, s.length()/2);\n\tn=s.length();\n\tlen=n-gaofail(s);\n\tgaopre();\n\tif (n%len==0) {\n\t\tfor (int i=0; i<26; i++)\n\t\t\tcout<<calc1(r, i)-calc1(l-1, i)<<(i<25?' ':'\\n');\n\t} else {\n\t\tfor (int i=0; i<26; i++)\n\t\t\tcout<<calc2(r, i)-calc2(l-1, i)<<(i<25?' ':'\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nconst int M = 110;\n\ntypedef long long LL;\n\nchar S[N];\nint n, f[N];\n\nstruct Info{\n\tLL cnt[26];\n\n\tInfo(){\n\t\tmemset(cnt, 0, sizeof cnt);\n\t}\n\n\tvoid operator = (const Info& A){\n\t\tFor(i, 0, 25) cnt[i] = A.cnt[i];\n\t}\n\n\tInfo operator + (const Info& A) const{\n\t\tInfo ret;\n\t\tFor(i, 0, 25) ret.cnt[i] = A.cnt[i] + cnt[i];\n\t\treturn ret;\n\t}\n\n\tInfo operator - (const Info& A) const{\n\t\tInfo ret;\n\t\tFor(i, 0, 25) ret.cnt[i] = cnt[i] - A.cnt[i];\n\t\treturn ret;\n\t}\n\n}A[M];\n\nLL len[M];\n\nInfo work(int x, LL r){\n\tif(x <= 2){\n\t\tInfo ret;\n\t\tFor(i, 1, r) ret.cnt[S[i] - 'a']++;\n\t\treturn ret;\n\t}\n\tif(r < len[x - 2]) return work(x - 2, r);\n\telse return A[x - 2] + work(x - 1, r - len[x - 2]);\n}\n\nInfo calc(LL r){\n\tif(r <= n) return work(1, r);\n\tint i = 1;\n\twhile(len[i] * 2 <= r) ++i;\n\treturn A[i] + work(i, r - len[i]);\n}\n\nint main(){\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\n\tf[1] = 0;\n\tFor(i, 2, n){\n\t\tint p = f[i - 1];\n\t\twhile(p && S[p + 1] != S[i]) p = f[p];\n\t\tf[i] = S[p + 1] == S[i] ? p + 1 : 0;\n\t}\n//\tprintf(\"period = %d\\n\", n - f[n]);\n\n\tFor(i, 1, n) A[1].cnt[S[i] - 'a']++;\n\tlen[1] = n;\n\tFor(i, 1, n + n - f[n]) A[2].cnt[S[i] - 'a']++;\n\tlen[2] = n + n - f[n];\n\tFor(i, 3, 100) len[i] = len[i - 1] + len[i - 2], A[i] = A[i - 1] + A[i - 2];\n\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tInfo ans = calc(r) - calc(l - 1);\n\tFor(i, 0, 25) printf(\"%lld%c\", ans.cnt[i], i == 25 ? '\\n' : ' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/arc077/tasks/arc077_d\n/*<head>*/\n// #include \"KMP.hpp\"\n/*</head>*/\n\n/*<body>*/\n/* #region header */\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* #region macro */\n#ifdef BTK\n#    define DEBUG if (1)\n#    define CIN_ONLY if (0)\n#else\n#    define DEBUG if (0)\n#    define CIN_ONLY if (1)\n#endif\n/** @def\n * ALLマクロ\n */\n#define ALL(v) (v).begin(), (v).end()\n\n/** @def\n * 再帰ラムダをするためのマクロ\n */\n#define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n/* #endregion */\n\nnamespace _Template_ {\n    /**\n     * @brief cin高速化処理を行うための構造体\n     * @details CIN_ONLYマクロで動作が変わる\n     */\n    struct cww {\n        cww() {\n            CIN_ONLY {\n                ios::sync_with_stdio(false);\n                cin.tie(0);\n            }\n        }\n    } star;\n    /**\n     * @brief change min\n     * @tparam T 型\n     * @param l 参照\n     * @param r 非参照\n     * @return 更新があればtrue\n     */\n    template <typename T>\n    inline bool chmin(T& l, T r) {\n        bool a = l > r;\n        if (a) l = r;\n        return a;\n    }\n    /**\n     * @brief chminのmax版\n     * @see chmin\n     */\n    template <typename T>\n    inline bool chmax(T& l, T r) {\n        bool a = l < r;\n        if (a) l = r;\n        return a;\n    }\n    /**\n     * @brief\n     * vectorに直接cin流すためのやつ\n     * @tparam T\n     * @param is\n     * @param v\n     * @return istream&\n     */\n    template <typename T>\n    istream& operator>>(istream& is, vector<T>& v) {\n        for (auto& it : v) is >> it;\n        return is;\n    }\n    /**\n     * @brief\n     * rangeを逆向きに操作したいとき用\n     * @details\n     * ループの範囲は[bg,ed)なので注意\n     * @see range\n     */\n    class reverse_range {\n      private:\n        struct I {\n            int x;\n            int operator*() { return x - 1; }\n            bool operator!=(I& lhs) { return x > lhs.x; }\n            void operator++() { --x; }\n        };\n        I i, n;\n\n      public:\n        reverse_range(int n) : i({0}), n({n}) {}\n        reverse_range(int i, int n) : i({i}), n({n}) {}\n        I& begin() { return n; }\n        I& end() { return i; }\n    };\n    /**\n     * @brief\n     * python みたいな range-based for を実現\n     * @details\n     * ループの範囲は[bg,ed)なので注意\n     * !つけると逆向きにループが回る (reverse_range)\n     * 空間計算量はO(1)\n     * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n     */\n    class range {\n      private:\n        struct I {\n            int x;\n            int operator*() { return x; }\n            bool operator!=(I& lhs) { return x < lhs.x; }\n            void operator++() { ++x; }\n        };\n        I i, n;\n\n      public:\n        range(int n) : i({0}), n({n}) {}\n        range(int i, int n) : i({i}), n({n}) {}\n        I& begin() { return i; }\n        I& end() { return n; }\n        reverse_range operator!() { return reverse_range(*i, *n); }\n    };\n    /**\n     * @brief\n     * rangeで生まれる使わない変数を消す用（警告消し）\n     */\n    template <typename T>\n    inline T& unused_var(T& v) {\n        return v;\n    }\n    using LL = long long;\n} // namespace _Template_\nusing namespace _Template_;\n\n/**\n * @file KMP.hpp\n * @author btk\n * @brief KMP\n * @date 2019-05-27\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\nnamespace _KMP_ {\n    class KMP {\n      private:\n        string keyword;\n        vector<int> table;\n\n      public:\n        KMP(string keyword, string eow = \"$\") : keyword(keyword + eow) {\n            const int n = this->keyword.size();\n            table.resize(n);\n            table[0] = -1;\n            for (int i = 2, j = 0; i < n;) {\n                if (keyword[i - 1] == keyword[j])\n                    table[i++] = ++j;\n                else if (j > 0)\n                    j = table[j];\n                else\n                    table[i++] = 0;\n            }\n        }\n\n        inline bool advance(const char next_char, int& reading_len) {\n            if (next_char != keyword[reading_len]) {\n                while (reading_len >= 0 && keyword[reading_len] != next_char) {\n                    reading_len = table[reading_len];\n                }\n            }\n            reading_len++;\n            return reading_len == (int)keyword.size() - 1;\n        }\n\n        inline int find(string& sentence, int& reading_len, int tail_pos = 0) {\n            const int sentence_size = sentence.size();\n            for (; tail_pos < sentence_size; tail_pos++) {\n                if (advance(sentence[tail_pos], reading_len)) {\n                    return tail_pos + 1;\n                }\n            }\n            return -1;\n        }\n\n        vector<int> find_all(string sentence) {\n            int reading_len = 0;\n            int tail_pos    = 0;\n            vector<int> position;\n            while (1) {\n                tail_pos = find(sentence, reading_len, tail_pos);\n                if (tail_pos == -1) {\n                    break;\n                }\n                else {\n                    position.push_back(tail_pos - keyword.size() + 1);\n                }\n            }\n            return position;\n        }\n\n        /**\n         * @brief keyword[0,i)の最小周期を求める\n         * @return int 最小周期長\n         */\n        int period(int i = 0) {\n            if (i == 0) i = (int)keyword.size() - 1;\n            return i - table[i];\n        }\n    };\n} // namespace _KMP_\nusing namespace _KMP_;\n/*\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> V;\ntypedef vector<V> VV;\n//KMP\nint kmp_search(string S,string word,V& table){\nint n=S.size();\nint m=word.size();\nint i=0,j=0;\nfor(;j<n&&i<m;i++,j++)\nwhile(i>=0&&word[i]!=S[j])i=table[i];\nif(i==m)return j-m;\nelse return -1;\n}\n\n\nV kmp_table_build(string word){\nint n=word.size()+1;\nV table(n,0);\ntable[0]=-1;\nfor(int i=2,j=0;i<n;){\nif(word[i-1]==word[j])table[i++]=++j;\nelse if(j>0)j=table[j];\nelse table[i++]=0;\n}\nreturn table;\n}\n*/\n\n/* #endregion */\n/*</body>*/\n\n\ntypedef __int128 INT;\n\nusing V  = vector<LL>;\nusing VV = vector<V>;\n\nV f(string s, INT k) {\n    LL x = s.size();\n    V ret(26, 0);\n    LL loop = k / x;\n    for (auto& it : s) ret[it - 'a'] += loop;\n    k -= loop * x;\n    for (int i : range((int)k)) ret[s[i] - 'a']++;\n    return ret;\n}\nV g(string& s1, VV& c, vector<INT>& l, INT k, int id) {\n    if (k == 0) return V(26, 0);\n    if (id <= 1) {\n        V ret(26, 0);\n        for (int i : range((int)k)) ret[s1[i] - 'a']++;\n        return ret;\n    }\n    if (l[id - 1] <= k) {\n        V ret  = c[id - 1];\n        V rest = g(s1, c, l, k - l[id - 1], id - 2);\n        for (int i : range(26)) ret[i] += rest[i];\n        return ret;\n    }\n    else {\n        return g(s1, c, l, k, id - 1);\n    }\n}\n\nint main() {\n    string s;\n    LL l, r;\n    cin >> s >> l >> r;\n    LL n = s.size() / 2;\n    s    = s.substr(0, n);\n    KMP finder(s);\n    int x = finder.period();\n    if (n % x == 0) {\n        s      = s.substr(0, x);\n        auto a = f(s, r);\n        auto b = f(s, l - 1);\n        for (int i : range(26)) cout << \" \" + (!i) << a[i] - b[i];\n        cout << endl;\n    }\n    else {\n        VV cnt(128, V(26, 0));\n        vector<INT> len(128);\n        for (int i : range(n)) cnt[0][s[i] - 'a']++;\n        len[0] = n;\n        len[1] = n + x;\n        cnt[1] = cnt[0];\n        for (int i : range(x)) cnt[1][s[i] - 'a']++;\n        int id = -1;\n        for (int i : range(2, 128)) {\n            len[i] = len[i - 1] + len[i - 2];\n            for (int j : range(26)) cnt[i][j] += cnt[i - 1][j] + cnt[i - 2][j];\n            if (len[i] > r) {\n                id = i;\n                break;\n            }\n        }\n        s      = s + s.substr(0, x);\n        auto a = g(s, cnt, len, r, id);\n        auto b = g(s, cnt, len, l - 1, id);\n        for (int i : range(26)) cout << \" \" + (!i) << a[i] - b[i];\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nconst int H=31;\nll l,r;\nint n,len,len2; \nstring s;\nint cnt[maxn][maxm];\nint hsh[maxn],power[maxn],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nbool same(int pos){\n\tint k1=hsh[pos-1],k2=hsh[n-1]-hsh[n-1-pos]*power[pos];\n\treturn k1==k2;\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\thsh[0]=s[0]-'a';power[0]=1;\n\tREP(i,n-1)hsh[i]=hsh[i-1]*H+s[i]-'a',power[i]=power[i-1]*H;\n\tREP(i,n-1)if(same(i))len=max(len,i);\n\t\n//\tZ_algorithm();\n//\tREP(i,n-1)if(z[i]+i==n)len2=max(len2,i);\n\n\tif(len==0){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tlen=n-len;\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring> \n\nusing namespace std;\n\nconst int N = 2e5 + 10;\n \nint n, T, p[N];\nchar s[N];\nlong long L, R, num[N][30];\n\nlong long fib(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tlong long f1 = num[n][c], f2 = num[n][c] + num[T][c], l1 = n, l2 = n + T;\n\twhile (len > l1 + l2) {\n\t\tlong long t = f2;\n\t\tf2 += f1, f1 = t;\n\t\tt = l2, l2 += l1, l1 = t;\n\t}\n\treturn f2 + fib(len - l2, c);\t\n}\n\nlong long calc(long long len, int c) {\n\tif (len <= n) return num[len][c];\n\tif (len % T == 0) {\n\t\tlong long re = 1ll * (len - n) / T * num[T][c] + num[n][c];\n\t\tlen -= n, len %= T;\n\t\treturn re + num[len][c];\n\t}\n\telse return fib(len, c);\n}\n\nint main() {\n\tscanf(\"%s%lld%lld\", s + 1, &L, &R);\n\tn = strlen(s + 1) / 2;\n\tp[1] = 0;\n\tfor (int j = 0, i = 2; i <= n; i ++) {\n\t\tfor (; j && s[j + 1] != s[i];) j = p[j];\n\t\tif (s[j + 1] == s[i]) j ++;\n\t\tp[i] = j;\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < 26; j ++) num[i][j] = num[i - 1][j];\n\t\tnum[i][s[i] - 'a'] ++;\n\t}\n\tT = n - p[n];\n\tfor (int i = 0; i < 26; i ++) printf(\"%lld%c\", calc(R, i) - calc(L - 1, i), i == 25 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nstring trans(string s) {\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s.substr(0, i) == s.substr(s.size() - i, i)) {\n            string b = s.substr(0, s.size() - i);\n            return s + b;\n        }\n    }\n    assert(false);\n    return \"\";\n}\nvoid stupid() {\n    while (true) {\n        string s;\n        int p = rand() % 7 + 2;\n        for (int i = 0; i < p; i++) {\n            s += (char) (rand() % 2 + 'a');\n        }\n        string ns = trans(s);\n        int blen = ns.size() - s.size();\n        int slen = s.size() - blen;\n//        if (blen <= slen) continue;\n        bool f1 = (slen == 0);\n        bool f2 = (s.size() % blen == 0);//(blen <= slen);\n        if (blen <= slen && !f2) {\n            s = ns;\n            ns = trans(s);\n            blen = ns.size() - s.size();\n            slen = s.size() - blen;\n            assert(blen > slen);\n        }\n        string init = s;\n        s = ns;\n        for (int step = 0; step < 10; step++) {\n            string ns = trans(s);\n            int hisb = ns.size() - s.size();\n            int hiss = s.size() - hisb;\n            if (f1) {\n                assert(hisb == blen);\n            }\n            else if (f2) {\n                assert(hisb == blen);\n            }\n            else {\n//            if (hiss != blen) {\n//                cout << init << \" GG \" << s << \" \" << ns << \" \" << hiss << \" \" << blen << endl;\n//            }\n                assert(hiss == blen);\n            }\n            blen = hisb;\n            slen = hiss;\n//            cout << s << \" -> \" << ns << endl;\n            s = ns;\n        }\n    }\n}\nstring s;\nll l, r;\nvector < int > z_function(string& s) {\n    vector < int > z(s.size());\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < s.size(); i++) {\n        if (r < i) {\n            l = r = i;\n        }\n        z[i] = min(r - i, z[i - l]);\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\nll ans[26];\nll len[100];\nll lenB[100];\nll lenS[100];\nconst ll INF = 1e18 + 2;\nconst int maxN = 2e5 + 10;\nint pref[26][maxN];\nint prefS[26][maxN];\nll calcB(ll r, int c, int who);\nll calcS(ll r, int c, int who);\nll calc(ll r, int c, int who);\nmap < pair < pair < ll, int >, int >, ll > mp, mpB, mpS;\nll calc(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mp.find({{r, c}, who}) != mp.end()) return mp[{{r, c}, who}];\n    ll& d = mp[{{r, c}, who}];\n    if (r <= lenB[who]) {\n        return d = calc(r, c, who - 1);\n    }\n    return d = calc(lenB[who] - 1, c, who - 1) + calcB(r - lenB[who], c, who - 1);\n}\nll calcB(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpB.find({{r, c}, who}) != mpB.end()) return mpB[{{r, c}, who}];\n    ll& d = mpB[{{r, c}, who}];\n    if (r <= lenB[who]) {\n        return d = calcB(r, c, who - 1);\n    }\n    return d = calcB(lenB[who] - 1, c, who - 1) + calcS(r - lenB[who], c, who - 1);\n}\nll calcS(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpS.find({{r, c}, who}) != mpS.end()) return mpS[{{r, c}, who}];\n    ll& d = mpS[{{r, c}, who}];\n    return d = calcB(r, c, who - 1);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> s;\n    s = s.substr(0, s.size() / 2);\n    cin >> l >> r;\n    l--;\n    r--;\n    auto zz = z_function(s);\n    int n = s.size();\n    int blen = 0;\n    int slen = 0;\n    for (int i = 1; i < n; i++) {\n        if (zz[i] == n - i) {\n            blen = i;\n            slen = n - i;\n            break;\n        }\n    }\n    if (blen == 0 && slen == 0) {\n        blen = n;\n    }\n    if (n % blen == 0) {\n        string f = s.substr(0, blen);\n        cout << f << endl;\n        for (int i = 0; i < f.size(); i++) {\n            // blen * k + i >= l\n            // blen * k + i <= r\n            ll at_least = max(0LL, (l - i + blen - 1) / blen);\n            ll at_most = (i > r ? -1 : (r - i) / blen);\n            ans[f[i] - 'a'] += at_most - at_least + 1;\n        }\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n    }\n    else {\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < n; i++) {\n                pref[j][i] = ((s[i] - 'a') == j);\n                if (i) pref[j][i] += pref[j][i - 1];\n            }\n        }\n        string ns = s.substr(0, slen);\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < ns.size(); i++) {\n                prefS[j][i] = ((ns[i] - 'a') == j);\n                if (i) prefS[j][i] += prefS[j][i - 1];\n            }\n        }\n        len[0] = s.size();\n        lenB[0] = blen;\n        lenS[0] = slen;\n        int who = -1;\n        for (int i = 1; i < 100; i++) {\n            if (len[i - 1] - 1 >= r) {\n                who = i - 1;\n                break;\n            }\n            lenS[i] = lenB[i - 1];\n            lenB[i] = len[i - 1];\n            len[i] = lenB[i] + lenS[i];\n        }\n        assert(who != -1);\n        for (int i = 0; i < 26; i++) {\n            ans[i] = calc(r, i, who);\n            if (l) ans[i] -= calc(l - 1, i, who);\n            cout << ans[i] << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\ntypedef struct Z { ll l,r,nxt; vector<ll> bordercnt,totcnt; Z() {} Z(ll l,ll r,ll nxt):l(l),r(r),nxt(nxt) {} } Z;\n\nchar s[MAXN+1]; int n;\nll ql,qr;\n\nint nxt[MAXN]; // nxt[i] = longest border of [0..i]\nint scnt[MAXN][26];\n\n\nvector<Z> z;\nvector<ll> add(vector<ll> a,vector<ll> b) { vector<ll> c(26); REP(i,26) c[i]=a[i]+b[i]; return c; }\nvector<ll> sub(vector<ll> a,vector<ll> b) { vector<ll> c(26); REP(i,26) c[i]=a[i]-b[i]; return c; }\nvector<ll> calc(ll r) {\n\tvector<ll> ret(26,0);\n\tint at=0; while(at<SZ(z)&&z[at].r<r) ret=add(ret,z[at].totcnt),++at; assert(at<SZ(z));\n\tif(at==0) {\n\t\tREP(i,26) ret[i]=r==0?0:scnt[r-1][i];\n\t} else {\n\t\tret=add(ret,sub(calc(z[at].nxt+r-z[at].l-1),z[at-1].bordercnt));\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%s%lld%lld\",s,&ql,&qr); --ql; n=strlen(s);\n\n\tnxt[0]=0; FOR(i,1,n) { nxt[i]=nxt[i-1]; while(nxt[i]!=0&&s[i]!=s[nxt[i]]) nxt[i]=nxt[nxt[i]]; if(s[i]==s[nxt[i]]) ++nxt[i]; }\n\t//REP(i,n) printf(\"%d \",nxt[i]); puts(\"\");\n\tmemset(scnt,0,sizeof(scnt)); REP(i,n) { if(i!=0) REP(j,26) scnt[i][j]=scnt[i-1][j]; ++scnt[i][s[i]-'a']; }\n\n\tz.clear(); z.PB(Z(0,n,-1)); z.back().totcnt=calc(n);\n\tll cnxt=nxt[n-1]; while(2*cnxt>=n) cnxt=nxt[cnxt-1]; int at=0;\n\twhile(z.back().r<qr) {\n\t\t//printf(\"cnxt=%lld\\n\",cnxt);\n\t\tz.back().bordercnt=calc(cnxt);\n\t\t//printf(\"cnxt=%lld:\",cnxt); REP(j,26) printf(\" %lld\",z.back().bordercnt[j]); puts(\"\");\n\t\tvector<ll> totcnt=sub(calc(z.back().r-cnxt),z.back().bordercnt);\n\t\t//printf(\"cnxt=%lld:\",cnxt); REP(j,26) printf(\" %lld\",totcnt[j]); puts(\"\");\n\t\tz.PB(Z(z.back().r,z.back().r+z.back().r-2*cnxt,cnxt+1));\n\t\tz.back().totcnt=totcnt;\n\t\tcnxt=z.back().nxt+z.back().r-z.back().l-1-1;\n\t\twhile(at<SZ(z)&&cnxt>=z[at].r) ++at; assert(at<SZ(z));\n\t\tcnxt=at==0?nxt[cnxt]:z[at].nxt+cnxt-z[at].l;\n\t\t//printf(\"cnxt=%lld\\n\",cnxt);\n\t}\n\t//REPSZ(i,z) { printf(\"(%lld,%lld,%lld)\",z[i].l,z[i].r,z[i].nxt); REP(j,26) printf(\" %lld\",z[i].totcnt[j]); if(i!=SZ(z)-1) { printf(\" |\"); REP(j,26) printf(\" %lld\",z[i].bordercnt[j]); } puts(\"\"); }\n\tvector<ll> ret=sub(calc(qr),calc(ql)); REP(j,26) { if(j!=0) printf(\" \"); printf(\"%lld\",ret[j]); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=2e6+5,M=1e7+50,mo=1e9+7;\nint fail[N],n,i,per;\nll len1,len2,d,prt[30],l,r,f[305][26],g[305][26],sf[305],sg[305];\nchar s[N];\nvoid kmp()\n{\n\tint i,j;\n\tj=0;\n\tn=strlen(s+1);\n\tfo(i,2,n)\n\t{\n\t\twhile (j&&s[i]!=s[j+1]) j=fail[j];\n\t\tif (s[i]==s[j+1]) j++;\n\t\tfail[i]=j;\n\t}\n\ti=fail[n];\n}\nvoid fib()\n{\n\tint i,j;\n\tfo(i,2,300)\n\t{\n\t\tfo(j,0,25)  g[i][j]=g[i-1][j]+g[i-2][j];\n\t\tsg[i]=sg[i-1]+sg[i-2];\n\t\tif (sg[i]*2>r) break;\n\t}\n\tfo(i,0,300)\n\t{\n\t\tfo(j,0,25) f[i][j]=g[i][j]*2;\n\t\tsf[i]=sg[i]*2;\n\t\tif (sf[i]>r) break;\n\t}\n}\nvoid calc(ll x,ll xs)\n{\n\tint pos;\n\tfo(pos,0,300)\n\t\tif (sf[pos]>x) break;\n \twhile (pos>=0)\n\t{\n\t\tif (sf[pos]<=x)\n\t\t{\n\t\t\tfo(i,0,25) prt[i]+=xs*f[pos][i];\n\t\t\tx-=sf[pos];\n\t\t\tpos--;\n\t\t}else\n\t\tpos--;\n\t}\n\tfo(i,1,x) prt[s[i]-'a']+=xs;\n}\nint main()\n{\n\tscanf(\"%s %lld %lld\",s+1,&l,&r);\n\tkmp();\n\tn=strlen(s+1);\n\tfo(i,1,n/2) g[0][s[i]-'a']++,sg[0]++;\n\tper=n/2-fail[n/2];\n\tfo(i,0,25) g[1][i]=g[0][i];\n\tsg[1]=sg[0];\n\tfo(i,1,per) g[1][s[i]-'a']++,sg[1]++;\n\tfib();\n\tcalc(r,1);\n\tcalc(l-1,-1);\n\tfo(i,0,25) printf(\"%lld \",prt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\nchar s[200002];\nlong long hs[200002],pw[200002];\nlong long gethash(int st,int ed)\n{\n\treturn hs[ed]-hs[st-1]*pw[ed-st+1];\n}\nvector<long long> accumulate(int st,int ed)\n{\n\tvector<long long> ret(26);\n\tfor (int i=st;i<=ed;++i)\n\t\t++ret[s[i]-'a'];\n\treturn ret;\n}\nvoid count_numbers(vector<long long> p,vector<long long> q,vector<long long>& ans,long long& rem)\n{\n\tlong long sm=0;\n\tvector<long long> add;\n\tfor (int i=0;i<26;++i)\n\t{\n\t\tsm+=q[i];\n\t\tif (sm>rem)\n\t\t\treturn;\n\t\tadd.push_back(p[i]+q[i]);\n\t}\n\tcount_numbers(q,add,ans,rem);\n\tif (sm<=rem)\n\t{\n\t\tfor (int i=0;i<26;++i)\n\t\t\tans[i]+=q[i];\n\t\trem-=sm;\n\t}\n}\nint plen;\nvector<long long> f10100(long long len,vector<long long> p,vector<long long> q)\n{\n\tvector<long long> ans(26);\n\tcount_numbers(q,p,ans,len);\n\tfor (int i=1;i<=len;++i)\n\t\t++ans[s[i]-'a'];\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=int(strlen(s+1));\n\tpw[0]=1;\n\tn/=2;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpw[i]=pw[i-1]*202877;\n\t\ths[i]=hs[i-1]*202877+s[i];\n\t}\n\tfor (int i=n;i>=(n+1)/2;--i)\n\t\tif (gethash(1,n-i)==gethash(i+1,n))\n\t\t\tplen=i;\n\tvector<long long> p=accumulate(1,plen),q=accumulate(plen+1,n);\n\tlong long l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tvector<long long> rnum=f10100(r,p,q),lnum=f10100(l-1,p,q);\n\tfor (int i=0;i<26;++i)\n\t\tprintf(\"%lld \",rnum[i]-lnum[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\nll dif[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll V) {\n\tvector<ll> ret(26,0);\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V>=cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) cnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t}\n\t\tRR=hoge2(R);\n\t\tLL=hoge2(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    int x = min(pi[T.size() - 1], (int)T.size() - pi[T.size() - 1]);\n    for(int i = 0; i < x; i++) A.push_back(T[i]);\n    for(int i = x; i < T.size() - pi[T.size() - 1]; i++) B.push_back(T[i]);\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<utility>\n#include<algorithm>\n \n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define For(i,x,y) for(int i=((int)x);i<=((int)y);i++)\n#define Dep(i,y,x) for(int i=((int)y);i>=((int)x);i--)\n#define Rep(i,x) for (int y,i=head[x];i;i=E[i].nxt)\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\n \nint rd() {\n    char c=getchar(); int t=0,f=1;\n    while (!isdigit(c)) f=(c=='-')?-1:1,c=getchar();\n    while (isdigit(c)) t=t*10+c-48,c=getchar(); return t*f;\n}\nvoid wt(int x) {\n    if (x<0) putchar('-'),wt(-x);\n    else { if (x>9) wt(x/10); putchar(x%10+48); }\n}\n\nconst int N=2e5+5;\n\nchar s[N];\nint n,j,t,up,fail[N];\nll l,r,ans[26],len[101],pre[N][26],sum[101][26];\n\nvoid solve(ll p,ll f) {\n\tfor (int i=up;i>=0;i--) if (p>=len[i]) {\n\t\tp-=len[i];\n\t\tFor (j,0,25) ans[j]+=f*sum[i][j];\n\t}\n\tFor (j,0,25) ans[j]+=f*pre[p][j];\n}\n\nint main() {\n\tscanf(\"%s\",s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\t\n\tn=strlen(s+1)/2,j=0;\n\tFor (i,2,n) {\n\t\twhile (j && s[j+1]!=s[i]) j=fail[j];\n\t\tif (s[j+1]==s[i]) j++; fail[i]=j;\n\t}\n\tt=n-fail[n];\n\tFor (i,1,n) For (j,0,25)\n\t\tpre[i][j]=pre[i-1][j]+(s[i]=='a'+j);\n\t\n\tlen[0]=n;\n\tlen[1]=n+t;\n\tFor (j,0,25) {\n\t\tsum[0][j]=pre[n][j];\n\t\tsum[1][j]=pre[n][j]+pre[t][j];\n\t}\n\tfor (up=2;len[up-2]+len[up-1]<=1e18;up++) {\n\t\tlen[up]=len[up-2]+len[up-1];\n\t\tFor (j,0,25) sum[up][j]=sum[up-2][j]+sum[up-1][j];\n\t}\n\tup--;\n\t\n\tsolve(l-1,-1);\n\tsolve(r,1);\n\t\n\tFor (j,0,25) printf(\"%lld \",ans[j]); puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 500006\nusing namespace std;\nchar s[N];long long f[1006],g[1006][26],a[26],l,r,x;\nlong long n,p,t,v[26],height[N],sa[N],fuckyouatcoder[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\nvoid SA()\n{\n\tfor(long long i=1;i<=n;i++)cntA[(long long)s[i]]++;\n\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(long long i=n;i;i--)sa[cntA[(long long)s[i]]--]=i;\n\tfuckyouatcoder[sa[1]]=1;\n\tfor(long long i=2;i<=n;i++){\n\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t}\n\tfor(long long l=1;fuckyouatcoder[sa[n]]!=n;l<<=1){\n\t\tfor(long long i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\tcntA[A[i]=fuckyouatcoder[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?fuckyouatcoder[i+l]:0)]++;\n\t\t}\n\t\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(long long i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(long long i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\tfuckyouatcoder[sa[1]]=1;\n\t\tfor(long long i=2;i<=n;i++){\n\t\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t\t}\n\t}\n\tlong long tot=0;\n\tfor(long long i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[fuckyouatcoder[i]-1]+tot])tot++;\n\t\theight[fuckyouatcoder[i]]=tot;\n\t}\n\tp=n;long long mi=N;\n\tfor(long long i=fuckyouatcoder[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(long long i=fuckyouatcoder[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(long long w,long long F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(long long i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(long long i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(long long i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(long long i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(long long i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(long long i=(l-n-1)%p+1;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(long long i=1;i<=(r-1)%p+1;i++)a[s[i]-97]++;\n\t\t\tfor(long long i=0;i<26;i++)a[i]+=1LL*v[i]*((r-1)/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(long long i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(long long i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(long long i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(long long i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=255555;\ntypedef long long LL;\nstruct data{\n\tLL len,a[26];\n\tinline void operator+=(const data&rhs){\n\t\tlen+=rhs.len;\n\t\tfor(int i=0;i<26;++i)a[i]+=rhs.a[i];\n\t}\n\tinline data operator-(const data&rhs)const{\n\t\tdata c;\n\t\tc.len=0;\n\t\tfor(int i=0;i<26;++i)c.a[i]=a[i]-rhs.a[i];\n\t\treturn c;\n\t}\n}d[500],ans;\nchar s[N];\nint fail[N],n;\nLL L,R;\nvoid getfail(){\n    for(int i=2,j=0;i<=n;++i){\n        while(j&&s[j+1]!=s[i])j=fail[j];\n        if(s[j+1]==s[i])++j;\n        fail[i]=j;\n    }\n}\ndata solve(LL R){\n\tdata ret;\n\tfor(int i=ret.len=0;i<26;++i)ret.a[i]=0;\n\tif(n%(n-fail[n])==0){\n\t\tLL k=R/n;\n\t\tfor(int i=1;i<=n;++i)ret.a[s[i]-'a']+=k;\n\t\tfor(int i=1;i<=R%n;++i)++ret.a[s[i]-'a'];\n\t}else{\n\t\tmemset(d,0,sizeof d);\n\t\tint tot=2;\n\t\td[2].len=n;\n\t\tfor(int i=1;i<=n;++i)++d[2].a[s[i]-'a'];\n\t\td[1].len=n-fail[n];\n\t\tfor(int i=1;i<=n-fail[n];++i)++d[1].a[s[i]-'a'];\n\t\twhile(d[tot].len*2<=R){\n\t\t\t++tot;\n\t\t\td[tot]=d[tot-1],d[tot]+=d[tot-2];\n\t\t}\n\t\tfor(int i=tot;i;--i)\n\t\tif(R>=d[i].len)R-=d[i].len,ret+=d[i];\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s+1,&L,&R);\n\tn=strlen(s+1)>>1;\n\tgetfail();\n\tans=solve(R)-solve(L-1);\n\tfor(int i=0;i<26;++i)\n\tprintf(\"%lld \",ans.a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<utility>\nusing namespace std;\n#define ll \"ll\"\n#define ran 222222\nchar s[ran];\n#define uint64 unsigned long long int\n#define int64 long long int\n#define MUL 197\nuint64 hsh[ran],mul[ran];\nint64 L,R;\n\nint n,pos;\n\nint64 res[26],res2[26];\n\nint64 tmp[26];\nvoid calc_naive(int64 x,int w){\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(int i=1; i<=n; i++)\n\t\ttmp[s[i]-'a'] ++;\n\tfor(int i=0; i<26; i++)\n\t\tres[i] += tmp[i] * (x / n) * w;\n\tfor(int i=1; i<=x%n; i++)\n\t\tres[s[i]-'a'] += w;\n}\n\nstruct cnt{\n\tint64 len;\n\tint64 a[26];\n\tcnt(){memset(a,0,sizeof(a));len=0;}\n};\nvoid add(cnt&A,cnt&B,cnt&C){\n\tA.len = B.len + C.len;\n\tfor(int i=0; i<26; i++)\n\t\tA.a[i] = B.a[i] + C.a[i];\n}\nvoid sub(cnt&A,cnt&B,cnt&C){\n\tA.len = B.len - C.len;\n\tfor(int i=0; i<26; i++)\n\t\tA.a[i] = B.a[i] - C.a[i];\n}\nvector<pair<cnt,cnt> > len;\n\nvoid calc(int64 L){\n\tlen.clear();\n\tcnt A,B,AB,AB2,AB4,AB4dec;\n\tfor(int i=1; i<=n; i++){\n\t\tif(i <= pos){\n\t\t\tA.len ++;\n\t\t\tA.a[s[i]-'a'] ++;\n\t\t}else{\n\t\t\tB.len ++;\n\t\t\tB.a[s[i]-'a'] ++;\n\t\t}\n\t}\n\tadd(AB, A, B);\n\tadd(AB2, AB, AB);\n\tsub(AB4, AB2, A);\n\tadd(AB4dec, AB4, AB4);\n\t\n\tlen.push_back(make_pair(AB2, A));\n\tlen.push_back(make_pair(AB4dec, B));\n\tint step = 1;\n\twhile(true){\n\t\tif(len[step].first.len >= L)break;\n\t\tcnt tmp_len1, tmp_len;\n\t\tsub(tmp_len1, len[step].first, len[step].second);\n\t\tadd(tmp_len, tmp_len1, tmp_len1);\n\t\tcnt tmp_match;\n\t\tadd(tmp_match, len[step].second, len[step-1].second);\n\t\tlen.push_back(make_pair(tmp_len, tmp_match));\n\t\tstep++;\n\t}\n\n\twhile(step > 0){\n\t\tif(L <= len[step-1].first.len)\n\t\t\tstep --;\n\t\telse{\n\t\t\tL -= len[step-1].first.len - len[step-1].second.len;\n\t\t\tcnt tmp;\n\t\t\tsub(tmp, len[step-1].first, len[step-1].second);\n\t\t\tfor(int i=0; i<26; i++)\n\t\t\t\tres[i] += tmp.a[i];\n\t\t\tstep --;\n\t\t}\n\t}\n\n\tfor(int i=1; i<=L; i++)\n\t\tres[s[i]-'a'] ++;\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%\"ll\"d%\"ll\"d\",&L,&R);\n\tn = strlen(s+1) / 2;\n\tmul[0] = 1;\n\tfor(int i=1; i<=n * 2; i++){\n\t\thsh[i] = hsh[i-1] * MUL + s[i];\n\t\tmul[i] = mul[i-1] * MUL;\n\t}\n\tpos = 0;\n\tfor(int i=n-1; i>=1; i--)\n\t\tif(hsh[i] == hsh[n * 2] - hsh[n * 2 - i] * mul[i]){\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\n\tif(pos == 0){\n\t\tcalc_naive(L-1, -1);\n\t\tcalc_naive(R, 1);\n\t}else{\n\t\tcalc(L-1);\n\t\tmemcpy(res2, res, sizeof(res2));\n\t\tmemset(res,0,sizeof(res));\n\t\tcalc(R);\n\t\tfor(int i=0; i<26; i++)\n\t\t\tres[i] -= res2[i];\n\t}\n\n\tfor(int i=0; i<26; i++)\n\t\tprintf(\"%\"ll\"d%c\",res[i],i<25?' ':'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\ntypedef long long Int;\nstring str;\nInt Z[2160000], l, r;\nInt cnt[216000];\nvoid z_algorithm(string str){\n  Int L = str.size();\n  \n  for(Int i=1, left=0, right=0; i<L; i++){\n    if(i > right){\n      left = right = i;\n      for(;right < L && str[right-left] == str[right]; right++);\n      Z[i] = right - left;\n      right--;\n    }\n    else{\n      Int k = i - left;\n      if(Z[k] < right - i + 1){\n\tZ[i] = Z[k];\n      }\n      else{\n\tleft = i;\n\tfor(;right < L && str[right-left] == str[right]; right++);\n\tZ[i] = right - left;\n\tright--;\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  cin >> str;\n  z_algorithm(str);\n  Int p = -1;\n  for(Int i = (str.size()+1) / 2;i < str.size();i++){\n    if(Z[i] == str.size() - i){\n      p = i;\n      break;\n    }\n  }\n  string nstr;\n  for(Int i = 0;i < p;i++){\n    nstr += str[i];\n  }\n  str = nstr;\n  Int pos = 1;\n  do{\n    z_algorithm(str);\n    for(Int i = pos;i < str.size();i++){\n      if(Z[i] == str.size() - i){\n\tpos = i;\n\tbreak;\n      }\n    }\n    for(Int i = 0;i < pos;i++){\n      str += str[i];\n    }\n  }while(pos * 2 > str.size());\n  Int looplen = pos;\n  cin >> l >> r;l--;r--;\n  for(Int i = 0;i < str.size();i++){\n    if(l <= i && i <= r)cnt[str[i]]++;\n  }\n  l = max(l, (Int)str.size());\n  r -= l;\n  for(Int i = 0;i < pos;i++){\n    cnt[str[i]] += r / pos;\n    if(r % pos <= i)cnt[str[i]]++;\n  }\n\n  for(char c = 'a'; c <= 'z';c++){\n    cout << cnt[c] << \" \";\n  }cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N=2e5+10;\n\nLL l,r,ans[26],g[110],sum[N][26],sm[110][26];\nint len,plen,nxt[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n}\n\nvoid Getnext(char *s,int len) {\n\tnxt[0]=0;nxt[1]=0;\n\tfor (int i=1,k=0;i<len;++i) {\n\t\twhile (k && s[i]!=s[k]) k=nxt[k];\n\t\tif (s[i]==s[k]) ++k;\n\t\tnxt[i+1]=k;\n\t}\n}\n\nvoid Calc(int dep,LL *ans,LL l,LL r,int op) {\n\tif (r==g[dep] && l==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*sm[dep][j];\n\t\treturn ;\n\t}\n\tif (dep==0 || dep==1) {\n\t\tfor (int j=0;j<26;++j) ans[j]=ans[j]+op*(sum[r][j]-sum[l-1][j]);\n\t\treturn ;\n\t}\n\tif (r>g[dep-1]) {\n\t\tCalc(dep-1,ans,l,g[dep-1],op);\n\t\tCalc(dep-2,ans,1,r-g[dep-1],op);\n\t}else Calc(dep-1,ans,l,r,op);\n}\n\nvoid Solve() {\n\tlen=strlen(s);len/=2;\n\tGetnext(s,len);\n\tfor (int i=1;i<=len;++i) {\n\t\tfor (int j=0;j<26;++j) sum[i][j]=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tplen=len-nxt[len];\n\tg[0]=plen; for (int j=0;j<26;++j) sm[0][j]=sum[plen][j];\n\tg[1]=len; for (int j=0;j<26;++j) sm[1][j]=sum[len][j];\n\tfor (int i=2;i<=100;++i) {\n\t\tg[i]=g[i-1]+g[i-2];\n\t\tfor (int j=0;j<26;++j) sm[i][j]=sm[i-1][j]+sm[i-2][j];\n\t}\n\t\n\tfor (int i=1;i<=100;++i) \n\t\tif (g[i]>r) { Calc(i,ans,l,r,1); break; }\n\tfor (int i=0;i<26;++i) printf(\"%lld%c\",ans[i],(i==25)?'\\n':' ');\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nconst int H=31;\nll l,r;\nint n,len,len2; \nstring s;\nint cnt[maxn][maxm];\nint hsh[maxn],power[maxn],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nbool same(int pos){\n\tint k1=hsh[pos-1],k2=hsh[n-1]-hsh[n-1-pos]*power[pos];\n\treturn k1==k2;\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\thsh[0]=s[0]-'a';power[0]=1;\n\tREP(i,n-1)hsh[i]=hsh[i-1]*H+s[i]-'a',power[i]=power[i-1]*H;\n\tREP(i,n-1)if(same(i))len=max(len,i);\n\t\n//\tZ_algorithm();\n//\tREP(i,n-1)if(z[i]+i==n)len2=max(len2,i);\n\n\tif(len==0){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tlen=n-len;\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 9;\n\nchar s[N];\nint f[N], n, t, lim;\nusing ll = long long;\nll l, r, c[120][26], ans[26], fib[N];\n\nvoid Solve (ll x, int t) {\n\tll bs = x / ::t, b2 = x % ::t;\n\tbs *= t;\n\tfor (int i = 0; i < ::t; ++i) {\n\t\tans[s[i] - 'a'] += bs;\n\t\tif (i < b2) ans[s[i] - 'a'] += t;\n\t}\n}\n\nvoid Solve2 (ll x, int t) {\n\tint now = lim + 1;\n\twhile (now-- > 0) {\n\t\tif (x >= fib[now]) {\n\t\t\tfor (int i = 0; i < 26; ++i) ans[i] += c[now][i] * t;\n\t\t\tx -= fib[now], --now;\n\t\t}\n\t}\n\tfor (int i = 0; i < x; ++i) ans[s[i] - 'a'] += t;\n}\n\nint main () {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tn >>= 1;\n\ts[n] = '\\0';\n\tscanf(\"%lld%lld\", &l, &r);\n\tfor (int i = 1, j; i < n; ++i) {\n\t\tj = f[i];\n\t\twhile (j && s[j] != s[i]) j = f[j];\n\t\tf[i + 1] = s[i] == s[j] ? j + 1 : 0;\n\t}\n\tt = n - f[n];\n\tif (n % t == 0) {\n\t\tSolve(r, 1); Solve(l - 1, -1);\n\t} else {\n\t\tfor (int i = 0; i < t; ++i) ++c[0][s[i] - 'a'];\n\t\tfor (int i = 0; i < n; ++i) ++c[1][s[i] - 'a'];\n\t\tfib[0] = t; fib[1] = n;\n\t\tfor (lim = 2; ; ++lim) {\n\t\t\tfor (int j = 0; j < 26; ++j) c[lim][j] = c[lim - 1][j] + c[lim - 2][j];\n\t\t\tif ((fib[lim] = fib[lim - 1] + fib[lim - 2]) >= 1e18) break;\n\t\t}\n\t\tSolve2(r, 1); Solve2(l - 1, -1);\n\t}\n\tll sum = 0;\n\tfor (int i = 0; i < 26; ++i) printf(\"%lld \", ans[i]), sum += ans[i];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tV=0;\n\t\t}\n\t\tif(V>cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge3(R);\n\t\tLL=hoge3(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2e5 + 5; \ntypedef long long ll;\ntypedef unsigned int ui;\nconst ui p = 19260817; \nusing namespace std;\n\nint n; \nll s[105][30], b[105][30], a[105][30], cnt[30], L, R; \nui pw[N], hashh[N];\nchar S[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nui gethashh(int l, int r)\n{\n\tint len = r - l + 1; \n\treturn hashh[r] - hashh[l - 1] * pw[len]; \n}\n\nvoid prepare()\n{\n\tfor(int i = (pw[0] = 1); i <= n; i++) pw[i] = pw[i - 1] * p;\n\tfor(int i = 1; i <= n; i++) hashh[i] = hashh[i - 1] * p + (S[i] - 'a' + 1);\n\tint tmp = 0; \n\tfor(int i = 1; i < n / 2; i++)\n\t\tif(gethashh(1, i) == gethashh(n - i + 1, n)) tmp = i; \n\tfor(int i = 1; i <= tmp; i++) s[0][0]++, s[0][S[i] - 'a' + 1]++;\n\tfor(int i = tmp + 1; i <= n / 2; i++) b[0][0]++, b[0][S[i] - 'a' + 1]++;\n\tfor(int i = n / 2 + 1; i <= n - tmp; i++) a[0][0]++, a[0][S[i] - 'a' + 1]++; \n}\n\nvoid calc(ll x, int op, int pos, int type)\n{\n\tif(!x) return; \n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 1); \n\t}\n\tif(type == 1)\n\t{\n\t\tif(x >= a[pos][0])\n\t\t{\n\t\t\tx -= a[pos][0];\n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += a[pos][j] * op;\n\t\t\ttype = 2; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= s[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= s[pos - 1][0]; \n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos - 1][j] * op;\n\t\t\t\treturn calc(x, op, pos - 1, 2); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 0); \n\t\t}\n\t}\n\tif(type == 2)\n\t{\n\t\tif(x >= b[pos][0])\n\t\t{\n\t\t\tx -= b[pos][0];\n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos][j] * op;\n\t\t\ttype = 0; if(!x) return; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x >= b[pos - 1][0])\n\t\t\t{\n\t\t\t\tx -= b[pos - 1][0];\n\t\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += b[pos - 1][j] * op;\n\t\t\t\treturn calc(x, op, pos - 1, 0); \n\t\t\t}\n\t\t\telse return calc(x, op, pos - 1, 2); \n\t\t}\n\t}\n\tif(!type)\n\t{\n\t\tif(x >= s[pos][0])\n\t\t{\n\t\t\tx -= s[pos][0]; \n\t\t\tfor(int j = 1; j <= 26; j++) cnt[j] += s[pos][j] * op; \n\t\t\ttype = 1; if(!x) return; \n\t\t}\n\t\telse return calc(x, op, pos - 1, 1); \n\t}\n}\n\nvoid solve(ll L, ll R, int id) { calc(R, 1, id, 0), calc(L - 1, -1, id, 0); }\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin), freopen(\"cpp.out\", \"w\", stdout); \n#endif\n\tscanf(\"%s\", S + 1), n = strlen(S + 1); \n\tprepare(), L = read <ll> (), R = read <ll> (); \n\tfor(int i = 1; i <= 92; i++)\n\t{\n\t\tfor(int j = 0; j <= 26; j++)\n\t\t\ts[i][j] = b[i - 1][j], b[i][j] = b[i - 1][j] + s[i - 1][j], a[i][j] = s[i - 1][j] + b[i - 1][j];\n\t\tif(1.0 * -R + s[i][0] + a[i][0] + b[i][0] + s[i][0] >= 0) { solve(L, R, i); break; }\n\t}\n\tfor(int i = 1; i <= 26; i++) printf(\"%lld%c\", cnt[i], i == 26 ? '\\n' : ' '); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc077/tasks/arc077_d\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\nstring s;\nint Z[N], n;\nlong long l, r, cnt[1000], ch[1000][26], ans[26];\n\nvoid cal(long long x, int v){\n    int cur = 0;\n    while (cnt[cur] < x) cur++;\n    while (x){\n        if (x <= cnt[0]){\n            for (int i = 0; i < x; i++) ans[s[i] - 'a'] += v;\n            break;\n        }\n        while (cnt[cur-1] >= x) cur--;\n        if (cnt[cur] == x){\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur][i] * v;\n            x = 0;\n        }\n        else{\n            for (int i = 0; i < 26; i++) ans[i] += ch[cur-1][i] * v;\n            x -= cnt[cur-1];\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> s >> l >> r; n = s.size();\n    for (int i = 1, l = 0, r = 0; i < n; i++){\n        if (i <= r) Z[i] = min(r-i+1, Z[i-l]);\n        while (i + Z[i] < n && s[Z[i]] == s[i+Z[i]]) Z[i]++;\n        if (i + Z[i] - 1 > r) l = i, r = i + Z[i] - 1;\n    }\n    for (int i = 1; i < n; i++) if (i > n/2 && i + Z[i] == n){\n        s.resize(i); n = i; break;\n    }\n    cnt[0] = n;\n    for (int i = 1; i < n; i++) if (i + Z[i] >= n){\n        cnt[1] = cnt[0] + i;\n        break;\n    }\n    if (!cnt[1]) cnt[1] = 2 * cnt[0];\n    if (cnt[0] % (cnt[1] - cnt[0]) == 0){\n        int siz = cnt[1] - cnt[0];\n        for (int i = 0; i < siz; i++) ans[s[i] - 'a'] += (r / siz) - ((l-1) / siz);\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) ch[0][s[i] - 'a']++, ch[1][s[i] - 'a']++;\n    for (int i = 0; i < (cnt[1] - cnt[0]); i++) ch[1][s[i] - 'a']++;\n\n    for (int i = 2; cnt[i-1] <= r; i++) {\n        cnt[i] = cnt[i-1] + cnt[i-2];\n        for (int j = 0; j < 26; j++) ch[i][j] = ch[i-1][j] + ch[i-2][j];\n    }\n    cal(r, 1); cal(l-1, -1);\n\n    for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,m,fail[100010];\nll ans[30],len[95],sum[95][30],cnt[100010][30];\nchar s[100010];\nvoid kmp()\n{\n\tfail[0]=-1;\n\tint p=-1;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\twhile (p>=0 && s[i]!=s[p+1])\n\t\t{\n\t\t\tp=fail[p];\n\t\t}\n\t\tif (s[i]==s[p+1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\tfail[i]=p;\n\t}\n}\nvoid solve(ll k,ll f)\n{\n\tll p=k/(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*p*cnt[m][i];\n\t}\n\tll q=k%(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[q][i];\n\t}\n}\nvoid work(ll k,ll f)\n{\n\tint i=1;\n\twhile (len[i]<=k)\n\t{\n\t\ti++;\n\t}\n\tfor (;i;i--)\n\t{\n\t\tif (k>len[i])\n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tans[j]+=f*sum[i][j];\n\t\t\t}\n\t\t\tk-=len[i];\n\t\t}\n\t}\n\tfor (i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[k][i];\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",&s);\n\tn=strlen(s);\n\tn/=2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tkmp();\n\tm=n-1-fail[n-1];\n\tll l,r;\n\tcin>>l>>r;\n\tif (n%m==0)\n\t{\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t}\n\telse\n\t{\n\t\tlen[1]=n;\n\t\tlen[2]=m+n;\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tsum[1][i]=cnt[n][i];\n\t\t\tsum[2][i]=cnt[m][i]+sum[1][i];\n\t\t}\n\t\tfor (int i=3;i<=90;i++)\n\t\t{\n\t\t\tlen[i]=len[i-2]+len[i-1];\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\t\t}\n\t\t}\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\t//rep(j, 26)cout << ad[j] << \" \"; cout << endl;\n\t\t\tres = merge(res, ad);\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(res, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\tll sum = 0;\n\trep(i, 26)sum += ans[i];\n\tassert(sum == r - l + 1);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e18\nusing namespace std;\n\nconst int maxn = 210000;\n\nll L,R;\nint n,pos;\nbool flag;\nint ex[maxn],id,mx;\nchar str[maxn];\nstruct node\n{\n\tll n,s[26];\n\tnode(){n=0;memset(s,0,sizeof s);}\n}f[maxn]; int ed;\ninline node operator +(node &x,node &y)\n{\n\tnode re; re.n=x.n+y.n;\n\tfor(int i=0;i<26;i++) re.s[i]=x.s[i]+y.s[i];\n\treturn re;\n}\n\nvoid dp()\n{\n\tf[0].n=pos;\n\tfor(int i=0;i<pos;i++) f[0].s[str[i]-'a']++;\n\tf[1].n=n;\n\tfor(int i=0;i<n;i++) f[1].s[str[i]-'a']++;\n\t\n\ted=1;\n\twhile(f[ed].n<inf) \n\t\tf[ed+1]=f[ed]+f[ed-1],ed++;\n}\nnode solve1(ll x)\n{\n\tll div=x/f[0].n,oth=x%f[0].n;\n\tnode re; for(int i=0;i<26;i++) re.s[i]=f[0].s[i]*div;\n\tif(oth)\n\t{\n\t\tfor(int i=0;i<oth;i++) re.s[str[i]-'a']++;\n\t}\n\treturn re;\n}\nnode solve2(ll x,int now)\n{\n\twhile(now&&f[now-1].n>=x) now--;\n\tnode re;\n\tif(now<=1)\n\t{\n\t\tfor(int i=0;i<x;i++) re.s[str[i]-'a']++;\n\t\treturn re;\n\t}\n\tre=f[now-1];\n\tnode temp=solve2(x-f[now-1].n,now-2);\n\tre=re+temp;\n\treturn re;\n}\nnode calc(ll x)\n{\n\tnode re;\n\tif(!x) return re;\n\tif(flag) re=solve1(x);\n\telse re=solve2(x,ed);\n}\n\nint main()\n{\n\tscanf(\"%s\",str); n=strlen(str); n>>=1; str[n]='$';\n\tid=1,mx=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(mx>=i) ex[i]=min(ex[i-id],mx-i);\n\t\twhile(str[i+ex[i]]==str[ex[i]]) ex[i]++;\n\t}\n\t\n\tflag=false;\n\tfor(pos=1;pos<n&&pos+ex[pos]-1!=n-1;pos++);\n\tif(n%pos==0) flag=true;\n\tdp();\n\t\n\tscanf(\"%lld%lld\",&L,&R);\n\tnode a1=calc(R),a2=calc(L-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",a1.s[i]-a2.s[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<valarray>\n#define array valarray<long long>\nusing namespace std;\nlong long a[200011],b[200011],p[200011]={1},q[200011]={1},moda=1000000007,modb=2147483647,cnt[300000][27];\nchar s[300000];\npair<long long,long long> query(long long l,long long r){return make_pair((p[r-l]*a[l]-a[r]+moda)%moda,(q[r-l]*b[l]-b[r]+modb)%modb);}\npair<array,long long> f(long long n,long long l,const array &left,long long r,const array &right)\n{\n\tarray ans(26);\n\tif(l+r<=n)\n\t{\n\t\tauto x=f(n,l+r,left+right,l,left);\n\t\tans+=x.first;\n\t\tn=x.second;\n\t}\n\tif(l<=n)\n\t{\n\t\tans+=left;\n\t\tn-=l;\n\t}\n\treturn make_pair(ans,n);\n}\nint main()\n{\n\tlong long l,r;\n\tstring s;\n\tcin>>s>>l>>r;l--;\n\ts=s.substr(0,s.size()>>1);\n\tlong long n=s.size();\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\ta[i]=(a[i-1]*17+s[i-1]-'a')%moda;\n\t\tb[i]=(b[i-1]*19+s[i-1]-'a')%modb;\n\t\tp[i]=p[i-1]*17%moda;\n\t\tq[i]=q[i-1]*19%modb;\n\t}\n\tfor(long long i=0;i<n;i++)\n\t{\n\t\tfor(long long j=0;j<26;j++)cnt[i+1][j]=cnt[i][j];\n\t\tcnt[i+1][s[i]-'a']++;\n\t}\n\tlong long k=0;\n\tfor(long long i=0;i<n;i++)\n\t\tif(query(0,i)==query(n-i,n))k=i;\n\tif(!k)\n\t{\n\t\tfor(long long i=0;i<26;i++)cout<<cnt[n][i]*(r/n)-cnt[n][i]*(l/n)+cnt[r%n][i]-cnt[l%n][i]<<' ';\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\tarray left(26),right(26);\n\tfor(long long i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(long long i=0;i<26;i++)cout<<upper.first[i]+cnt[upper.second][i]-lower.first[i]-cnt[lower.second][i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[880008],sz,pos,g,cnt[26][200022],p[26][400044],q[26][800088];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[800088];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\telse if (pos/2<=sq) return q[a][sq-1]+q[a][pos-sq-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos/2-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t\tif (re<0)\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tre=pos-pos/2+re;\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz/2;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz/2;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long \n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nstruct node {\n    int a[26],s;\n\n    node () {memset(a,0,sizeof a);}\n\n    node operator + (const node &x) const {\n        node c;\n        for(int i=0;i<26;i++) c.a[i]=a[i]+x.a[i];\n        c.s=s+x.s;\n        return c;\n    }\n\n    node operator - (const node &x) const {\n        node c;\n        for(int i=0;i<26;i++) c.a[i]=a[i]-x.a[i];\n        c.s=s-x.s;\n        return c;\n    }\n}f[100];\n\nint tot,n,p,nxt[maxn];\nchar s[maxn];\n\nvoid gao() {\n    for(int i=2;i<=n;i++) {\n        int j=nxt[i-1];\n        while(j&&s[j+1]!=s[i]) j=nxt[j];\n        if(s[j+1]==s[i]) nxt[i]=j+1;\n    }\n}\n\nnode solve(int r) {\n    node ans;\n    for(int i=tot;~i;i--) {\n        if(r<f[i].s) continue;\n        r-=f[i].s,ans=ans+f[i];\n    }\n    for(int i=1;i<=r;i++) ans.a[s[i]-'a']++;\n    return ans;\n}\n\nsigned main() {\n    scanf(\"%s\",s+1),n=strlen(s+1)/2;\n    gao();int p=n-nxt[n];\n    for(int i=1;i<=n;i++) f[0].a[s[i]-'a']++;f[1]=f[0];\n    for(int i=1;i<=p;i++) f[1].a[s[i]-'a']++;\n    f[0].s=n,f[1].s=n+p;tot=1;\n    for(int i=2;f[i-1].s+f[i-2].s<=1e18;i++) f[++tot]=f[i-1]+f[i-2];\n    int l,r;read(l),read(r);\n    node ans=solve(r)-solve(l-1);\n    for(int i=0;i<26;i++) printf(\"%lld \",ans.a[i]);puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 200054;\nconstexpr long double phi = 0.61803398874989484820458683436564l,\n\thz = 0.49723029647758477079258462177973l, lz = phi;\n\nint n, T;\nint f[N];\nll ans[N];\nchar s[N];\n\nll phi_n(ll n) {\n\tunsigned int hi = n >> 32, lo = n & 0xffffffff;\n\treturn 2654435769ll * hi + floorl(hi * hz + lo * lz);\n}\n\nvoid solve(ll x, int coef) {\n\tint i, u = n / T * T, v = n - u;\n\tif (v) {\n\t\tll p, Lu = -1, Lv = -1, Cu, Cv, estimate = x / (u * phi + v * (1 - phi));\n\t\tfor (p = std::max<ll>(estimate - 100, 1); ; ++p) {\n\t\t\tCu = phi_n(p), Cv = p - 1 - Cu;\n\t\t\tif (u * Cu + v * Cv > x) break;\n\t\t\tLu = Cu, Lv = Cv;\n\t\t}\n\t\tassert(~Lu && ~Lv);\n\t\tfor (i = 0; i < u; ++i) ans[s[i]] += Lu * coef;\n\t\tfor (i = 0; i < v; ++i) ans[s[i]] += Lv * coef;\n\t\tp = x - (u * Lu + v * Lv);\n\t\tfor (i = 0; i < p; ++i) ans[s[i]] += coef;\n\t} else {\n\t\tlldiv_t info = lldiv(x, T);\n\t\tfor (i = 0; i < T; ++i) ans[s[i]] += info.quot * coef;\n\t\tfor (i = 0; i < info.rem; ++i) ans[s[i]] += coef;\n\t}\n\t\n}\n\nint main() {\n\tint i, j = 0; ll l, r;\n\tscanf(\"%s%lld%lld\", s, &l, &r), s[n = strlen(s) / 2] = 0;\n\tfor (j = *f = -1, i = 0; i < n; f[++i] = ++j)\n\t\tfor (; ~j && s[j] != s[i]; j = f[j]);\n\tT = n - f[n];\n\tsolve(r, 1), solve(l - 1, -1);\n\tfor (i = 97; i < 123; ++i) printf(\"%lld%c\", ans[i], i == 122 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define b 31ll\n#define mod 1004535809ll\n#define ll long long\nusing namespace std;\nchar s[400005];\nll l[1005],fib[1005][27],ans[27];\nll has[400005],m[400005],lo,hi;\nint len,t;\ninline ll get(int l,int r)\n{if (l>r) return 0;\nll ret=(has[r]-has[l-1]*m[r-l+1])%mod;\nreturn (ret<0?ret+mod:ret);\n}\ninline void add(ll p,int pos)\n{if (pos==0)\n{for (int i=1;i<=p;i++)\n{ans[s[i]-'a']++;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]+=fib[pos-1][i];\nadd(p-l[pos-1],pos-2);\nreturn;\n}\nadd(p,pos-1);\n}\ninline void del(ll p,int pos)\n{if (pos==0)\n{for (int i=1;i<=p;i++)\n{ans[s[i]-'a']--;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]-=fib[pos-1][i];\ndel(p-l[pos-1],pos-2);\nreturn;\n}\ndel(p,pos-1);\n}\nint main (){\n\tint i,j,las;\n\tscanf(\"%s\",s+1);len=strlen(s+1);\n\tscanf (\"%lld%lld\",&lo,&hi);\n\tm[0]=1ll;len>>=1;\n\tfor (i=1;i<=len;i++)\n\t{m[i]=m[i-1]*b%mod;\n\thas[i]=has[i-1]*b+(s[i]-'0');\n\thas[i]%=mod;\n\t}\n\tfor (i=1;i<=len;i++)\n\t{if (get(1,len-i)==get(i+1,len))\n\t{t=i;break;}\n\t}\n\tl[0]=len;l[1]=len+t;\n\tfor (i=1;i<=len;i++)\n\t{fib[0][s[i]-'a']++;\n\tfib[1][s[i]-'a']++;\n\t}\n\tfor (i=1;i<=t;i++)\n\t{fib[1][s[i]-'a']++;}\n\tfor (i=2;l[i-2]+l[i-1]<=2ll*hi;i++)\n\t{for (j=0;j<26;j++)\n\t{fib[i][j]=fib[i-1][j]+fib[i-2][j];}\n\tl[i]=l[i-1]+l[i-2];\n\tlas=i;\n\t}\n\tadd(hi,las);del(lo-1,las);\n\tfor (i=0;i<26;i++)\n\t{printf (\"%lld \",ans[i]);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\nusing namespace std;\n\ntypedef long long LL;\nint n,m,nxt[200100];\nLL l,r,ans[26],sum[100][26],len[100];\nchar a[200100];\n\nint calc(int m)\n{\n    int x=m-n%m;\n    return (n+x)/m&1?x+m:x;\n}\n\nvoid solve(LL n,int w)\n{\n    repd(i,m,0)\n        if (n>=len[i])\n        {\n            n-=len[i];\n            repu(j,0,25)\n                ans[j]+=w*sum[i][j];\n        }\n    repu(i,1,n)\n        ans[a[i]-'a']+=w;\n}\n\nint main()\n{\n    scanf(\"%s%lld%lld\",a+1,&l,&r),n=strlen(a+1)/2;\n    for (int i=2,j=0; i<=n; ++i)\n    {\n        for (; j && a[i]!=a[j+1]; j=nxt[j]);\n        nxt[i]=j+=a[i]==a[j+1];\n    }\n    len[m=1]=n,len[0]=n-nxt[n];\n    repu(i,1,n)\n    {\n        ++sum[1][a[i]-'a'];\n        sum[0][a[i]-'a']+=i<=len[0];\n    }\n    while (len[m]<r)\n    {\n        ++m,len[m]=len[m-1]+len[m-2];\n        repu(i,0,25)\n            sum[m][i]=sum[m-1][i]+sum[m-2][i];\n    }\n    solve(l-1,-1),solve(r,1);\n    repu(i,0,25)\n        printf(\"%lld \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nstring s;\nll l,r;\n \nint z[430252];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n \nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n \nll cnt[26];\nll ans[26];\n\nstring X,Y;\nll cntx[1252][26];\nll xsum[1252];\n \nvoid calc(ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  int z = 2;\n  while(xsum[z]>=0 && xsum[z]<=end){\n    z++;\n  }\n  z--;\n  REP(i,26)cnt[i]+=cntx[z][i];\n  calc(end-xsum[z]);\n}\n \nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n \nint main(){\n  cin>>s;\n  cin>>l>>r;\n  // first step\n  s = f(s);\n  // second\n  string t = f(s); \n  X = s.substr(0,s.size()/2);\n  Y = t.substr(0,t.size()/2);\n  // Y = t.substr(X.size(),t.size()/2-X.size());\n  REP(i,X.size()){\n    cntx[0][X[i]-'a']++;\n  }\n  xsum[0] = X.size();\n  REP(i,Y.size()){\n    cntx[1][Y[i]-'a']++;\n  }\n  xsum[1] = Y.size();\n  FOR(i,2,1252){\n    REP(j,26)cntx[i][j] = cntx[i-1][j]+cntx[i-2][j];\n    xsum[i] = xsum[i-1] + xsum[i-2];\n  }\n\n  calc(r+1);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(l);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nconst int MAXN = 1000000;\nint z[MAXN];\nchar s[MAXN];\nll cc[100];\n\nvoid zz(int n) {\n    z[0] = 0;\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (r > i)\n            z[i] = min(r - i, z[i - l]);\n        else\n            z[i] = 0;\n        while (i + z[i] < n && s[i + z[i]] == s[z[i]])\n            ++z[i];\n        if (i + z[i] > r)\n            r = i + z[i], l = i;\n    }\n}\n\nstruct st {\n    ll len;\n    int l, r;\n    int dp;\n    ll cc[26];\n    st(int l, int r): l(l), r(r) {\n        len = r - l;\n        dp = 0;\n        for (int i = 0; i < 26; ++i)\n            cc[i] = 0;\n        for (int i = l; i < r; ++i)\n            ++cc[s[i] - 'a'];\n    }\n    st operator+(st x) {\n        st ans(0, 0);\n        ans.len = len + x.len;\n        ans.l = x.l;\n        ans.r = x.r;\n        ans.dp = x.dp + 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] + x.cc[i];\n        return ans;\n    }\n    st operator-(st x) {\n        st ans(0, 0);\n        ans.len = len - x.len;\n        ans.l = l;\n        ans.r = r;\n        ans.dp = dp - 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] - x.cc[i];\n        return ans;\n    }\n};\n\n\nvoid add(st a, st b, ll x) {\n    if (x == 0)\n        return;\n    if (b.dp == 0) {\n        for (int i = b.l; i < b.l + x; ++i) {\n            ++cc[s[i] - 'a'];\n        }\n        return;\n    }\n    st q = a - b;\n    a = b;\n    b = q;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n        add(b, a - b, x);\n    }\n    else {\n        add(a, b, x);\n    }\n}\n\nvoid solve(ll x) {\n    int n = strlen(s);\n    zz(n);\n    int xx = 0;\n    for (int i = 1; i < n / 2; ++i)\n        if (i + z[i] >= n / 2) {\n            xx = i;\n            break;\n        }\n    assert(xx != 0);\n    st a(xx, n / 2);\n    st b(n / 2 - xx, xx);\n    for (int i = 0; i < min((ll)n, x); ++i)\n        ++cc[s[i] - 'a'];\n    x -= min((ll)n, x);\n    if (x == 0)\n        return;\n    while (x >= b.len + a.len + a.len + b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += 2 * a.cc[i] + 2 * b.cc[i];\n        x -= 2 * (a.len + b.len);\n        st q = a + b;\n        b = a;\n        a = q;\n    }\n    st c = a + b;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n}\nll ans[100];\n\nint main() {\n    scanf(\"%s\", s);\n    ll l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    --l;\n    int n = strlen(s);\n    zz(n);\n    for (int i = 0; i < n; ++i)\n        ++cc[s[i] - 'a'];\n    for (int i = 1; i < n / 2; ++i) {\n        if (n % i == 0 && i + z[i] >= n) {\n            for (int i = 0; i < 26; ++i) {\n                ll ans = 0;\n                ans += cc[i] * (r / n);\n                for (int j = 0; j < r % n; ++j)\n                    if (s[j] - 'a' == i)\n                        ++ans;\n                ans -= cc[i] * (l / n);\n                for (int j = 0; j < l % n; ++j)\n                    if (s[j] - 'a' == i)\n                        --ans;\n                cout << ans << \"\\n\";\n            }\n            return 0;\n        }\n    }\n    n /= 2;\n    int x = n;\n    for (int i = 1; i < n; ++i) {\n        if (i + z[i] >= n) {\n            x = i;\n            break;\n        }\n    }\n    if (x == n) {\n        n *= 2;\n        for (int i = 0; i < 26; ++i) {\n            ll ans = 0;\n            ans += cc[i] * (r / n);\n            for (int j = 0; j < r % n; ++j)\n                if (s[j] - 'a' == i)\n                    ++ans;\n            ans -= cc[i] * (l / n);\n            for (int j = 0; j < l % n; ++j)\n                if (s[j] - 'a' == i)\n                    --ans;\n            cout << ans << \"\\n\";\n        }\n        return 0;\n    }\n    n *= 2;\n    for (int i = 0; i < x; ++i) {\n        s[n] = s[n - x];\n        ++n;\n    }\n    for (int i = 0; i < x; ++i) {\n        s[n + i] = s[i];\n    }\n    n += x;\n    for (int i = 0; i < 26; ++i)\n        cc[i] = 0;\n    solve(r);\n    for (int i = 0; i < 26; ++i)\n        ans[i] = cc[i], cc[i] = 0;\n    solve(l);\n    for (int i = 0; i < 26; ++i)\n        ans[i] -= cc[i];\n    for (int i = 0; i < 26; ++i)\n        cout << ans[i] << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=400100,M=10000;\ntypedef long long ll;\nint f[N],n;\nll tmp[M][36],len[M],ans[36],l,r;\nchar s[N];\n\nvoid MP(){\n\tint j=f[0]=-1;f[1]=0;\n\tfor(int i=1;i<n;f[++i]=++j)\n\t\tfor(;~j&&s[i]!=s[j];j=f[j]);\n}\n\nvoid solve1(ll lim,int op){\n\tmemset(tmp,0,sizeof tmp);\n\tfor(int j=0;j<n+n-f[n];++j){\n\t\tif(j<n)tmp[0][s[j]]++;\n\t\ttmp[1][s[j]]++;\n\t}\n\tlen[0]=n;len[1]=n+n-f[n];\n\tint i=2;\n\tfor(;len[i-1]<=lim;++i){\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tfor(int j=0;j<26;++j)tmp[i][j]=tmp[i-1][j]+tmp[i-2][j];\n\t}\n\tfor(i-=2;i>=0;--i)\n\t\tif(lim>=len[i]){\n\t\t\tfor(int k=0;k<26;++k)ans[k]+=tmp[i][k]*op;\n\t\t\tlim-=len[i];\n\t\t}\n\tfor(int j=0;j<lim;++j)ans[s[j]]+=op;\n}\n\nvoid solve2(ll lim,int op){\n\t--lim;\n\tfor(int i=0;i<(n-f[n]);++i)\n\t\tans[s[i]]+=(lim+n-f[n]-i)/(n-f[n])*op;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>s>>l>>r;n=strlen(s)/2;\n\tfor(int i=0;i<2*n;++i)s[i]-='a';MP();\n\tif(n%(n-f[n])){solve1(r,1);solve1(l-1,-1);}\n\telse{solve2(r,1);solve2(l-1,-1);}\n\tfor(int i=0;i<26;++i)cout<<ans[i]<<\" \\n\"[i==25];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) {\n      cnt[s[i] - 'a'] += rq - lq;\n    }\n    for (unsigned i = 0; i < rr; ++i) {\n      ++cnt[s[i] - 'a'];\n    }\n    for (unsigned i = 0; i < lr; ++i) {\n      --cnt[s[i]];\n    }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      auto x = len[len.size() - 1];\n      auto y = len[len.size() - 2];\n      len.push_back(x + y);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs('z' - 'a' + 1, 0);\n    for (unsigned i = 0; i < cnt_s.size(); ++i) { cnt_gs[i] = cnt_s[i]; }\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        auto x = cnt[cnt.size() - 1];\n        auto y = cnt[cnt.size() - 2];\n        cnt.push_back(x + y);\n      }\n      unsigned long long ans = 0;\n      auto rr = r;\n      for (auto j = len.size() - 1; j > 1; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      if (rr >= len[1]) {\n        rr -= len[1];\n        ans += cnt[i];\n        for (unsigned j = 0; j < rr; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      } else {\n        for (unsigned j = 0; j < s.size() && rr; ++j) {\n          --rr;\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n        for (unsigned j = 0; j < rr; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      }\n      auto ll = l - 1;\n      for (auto j = len.size() - 1; j > 1; --j) {\n        if (len[j] > ll) { continue; }\n        ll -= len[j];\n        ans -= cnt[j];\n      }\n      if (ll >= len[1]) {\n        ll -= len[1];\n        ans += cnt[i];\n        for (unsigned j = 0; j < ll; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      } else {\n        for (unsigned j = 0; j < s.size() && ll; ++j) {\n          --ll;\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n        for (unsigned j = 0; j < ll; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nll rui[1000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = false;\n\ts = conv(s);\n\tvector<int>v = zalgo(s);\n\tfor (int i = 1; i < v.size() / 2; i++)\n\t{\n\t\tif (v[i] + i == s.size())\n\t\t{\n\t\t\tif (s.size() % i == 0)fff = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2] - len[i - 3]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define MN 210000\nusing namespace std;\n\nll n,k,l,r,ne[MN],w[26];\nchar s[MN];\nvoid work(ll r){\n\tif (r<=n) for (ll i=0;i<r;i++) w[s[i]-'a']++;else{\n\t\tll _s=0,_t=1,S=1,T=0;\n\t\tfor (;S*n+T*k<r;) S+=_s,T+=_t,_s=S-_s,_t=T-_t;\n\t\twork(r-_s*n-_t*k);\n\t\tfor (ll i=0;i<k;i++) w[s[i]-'a']+=_t;\n\t\tfor (ll i=0;i<n;i++) w[s[i]-'a']+=_s;\n\t}\n}\nint main(){\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s)/2;ne[0]=-1;\n\tfor (ll i=1;i<n;i++){\n\t\tll j=ne[i-1];\n\t\twhile (j!=-1&&s[i]!=s[j+1]) j++;\n\t\tne[i]=j+(s[i]==s[j+1]);\n\t}\n\tk=n-ne[n-1]-1;\n\twork(l-1);\n\tfor (ll i=0;i<26;i++) w[i]=-w[i];\n\twork(r);\n\tfor (ll i=0;i<26;i++) printf(\"%lld \",w[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=400000+19;\n\nchar s[N];\nll fib[100];\nint Fail[N];\nint n,flag,a,b,m;\nll l,r,ca,cb;\nvector<ll> V1,V2;\n\nvoid getfail(){\n\tFail[1]=0;\n\tfor (int i=2,j=0;i<=n;i++){\n\t\twhile (j&&s[j+1]!=s[i]) j=Fail[j];\n\t\tif (s[j+1]==s[i]) j++;\n\t\tFail[i]=j;\n\t}\n}\nvector<ll> Work(ll m){\n\tvector<ll> ans;\n\tans.resize(26);\n\tca=0;cb=0;\n\tif (flag){\n\t\tFor(i,1,n+1) ans[s[i]-'a']+=m/n;\n\t\tFor(i,1,m%n+1) ans[s[i]-'a']++;\n\t} else{\n\t\twhile (m>n){\n\t\t\tint i=1;\n\t\t\twhile (b*fib[i+1]+a*fib[i+2]<=m) i++;\n\t\t\tm-=b*fib[i]+a*fib[i+1];\n\t\t\tca+=fib[i+1];\n\t\t\tcb+=fib[i];\n\t\t}\n\t\tFor(i,1,m+1) ans[s[i]-'a']++;\n\t\tFor(i,1,a+1) ans[s[i]-'a']+=ca;\n\t\tFor(i,a+1,n+1) ans[s[i]-'a']+=cb;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfib[0]=0;\n\tfib[1]=1;\n\tFor(i,2,100) fib[i]=fib[i-1]+fib[i-2];\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tcin>>l>>r;\n\tgetfail();\n\tfor (m=Fail[n];m&&m>=(n+1)/2;m=Fail[m]);\n\tn-=m;\n\tm=Fail[n];\n\tif (m==0) flag=1;\n\tif (n%2==0){\n\t\tint chk=1;\n\t\tFor(i,0,n/2) if (s[i+1]!=s[n/2+i+1]) chk=0;\n\t\tif (chk) flag=1;\n\t}\n\tb=m;\n\ta=n-m;\n\tV1=Work(r);\n\tV2=Work(l-1);\n\tFor(i,0,26) printf(\"%lld \",V1[i]-V2[i]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,m,fail[200010];\nll ans[30],len[95],sum[95][30],cnt[200010][30];\nchar s[200010];\nvoid kmp()\n{\n\tfail[0]=-1;\n\tint p=-1;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\twhile (p>=0 && s[i]!=s[p+1])\n\t\t{\n\t\t\tp=fail[p];\n\t\t}\n\t\tif (s[i]==s[p+1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\tfail[i]=p;\n\t}\n}\nvoid solve(ll k,ll f)\n{\n\tll p=k/(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*p*cnt[m][i];\n\t}\n\tll q=k%(ll)m;\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[q][i];\n\t}\n}\nvoid work(ll k,ll f)\n{\n\tint i=1;\n\twhile (len[i]<=k)\n\t{\n\t\ti++;\n\t}\n\tfor (;i;i--)\n\t{\n\t\tif (k>len[i])\n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tans[j]+=f*sum[i][j];\n\t\t\t}\n\t\t\tk-=len[i];\n\t\t}\n\t}\n\tfor (i=0;i<26;i++)\n\t{\n\t\tans[i]+=f*cnt[k][i];\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",&s);\n\tn=strlen(s);\n\tn/=2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tcnt[i][j]=cnt[i-1][j];\n\t\t}\n\t\tcnt[i][s[i-1]-'a']++;\n\t}\n\tkmp();\n\tm=n-1-fail[n-1];\n\tll l,r;\n\tcin>>l>>r;\n\tif (n%m==0)\n\t{\n\t\tsolve(r,1);\n\t\tsolve(l-1,-1);\n\t}\n\telse\n\t{\n\t\tlen[1]=n;\n\t\tlen[2]=m+n;\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tsum[1][i]=cnt[n][i];\n\t\t\tsum[2][i]=cnt[m][i]+sum[1][i];\n\t\t}\n\t\tfor (int i=3;i<=90;i++)\n\t\t{\n\t\t\tlen[i]=len[i-2]+len[i-1];\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tsum[i][j]=sum[i-1][j]+sum[i-2][j];\n\t\t\t}\n\t\t}\n\t\twork(r,1);\n\t\twork(l-1,-1);\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=200200,D=26;\nchar s[N];\nint p[N];\nll len[1000],num[1000];\nint i,j,k,n,m;\nll l,r;\nll work(ll x,int ch) {\n\tint i,j;\n\tll ans=0;\n\tch+='a';\n\tlen[1]=n;num[1]=0;\n\tfor (i=1;i<=n;i++) if (s[i]==ch) num[1]++;\n\tlen[2]=n+m;num[2]=num[1];\n\tfor (i=1;i<=m;i++) if (s[i]==ch) num[2]++;\n\t//printf(\"%lld %lld\\n\",len[1],len[2]);\n\tfor (i=2;i;i++) {\n\t\t//printf(\"%lld\\n\",len[i]);\n\t\tif (len[i-1]+len[i]>x) break;\n\t\tlen[i+1]=len[i-1]+len[i];\n\t\tnum[i+1]=num[i-1]+num[i];\n\t}\n\tfor (j=i;j;j--) {\n\t\tif (x>=len[j]) {\n\t\t\tx-=len[j];\n\t\t\tans+=num[j];\n\t\t}\n\t}\n\tfor (i=1;i<=x;i++) if (s[i]==ch) ans++;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tn/=2;\n\tj=0;\n\tfor (i=2;i<=n;i++) {\n\t\twhile (j && s[j+1]!=s[i]) j=p[j];\n\t\tif (s[j+1]==s[i]) p[i]=++j;\n\t}\n\tm=n-p[n];\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor (i=0;i<D;i++) printf(\"%lld \",work(r,i)-work(l-1,i));\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 200009;\nchar s[maxn]; int Next[maxn], n, m;\nLL l, r, w[26];\n\nvoid solve(LL k){\n\tif (k <= n){\n\t\tfor (int i=0; i<k; i++) w[s[i]-'a']++;\n\t\treturn;\n\t}\n\tLL S = 1, T = 0, _s = 0, _t = 1;\n\twhile (S*n + T*m < k) { S += _s; T += _t; _s = S - _s; _t = T - _t; }\n\tsolve(k - _s*n - _t*m);\n\tfor (int i=0; i<n; i++) w[s[i]-'a'] += _s;\n\tfor (int i=0; i<m; i++) w[s[i]-'a'] += _t;\n}\n\nint main(){\n\tgets(s); scanf(\"%lld%lld\", &l, &r);\n\tn = strlen(s)/2;\n\tint k = 0; Next[0] = 0;\n\tfor (int i=1; i<n; i++){\n\t\twhile (k && s[k] != s[i]) k = Next[k-1];\n\t\tif (s[k] == s[i]) k++; Next[i] = k;\n\t}\n\tm = n-Next[n-1];\n\tsolve(l-1); for (int i=0; i<26; i++) w[i] = -w[i];\n\tsolve(r); for (int i=0; i<26; i++) printf(\"%lld \", w[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nstring f(string s) {\n\tint n = int(s.size()) / 2;\n\tvector<int> fail(n+1);\n\tfail[0] = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint cnd = fail[i-1];\n\t\twhile (cnd != -1 && s[cnd] != s[i-1]) {\n\t\t\tcnd = fail[cnd];\n\t\t}\n\t\tassert(cnd == -1 || s[cnd] == s[i-1]);\n\t\tfail[i] = cnd+1;\n\t}\n\tint repLen = fail[n];\n\treturn s.substr(0, 2 * n - repLen) + s.substr(0, 2 * n - repLen);\n}\n\nmap<ll, vector<ll>> mem;\nset<ll> reflections;\nvector<ll> prefCnt(ll a) {\n\tif (mem.count(a)) {\n\t\treturn mem[a];\n\t}\n\tauto it = reflections.lower_bound(a);\n\tassert(it != reflections.begin());\n\t--it;\n\tll md = *it;\n\tvector<ll> v1 = prefCnt(md);\n\tvector<ll> v2 = prefCnt(a - md);\n\tfor (int i = 0; i < 26; i++) {\n\t\tv1[i] += v2[i];\n\t}\n\treturn mem[a] = v1;\n}\n\nvector<ll> go() {\n\tstring S; cin >> S;\n\tll L, R; cin >> L >> R; L--;\n\tstring f0 = S;\n\tstring f1 = f(f0);\n\tstring f2 = f(f1);\n\tll a = int(f0.size()) / 2;\n\tll b = int(f1.size()) / 2;\n\tll c = int(f2.size()) / 2;\n\tif (a + c == b + b) {\n\t\t//cerr << \"periodic\" << '\\n';\n\t\tll period = b - a;\n\t\tvector<ll> ans(26);\n\t\tfor (int i = 0; i < period; i++) {\n\t\t\tans[S[i] - 'a'] += (R - i + period - 1) / period - (L - i + period - 1) / period;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//cerr << \"fibo\" << '\\n';\n\tmem[0] = vector<ll>(26, 0);\n\tfor (int i = 0; i < int(S.size()); i++) {\n\t\tmem[i+1] = mem[i];\n\t\tmem[i+1][S[i]-'a']++;\n\t}\n\tfor (ll x = a, y = b; x <= R; y += x, x = y - x) {\n\t\treflections.insert(x);\n\t}\n\tvector<ll> rans = prefCnt(R);\n\tvector<ll> lans = prefCnt(L);\n\tvector<ll> ans(26);\n\tfor (int i = 0; i < 26; i++) {\n\t\tans[i] = rans[i] - lans[i];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tauto ans = go();\n\tfor (int i = 0; i < 26; i++) {\n\t\tcout << ans[i] << \" \\n\"[i+1==26];\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstring s;\nll l,r;\n\nint z[430252*2];\nvoid zalgo(string s){\n  REP(i,s.size())z[i] = 0;\n  // z algorithm\n  // http://snuke.hatenablog.com/entry/2014/12/03/214243\n  z[0] = s.size();\n  {\n    int i=1,j=0;\n    while(i<s.size()){\n      while(i+j<s.size() && s[j]==s[i+j]){\n        j++;\n      }\n      z[i]=j;\n      if(j==0){\n        i++;\n        continue;\n      }\n      int k=1;\n      while(i+k<s.size() && k+z[k]<j){\n        z[i+k] = z[k];\n        k++;\n      }\n      i+=k;\n      j-=k;\n    }\n  }\n}\n\nll fibmemo[1252];\nll fib(int x){\n  if(x==0)return 0;\n  if(x==1)return 1;\n  if(fibmemo[x]>0)return fibmemo[x];\n  return fibmemo[x] = fib(x-1)+fib(x-2);\n}\n\nll cnt[26];\nll ans[26];\n\nvoid calc(string &X, string &Y, ll end){\n  ll x = X.size();\n  ll y = Y.size();\n  if(end <= x+y){\n    // greedy\n    REP(i,end){\n      if(i<x)cnt[X[i]-'a']++;\n      else cnt[Y[i-x]-'a']++;\n    }\n    return;\n  }\n  ll xcnt = 1; int xi=1;\n  ll ycnt = 0; int yi=0;\n  while(x*xcnt <= end && y*ycnt <= end && x*xcnt+y*ycnt > 0 && x*xcnt+y*ycnt <= end){\n    xcnt = fib(++xi);\n    ycnt = fib(++yi);\n  }\n  xcnt = fib(--xi);\n  ycnt = fib(--yi);\n  REP(i,x)cnt[X[i]-'a']+=xcnt;\n  REP(i,y)cnt[Y[i]-'a']+=ycnt;\n  ll len = x*xcnt+y*ycnt;\n  if(len==end)return;\n  calc(X,Y,end-len);\n}\n\nstring f(string s){\n  zalgo(s);\n  int n = s.size();\n  int k = 0;\n  REP(i,(n-1)/2){\n    if(z[n-1-i]>=i+1)k=i+1;\n  }\n  string t = s.substr(0,n-k);\n  return t+t;\n}\n\nint main(){\n  cin>>s;\n  int n = s.size();\n  cin>>l>>r;\n  s = f(s);\n  // first step\n  s = f(s);\n  // second\n  string t = f(s);\n\n  string X = s.substr(0,s.size()/2);\n  string Y = t.substr(X.size(),t.size()/2-X.size());\n  calc(X,Y,r+1);\n  REP(i,26)ans[i]=cnt[i];\n  REP(i,26)cnt[i]=0;\n  calc(X,Y,l);\n  REP(i,26)ans[i]-=cnt[i];\n  REP(i,26)printf(\"%llu%c\",ans[i],i==25?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos,1);\n\t}\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tint m=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0){\n\t\tif(l<=n){\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=(l-1)%m+1;i<=(r-1)%m+1;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=(l-1)%m+1;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=(r-1)%m+1;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=1;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tsolve(x,l,1);\n\tsolve(x+1,r-len[x],0);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nchar s[maxn]; int len;\nint h0[maxn], pw[maxn];\ninline int sub(int l,int r) {\n\treturn (h0[r] + ll(mod - pw[r - l + 1]) * h0[l - 1]) % mod;\n}\nstruct T { ll a[26]; };\ninline T add(T x, T y) {\n\tfor(int i = 0;i < 26;++i) {\n\t\tx.a[i] += y.a[i];\n\t}\n\treturn x;\n}\ninline T sub(T x, T y) {\n\tfor(int i = 0;i < 26;++i) {\n\t\tx.a[i] -= y.a[i];\n\t}\n\treturn x;\n}\ntypedef std::string str;\nT sum[maxn], empty;\nll size[maxn];\nstr b;\nint ok[maxn];\ninline void init(str s0, str s1) {\n\ts1 = s0 + s1;\n\tsize[1] = s0.size(), size[2] = s1.size();\n\tfor(char i : s0) ++ sum[1].a[i - 'a'];\n\tfor(char i : s1) ++ sum[2].a[i - 'a'];\n\tok[1] = ok[2] = 1;\n\tfor(int i = 3;i <= 100;++i) {\n\t\tsize[i] = size[i - 1] + size[i - 2];\n\t\tok[i] = ok[i - 1] && size[i] <= 2e18;\n\t\tsum[i] = add(sum[i - 1], sum[i - 2]);\n\t}\n}\ninline T pre(ll x) {\n\tT ans = empty;\n\tfor(int j = 100;j >= 0;--j) if(ok[j] && x >= size[j]) {\n\t\tans = add(ans, sum[j]);\n\t\tx -= size[j], --j;\n\t}\n\tfor(int j = 1;j <= x;++j) ++ ans.a[s[j] - 'a'];\n\treturn ans;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\t*pw = 1;\n\tfor(int i = 1;i < maxn;++i) {\n\t\tpw[i] = pw[i - 1] * 233ll % mod;\n\t}\n\tcin >> s + 1, len = strlen(s + 1) >> 1;\n\tfor(int i = 1;i <= len;++i) {\n\t\th0[i] = (h0[i - 1] * 233ll + s[i]) % mod;\n\t}\n\tint border = len;\n\tfor(int i = 1;i < len;++i) {\n\t\tif(sub(1, i) == sub(len - i + 1, len)) {\n\t\t\tborder = i;\n\t\t}\n\t}\n\tif(border << 1 >= len) {\n\t\tinit(str(s + 1, s + len + 1), str(s + 1, s + len + 1));\n\t} else if(border > 0) {\n\t\tinit(str(s + 1, s + len + 1), str(s + 1, s + len - border + 1));\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\tT ans = sub(pre(r), pre(l - 1));\n\tfor(int i = 0;i < 26;++i) {\n\t\tcout << ans.a[i] << ' ';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 200005\n#define mod1 1000000003\n#define mod2 1000000007\nusing namespace std;\n//ifstream cin(\"date.in\");\n//ofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\npair<long long, long long> h[DIM], pt[DIM], val, prv;\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    for(i = 1; i <= n; i++){\n        if(i <= n / 2 + n % 2){\n            a[i] = s[i];\n        }\n        else{\n            a[i + 1] = s[i];\n        }\n    }\n    a[n / 2 + n % 2 + 1] = '*';\n    for(i = 2; i <= n + 1; i++){\n        while(L > 0 && a[i] != a[L + 1]){\n            L = p[L];\n        }\n        if(a[i] == a[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    n = n - p[n + 1];\n    for(i = 1; i <= n; i++){\n        pt[i] = make_pair(pt[i - 1].first * 26 % mod1, pt[i - 1].second * 26 % mod2);\n    }\n    for(i = n; i >= 1; i--){\n        h[i].first = (h[i + 1].first * 26 + s[i] - 'a') % mod1;\n        h[i].second = (h[i + 1].second * 26 + s[i] - 'a') % mod2;\n    }\n    for(i = 1; i <= n; i++){\n        prv.first = h[1].first - h[i + 1].first * pt[n - i].first % mod1;\n        if(prv.first < 0){\n            prv.first += mod1;\n        }\n        prv.second = h[1].second - h[i + 1].second * pt[n - i].second % mod2;\n        if(prv.second < 0){\n            prv.second += mod2;\n        }\n        ok = 1;\n        for(j = i + 1; j + i - 1 <= n; j += i){\n            val.first = h[j].first - h[j + i].first * pt[n - i - j + 1].first % mod1;\n            if(val.first < 0){\n                val.first += mod1;\n            }\n            val.second = h[j].first - h[j + i].second * pt[n - i - j + 1].second % mod2;\n            if(val.second < 0){\n                val.second += mod2;\n            }\n            if(val != prv){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=300005;\nint nxt[maxn],n,k;\nchar s[maxn];\ninline i64 calc(int c,i64 r){\n\ti64 res=0;\n\tif(r<=n){\n\t\trep(i,1,r)res+=s[i]==c;\n\t\treturn res;\n\t}\n\ti64 ca=0,cb=0;\n\trep(i,1,n-k)ca+=s[i]==c;\n\trep(i,n-k+1,n)cb+=s[i]==c;\n\tif(k%(n-k)==0){\n\t\ti64 cc=0;\n\t\trep(i,n-k+1,n-k+(r-(n-k))%k)cc+=s[i]==c;\n\t\treturn ca+cb*((r-(n-k))/k)+cc;\n\t}else{\n\t\ti64 a=n-k,b=k;\n\t\tfor(;a+b<=r;b+=a,swap(a,b),cb+=ca,swap(ca,cb));\n\t\treturn ca+calc(c,r-a);\n\t}\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\trep(i,2,n){\n\t\tint p=nxt[i-1];\n\t\twhile(p&&s[p+1]!=s[i])p=nxt[p];\n\t\tif(s[p+1]==s[i])p++;\n\t\tnxt[i]=p;\n\t}\n\tk=nxt[n];\n\tif(k==0)k=n,n+=n;\n\ti64 l,r;\n\tcin>>l>>r;\n\trep(i,0,25)cout<<calc(i+'a',r)-calc(i+'a',l-1)<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define next next2\n#define inf (ll)(1e18)\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar s[200005];\n\nll sum[100][26],len[100],ans[26];\nint ns;\n\nvoid pre(int n,int m) {\n  ns=1;\n  len[0]=m;len[1]=n;\n  for(int i=0;i<m;i++) sum[0][s[i]-'a']++;\n  for(int i=0;i<n;i++) sum[1][s[i]-'a']++;\n  for(;len[ns]<inf;ns++) {\n  \tlen[ns+1]=len[ns]+len[ns-1];\n  \tfor(int j=0;j<26;j++) sum[ns+1][j]=sum[ns][j]+sum[ns-1][j];\n  } \n}\n\nll calc(ll n,int num) {\n  for(int i=ns;i>0;i--) \n    if (n>=len[i]) {\n    \tfor(int j=0;j<26;j++) ans[j]+=sum[i][j]*num;\n    \tn-=len[i];\n\t}\n  for(int i=0;i<n;i++) ans[s[i]-'a']+=num;\n}\n\nint next[200005];\n\nint kmp(int n) {\n  s[n]='\\0';\n  next[0]=next[1]=0;\n  for(int i=1,j=0;i<n;i++) {\n  \twhile (j&&s[j]!=s[i]) j=next[j];\n  \tif (s[j]==s[i]) j++;\n  \tnext[i+1]=j;\n  }\n  return next[n];\n}\n\nint main() {\n  scanf(\"%s\",s);\n  int n=strlen(s);\n  n>>=1;\n  int m=n-kmp(n);\n  pre(n,m);\n  ll l=0,r=0;\n  scanf(\"%lld%lld\",&l,&r);\n  calc(r,1);\n  calc(l-1,-1);\n  for(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\nchar s[200002];\nint hs[200002],pw[200002];\nint gethash(int st,int ed)\n{\n\treturn hs[ed]-hs[st-1]*pw[ed-st+1];\n}\nvector<long long> accumulate(int st,int ed)\n{\n\tvector<long long> ret(26);\n\tfor (int i=st;i<=ed;++i)\n\t\t++ret[s[i]-'a'];\n\treturn ret;\n}\nvoid count_numbers(vector<long long> p,vector<long long> q,vector<long long>& ans,long long& rem)\n{\n\tlong long sm=0;\n\tvector<long long> add;\n\tfor (int i=0;i<26;++i)\n\t{\n\t\tsm+=q[i];\n\t\tadd.push_back(p[i]+q[i]);\n\t}\n\tif (sm>rem)\n\t\treturn;\n\tcount_numbers(q,add,ans,rem);\n\tif (sm<=rem)\n\t{\n\t\tfor (int i=0;i<26;++i)\n\t\t\tans[i]+=q[i];\n\t\trem-=sm;\n\t}\n}\nint plen;\nvector<long long> f10100(long long len,vector<long long> p,vector<long long> q)\n{\n\tvector<long long> ans(26);\n\tcount_numbers(q,p,ans,len);\n\tfor (int i=1;i<=len;++i)\n\t\t++ans[s[i]-'a'];\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=int(strlen(s+1));\n\tpw[0]=1;\n\tn/=2;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpw[i]=pw[i-1]*202877;\n\t\ths[i]=hs[i-1]*202877+s[i];\n\t}\n\tfor (int i=n;i>=n/2+1;--i)\n\t\tif (gethash(1,n-i)==gethash(i+1,n))\n\t\t\tplen=i;\n\tvector<long long> p=accumulate(1,plen),q=accumulate(plen+1,n);\n\tlong long l,r;\n\tscanf(\"%lld%lld\",&l,&r);\n\tvector<long long> rnum=f10100(r,p,q),lnum=f10100(l-1,p,q);\n\tfor (int i=0;i<26;++i)\n\t\tprintf(\"%lld \",rnum[i]-lnum[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    A = T;\n    for(int i = 0; i < pi[T.size() - 1]; i++) A.push_back(T[i]);\n    B = A;\n    for(int i = 0; i < T.size(); i++) B.push_back(T[i]);\n\n    //cout << A << ' ' << B << endl;\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\n///// This part below is only for debug, not used /////\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n///// END /////\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\nlint L, R;\nstring S, T, U;\n\n// Z algorithm (length of longest common prefix for s[0:N] & s[i:N] for each i)\n// Complexity: O(N)\n// <http://snuke.hatenablog.com/entry/2014/12/03/214243>\n\nvector<int> z_algorithm(const string &s) {\n    vector<int> ans(s.size());\n    ans[0] = s.size();\n    int i = 1, j = 0;\n    while (i < (int)s.size()) {\n        while (i + j < (int)s.size() && s[j] == s[i + j]) ++j;\n        ans[i] = j;\n        if (!j) {\n            ++i;\n            continue;\n        }\n        int k = 1;\n        while (i + k < (int)s.size() && k + ans[k] < j) ans[i + k] = ans[k], ++k;\n        i += k;\n        j -= k;\n    }\n    return ans;\n}\nvector<lint> C2(string S) {\n    vector<lint> ret(26);\n    for (auto c : S) ret[c - 'a']++;\n    for (auto &d : ret) d /= 2;\n    return ret;\n}\n\nstring Next(string S) {\n    vector<int> z = z_algorithm(S);\n    int r = S.length();\n    FOR(i, S.length() / 2 + 1, S.length()) if (z[i] + i == S.length()) mmin(r, i);\n    return  S.substr(0, r) + S.substr(0, r);\n}\n\nmap<lint, vector<lint>> mp;\n\nvector<lint> solve(lint L) {\n    vector<lint> ret(26);\n    while (L > U.length())\n    {\n        auto itr = prev(mp.upper_bound(L));\n        REP(d, 26) ret[d] += itr->second[d];\n        L -= itr->first;\n    }\n    REP(i, L) ret[U[i] - 'a']++;\n    return ret;\n}\n\nint main()\n{\n    cin >> S >> L >> R;\n    T = Next(S);\n    vector<lint> v1 = C2(S), v2 = C2(T);\n    lint l1 = S.length() / 2, l2 = T.length() / 2;\n    mp[l1] = v1;\n    mp[l2] = v2;\n    U = T;\n    REP(_, 1e2) {\n        U = Next(U);\n        if (U.length() > 1e6) break;\n    }\n    while (l2 < 2e18) {\n        swap(l1, l2);\n        l2 += l1;\n        swap(v1, v2);\n        REP(i, 26) v2[i] += v1[i];\n        mp[l2] = v2;\n    }\n    vector<lint> ret1 = solve(L - 1), ret2 = solve(R);\n    REP(d, 26) printf(\"%lld \", ret2[d] - ret1[d]);\n    puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint z[200005];\nlong long l,r,num[200005][26];\nint n,p;\nstring s;\nvoid zfunc()\n{\n\tint l=0,r=0;\n\tmemset(z,0,sizeof(z));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<=r)z[i]=min(z[i-l],r-i+1);\n\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;\n\t\tif(i+z[i]-1>r)\n\t\t{\n\t\t\tl=i;\n\t\t\tr=i+z[i]-1;\n\t\t}\n\t}\n}\nlong long doit(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n\tif(x<=2*n)return num[n][y]+num[x-n][y];\n\tlong long x1=num[n][y]+num[p][y],x2=num[n][y];\n\tlong long l1=n+p,l2=n;\n\twhile(x>l1+l2)\n\t{\n//\t\tcout<<x1<<\" \"<<x2<<\" \"<<l1<<\" \"<<l2<<endl;\n\t\tlong long t=x1;\n\t\tx1+=x2;\n\t\tx2=t;\n\t\tt=l1;\n\t\tl1+=l2;\n\t\tl2=t;\n\t}\n\tx1+=doit(x-l1,y);\n//\tcout<<x<<\" \"<<x1<<endl;\n\treturn x1;\n}\nlong long sol(long long x,int y)\n{\n\tif(x<=n)return num[x][y];\n//\tif(x<=2*n)return num[n][y]+num[x-n][y];\n/*\tif(n%p==0)\n\t{\n\t\tlong long xx=(x-n)/(long long)p*num[p][y]+num[n][y];\n\t\tx%=(long long)p;\n\t\txx+=num[x][y];\n\t\treturn xx;\n\t}\n*/\treturn doit(x,y);\n}\nint main()\n{\n\tcin>>s>>l>>r;\n\tn=s.size();\n\tn/=2;\n\ts=s.substr(0,n);\n\tzfunc();\n\tp=n;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tif(z[i]+i==n)\n\t\t{\n\t\t\tp=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)num[i][j]=num[i-1][j];\n\t\tnum[i][s[i-1]-'a']++;\n\t}\n//\tcout<<sol(10,0)<<endl;\n\tfor(int i=0;i<26;i++)cout<<sol(r,i)-sol(l-1,i)<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nint n,p,t,v[26],height[N],sa[N],rank[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\ninline int read()\n{\n\tint x=0,c=getchar(),f=1;while(c<'0'||c>'9')f=(c=='-'?-f:f),c=getchar();\n\twhile(c>='0'&&c<='9')x=(x<<1)+(x<<3)+c-48,c=getchar();return f>0?x:-x;\n}\nvoid print(long long x)\n{\n\tif(x>9)print(x/10);putchar(x%10+48);\n}\nvoid SA()\n{\n\tfor(int i=1;i<=n;i++)cntA[(int)s[i]]++;\n\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(int i=n;i;i--)sa[cntA[(int)s[i]]--]=i;\n\trank[sa[1]]=1;\n\tfor(int i=2;i<=n;i++){\n\t\trank[sa[i]]=rank[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])rank[sa[i]]++;\n\t}\n\tfor(int l=1;rank[sa[n]]!=n;l<<=1){\n\t\tfor(int i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcntA[A[i]=rank[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?rank[i+l]:0)]++;\n\t\t}\n\t\tfor(int i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(int i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(int i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\trank[sa[1]]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\trank[sa[i]]=rank[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])rank[sa[i]]++;\n\t\t}\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[rank[i]-1]+tot])tot++;\n\t\theight[rank[i]]=tot;\n\t}\n\tp=n;int mi=N;\n\tfor(int i=rank[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(int i=rank[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(int w,int F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(int i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(int i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(int i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(int i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(int i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(int i=(l-n)%p;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(int i=1;i<=r%p;i++)a[s[i]-97]++;\n\t\t\tfor(int i=0;i<26;i++)a[i]+=1LL*v[i]*(r/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(int i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(int i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(int i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(int i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\trep(j,n)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n/*\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}*/ \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nconst int M = 110;\n\ntypedef long long LL;\n\nchar S[N];\nint n, f[N];\n\nstruct Info{\n\tLL cnt[26];\n\n\tInfo(){\n\t\tmemset(cnt, 0, sizeof cnt);\n\t}\n\n\tInfo operator + (const Info& A) const{\n\t\tInfo ret;\n\t\tFor(i, 0, 25) ret.cnt[i] = A.cnt[i] + cnt[i];\n\t\treturn ret;\n\t}\n\n\tInfo operator - (const Info& A) const{\n\t\tInfo ret;\n\t\tFor(i, 0, 25) ret.cnt[i] = cnt[i] - A.cnt[i];\n\t\treturn ret;\n\t}\n\n}A[M];\n\nLL len[M];\n\nInfo work(int x, LL r){\n\tif(x <= 2){\n\t\tInfo ret;\n\t\tFor(i, 1, r) ret.cnt[S[i] - 'a']++;\n\t\treturn ret;\n\t}\n\tif(r <= len[x - 2]) return work(x - 2, r);\n\telse return A[x - 2] + work(x - 1, r - len[x - 2]);\n}\n\nInfo calc(LL r){\n\tif(r <= n) return work(1, r);\n\tint i = 1;\n\twhile(len[i] * 2 < r) ++i;\n\treturn A[i] + work(i, r - len[i]);\n}\n\nint main(){\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\n\tf[1] = 0;\n\tFor(i, 2, n){\n\t\tint p = f[i - 1];\n\t\twhile(p && S[p + 1] != S[i]) p = f[p];\n\t\tf[i] = S[p + 1] == S[i] ? p + 1 : 0;\n\t}\n//\tprintf(\"period = %d\\n\", n - f[n]);\n\n\tFor(i, 1, n) A[1].cnt[S[i] - 'a']++;\n\tlen[1] = n;\n\tFor(i, 1, n + n - f[n]) A[2].cnt[S[i] - 'a']++;\n\tlen[2] = n + n - f[n];\n\tFor(i, 3, 100) len[i] = len[i - 1] + len[i - 2], A[i] = A[i - 1] + A[i - 2];\n\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tInfo ans = calc(r) - calc(l - 1);\n\tFor(i, 0, 25) printf(\"%lld%c\", ans.cnt[i], i == 25 ? '\\n' : ' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define b 31ll\n#define mod 1004535809ll\n#define ll long long\nusing namespace std;\nchar s[400005];\nll l[1005],fib[1005][27],ans[27];\nll has[400005],m[400005],lo,hi;\nint len,t;\ninline ll get(int l,int r)\n{if (l>r) return 0;\nll ret=(has[r]-has[l-1]*m[r-l+1])%mod;\nreturn (ret<0?ret+mod:ret);\n}\ninline void add(ll p,int pos)\n{if (pos==0)\n{for (int i=1;i<=p;i++)\n{ans[s[i]-'a']++;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]+=fib[pos-1][i];\nadd(p-l[pos-1],pos-2);\nreturn;\n}\nadd(p,pos-1);\n}\ninline void del(ll p,int pos)\n{if (pos==0)\n{for (int i=1;i<=p;i++)\n{ans[s[i]-'a']--;}\nreturn;\n}\nif (p>=l[pos-1])\n{for (int i=0;i<26;i++) ans[i]-=fib[pos-1][i];\ndel(p-l[pos-1],pos-2);\nreturn;\n}\ndel(p,pos-1);\n}\nint main (){\n\tint i,j,las;\n\tgets(s+1);len=strlen(s+1);\n\tscanf (\"%lld%lld\",&lo,&hi);\n\tm[0]=1ll;len>>=1;\n\tfor (i=1;i<=len;i++)\n\t{m[i]=m[i-1]*b%mod;\n\thas[i]=has[i-1]*b+(s[i]-'0');\n\thas[i]%=mod;\n\t}\n\tfor (i=1;i<=len;i++)\n\t{if (get(1,len-i)==get(i+1,len))\n\t{t=i;break;}\n\t}\n\tl[0]=len;l[1]=len+t;\n\tfor (i=1;i<=len;i++)\n\t{fib[0][s[i]-'a']++;\n\tfib[1][s[i]-'a']++;\n\t}\n\tfor (i=1;i<=t;i++)\n\t{fib[1][s[i]-'a']++;}\n\tfor (i=2;l[i-2]+l[i-1]<=2ll*hi;i++)\n\t{for (j=0;j<26;j++)\n\t{fib[i][j]=fib[i-1][j]+fib[i-2][j];}\n\tl[i]=l[i-1]+l[i-2];\n\tlas=i;\n\t}\n\tadd(hi,las);del(lo-1,las);\n\tfor (i=0;i<26;i++)\n\t{printf (\"%lld \",ans[i]);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint n,up,nex[N],type;\nchar str[N];\nint pre[N][26];\nll l,r,cut,len[100],ans[26];\nll f[100][26];\nvoid readData(){\n    scanf(\"%s%lld%lld\",str+1,&l,&r);\n    n=strlen(str+1);\n    n>>=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<26;j++) pre[i][j]=pre[i-1][j];\n        pre[i][str[i]-'a']++;\n    }\n}\nvoid getNex(){\n    nex[1]=0;\n    for(int i=2,j;i<=n;i++){\n        j=nex[i-1];\n        while(j&&str[j+1]!=str[i]) j=nex[j];\n        nex[i]=(str[j+1]==str[i])?j+1:0;\n    }\n}\nvoid preWork(){\n    len[1]=n;\n    for(int i=1;i<=n;i++){\n        f[1][str[i]-'a']++;\n        f[2][str[i]-'a']++;\n    }\n    len[2]=n+cut;\n    for(int i=0;i<26;i++) \n        f[2][i]+=pre[cut][i];\n    for(int i=3;;i++){\n        for(int j=0;j<26;j++) f[i][j]=f[i-2][j]+f[i-1][j];\n        len[i]=len[i-2]+len[i-1];\n        if(len[i]>1e18){\n            up=i;\n            break;\n        }\n    }\n}\nvoid calc1(ll m,ll a){\n    if(m<=0) return;\n    ll t=m/cut;\n    for(int i=0;i<26;i++) ans[i]+=a*t*pre[cut][i];\n    t=m%cut;        \n    for(int i=0;i<26;i++) ans[i]+=a*pre[t][i];\n}\nvoid calc2(ll m,ll a){\n    for(int i=up;i>=1;i--)\n        if(len[i]<=m){\n            m-=len[i];\n            for(int j=0;j<26;j++) ans[j]+=a*f[i][j];\n        }\n    for(int j=0;j<26;j++) ans[j]+=a*pre[m][j];\n}\nint main(){\n    readData();\n    getNex();\n    cut=n-nex[n];\n    if(n%cut==0){\n        calc1(r,1);\n        calc1(l-1,-1);\n    }\n    else{\n        preWork();\n        calc2(r,1);\n        calc2(l-1,-1);\n    }\n    for(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[888888],sz,pos,g,cnt[28][222222],p[28][444444],q[28][888888];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[888888];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz-i;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tpos=0;\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\nconst bool DEBUG = 0;\n/// --- .lumrc Template {{{ ///\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\";\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\";\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n<<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\";\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\";\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\nstring s = ins;\nint n = s.size() / 2;\n\nll ans;\nint k = 0;\nconst int N = 1e6;\narray<ll, 27> cnt[N];\nconst int MAXS = 10000;\narray<ll, 27> SS[MAXS];\nint SSLength;\n\narray<ll, 27> add(array<ll, 27> a, array<ll, 27> b, bool minus = false) {\n  REP(i, 27) {\n    a[i] += b[i] * (minus ? -1 : 1);\n  }\n  return a;\n}\n\narray<ll, 27> solve(ll x) {\n  array<ll,27> res;\n  if(x <= n) {\n    return cnt[x];\n  }\n  array<ll,27> search;\n  search[0] = x;\n  search[1] = LINF;\n\n  int p = lower_bound(SS, SS + SSLength, search) - SS;\n  p--;\n  assert(p>=0);\n  // dump2(x, SS[p][0]);\n  // dump2(p, SSLength);\n  return add(SS[p], solve(x - SS[p][0]));\n}\n\null upow(ull a, ull b) {\n  ull res = 1;\n  while(b) {\n    if(b&1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nconst ull B = 26;\n\nint main() {\n  // ローリングハッシュ法で前半k文字と後半k文字で一致する\n  // ような最大のkを求める\n  dump(2);\n  ull backHash = 0;\n  ull forwardHash = 0;\n  REP(i, n-1) {\n    backHash *= B;\n    backHash += s[i]-'a';\n    forwardHash += upow(B, i) * (s[n-1-i]-'a');\n    if(backHash == forwardHash) k = i + 1;\n  }\n  dump(k);\n  \n  dump(3);\n  ll l=inl, r=inl;\n  dump2(l, s);\n  \n  FOR(i, 1, n+1) {\n    cnt[i] = cnt[i-1];\n    cnt[i][0]++;\n    cnt[i][1+s[i-1]-'a']++;\n  }\n\n  REP(i, n-k) {\n    SS[0][0]++;\n    SS[0][1+s[i]-'a']++;\n  }\n  FOR(i, n-k, n) {\n    SS[1][0]++;\n    SS[1][1+s[i]-'a']++;\n  }\n  dump(4);\n  SSLength = MAXS;\n  FOR(i, 2, MAXS) {\n    REP(j, i-2+1) {\n      SS[i] = add(SS[i], SS[j]);\n      if(SS[i][0]>LINF) {\n        SSLength = i;\n        break;\n      }\n    }\n    if(SSLength!=MAXS) break;\n  }\n  \n  dump(1);\n  dump(r);\n  auto ans = add(solve(r), solve(l-1), true);\n  \n\n  dump(7);\n  REP(i, 26) {\n    cout << ans[i+1] << (i!=int(ans.size()-1)?\" \":\"\\n\");\n  }\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=4e5+100;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nchar s[N];\nint nxt[N];\nLL ans[26],cnt[1000][26],len[1000];\ninline void solve(int n,int v,LL m) {\n\tint i,t;\n\tif (n%v) {\n\t\tmemset(cnt,0,416);\n\t\tlen[0]=v;\n\t\tfor (i=1;i<=v;i++) cnt[0][s[i]-'a']++;\n\t\tlen[1]=n;\n\t\tfor (i=1;i<=n;i++) cnt[1][s[i]-'a']++;\n\t\tfor (i=2;(len[i]=len[i-1]+len[i-2])<=m;i++)\n\t\t\tfor (t=0;t<26;t++) cnt[i][t]=cnt[i-1][t]+cnt[i-2][t];\n\t\twhile (i--)\n\t\t\tif (m>=len[i])\n\t\t\t\tfor (t=0,m-=len[i];t<26;t++) ans[t]+=cnt[i][t];\n\t} else {\n\t\tfor (i=1;i<=n&&i<=m;i++)\n\t\t\tans[s[i]-'a']++;\n\t\tif (m<=n) return;\n\t\tm-=n;\n\t\tfor (i=1;i<=v;i++)\n\t\t\tans[s[i]-'a']+=m/v+(m%v>=i);\n\t}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1)/2,i,k,v;LL l,r;cin>>l>>r;\n\tfor (i=2,k=0;i<=n;i++) {\n\t\twhile (k&&s[k+1]!=s[i]) k=nxt[k];\n\t\tnxt[i]=k+=s[k+1]==s[i];\n\t}\n\tv=n-nxt[n];\n\tsolve(n,v,l-1);\n\tfor (i=0;i<26;i++) ans[i]*=-1;\n\tsolve(n,v,r);\n\tfor (i=0;i<26;i++)\n\t\tcout<<ans[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename X, typename Y> istream& operator>>(istream& is, pair<X, Y>& p) { return is >> p.first >> p.second; }\n// z[i] is the length of the longest common prefix between s and the suffix of s starting at i\nvector<int> make_z_function(const string& s) {\n    vector<int> z(s.length() + 1);\n    z[0] = s.length();\n    for(int i = 1, L = 0, R = 0; i < s.length(); i++) {\n        z[i] = i < R ? min(z[i - L], R - i) : 0;\n        while(i + z[i] < s.length() and s[i + z[i]] == s[z[i]]) {\n            z[i]++;\n        }\n        if(R < i + z[i]) {\n            L = i, R = i + z[i];\n        }\n    }\n    return z;\n}\nvector<vector<int>> make_occ(const string& S) {\n    vector<vector<int>> occ(256, vector<int>(S.size() + 1));\n    for(char c = 'a'; c <= 'z'; c++) {\n        for(int i = 1; i <= S.size(); i++) {\n            occ[c][i] = S[i - 1] == c;\n        }\n        partial_sum(occ[c].begin(), occ[c].end(), occ[c].begin());\n    }\n    return occ;\n}\nvoid solve(std::string S, long long l, long long r) {\n    S = S.substr(0, S.size() / 2);\n    auto z = make_z_function(S);\n    string T;\n    for(int i = 1; i <= S.size() and T.size() == 0; i++) {\n        if(z[i] == S.size() - i) {\n            T = S.substr(0, i);\n        }\n    }\n    auto occ0 = make_occ(S), occ1 = make_occ(S + T);\n    if(S.size() % T.size() == 0) {\n        auto C = [&](ll i, char c) {\n            return i / S.size() * occ0[c][S.size()] + occ0[c][i % S.size()];\n        };\n        for(char c = 'a'; c <= 'z'; c++) {\n            cout << C(r, c) - C(l - 1, c) << \" \\n\"[c == 'z'];\n        }\n    } else {\n        vector<ll> len = {ll(S.size()), ll(S.size() + T.size())};\n        while(len.back() < r) {\n            len.push_back(len[len.size() - 1] + len[len.size() - 2]);\n        }\n        map<tuple<int, ll, char>, ll> memo;\n        function<ll(int, ll, char)> C = [&](int level, ll i, char c) -> ll {\n            auto p = make_tuple(level, i, c);\n            if(not memo.count(p)) {\n                ll& ans = memo[p];\n                if(level == 0) {\n                    ans = occ0[c][i];\n                } else if(level == 1) {\n                    ans = occ1[c][i];\n                } else if(i > len[level - 1]) {\n                    ans = C(level - 1, len[level - 1], c) + C(level - 2, i - len[level - 1], c);\n                } else {\n                    ans = C(level - 1, i, c);\n                }\n            }\n            return memo[p];\n        };\n        for(char c = 'a'; c <= 'z'; c++) {\n            cout << C(len.size() - 1, r, c) - C(len.size() - 1, l - 1, c) << \" \\n\"[c == 'z'];\n        }\n    }\n}\nint main() {\n    std::string S;\n    std::cin >> S;\n    long long l;\n    scanf(\"%lld\",&l);\n    long long r;\n    scanf(\"%lld\",&r);\n    solve(S, l, r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 200000;\n\nll a[26], b[26], c[150][26], d[150];\n\nchar S[MAXN + 5]; int f[MAXN + 5];\nint main() {\n\tint n, m; ll l, r;\n\tscanf(\"%s%lld%lld\", S + 1, &l, &r);\n\tn = strlen(S + 1), m = n / 2;\n\t\n\tf[0] = -1, f[1] = 0;\n\tfor(int i=2;i<=m;i++) {\n\t\tint j = f[i - 1];\n\t\twhile( j != -1 && S[i] != S[j + 1] )\n\t\t\tj = f[j];\n\t\tf[i] = j + 1;\n\t}\n\t\n\tint p = m - f[m];\n\tif( f[m] && m % (m - f[m]) == 0 ) {\n\t\tll q1 = r / p, r1 = r % p, q2 = (l - 1) / p, r2 = (l - 1) % p;\n\t\tfor(int i=1;i<=p;i++) b[S[i] - 'a']++;\n\t\tfor(int i=0;i<26;i++) a[i] += q1 * b[i];\n\t\tfor(int i=1;i<=r1;i++) a[S[i] - 'a']++;\n\t\tfor(int i=0;i<26;i++) a[i] -= q2 * b[i];\n\t\tfor(int i=1;i<=r2;i++) a[S[i] - 'a']--;\n\t}\n\telse {\n\t\tfor(int i=1;i<=p;i++) c[0][S[i] - 'a']++;\n\t\tfor(int i=1;i<=m;i++) c[1][S[i] - 'a']++;\n\t\tint k; d[0] = p, d[1] = m;\n\t\tfor(k=1;d[k]<=r;k++) {\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tc[k + 1][j] = c[k][j] + c[k - 1][j];\n\t\t\td[k + 1] = d[k] + d[k - 1];\n\t\t}\n\t\t\n\t\tll t = r;\n\t\tfor(int i=k;i>=0;i--) {\n\t\t\tif( t >= d[i] ) {\n\t\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\t\ta[j] += c[i][j];\n\t\t\t\tt -= d[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=t;i++)\n\t\t\ta[S[i] - 'a']++;\n\t\t\n\t\tt = l - 1;\n\t\tfor(int i=k;i>=0;i--) {\n\t\t\tif( t >= d[i] ) {\n\t\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\t\ta[j] -= c[i][j];\n\t\t\t\tt -= d[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=t;i++)\n\t\t\ta[S[i] - 'a']--;\n\t}\n\t\n\tfor(int i=0;i<26;i++) printf(\"%lld \", a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n        cerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nconst int MAXN = 1000000;\nint z[MAXN];\nchar s[MAXN];\nll cc[100];\n\nvoid zz(int n) {\n    z[0] = 0;\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (r > i)\n            z[i] = min(r - i, z[i - l]);\n        else\n            z[i] = 0;\n        while (i + z[i] < n && s[i + z[i]] == s[z[i]])\n            ++z[i];\n        if (i + z[i] > r)\n            r = i + z[i], l = i;\n    }\n}\n\nstruct st {\n    ll len;\n    int l, r;\n    int dp;\n    ll cc[26];\n    st(int l, int r): l(l), r(r) {\n        len = r - l;\n        dp = 0;\n        for (int i = 0; i < 26; ++i)\n            cc[i] = 0;\n        for (int i = l; i < r; ++i)\n            ++cc[s[i] - 'a'];\n    }\n    st operator+(st x) {\n        st ans(0, 0);\n        ans.len = len + x.len;\n        ans.l = x.l;\n        ans.r = x.r;\n        ans.dp = x.dp + 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] + x.cc[i];\n        return ans;\n    }\n    st operator-(st x) {\n        st ans(0, 0);\n        ans.len = len - x.len;\n        ans.l = l;\n        ans.r = r;\n        ans.dp = dp - 1;\n        for (int i = 0; i < 26; ++i)\n            ans.cc[i] = cc[i] - x.cc[i];\n        return ans;\n    }\n};\n\n\nvoid add(st a, st b, ll x) {\n    if (x == 0)\n        return;\n    if (b.dp == 0) {\n        for (int i = b.l; i < b.l + x; ++i) {\n            ++cc[s[i] - 'a'];\n        }\n        return;\n    }\n    st q = a - b;\n    a = b;\n    b = q;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n        add(b, a - b, x);\n    }\n    else {\n        add(a, b, x);\n    }\n}\n\nvoid solve(ll x) {\n    int n = strlen(s);\n    zz(n);\n    int xx = 0;\n    for (int i = 1; i < n / 2; ++i)\n        if (i + z[i] >= n / 2) {\n            xx = i;\n            break;\n        }\n    assert(xx != 0);\n    st a(xx, n / 2);\n    st b(n / 2 - xx, xx);\n    for (int i = 0; i < min((ll)n, x); ++i)\n        ++cc[s[i] - 'a'];\n    x -= min((ll)n, x);\n    if (x == 0)\n        return;\n    while (x >= b.len + a.len + a.len + b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += 2 * a.cc[i] + 2 * b.cc[i];\n        x -= 2 * (a.len + b.len);\n        st q = a + b;\n        b = a;\n        a = q;\n    }\n    st c = a + b;\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= a.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += a.cc[i];\n        x -= a.len;\n    }\n    else {\n        add(c, a, x);\n        return;\n    }\n    if (x >= b.len) {\n        for (int i = 0; i < 26; ++i)\n            cc[i] += b.cc[i];\n        x -= b.len;\n    }\n    else {\n        add(a, b, x);\n        return;\n    }\n}\nll ans[100];\n\nint main() {\n    scanf(\"%s\", s);\n    ll l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    --l;\n    int n = strlen(s);\n    zz(n);\n    for (int i = 0; i < n; ++i)\n        ++cc[s[i] - 'a'];\n    for (int i = 1; i < n / 2; ++i) {\n        if (n % i == 0 && i + z[i] >= n) {\n            for (int i = 0; i < 26; ++i) {\n                ll ans = 0;\n                ans += cc[i] * (r / n);\n                for (int j = 0; j < r % n; ++j)\n                    if (s[j] - 'a' == i)\n                        ++ans;\n                ans -= cc[i] * (l / n);\n                for (int j = 0; j < l % n; ++j)\n                    if (s[j] - 'a' == i)\n                        --ans;\n                cout << ans << \"\\n\";\n            }\n            return 0;\n        }\n    }\n    n /= 2;\n    int x = n;\n    for (int i = 1; i < n; ++i) {\n        if (i + z[i] >= n) {\n            x = i;\n            break;\n        }\n    }\n    if (x == n) {\n        n *= 2;\n        for (int i = 0; i < 26; ++i) {\n            ll ans = 0;\n            ans += cc[i] * (r / n);\n            for (int j = 0; j < r % n; ++j)\n                if (s[i] - 'a' == i)\n                    ++ans;\n            ans -= cc[i] * (l / n);\n            for (int j = 0; j < l % n; ++j)\n                if (s[i] - 'a' == i)\n                    --ans;\n            cout << ans << \"\\n\";\n        }\n        return 0;\n    }\n    n *= 2;\n    for (int i = 0; i < x; ++i) {\n        s[n] = s[n - x];\n        ++n;\n    }\n    for (int i = 0; i < x; ++i) {\n        s[n + i] = s[i];\n    }\n    n += x;\n    for (int i = 0; i < 26; ++i)\n        cc[i] = 0;\n    solve(r);\n    for (int i = 0; i < 26; ++i)\n        ans[i] = cc[i], cc[i] = 0;\n    solve(l);\n    for (int i = 0; i < 26; ++i)\n        ans[i] -= cc[i];\n    for (int i = 0; i < 26; ++i)\n        cout << ans[i] << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 201000\n#define ll long long\nusing namespace std;\nchar s[N];\nint nxt[N],n,m,t,a[N][26];\nvoid kmp()\n{\n\tint j=0;\n\tfo(i,2,m)\n\t{\n\t\twhile(j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif(s[j+1]==s[i]) j++;\n\t\tnxt[i]=j;\n\t}\n}\nll calc(int x,ll l)\n{\n\tif(l<=m) return a[l][x];\n\tll l1=t,l2=m,b1=a[t][x],b2=a[m][x];\n\twhile(l2<=l)\n\t{\n\t\tll jy=b1;\n\t\tb1=b2;b2=b2+jy;\n\t\tjy=l1;l1=l2;l2=l1+jy;\n\t}\n\tif(l==l1) return b1;\n\telse return b1+calc(x,l-l1);\n}\nint main()\n{\n\tscanf(\"%s\\n\",s+1);\n\tn=strlen(s+1);\n\tm=n/2;\n\tkmp();\n\tt=m-nxt[m];\n\tfo(i,1,n)\n\t{\n\t\tfo(j,0,25) a[i][j]=a[i-1][j];\n\t\ta[i][s[i]-97]++;\n\t}\n\tll l,r;scanf(\"%lld %lld\",&l,&r);\n\tfo(i,0,25) printf(\"%lld \",calc(i,r)-calc(i,l-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 2*1e5+10;\n\nstring s;\nll l,r,len[maxn],cnt[100][maxn],ans[30];\nint KMP[maxn];\n\nint pre_calc(string s) {\n    memset(KMP,0,sizeof(KMP));\n    //cout<<s<<endl;\n    int n= s.length();\n    for (int i=0;i<n;i++) {\n        if (i==0) KMP[i]=-1;\n        else {\n            KMP[i] = KMP[i-1];\n            while (1) {\n                //cout<<i<<\" \"<<KMP[i]<<endl;\n                if (s[KMP[i]+1] == s[i]) {\n                    KMP[i]++;\n                    break;\n                }\n                if (KMP[i]==-1) break;\n                KMP[i] = KMP[KMP[i]];\n            }\n        }\n    }\n    //cout<<\"fuk\"<<endl;\n    int tmp = KMP[n-1]+1;\n    //cout<<tmp<<endl;\n    while (tmp*2>n) tmp=KMP[tmp];\n    return tmp;\n}\n\nvoid calc(ll LEN,ll coe) {\n    int T1 = pre_calc(s);\n    string s2 = \"\";\n    for (int i=0;i<s.length()-T1;i++) s2+=s[i];\n    int T2 = pre_calc(s2);\n    int sz=0;\n    //cout<<T1<<\" \"<<T2<<endl;\n    for (int i=T2;i<s2.length()-T2;i++) {\n        len[sz]++;\n        cnt[sz][s2[i]-'a']++;\n    }\n    sz++;\n    for (int i=0;i<T2;i++) {\n        len[sz]++;\n        cnt[sz][s2[i]-'a']++;\n    }\n    sz++;\n    while (len[sz-1]<=LEN) {\n        len[sz] = len[sz-1] + len[sz-2];\n        for (int i=0;i<26;i++) cnt[sz][i] = cnt[sz-1][i] + cnt[sz-2][i];\n        sz++;\n        ///cout<<len[sz-1]<<endl;\n    }\n    for (int i=sz-1;i>=2;i--) {\n        if (LEN>=len[i]) {\n            LEN-=len[i];\n            for (int j=0;j<26;j++) ans[j]+= coe*cnt[i][j];\n        }\n    }\n    for (int i=0;i<LEN;i++) ans[s[i]-'a']+=coe;\n\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>s;\n    cin>>l>>r;\n    calc(r,1);\n    calc(l-1,-1);\n    for (int i=0;i<26;i++) cout<<ans[i]<<\" \";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tV=0;\n\t\t}\n\t\tif(V>cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[2][i]-'a']++;\n\treturn ret;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t}\n\telse {\n\t\tassert(0);\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\tRR=hoge3(R);\n\t\tLL=hoge3(L-1);\n\t}\n\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 2) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = false;\n\ts = conv(s);\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 2; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define all(x) (x).begin(), (x).end()\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 4;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    string s;\n    cin >> s;\n    {\n        vector<int> z(s.size());\n        int L = 0, R = 0;\n        for (int i = 1; i < s.size(); i++)\n        {\n            z[i] = max(0, min(z[i - L], R - i));\n            while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n            if (i + z[i] > R)\n            {\n                R = i + z[i];\n                L = i;\n            }\n        }\n        int len = s.size();\n        for (int i = s.size() - 1; 2 * i > s.size(); i--)\n        {\n            if (i + z[i] == s.size())\n            {\n                len = i;\n            }\n        }\n        while (s.size() > len) s.pop_back();\n    }\n\n    ll n = s.size();\n    vector<int> z(s.size());\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    ll k = n;\n    for (int i = 1; i < s.size(); i++)\n    {\n        if (i + z[i] == s.size())\n        {\n            k = i;\n            break;\n        }\n    }\n    cout << n << \" \" << k << endl;\n    if (n % k == 0)\n    {\n        vector<ll> cnt(26);\n        ll L, R;\n        cin >> L >> R;\n        L--;\n        ll c = R / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] += c + 1;\n            else cnt[s[i] - 'a'] += c;\n        }\n        c = L / k;\n        for (int i = 0; i < k; i++)\n        {\n            if (i < R % k) cnt[s[i] - 'a'] -= c + 1;\n            else cnt[s[i] - 'a'] -= c;\n        }\n        for (int i = 0; i < 26; i++)\n        {\n            cout << cnt[i] << \" \";\n        }\n    }\n    else\n    {\n        return 1;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<cstring>\n#define DIM 200005\nusing namespace std;\nifstream cin(\"date.in\");\nofstream cout(\"date.out\");\nint n, L, i, j, ok, k;\nchar s[DIM], a[DIM];\nint p[DIM];\nlong long st, dr, fib[10000], sol[200], sn[200], sk[200];\nvoid solve(int m, long long x, int semn){\n    if(m <= 2){\n        if(x <= n){\n            for(int i = 1; i <= x; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        else{\n            for(int i = 1; i <= n; i++){\n                sol[ s[i] ] += semn;\n            }\n            for(i = 1; i <= x - n; i++){\n                sol[ s[i] ] += semn;\n            }\n        }\n        return;\n    }\n    if(fib[m - 1] * n + fib[m - 2] * k >= x){\n        solve(m - 1, x, semn);\n    }\n    else{\n        x -= fib[m - 1] * n + fib[m - 2] * k;\n        for(int i = 'a'; i <= 'z'; i++){\n            sol[i] += sn[i] * fib[m - 1] * semn;\n            sol[i] += sk[i] * fib[m - 2] * semn;\n        }\n        solve(m - 2, x, semn);\n    }\n}\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    cin>> st >> dr;\n    for(i = 1; i <= n; i++){\n        if(i <= n / 2 + n % 2){\n            a[i] = s[i];\n        }\n        else{\n            a[i + 1] = s[i];\n        }\n    }\n    a[n / 2 + n % 2 + 1] = '*';\n    for(i = 2; i <= n + 1; i++){\n        while(L > 0 && a[i] != a[L + 1]){\n            L = p[L];\n        }\n        if(a[i] == a[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    n = n - p[n + 1];\n    L = 0;\n    for(i = 2; i <= n; i++){\n        while(L > 0 && s[i] != s[L + 1]){\n            L++;\n        }\n        if(s[i] == s[L + 1]){\n            L++;\n        }\n        p[i] = L;\n    }\n    for(i = 1; i <= n; i++){\n        ok = 1;\n        for(j = i + i; j <= n; j += i){\n            if(p[j] != j - i){\n                ok = 0;\n            }\n        }\n        L = 1;\n        for(j = j - i + 1; j <= n; j++){\n            if(s[j] != s[L]){\n                ok = 0;\n            }\n            L++;\n        }\n        if(ok == 1){\n            k = i;\n            break;\n        }\n    }\n    for(i = 1; i <= n; i++){\n        sn[ s[i] ]++;\n    }\n    for(i = 1; i <= k; i++){\n        sk[ s[i] ]++;\n    }\n    fib[1] = fib[2] = 1;\n    for(i = 3; ; i++){\n        fib[i] = fib[i - 1] + fib[i - 2];\n        if(fib[i] * n >= dr || fib[i] * n + fib[i - 1] * k >= dr){\n            solve(i, dr, 1);\n            solve(i, st - 1, -1);\n            break;\n        }\n    }\n    for(i = 'a'; i <= 'z'; i++){\n        cout<< sol[i] <<\" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len; \nstring s;\nint cnt[maxn][maxm],z[maxn]; \nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-L]<=R-i)z[i]=z[i-L];\n\t\t\telse{\n\t\t\t\tz[i]=R-i;\n\t\t\t\tfor(int j=R-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tREP(i,n-1)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==0){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n \n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n \nusing namespace std;\n \ntypedef long long LL;\nconst int N = 400010;\n \nchar s0[N];\nint len, nxt[N];\n \nvoid get_nxt()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= len; i ++) {\n\t\twhile (j && s0[i] != s0[j + 1]) j = nxt[j];\n\t\tif (s0[i] == s0[j + 1]) j ++;\n\t\tnxt[i] = j; \n\t}\n}\n \nLL f[N][27], ans[27];\n \nLL calc(int x, LL k, int c)\n{\n\tif (f[x][0] == k) return f[x][c];\n\tif (k >= f[x - 1][0])\n\t\treturn f[x - 1][c] + calc(x - 2, k - f[x - 1][0], c);\n\telse return calc(x - 1, k, c);\n}\n \nint main()\n{\n\tscanf(\"%s\", s0 + 1);\n\tlen = strlen(s0 + 1) / 2;\n\tLL l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tget_nxt();\n\t\n\tRep(i, len - nxt[len]) f[0][s0[i] - 'a' + 1] ++;\n\tRep(i, len) f[1][s0[i] - 'a' + 1] ++;\n\tf[0][0] = len - nxt[len], f[1][0] = len;\n\tint x = 2;\n\twhile (true) {\n\t\tRep0(i, 26) f[x][i] = f[x - 1][i] + f[x - 2][i];\n\t\tif (f[x][0] >= r) break;\n\t\tx ++;\n\t}\n\tif (l > 1) Rep0(i, x) if (f[i][0] >= l - 1) {\n\t\tRep(j, 26) ans[j] -= calc(i, l - 1, j);\n\t\tbreak;\n\t}\n \n\tRep0(i, x) if (f[i][0] >= r) {\n\t\tRep(j, 26) ans[j] += calc(i, r, j);\n\t\tbreak;\n\t}\n\tRep(i, 26) printf(\"%lld \", ans[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nstring f(const string& s) {\n  const int n = s.size();\n  vector<int> Z(n);\n\n  Z[0] = n;\n  for (int i = 1, j = 0; i < n; ) {\n    while (i + j < n && s[j] == s[i + j]) {\n      ++j;\n    }\n    Z[i] = j;\n    if (j == 0) {\n      ++i;\n      continue;\n    }\n    int k = 1;\n    while (i + k < n && k + Z[k] < j) {\n      Z[i + k] = Z[k];\n      ++k;\n    }\n    i += k;\n    j -= k;\n  }\n\n  int r = 0;\n  for (int i = 1; i * 2 < n; ++i) {\n    if (Z[n - i] == i) {\n      r = i;\n    }\n  }\n\n  return s.substr(0, n - r) + s.substr(0, n - r);\n}\n\nInt len[1024], res[26], cnt[1024][26];\nstring A0, A1;\n\nvoid solve(int k, Int L, Int R) {\n  // cerr<<k<<' '<<L<<' '<<R<<endl;\n  if (len[k] == R - L) {\n    for (int i = 0; i < 26; ++i) {\n      res[i] += cnt[k][i];\n    }\n    return;\n  }\n  if (k <= 1) {\n    const string& s = (k == 0 ? A0 : A1);\n    for (int i = L; i < R; ++i) {\n      res[s[i] - 'a']++;\n    }\n    return;\n  }\n  if (L < len[k - 1]) solve(k - 1, L, min(R, len[k - 1]));\n  if (R > len[k - 1]) solve(k - 2, max(L, len[k - 1]) - len[k - 1], R - len[k - 1]);\n}\n\nint main() {\n  string S;\n  cin >> S;\n\n  Int L, R;\n  cin >> L >> R;\n  --L;\n\n  const string S1 = f(S);\n  const string S2 = f(S1);\n\n  A0 = S1.substr(S.size() / 2, S1.size() / 2 - S.size() / 2);\n  A1 = S2.substr(S1.size() / 2, S2.size() / 2 - S1.size() / 2);\n\n  for (const char c : A0) cnt[0][c - 'a']++;\n  for (const char c : A1) cnt[1][c - 'a']++;\n\n  int k = 1;\n  len[0] = A0.size();\n  len[1] = A1.size();\n  for (int i = 2; ; ++i) {\n    len[i] = len[i - 1] + len[i - 2];\n    for (int j = 0; j < 26; ++j) {\n      cnt[i][j] = cnt[i - 1][j] + cnt[i - 2][j];\n    }\n    if (len[i] > INFLL) {\n      k = i;\n      break;\n    }\n  }\n\n  S = S.substr(S.size() / 2);\n \n  fill(res, res + 26, 0);\n  if (L < S.size()) {\n    while (L < S.size() && L < R) {\n      res[S[L] - 'a']++;\n      ++L;\n    }\n  }\n  L -= S.size();\n  R -= S.size();\n\n  if (R - L > 0) {\n    for (int i = 0; i <= k; ++i) {\n      if (L < len[i]) solve(i, L, min(R, len[i]));\n      L -= len[i];\n      R -= len[i];\n      if (R <= 0) break;\n      if (L < 0) L = 0;\n    }\n  }\n\n  for (int i = 0; i < 26; ++i) {\n    printf(\"%lld%c\", res[i], i+1 == 26 ? '\\n' : ' ');\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nvector<ll> z_algo(string S) {//0-index\n\tll N = S.size();\n\n\tvector<ll> A(N, 0);\n\n\n\tll c = 0;\n\trepn(i, N - 1) {\n\t\tif (c > 0 && i - c + A[i - c] < A[c]) { A[i] = A[i - c]; }\n\t\telse {\n\t\t\tll j = max(0, c + A[c] - i);\n\t\t\twhile (i + j < N && S[j] == S[i + j]) { j++; }\n\t\t\tA[i] = j;\n\t\t\tc = i;\n\t\t}\n\t}\n\n\tA[0] = N;\n\n\treturn A;\n}\n\nll pre(string S) {\n\tll N = S.size();\n\tvll z = z_algo(S);\n\t//rep(j, N)cout << z[j] << \" \";\n\t//cout << endl;\n\n\trepn(i, N) {\n\t\tbool b = 1;\n\t\tfor (ll j = i; j < N; j+=i) {\n\t\t\tif (z[j] < min(N - j, i)) { b = 0; break; }\n\t\t}\n\t\tif (b) { return i; break; }\n\t}\n}\n\nstring S;\nll N;\nll P;\n\nmap<ll, vll> mp;\n\nvll f;\n\nvoid cal(ll l) {\n\t//cout << l << endl;\n\tif (mp.count(l)) { return; }\n\n\tif (N % P == 0) {\n\t\tll k = l / P;\n\t\tvll v = mp[P];\n\t\trep(j, 26) { v[j] *= k; }\n\t\tmp[l] = v;\n\t\treturn;\n\t}\n\n\tauto itr = lower_bound(f.begin(), f.end(), l);\n\tll x = distance(f.begin(), itr) - 1;\n\t//cout << x<<\" \"<<f[x] << endl;\n\t\n\tcal(f[x]);\n\tcal(l - f[x]);\n\n\tvll ret(26, 0);\n\trep(j, 26) {\n\t\tret[j] = mp[f[x]][j] + mp[l - f[x]][j];\n\t}\n\tmp[l] = ret;\n\treturn;\n}\n\nint main(){\n\tll l, r;\n\tcin >> S >> l >> r;\n\tll M = S.size();\n\tvll d = z_algo(S);\n\tN = M;\n\trepn(i, M - 1) {\n\t\tif (i * 2 >= M && d[i] >= M - i) { N = i; break; }\n\t}\n\tS = S.substr(0, N);\n\t//cout << S << endl;\n\n\tP = pre(S);\n\t//cout << N<<\" \"<<P << endl;\n\t\n\tvll c(26, 0);\n\tmp[0] = c;\n\trepn(i, N) {\n\t\tc[S[i - 1] - 'a']++;\n\t\tmp[i] = c;\n\t}\n\n\tf.assign(3, 0);\n\tf[0] = N;\n\tf[1] = N + P;\n\tf[2] = N * 2 + P;\n\tll X = 3;\n\twhile (1) {\n\t\tf.push_back(f[X - 1] - f[X - 3] + f[X - 1]);\n\t\tif (f[X] > INF || X > 500) { break; }\n\t\t//cout << f[X] << endl;\n\t\tX++;\n\t}\n\n\tcal(r);\n\tcal(l - 1);\n\trep(j, 26) {\n\t\tcout << mp[r][j] - mp[l - 1][j] << \" \";\n\t}\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\ntypedef long long ll;\nconst int Imx=2147483647;\nconst int mod=1000000007;\nconst ll Lbig=2e18;\n//My own input/output stream\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putsp()\n#define putii(x,y) puti(x),putnum(y),putsp()\n#define putiii(x,y,z) putii(x,y),putnum(z),putsp()\n#define putsi(x) putnum(x),putendl()\n#define putsii(x,y) puti(x),putnum(y),putendl()\n#define putsiii(x,y,z) putii(x,y),putnum(z),putendl()\ninline ll getnum()\n{\n\tregister ll r=0;register bool ng=0;register char c;c=getchar();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tif(c=='-')ng=1,c=getchar();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=getchar();\n\tif(ng)r=-r;return r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline void putsp(){putchar(' ');}\ninline void putendl(){putchar('\\n');}\ninline char mygetchar(){register char c=getchar();while(c==' '||c=='\\n')c=getchar();return c;}\nchar s[800111];\nll hs[800111],bs,pw[800111];\nint n;\nvoid iniths()\n{\n\tfor(int i=1;i<=n;i++)hs[i]=(1ll*hs[i-1]*bs+s[i])%mod;\n}\nll calchs(int l,int r)\n{\n\treturn ((hs[r]-1ll*hs[l-1]*pw[r-l+1])%mod+mod)%mod;\n}\nll l,r;\nvoid nxtstr()\n{\n\tiniths();\n\tint len=0;\n\tfor(int i=n/2-1;i>=1;i--)\n\t{\n\t\tif(calchs(1,i)==calchs(n-i+1,n))\n\t\t{\n\t\t\tlen=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint nn=n-len;\n\tn=nn+nn;\n\tfor(int i=1;i<=nn+nn;i++)s[i]=s[(i-1)%nn+1];\n}\nll ans[26];\nint pre[800111][26];\nll dp[200],dpcnt[200][26];\nbool type;\nvoid calc(int lv,ll x,int coef)\n{\n\tif(type)\n\t{\n//\t\tcout<<\"calc:\"<<lv<<\" \"<<x<<endl;\n\t\tif(lv<=1)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[x][i];\n\t\t\treturn;\n\t\t}\n\t\tll t=dp[lv]/2;\n\t\tif(x<=t)calc(lv-1,x,coef);\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*(dpcnt[lv][i]/2);\n\t\t\tcalc(lv-1,x-t,coef);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(x<=n)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=coef*pre[x][i];\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)ans[i]+=1ll*coef*pre[n][i]*(x/n);\n\t\t\tcalc(lv,x%n,coef);\n\t\t}\n\t}\n}\nint main()\n{\n\tsrand(time(NULL));\n\tbs=rand()+1000;\n\tpw[0]=1;\n\tfor(int i=1;i<=800011;i++)pw[i]=1ll*pw[i-1]*bs%mod;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tint n1=n;\n\tnxtstr();\n\tint n2=n;\n\tnxtstr();\n\tint n3=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t{\n\t\t\tpre[i][j]=pre[i-1][j]+(s[i]=='a'+j);\n\t\t}\n\t}\n\tif(n3-n2==n2-n1)type=0;\n\telse type=1;\n//\tcout<<n<<endl;\n//\tfor(int i=1;i<=n;i++)cout<<s[i];cout<<endl;\n\tdp[0]=n1;\n\tdp[1]=n2;\n\tdp[2]=n3;\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tdpcnt[0][i]=pre[n1][i];\n\t\tdpcnt[1][i]=pre[n2][i];\n\t\tdpcnt[2][i]=pre[n3][i];\n\t}\n\tint mx=0;\n\tif(type)\n\t{\n\t\tfor(int i=3;i<200;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+dp[i-2];\n//\t\t\tcout<<i<<\" \"<<dp[i]<<endl;\n\t\t\tmemset(ans,0,sizeof(ans));\n\t\t\tcalc(i-1,dp[i]/2,2);\n\t\t\tfor(int j=0;j<26;j++)dpcnt[i][j]=ans[j];\n//\t\t\tcout<<ans[j]<<\" \";cout<<endl;\n\t\t\tif(dp[i]>1ll*mod*mod)\n\t\t\t{\n\t\t\t\tmx=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(mx!=0);\n\t}\n\tmemset(ans,0,sizeof(ans));\n\tgetii(l,r);\n\tcalc(mx,r,1);\n\tcalc(mx,l-1,-1);\n\tfor(int i=0;i<26;i++)cout<<ans[i]<<\" \";cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nlong all[30];\nstring f(const string s)\n{\n\tint cnt = s.size() / 2;\n\tfor(;cnt < s.size(); ++cnt)\n\t{\n\t\tstring curs = s.substr(0,cnt);\n\t\tstring curs2 = s.substr(cnt + 1);\n\t\tif(curs.find(curs2)!= string::npos)\n\t\t{\n\t\t\treturn curs + curs;\n\t\t}\n\t}\n\treturn s + s;\n}\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tif(s.size() % 2 == 0 && s.substr(0,s.size() / 2) == s.substr(s.size() / 2 + 1))\n\t{\n\t\tstring cur_s = f(s);\n\t\tfor(int i = 0;i < cur_s.size(); ++i)\n\t\t{\n\t\t\tall[cur_s[i] - 'a']++;\n\t\t}\n\t\tfor(int i = 0;i < 26; ++i)\n\t\t{\n\t\t\tcout<<all[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nconst int N = 2e+5+5;\n\nint n;\nchar s[N*2];\nLL l,r;\nLL cnt[30],ans[30];\nint nxt[N*2];\n\nvoid prepare(){\n\tfo(i,1,n)nxt[i]=0;\n\tint w=0;\n\tfo(i,2,n){\n\t\tif (w+nxt[w]-1>=i)nxt[i]=min(nxt[i-w+1],w+nxt[w]-i);\n\t\twhile(i+nxt[i]<=n&&s[i+nxt[i]]==s[nxt[i]+1])nxt[i]++;\n\t\tif (i+nxt[i]-1>=w+nxt[w]-1)w=i;\n\t}\n}\n\nvoid trs(){\n\tprepare();\n\tfo(i,n/2+2,n)\n\tif(i+nxt[i]-1==n){n=i-1;break;}\n}\n\nstruct number{\n\tLL x,y,val;\n\tnumber(const LL x_=0,const LL y_=0,const LL val_=0){x=x_;y=y_;val=val_;}\n}a[100];\nnumber operator + (number a,number b){return number(a.x+b.x,a.y+b.y,a.val+b.val);}\n\nint key,k;\n\nvoid add(LL lim){\n\tif (lim<=n){\n\t\tfo(i,1,lim)cnt[s[i]-'a']++;\n\t\treturn;\n\t}\n\tint w;\n\tfd(i,key,1)\n\tif(lim>=a[i].val){w=i;break;}\n\tfo(i,1,n)cnt[s[i]-'a']+=a[w].x;\n\tfo(i,1,k)cnt[s[i]-'a']+=a[w].y;\n\tadd(lim-a[w].val);\n}\n\nvoid solve(LL lim){\n\tfo(i,0,25)cnt[i]=0;\n\tk=n;\n\tfo(i,1,n)\n\tif (i+nxt[i]-1==n){k=i-1;break;}\n\tif (n%k==0){\n\t\tLL tim=lim/k;\n\t\tfo(i,1,k)cnt[s[i]-'a']+=tim;\n\t\tfo(i,1,lim%k)cnt[s[i]-'a']++;\n\t}\n\telse{\n\t\ta[0]=number(0,1,k);\n\t\ta[1]=number(1,0,n);\n\t\tkey=0;\n\t\tfo(i,2,100){\n\t\t\ta[i]=a[i-1]+a[i-2];\n\t\t\tif (a[i].val>lim){key=i-1;break;}\n\t\t}\n\t\tadd(lim);\n\t}\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%lld%lld\",&l,&r);\n\ttrs();\n\tprepare();\n\tsolve(r);\n\tfo(i,0,25)ans[i]=cnt[i];\n\tsolve(l-1);\n\tfo(i,0,25)ans[i]-=cnt[i];\n\tfo(i,0,25)printf(\"%lld \",ans[i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.11.2019 02:41:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> kmp_table(int n, const T &s) {\n  vector<int> p(n, 0);\n  int k = 0;\n  for (int i = 1; i < n; i++) {\n    while (k > 0 && !(s[i] == s[k])) {\n      k = p[k - 1];\n    }\n    if (s[i] == s[k]) {\n      k++;\n    }\n    p[i] = k;\n  }\n  return p;\n}\n\ntemplate <typename T>\nvector<int> kmp_table(const T &s) {\n  return kmp_table((int) s.size(), s);\n}\n\ntemplate <typename T>\nvector<int> kmp_search(int n, const T &s, int m, const T &w, const vector<int> &p) {\n  assert(n >= 1 && (int) p.size() == n);\n  vector<int> res;\n  int k = 0;\n  for (int i = 0; i < m; i++) {\n    while (k > 0 && (k == n || !(w[i] == s[k]))) {\n      k = p[k - 1];\n    }\n    if (w[i] == s[k]) {\n      k++;\n    }\n    if (k == n) {\n      res.push_back(i - n + 1);\n    }\n  }\n  return res;\n  // returns 0-indexed positions of occurrences of s in w\n}\n\ntemplate <typename T>\nvector<int> kmp_search(const T &s, const T &w, const vector<int> &p) {\n  return kmp_search((int) s.size(), s, (int) w.size(), w, p);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  if (s.size() == 1) s += s;\n  long long L, R;\n  cin >> L >> R;\n  vector<int> pers;\n  vector<string> sss(1, s);\n  while (true) {\n    vector<int> p = kmp_table(s);\n    int n = (int) s.size();\n    int x = p[n - 1];\n    while (x >= n / 2) {\n      x = p[x - 1];\n    }\n    s += s.substr(x, n - 2 * x);\n    pers.push_back(n - x);\n    debug(s, pers);\n    sss.push_back(s);\n    if (pers.size() == 5) break;\n  }\n  string A = sss[3];\n  string B = sss[4];\n  vector<long long> len(2);\n  vector<vector<long long>> cnt(2, vector<long long>(26));\n  for (char c : A) {\n    len[0] += 1;\n    cnt[0][c - 'a'] += 1;\n  }\n  for (char c : B) {\n    len[1] += 1;\n    cnt[1][c - 'a'] += 1;\n  }\n  while (len.back() < R) {\n    len.push_back(len.back() + len[len.size() - 2]);\n    cnt.emplace_back(26, 0);\n    for (int i = 0; i < 26; i++) cnt.back()[i] = cnt[cnt.size() - 3][i] + cnt[cnt.size() - 2][i];\n  }\n  vector<long long> res(26);\n  function<void(long long, long long)> Fun = [&](long long L, long long R) {\n    int id = 0;\n    while (len[id] < R) {\n      ++id;\n    }\n    if (id == 0) {\n      for (int i = L; i <= R; i++) res[A[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (id == 1) {\n      for (int i = L; i <= R; i++) res[B[i - 1] - 'a'] += 1;\n      return;\n    }\n    if (L == 1 && R == len[id]) {\n      for (int i = 0; i < 26; i++) res[i] += cnt[id][i];\n      return;\n    }\n    if (L > len[id - 1]) {\n      Fun(L - len[id - 1], R - len[id - 1]);\n    } else {\n      Fun(L, len[id - 1]);\n      Fun(1, R - len[id - 1]);\n    }\n  };\n  Fun(L, R);\n  for (int i = 0; i < 26; i++) cout << res[i] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n\n//#define DEBUG 1\n\n#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define vec(x) vector< x >\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define sqr(x) 1LL*(x)*(x)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define debug\n#endif\n\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nint suffix[200005];\n\nint find_suffix(string s)\n{\n    //find length of longest suffix of s that is also a prefix of s\n    suffix[0] = suffix[1] = 0;\n    for (int i=2; i<=s.length(); i++) {\n        int j = suffix[i-1];\n        while (true) {\n            if (s[j] == s[i-1]) {\n                suffix[i] = j+1;\n                break;\n            }\n            else if (j == 0) {\n                suffix[i] = 0;\n                break;\n            }\n            j = suffix[j];\n        }\n    }\n    //printa(suffix,s.length()+1);\n    return suffix[s.length()];\n}\n\nvector<ll> count_chars(string s)\n{\n    vector<ll> ret(26,0);\n    iter(s)\n        ret[*it-'a']++;\n    return ret;\n}\n\nvector<ll> query(vector<vector<ll>> & chr_cnt, vector<ll> & lens, string g1, ll r)\n{\n    vector<ll> ret(26,0);\n    if (r <= 0)\n        return ret;\n\n    int lv = sz(lens)-1;\n    while (lv > 0) {\n        if (lens[lv-1] <= r) {\n            r -= lens[lv-1];\n            for0(i,26) {\n                ret[i] += chr_cnt[lv-1][i];\n            }\n        }\n        lv--;\n    }\n    //prl(r)\n    assert(r <= g1.length());\n\n    for (int i=0; r>0 && i<g1.length(); i++,r--) {\n        ret[g1[i]-'a']++;\n    }\n    return ret;\n}\n\nvoid solve(string g1, string g2, ll l, ll r)\n{\n    vector<vector<ll>> chr_cnt;\n    vector<ll> lens;\n    chr_cnt.pb(count_chars(g1));\n    chr_cnt.pb(count_chars(g2));\n    lens.pb(g1.length());\n    lens.pb(g2.length());\n\n    while (lens.back() < r) {\n        vector<ll> next_cnt(26,0);\n        for0(i,26) {\n            next_cnt[i] = chr_cnt[sz(chr_cnt)-1][i] + chr_cnt[sz(chr_cnt)-2][i];\n        }\n        chr_cnt.pb(next_cnt);\n        lens.pb(lens[sz(lens)-1] + lens[sz(lens)-2]);\n    }\n\n    vector<ll> r_cnt = query(chr_cnt, lens, g1, r);\n    vector<ll> l_cnt = query(chr_cnt, lens, g1, l-1);\n    for0(i,26) {\n        cout<<r_cnt[i]-l_cnt[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nint32_t main()\n{\n    #ifdef DEBUG\n    freopen(\"D.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    string s;\n    cin >> s;\n    s = s.substr(0,s.length()/2);\n    long long l,r;\n    cin >> l >> r;\n\n    int suf_len = find_suffix(s);\n    string T = s.substr(0,s.length()-suf_len);\n    string g1 = s+T;\n    string g2 = s+T+s;\n    solve(g1, g2, l, r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nvector<int> z_algo(const string& S) {\n\tvector<int> A(sz(S));\n\tA[0] = S.size();\n\tint i = 1, j = 0;\n\twhile (i < S.size()) {\n\t\twhile (i + j < S.size() && S[j] == S[i + j]) ++j;\n\t\tA[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < S.size() && k + A[k] < j) A[i + k] = A[k], ++k;\n\t\ti += k; j -= k;\n\t}\n\n\treturn A;\n}\n\nll cnt[2 * ten(5) + 10];\n\nvoid solve(ll a0, ll a1, ll r, vector<ll>& ret) {\n\tvector<ll> fib = { a0, a1 };\n\twhile (fib.back() < r) {\n\t\tll nxt = fib[sz(fib) - 1] + fib[sz(fib) - 2];\n\t\tfib.push_back(nxt);\n\t}\n\n\tmap<ll, ll> mp;\n\tmp[r]++;\n\twhile (true) {\n\t\tll idx, cnt; tie(idx, cnt) = *mp.rbegin();\n\t\tif (idx <= a0) break;\n\t\tmp.erase(prev(mp.end()));\n\n\t\tint fib_i = lower_bound(fib.begin(), fib.end(), idx) - fib.begin();\n\t\tfib_i--;\n\n\t\tmp[fib[fib_i]] += cnt;\n\t\tmp[idx - fib[fib_i]] += cnt;\n\t}\n\n\tret.resize((int)a0 + 1);\n\tfor (auto kv : mp) {\n\t\tret[(int)kv.first] += kv.second;\n\t}\n\tfor (int i = a0; i > 0; i--) ret[i - 1] += ret[i];\n}\n\nint main() {\n\tstring s; reader(s);\n\tstring o = s;\n\tvector<int> len;\n\tFOR(i,4) {\n\t\tlen.push_back(sz(s) / 2);\n\t\t//printf(\"%d : \", sz(s) / 2);\n\t\t//cout << s.substr(sz(s) / 2) << endl;\n\n\t\tauto len = z_algo(s);\n\t\tfor (int j = sz(s) / 2 + 1; j <= sz(s); j++) {\n\t\t\tbool ok = true;\n\t\t\tif (j != sz(s)) {\n\t\t\t\tif (len[j] + j != sz(s)) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tstring t;\n\t\t\t\tt = s.substr(0, j);\n\t\t\t\tt = t + t;\n\t\t\t\ts = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tll l, r; reader(l, r);\n\tl--;\n\tif (len[2] == len[1] + len[0] && len[3] == len[2] + len[1]) {\n\t\tvector<ll> ret1;\n\t\tsolve(len[0], len[1], r, ret1);\n\t\tvector<ll> ret2;\n\t\tsolve(len[0], len[1], l, ret2);\n\n\t\tFOR(i, sz(ret1) - 1) {\n\t\t\tcnt[i] = ret1[i + 1] - ret2[i + 1];\n\t\t}\n\t} else {\n\t\tint diff = len[1] - len[0];\n\t\tFOR(i, sz(o)) {\n\t\t\tcnt[i] += r / sz(o);\n\t\t\tif (i < r % sz(o)) cnt[i]++;\n\t\t\tcnt[i] -= l / sz(o);\n\t\t\tif (i < l % sz(o)) cnt[i]--;\n\t\t}\n\t}\n\n\tvector<ll> ans(26);\n\tFOR(i, sz(o)) {\n\t\tans[o[i] - 'a'] += cnt[i];\n\t}\n\twriterArr(ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len; \nstring s;\nint cnt[maxn][maxm],z[maxn]; \nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-L]<=r-i)z[i]=z[i-L];\n\t\t\telse{\n\t\t\t\tz[i]=R-i;\n\t\t\t\tfor(int j=R-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tREP(i,n-1)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==0){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\nconst ll MOD = 1e9 + 7;\nconst ll P = 2413;\n\nstring S, T;\nll phash[MAXN];\nll pmult[MAXN];\nll sz[100];\nll cc[100][26];\n\nstring get_nv ()\n{\n    int N = S.length();\n    phash[0] = 0;\n    pmult[0] = 1;\n    for (int i = 0; i < N; i++)\n    {\n        phash[i+1] = (phash[i] * P + S[i]) % MOD;\n        pmult[i+1] = (pmult[i] * P) % MOD;\n    }\n\n    for (int i = N + 2; ; i += 2)\n    {\n        int cchunk = i / 2;\n        ll lhs = phash[N-cchunk];\n        ll rhs = phash[N] - phash[cchunk] * pmult[N-cchunk];\n        if ((lhs - rhs) % MOD == 0)\n        {\n            return S + S.substr(N - cchunk, i - N);\n        }\n    }\n}\n\nvector <ll> gogo (ll x)\n{\n    if (x < sz[0])\n    {\n        vector <ll> res;\n        for (int i = 0; i < 26; i++)\n            res.push_back(0);\n\n        for (int i = 0; i < x; i++)\n            res[S[i]-'a']++;\n        return res;\n    }\n\n    int chi = 0;\n    while (x >= sz[chi+1])\n        chi++;\n\n    vector <ll> res;\n    for (int i = 0; i < 26; i++)\n        res.push_back(cc[chi][i]);\n\n    vector <ll> nleft = gogo (x - sz[chi]);\n    for (int i = 0; i < 26; i++)\n        res[i] += nleft[i];\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> S;\n    T = get_nv ();\n\n    //cout << T << \"\\n\";\n\n    sz[0] = S.length() / 2;\n    for (int i = 0; i < S.length() / 2; i++)\n    {\n        int nv = S[i] - 'a';\n        cc[0][nv]++;\n    }\n    sz[1] = T.length() / 2;\n    for (int i = 0; i < T.length() / 2; i++)\n    {\n        int nv = T[i] - 'a';\n        cc[1][nv]++;\n    }\n    \n    int chi = 2;\n    while (true)\n    {\n        sz[chi] = sz[chi-1] + sz[chi-2];\n        for (int i = 0; i < 26; i++)\n        {\n            cc[chi][i] = cc[chi-1][i] + cc[chi-2][i];\n        }\n\n        if (sz[chi] > 2e18)\n            break;\n        chi++;\n    }\n\n    ll L, R;\n    cin >> L >> R;\n    vector <ll> res1 = gogo (R), res2 = gogo (L - 1);\n    for (int i = 0; i < 26; i++)\n        res1[i] -= res2[i];\n\n    for (int i = 0; i < 26; i++)\n    {\n        if (i) cout << \" \";\n        cout << res1[i];\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//#define ONLINE_JUDGE\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y){ return y > x ? x = y, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &x, const T &y){ return y < x ? x = y, 1 : 0; }\n\n#ifdef ONLINE_JUDGE\n#define debug(...) ;\n#else\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define DEBUG\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 4e5 + 100;\n\nint n, m;\nchar s[maxn], t[maxn];\nLL cnt[maxn][26], cnt2[maxn][26];\nLL l, r;\nLL ans[26];\nint border[maxn];\n\nvoid KMP()\n{\n\tborder[0] = -1;\n\tforn(i, 1, n)\n\t{\n\t\tt[++m] = s[i];\n\t\tint j = border[i - 1];\n\t\twhile(~j && s[j + 1] != s[i]) j = border[j];\n\t\tborder[i] = j + 1;\n\t}\n\tint l = border[n / 2];\n\tforn(i, l + 1, n - l) t[++m] = s[i];\n\treturn;\n}\n\nvoid Q(LL N, int opr)\n{\n\tif(!N) return;\n\tstatic vl fib; fib.clear();\n\tfib.pb(n / 2); fib.pb(m / 2);\n\tif(N <= (LL)m / 2)\n\t{\n\t\trep(i, 26) ans[i] += 1ll * opr * cnt2[N][i];\n\t\treturn;\n\t}\n\twhile(fib.back() <= N) fib.pb(fib.back() + fib[SZ(fib) - 2]);\n\tstatic LL A[26], B[26], C[26];\n\tmemcpy(A, cnt[n / 2], sizeof(cnt[n / 2]));\n\tmemcpy(B, cnt2[m / 2], sizeof(cnt2[m / 2]));\n\tforn(i, 2, SZ(fib) - 2)\n\t{\n\t\tmemset(C, 0, sizeof C);\n\t\trep(j, 26) C[j] = A[j] + B[j];\n\t\tmemcpy(A, B, sizeof A);\n\t\tmemcpy(B, C, sizeof B);\n\t}\n\trep(i, 26) ans[i] += 1ll * opr * B[i];\n\tQ(N - fib[SZ(fib) - 2], opr);\n\treturn;\n}\n\nvoid fQ(LL N, int opr)\n{\n\tif(!N) return;\n\tstatic vl fib; fib.clear();\n\tfib.pb(n); fib.pb(m);\n\tif(N <= (LL)m)\n\t{\n\t\trep(i, 26) ans[i] += 1ll * opr * cnt2[N][i];\n\t\treturn;\n\t}\n\twhile(fib.back() <= N) fib.pb(fib.back() + fib[SZ(fib) - 2]);\n\tstatic LL A[26], B[26], C[26];\n\tmemcpy(A, cnt[n], sizeof(cnt[n]));\n\tmemcpy(B, cnt2[m], sizeof(cnt2[m]));\n\tforn(i, 2, SZ(fib) - 2)\n\t{\n\t\tmemset(C, 0, sizeof C);\n\t\trep(j, 26) C[j] = A[j] + B[j];\n\t\tmemcpy(A, B, sizeof A);\n\t\tmemcpy(B, C, sizeof B);\n\t}\n\trep(i, 26) ans[i] += 1ll * opr * B[i];\n#ifdef DEBUG\n\trep(i, 26) printf(\"%lld \", ans[i]); puts(\"\");\n#endif\n\tQ(N - fib[SZ(fib) - 2], opr);\n\treturn;\n}\n\nint main()\n{\n\tscanf(\"%s\", s + 1); scf(l, r); n = strlen(s + 1);\n\tforn(i, 1, n) cnt[i][s[i] - 'a'] = 1;\n\tforn(i, 1, n) rep(j, 26) cnt[i][j] += cnt[i - 1][j];\n\tKMP();\n\tforn(i, 1, m) cnt2[i][t[i] - 'a'] = 1;\n\tforn(i, 1, m) rep(j, 26) cnt2[i][j] += cnt2[i - 1][j];\n\tQ(r, 1);\n\tQ(l - 1, -1);\n\trep(i, 26) printf(\"%lld \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long n, l, r, a[26], hash1[200009], hash2[200009], mod = 1000000007, leng; string S; vector<long long>X;\n\nlong long repeated(string V) {\n\tfor (int i = 1; i < n / 2; i++) {\n\t\tif (n%i > 0) continue;\n\t\tstring W = V.substr(0, i); bool flag = false;\n\t\tfor (int j = 0; j < n; j += i) {\n\t\t\tstring WW = V.substr(j, j + i);\n\t\t\tif (W != WW) { flag = true; break; }\n\t\t}\n\t\tif (flag == true) return i;\n\t}\n\treturn -1;\n}\n\nstring naive_solve(string T) {\n\tfor (int i = 0; i <= T.size(); i++) { hash1[i] = 0; hash2[i] = 0; }\n\tlong long U = 1;\n\tfor (int i = 0; i < T.size(); i++) { hash1[i + 1] = hash1[i] + 1LL * U*(long long)(T[i] - 'a'); hash1[i + 1] %= mod; U *= 26; U %= mod; }\n\tfor (int i = T.size() - 1; i >= 0; i--) { hash2[i] = hash2[i + 1] * 26LL + (long long)(T[i] - 'a'); hash2[i] %= mod; }\n\tfor (int i = T.size() / 2 - 1; i >= 0; i--) {\n\t\tif (hash1[i] == hash2[T.size() - i]) return T.substr(0, T.size() - i) + T.substr(0, T.size() - i);\n\t}\n\treturn \"\";\n}\nchar get_s(long long pos) {\n\tif (pos < S.size()) return S[pos];\n\tint pos1 = upper_bound(X.begin(), X.end(), pos) - X.begin(); pos1--;\n\treturn get_s(pos - X[pos1]);\n}\nlong long solve() {\n\tstring I1 = S.substr(0, n);\n\tstring I2 = \"\";\n\tfor (int i = leng - n; i < leng; i++) I2 += get_s(i);\n\tfor (int i = 0; i <= n; i++) { hash1[i] = 0; hash2[i] = 0; }\n\tlong long U = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\thash1[i + 1] = hash1[i] + 1LL * U*(long long)(I1[i] - 'a'); hash1[i + 1] %= mod;\n\t\tU *= 26; U %= mod;\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\thash2[i] = hash2[i + 1] * 26LL + (long long)(I2[i] - 'a'); hash2[i] %= mod;\n\t}\n\tfor (int i = n; i >= 0; i--) {\n\t\tif (hash1[i] == hash2[n - i]) return leng - n;\n\t}\n\treturn -1;\n}\n\nlong long p[200009], q[200009];\n\nvoid solve_last(vector<long long>XX) {\n\tp[XX.size() - 1] = 1;\n\tfor (int i = XX.size() - 1; i >= 0; i--) {\n\t\tlong long cx = XX[i];\n\t\twhile (true) {\n\t\t\tlong long pos1 = upper_bound(XX.begin(), XX.end(), cx) - XX.begin(); pos1--;\n\t\t\tif (pos1 >= 0 && XX[pos1] == cx) pos1--;\n\t\t\tif (pos1 < 0) break;\n\t\t\tlong long I = cx / XX[pos1];\n\t\t\tp[pos1] += I*p[i];\n\t\t\tcx -= I*XX[pos1];\n\t\t}\n\t\tq[n] += (cx / n)*p[i];\n\t\tq[cx%n] += p[i];\n\t}\n\tfor (int i = n; i >= 1; i--) q[i] += q[i + 1];\n}\nvector<long long> solve_last2(long long lim) {\n\tfor (int i = 0; i < 200009; i++) { p[i] = 0; q[i] = 0; }\n\tvector<long long>X2;\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (X[i] < lim)X2.push_back(X[i]);\n\t}\n\tsolve_last(X2);\n\tvector<long long>X3(26, 0);\n\tfor (int i = 1; i <= n; i++) X3[S[i - 1] - 'a'] += q[i];\n\treturn X3;\n}\n\nint main() {\n\tcin >> S >> l >> r; n = S.size();\n\tlong long R = repeated(S);\n\tif (R != -1) {\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tlong long I = (n - i + (R - 1)) / R;\n\t\t\ta[S[i] - 'a'] += I;\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) cout << a[i] << endl;\n\t\treturn 0;\n\t}\n\tleng = n;\n\twhile (S.size() < 10000000) {\n\t\tX.push_back(leng);\n\t\tS = naive_solve(S);\n\t\tleng = S.size();\n\t}\n\tX.push_back(leng);\n\twhile (leng < r) {\n\t\tlong long E = solve();\n\t\tleng = E * 2;\n\t\tX.push_back(leng);\n\t}\n\tvector<long long>R1 = solve_last2(l - 1);\n\tvector<long long>R2 = solve_last2(r - 1);\n\tfor (int i = 0; i < 26; i++) cout << R2[i] - R1[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 500006\nusing namespace std;\nchar s[N];long long f[106],g[106][26],a[26],l,r,x;\nlong long n,p,t,v[26],height[N],sa[N],fuckyouatcoder[N],tsa[N],cntA[N],cntB[N],A[N],B[N];\nvoid SA()\n{\n\tfor(long long i=1;i<=n;i++)cntA[(long long)s[i]]++;\n\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1];\n\tfor(long long i=n;i;i--)sa[cntA[(long long)s[i]]--]=i;\n\tfuckyouatcoder[sa[1]]=1;\n\tfor(long long i=2;i<=n;i++){\n\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\tif(s[sa[i]]!=s[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t}\n\tfor(long long l=1;fuckyouatcoder[sa[n]]!=n;l<<=1){\n\t\tfor(long long i=0;i<N;i++)cntA[i]=cntB[i]=0;\n\t\tfor(long long i=1;i<=n;i++){\n\t\t\tcntA[A[i]=fuckyouatcoder[i]]++;\n\t\t\tcntB[B[i]=(i+l<=n?fuckyouatcoder[i+l]:0)]++;\n\t\t}\n\t\tfor(long long i=1;i<N;i++)cntA[i]+=cntA[i-1],cntB[i]+=cntB[i-1];\n\t\tfor(long long i=n;i;i--)tsa[cntB[B[i]]--]=i;\n\t\tfor(long long i=n;i;i--)sa[cntA[A[tsa[i]]]--]=tsa[i];\n\t\tfuckyouatcoder[sa[1]]=1;\n\t\tfor(long long i=2;i<=n;i++){\n\t\t\tfuckyouatcoder[sa[i]]=fuckyouatcoder[sa[i-1]];\n\t\t\tif(A[sa[i]]!=A[sa[i-1]]||B[sa[i]]!=B[sa[i-1]])fuckyouatcoder[sa[i]]++;\n\t\t}\n\t}\n\tlong long tot=0;\n\tfor(long long i=1;i<=n;i++){\n\t\tif(tot)tot--;\n\t\twhile(s[i+tot]==s[sa[fuckyouatcoder[i]-1]+tot])tot++;\n\t\theight[fuckyouatcoder[i]]=tot;\n\t}\n\tp=n;long long mi=N;\n\tfor(long long i=fuckyouatcoder[1];i>=2;i--){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i-1]+1)p=min(p,sa[i-1]-1);\n\t}mi=N;\n\tfor(long long i=fuckyouatcoder[1]+1;i<=n;i++){\n\t\tmi=min(mi,height[i]);\n\t\tif(mi==n-sa[i]+1)p=min(p,sa[i]-1);\n\t}\n}\nvoid wk(long long w,long long F)\n{\n\tif(x==0)return;\n\tif(f[w]>x)\n\t\tif(w>2){wk(w-1,F);if(x)wk(w-2,F);}\n\t\telse{for(long long i=1;i<=x;i++)a[s[i]-97]+=F;x=0;}\n\telse{for(long long i=0;i<26;i++)a[i]+=F*g[w][i];x-=f[w];}\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;scanf(\"%lld%lld\",&l,&r);SA();\n\tfor(long long i=1;i<=p;i++)v[s[i]-97]++;\n\tif(n%p==0){\n\t\tif(r<=n)for(long long i=l;i<=r;i++)a[s[i]-97]++;\n\t\telse{\n\t\t\tif(l<=n)for(long long i=l;i<=n;i++)a[s[i]-97]++;\n\t\t\telse for(long long i=(l-n-1)%p+1;i<=p;i++)a[s[i]-97]++;\n\t\t\tr-=n;for(long long i=1;i<=(r-1)%p+1;i++)a[s[i]-97]++;\n\t\t\tfor(long long i=0;i<26;i++)a[i]+=1LL*v[i]*((r-1)/p-(l<=n?0:(l-n-1)/p+1));\n\t\t}\n\t}else{\n\t\tf[1]=n;f[2]=n+p;\n\t\tfor(long long i=1;i<=n;i++)g[1][s[i]-97]=++g[2][s[i]-97];\n\t\tfor(long long i=0;i<26;i++)g[2][i]+=v[i];\n\t\tfor(t=3;f[t-1]<r;t++){\n\t\t\tf[t]=f[t-1]+f[t-2];\n\t\t\tfor(long long i=0;i<26;i++)g[t][i]+=g[t-1][i]+g[t-2][i];\n\t\t}t--;\n\t\tx=r;wk(t,1);if(l>1)x=l-1,wk(t,-1);\n\t}\n\tfor(long long i=0;i<25;i++)printf(\"%lld \",a[i]);printf(\"%lld\\n\",a[25]);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nstring trans(string s) {\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s.substr(0, i) == s.substr(s.size() - i, i)) {\n            string b = s.substr(0, s.size() - i);\n            return s + b;\n        }\n    }\n    assert(false);\n    return \"\";\n}\nvoid stupid() {\n    while (true) {\n        string s;\n        int p = rand() % 7 + 2;\n        for (int i = 0; i < p; i++) {\n            s += (char) (rand() % 2 + 'a');\n        }\n        string ns = trans(s);\n        int blen = ns.size() - s.size();\n        int slen = s.size() - blen;\n//        if (blen <= slen) continue;\n        bool f1 = (slen == 0);\n        bool f2 = (s.size() % blen == 0);//(blen <= slen);\n        if (blen <= slen && !f2) {\n            s = ns;\n            ns = trans(s);\n            blen = ns.size() - s.size();\n            slen = s.size() - blen;\n            assert(blen > slen);\n        }\n        string init = s;\n        s = ns;\n        for (int step = 0; step < 10; step++) {\n            string ns = trans(s);\n            int hisb = ns.size() - s.size();\n            int hiss = s.size() - hisb;\n            if (f1) {\n                assert(hisb == blen);\n            }\n            else if (f2) {\n                assert(hisb == blen);\n            }\n            else {\n//            if (hiss != blen) {\n//                cout << init << \" GG \" << s << \" \" << ns << \" \" << hiss << \" \" << blen << endl;\n//            }\n                assert(hiss == blen);\n            }\n            blen = hisb;\n            slen = hiss;\n//            cout << s << \" -> \" << ns << endl;\n            s = ns;\n        }\n    }\n}\nstring s;\nll l, r;\nvector < int > z_function(string& s) {\n    vector < int > z(s.size());\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < s.size(); i++) {\n        if (r < i) {\n            l = r = i;\n        }\n        z[i] = min(r - i, z[i - l]);\n        while (i + z[i] < s.size() && s[z[i]] == s[i + z[i]]) z[i]++;\n        if (i + z[i] > r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\nll ans[26];\nll len[100];\nll lenB[100];\nll lenS[100];\nconst ll INF = 1e18 + 2;\nconst int maxN = 2e5 + 10;\nint pref[26][maxN];\nint prefS[26][maxN];\nll calcB(ll r, int c, int who);\nll calcS(ll r, int c, int who);\nll calc(ll r, int c, int who);\nmap < pair < pair < ll, int >, int >, ll > mp, mpB, mpS;\nll calc(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mp.find({{r, c}, who}) != mp.end()) return mp[{{r, c}, who}];\n    ll& d = mp[{{r, c}, who}];\n    if (r <= lenB[who]) {\n        return d = calc(r, c, who - 1);\n    }\n    return d = calc(lenB[who] - 1, c, who - 1) + calcB(r - lenB[who], c, who - 1);\n}\nll calcB(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpB.find({{r, c}, who}) != mpB.end()) return mpB[{{r, c}, who}];\n    ll& d = mpB[{{r, c}, who}];\n    if (r <= lenB[who]) {\n        return d = calcB(r, c, who - 1);\n    }\n    return d = calcB(lenB[who] - 1, c, who - 1) + calcS(r - lenB[who], c, who - 1);\n}\nll calcS(ll r, int c, int who) {\n    if (who == 0) return pref[c][r];\n    if (mpS.find({{r, c}, who}) != mpS.end()) return mpS[{{r, c}, who}];\n    ll& d = mpS[{{r, c}, who}];\n    return d = calcB(r, c, who - 1);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> s;\n    s = s.substr(0, s.size() / 2);\n    cin >> l >> r;\n    l--;\n    r--;\n    auto zz = z_function(s);\n    int n = s.size();\n    int blen = 0;\n    int slen = 0;\n    for (int i = 1; i < n; i++) {\n        if (zz[i] == n - i) {\n            blen = i;\n            slen = n - i;\n            break;\n        }\n    }\n    if (blen == 0 && slen == 0) {\n        blen = n;\n    }\n    if (n % blen == 0) {\n        string f = s.substr(0, blen);\n        for (int i = 0; i < f.size(); i++) {\n            // blen * k + i >= l\n            // blen * k + i <= r\n            ll at_least = max(0LL, (l - i + blen - 1) / blen);\n            ll at_most = (i > r ? -1 : (r - i) / blen);\n            ans[f[i] - 'a'] += at_most - at_least + 1;\n        }\n        for (int i = 0; i < 26; i++) cout << ans[i] << \" \";\n    }\n    else {\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < n; i++) {\n                pref[j][i] = ((s[i] - 'a') == j);\n                if (i) pref[j][i] += pref[j][i - 1];\n            }\n        }\n        string ns = s.substr(0, slen);\n        for (int j = 0; j < 26; j++) {\n            for (int i = 0; i < ns.size(); i++) {\n                prefS[j][i] = ((ns[i] - 'a') == j);\n                if (i) prefS[j][i] += prefS[j][i - 1];\n            }\n        }\n        len[0] = s.size();\n        lenB[0] = blen;\n        lenS[0] = slen;\n        int who = -1;\n        for (int i = 1; i < 100; i++) {\n            if (len[i - 1] - 1 >= r) {\n                who = i - 1;\n                break;\n            }\n            lenS[i] = lenB[i - 1];\n            lenB[i] = len[i - 1];\n            len[i] = lenB[i] + lenS[i];\n        }\n        assert(who != -1);\n        for (int i = 0; i < 26; i++) {\n            ans[i] = calc(r, i, who);\n            if (l) ans[i] -= calc(l - 1, i, who);\n            cout << ans[i] << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < B.size(); i++) {\n        fcnt[1][ B[i] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            ret[ B[i] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    A = T;\n    for(int i = 0; i < (int)T.size() - pi[T.size() - 1]; i++) A.push_back(T[i]);\n    B = A;\n    for(int i = 0; i < T.size(); i++) B.push_back(T[i]);\n\n    //cout << pi[T.size() - 1] << ' ' << T.size() << endl;\n\n    //cout << A << ' ' << B << endl;\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\n\n#define LL long long\n#define DB double\n#define MOD 1000000007\n#define MAXN 1000000\n#define INF 1000000\n#define mem(x,v) memset(x,v,sizeof(x))\n\nLL read(){\n    LL x=0,F=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*F;\n}\n\nint n,m,nxt,res;LL l,r;\nchar s[MAXN+5],t[MAXN+5];\nint f[MAXN+5],cnt[MAXN+5][30];\n\nvoid getfail(int *fail){\n    for(int i=2,j=0;i<=n;i++){\n        while(j&&t[i]!=t[j+1])j=fail[j];\n        j+=(t[i]==t[j+1]);\n        fail[i]=j;\n    }\n}\nLL getres(LL p,int c){\n    if(p<=n)return cnt[p][c];\n    LL res0=cnt[m][c],res1=cnt[n][c],L0=m,L1=n,tmp;\n    while(L0+L1<p){\n        tmp=L1,L1+=L0,L0=tmp;\n        tmp=res1,res1+=res0,res0=tmp;\n    }\n    return res1+getres(p-L1,c);\n}\n\nint main(){\n    scanf(\"%s\",t+1);l=read(),r=read();\n    n=strlen(t+1)/2;\n    getfail(f),m=n-f[n];\n    for(int c=0;c<26;c++)\n        for(int i=1;i<=n;i++)\n        cnt[i][c]=cnt[i-1][c]+(t[i]==c+'a');\n    for(int x=0;x<26;x++)\n    printf(\"%lld \",getres(r,x)-getres(l-1,x));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> KMP(const std::string &s) {\n  std::vector<int> ret(s.size() + 1);\n  ret[0] = -1;\n  int j = -1;\n  for (unsigned i = 0; i < s.size(); ++i) {\n    while (j >= 0 && s[i] != s[j]) { j = ret[j]; }\n    ++j;\n    ret[i + 1] = j;\n  }\n  ret[0] = 0;\n  return ret;\n}\n\nstd::vector<unsigned> period(const std::string &s) {\n  auto x = KMP(s);\n  std::vector<unsigned> ret(s.size());\n  for (unsigned i = 0; i < s.size(); ++i) {\n    ret[i] = i + 1 - x[i + 1];\n  }\n  return ret;\n}\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  auto lens = s.size();\n  while (s.size() > lens / 2) { s.pop_back(); }\n  unsigned long long l, r;\n  std::cin >> l >> r;\n  auto per = period(s).back();\n  if (s.size() % per == 0) {\n    std::vector<unsigned long long> cnt('z' - 'a' + 1, 0);\n    unsigned long long lq = (l - 1) / per;\n    unsigned long long lr = (l - 1) % per;\n    unsigned long long rq = r / per;\n    unsigned long long rr = r % per;\n    for (unsigned i = 0; i < per; ++i) {\n      cnt[s[i] - 'a'] += rq - lq;\n    }\n    for (unsigned i = 0; i < rr; ++i) {\n      ++cnt[s[i] - 'a'];\n    }\n    for (unsigned i = 0; i < lr; ++i) {\n      --cnt[s[i]];\n    }\n    for (unsigned i = 0; i < cnt.size(); ++i) {\n      std::cout << cnt[i] << \" \";\n    }\n    std::cout << std::endl;\n  } else {\n    std::vector<unsigned long long> len;\n    len.push_back(s.size());\n    len.push_back(s.size() + per);\n    while (len.back() < r) {\n      auto x = len[len.size() - 1];\n      auto y = len[len.size() - 2];\n      len.push_back(x + y);\n    }\n    std::vector<unsigned long long> cnt_s('z' - 'a' + 1, 0);\n    for (auto &c : s) { ++cnt_s[c - 'a']; }\n    std::vector<unsigned long long> cnt_gs('z' - 'a' + 1, 0);\n    for (unsigned i = 0; i < cnt_s.size(); ++i) { cnt_gs[i] = cnt_s[i]; }\n    for (unsigned i = 0; i < per; ++i) { ++cnt_gs[s[i] - 'a']; }\n    for (int i = 0; i <= 'z' - 'a'; ++i) {\n      std::vector<unsigned long long> cnt;\n      cnt.push_back(cnt_s[i]);\n      cnt.push_back(cnt_gs[i]);\n      for (unsigned j = 2; j < len.size(); ++j) {\n        auto x = cnt[cnt.size() - 1];\n        auto y = cnt[cnt.size() - 2];\n        cnt.push_back(x + y);\n      }\n      unsigned long long ans = 0;\n      auto rr = r;\n      for (auto j = len.size() - 1; j > 1; --j) {\n        if (len[j] > rr) { continue; }\n        rr -= len[j];\n        ans += cnt[j];\n      }\n      if (rr >= len[1]) {\n        rr -= len[1];\n        ans += cnt[1];\n        for (unsigned j = 0; j < rr; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      } else {\n        for (unsigned j = 0; j < s.size() && rr; ++j) {\n          --rr;\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n        for (unsigned j = 0; j < rr; ++j) {\n          if (s[j] - 'a' == i) { ++ans; }\n        }\n      }\n      auto ll = l - 1;\n      for (auto j = len.size() - 1; j > 1; --j) {\n        if (len[j] > ll) { continue; }\n        ll -= len[j];\n        ans -= cnt[j];\n      }\n      if (ll >= len[1]) {\n        ll -= len[1];\n        ans -= cnt[1];\n        for (unsigned j = 0; j < ll; ++j) {\n          if (s[j] - 'a' == i) { --ans; }\n        }\n      } else {\n        for (unsigned j = 0; j < s.size() && ll; ++j) {\n          --ll;\n          if (s[j] - 'a' == i) { --ans; }\n        }\n        for (unsigned j = 0; j < ll; ++j) {\n          if (s[j] - 'a' == i) { --ans; }\n        }\n      }\n      std::cout << ans << \" \";\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvi Z_Algorithm(string s){\n\tint S=s.size();\n\tvi A(S);\n\tA[0]=S;\n\tint i=1,j=0;\n\twhile(i<S){\n\t\twhile(i+j<S&&s[j]==s[i+j]) j++;\n\t\tA[i]=j;\n\t\tif(!j){\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tint k=1;\n\t\twhile(i+k<S&& k+A[k] < j){\n\t\t\tA[i+k]=A[k];\n\t\t\tk++;\n\t\t}\n\t\ti+=k;\n\t\tj-=k;\n\t}\n\treturn A;\n}\n\nint f(char c){\n\treturn c-'a';\n} \n\nstring s,t;\nll l,r,S,T;\n\nll solve(ll x,char c){\n\tif(x<=S+T){\n\t\tll res=0;\n\t\tfor(int i=0;i<min(S,x);i++) if(s[i]==c) res++;\n\t\tif(x>S){\n\t\t\tfor(int i=0;i<min(T,x-S);i++) if(t[i]==c) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tvl len(100),num(100);\n\tll res,I=2;\n\tlen[0]=S;\n\tlen[1]=S+T;\n\tfor(int i=0;i<S;i++) if(s[i]==c) num[0]++;\n\tfor(int i=0;i<T;i++) if(t[i]==c) num[1]++;\n\tnum[1]+=num[0];\n\twhile(1){\n\t\tlen[I]=len[I-1]+len[I-2];\n\t\tnum[I]=num[I-1]+num[I-2];\n\t\tif(len[I]>x){\n\t\t\tres=num[I-1]+solve(x-len[I-1],c);\n\t\t\tbreak;\n\t\t}\n\t\tI++;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>s>>l>>r;\n\tS=s.size()/2;\n\ts=s.substr(0,S);\n\tl--;\n\tint M=0;\n\tT=S;\n\tvi z=Z_Algorithm(s);\n\tfor(int i=1;i<S;i++){\n\t\tif(z[i]==S-i){\n\t\t\tM=z[i];\n\t\t\tT=i;\n\t\t}\n\t}\n\tt=s.substr(0,T);\n\tif(S%T==0){\n\t\tvl a(26);\n\t\tfor(int i=l;i<S;i++) a[f(s[i])]++;\n\t\tfor(int i=0;i<T;i++) a[f(t[i])]+=(r<=S?0:(r-S)/T);\n\t\tfor(int i=0;i<(r-S)%T;i++) a[f(t[i])]++;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<a[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\telse{\n\t\tcout<<'A'<<endl;\n/*\t\tchar c='a';\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(i) cout<<' ';\n\t\t\tcout<<solve(r,c)-solve(l,c++);\n\t\t}\n\t\tcout<<endl;*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n// z-algorithm : a[i] = s[0,n) と s[i,n) の最長共通接頭辞の長さ O(N)\nvector<int> zAlgorithm(const string &s){\n  int n = s.size();\n  vector<int> a(n+1,0);\n  int i=1, j=0;\n  while(i<n){\n    while(i+j<n && s[j] == s[i+j]) j++;\n    a[i] = j;\n    if(j==0){i++; continue;}\n    int k = 1;\n    while(i+k<n && k+a[k]<j) a[i+k]=a[k], k++;\n    i += k;\n    j -= k;\n  }\n  return a;\n}\n\nint main(){\n  string s;\n  cin>>s;\n  s = s.substr(0,s.size()/2);\n  long l,r;\n  cin>>l>>r;\n\n  auto z = zAlgorithm(s);\n  long x = z.size()-1;\n  repl(j,1,x+1) if(z[j] + j == x){\n    x = j;\n    break;\n  }\n  // sは周期xの文字列\n\n  auto cnt = [&](long len){\n    vector<long> vec(26,0);\n    rep(i,len) vec[s[i]-'a']++;\n    return vec;\n  };\n\n  if(s.size()%x==0){\n    // [0...x) を繰り返す\n    auto v = cnt(x);\n    auto f = [&](long p){\n      long q = p/x;\n      auto v1 = v;\n      auto v2 = cnt(p%x);\n      rep(i,26) v1[i] = v1[i]*q + v2[i];\n      return v1;\n    };\n\n    auto f1 = f(l-1), f2 = f(r);\n    rep(i,26) cout << f2[i] - f1[i] << \" \\n\"[i==25];\n  }\n  else {\n    // fibonacci\n    vector<vector<long>> nums;\n    vector<long> len;\n    nums.pb(cnt(x));\n    len.pb(x);\n    nums.pb(cnt(s.size()));\n    len.pb(s.size());\n\n    while( len[len.size()-1] + len[len.size()-2] <= r ){\n      int sz = len.size();\n      vector<long> v(nums[sz-1]);\n      rep(i,26) v[i] += nums[sz-2][i];\n      nums.pb(v);\n      len.pb(len[len.size()-1] + len[len.size()-2]);\n    }\n\n    function<vector<long>(long)> f = [&](long p){\n      int idx = upper_bound(all(len), p) - len.begin();\n      if(idx==0){\n        return cnt(p);\n      }\n      idx--;\n      auto vr = f(p - len[idx]);\n      rep(i,26) vr[i] += nums[idx][i];\n      return vr;\n    };\n\n    auto f1 = f(l-1), f2 = f(r);\n    rep(i,26) cout << f2[i] - f1[i] << \" \\n\"[i==25];\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nstring S[3];\nll L,R;\nll cnt[103][28];\n\n\nvector<int> Zalgo(string s) {\n\tvector<int> v(1,s.size());\n\tfor(int i=1,l=-1,r=-1;i<s.size();i++) {\n\t\tif(i<=r && v[i-l]<r-i+1) v.push_back(v[i-l]);\n\t\telse {\n\t\t\tl=i; r=(i>r)?i:(r+1);\n\t\t\twhile(r<s.size() && s[r-i]==s[r]) r++;\n\t\t\tv.push_back((r--)-l);\n\t\t}\n\t}\n\tv.push_back(0);\n\treturn v;\n}\nstring nex(string S) {\n\tvector<int> V=Zalgo(S);\n\t\n\tint l;\n\tfor(l=S.size()/2-1;l>=0;l--) {\n\t\tif(V[S.size()-l]>=l) return S.substr(0,S.size()-l)+S.substr(0,S.size()-l);\n\t}\n}\nvector<ll> hoge(ll v) {\n\tvector<ll> ret(26,0);\n\tint i;\n\tFOR(i,26) ret[i] = v/S[0].size()*cnt[0][i];\n\tv%=S[0].size();\n\tFOR(i,v) ret[S[0][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll L,ll R) ;\nvector<ll> hoge3(ll V) {\n\tvector<ll> ret(26,0);\n\t\n\tint i,j;\n\tfor(i=99;i>=1;i--) {\n\t\tif(V==cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i][j];\n\t\t\tV=0;\n\t\t}\n\t\tif(V>cnt[i][26]) {\n\t\t\tFOR(j,26) ret[j]+=cnt[i-1][j];\n\t\t\tV-=cnt[i-1][26];\n\t\t}\n\t}\n\tFOR(i,V) ret[S[1][i]-'a']++;\n\treturn ret;\n}\n\nvector<ll> hoge2(ll L,ll R) {\n\tvector<ll> RR=hoge3(R);\n\tvector<ll> LL=hoge3(L-1);\n\tint i;\n\tFOR(i,26) RR[i]-=LL[i];\n\treturn RR;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S[0]>>L>>R;\n\tS[1]=nex(S[0]);\n\tS[2]=nex(S[1]);\n\t\n\tFORR(r,S[0]) cnt[0][r-'a']++;\n\tFORR(r,S[1]) cnt[1][r-'a']++;\n\tcnt[0][26]=S[0].size();\n\tcnt[1][26]=S[1].size();\n\t\n\t\n\tvector<ll> LL,RR;\n\tif(S[0].size()+S[2].size()==2*S[1].size()) {\n\t\tRR=hoge(R);\n\t\tLL=hoge(L-1);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i]-LL[i],(i==25)?'\\n':' ');\n\t}\n\telse {\n\t\tfor(i=2;i<=100;i++) {\n\t\t\tFOR(j,27) {\n\t\t\t\tcnt[i][j] = min(1LL<<60,cnt[i-1][j]+cnt[i-2][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tRR=hoge2(L,R);\n\t\tFOR(i,26) _P(\"%lld%c\",RR[i],(i==25)?'\\n':' ');\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nstring f_half(string s) {\n  for (int d=1; d<s.length(); d++) {\n    bool ok = true;\n    for (int i=d; i<s.length(); i++) if (s[i] != s[i-d]) ok = false;\n    if (ok) {\n      string o(s);\n      rep(j, d) o += s[j];\n      return o;\n    }\n  }\n  return s+s;\n}\n\nstring S;\nlong long L, R;\nvector<long long> F;\n\nvector<long long> fib(long long cur) {\n  vector<long long> C(F.size(), 0);\n\n  assert(F.size() >= 2 && F[0] == S.length()/2);\n  for (int i=F.size()-1; i>=0; i--) {\n    if (cur >= F[i]) {\n      cur -= F[i];\n      C[i]++;\n    }\n    if (i >= 2) C[i-2] += C[i];\n    if (i >= 1) C[i-1] += C[i];\n  }\n  vector<long long> ret(26, 0);\n  // cur\n  rep(i, cur+1) ret[S[i]-'a']++;\n  // C[1]\n  rep(i, F[1]-F[0]) ret[S[i]-'a'] += C[1];\n  // C[0]\n  rep(i, S.length()/2) ret[S[i]-'a'] += C[0];\n  return ret;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> S >> L >> R;\n  L--, R--;\n  string half(S); half.resize(S.length()/2);\n  vector<int> seq;\n  seq.pb(half.size());\n  rep(_, 3) {\n    half = f_half(half);\n    seq.pb(half.size());\n  }\n  bool repeat = true;\n  rep(i, seq.size()-1) if (seq[i+1]-seq[i] != seq[1]-seq[0]) repeat = false;\n  vector<long long> ans(26);\n  if (repeat) {\n    long long N = S.length()/2;\n    rep(i, N) {\n      long long l = max(0LL, (L-i+N-1)/N), r = (R-i)/N;\n      ans[S[i]-'a'] += max(0LL, r-l+1);\n    }\n  }\n  else {\n    F.pb(seq[0]);\n    F.pb(seq[1]);\n    while (F.back() <= 1e18) F.pb(F[F.size()-1] + F[F.size()-2]);\n\n    ans = fib(R);\n    if (L > 0) {\n      vector<long long> t = fib(L-1);\n      rep(i, 26) ans[i] -= t[i];\n    }\n  }\n  rep(i, 26) cout << ans[i] << \" \"; cout << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define max(x, y) ((x) > (y) ? (x) : (y))\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\nstruct C {\n\tlong long sum[26];\n\tlong long s;\n\tC() {\n\t\tmemset(sum, 0, sizeof sum);\n\t\ts = 0;\n\t}\n} F[1100];\n\nC operator * (C x, long long y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] *= y;\n\tx.s *= y;\n\treturn x;\n}\n\nC operator + (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] += y.sum[i];\n\tx.s += y.s;\n\treturn x;\n}\n\nC operator - (C x, C y) {\n\tfor (int i = 0; i < 26; i++)\n\t\tx.sum[i] -= y.sum[i];\n\tx.s -= y.s;\n\treturn x;\n}\n\nint len;\nint n;\nchar S[210000];\nint ne[210000];\n\nC query(int k, long long l, long long r) {\n\t// printf(\"?? %d %lld %lld\\n\", k, l, r);\n\tif (k <= 1) {\n\t\tif (k == 0) {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, n - ne[n]);\n\t\t}else {\n\t\t\tl = max(l, 1);\n\t\t\tr = min(r, n);\n\t\t}\n\t\tC ans;\n\t\tmemset(ans.sum, 0, sizeof ans.sum);\n\t\tans.s = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tans.sum[S[i] - 'a'] += 1, ans.s += 1;\n\t\treturn ans;\n\t}\n\tif (l <= 1 && r >= F[k].s)\n\t\treturn F[k];\n\tif (r <= F[k - 1].s)\n\t\treturn query(k - 1, l, r);\n\telse if (l > F[k - 1].s)\n\t\treturn query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n\telse\n\t\treturn query(k - 1, l, r) + query(k - 2, l - F[k - 1].s, r - F[k - 1].s);\n}\n\nint main() {\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1) / 2;\n\tint p = 0;\n\tne[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (; p && S[p + 1] != S[i]; p = ne[p]);\n\t\tif (S[p + 1] == S[i])\n\t\t\tp ++;\n\t\tne[i] = p;\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r;\n\t// if (ne[n] * 2 >= n) {\n\t// \tint c = n - ne[n];\n\t// \tC pp;\n\t// \tfor (int i = 1; i <= c; i++)\n\t// \t\tpp.sum[S[i] - 'a'] += 1, pp.s += 1;\n\t// \tC ans = pp * (r / c);\n\t// \tfor (int i = 1; i <= r % c; i++)\n\t// \t\tans.sum[S[i] - 'a'] += 1;\n\t// \tl -= 1;\n\t// \tans = ans - (pp * (l / c));\n\t// \tfor (int i = 1; i <= l % c; i++)\n\t// \t\tans.sum[S[i] - 'a'] -= 1;\n\t// \tfor (int i = 0; i < 25; i++)\n\t// \t\tprintf(\"%lld \", ans.sum[i]);\n\t// \tprintf(\"%lld\\n\", ans.sum[25]);\n\t// }else {\n\t\tlen = 1;\n\t\tfor (int i = 1; i <= n - ne[n]; i++)\n\t\t\tF[0].sum[S[i] - 'a'] += 1, F[0].s += 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tF[1].sum[S[i] - 'a'] += 1, F[1].s += 1;\n\t\twhile (F[len].s <= 1000000000000000000LL) {\n\t\t\tF[len + 1] = F[len] + F[len - 1];\n\t\t\tlen += 1;\n\t\t}\n\t\tC ans = query(len, l, r);\n\t\tfor (int i = 0; i < 25; i++)\n\t\t\tprintf(\"%lld \", ans.sum[i]);\n\t\tprintf(\"%lld\\n\", ans.sum[25]);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=400100,M=10000;\ntypedef long long ll;\nint f[N],n;\nll tmp[M][36],len[M],ans[36],l,r;\nchar s[N];\n\nvoid MP(){\n\tint j=f[0]=-1;f[1]=0;\n\tfor(int i=1;i<n;f[++i]=++j)\n\t\tfor(;~j&&s[i]!=s[j];j=f[j]);\n}\n\nvoid solve1(ll lim,int op){\n\tmemset(tmp,0,sizeof tmp);\n\tfor(int j=0;j<n+n-f[n];++j){\n\t\tif(j<n)tmp[0][s[j]]++;\n\t\ttmp[1][s[j]]++;\n\t}\n\tlen[0]=n;len[1]=n+n-f[n];\n\tint i=2;\n\tfor(;len[i-1]<=lim;++i){\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tfor(int j=0;j<26;++j)tmp[i][j]=tmp[i-1][j]+tmp[i-2][j];\n\t}\n\tfor(i-=2;i>=0;--i)\n\t\tif(lim>=len[i]){\n\t\t\tfor(int k=0;k<26;++k)ans[k]+=tmp[i][k]*op;\n\t\t\tlim-=len[i];\n\t\t}\n\tfor(int j=0;j<lim;++j)ans[s[j]]+=op;\n}\n\nvoid solve2(ll lim,int op){\n\tfor(int i=0;i<(n-f[n]);++i)\n\t\tans[s[i]]+=(lim+n-f[n]-i)/(n-f[n])*op;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>s>>l>>r;n=strlen(s)/2;\n\tfor(int i=0;i<2*n;++i)s[i]-='a';MP();\n\tif(n%(n-f[n])){solve1(r,1);solve1(l-1,-1);}\n\telse{solve2(r,1);solve2(l-1,-1);}\n\tfor(int i=0;i<26;++i)cout<<ans[i]<<\" \\n\"[i==25];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH ;//<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) ;//<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nvi KMP(string s){\n\tint n=s.size();\n\tvi dp(n+1,-1);\n\tFOR(i,1,n+1){\n\t\tint j=dp[i-1];\n\t\twhile(j!=-1)\n\t\t\tif(s[j]==s[i-1])break;\n\t\t\telse j=dp[j];\n\t\tdp[i]=j+1;\n\t}\n\treturn dp;\n}\n\nstruct Kyuridenamida{\n\tstring org;\n\tvi cnt;\n\tKyuridenamida const *s,*t;\n\tint len;\n\tKyuridenamida(string w){\n\t\t;//<<\"Init \"<<w<<endl;\n\t\torg=w;\n\t\tcnt.resize(26,0);\n\t\tfor(auto const&c:w)cnt[c-'a']++;\n\t\ts=NULL;\n\t\tt=NULL;\n\t\tlen=w.size();\n\t\tassert(cnt.size()==26);\n\t}\n\tKyuridenamida(Kyuridenamida const&x,Kyuridenamida const&y){\n\t\tcnt.resize(26,0);\n\t\tREP(i,26)cnt[i]=x.cnt[i]+y.cnt[i];\n\t\ts=&x;\n\t\tt=&y;\n\t\tlen=x.len+y.len;\n\t\tassert(cnt.size()==26);\n\t}\n\tvi Calc(int x)const{\n\t\t;//<<\"Call \"<<len<<\" \"<<x<<endl;\n\t\tif(s);//<<\"ScntSize \"<<s->cnt.size()<<endl;\n\t\tassert(!s||s->cnt.size()==26);\n\t\tassert(x<=len);\n\t\t;//<<-2<<endl;\n\t\tif(x<=0)return vi(26,0);\n\t\t;//<<-1<<endl;\n\t\tassert(cnt.size()==26);\n\t\tif(x==len)return cnt;\n\t\t;//<<0<<endl;\n\t\tvi res(26,0);\n\t\tif(!s&&!t){\n\t\t\t;//<<1<<endl;\n\t\t\tREP(i,x)res[org[i]-'a']++;\n\t\t\t;//<<2<<endl;\n\t\t}else{\n\t\t\t;//<<3<<endl;\n\t\t\tassert(s->cnt.size()==26);\n\t\t\tvi u=s->Calc(min(x,s->len)),v=t->Calc(x-s->len);\n\t\t\t;//<<4<<endl;\n\t\t\t;//<<u<<endl;\n\t\t\t;//<<v<<endl;\n\t\t\tREP(i,26)res[i]=u[i]+v[i];\n\t\t\t;//<<5<<endl;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nsigned main(){\n\tstring s=readString();\n\tint l=read(),r=read(),n=s.size();\n\tvi kmp=KMP(s);\n\tint div=n;\n\twhile(div!=-1&&div*2>=n)\n\t\tdiv=kmp[div];\n\tREP(i,div)s.pop_back();\n\tn-=div;\n\tstring t=s.substr(0,n-KMP(s).back());\n\tvector<Kyuridenamida> k;k.reserve(893);\n\tk.PB(Kyuridenamida(t));\n\tk.PB(Kyuridenamida(s));\n\t;//<<893<<endl;\n\twhile(k.back().len<r)k.PB(Kyuridenamida(k[int(k.size())-1],k[int(k.size())-2]));\n\t;//<<1919<<endl;\n\t;//<<k[1].len<<\" \"<<k[1].cnt.size()<<endl;\n\tvi ans1=k.back().Calc(r);\n\tvi ans2=k.back().Calc(l-1);\n\tREP(i,26)print(ans1[i]-ans2[i],i==25?1:2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<class Iter> vector<int>Z_Algorithm(Iter a, Iter a_end) {\n    int n = a_end - a;\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && a[r-l] == a[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && a[r-l] == a[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\n\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=2; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    REP (i, R) ans[S[i%N]-'a']++;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    N /= 2;\n    VI z = Z_Algorithm(S, S+N);\n    \n    int pos = N;\n    for (int i=1; i<N; i++) if (i + z[i] == N) {\n\tpos = i;\n\tbreak;\n    }\n\n    len[0] = pos;\n    len[1] = N;\n    REP (i, N) {\n\tif (i < pos) C[0][S[i]-'a']++;\n\tC[1][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n//    puts(S);\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    assert(len[LEVEL-1] > r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nvector<Int> zalgorithm(string s){\n  Int n=s.size();\n  vector<Int> a(n,0);\n  a[0]=n;\n  Int i=1,j=0;\n  while(i<n){\n    while(i+j<n&&s[j]==s[i+j]) j++;\n    a[i]=j;\n    if(j==0){\n      i++;\n      continue;\n    }\n    Int k=1;\n    while(i+k<n&&k+a[k]<j) a[i+k]=a[k],k++;\n    i+=k;\n    j-=k;\n  }\n  return a;\n}\n\n//INSERT ABOVE HERE\nusing vint = vector<Int>;\nvoid print(const vint &v){\n  for(Int i=0;i<(Int)v.size();i++){\n    if(i) cout<<\" \";\n    cout<<v[i];\n  }\n  cout<<endl;\n}\n\nvint add(const vint &a,const vint &b){\n  vint c(26,0);\n  for(Int i=0;i<26;i++) c[i]=a[i]+b[i];\n  return c;\n}\nvint sub(const vint &a,const vint &b){\n  vint c(26,0);\n  for(Int i=0;i<26;i++) c[i]=a[i]-b[i];\n  return c;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  Int l,r;\n  cin>>l>>r;\n  l--;\n  \n  Int n=s.size(),k=n/2+1;\n  vector<Int> z=zalgorithm(s);\n  while(k<n&&k+z[k]<n) k++;\n  \n  vector<Int> x;\n  x.emplace_back(n);\n  x.emplace_back(k*2);\n  for(Int i=0;x.back()<=r;i++)\n    x.emplace_back(Int(x[i]+x[i+1]));\n\n  vector<vint> a(n+1,vint(26,0));\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<26;j++)\n      a[i+1][j]=a[i][j]+(s[i]=='a'+j);\n  \n  using P = pair<Int, Int>;\n  map<P, vint> dp;\n  function<vint(Int, Int)> dfs=\n    [&](Int l,Int r){\n      if(dp.count(P(l,r))) return dp[P(l,r)];\n      vint &res=dp[P(l,r)];\n      if(r<=n) return res=sub(a[r],a[l]);\n      Int p=0;\n      while(r>x[p]) p++;\n      Int y=x[p]/2;\n      if(y<=l) return res=dfs(l-y,r-y);\n      return res=add(dfs(l,y),dfs(0,r-y));\n    };\n  \n  print(dfs(l,r));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<valarray>\nusing namespace std;\npair<valarray<long long>,long long> f(long long n,long long l,const valarray<long long> &left,long long r,const valarray<long long> &right)\n{\n\tvalarray<long long> ans(26);\n\tif(l+r<=n)\n\t{\n\t\tauto x=f(n,l+r,left+right,l,left);\n\t\tans+=x.first;\n\t\tn=x.second;\n\t}\n\tif(l<=n)ans+=left,n-=l;\n\treturn make_pair(ans,n);\n}\nchar s[300000];\nlong long cnt[300000][30],z[300000],n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tz[1]=n;\n\tlong long l=1,r=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tif(i>r)\n\t\t{\n\t\t\tz[i]=0;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tif(z[i])l=i,r=i+z[i]-1;\n\t\t}\n\t\telse if(z[i-l+1]<r-i+1)z[i]=z[i-l+1];\n\t\telse\n\t\t{\n\t\t\tz[i]=r-i+1;\n\t\t\twhile(z[i]+i<=n&&s[z[i]+i]==s[z[i]+1])z[i]++;\n\t\t\tl=i,r=i+z[i]-1;\n\t\t}\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tfor(long long j=0;j<26;j++)cnt[i][j]=cnt[i-1][j];\n\t\tcnt[i][s[i]-'a']++;\n\t}\n\tlong long k=0;\n\tfor(long long i=n;i>1;i--)\n\t\tif(z[i]+i-1==n)k=z[i];\n\tscanf(\"%lld%lld\",&l,&r);l--;\n\tif(!k)\n\t{\n\t\tfor(long long i=0;i<26;i++)printf(\"%lld \",cnt[n][i]*(r/n)+cnt[r%n][i]-cnt[n][i]*(l/n)-cnt[l%n][i]);\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\tvalarray<long long> left(26),right(26);\n\tfor(long long i=0;i<26;i++)\n\t{\n\t\tleft[i]=cnt[n-k][i];\n\t\tright[i]=cnt[n][i]-cnt[n-k][i];\n\t}\n\tauto lower=f(l,n-k,left,k,right),upper=f(r,n-k,left,k,right);\n\tfor(long long i=0;i<26;i++)printf(\"%lld \",upper.first[i]-lower.first[i]+cnt[upper.second][i]-cnt[lower.second][i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define next nxt\nusing namespace std;\nchar st[500010];\nint go[500010][26],next[500010],w,len;\nlong long work(long long r,int ch)\n{\n\tif (r<=len) return go[r][ch];\n\tlong long n1=go[len/2][ch],n2=go[w][ch],l1=len/2,l2=w;\n\twhile (l1+l2<=r)\n\t{\n\t\tlong long tmp=l1;l1+=l2;l2=tmp;\n\t\ttmp=n1;n1+=n2;n2=tmp;\n\t}\n\treturn n1+work(r-l1,ch);\n}\nint main()\n{\n\tscanf(\"%s\\n\",st+1);len=strlen(st+1);\n\tfor (int i=1;i<=len;i++)\n\t{\n\t\tfor (int j=0;j<26;j++) go[i][j]=go[i-1][j];\n\t\tgo[i][st[i]-'a']++;\n\t}\n\tnext[0]=-1;\n\tfor (int i=1;i<=len;i++)\n\t{\n\t\tint t=next[i-1];\n\t\twhile ((t!=-1)&&(st[t+1]!=st[i])) t=next[t];\n\t\tnext[i]=t+1;\n\t}\n\tw=next[len];\n\twhile (w>=len/2) w=next[w];\n\tw=len/2-w;\n\tlong long l,r;scanf(\"%lld%lld\",&l,&r);\n\tfor (int i=0;i<26;i++) printf(\"%lld \",work(r,i)-work(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 200005;\n\nchar str[MAXN];\nint fail[MAXN];\nlint dp[222];\nlint cnt[222][26];\n\nvector<lint> solve(lint p, int s, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cnt, 0, sizeof(cnt));\n\tvector<lint> dap(26);\n\tdp[0] = s;\n\tdp[1] = t;\n\tvector<int> v;\n\tfor(int i=0; i<s; i++){\n\t\tcnt[0][str[i] - 'a']++;\n\t}\n\tfor(int i=0; i<t; i++){\n\t\tcnt[1][str[i] - 'a']++;\n\t}\n\tfor(int i=2; i<100; i++){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tcnt[i][j] = cnt[i-1][j] + cnt[i-2][j];\n\t\t}\n\t\tdp[i] = (dp[i-1] + dp[i-2]);\n\t\tif(dp[i] >= p){\n\t\t\tfor(int j=i; j>=0; j--){\n\t\t\t\tif(p >= dp[j]){\n\t\t\t\t\tp -= dp[j];\n\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<p; i++){\n\t\tdap[str[i] - 'a']++;\n\t}\n\tfor(auto &i : v){\n\t\tfor(int j=0; j<26; j++){\n\t\t\tdap[j] += cnt[i][j];\n\t\t}\n\t}\n\treturn dap;\n}\n\nint main(){\n\tscanf(\"%s\", str);\n\tint p = 0;\n\tfor(int i=1; str[i]; i++){\n\t\tif(p && str[i] != str[p]) p = fail[p];\n\t\tif(str[i] == str[p]) p++;\n\t\tfail[i + 1] = p;\n\t}\n\tint n = strlen(str);\n\tint s = n / 2;\n\tint t = n / 2 - fail[n / 2];\n\tlint l, r; cin >> l >> r;\n\tauto x = solve(r, s, t);\n\tauto y = solve(l - 1, s, t);\n\tfor(int i=0; i<26; i++){\n\t\tprintf(\"%lld \", x[i] - y[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=400010;\nchar s[N];\nint nxt[N];\nLL l,r;\nLL f[100][27];\nLL sum[100],ans[27];\n\nvoid getnext()\n{\n\tint n=strlen(s+1)/2,j=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\twhile(j&&s[i]!=s[j+1]) j=nxt[j];\n\t\tif(s[i]==s[j+1]) j++;\n\t\tnxt[i]=j;\n\t}\n}\n\nvoid initfib()\n{\n\tfor(int i=2;i<=87;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i][j]=f[i-1][j]+f[i-2][j];\n\t\tsum[i]=sum[i-1]+sum[i-2];\n\t}\n}\n\nvoid gao(LL x,int fg)\n{\n\tint p;\n\tfor(p=0;p<=87;p++)\n\t\tif(sum[p]>x) break;\n\tfor(;p;p--)\n\t\tif(x>=sum[p])\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t\tans[i]+=fg*f[p][i];\n\t\t\tx-=sum[p];\n\t\t}\n\tfor(int i=1;i<=x;i++) ans[s[i]-'a']+=fg;\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&l,&r);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tf[0][s[i]-'a']++;\n\tgetnext();\n\tsum[0]=n;sum[1]=2*(n-nxt[n/2]);\n\tfor(int i=0;i<26;i++) f[1][i]=f[0][i];\n\tfor(int i=nxt[n/2]+1;i<=n-nxt[n/2];i++)\n\t\tf[1][s[i]-'a']++;\n\tinitfib();gao(r,1);gao(l-1,-1);\n\tfor(int i=0;i<26;i++) printf(\"%lld \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ntemplate<typename T = int>\ninline T read() {\n\tT x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 2e5 + 1e3;\n\nchar S[N]; int lenT, n, fail[N], pre[N][26];\n\nll l, r, ans[26], f[100][26], len[100];\n\nvoid Get_Fail() {\n\tFor (i, 2, n) {\n\t\tint j = fail[i - 1];\n\t\twhile (j && S[j + 1] != S[i]) j = fail[j];\n\t\tfail[i] = j + (S[j + 1] == S[i]);\n\t}\n}\n\nvoid Calc1(ll m, int opt) {\n\tif (m <= 0) return; \n\tll t = m % lenT; Rep (i, 26) ans[i] += opt * pre[t][i];\n\tt = m / lenT; Rep (i, 26) ans[i] += opt * t * pre[lenT][i];\n}\n\nint up = 0;\nvoid Prepare() {\n\tlen[1] = n; len[2] = n + lenT;\n\tRep (i, 26)\n\t\tf[1][i] = pre[n][i], f[2][i] = pre[n][i] + pre[lenT][i];\n\tfor (int i = 3; up = i - 1, (len[i] = len[i - 1] + len[i - 2]) <= r; ++ i)\n\t\tRep (j, 26) f[i][j] = f[i - 1][j] + f[i - 2][j];\n}\n\nvoid Calc2(ll m, int opt) {\n\tFordown (i, up, 1) if (len[i] <= m) {\n\t\tm -= len[i]; Rep (j, 26) ans[j] += opt * f[i][j];\n\t}\n\tRep (j, 26) ans[j] += opt * pre[m][j];\n}\n\nint main () {\n\n\tFile();\n\n\tscanf (\"%s\", S + 1); n = strlen(S + 1) >> 1; \n\n\tGet_Fail();\n\tFor (i, 1, n) Rep (j, 26) \n\t\tpre[i][j] = pre[i - 1][j] + (S[i] - 'a' == j);\n\n\tl = read<ll>(), r = read<ll>(); \n\n\tlenT = n - fail[n];\n\n\tif (n % lenT) \n\t\tPrepare(), Calc2(l - 1, -1), Calc2(r, 1);\n\telse \n\t\tCalc1(l - 1, -1), Calc1(r, 1);\n\n\tRep (i, 26)\n\t\tprintf (\"%lld%c\", ans[i], i == iend - 1 ? '\\n' : ' ');\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1600010;\nchar s[maxn];\nint n,f[maxn],cnt[30];\nll ans[30],g[1000][30];\nint get_next() {\n\tf[0]=f[1]=0;\n\trep(i,1,n-1) {\n\t\tint j=f[i];\n\t\twhile(j&&s[j]!=s[i]) j=f[j];\n\t\tf[i+1]=(s[i]==s[j]?j+1:0);\n\t}\n\tint j=f[n];\n\twhile(j&&j>=(n+1)/2) j=f[j];\n\tint m=n;\n\trep(i,j,n-j-1) s[m++]=s[i];\n\treturn n=m;\n}\nint main() {\n\tll l,r;\n\tscanf(\"%s%lld%lld\",s,&l,&r);\n\tn=strlen(s);\n\tint a=get_next();\n\tint b=get_next();\n\tint c=get_next();\n\tif(b*2==a+c) { // equal\n\t\trep(i,1,n) if(i>=l&&i<=r) ans[s[i-1]-'a']++;\n\t\trep(i,b,c-1) cnt[s[i]-'a']++;\n\t\tr-=n;l-=n+1;\n\t\trep(x,0,25) {\n\t\t\tll k=r/(c-b);if(r<0) k=0;\n\t\t\tans[x]+=k*cnt[x];\n\t\t\tll k2=l/(c-b);if(l<0) k2=0;\n\t\t\tans[x]-=k2*cnt[x];\n\t\t\tif(x==25) {\n\t\t\t\tr-=k*(c-b);l-=k2*(c-b);\n\t\t\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\t\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t\t\t}\n\t\t}\n\t}\n\telse { // fib\n\t//\tprintf(\"%d %d %d\\n\",a,b,c);\n\t\trep(i,0,a-1) g[1][s[i]-'a']++;\n\t\trep(i,0,b-1) g[2][s[i]-'a']++;\n\t\tg[1][26]=a;g[2][26]=b;\n\t\tint m;\n\t\trep(i,3,1000) {\n\t\t\trep(x,0,26) g[i][x]=g[i-1][x]+g[i-2][x];\n\t\t\tif(g[i][26]>=r) {m=i;break;}\n\t\t}\n\t\trep(i,1,m) if(g[i][26]>=r) {m=i;break;}\n\t\tdwn(j,m,1) if(r>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]+=g[j][x];\n\t\t\tr-=g[j][26];\n\t\t}\n\t\trep(i,1,r) ans[s[i-1]-'a']++;\n\t\tl--;\n\t\tdwn(j,m,1) if(l>=g[j][26]) {\n\t\t\trep(x,0,25) ans[x]-=g[j][x];\n\t\t\tl-=g[j][26];\n\t\t}\n\t\trep(i,1,l) ans[s[i-1]-'a']--;\n\t}\n\trep(i,0,25) printf(\"%lld%c\",ans[i],i==25?'\\n':' ');\n\treturn 0;\n}\n/*\nvgxgpuamkvgxgvgxgpuamkvgxg\n1 1000000000000000000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\n\nconst int oo = 1e9;\n\nstring s;\nll L , R;\nint pre[N];\nll len[N], f[N][26];\n\nvoid kmp() {\n\tint idx = 0;\n\tfor (int i = 1; i < s.size(); ++i) {\n\t\twhile (idx > 0 && s[i] != s[idx])idx = pre[idx - 1];\n\t\tif (s[i] == s[idx])++idx;\n\t\tpre[i] = idx;\n\t}\n}\nll calc(int c , ll rem) {\n\tif (rem <= s.size()){\n\t\tll res = 0;\n\t\tfor (int i = 0; i < rem; ++i)\n\t\t\tif (c == s[i] - 'a')res++;\n\t\treturn res;\n\t}\n\tint id = 2;\n\twhile (rem >= len[id - 2] + len[id - 1]) {\n\t\tf[id][c] = f[id - 2][c] + f[id - 1][c];\n\t\tlen[id] = len[id - 2] + len[id - 1];\n\t\tid++;\n\t}\n\n\tif (len[id - 1] == rem)return f[id - 1][c];\n\treturn f[id - 1][c] + calc(c, rem - len[id - 1]);\n}\nint main() {\n\tcin >> s;\n\tcin >> L >> R;\n\tkmp();\n\tlen[1] = s.size() / 2;\n\tlen[0] = s.size() / 2 - pre[s.size() / 2 - 1];\n\tfor (int i = 0; i < len[0]; ++i)\n\t\tf[0][s[i] - 'a']++;\n\tfor (int i = 0; i < len[1]; ++i)\n\t\tf[1][s[i] - 'a']++;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (i)printf(\" \");\n\t\tprintf(\"%lld\", calc(i, R) - calc(i, L - 1));\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=200005;\nint n,m,c,s[N][30],f[N];\nchar S[N];\ntypedef long long LL;\nLL l,r;\n\nLL calc(LL x)\n{\n\tif(x<=n) return s[x][c];\n\tLL s1=s[n][c],s0=s[m][c];\n\tLL l1=n,l0=m;\n\twhile(l1<=x) swap(l1,l0),l1+=l0,swap(s1,s0),s1+=s0;\n\treturn s0+calc(x-l0);\n}\n\nint main()\n{\n\tscanf(\"%s\",S+1),n=strlen(S+1)/2;\n\trep(i,1,n)\n\t\trep(j,0,25) s[i][j]=s[i-1][j]+(S[i]-'a'==j);\n\trep(i,2,n)\n\t{\n\t\tint k=f[i-1];\n\t\twhile(k && S[k+1]!=S[i]) k=f[k];\n\t\tif(S[k+1]==S[i]) ++k;\n\t\tf[i]=k;\n\t}\n\tm=n-f[n];\n\tscanf(\"%lld %lld\",&l,&r);\n\trep(i,0,25) c=i,printf(\"%lld \",calc(r)-calc(l-1));\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\n#define LL long long\n \nchar s[N];\nint tot[N][26],f[N];\nint n,T;\n \nLL calc(LL len,int ch)\n{\n\tif(len<=n) return tot[len][ch];\n\tLL num1=tot[n][ch],num2=tot[T][ch];\n\tLL len1=n,len2=T;\n\twhile(len1+len2<=len){\n\t\tnum1=num1+num2,num2=num1-num2;\n\t\tlen1=len1+len2,len2=len1-len2;\n\t}\n\treturn num1+calc(len-len1,ch);\n}\n \nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)/2;\n\tf[0]=0;f[1]=0;tot[1][s[1]-'a']=1;\n\tfor(int i=2,p;i<=n;i++)\n\t{\n\t\tp=f[i-1];\n\t\twhile(p&&s[p+1]!=s[i]) p=f[p];\n\t\tf[i]=s[p+1]!=s[i] ? 0:p+1;\n\t\tmemcpy(tot[i],tot[i-1],sizeof(tot[i]));\n\t\ttot[i][s[i]-'a']++;\n\t}\n\tT=n-f[n]; cout << T << endl; return 0;\n\tLL l,r;\n\tcin>>l>>r;\n\tfor(int i=0;i<26;i++)\tcout<<calc(r,i)-calc(l-1,i)<<\" \";\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=200005;\nint n,d,fail[N];\nll l,r,s[N][30];\nchar a[N];\nvoid KMP(){\n\tint k=0;\n\tfor (int i=2;i<=n;i++){\n\t\tfor (;k&&a[k+1]!=a[i];) k=fail[k];\n\t\tfail[i]=(k+=(a[k+1]==a[i]));\n\t}\n\td=n-fail[n];\n}\nll fib(ll p,int c){\n\tif (p<=n) return s[p][c];\n\tif (p<=n*2) return s[n][c]+s[p-n][c];\n\tll ans1=s[n][c]+s[d][c],ans2=s[n][c];\n\tll a=n+d,b=n;\n\tfor (;p>a+b;){\n\t\tll c=ans1; ans1+=ans2; ans2=c;\n\t\tc=a; a+=b; b=c;\n\t}\n\treturn ans1+fib(p-a,c);\n}\nll calc(ll p,int c){\n\tif (p<=n) return s[p][c];\n\tif(n%d==0){\n\t\tll ans=(p-n)/d*s[d][c]+s[n][c];\n\t\treturn ans+s[(p-n)%d][c];\n\t}\n\treturn fib(p,c);\n}\nint main(){\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1)/2;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<26;j++)\n\t\t\ts[i][j]=s[i-1][j];\n\t\ts[i][a[i]-'a']++;\n\t}\n\tKMP();\n\tscanf(\"%lld%lld\",&l,&r);\n\tfor (int i=0;i<26;i++)\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid getPi(string s, vector<int> &pi) {\n    pi = vector<int>(s.size(), 0);\n    int j = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while(j && s[i] != s[j]) j = pi[j - 1];\n        if(s[i] == s[j]) pi[i] = ++j;\n    }\n}\n\nstring S, T, A, B;\nll L, R;\nvector<int> pi;\nvector<ll> fibo;\nvector<vector<ll> > fcnt;\n\nvoid Fibonacci() {\n    //cout << A << ' ' << B << endl;\n    fibo.push_back(A.size());\n    fibo.push_back(A.size() + B.size());\n    for(int i = 2;; i++) {\n        ll a = fibo[i - 2];\n        ll b = fibo[i - 1];\n        fibo.push_back(a + b);\n        if(fibo[i] >= 1e18) break;\n    }\n    fcnt = vector<vector<ll> >(fibo.size(), vector<ll>(26, 0));\n    for(int i = 0; i < A.size(); i++) {\n        fcnt[0][ A[i] - 'a' ]++;\n    }\n    for(int i = 0; i < A.size() + B.size(); i++) {\n        if(i < A.size()) fcnt[1][ A[i] - 'a' ]++;\n        else fcnt[1][ B[i - (int)A.size()] - 'a' ]++;\n    }\n    for(int i = 2; i < fibo.size(); i++) {\n        for(int j = 0; j < 26; j++) {\n            fcnt[i][j] = fcnt[i - 1][j] + fcnt[i - 2][j];\n        }\n    }\n}\n\nvector<ll> solve(ll x) {\n    if(x < 0) return vector<ll>(26, 0);\n    if(x + 1 <= A.size() + B.size()) {\n        vector<ll> ret(26, 0);\n        for(int i = 0; i <= x; i++) {\n            if(i < A.size()) ret[ A[i] - 'a' ]++;\n            else ret[ B[ i - (int)A.size() ] - 'a' ]++;\n        }\n        return ret;\n    }\n\n    int s = 0, e = fibo.size() - 1;\n    int r;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(fibo[m] <= x + 1) {\n            r = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    vector<ll> ret(26, 0);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += fcnt[r][i];\n    }\n\n    vector<ll> tmp = solve(x - fibo[r]);\n    for(int i = 0; i < 26; i++) {\n        ret[i] += tmp[i];\n    }\n    return ret;\n}\n\nint main() {\n    cin>>S>>L>>R;\n    L--; R--;\n\n    for(int i = 0; i < S.size() / 2; i++) T.push_back(S[i]);\n    getPi(T, pi);\n\n    for(int i = 0; i < pi[T.size() - 1]; i++) A.push_back(T[i]);\n    for(int i = pi[T.size() - 1]; i < T.size() - pi[T.size() - 1]; i++) B.push_back(T[i]);\n\n    Fibonacci();\n\n    vector<ll> Y = solve(R);\n    vector<ll> X = solve(L - 1);\n\n    for(int i = 0; i < 26; i++) {\n        printf(\"%lld \", Y[i] - X[i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstring s0, s1;\n\nvector<vector<ll>> alfs;\n\nvector<ll> merge(vector<ll> &a, vector<ll> &b) {\n\tvector<ll> res(26);\n\trep(i, 26)res[i] = a[i] + b[i];\n\treturn res;\n}\nstring s;\nvector<ll> calc(ll x) {\n\tvector<ll> res(26,0);\n\tif (x <= s.size()) {\n\t\trep(i, x) {\n\t\t\tres[s[i] - 'a']++;\n\t\t}\n\t\treturn res;\n\t}\n\trep(i, alfs.size()) {\n\t\tif (x <= alfs[i].back()) {\n\t\t\tll len = alfs[i - 1].back();\n\t\t\t//assert(x >= len);\n\t\t\t//cout << \"? \" << len << endl;\n\t\t\tvector<ll> ad = alfs[i - 1];\n\t\t\tvector<ll> ad2 = calc(x-len);\n\t\t\tres = merge(ad, ad2);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << x <<\" ! \"<< endl;\n\t//rep(i, 26)cout << res[i] << \" \";\n\t//cout << endl;\n\treturn res;\n}\nvoid solve() {\n\tcin >> s;\n\tvector<int> a; Z_algorithm(s, a);\n\tint n = s.size();\n\tn /= 2;\n\tint chk = 0;\n\tRep(i, n + 1, 2 * n) {\n\t\tif (a[i] == 2 * n - i) {\n\t\t\tchk = 2 * n - i;\n\t\t}\n\t}\n\ts0 = s.substr(2 * n - chk, chk);\n\tassert(s0.size());\n\ts1 = s.substr(n, n - chk);\n\tint z = s1.size();\n\tif (n%z == 0) {\n\t\tbool c = true;\n\t\trep(i, z) {\n\t\t\trep(j, n / z) {\n\t\t\t\tif (s[i + j * z] != s[i])c = false;\n\t\t\t}\n\t\t}\n\t\tif (c) {\n\t\t\tvector<ll> num(27, 0);\n\t\t\trep(i, z) {\n\t\t\t\tnum[s[i] - 'a']++;\n\t\t\t\tnum[26]++;\n\t\t\t}\n\t\t\tvector<ll> ans(26, 0);\n\t\t\tll l, r; cin >> l >> r; l--; r--;\n\t\t\tll rd = r / z;\n\t\t\tll rr = r % z;\n\t\t\trep(i, 26) {\n\t\t\t\tans[i] += rd * num[i];\n\t\t\t}\n\t\t\trep(i, rr+1)ans[s[i] - 'a']++;\n\t\t\tl--;\n\t\t\tif (l >= 0) {\n\t\t\t\trd = l / z;\n\t\t\t\trr = l % z;\n\t\t\t\trep(i, 26)ans[i] -= rd * num[i];\n\t\t\t\trep(i, rr+1)ans[s[i] - 'a']--;\n\t\t\t}\n\t\t\trep(i, 26) {\n\t\t\t\tif (i > 0)cout << \" \";\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl; return;\n\t\t}\n\t}\n\n\talfs.resize(2);\n\talfs[0].resize(27);\n\trep(i, s0.size()) {\n\t\talfs[0][s0[i] - 'a']++;\n\t\talfs[0][26]++;\n\t}\n\talfs[1].resize(27);\n\trep(i, s1.size()) {\n\t\talfs[1][s1[i] - 'a']++;\n\t\talfs[1][26]++;\n\t}\n\twhile (alfs.back().back() < INF) {\n\t\tint len = alfs.size();\n\t\tvector<ll> nex = merge(alfs[len - 2], alfs.back());\n\t\tnex.push_back(alfs[len - 2].back() + alfs[len - 1].back());\n\t\talfs.push_back(nex);\n\t\tcout << nex.back() << endl;\n\t}\n\tll l, r; cin >> l >> r;\n\tvector<ll> ansl = calc(l - 1);\n\t//cout << \"hello\" << endl;\n\tvector<ll> ansr = calc(r);\n\trep(i, 26)ansl[i] *= -1;\n\tvector<ll> ans = merge(ansl, ansr);\n\trep(i, 26) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5, alpha = 26;\n\nchar s0[MAXN + 5];\nint S[MAXN + 5];\n\nint n, N;\nLL L, R;\n\ninline void input()\n{\n\tscanf(\"%s\", s0 + 1), n = strlen(s0 + 1), N = n / 2;\n\tfor(int i = 1; i <= n; ++i) S[i] = s0[i] - 'a';\n\tL = read<LL>(), R = read<LL>();\n}\n\nint T[MAXN + 5];\nint M;\n\ninline void calc_T(int *s, int len)\n{\n\tstatic int fail[MAXN + 5];\n\n\tfor(int i = 2, j = 0; i <= len; ++i)\n\t{\n\t\twhile(j && s[j + 1] != s[i]) j = fail[j];\n\t\tif(s[j + 1] == s[i]) ++j;\n\t\tfail[i] = j;\n\t}\n\n\tM = fail[len] ?  len - fail[len] : len;\n\tfor(int i = 1; i <= M; ++i) T[i] = s[i];\n}\n\nstruct vec\n{\n\tLL cnt[alpha];\n\n\tinline LL &operator [] (int pos) { return cnt[pos]; }\n\tinline const LL &operator [] (int pos) const { return cnt[pos]; }\n\n\tinline vec operator + (const vec &rhs) const\n\t{\n\t\tstatic vec res;\n\t\tfor(int i = 0; i < alpha; ++i) res[i] = (*this)[i] + rhs[i];\n\t\treturn res;\n\t}\n\tinline vec operator - (const vec &rhs) const\n\t{\n\t\tstatic vec res;\n\t\tfor(int i = 0; i < alpha; ++i) res[i] = (*this)[i] - rhs[i];\n\t\treturn res;\n\t}\n\n\tvec() { memset(cnt, 0, sizeof cnt); }\n};\n\nconst int MAX_LOG = 100;\n\nvec cnt[MAX_LOG + 1];\nLL len[MAX_LOG + 1];\nint k;\n\ninline vec prefix(LL LIM)\n{\n\tif(LIM == 0) return vec();\n\tfor(int i = k; i >= 1; --i) if(len[i] <= LIM) return cnt[i] + prefix(LIM - len[i]);\n\n\tvec res;\n\tfor(int i = 1; i <= LIM; ++i) ++res[S[i]];\n\treturn res;\n}\n\ninline void solve()\n{\n\tcalc_T(S, N);\n\n\tlen[1] = N;\n\tfor(int i = 1; i <= N; ++i) ++cnt[1][S[i]];\n\n\tlen[2] = N + M;\n\tfor(int i = 1; i <= N; ++i) ++cnt[2][S[i]];\n\tfor(int i = 1; i <= M; ++i) ++cnt[2][T[i]];\n\n\tfor(k = 2; len[k] * 2 < R; )\n\t{\n\t\t++k;\n\t\tlen[k] = len[k - 1] + len[k - 2];\n\t\tfor(int i = 0; i < alpha; ++i) cnt[k][i] = cnt[k - 1][i] + cnt[k - 2][i];\n\t}\n\n\tvec ans;\n\tif(R > len[k]) ans = prefix(len[k]) - prefix(L - 1) + prefix(R - len[k]);\n\telse ans = prefix(R) - prefix(L - 1);\n\tfor(int i = 0; i < alpha; ++i) printf(\"%lld \", ans[i]);\n\tputs(\"\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nchar S[MaxN];\nlong long Pred[MaxN][26], L, R, T;\nint Next[MaxN], n;\n\nvoid InitPred()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++) Pred[i][j] = Pred[i - 1][j];\n\t\tPred[i][S[i] - 'a']++;\n\t}\n}\n\nvoid Kmp()\n{\n\tNext[1] = 0;\n\tfor (int j = 0, i = 2; i <= n; i++)\n\t{\n\t\tfor (; j > 0 && S[j + 1] != S[i]; j = Next[j]);\n\t\tif (S[j + 1] == S[i])\n\t\t\tj++;\n\t\tNext[i] = j;\n\t}\n}\n\nvoid SwapOffset(long long &a, long long &b)\n{\n\tlong long tmp = b;\n\tb += a;\n\ta = tmp;\n}\n\nlong long Fib(long long len, int c)\n{\n\tif (len <= n)\n\t\treturn Pred[len][c];\n\tif (len <= n * 2)\n\t\treturn Pred[n][c] + Pred[len - n][c];\n\tlong long f1 = Pred[n][c], f2 = Pred[n][c] + Pred[T][c], l1 = n, l2 = n + T, tmp;\n\twhile (len > l1 + l2)\n\t{\n\t\tSwapOffset(f1, f2);\n\t\tSwapOffset(l1, l2);\n\t}\n\treturn f2 + Fib(len - l2, c);\n}\n\nlong long Calc(long long len, int c)\n{\n\tif (len <= n)\n\t\treturn Pred[len][c];\n\tif (len <= n * 2)\n\t\treturn Pred[n][c] + Pred[len - n][c];\n\tif (n % T == 0)\n\t{\n\t\tlong long res = 1LL * (len - n) / T * Pred[T][c] + Pred[n][c];\n\t\tlen -= n, len %= T;\n\t\treturn res + Pred[len][c];\n\t}\n\telse\n\t\treturn Fib(len, c);\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\", S + 1, &L, &R);\n\tn = strlen(S + 1) / 2;\n\tInitPred();\n\tKmp();\n\tT = n - Next[n];\n\tfor (int i = 0; i < 26; i++)\n\t\tprintf(\"%lld%c\", Calc(R, i) - Calc(L - 1, i), i == 25 ? '\\n' : ' ');\n#ifdef GLOBAL_DEBUG\n\tsystem(\"pause\");\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=2e5;\n\nchar str[N+5];\nll lef,rig;\nll fib[200],cnt[200][30],calA[30],calB[30];\nint pi[N+5];\nint n,m;\n\nvoid Calc(ll *res,ll pos){\n    int p=m;\n    while(pos>fib[0]){\n        while(fib[p]>pos) p--;\n        for(int i=0;i<26;i++)\n            res[i]+=cnt[p][i];\n        pos-=fib[p];\n    }\n    for(int i=0;i<pos;i++)\n        res[str[i]-'a']++;\n}\nvoid Excalc(ll *res,ll pos){\n    for(int i=0;i<n;i++)\n        res[str[i]-'a']+=pos/n;\n    for(int i=pos%n-1;i>=0;i--)\n        res[str[i]-'a']++;\n}\nint main(){\n    scanf(\"%s%lld%lld\",str,&lef,&rig);\n    n=strlen(str);\n    n>>=1;\n    for(int i=1;i<n;i++){\n        int j=pi[i-1];\n        while(j && str[i]!=str[j])\n            j=pi[j-1];\n        if(str[i]==str[j]) j++;\n        pi[i]=j;\n    }\n    if(n%(n-pi[n-1])==0){\n        Excalc(calA,lef-1);\n        Excalc(calB,rig);\n    }\n    else{\n        fib[0]=n;fib[1]=n+n-pi[n-1];\n        for(int i=0;i<n;i++){\n            cnt[0][str[i]-'a']++;\n            cnt[1][str[i]-'a']++;\n            if(i<n-pi[n-1]) cnt[1][str[i]-'a']++;\n        }\n        for(int i=2;i<87;i++){\n            fib[i]=fib[i-1]+fib[i-2];\n            if(fib[i]>=rig) break;\n            m=i;\n            //printf(\"%d:%lld\\n\",i,fib[i]);\n            for(int j=0;j<26;j++)\n            \tcnt[i][j]=cnt[i-1][j]+cnt[i-2][j];\n        }\n        Calc(calA,lef-1);Calc(calB,rig);\n    }\n    for(int i=0;i<26;i++)\n        printf(\"%lld%c\",calB[i]-calA[i],i==25? '\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<class Iter> vector<int>Z_Algorithm(Iter a, Iter a_end) {\n    int n = a_end - a;\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && a[r-l] == a[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && a[r-l] == a[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\n\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=2; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    REP (i, R) ans[S[i]-'a']++;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    VI z = Z_Algorithm(S, S+N);\n    \n    int pos = N;\n    for (int i=N/2+1; i<N; i++) if (i + z[i] == N) {\n\tpos = i;\n\tbreak;\n    }\n    int sep = pos;\n    S[pos] = 0;\n    for (int i=1; i<pos; i++) if (i + z[i] >= pos) {\n\tsep = i;\n\tbreak;\n    }\n\n    len[0] = pos - sep;\n    len[1] = sep;\n    REP (i, pos) {\n\tif (i < sep) C[1][S[i]-'a']++;\n\telse C[0][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\n///// This part below is only for debug, not used /////\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n///// END /////\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\nlint L, R;\nstring S, T;\n\n// Z algorithm (length of longest common prefix for s[0:N] & s[i:N] for each i)\n// Complexity: O(N)\n// <http://snuke.hatenablog.com/entry/2014/12/03/214243>\n\nvector<int> z_algorithm(const string &s) {\n    vector<int> ans(s.size());\n    ans[0] = s.size();\n    int i = 1, j = 0;\n    while (i < (int)s.size()) {\n        while (i + j < (int)s.size() && s[j] == s[i + j]) ++j;\n        ans[i] = j;\n        if (!j) {\n            ++i;\n            continue;\n        }\n        int k = 1;\n        while (i + k < (int)s.size() && k + ans[k] < j) ans[i + k] = ans[k], ++k;\n        i += k;\n        j -= k;\n    }\n    return ans;\n}\nvector<lint> C(string S) {\n    vector<lint> ret(26);\n    for (auto c : S) ret[c - 'a']++;\n    return ret;\n}\n\nstring Next(string S) {\n    vector<int> z = z_algorithm(S);\n    int r = S.length();\n    FOR(i, S.length() / 2 + 1, S.length()) if (z[i] + i == S.length()) mmin(r, i);\n    return  S.substr(0, r) + S.substr(0, r);\n}\n\nmap<lint, vector<lint>> mp;\n\nvector<lint> solve(lint L) {\n    vector<lint> ret(26);\n    while (L > T.length())\n    {\n        auto itr = prev(mp.upper_bound(L));\n        REP(d, 26) ret[d] += itr->second[d];\n        L -= itr->first;\n    }\n    REP(i, L) ret[T[i] - 'a']++;\n    return ret;\n}\n\nint main()\n{\n    cin >> S >> L >> R;\n    T = Next(S);\n    vector<lint> v1 = C(S), v2 = C(T);\n    lint l1 = S.length(), l2 = T.length();\n    mp[l1] = v1;\n    mp[l2] = v2;\n    while (l2 < 2e18) {\n        swap(l1, l2);\n        l2 += l1;\n        swap(v1, v2);\n        REP(i, 26) v2[i] += v1[i];\n        mp[l2] = v2;\n    }\n    vector<lint> ret1 = solve(L - 1), ret2 = solve(R);\n    REP(d, 26) printf(\"%lld \", ret2[d] - ret1[d]);\n    puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3) \n#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set> \n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db long double\n#define inf 200001\n#define INF (ll)1e15 \n#define pi acos(-1)\n#define mxbit 30\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n\nchar str[inf];\nint nxt[inf];\nll sum[26][inf];\nint n,lens;\n\nvoid getnxt(void){\n\tint k=0;\n    nxt[0]=0;\n    for (int i=2;i<=n;i++){\n        while (k && str[k+1]!=str[i]){\n            k=nxt[k];\n        }\n        if (str[k+1]==str[i]){\n            k++;\n        }\n        nxt[i]=k;\n    }\n    return;\n}\n\nll query(ll x,int p){\n\tif (x<n){\n\t\treturn sum[p][x];\n\t}\n\tll a=sum[p][lens],b=sum[p][n];\n\tll l1=lens,l2=n;\n    while(l1+l2<x){\n    \ta+=b;\n\t\tswap(a,b);\n\t\tl1+=l2;\n\t\tswap(l1,l2);\n\t}\n    return b+query(x-l2,p);\n}\n\nint main(){\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1)/2;\n\tgetnxt();\n\tlens=n-nxt[n];\n\tfor (int i=0;i<26;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tsum[i][j]=sum[i][j-1]+(str[j]-'a'==i);\n\t\t}\n\t}\n\tll l,r;\n\trd(l) rd(r)\n\tfor (int i=0;i<26;i++){\n\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t200005\n#define MAXC\t26\n#define MAXLOG\t105\n#define INF\t1e18\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nlong long cnt[MAXLOG][MAXC];\nlong long sum[MAXLOG];\nlong long ans[MAXC], bns[MAXC];\nlong long n, l, r, m;\nchar s[MAXN];\nvoid init() {\n\tstatic int next[MAXN];\n\tfor (int i = 2; i <= n; i++) {\n\t\tint j = next[i - 1];\n\t\twhile (j && s[j + 1] != s[i]) j = next[j];\n\t\tif (s[j + 1] == s[i]) j++;\n\t\tnext[i] = j;\n\t}\n\tfor (int i = next[n] + 1; i <= n; i++)\n\t\tcnt[1][s[i] - 'a']++;\n\tm = 1;\n\tsum[0] = n;\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[0][s[i] - 'a']++;\n\tsum[1] = n + n - next[n];\n\tfor (int i = 0; i < 26; i++)\n\t\tcnt[1][i] += cnt[0][i];\n\twhile (sum[m] + sum[m - 1] <= INF) {\n\t\tm++; sum[m] = sum[m - 1] + sum[m - 2];\n\t\tfor (int i = 0; i < 26; i++)\n\t\t\tcnt[m][i] = cnt[m - 1][i] + cnt[m - 2][i];\n\t}\n}\nvoid calc(long long total, long long *ans) {\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (total < sum[i]) continue;\n\t\ttotal -= sum[i];\n\t\tfor (int j = 0; j < 26; j++)\n\t\t\tans[j] += cnt[i][j];\n\t}\n\tfor (int i = 1; i <= total; i++)\n\t\tans[s[i] - 'a']++;\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1) / 2;\n\tread(l), read(r);\n\tinit();\n\tcalc(r, ans);\n\tcalc(l - 1, bns);\n\tfor (int i = 0; i < 26; i++)\n\t\tprintf(\"%lld \", ans[i] - bns[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\n#define N 200010\n#define ll long long\n\nusing namespace std;\n\nstruct data\n{\n\tll len,a[30];\n\tdata()\n\t{\n\t\tlen=0;\n\t\tmemset(a,0,sizeof(a));\n\t}\n}f[100];\n\ndata operator + (data a,data b)\n{\n\tdata c;\n\tc.len=a.len+b.len;\n\tfor(int i=0;i<26;i++)\n\t\tc.a[i]=a.a[i]+b.a[i];\n\treturn c;\n}\n\ndata operator - (data a,data b)\n{\n\tdata c;\n\tc.len=a.len-b.len;\n\tfor(int i=0;i<26;i++)\n\t\tc.a[i]=a.a[i]-b.a[i];\n\treturn c;\n}\n\nint n,maxn;\nint cut,kmp[N];\nchar s[N],ss[N];\nll ql,qr;\n\ndata query(int k,ll x)\n{\n\tif(x==f[k].len) return f[k];\n\tif(!k)\n\t{\n\t\tdata c;\n\t\tc.len=x;\n\t\tfor(int i=cut+1;i<=cut+x;i++)\n\t\t\tc.a[s[i]-'a']++;\n\t\treturn c;\n\t}\n\tif(k==1)\n\t{\n\t\tdata c;\n\t\tc.len=x;\n\t\tfor(int i=1;i<=x;i++)\n\t\t\tc.a[s[i]-'a']++;\n\t\treturn c;\n\t}\n\tif(x<=f[k-1].len) return query(k-1,x);\n\treturn f[k-1]+query(k-2,x-f[k-1].len);\n}\n\nint main()\n{\n\tscanf(\"%s%lld%lld\",s+1,&ql,&qr);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n/2;i++)\n\t\tss[n/2-i+1]=s[i];\n\tfor(int i=2,j=0;i<=n/2;i++)\n\t{\n\t\twhile(j&&ss[j+1]!=ss[i]) j=kmp[j];\n\t\tif(ss[j+1]==ss[i]) j++;\n\t\tkmp[i]=j;\n\t}\n\tint cut=n/2-kmp[n/2];\n\tfor(int i=cut+1;i<=n/2;i++)\n\t{\n\t\tf[0].len++;\n\t\tf[0].a[s[i]-'a']++;\n\t}\n\tfor(int i=1;i<=cut;i++)\n\t{\n\t\tf[1].len++;\n\t\tf[1].a[s[i]-'a']++;\n\t}\n\tfor(int i=2;;i++)\n\t{\n\t\tf[i].len=f[i-1].len+f[i-2].len;\n\t\tfor(int j=0;j<26;j++)\n\t\t\tf[i].a[j]=f[i-1].a[j]+f[i-2].a[j];\n\t\tif(f[i].len>qr)\n\t\t{\n\t\t\tmaxn=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdata ans=query(maxn,qr)-query(maxn,ql-1);\n\tfor(int i=0;i<26;i++)\n\t\tprintf(\"%lld \",ans.a[i]);\n\treturn 0;\n}\n/*\n87167725689669676 0 0 0 0 0 282080685775825810 0 0 0 87167725689669676 0 87167725689669676 0 0 87167725689669676 0 0 0 0 87167725689669676 141040342887912905 0 141040342887912905 0 0\n87167725689669676 0 0 0 0 0 282080685775825810 0 0 0 87167725689669676 0 87167725689669676 0 0 87167725689669676 0 0 0 0 87167725689669676 141040342887912905 0 141040342887912905 0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nint n,m,nxt[N];\nll l,r,ans[26],w[26],f[105][26],len[105];\nchar s[N];\nvoid print(){\n\tfor(int i=0;i<25;i++) printf(\"%lld \",ans[i]);\n\tprintf(\"%lld\",ans[25]);\n}\nvoid solve(int k,ll pos,int op){\n\tif(pos>len[k]||pos<1) return;\n\tif(k<=1){\n\t\tint x=k==0?m:n;\n\t\tif(!op) for(int i=1;i<=pos;i++) ans[s[i]-'a']++;\n\t\telse for(int i=pos;i<=x;i++) ans[s[i]-'a']++;\n\t\treturn;\n\t}\n\tif(!op){\n\t\tif(len[k-1]<=pos) {for(int i=0;i<26;i++) ans[i]+=f[k-1][i];solve(k-2,pos-len[k-1],0);}\n\t\telse solve(k-1,pos,0);\n\t}else{\n\t\tif(len[k-1]>=pos-1){for(int i=0;i<26;i++) ans[i]+=f[k-2][i];solve(k-1,pos,1);}\n\t\telse solve(k-2,pos-len[k-1],1);\n\t}\n}\nvoid get(int k,ll l,ll r){\n\tif(l>len[k-1]){get(k-2,l-len[k-1],r-len[k-1]);return;}\n\tif(r<=len[k-1]){get(k-1,l,r);return;}\n\tsolve(k-1,l,1);\n\tsolve(k-2,r-len[k-1],0);\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1)>>1;\n\tfor(int i=2;i<=n;i++){\n\t\tnxt[i]=nxt[i-1];\n\t\twhile(s[nxt[i]+1]!=s[i]&&nxt[i]) nxt[i]=nxt[nxt[i]];\n\t\tif(s[nxt[i]+1]==s[i]) nxt[i]++;\n\t}\n\tm=n-nxt[n];\n\tfor(int i=1;i<=m;i++) w[s[i]-'a']++;\n\tscanf(\"%lld%lld\",&l,&r);\n\tif(n%m==0||r<=n){\n\t\tif(l<=n){\nreturn -1;\n\t\t\tfor(int i=l;i<=n&&i<=r;i++) ans[s[i]-'a']++;\n\t\t\tif(r<=n) {print();return 0;}\n\t\t\tl=n+1;\n\t\t}\n\t\tl-=n;r-=n;\n\t\tll L=(l%m==0)?m:l%m,R=(r%m==0)?m:r%m;\n\t\tif((l-1)/m==(r-1)/m){\n\t\t\tfor(int i=L;i<=R;i++) ans[s[i]-'a']++;\n\t\t\tprint();\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=L;i<=m;i++,l++) ans[s[i]-'a']++;\n\t\tfor(int i=1;i<=R;i++,r--) ans[s[i]-'a']++;\n\t\tfor(int i=0;i<26;i++) ans[i]+=w[i]*(r-l+1)/m;\n\t\tprint();\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) f[0][s[i]-'a']++;\n\tfor(int i=1;i<=n;i++) f[1][s[i]-'a']++;\n\tlen[0]=m;len[1]=n;\n\tfor(int i=2;i<=100;i++){\n\t\tfor(int p=0;p<26;p++) f[i][p]=f[i-1][p]+f[i-2][p];\n\t\tlen[i]=len[i-1]+len[i-2];\n\t}\n\tint x;\n\tfor(int i=0;i<=100;i++){\n\t\tif(len[i]<r&&len[i+1]>=r){\n\t\t\tx=i;break;\n\t\t}\n\t}\n\tget(x+1,l,r);\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 200009;\nchar s[maxn]; int Next[maxn], n, m;\nLL l, r, w[26];\n\nvoid solve(LL k){\n\tif (k <= n){\n\t\tfor (int i=0; i<k; i++) w[s[i]-'a']++;\n\t\treturn;\n\t}\n\tLL S = 1, T = 0, _s = 0, _t = 1;\n\twhile (S*n + T*m < k) { S += _s; T += _t; _s = S - _s; _t = T - _t; }\n\tsolve(k - _s*n - _t*m);\n\tfor (int i=0; i<n; i++) w[s[i]-'a'] += _s;\n\tfor (int i=0; i<m; i++) w[s[i]-'a'] += _t;\n}\n\nint main(){\n\tscanf(\"%s\", &s); scanf(\"%lld%lld\", &l, &r);\n\tn = strlen(s)/2;\n\tint k = 0; Next[0] = 0;\n\tfor (int i=1; i<n; i++){\n\t\twhile (k && s[k] != s[i]) k = Next[k-1];\n\t\tif (s[k] == s[i]) k++; Next[i] = k;\n\t}\n\tm = n-Next[n-1];\n\tsolve(l-1); for (int i=0; i<26; i++) w[i] = -w[i];\n\tsolve(r); for (int i=0; i<26; i++) printf(\"%lld \", w[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 200010,int lnN = 18>\nstruct String{\n\tstring S;\n\tint sa[N][lnN];\n\tvoid sa_init(){\n\t\tif(true){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tvec.push_back(P(S[i],0));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tsa[i][0] = lower_bound(vec.begin(),vec.end(),P(S[i],0)) - vec.begin();\n\t\t\t}\n\t\t}\n\t\tfor(int t = 1 ; t < lnN ; t ++){\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size())vec.push_back(P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]));\n\t\t\t\telse vec.push_back(P(sa[i][t-1],-1));\n\t\t\t}\n\t\t\tsort(vec.begin(),vec.end());\n\t\t\tfor(int i = 0 ; i < S.size() ; i ++){\n\t\t\t\tif(i+(1<<(t-1)) < S.size()){\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],sa[i+(1<<(t-1))][t-1]))-vec.begin();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsa[i][t] = lower_bound(vec.begin(),vec.end(),P(sa[i][t-1],-1)) - vec.begin();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool eq(int x,int y,int l){\n\t\tfor(int t = lnN-1 ; t >= 0 ; t--){\n\t\t\tif(l < (1<<t))continue;\n\t\t\tif(sa[x][t] != sa[y][t])return false;\n\t\t\tl -= 1<<t;\n\t\t\tx += 1<<t;\n\t\t\ty += 1<<t;\n\t\t}\n\t\treturn true;\n\t}\n};\nString<> str;\n\nstring A,B;\nvector<P> vec;\nll ret[26];\nll cnt_A[26];\nll cnt_B[26];\nvoid cnt(ll x,ll k){\n\t//cout << x << \" \" << k << endl;\n\tif(x <= A.size()+B.size()){\n\t\tfor(int i = 0 ; i < min( x , (ll)A.size() ) ; i ++){\n\t\t\tret[A[i]-'a'] += k;\n\t\t}\n\t\tfor(int i = A.size() ; i < x ; i ++){\n\t\t\tret[B[i-A.size()]-'a'] += k;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i = 0 ; i+1 < vec.size() ; i ++){\n\t\tif(vec[i+1].fr*A.size()+vec[i+1].sc*B.size() <= x)continue;\n\t\tll len = vec[i].fr*A.size() + vec[i].sc*B.size();\n\t\tfor(int j = 0 ; j < 26 ; j ++){\n\t\t\tret[j] += cnt_A[j]*vec[i].fr*k;\n\t\t\tret[j] += cnt_B[j]*vec[i].sc*k;\n\t\t}\n\t\tcnt(x-len,k);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tll l,r;\n\tcin >> str.S;\n\tcin >> l >> r;\n\t\n\t/*str.sa_init();\n\tA = \"\";\n\tfor(int i = str.S.size()/2+1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tA = str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}*/\n\tA = str.S.substr(0,str.S.size()/2);\n\tstr.S = A;\n\tstr.sa_init();\n\tfor(int i = 1 ; i <= str.S.size() ; i ++){\n\t\tif(str.eq(0,i,str.S.size()-i)){\n\t\t\tB = str.S.substr(0,i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//cout << A << \" \" << B << endl;\n\t\n\tvec.push_back(P(0,1));\n\tvec.push_back(P(1,0));\n\twhile(1){\n\t\tP p;\n\t\tp.fr = vec[vec.size()-2].fr + vec[vec.size()-1].fr;\n\t\tp.sc = vec[vec.size()-2].sc + vec[vec.size()-1].sc;\n\t\tvec.push_back(p);\n\t\tif(p.fr*A.size()+p.sc*B.size() > r)break;\n\t}\n\tfor(int i = 0 ; i < A.size() ; i ++){\n\t\tcnt_A[A[i]-'a'] ++;\n\t}\n\tfor(int i = 0 ; i < B.size() ; i ++){\n\t\tcnt_B[B[i]-'a'] ++;\n\t}\n\t\n\tcnt(r,1);\n\tcnt(l-1,-1);\n\tfor(int i = 0 ; i < 26 ; i ++){\n\t\tprintf(\"%lld%c\",ret[i],(i==25)?'\\n':' ');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[888888],sz,pos,g,cnt[28][222222],p[28][444444],q[28][888888];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[222222];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool f=0;\n\tfor (int i=1;i<sz;i++) \n\t{\n\t\tif (z[i]+i==sz) f=1;\n\t}\n\tif (!f) g=sz;\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nvector<int>Z(char *s)\n{\n\tvector<int>z(1000010);\n\tint l=0,r=0;\n\tint ln=strlen(s);\n\tfor(int k=2;k<=ln;k++)\n\t{\n\t\tif(s[k-1]!=s[0])continue;\n\t\tif(k>r)\n\t\t{\n\t\t\tl=r=k;\n\t\t\twhile(r<=ln && s[r-1]==s[r-l])r++;\n\t\t\tr--;\n\t\t\tz[k]=r+1-l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tk=k+1-l;\n\t\t\tif(z[tk]<r+1-k)\n\t\t\t{\n\t\t\t\tz[k]=z[tk];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=k;\n\t\t\t\twhile(r<=ln && s[r-1]==s[r-l])r++;\n\t\t\t\tr--;\n\t\t\t\tz[k]=r+1-l;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nchar s[200010];\nlong long l,r;\nint p;\nint n;\nlong long sum[200010][26];\nlong long gtans(long long x,int y)\n{\n\tif(x<=n)return sum[x][y];\n\tif(x<=2*n)return sum[x-n][y]+sum[n][y];\n\tlong long s1=sum[n][y]+sum[p][y],s2=sum[n][y],a=n+p,b=n;\n\twhile(x>a+b)\n\t{\n\t\ts1+=s2;s2=s1-s2;a+=b;b=a-b;\n\t}\n\treturn s1+gtans(x-a,y);\n}\nlong long solve(long long x,int y)\n{\n\tif(x<=n)return sum[x][y];\n\tif(n%p==0)\n\t{\n\t\tlong long t=(x-n)/(long long)p*sum[p][y]+sum[n][y];\n\t\tx%=(long long)p;\n\t\treturn t+sum[x][y];\n\t}\n\telse return gtans(x,y);\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tn=strlen(s)/2;\n\tvector<int>res=Z(s);\n\tfor(int i=n+2;i<=strlen(s);i++)\n\t{\n\t\tif(res[i]==strlen(s)+1-i)\n\t\t{\n\t\t\tp=res[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tp=n-p;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<26;j++)sum[i][j]+=sum[i-1][j];\n\t\tsum[i][s[i-1]-'a']++;\n\t}\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",solve(r,i)-solve(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\n\ntemplate<class Iter> vector<int>Z_Algorithm(Iter a, Iter a_end) {\n    int n = a_end - a;\n    vector<int>z(n);\n    int l = 0, r = 0;\n    for (int i=1; i<n; i++) {\n\tif (i > r) {\n\t    l = r = i;\n\t    while (r<n && a[r-l] == a[r]) r++;\n\t    z[i] = r-l; r--;\n\t} else {\n\t    int k = i-l;\n\t    if (z[k] < r-i+1) z[i] = z[k];\n\t    else {\n\t\tl = i;\n\t\twhile (r<n && a[r-l] == a[r]) r++;\n\t\tz[i] = r-l; r--;\n\t    }\n\t}\n    }\n    return z;\n}\nconst int LEVEL = 100;\nconst LL INF = 1LL<<61;\nint N;\nchar S[200011];\nLL C[LEVEL][26];\nLL len[LEVEL];\nLL ans[26];\n\nvoid F(LL R, int sgn) {\n    for (int i=LEVEL-1; i>=2; i--) {\n\tif (len[i] <= R) {\n\t    REP (t, 26) ans[t] += C[i][t] * sgn;\n\t    R -= len[i];\n\t}\n    }\n\n    assert(R <= N);\n    REP (i, R) ans[S[i]-'a'] += sgn;\n}\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    N /= 2;\n    VI z = Z_Algorithm(S, S+N);\n    \n    int pos = N;\n    for (int i=1; i<N; i++) if (i + z[i] == N) {\n\tpos = i;\n\tbreak;\n    }\n\n    len[0] = pos;\n    len[1] = N;\n    REP (i, N) {\n\tif (i < pos) C[0][S[i]-'a']++;\n\tC[1][S[i]-'a']++;\n    }\n    for (int i=2; i<LEVEL; i++) {\n\tlen[i] = min(INF, len[i-1] + len[i-2]);\n\tREP (t, 26) C[i][t] = C[i-1][t] + C[i-2][t];\n    }\n//    puts(S);\n\n    LL l, r;\n    scanf(\"%lld%lld\", &l, &r);\n    assert(len[LEVEL-1] > r);\n    F(r, 1);\n    F(l-1, -1);\n\n    //puts(S);\n    //printf(\"%d %d\\n\", sep, pos);\n    rprintf(\"%lld\", ans, ans+26);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long z[888888],sz,pos,g,cnt[28][222222],p[28][222222],q[28][444444];\nlong long l,r,sp,sq,len[111],re,num[111],cur,res;\nchar s[222222];\nvoid z_func(int sz)\n{\n\tlong long l,r,j,k;\n\tl=0;r=0;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (i>r)\n\t\t{\n\t\t\tfor (j=0;j<sz;j++)\n\t\t\t{\n\t\t\t\tif (s[j]!=s[j+i]) break;\n\t\t\t}\n\t\t\tl=i;r=i+j-1;z[i]=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk=i-l;\n\t\t\tif (z[k]<r-i+1) \n\t\t\t{\n\t\t\t\tz[i]=z[k];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfor (j=r;j<sz;j++)\n\t\t\t\t{\n\t\t\t\t\tif (s[j]!=s[j-i]) break;\n\t\t\t\t}\n\t\t\t\tl=i;r=j-1;z[i]=r-l+1;\n\t\t\t}\n\t\t}\n\t}\n}\nlong long query(long long p,long long a)\n{\n\tif (p%g==0) return cnt[a][g-1]*(p/g);\n\treturn cnt[a][g-1]*(p/g)+cnt[a][(p-1)%g];\n}\nlong long calc(long long pos,long long a)\n{\n\tif (!pos) return 0;\n\tif (pos<=sq) return q[a][pos-1];\n\tlen[1]=sp;len[2]=sq;num[1]=p[a][sp-1];num[2]=q[a][sq-1];re=pos-sq;res=num[2];\n\tfor (int i=3;i<111;i++)\n\t{\n\t\tif (re<len[i-2])\n\t\t{\n\t\t\tcur=i-2;\n\t\t\tbreak;\n\t\t}\n\t\tlen[i]=len[i-1]+len[i-2];\n\t\tnum[i]=num[i-1]+num[i-2];\n\t\tres+=num[i-2];\n\t\tre-=len[i-2];\n\t}\n\twhile(cur>2)\n\t{\n\t\tif (re>=len[cur-1])\n\t\t{\n\t\t\tres+=num[cur-1];\n\t\t\tre-=len[cur-1];\n\t\t\tcur-=2;\n\t\t}\n\t\telse cur--;\n\t}\n\tif (!re) return res;\n\tif (cur==2) return res+q[a][re-1];\n\treturn res+p[a][re-1];\n}\nint main()\n{\n\tscanf(\"%s\",s);\n\tscanf(\"%lld%lld\",&l,&r);\n\tsz=strlen(s);\n\tz_func(sz);\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tif (z[i]+i==sz && sz%i==0)\n\t\t{\n\t\t\tz_func(i);g=i;\n\t\t\tfor (int j=1;j<i;j++) \n\t\t\t{\n\t\t\t\tif (z[j]+j==i) g=0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool f=0;\n\tfor (int i=1;i<sz;i++) \n\t{\n\t\tif (z[i]+i==sz) f=1;\n\t}\n\tif (!f) g=sz;\n\tif (g)\n\t{\n\t\tcnt[s[0]-'a'][0]=1;\n\t\tfor (int i=1;i<g;i++) \n\t\t{\n\t\t\tfor (int j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tif (j==s[i]-'a') cnt[j][i]=cnt[j][i-1]+1;\n\t\t\t\telse cnt[j][i]=cnt[j][i-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<26;i++)\n\t\t{\n\t\t\tprintf(\"%lld \",query(r,i)-query(l-1,i));\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tz_func(sz);\n\tp[s[0]-'a'][0]=sp=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tp[j][i]=p[j][i-1];\n\t\t}\n\t\tp[s[i]-'a'][i]++;\n\t\tsp++;\n\t}\n\tfor (int i=sz/2+1;i<sz;i++)\n\t{\n\t\tif (i+z[i]==sz)\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i=sz-pos;i<pos;i++)\n\t{\n\t\ts[sz++]=s[i];\n\t}\n\tq[s[0]-'a'][0]=sq=1;\n\tfor (int i=1;i<sz;i++)\n\t{\n\t\tfor (int j=0;j<26;j++)\n\t\t{\n\t\t\tq[j][i]=q[j][i-1];\n\t\t}\n\t\tq[s[i]-'a'][i]++;\n\t\tsq++;\n\t}\n\tfor (int i=0;i<26;i++)\n\t{\n\t\tprintf(\"%lld \",calc(r,i)-calc(l-1,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nvector<ll> z_algorithm(const string& S){\n  const ll n=S.length();\n  vector<ll> A(n);\n  A[0] = n;\n  int i = 1, j = 0;\n  while (i < n) {\n    while (i+j < n && S[j] == S[i+j]) ++j;\n    A[i] = j;\n    if (j == 0) { ++i; continue;}\n    ll k = 1;\n    while (i+k < n && k+A[k] < j) A[i+k] = A[k], ++k;\n    i += k; j -= k;\n  }\n  return A;\n}\n\nstruct alpha{\n  vector<ll> cnt;\n  ll sum;\n};\nalpha operator+(const alpha& a,const alpha& b){\n  vector<ll> ncnt(26,0);\n  ll nsum=0;\n  rep(i,26){\n    ncnt[i]=a.cnt[i]+b.cnt[i];\n    nsum+=ncnt[i];\n  }\n  return (alpha){ncnt,nsum};\n}\n\nalpha alphas[101];\n\nalpha calc2(const string& sa,const string& sb,ll i,ll len){\n  if(i==0){\n    vector<ll> cnt(26,0);\n    ll sum=0;\n    rep(j,len){\n      cnt[sb[j]-'a']++; sum++;\n    }\n    return (alpha){cnt,sum};\n  }else if(i==1){\n    vector<ll> cnt(26,0);\n    ll sum=0;\n    rep(j,len){\n      cnt[sa[j]-'a']++; sum++;\n    }\n    return (alpha){cnt,sum};\n  }else{\n    if(alphas[i-1].sum>=len){\n      return calc2(sa,sb,i-1,len);\n    }else{\n      return alphas[i-1]+calc2(sa,sb,i-2,len-alphas[i-1].sum);\n    }\n  }\n}\n\nalpha calc(const string& S, const string& sa,const string& sb, ll len){\n  if(len<=(ll)S.size()){\n    vector<ll> cnt(26,0);\n    ll sum=0;\n    rep(i,len){\n      cnt[S[i]-'a']++; sum++;\n    }\n    return (alpha){cnt,sum};\n  }\n  ll crt=0;\n  alpha res=alphas[1];\n  while(res.sum+alphas[crt].sum<len){\n    res=res+alphas[crt];\n    crt++;\n  }\n  res=res+calc2(sa,sb,crt,len-res.sum);\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string S;\n  cin>>S;\n  int N=S.size();\n  S=S.substr(0,N/2);\n  N/=2;\n  vector<ll> Z=z_algorithm(S);\n\n  int L=N;\n  repl(i,1,N){\n    if(Z[i]==N-i){\n      L=i; break;\n    }\n  }\n\n  alpha A,B;\n  A.cnt.resize(26,0); A.sum=0;\n  B.cnt.resize(26,0); B.sum=0;\n  rep(i,L){\n    A.cnt[S[i]-'a']++; A.sum++;\n  }\n  repl(i,L,N){\n    B.cnt[S[i]-'a']++; B.sum++;\n  }\n  alphas[0]=B; alphas[1]=A;\n  repl(i,2,100){\n    if(alphas[i-1].sum<2e18&&alphas[i-2].sum<2e18) alphas[i]=alphas[i-1]+alphas[i-2];\n    else break;\n  }\n\n  ll l,r;\n  cin>>l>>r;\n  l--;\n  alpha resl=calc(S,S.substr(0,L),S.substr(L,N-L),l);\n  alpha resr=calc(S,S.substr(0,L),S.substr(L,N-L),r);\n  rep(i,26)cout<<resr.cnt[i]-resl.cnt[i]<<\" \";\n  cout<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=1e5+7;\n\nchar s[N];\nint len,n,m;\nll L,R;\nint app[N][26],p[N];\n\nll count(ll a,ll b)\n{\n\tif(a<=(n<<1))return a<=n?app[a][b]:app[n][b]+app[a-n][b];\n\tll f1=n,f2=m,k1=app[n][b],k2=app[m][b],k3,f3;\n\twhile(f1*2<a){\n\t\tf3=f1+f2; f2=f1; f1=f3;\n\t\tk3=k1+k2; k2=k1; k1=k3;\n\t}\n\treturn k3+count(a-f1,b);\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tlen=strlen(s+1); n=len>>1;\n\tcin>>L>>R; --L;\n\tfo(i,1,n){\n\t\tfo(l,0,25)app[i][l]=app[i-1][l];\n\t\t++app[i][s[i]-97];\n\t}\n\tfor(int j=0,i=2;i<=n;++i){\n\t\twhile(j!=0&&s[j+1]!=s[i])j=p[j];\n\t\tif(s[j+1]==s[i])++j;\n\t\tp[i]=j;\n\t}\n\tm=n-p[n];\n\tfo(i,0,25)printf(\"%lld \",count(R,i)-count(L,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nmap<pii, vector<ll> >ma;\nvector<int>zalgo(string s)\n{\n\tvector<int>ret;\n\tif (s.empty())return ret;\n\tret.resize(s.size());\n\tret[0] = s.size();\n\tint now = 1, pt = 0;\n\tfor (;;)\n\t{\n\t\tif (now == s.size())break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + pt == s.size())break;\n\t\t\tif (s[now + pt] == s[pt])pt++;\n\t\t\telse break;\n\t\t}\n\t\tret[now] = pt;\n\t\tint idx = 1;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now + idx == s.size())break;\n\t\t\tif (ret[idx] < ret[now] - idx)ret[idx + now] = ret[idx], idx++;\n\t\t\telse break;\n\t\t}\n\t\tnow += idx, pt -= idx;\n\t\tif (pt < 0)pt = 0;\n\t}\n\treturn ret;\n}\nstring conv(string s)\n{\n\tvector<int>z = zalgo(s);\n\t//for (int i = 0; i < s.size(); i++)printf(\"%d \", z[i]); printf(\"\\n\");\n\tfor (int i = (s.size() + 3) / 2; i < s.size(); i++)\n\t{\n\t\tif (z[i] == s.size() - i)\n\t\t{\n\t\t\tfor (int j = s.size() - i; j < i; j++)s.push_back(s[j]);\n\t\t\treturn s;\n\t\t}\n\t}\n\tint a = s.size();\n\tfor (int j = 0; j < a; j++)s.push_back(s[j]);\n\treturn s;\n}\nll len[1000];\nint rui[2000000][26];\nstring s;\nvector<ll>dfs(ll x, int pt)\n{\n\tif (ma.count(make_pair(x, pt)))return ma[make_pair(x, pt)];\n\tif (pt == 0)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)v.push_back(rui[x][i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\tif (len[pt - 1] < x)\n\t{\n\t\tvector<ll>v;\n\t\tvector<ll>v1 = dfs(len[pt - 1], pt - 1), v2 = dfs(x - len[pt - 1], pt - 1);\n\t\tfor (int i = 0; i < 26; i++)v.push_back(v1[i] + v2[i]);\n\t\treturn ma[make_pair(x, pt)] = v;\n\t}\n\treturn ma[make_pair(x, pt)] = dfs(x, pt - 1);\n}\nvector<ll>get(ll t, bool fff)\n{\n\tif (fff)\n\t{\n\t\tvector<ll>v;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tv.push_back(t / s.size()*rui[s.size()][i] + rui[t%s.size()][i]);\n\t\t}\n\t\treturn v;\n\t}\n\tint rr = 0;\n\tfor (int i=0;;i++)\n\t{\n\t\tif (len[i] >= t)\n\t\t{\n\t\t\trr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dfs(t, rr);\n}\nint main()\n{\n\tcin >> s;\n\tll lf, rf;\n\tscanf(\"%lld%lld\", &lf, &rf);\n\tbool fff = true;\n\ts = conv(s);\n\tstring s2 = conv(s);\n\tstring s3 = conv(s2);\n\tvector<int>v = zalgo(s);\n\tfor (int i = v.size() / 2 + 2; i < v.size(); i++)\n\t{\n\t\tif (i + v[i] == v.size())\n\t\t{\n\t\t\tif ((v.size() / 2) % (i - v.size() / 2) != 0)fff = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen[0] = s.size();\n\tlen[1] = s2.size();\n\tlen[2] = s3.size();\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < 26; j++)\n\t\t{\n\t\t\trui[i + 1][j] = rui[i][j] + (s[i] == 'a' + j);\n\t\t}\n\t}\n\tfor (int i = 3; i < 1000; i++)\n\t{\n\t\tll d1 = (len[i - 3] + len[i - 3] - len[i - 2]) / 2;\n\t\tll d2 = (len[i - 2] + len[i - 2] - len[i - 1]) / 2;\n\t\tlen[i] = len[i - 1] + len[i - 1] - (d1 + d2) * 2;\n\t\t//if (i <= 20)printf(\"%lld\\n\", len[i - 2]);\n\t}\n\tvector<ll>v1 = get(rf, fff), v2 = get(lf - 1, fff);\n\tfor (int i = 0; i < 26; i++)printf(\"%lld \", v1[i] - v2[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "// see https://github.com/LumaKernel/vimfiles/tree/master/snippets/cp-cpp/temp.snip\nconst bool DEBUG = 0;\n/// --- .lumrc Template {{{ ///\n#include <iostream>\n#include <vector>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n#include <random>\n#include <iomanip>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = tuple<ll, ll>;\nusing P3 = tuple<ll, ll, ll>;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VP = vector<P>;\nusing VS = vector<string>;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);++i)\n#define FORI(i,a,b) for(int i=int(a);i<=int(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPI(i,n) FORI(i,0,n)\n#define RFOR(i,a,b) for(int i=int(b)-1;i>=int(a);--i)\n#define RFORI(i,a,b) for(int i=int(b);i>=int(a);--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPI(i,n) RFORI(i,0,n)\n\n#define ALL(a) (a).begin(),(a).end()\n#define UNIQUE(a) (a).erase(unique(ALL(a)),(a).end())\n#define PB push_back\n#define EACH(i,c) REP(i,(c).size())\n#define REACH(i,c) RREP(i,(c).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n\n#define BR cout<<\"\\n\";\n\n#define dump(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)<<\"\\n\";\n#define dump2(x,y) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)<<\"\\n\";\n#define dump3(x,y,z) if(DEBUG)cerr<<\"[\"<<__LINE__<<\"] \"<<#x<<\"=\"<<(x)\\\n  <<\" , \"<<#y<<\"=\"<<(y)\\\n<<\" , \"<<#z<<\"=\"<<(z)<<\"\\n\";\n\n#define SAY(x) if(DEBUG) cerr<<\"[\"<<__LINE__<< \"] \"<<(x)<<\"\\n\";\n\n#define YES(x) cout<<((x)?\"YES\":\"NO\")<<\"\\n\";\n#define Yes(x) cout<<((x)?\"Yes\":\"No\")<<\"\\n\";\n#define yes(x) cout<<((x)?\"yes\":\"no\")<<\"\\n\";\n\ninline int omajinai_int_in(){omajinai;int n;cin>>n;return n;}\ninline ll omajinai_ll_in(){omajinai;ll n;cin>>n;return n;}\ninline string omajinai_string_in(){omajinai;string n;cin>>n;return n;}\ninline int int_in(){int n;cin>>n;return n;}\ninline ll ll_in(){ll n;cin>>n;return n;}\ninline string string_in(){string n;cin>>n;return n;}\n#define oini omajinai_int_in()\n#define oinl omajinai_ll_in()\n#define oins omajinai_string_in()\n#define ini int_in()\n#define inl ll_in()\n#define ins string_in()\n\n#define isInside(y,x) (0<=(y)&&(y)<h&&0<=(x)&&(x)<w)\n\n#define fi(x) (get<0>(x))\n#define se(x) (get<1>(x))\n#define th(x) (get<2>(x))\n#define fo(x) (get<3>(x))\n#define fif(x) (get<4>(x))\n\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; EACH(i, v) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\n\ntemplate <typename T> inline void smax(T &a, T b) { a = a > b ? a : b; }\ntemplate <typename T> inline void smin(T &a, T b) { a = a < b ? a : b; }\n\n/// }}}--- ///\n\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\nconstexpr int MOD = 1e9+7;\n\nstring s = ins;\nint n = s.size() / 2;\n\nll ans;\nint k = 0;\nconst int N = 1e6;\narray<ll, 27> cnt[N];\nconst int MAXS = 10000;\narray<ll, 27> SS[MAXS];\nint SSLength;\n\narray<ll, 27> add(array<ll, 27> a, array<ll, 27> b, bool minus = false) {\n  REP(i, 27) {\n    a[i] += b[i] * (minus ? -1 : 1);\n  }\n  return a;\n}\n\narray<ll, 27> solve(ll x) {\n  array<ll,27> res;\n  if(x <= n) {\n    return cnt[x];\n  }\n  array<ll,27> search;\n  search[0] = x;\n  search[1] = LINF;\n\n  int p = lower_bound(SS, SS + SSLength, search) - SS;\n  p--;\n  assert(p>=0);\n  // dump2(x, SS[p][0]);\n  // dump2(p, SSLength);\n  return add(SS[p], solve(x - SS[p][0]));\n}\n\null upow(ull a, ull b) {\n  ull res = 1;\n  while(b) {\n    if(b&1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nconst ull B = 1e8+7;\n\nint main() {\n  // ローリングハッシュ法で前半k文字と後半k文字で一致する\n  // ような最大のkを求める\n  dump(2);\n  ull backHash = 0;\n  ull forwardHash = 0;\n  REP(i, n-1) {\n    backHash *= B;\n    backHash += s[i]-'a';\n    forwardHash += upow(B, i) * (s[n-1-i]-'a');\n    if(backHash == forwardHash) k = i + 1;\n  }\n  dump(k);\n  \n  dump(3);\n  ll l=inl, r=inl;\n  dump2(l, s);\n  \n  FOR(i, 1, n+1) {\n    cnt[i] = cnt[i-1];\n    cnt[i][0]++;\n    cnt[i][1+s[i-1]-'a']++;\n  }\n\n  REP(i, n-k) {\n    SS[0][0]++;\n    SS[0][1+s[i]-'a']++;\n  }\n  FOR(i, n-k, n) {\n    SS[1][0]++;\n    SS[1][1+s[i]-'a']++;\n  }\n  dump(4);\n  SSLength = MAXS;\n  FOR(i, 2, MAXS) {\n    REP(j, i-2+1) {\n      SS[i] = add(SS[i], SS[j]);\n      if(SS[i][0]>LINF) {\n        SSLength = i;\n        break;\n      }\n    }\n    if(SSLength!=MAXS) break;\n  }\n  \n  dump(1);\n  dump(r);\n  auto ans = add(solve(r), solve(l-1), true);\n  \n\n  dump(7);\n  REP(i, 26) {\n    cout << ans[i+1] << (i!=int(ans.size()-1)?\" \":\"\\n\");\n  }\n}\n\n//\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(2)\n#include<set>    \n#include<map>    \n#include<stack>    \n#include<ctime>    \n#include<cstdio>    \n#include<queue>    \n#include<cmath>    \n#include<vector>    \n#include<cstring>   \n#include<climits>    \n#include<iostream>   \n#include<algorithm>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\nLL read(){\n    LL f=1,x=0;char c=getchar();\n    while(c<'0'||'9'<c){if(c=='-')f=-1;c=getchar();}\n    while('0'<=c&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return f*x;\n}\n#define INF (LL)(1e18)\n#define MAXN 2000000\nLL f[100],g[100][26],s0[MAXN+5][26],s1[MAXN+5][26],sum[26];\nchar S[MAXN+5];\nint nxt[MAXN+5],siz=1;\nvoid Climb(LL m,int s){\n\tint p=siz;\n\twhile(p>1){\n\t\tif(f[p-1]<=m){//&&m<=f[p]\n\t\t\tm-=f[p-1];\n\t\t\tfor(int c=0;c<26;c++)\n\t\t\t\tsum[c]+=s*g[p-1][c];\n\t\t\tp-=2;\n\t\t}\n\t\telse\n\t\t\tp--;\n\t}\n\tif(f==0){\n\t\tfor(int c=0;c<26;c++)\n\t\t\tsum[c]+=s*s0[m][c];\n\t}\n\telse{\n\t\tfor(int c=0;c<26;c++)\n\t\t\tsum[c]+=s*s1[m][c];\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%s\",S+1);\n\tint n=strlen(S+1)/2;\n\tf[0]=n;\n\tLL L=read(),R=read();\n\tfor(int i=1;i<=n;i++){\n\t\tmemcpy(s0[i],s0[i-1],sizeof(s0[i-1])),s0[i][S[i]-'a']++;\n\t\tmemcpy(s1[i],s1[i-1],sizeof(s1[i-1])),s1[i][S[i]-'a']++;\n\t\tg[0][S[i]-'a']++,g[1][S[i]-'a']++;\n\t}\n\tfor(int i=2,j=0;i<=n;i++){\n\t\twhile(j!=0&&S[i]!=S[j+1])\n\t\t\tj=nxt[j];\n\t\tif(S[i]==S[j+1])\n\t\t\tj++;\n\t\tnxt[i]=j;\n\t}\n\tif(n%(n-nxt[n])==0){\n\t\tfor(int c=0;c<26;c++)\n\t\t\tsum[c]=(R/n*s0[n][c]+s0[R%n][c])-((L-1)/n*s0[n][c]+s0[(L-1)%n][c]);\n\t\tfor(int c=0;c<26;c++)\n\t\t\tprintf(\"%lld\",sum[c]),putchar(c==25?'\\n':' ');\n\t\treturn 0;\n\t}\n\tf[1]=f[0]+n-nxt[n];\n\tfor(int i=1;i<=n-nxt[n];i++){\n\t\tmemcpy(s1[i+n],s1[i+n-1],sizeof(s1[i+n-1])),s1[i+n][S[i]-'a']++;\n\t\tg[1][S[i]-'a']++;\n\t}\n\twhile(f[siz]<=INF){\n\t\t++siz;\n\t\tf[siz]=f[siz-1]+f[siz-2];\n\t\tfor(int c=0;c<26;c++)\n\t\t\tg[siz][c]=g[siz-1][c]+g[siz-2][c];\n\t}\n\tClimb(R,1),Climb(L-1,-1);\n\tfor(int c=0;c<26;c++)\n\t\tprintf(\"%lld\",sum[c]),putchar(c==25?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=200005;\nconst int maxm=30;\nll l,r;\nint n,len;\nstring s;\nint cnt[maxn][maxm],z[maxn];\nll ans[maxm];\n\nvoid Z_algorithm(){\n\tz[0]=0;\n\tint L=0,R=0;\n\tREP(i,n-1){\n\t\tif(R<=i){\n\t\t\tfor(int j=0;i+j<n;j++)\n\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\telse break;\n\t\t\tif(z[i])L=i,R=i+z[i]-1; \n\t\t} \n\t\telse{\n\t\t\tif(i>L&&i<R&&z[i-l]<=r-i)z[i]=z[i-l];\n\t\t\telse{\n\t\t\t\tz[i]=r-i;\n\t\t\t\tfor(int j=r-i;i+j<n;j++)\n\t\t\t\tif(s[j]==s[i+j])z[i]++;\n\t\t\t\telse break;\n\t\t\t\tif(z[i])L=i,R=i+z[i]-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline vector<ll>add_vector(vector<ll>a,vector<ll>b){\n\trep(i,26)b[i]+=a[i];\n\treturn b;\n}\n\nll solve(ll l_len,vector<ll>L,ll r_len,vector<ll>R,ll rest,vector<ll>&Ans){\n\tif(l_len+r_len<=rest){\n\t\tvector<ll>sum=add_vector(L,R);\n\t\tll x=solve(l_len+r_len,sum,l_len,L,rest,Ans);\n\t\trest=x;\n\t}\n\tif(l_len<=rest){\n\t\tAns=add_vector(Ans,L);\n\t\trest-=l_len;\n\t}\n\treturn rest;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>s>>l>>r;\n\tl--;r--;\n\ts=s.substr(0,s.size()/2);\n\tn=s.size();\n\t\n\trep(i,n){\n\t\trep(j,26){\n\t\t\tif(s[i]-'a'==j)cnt[i][j]=!i?1:cnt[i-1][j]+1;\n\t\t\telse cnt[i][j]=!i?0:cnt[i-1][j];\n\t\t}\n\t}\n\t\n\tZ_algorithm();\n\tlen=-1;\n\trep(i,n)if(z[i]+i==n)len=max(len,i);\n\n\tif(len==-1){\n\t\trep(j,26){\n\t\t\tans[j]+=(ll)cnt[n-1][j]*(r/(ll)n)+(ll)cnt[r%(ll)n][j];\n\t\t\tif(l-1>=0)ans[j]-=(ll)cnt[n-1][j]*((l-1)/(ll)n)+(ll)cnt[(l-1)%(ll)n][j];\n\t\t}\n\t\trep(j,26)cout<<ans[j]<<' ';\n\t\treturn 0;\n\t}\n\t\n/*\telse{\n\t\tvector<ll>L(maxm),R(maxm);\n\t\trep(i,26)L[i]=cnt[len-1][i];\n\t\trep(i,26)R[i]=cnt[n-1][i]-cnt[len-1][i];\n\t\tvector<ll>Ans1(maxm),Ans2(maxm);\n\t\tll x1=solve(len,L,n-len,R,r+1,Ans1);\n\t\tll x2=solve(len,L,n-len,R,l,Ans2);\n\t\trep(i,26){\n\t\t\tans[i]+=Ans1[i]-Ans2[i];\n\t\t\tif(x1>=1)ans[i]+=(ll)cnt[x1-1][i];\n\t\t\tif(x2>=1)ans[i]-=(ll)cnt[x2-1][i];\n\t\t}\n\t\trep(i,26)cout<<ans[i]<<\" \";\n\t\treturn 0;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nstruct rolling_hash {\n    static constexpr int size = 4;\n    static const int32_t prime[size];\n    static int32_t base[size];\n    static struct base_initializer_t {\n        base_initializer_t() {\n            random_device device;\n            default_random_engine gen(device());\n            REP (i, size) {\n                base[i] = uniform_int_distribution<int32_t>(256, prime[i] - 1)(gen);\n            }\n        }\n    } base_initializer;\npublic:\n    array<int32_t, size> data;\n    rolling_hash() : data({}) {}\n    rolling_hash(char c) {\n        REP (i, size) data[i] = c;\n    }\n    void push_back(char c) {\n        REP (i, size) {\n            data[i] = (data[i] *(int64_t) base[i] + c) % prime[i];\n        }\n    }\n    rolling_hash & operator -= (rolling_hash const & other) {\n        REP (i, size) {\n            data[i] -= other.data[i];\n            if (data[i] < 0) data[i] += prime[i];\n        }\n        return *this;\n    }\n    rolling_hash & operator <<= (array<int32_t, size> const & pow_base) {\n        REP (i, size) {\n            data[i] = data[i] *(int64_t) pow_base[i] % prime[i];\n        }\n        return *this;\n    }\n    bool operator == (rolling_hash const & other) const {\n        return equal(ALL(data), other.data.begin());\n    }\n    bool operator != (rolling_hash const & other) const {\n        return not (*this == other);\n    }\n};\nconst int32_t rolling_hash::prime[size] = { 1000000027, 1000000033, 1000000087, 1000000093 };\nint32_t rolling_hash::base[size];\nrolling_hash::base_initializer_t rolling_hash::base_initializer;\n\nstruct rolling_hash_cumulative_sum {\n    rolling_hash_cumulative_sum() = default;\n    int size;\n    vector<rolling_hash> data;\n    vector<array<int32_t, rolling_hash::size> > pow_base;\n    rolling_hash_cumulative_sum(string const & s) {\n        size = s.length();\n        data.resize(size + 1);\n        data[0] = rolling_hash();\n        REP (i, size) {\n            data[i + 1] = data[i];\n            data[i + 1].push_back(s[i]);\n        }\n        pow_base.resize(size + 1);\n        fill(ALL(pow_base[0]), 1);\n        REP (i, size) {\n            REP (j, rolling_hash::size) {\n                pow_base[i + 1][j] = pow_base[i][j] *(int64_t) rolling_hash::base[j] % rolling_hash::prime[j];\n            }\n        }\n    }\n    rolling_hash get_range(int l, int r) {\n        assert (0 <= l and l <= r and r <= size);\n        return rolling_hash(data[r]) -= (rolling_hash(data[l]) <<= pow_base[r - l]);\n    }\n};\n\ntemplate <class Func>\nvoid enumerate_cycles(string const & s, Func func) {\n    rolling_hash_cumulative_sum hash(s);\n    REP3 (cycle, 1, s.length() + 1) {\n        bool is_cycle = true;\n        auto x = hash.get_range(0, cycle);\n        int i = cycle;\n        for (; i + cycle < s.length() and is_cycle; i += cycle) {\n            auto y = hash.get_range(i, i + cycle);\n            if (x != y) is_cycle = false;\n        }\n        if (is_cycle) {\n            auto y = hash.get_range(i, s.length());\n            auto z = hash.get_range(0, s.length() - i);\n            if (y != z) is_cycle = false;\n        }\n        if (is_cycle) {\n            if (not func(cycle)) {\n                return;\n            }\n        }\n    }\n}\n\nstring delta_f(string const & s) {\n    int result_cycle = s.length();\n    int result_delta_length = s.length();\n    enumerate_cycles(s, [&](int cycle) {\n        int a = s.length() / cycle;\n        int b = s.length() % cycle;\n        int delta_length = 0;\n        if (b != 0) {\n            delta_length += cycle - b;\n            a += 1;\n        }\n        if (a % 2 == 1) {\n            delta_length += cycle;\n        }\n        if (delta_length == 0) {\n            delta_length += 2 * cycle;\n        }\n        if (delta_length < result_delta_length) {\n            result_delta_length = delta_length;\n            result_cycle = cycle;\n        }\n        return true;\n    });\n    int cycle = result_cycle;\n    int a = s.length() / cycle;\n    int b = s.length() % cycle;\n    string delta;\n    if (b != 0) {\n        delta += s.substr(b, cycle - b);\n        a += 1;\n    }\n    if (a % 2 == 1) {\n        delta += s.substr(0, cycle);\n    }\n    if (delta.length() == 0) {\n        delta += s.substr(0, cycle);\n        delta += s.substr(0, cycle);\n    }\n    return delta;\n}\n\narray<ll, 26> count_alphabets(string const & s) {\n    array<ll, 26> cnt = {};\n    for (char c : s) cnt[c - 'a'] += 1;\n    return cnt;\n}\narray<ll, 26> operator + (array<ll, 26> const & a, array<ll, 26> const & b) {\n    array<ll, 26> c;\n    REP (i, 26) c[i] = a[i] + b[i];\n    return c;\n}\narray<ll, 26> operator - (array<ll, 26> const & a, array<ll, 26> const & b) {\n    array<ll, 26> c;\n    REP (i, 26) c[i] = a[i] - b[i];\n    return c;\n}\nstring half(string const & s) {\n    assert (s.substr(0, s.length() / 2) == s.substr(s.length() / 2));\n    return s.substr(0, s.length() / 2);\n}\n\nint main() {\n    // input\n    string s; cin >> s;\n    ll l, r; cin >> l >> r; -- l;\n\n    // solve\n    s += delta_f(s);\n    string t = half(s);\n    string gt = half(s + delta_f(s));\n    vector<ll> len(2);\n    len[0] =  t.size();\n    len[1] = gt.size();\n    vector<array<ll, 26> > cnt(2);\n    cnt[0] = count_alphabets( t);\n    cnt[1] = count_alphabets(gt);\n    while (len.back() < 2 * r + 10000) {\n        int i = len.size();\n        len.push_back(len[i - 1] + len[i - 2]);\n        cnt.push_back(cnt[i - 1] + cnt[i - 2]);\n    }\n    function<array<ll, 26> (ll)> func = [&](ll r) {\n        if (r < len[0]) return count_alphabets(t.substr(0, r));\n        int i = 0;\n        while (len[i + 1] < r) ++ i;\n        return cnt[i] + func(r - len[i]);\n    };\n    auto result = func(r) - func(l);\n\n    // output\n    REP (i, 26) {\n        cout << result[i] << ' ';\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < (b); ++i)\n#define rrep(i,a,b) for(int i = b; i --> (a);)\n#define all(v) v.begin(),v.end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) (int)(v).size()\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nconst ll b = 2;//1342231LL;\n\nconst int mx = 2e5;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tvector<ll> pw(mx);\n\tpw[0] = 1;\n\trep(i,1,mx) pw[i] = pw[i-1]*b % md;\n\n\tstring s;\n\tcin >> s;\n\tint n = sz(s)/2;\n\tstring a = s.substr(0, n);\n\n\tvector<ll> pre(n+1);\n\trep(i,0,n) pre[i+1] = (pre[i]*b + a[i])%md;\n\n\tint len;\n\tfor(len = n; len --> 0;){\n\t\tif((pre[n]-pre[n-len]*pw[len]%md - pre[len])%md == 0)\n\t\t\tbreak;\n\t}\n\tll l, r;\n\tcin >> l >> r;\n\n\tvector<ll> fibs(200);\n\tfibs[0] = len, fibs[1] = n-len;\n\trep(i,2,200) fibs[i] = fibs[i-1] + fibs[i-2];\n\n\tvector<vector<ll>> cnts(200, vector<ll>(26));\n\trep(i,0,26) cnts[0][i] = count(a.begin(),a.begin()+len, 'a'+i);\n\trep(i,0,26) cnts[1][i] = count(a.begin()+len,a.end(), 'a'+i);\n\trep(i,2,200) rep(j,0,26) cnts[i][j] = cnts[i-1][j]+cnts[i-2][j];\n\n\tfunction<ll(ll,int,int)> que = [&](ll pos, int c, int ix){\n\t\tassert(fibs[ix] >= pos);\n\t\tif(ix == 0){\n\t\t\treturn (ll)count(a.begin(),a.begin()+pos, 'a'+c);\n\t\t}\n\t\tif(ix == 1){\n\t\t\treturn (ll)count(a.begin()+len,a.begin()+len+pos, 'a'+c);\n\t\t}\n\t\tif(pos <= fibs[ix-1]) return que(pos, c, ix-1);\n\t\treturn cnts[ix-1][c] + que(pos-fibs[ix-1],c,ix-2);\n\t};\n\n\tfunction<ll(ll,int)> f = [&](ll pos, int c){\n\t\tint i = 2;\n\t\twhile(fibs[i] < pos) ++i;\n\t\treturn que(pos, c, i);\n\t};\n\trep(c,0,26){\n\t\tcout << f(r,c) - f(l-1,c) << ' ';\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 200100\n#define MAXLOOP 300\n\nll l,r;\nll len[MAXLOOP];\nll ans[MAXLOOP][28];\nchar s1[MAXN];\nll final[28][2];\nint n;\nint z[MAXN];\n\nvoid getz(){\n\tint last = 0;\n\tfor(int i = 2;i <= n;i++){\n\t\twhile(last != 0  &&  s1[last+1] != s1[i])\n\t\t\tlast = z[last];\n\t\tif(s1[last+1] == s1[i]){\n\t\t\tlast++;\n\t\t\tz[i] = last;\n\t\t}\n\t}\n}\n\nvoid getans(ll endpos,int mem){\n\t//cout << endpos << \" \" << mem << endl;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << s1[i] << \" \";cout << endl;\n\t//for(int i = 0;i < n;i++)\n\t//\tcout << z[i] << \" \";cout << endl;\n\tint j = 0;\n\t//0 1 2 3 4 5 6 7 8 9 10 11 12 13\n\t/// v g x g p u a m k v  g  x  g\n\tgetz();\n\tlen[0] = n - z[n];\n\t//cout << len[0] << \" =-=-==-==-\" << endl;\n\tlen[1] = n;\n\tlen[2] = n + len[0];\n\tlen[0] = 0;\n\t//cout << len[1] << \" =-=-==-==-\" << endl;\n\tj = 3;\n\twhile(1){\n\t\tlen[j] = len[j-1] + len[j-2];\n\t\t//cout << len[j] << endl;\n\t\tif(len[j-1] + len[j-2] >= endpos) break;\n\t\tj++;\n\t}\n\tj--;\n\t//cout << j << \" PPPPPPPPPPPPPPPPPPPPPPPPPP\" << endl;\n\t//cout << \"END\" << endl;\n\t//for(int i = 0;i <= j;i++) cout << len[i] << \" \";cout << endl;\n\t\n\t\n\tll pos = endpos;\n\tfor(char let = 'a';let <= 'z';let++){\n\t\tpos = endpos;\n\t\tint intlet = let - 'a';\n\t\tans[1][intlet] = 0;\n\t\tfor(ll i = 1;i <= len[1];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[1][intlet]++;\n\t\tans[2][intlet] = 0;\n\t\tfor(ll i = 1;i <= len[2];i++)\n\t\t\tif(s1[i] == let)\n\t\t\t\tans[2][intlet]++;\n\t\tfor(ll i = 3;i <= j;i++)\n\t\t\tans[i][intlet] = ans[i-1][intlet] + ans[i-2][intlet];\n\t\tfor(ll i = j;i >= 0;i--){\n\t\t\tif(pos >= len[i]){\n\t\t\t\tpos -= len[i];\n\t\t\t\t//cout << pos << endl;\n\t\t\t\tfinal[intlet][mem] += ans[i][intlet];\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 1;i <= pos;i++){\n\t\t\tif(s1[i] == let){\n\t\t\t\tfinal[intlet][mem]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t//freopen(\"ss.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tscanf(\"%s\",s1+1);\n\tcin >> l >> r;\n\t\n\tn = strlen(s1+1);\n\t\n\tn /= 2;\n\t//cout << n << endl;\n\t\n\tms(final);\n\tif(l >= 2) getans(l-1,0);\n\tif(r >= 1) getans(r,1);\n\t\n\tfor(int i = 0;i < 26;i++)\n\t\tprintf(\"%lld \",final[i][1] - final[i][0]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5;\nconst int SIZE = 205;\nconst LL HMOD = 1e9 + 123, HBASE = 233;\n\nint N;\nLL L, R;\nchar S[MAXN];\n\nvoid input()\n{\n    scanf(\"%s\", S + 1);\n    read(L); read(R);\n    N = strlen(S + 1) / 2;\n}\n\nint maxlen;\nLL Flen[SIZE];\nLL cnt[SIZE];\nint M;\nint curc;\n\nLL count(LL d, LL n)\n{\n    if (d == 0) {\n        assert(n <= N - maxlen * 2);\n        LL ret = 0;\n        for (int j = 0; j < n; ++j) {\n            ret += (S[maxlen + 1 + j] == curc + 'a');\n        }\n        return ret;\n    }\n    if (d == 1) {\n        assert(n <= maxlen);\n        LL ret = 0;\n        for (int j = 0; j < n; ++j) {\n            ret += (S[1 + j] == curc + 'a');\n        }\n        return ret;\n    }\n    if (n > Flen[d - 1])\n        return cnt[d - 1] + count(d - 2, n - Flen[d - 1]);\n    else\n        return count(d - 1, n);\n}\n\nLL metacount(LL n)\n{\n    LL al = Flen[M - 1], bl = Flen[M - 2];\n    LL ac = cnt[M - 1], bc = cnt[M - 2];\n    LL ret = 0;\n    if (n <= al)\n        return count(M - 1, n);\n    n -= al; ret += ac;\n    if (n <= bl)\n        return count(M - 2, n);\n    n -= bl; ret += bc;\n    if (n <= al)\n        return count(M - 1, n);\n    n -= al; ret += ac;\n    if (n <= al)\n        return count(M - 1, n);\n    n -= al; ret += ac;\n    if (n <= bl)\n        return count(M - 2, n);\n    n -= bl; ret += bc;\n    if (n <= al)\n        return count(M - 1, n);\n    abort();\n}\n\nvoid solve()\n{\n    static LL hval[MAXN];\n\n    for (int i = 1; i <= N; ++i) {\n        hval[i] = (hval[i - 1] * HBASE + S[i] - 'a' + 1) % HMOD;\n    }\n\n    LL base = 1;\n    for (int i = 1; i * 2 <= N; ++i) {\n        (base *= HBASE) %= HMOD;\n        if (hval[i] == (hval[N] - hval[N - i] * base % HMOD + HMOD) % HMOD)\n            maxlen = i;\n    }\n\n    Flen[M++] = N - maxlen * 2;\n    Flen[M++] = maxlen;\n    for (; Flen[M - 1] <= 1e18; ++M) {\n        Flen[M] = Flen[M - 1] + Flen[M - 2];\n    }\n\n    // for (int i = 0; i < M; ++i) {\n    //     printf(\"%lld\\n\", Flen[i]);\n    // }\n\n    for (curc = 0; curc < 26; ++curc) {\n        std::fill(cnt, cnt + M, 0);\n        for (int j = 1; j <= maxlen; ++j) {\n            cnt[1] += (S[j] == curc + 'a');\n        }\n        for (int j = maxlen + 1; j < N - maxlen + 1; ++j) {\n            cnt[0] += (S[j] == curc + 'a');\n        }\n        for (int j = 2; j < M; ++j) {\n            cnt[j] = cnt[j - 1] + cnt[j - 2];\n        }\n        // for (int i = 0; i < 10; ++i) {\n        //     printf(\"%lld \", cnt[i]);\n        // }\n        // puts(\"\");\n\n        LL xr = metacount(R);\n        LL xl = metacount(L - 1);\n\n        // printf(\"%lld %lld\\n\", xr, xl);\n\n        printf(\"%lld \", xr - xl);\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 此生谁料，心在天山，身老沧洲。\n//     -- 陆游《诉衷情·当年万里觅封侯》\n"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst ll  inf=1e18;\nconst int maxn=2e5+10;\nconst int maxm=1e2+10;\nchar s[maxn];int n,lst,nxt[maxn],pre[maxn][26];\nll l,r,cutpos,ans[26],cnt[maxm],f[maxm][26];\nll read(){\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(ll x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(ll x){print(x);putchar(' ');}\nvoid get_nxt(){\n    nxt[1]=0;\n    for(int i=2,j;i<=n;i++){\n        j=nxt[i-1];\n        while(j&&s[j+1]!=s[i])j=nxt[j];\n        nxt[i]=s[j+1]==s[i]?j+1:0;\n    }\n}\nvoid cal1(ll x,ll v){\n    if(x<=0)return ;ll tmp=x/cutpos;\n    for(int i=0;i<26;i++)ans[i]+=v*tmp*pre[cutpos][i];\n    tmp=x%cutpos;\n    for(int i=0;i<26;i++)ans[i]+=v*pre[tmp][i];\n}\nvoid get_fib(){\n    cnt[1]=n;\n    for(int i=1;i<=n;i++){f[1][s[i]-'a']++;f[2][s[i]-'a']++;}\n    cnt[2]=n+cutpos;\n    for(int i=0;i<26;i++)f[2][i]+=pre[cutpos][i];\n    for(int i=3;;i++){\n        for(int j=0;j<26;j++)f[i][j]=f[i-2][j]+f[i-1][j];\n        cnt[i]=cnt[i-2]+cnt[i-1];if(cnt[i]>inf){lst=i;break;}\n    }\n}\nvoid cal2(ll x,ll v){\n    for(int i=lst;i>=1;i--)\n        if(cnt[i]<=x){\n            x-=cnt[i];\n            for(int j=0;j<26;j++)ans[j]+=v*f[i][j];\n        }\n    for(int i=0;i<26;i++)ans[i]+=v*pre[x][i];\n}\nint main(){\n    scanf(\"%s\",s+1);l=read();r=read();n=strlen(s+1);n>>=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<26;j++)pre[i][j]+=pre[i-1][j];\n        pre[i][s[i]-'a']++;\n    }get_nxt();cutpos=n-nxt[n];//write(cutpos);puts(\"\");\n    //if(!n%cutpos){cal1(r,1);cal1(l-1,-1);}\n    //else {get_fib();cal2(r,1);cal2(l-1,-1);}\n    get_fib();cal2(r,1);cal2(l-1,-1);\n    for(int i=0;i<26;i++)write(ans[i]);puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N\t200000\n#define A\t26\n#define K\t100\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint period(char *cc, int n) {\n\tstatic int zz[N];\n\tint i, l, r;\n\n\tfor (i = 1, l = r = 0; i < n; i++)\n\t\tif (zz[i - l] < r - i)\n\t\t\tzz[i] = zz[i - l];\n\t\telse {\n\t\t\tl = i, r = max(r, l);\n\t\t\twhile (r < n && cc[r] == cc[r - l])\n\t\t\t\tr++;\n\t\t\tzz[i] = r - l;\n\t\t}\n\tfor (i = 1; i < n; i++)\n\t\tif (zz[i] == n - i)\n\t\t\tbreak;\n\treturn i;\n}\n\nlong long ans[A];\n\nvoid solve(char *cc, int n, int m, long long r, int sign) {\n\tstatic long long len[K], cnt[K][A];\n\tint h, i, a, k;\n\n\tlen[0] = m, memset(cnt[0], 0, sizeof cnt[0]);\n\tfor (i = 0; i < m; i++)\n\t\tcnt[0][cc[i] - 'a']++;\n\tlen[1] = n, memset(cnt[1], 0, sizeof cnt[1]);\n\tfor (i = 0; i < n; i++)\n\t\tcnt[1][cc[i] - 'a']++;\n\tk = 2;\n\twhile (len[k - 1] < r) {\n\t\tlen[k] = len[k - 1] + len[k - 2];\n\t\tfor (a = 0; a < A; a++)\n\t\t\tcnt[k][a] = cnt[k - 1][a] + cnt[k - 2][a];\n\t\tk++;\n\t}\n\tfor (h = k - 1; h >= 0; h--)\n\t\tif (r >= len[h]) {\n\t\t\tfor (a = 0; a < A; a++)\n\t\t\t\tans[a] += cnt[h][a] * sign;\n\t\t\tr -= len[h];\n\t\t}\n}\n\nint main() {\n\tstatic char cc[N + 1];\n\tint n, m, i, a;\n\tlong long l, r;\n\n\tscanf(\"%s%lld%lld\", cc, &l, &r), n = strlen(cc) / 2, l--;\n\tm = period(cc, n);\n\tif (n % m == 0) {\n\t\twhile (l < r && l % m != 0)\n\t\t\tans[cc[l++ % m] - 'a']++;\n\t\twhile (l < r && r % m != 0)\n\t\t\tans[cc[--r % m] - 'a']++;\n\t\tfor (i = 0; i < m; i++)\n\t\t\tans[cc[i] - 'a'] += (r - l) / m;\n\t} else\n\t\tsolve(cc, n, m, r, 1), solve(cc, n, m, l, -1);\n\tfor (a = 0; a < A; a++)\n\t\tprintf(\"%lld \", ans[a]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N\t200000\n#define A\t26\n#define K\t100\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint period(char *cc, int n) {\n\tstatic int zz[N];\n\tint i, l, r;\n\n\tfor (i = 1, l = r = 0; i < n; i++)\n\t\tif (zz[i - l] < r - i)\n\t\t\tzz[i] = zz[i - l];\n\t\telse {\n\t\t\tl = i, r = max(r, l);\n\t\t\twhile (r < n && cc[r] == cc[r - l])\n\t\t\t\tr++;\n\t\t\tzz[i] = r - l;\n\t\t}\n\tfor (i = 1; i < n; i++)\n\t\tif (zz[i] == n - i)\n\t\t\tbreak;\n\treturn i;\n}\n\nlong long ans[A];\n\nvoid solve(char *cc, int n, int m, long long r, int sign) {\n\tstatic long long len[K], cnt[K][A];\n\tint h, i, a, k;\n\n\tlen[0] = m, memset(cnt[0], 0, sizeof cnt[0]);\n\tfor (i = 0; i < m; i++)\n\t\tcnt[0][cc[i] - 'a']++;\n\tlen[1] = n, memset(cnt[1], 0, sizeof cnt[1]);\n\tfor (i = 0; i < n; i++)\n\t\tcnt[1][cc[i] - 'a']++;\n\tk = 2;\n\twhile (len[k - 1] < r) {\n\t\tlen[k] = len[k - 1] + len[k - 2];\n\t\tfor (a = 0; a < A; a++)\n\t\t\tcnt[k][a] = cnt[k - 1][a] + cnt[k - 2][a];\n\t\tk++;\n\t}\n\tfor (h = k - 1; h >= 0; h--)\n\t\tif (r >= len[h]) {\n\t\t\tfor (a = 0; a < A; a++)\n\t\t\t\tans[a] += cnt[h][a] * sign;\n\t\t\tr -= len[h];\n\t\t}\n}\n\nint main() {\n\tstatic char cc[N + 1];\n\tint n, m, i, a;\n\tlong long l, r;\n\n\tscanf(\"%s%lld%lld\", cc, &l, &r), n = strlen(cc) / 2, l--;\n\tm = period(cc, n);\n\tif (n % m == 0) {\n\t\twhile (l <= r && l % m != 0)\n\t\t\tans[cc[l++ % m] - 'a']++;\n\t\twhile (l <= r && (r + 1) % m != 0)\n\t\t\tans[cc[r-- % m] - 'a']++;\n\t\tfor (i = 0; i < m; i++)\n\t\t\tans[cc[i] - 'a'] += (r - l) / m;\n\t} else\n\t\tsolve(cc, n, m, r, 1), solve(cc, n, m, l, -1);\n\tfor (a = 0; a < A; a++)\n\t\tprintf(\"%lld \", ans[a]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N\t200000\n#define A\t26\n#define K\t100\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint period(char *cc, int n) {\n\tstatic int zz[N];\n\tint i, l, r;\n\n\tfor (i = 1, l = r = 0; i < n; i++)\n\t\tif (zz[i - l] < r - i)\n\t\t\tzz[i] = zz[i - l];\n\t\telse {\n\t\t\tl = i, r = max(r, l);\n\t\t\twhile (r < n && cc[r] == cc[r - l])\n\t\t\t\tr++;\n\t\t\tzz[i] = r - l;\n\t\t}\n\tfor (i = 1; i < n; i++)\n\t\tif (zz[i] == n - i)\n\t\t\tbreak;\n\treturn i;\n}\n\nlong long ans[A];\n\nvoid solve(char *cc, int n, int m, long long r, int sign) {\n\tstatic long long len[K], cnt[K][A];\n\tint h, i, a, k;\n\n\tlen[0] = m, memset(cnt[0], 0, sizeof cnt[0]);\n\tfor (i = 0; i < m; i++)\n\t\tcnt[0][cc[i] - 'a']++;\n\tlen[1] = n, memset(cnt[1], 0, sizeof cnt[1]);\n\tfor (i = 0; i < n; i++)\n\t\tcnt[1][cc[i] - 'a']++;\n\tk = 2;\n\twhile (len[k - 1] < r) {\n\t\tlen[k] = len[k - 1] + len[k - 2];\n\t\tfor (a = 0; a < A; a++)\n\t\t\tcnt[k][a] = cnt[k - 1][a] + cnt[k - 2][a];\n\t\tk++;\n\t}\n\tfor (h = k - 1; h >= 0; h--)\n\t\tif (r >= len[h]) {\n\t\t\tfor (a = 0; a < A; a++)\n\t\t\t\tans[a] += cnt[h][a] * sign;\n\t\t\tr -= len[h];\n\t\t}\n\tfor (i = 0; i < r; i++)\n\t\tans[cc[i] - 'a'] += sign;\n}\n\nint main() {\n\tstatic char cc[N + 1];\n\tint n, m, i, a;\n\tlong long l, r;\n\n\tscanf(\"%s%lld%lld\", cc, &l, &r), n = strlen(cc) / 2, l--;\n\tm = period(cc, n);\n\tif (n % m == 0) {\n\t\twhile (l < r && l % m != 0)\n\t\t\tans[cc[l++ % m] - 'a']++;\n\t\twhile (l < r && r % m != 0)\n\t\t\tans[cc[--r % m] - 'a']++;\n\t\tfor (i = 0; i < m; i++)\n\t\t\tans[cc[i] - 'a'] += (r - l) / m;\n\t} else\n\t\tsolve(cc, n, m, r, 1), solve(cc, n, m, l, -1);\n\tfor (a = 0; a < A; a++)\n\t\tprintf(\"%lld \", ans[a]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t prevcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l > r) {\n\t\treturn -1;\n\t}\n\tif (l < r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptripleREVcomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll alp1[26], alp2[26];\null alpx[200][26], len[200];\n\nvoid mp (char s[], ull n, sll a[]) {\n\tsll i, j = -1;\n\ta[0] = -1;\n\tfor (i = 0; i < n; i++) {\n\t\twhile (j >= 0 && s[i] != s[j]) j = a[j];\n\t\tj++;\n\t\ta[i + 1] = j;\n\t}\n}\n\nvoid f (ull x, ull k, ull a[]) {\n\tif (x <= 1) {\n\t\tfor (sll i = 0; i < k; i++) {\n\t\t\ta[s[i] - 'a']++;\n\t\t}\n\t\treturn;\n\t}\n\n\t// printf(\"%llu: %llu (under: %llu + %llu)\\n\", x, k, len[x - 2], len[x - 1]);\n\t// fflush(stdout);\n\tif (len[x - 1] >= k) {\n\t\tf(x - 1, k, a);\n\t} else {\n\t\tfor (sll i = 0; i < 26; i++) {\n\t\t\ta[i] += alpx[x - 1][i];\n\t\t}\n\t\tf(x - 2, k - len[x - 1], a);\n\t}\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tn = strlen(s);\n\n\tmp(s, n, a);\n\ti = n;\n\twhile (i * 2 > n) i = a[i];\n\tm = n - i;\n\n\tull cycle = m - a[m];\n\n\tfor (i = 0; i < m; i++) {\n\t\talpx[1][s[i] - 'a']++;\n\t\tif (i < cycle) alpx[0][s[i] - 'a']++;\n\t}\n\tlen[0] = cycle;\n\tlen[1] = m;\n\n\t// printf(\"0: %llu\\n1: %llu\\n\", cycle, m);\n\t// fflush(stdout);\n\n\tull maxl = 1;\n\twhile (len[maxl] <= ub && ub - len[maxl] > len[maxl - 1]) {\n\t\tlen[maxl + 1] = len[maxl] + len[maxl - 1];\n\t\tfor (i = 0; i < 26; i++) {\n\t\t\talpx[maxl + 1][i] = alpx[maxl][i] + alpx[maxl - 1][i];\n\t\t}\n\t\t// printf(\"%llu: %llu\\n\", maxl + 1, len[maxl + 1]);\n\t\t// fflush(stdout);\n\n\t\tmaxl++;\n\t}\n\n\tf(maxl + 1, ub, alp1);\n\tf(maxl + 1, ua - 1, alp2);\n\n\tfor (i = 0; i < 26; i++) {\n\t\tprintf(\"%llu%c\", alp1[i] - alp2[i], (i == 25 ? '\\n' : ' '));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\tscanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\tscanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/* https://img.atcoder.jp/arc077/editorial.pdf */\n#include <stdio.h>\n#include <string.h>\n\n#define N\t200000\n#define A\t26\n#define K\t100\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint period(char *cc, int n) {\n\tstatic int zz[N];\n\tint i, l, r;\n\n\tfor (i = 1, l = r = 0; i < n; i++)\n\t\tif (zz[i - l] < r - i)\n\t\t\tzz[i] = zz[i - l];\n\t\telse {\n\t\t\tl = i, r = max(r, l);\n\t\t\twhile (r < n && cc[r] == cc[r - l])\n\t\t\t\tr++;\n\t\t\tzz[i] = r - l;\n\t\t}\n\tfor (i = 1; i < n; i++)\n\t\tif (zz[i] == n - i)\n\t\t\tbreak;\n\treturn i;\n}\n\nlong long ans[A];\n\nvoid solve(char *cc, int n, int m, long long r, int sign) {\n\tstatic long long len[K], cnt[K][A];\n\tint h, i, a, k;\n\n\tlen[0] = m, memset(cnt[0], 0, sizeof cnt[0]);\n\tfor (i = 0; i < m; i++)\n\t\tcnt[0][cc[i] - 'a']++;\n\tlen[1] = n, memset(cnt[1], 0, sizeof cnt[1]);\n\tfor (i = 0; i < n; i++)\n\t\tcnt[1][cc[i] - 'a']++;\n\tk = 2;\n\twhile (len[k - 1] < r) {\n\t\tlen[k] = len[k - 1] + len[k - 2];\n\t\tfor (a = 0; a < A; a++)\n\t\t\tcnt[k][a] = cnt[k - 1][a] + cnt[k - 2][a];\n\t\tk++;\n\t}\n\tfor (h = k - 1; h >= 0; h--)\n\t\tif (r >= len[h]) {\n\t\t\tfor (a = 0; a < A; a++)\n\t\t\t\tans[a] += cnt[h][a] * sign;\n\t\t\tr -= len[h];\n\t\t}\n\tfor (i = 0; i < r; i++)\n\t\tans[cc[i] - 'a'] += sign;\n}\n\nint main() {\n\tstatic char cc[N + 1];\n\tint n, m, a;\n\tlong long l, r;\n\n\tscanf(\"%s%lld%lld\", cc, &l, &r), n = strlen(cc) / 2, l--;\n\tm = period(cc, n);\n\tsolve(cc, n, m, r, 1), solve(cc, n, m, l, -1);\n\tfor (a = 0; a < A; a++)\n\t\tprintf(\"%lld \", ans[a]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tchar[] s = ns().toCharArray();\n\t\tlong L = nl()-1, R = nl()-1;\n\t\tint n = s.length;\n\t\tint ptn = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tptn |= 1<<s[i]-'a';\n\t\t}\n\t\tif((ptn&ptn-1) == 0){\n\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\tif(ptn<<~i<0){\n\t\t\t\t\tout.print(R-L+1 + \" \");\n\t\t\t\t}else{\n\t\t\t\t\tout.print(0 + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[] z = Z(s);\n\t\tint len = s.length;\n\t\tfor(int i = 1;i < s.length/2;i++){\n\t\t\tif(z[s.length/2+i] == s.length/2-i){\n\t\t\t\tlen = s.length/2+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(len == s.length){\n\t\t\tlong[] f = new long[26];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tf[s[i]-'a'] += (R+1) / s.length + ((R+1)%s.length > i ? 1 : 0);\n\t\t\t\tf[s[i]-'a'] -= L / s.length + (L%s.length > i ? 1 : 0);\n\t\t\t}\n\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\tout.print(f[i] + \" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tchar[] t = Arrays.copyOf(s, len*2);\n\t\tfor(int j = 0;j < len;j++){\n\t\t\tt[j+len] = t[j];\n\t\t}\n\t\tint[] zt = Z(t);\n\t\tint lent = t.length;\n\t\tfor(int i = 1;i < t.length/2;i++){\n\t\t\tif(zt[t.length/2+i] == t.length/2-i){\n\t\t\t\tlent = t.length/2+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong[] vs = new long[100];\n\t\tvs[0] = len;\n\t\tvs[1] = lent;\n\t\tfor(int i = 2;;i++){\n\t\t\tvs[i] = vs[i-1] + vs[i-2];\n\t\t\tif(vs[i] > 1e18){\n\t\t\t\tvs = Arrays.copyOf(vs, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] f1 = count(R, vs, s);\n\t\tlong[] f0 = count(L-1, vs, s);\n\t\tfor(int i = 0;i < 26;i++){\n\t\t\tout.print(f1[i] - f0[i] + \" \");\n\t\t}\n\t\tout.println();\n\t\t\n\t}\n\t\n\tpublic static int[] Z(char[] str)\n\t{\n\t\tint n = str.length;\n\t\tint[] z = new int[n];\n\t\tif(n == 0)return z;\n\t\tz[0] = n;\n\t\tint l = 0, r = 0;\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tif(i > r){\n\t\t\t\tl = r = i;\n\t\t\t\twhile(r < n && str[r-l] == str[r])r++;\n\t\t\t\tz[i] = r-l; r--;\n\t\t\t}else{\n\t\t\t\tif(z[i-l] < r-i+1){\n\t\t\t\t\tz[i] = z[i-l];\n\t\t\t\t}else{\n\t\t\t\t\tl = i;\n\t\t\t\t\twhile(r < n && str[r-l] == str[r])r++;\n\t\t\t\t\tz[i] = r-l; r--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn z;\n\t}\n\t\n\tstatic long[] count(long z, long[] vs, char[] s)\n\t{\n\t\tlong[][] ops = new long[][]{{0L, 1L}, {z+1, -1L}};\n\t\tfor(int i = vs.length-1;i >= 0;i--){\n\t\t\tfor(int j = ops.length-1;j >= 0;j--){\n\t\t\t\tif(ops[j][0] <= vs[i]){\n\t\t\t\t\tlong sum = 0;\n\t\t\t\t\tfor(int k = 0;k < ops.length;k++){\n\t\t\t\t\t\tif(ops[k][0] < vs[i]){\n\t\t\t\t\t\t\tsum += ops[k][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0;k < ops.length;k++){\n\t\t\t\t\t\tops[k][0] %= vs[i];\n\t\t\t\t\t}\n\t\t\t\t\tops = Arrays.copyOf(ops, ops.length+2);\n\t\t\t\t\tops[ops.length-2] = new long[]{0, sum};\n\t\t\t\t\tops[ops.length-1] = new long[]{vs[i], -sum};\n\t\t\t\t\tArrays.sort(ops, (x, y) -> Long.compare(x[0], y[0]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong[] ret = new long[26];\n\t\tlong h = 0;\n\t\tint p = 0;\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\twhile(p < ops.length && ops[p][0] <= i){\n\t\t\t\th += ops[p++][1];\n\t\t\t}\n\t\t\tret[s[i]-'a'] += h;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static Random gen = new Random();\n\t\n\tstatic public class Node\n\t{\n\t\tpublic long id;\n\t\tpublic long v; // value\n\t\tpublic long priority;\n\t\tpublic Node left, right, parent;\n\t\t\n\t\tpublic int count;\n\t\t\n\t\tpublic long add;\n\t\tpublic long sum;\n\t\t\n\t\tpublic Node(long id, long v)\n\t\t{\n\t\t\tthis.id = id;\n\t\t\tthis.v = v;\n\t\t\tpriority = gen.nextLong();\n\t\t\tupdate(this);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"Node [v=\");\n\t\t\tbuilder.append(v);\n\t\t\tbuilder.append(\", count=\");\n\t\t\tbuilder.append(count);\n\t\t\tbuilder.append(\", parent=\");\n\t\t\tbuilder.append(parent != null ? parent.v : \"null\");\n\t\t\tbuilder.append(\", add=\");\n\t\t\tbuilder.append(add);\n\t\t\tbuilder.append(\", sum=\");\n\t\t\tbuilder.append(sum);\n\t\t\tbuilder.append(\"]\");\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\tpublic static Node update(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.count = 1;\n\t\tif(a.left != null)a.count += a.left.count;\n\t\tif(a.right != null)a.count += a.right.count;\n\t\t\n\t\ta.sum = a.v + a.add * a.count;\n\t\tif(a.left != null)a.sum += a.left.sum;\n\t\tif(a.right != null)a.sum += a.right.sum;\n\t\treturn a;\n\t}\n\t\n\tpublic static Node disconnect(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.left = a.right = a.parent = null;\n\t\treturn update(a);\n\t}\n\t\n\tpublic static Node root(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\twhile(x.parent != null)x = x.parent;\n\t\treturn x;\n\t}\n\t\n\tpublic static int count(Node a)\n\t{\n\t\treturn a == null ? 0 : a.count;\n\t}\n\t\n\tpublic static void setParent(Node a, Node par)\n\t{\n\t\tif(a != null)a.parent = par;\n\t}\n\t\n\tpublic static long sum(Node a, int L, int R)\n\t{\n\t\tif(a == null || L >= R || L >= count(a) || R <= 0)return 0L;\n\t\tif(L <= 0 && R >= count(a)){\n\t\t\treturn a.sum;\n\t\t}else{\n\t\t\tlong ret = 0;\n\t\t\tret += sum(a.left, L, R);\n\t\t\tret += sum(a.right, L-count(a.left)-1, R-count(a.left)-1);\n\t\t\tif(L <= count(a.left) && count(a.left) < R)ret += a.v;\n\t\t\tret += (Math.min(R, a.count) - L) * a.add;\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static void add(Node a, int L, int R, long V)\n\t{\n\t\tif(a == null || L >= R || L >= count(a) || R <= 0)return;\n\t\tif(L <= 0 && R >= count(a)){\n\t\t\ta.add += V;\n\t\t}else{\n\t\t\tadd(a.left, L, R, V);\n\t\t\tadd(a.right, L-count(a.left)-1, R-count(a.left)-1, V);\n\t\t\tif(L <= count(a.left) && count(a.left) < R)a.v += V;\n\t\t}\n\t\tupdate(a);\n\t}\n\t\n\tpublic static void fall(Node a)\n\t{\n\t\tif(a == null)return;\n\t\ta.v += a.add;\n\t\tif(a.left != null){\n\t\t\ta.left.add += a.add;\n\t\t\tupdate(a.left);\n\t\t}\n\t\tif(a.right != null){\n\t\t\ta.right.add += a.add;\n\t\t\tupdate(a.right);\n\t\t}\n\t\ta.add = 0;\n\t\tupdate(a);\n\t}\n\t\n\tpublic static Node merge(Node a, Node b)\n\t{\n\t\tif(b == null)return a;\n\t\tif(a == null)return b;\n\t\tif(a.priority > b.priority){\n\t\t\tfall(a);\n\t\t\tsetParent(a.right, null);\n\t\t\tsetParent(b, null);\n\t\t\ta.right = merge(a.right, b);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tfall(b);\n\t\t\tsetParent(a, null);\n\t\t\tsetParent(b.left, null);\n\t\t\tb.left = merge(a, b.left);\n\t\t\tsetParent(b.left, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\t// [0,K),[K,N)\n\tpublic static Node[] split(Node a, int K)\n\t{\n\t\tif(a == null)return new Node[]{null, null};\n\t\tfall(a);\n\t\tif(K <= count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tNode[] s = split(a.left, K);\n\t\t\ta.left = s[1];\n\t\t\tsetParent(a.left, a);\n\t\t\ts[1] = update(a);\n\t\t\treturn s;\n\t\t}else{\n\t\t\tsetParent(a.right, null);\n\t\t\tNode[] s = split(a.right, K-count(a.left)-1);\n\t\t\ta.right = s[0];\n\t\t\tsetParent(a.right, a);\n\t\t\ts[0] = update(a);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tpublic static Node insert(Node a, int K, Node b)\n\t{\n\t\tif(a == null)return b;\n\t\tfall(a);\n\t\tif(b.priority < a.priority){\n\t\t\tif(K <= count(a.left)){\n\t\t\t\ta.left = insert(a.left, K, b);\n\t\t\t\tsetParent(a.left, a);\n\t\t\t}else{\n\t\t\t\ta.right = insert(a.right, K-count(a.left)-1, b);\n\t\t\t\tsetParent(a.right, a);\n\t\t\t}\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tNode[] ch = split(a, K);\n\t\t\tb.left = ch[0]; b.right = ch[1];\n\t\t\tsetParent(b.left, b);\n\t\t\tsetParent(b.right, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\tpublic static Node insertb(Node root, Node x)\n\t{\n\t\tint ind = search(root, x.id);\n\t\tif(ind < 0){\n\t\t\t// insert\n\t\t\tind = -ind-1;\n\t\t\treturn insert(root, ind, x);\n\t\t}else{\n\t\t\t// add\n\t\t\tNode t = get(root, ind);\n\t\t\tt.v += x.v;\n\t\t\twhile(t != null){\n\t\t\t\tupdate(t);\n\t\t\t\tt = t.parent;\n\t\t\t}\n\t\t\treturn root;\n\t\t}\n\t}\n\t\n\t// delete K-th\n\tpublic static Node erase(Node a, int K)\n\t{\n\t\tif(a == null)return null;\n\t\tif(K < count(a.left)){\n\t\t\ta.left = erase(a.left, K);\n\t\t\tsetParent(a.left, a);\n\t\t\treturn update(a);\n\t\t}else if(K == count(a.left)){\n\t\t\tfall(a);\n\t\t\tsetParent(a.left, null);\n\t\t\tsetParent(a.right, null);\n\t\t\tNode aa = merge(a.left, a.right);\n\t\t\tdisconnect(a);\n\t\t\treturn aa;\n\t\t}else{\n\t\t\ta.right = erase(a.right, K-count(a.left)-1);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}\n\t}\n\t\n\tpublic static Node get(Node a, int K)\n\t{\n\t\twhile(a != null){\n\t\t\tif(K < count(a.left)){\n\t\t\t\ta = a.left;\n\t\t\t}else if(K == count(a.left)){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tK = K - count(a.left)-1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int lowerBound(Node a, long q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.id >= q){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn lcount;\n\t}\n\n\t\n\tpublic static int search(Node a, long q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tfall(a);\n\t\t\tif(a.id == q){\n\t\t\t\tlcount += count(a.left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q < a.id){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a == null ? -(lcount+1) : lcount;\n\t}\n\t\n\tpublic static int index(Node a)\n\t{\n\t\tif(a == null)return -1;\n\t\tint ind = count(a.left);\n\t\twhile(a != null){\n\t\t\tNode par = a.parent;\n\t\t\tif(par != null && par.right == a){\n\t\t\t\tind += count(par.left) + 1;\n\t\t\t}\n\t\t\ta = par;\n\t\t}\n\t\treturn ind;\n\t}\n\t\n\tpublic static Node[] nodes(Node a) { return nodes(a, new Node[count(a)], 0, count(a)); }\n\tpublic static Node[] nodes(Node a, Node[] ns, int L, int R)\n\t{\n\t\tif(a == null)return ns;\n\t\tnodes(a.left, ns, L, L+count(a.left));\n\t\tns[L+count(a.left)] = a;\n\t\tnodes(a.right, ns, R-count(a.right), R);\n\t\treturn ns;\n\t}\n\t\n\tpublic static String toString(Node a, String indent)\n\t{\n\t\tif(a == null)return \"\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(toString(a.left, indent + \"  \"));\n\t\tsb.append(indent).append(a).append(\"\\n\");\n\t\tsb.append(toString(a.right, indent + \"  \"));\n\t\treturn sb.toString();\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc077;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        char[] s = in.nextToken().toCharArray();\n        s = Arrays.copyOf(s, s.length / 2);\n        int c = s.length - errorFunction(s)[s.length];\n\n        long l = in.nextLong() - 1;\n        long r = in.nextLong();\n\n        long[] ans = s.length % c == 0 ? solve(s, c, l, r) : solve2(s, c, l, r);\n        for (int i = 0; i < 26 ; i++) {\n            if (i >= 1) {\n                out.print(' ');\n            }\n            out.print(ans[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static long[] solve(char[] s, int c, long l, long r) {\n        long[] ans = new long[26];\n        long[] x = solveSame(r, s);\n        long[] y = solveSame(l, s);\n        for (int i = 0; i < 26; i++) {\n            ans[i] = x[i] - y[i];\n        }\n        return ans;\n    }\n\n\n    private static long[] solve2(char[] s, int lp, long l, long r) {\n        int MAX = 2000;\n        long[] ans = new long[26];\n        S = s;\n        wl = new long[MAX];\n        wl[0] = s.length;\n        wl[1] = s.length + lp;\n\n        wcnt = new long[MAX][26];\n        for (int i = 0; i < s.length ; i++) {\n            wcnt[0][s[i]-'a']++;\n            wcnt[1][s[i]-'a']++;\n        }\n        for (int i = 0; i < lp ; i++) {\n            wcnt[1][s[i]-'a']++;\n        }\n\n        for (int i = 2 ; i < MAX ; i++) {\n            wl[i] = wl[i-1] + wl[i-2];\n            for (int c = 0 ; c < 26 ; c++) {\n                wcnt[i][c] = wcnt[i-1][c] + wcnt[i-2][c];\n            }\n\n            if (wl[i] > r) {\n                long[] R = solveRec(r, i);\n                long[] L = solveRec(l, i);\n                for (int c = 0; c < 26 ; c++) {\n                    ans[c] = R[c] - L[c];\n                }\n                break;\n            }\n        }\n        return ans;\n    }\n\n    static char[] S;\n    static long[] wl;\n    static long[][] wcnt;\n\n    private static long[] solveRec(long r, int depth) {\n        if (depth <= 1) {\n            long[] cnt = new long[26];\n            for (int i = 0; i < Math.min(r, S.length); i++) {\n                cnt[S[i]-'a']++;\n            }\n            r -= S.length;\n            for (int i = 0; i < Math.min(r, S.length); i++) {\n                cnt[S[i]-'a']++;\n            }\n            return cnt;\n        }\n\n        long left = wl[depth-1];\n        if (r <= left) {\n            return solveRec(r, depth-1);\n        } else {\n            long[] ri = solveRec(r -  left, depth-2);\n            for (int i = 0; i < 26; i++) {\n                ri[i] += wcnt[depth-1][i];\n            }\n            return ri;\n        }\n    }\n\n\n    private static long[] solveSame(long r, char[] s) {\n        long cur = r / s.length;\n        long mod = r % s.length;\n        long[] ret = new long[26];\n        for (int i = 0; i < s.length ; i++) {\n            ret[s[i]-'a'] += cur;\n        }\n        for (int i = 0; i < mod ; i++) {\n            ret[s[i]-'a']++;\n        }\n        return ret;\n    }\n\n    public static int[] errorFunction(char[] a) {\n        int len = a.length;\n        int[] err = new int[len+1];\n        err[0] = -1;\n        for (int i = 2 ; i <= len ; i++) {\n            int now = err[i-1];\n            while (now > 0 && a[i-1] != a[now]) {\n                now = err[now];\n            }\n            if (a[i-1] == a[now]) {\n                now++;\n            } else {\n                now = 0;\n            }\n            err[i] = now;\n        }\n        return err;\n    }\n\n\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main{\n\n  static long[] fact;\n  static long m = 1_000_000_007L;\n\n  static long modPow(long base, long exp, long mod){\n    long ans = 1L;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        ans = ans * base % mod;\n      exp >>= 1;\n      base %= mod;\n      base = base * base % mod;\n    }\n\n    return ans;\n  }\n\n  static long nck(int n, int k){\n    return fact[n]*modPow(fact[k], m-2, m)%m*modPow(fact[n-k], m-2, m)%m;\n  }\n\n  public static void main(String[] args) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    Integer n = Integer.parseInt(in.readLine());\n    Integer[] a = Arrays.stream(in.readLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n    long cnt = 0;\n    int deplLeft=0, deplRight=0;\n\n    Set<Integer> set = new HashSet<>();\n\n    for(int i=0;i<n+1;i++){\n      if(set.contains(a[i])){\n        for(int j=0;j<i;j++){\n          if(a[i]==a[j]){\n            deplLeft = j;\n            deplRight = i;\n          }\n        }\n      }else{\n        set.add(a[i]);\n      }\n    }\n\n    fact = new long[n+2];\n\n    fact[0] = 1;\n    for(int i=1;i<n+2;i++){\n      fact[i] = fact[i-1] * i % m;\n    }\n\n    StringBuffer sb = new StringBuffer();\n    long b,c;\n    for(int i=0;i<n+1;i++){\n      b = nck(n+1, i+1);\n\n      if(deplLeft+n-deplRight-i>=0){\n        c = nck(deplLeft+n-deplRight, i);\n      } else {\n        c = 0;\n      }\n      // System.out.println(b);\n      // System.out.println(c);\n      // System.out.println();\n      sb.append((b - c + m) % m);\n      sb.append(\"\\n\");\n    }\n    System.out.print(sb.toString());\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main{\n\n  static long modPow(long base, long exp, long mod){\n    long ans = 1L;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        ans = ans * base % mod;\n      exp >>= 1;\n      base %= mod;\n      base = base * base % mod;\n    }\n\n    return ans;\n  }\n\n  public static void main(String[] args) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    Integer n = Integer.parseInt(in.readLine());\n    Integer[] a = Arrays.stream(in.readLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n    long cnt = 0;\n    int deplLeft=0, deplRight=0;\n    for(int i=0;i<n+1;i++){\n      for(int j=i+1;j<n+1;j++){\n        if(a[i]==a[j]){\n          deplLeft = i;\n          deplRight = j;\n        }\n      }\n    }\n\n    long[] x = new long[n+2];\n    long[] xInv = new long[n+2];\n\n    x[0] = 1;\n    xInv[0] = 1;\n    x[1] = 1;\n    xInv[1] = 1;\n    long m = 1000000007L;\n    long inv = 1000000005L;\n    for(int i=2;i<n+2;i++){\n      x[i] = x[i-1]*i%m;\n      xInv[i] = modPow(x[i], inv, m);\n    }\n\n    long nCk, lrCk;\n    for(int i=0;i<n+1;i++){\n        nCk = x[n+1]*xInv[i+1]%m*xInv[n-i]%m;\n\n        if(deplLeft+n-deplRight-i>=0){\n          lrCk = x[deplLeft+n-deplRight]*xInv[i]%m*xInv[deplLeft+n-deplRight-i]%m;\n        } else {\n          lrCk = 0;\n        }\n        // System.out.println(nCk);\n        // System.out.println(lrCk);\n        System.out.println((nCk-lrCk+m)%m);\n        // System.out.println();\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n\n        String s = in.nextToken();\n        String c0 = next(s);\n        String c1 = next(c0);\n        String c0half = c0.substring(0, c0.length()/2);\n        String c1half = c1.substring(0, c1.length()/2);\n\n        parts = new Parts[500];\n        parts[0] = new Parts(c0half);\n        parts[1] = new Parts(c1half);\n        for (int i = 2 ; i < parts.length ; i++) {\n            parts[i] = new Parts(parts[i-2], parts[i-1]);\n        }\n\n        long l = in.nextLong();\n        long r = in.nextLong();\n\n\n        long[] a = solve(l-1);\n        long[] b = solve(r);\n        for (int i = 0; i < a.length ; i++) {\n            if (i >= 1) {\n                out.print(' ');\n            }\n            out.print(b[i]-a[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    static class Parts {\n        String C;\n        long[] degree;\n        long length;\n\n        public Parts(String c0) {\n            C = c0;\n            length = c0.length();\n            degree = new long[26];\n            for (int i = 0; i < length ; i++) {\n                degree[c0.charAt(i)-'a']++;\n            }\n        }\n\n        public Parts(Parts left, Parts right) {\n            length = left.length + right.length;\n            degree = new long[26];\n            for (int i = 0; i < degree.length; i++) {\n                degree[i] = left.degree[i] + right.degree[i];\n            }\n        }\n    }\n\n    static Parts[] parts;\n\n    private static long[] solve(long l) {\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].length > l) {\n                return doit(i, l);\n            }\n        }\n        throw new RuntimeException(\"not enough:\" + l);\n    }\n\n    private static long[] doit(int level, long L) {\n        long[] ret = new long[26];\n        if (L == 0) {\n            return ret;\n        }\n\n        if (level <= 1) {\n            int ln = parts[level].C.length();\n            if (ln < L) {\n                throw new RuntimeException(\"not enough length base case:\" + level + \"/\" + L);\n            }\n            for (int i = 0; i < L ; i++) {\n                ret[parts[level].C.charAt(i)-'a']++;\n            }\n            return ret;\n        }\n\n        long a = parts[level-1].length;\n        long b = parts[level-2].length;\n        if (a + b < L) {\n            throw new RuntimeException(\"not enough length:\" + level + \"/\" + L + \"vs\" + (a + b));\n        } else if (a + b == L) {\n            return parts[level].degree;\n        }\n\n        if (L <= a) {\n            return doit(level-1, L);\n        } else {\n            long[] r = doit(level-2, L-a);\n            for (int i = 0; i < 26; i++) {\n                ret[i] = parts[level-1].degree[i] + r[i];\n            }\n            return ret;\n        }\n    }\n\n    private static String next(String a) {\n        int n = a.length();\n\n        long[] prefix = new long[2];\n        long[] suffix = new long[2];\n\n        long[] mulPow = {1, 1};\n\n        int longestMatch = 0;\n        for (int x = 0; x < (n+1)/2-1 ; x++) {\n            int h = a.charAt(x)-'a';\n            int t = a.charAt(n-1-x)-'a';\n\n            boolean same = true;\n            for (int w = 0; w < 2 ; w++) {\n                prefix[w] = (prefix[w] * mul[w] + h) % mod[w];\n                suffix[w] = (suffix[w] + mulPow[w] * t) % mod[w];\n                mulPow[w] = mulPow[w] * mul[w] % mod[w];\n                same &= prefix[w] == suffix[w];\n            }\n            if (same) {\n                longestMatch = x+1;\n            }\n        }\n        String pair = a.substring(0, a.length()-longestMatch);\n        return pair + pair;\n    }\n\n    static long[] mul = new long[]{31, 1009};\n    static long[] mod = new long[]{(long)1e9+7, (long)1e9+9};\n\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string s = Console.ReadLine();\n        SuffixArray S = new SuffixArray(s);\n        int d = s.Length;\n        int N = s.Length;\n        for(int i=1;i<s.Length;i++){\n            if(S.SameSize(0,i) == N-i){\n                d = i;\n                break;\n            }\n        }\n        string[] str = Console.ReadLine().Split(' ');\n        long L = long.Parse(str[0]);\n        long R = long.Parse(str[1]);\n        int l = (int)(L%d)-1;\n        int r = (int)(R%d)+1;\n        long D = (R-L+1+l+r)/d;\n        long[] A = new long[26];\n        long[] B = new long[26];\n        long[] C = new long[26];\n        for(int i=0;i<d;i++){\n            if(i <= l){\n                A[s[i]-'a']++;\n            }\n            B[s[i]-'a']++;\n            if(i >= r){\n                C[s[i]-'a']++;\n            }\n        }\n        for(int i=0;i<26;i++){\n            long count = 0;\n            count = D*B[i]-A[i]-C[i];\n            sb.Append(count);\n            if(i != 25){\n                sb.Append(\" \");\n            }\n            else{\n                sb.Append(\"\\n\");\n            }\n        }\n    }\n}\npublic class SuffixArray{\n    List<int[]> a;\n    int size;\n    public SuffixArray(string s){\n        a = new List<int[]>();\n        int[] b = new int[s.Length];\n        {\n            int[] c = new int[s.Length];\n            for(int i=0;i<s.Length;i++){\n                c[i] = i;\n            }\n            Array.Sort(c,(x,y) => s[x] > s[y] ? 1 : (s[x] == s[y] ? 0 : -1));\n            int count = 0;\n            b[c[0]] = 0;\n            for(int i=1;i<s.Length;i++){\n                if(s[c[i-1]] != s[c[i]]){\n                    count++;\n                }\n                b[c[i]] = count;\n            }\n        }\n        a.Add(b);\n        int l;\n        for(l=2;l<s.Length;l*=2){\n            int[] c = new int[s.Length-l+1];\n            for(int i=0;i<s.Length-l+1;i++){\n                c[i] = i;\n            }\n            Array.Sort(c,(x,y) => b[x] > b[y] ? 1 : (b[x] == b[y] ? b[x+l/2] - b[y+l/2] : -1));\n            int count = 0;\n            int[] b0 = new int[s.Length-l+1];\n            b0[c[0]] = 0;\n            for(int i=1;i<s.Length-l+1;i++){\n                if(b[c[i-1]] != b[c[i]] || b[c[i-1]+l/2] != b[c[i]+l/2]){\n                    count++;\n                }\n                b0[c[i]] = count;\n            }\n            a.Add(b0);\n            b = b0;\n        }\n        size = l/2;\n    }\n    public int SameSize(int x,int y){\n        int x0 = x;\n        int y0 = y;\n        int count = 0;\n        int p = a.Count-1;\n        for(int l=size;l!=0;l/=2,p--){\n            if(x0 < a[p].Length && y0 < a[p].Length && a[p][x0] == a[p][y0]){\n                count += l;\n                x0 += l;\n                y0 += l;\n            }\n        }\n        return count;\n    }\n    public int SameSizeRev(int x,int y){\n        int x0 = x;\n        int y0 = y;\n        int count = 0;\n        int p = a.Count-1;\n        for(int l=size;l!=0;l/=2,p--){\n            if(x0 >= l-1 && y0 >= l-1 && a[p][x0-l+1] == a[p][y0-l+1]){\n                count += l;\n                x0 -= l;\n                y0 -= l;\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.datastructure.lazyseg;\n\nint[] mp(T)(T s) {\n    int n = s.length.to!int;\n    int[] R = new int[n+1]; R[0] = -1;\n    for (int i = 0, j = -1; i < n; i++) {\n        while (j >= 0 && s[i] != s[j]) j = R[j];\n        j++;\n        R[i+1] = j;\n    }\n    return R;\n}\n\nlong[26] solve(char[] s1, char[] s2, long l) {\n    immutable long INF = 10L^^18 + 10L^^16;\n    debug writeln(s1, \" \", s2, \" \", l);\n    long[200] len;\n    long[26][200] all;\n    len[0] = s1.length;\n    len[1] = s2.length;\n    s1.each!(x => all[0][x-'a']++);\n    s2.each!(x => all[1][x-'a']++);\n    foreach (i; 2..200) {\n        len[i] = len[i-1] + len[i-2];\n        len[i] = min(len[i], INF);\n        all[i][] = all[i-1][] + all[i-2][];\n        all[i][].each!((ref x) => x = min(x, INF));\n    }\n    long[26] cnt;\n    void dfs(long b, int dp) {\n        if (b <= 0) return;\n        if (len[dp] <= b) {\n            cnt[] += all[dp][];\n            return;\n        }\n        if (dp == 0) {\n            iota(b).each!(i => cnt[s1[i]-'a']++);\n            return;\n        }\n        if (dp == 1) {\n            iota(b).each!(i => cnt[s2[i]-'a']++);            \n            return;\n        }\n        dfs(b, dp-1);\n        dfs(b - len[dp-1], dp-2);\n    }\n    dfs(l, 199);\n    debug writeln(cnt);\n    return cnt;\n}\n\nlong[26] solve_ex(char[] s1, long l) {\n    int n = s1.length.to!int;\n    long[26] cnt;\n    foreach (i, d; s1) {\n        cnt[d-'a'] += (l+n-1)/n;\n    }\n    return cnt;\n}\n\nint main() {\n    auto sc = new Scanner(stdin);\n    char[] s;\n    long l, r;\n    sc.read(s, l, r);\n    int n = s.length.to!int;\n    long[26] cnt;\n    if (s.mp[n/2] == 0) {\n        //xx, xxxx, xxxxxx, ...\n        cnt[] += solve_ex(s[0..n/2], r)[];\n        cnt[] -= solve_ex(s[0..n/2], l-1)[];\n    } else {\n        cnt[] += solve(s[0..n/2], s[0..n-s.mp[n/2]], r)[];\n        cnt[] -= solve(s[0..n/2], s[0..n-s.mp[n/2]], l-1)[];\n    }\n    writeln(cnt[].map!(to!string).join(\" \"));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/lazyseg.d */\n// module dcomp.datastructure.lazyseg;\n\n \nstruct LazySeg(T, L, alias opTT, alias opTL, alias opLL, T eT, L eL) {\n    const int n, sz, lg;\n    T[] d;\n    L[] lz;\n    @disable this();\n    this(int n) {\n        import std.algorithm : fill, each;\n        import core.bitop : bsr;\n        if (n == 0) return;\n        int lg = n.bsr;\n        if ((2^^lg) < n) lg++;\n        this.n = n;\n        this.sz = 2^^lg;\n        this.lg = lg;\n        d = new T[](2*this.sz);\n        d.each!((ref x) => x = eT);\n        lz = new L[](2*this.sz);\n        lz.each!((ref x) => x = eL);\n    }\n    private void lzAdd(int k, L x) {\n        d[k] = opTL(d[k], x);\n        lz[k] = opLL(lz[k], x);\n    }\n    private void push(int k) {\n        if (lz[k] == eL) return;\n        lzAdd(2*k, lz[k]);\n        lzAdd(2*k+1, lz[k]);\n        lz[k] = eL;\n    }\n     \n    T sum(int a, int b, int l, int r, int k) {\n        if (b <= l || r <= a) return eT;\n        if (a <= l && r <= b) return d[k];\n        push(k);\n        int md = (l+r)/2;\n        return opTT(sum(a, b, l, md, 2*k),\n            sum(a, b, md, r, 2*k+1));\n    }\n    T single(int k) {\n        k += sz;\n        foreach_reverse (int i; 1..lg+1) {\n            push(k>>i);\n        }\n        return d[k];\n    }\n    void singleSet(T x, int k) {\n        k += sz;\n        foreach_reverse (int i; 1..lg+1) {\n            push(k>>i);\n        }\n        d[k] = x;\n        foreach (int i; 1..lg+1) {\n            d[k>>i] = opTT(d[2*(k>>i)], d[2*(k>>i)+1]);\n        }\n    }\n    T sum(int a, int b) {\n        assert(0 <= a && a <= b && b <= n);\n        return sum(a, b, 0, sz, 1);\n    }\n    void add(int a, int b, L x, int l, int r, int k) {\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lzAdd(k, x);\n            return;\n        }\n        push(k);\n        int md = (l+r)/2;\n        add(a, b, x, l, md, 2*k);\n        add(a, b, x, md, r, 2*k+1);\n        d[k] = opTT(d[2*k], d[2*k+1]);\n    }\n    void add(int a, int b, L x) {\n        assert(0 <= a && a <= b && b <= n);\n        add(a, b, x, 0, sz, 1);\n    }\n    @property int opDollar() const {return sz;}\n    struct Range {\n        LazySeg* seg;\n        int start, end;\n        @property T sum() {\n            return seg.sum(start, end);\n        }\n    }\n    T opIndex(int k) {\n        assert(0 <= k && k < n);\n        return single(k);\n    }\n    void opIndexAssign(T x, int k) {\n        assert(0 <= k && k < n);\n        singleSet(x, k);\n    }\n    int[2] opSlice(size_t dim)(int start, int end) {\n        assert(0 <= start && start <= end && end <= sz);\n        return [start, end];\n    }\n    Range opIndex(int[2] rng) {\n        return Range(&this, rng[0], rng[1]);\n    }\n    void opIndexOpAssign(string op : \"+\")(L x, int[2] rng) {\n        add(rng[0], rng[1], x);\n    }\n}\n\n \n \n \n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.datastructure.lazyseg;\n\nint[] mp(T)(T s) {\n    int n = s.length.to!int;\n    int[] R = new int[n+1]; R[0] = -1;\n    for (int i = 0, j = -1; i < n; i++) {\n        while (j >= 0 && s[i] != s[j]) j = R[j];\n        j++;\n        R[i+1] = j;\n    }\n    return R;\n}\n\nlong[26] solve(char[] s1, char[] s2, long l) {\n    immutable long INF = 10L^^18 + 10L^^16;\n    debug writeln(s1, \" \", s2, \" \", l);\n    long[200] len;\n    long[26][200] all;\n    len[0] = s1.length;\n    len[1] = s2.length;\n    s1.each!(x => all[0][x-'a']++);\n    s2.each!(x => all[1][x-'a']++);\n    foreach (i; 2..200) {\n        len[i] = len[i-1] + len[i-2];\n        len[i] = min(len[i], INF);\n        all[i][] = all[i-1][] + all[i-2][];\n        all[i][].each!((ref x) => x = min(x, INF));\n    }\n    long[26] cnt;\n    void dfs(long b, int dp) {\n        if (b <= 0) return;\n        if (len[dp] <= b) {\n            cnt[] += all[dp][];\n            return;\n        }\n        if (dp == 0) {\n            iota(b).each!(i => cnt[s1[i]-'a']++);\n            return;\n        }\n        if (dp == 1) {\n            iota(b).each!(i => cnt[s2[i]-'a']++);            \n            return;\n        }\n        dfs(b, dp-1);\n        dfs(b - len[dp-1], dp-2);\n    }\n    dfs(l, 199);\n    debug writeln(cnt);\n    return cnt;\n}\n\nlong[26] solve_ex(char[] s1, long l) {\n    int n = s1.length.to!int;\n    long[26] cnt;\n    foreach (i, d; s1) {\n        cnt[d-'a'] += (l-i+n-1)/n;\n    }\n    return cnt;\n}\n\nint main() {\n    auto sc = new Scanner(stdin);\n    char[] s;\n    long l, r;\n    sc.read(s, l, r);\n    int n = s.length.to!int;\n    long[26] cnt;\n    if (s.mp[n/2] == 0) {\n        //xx, xxxx, xxxxxx, ...\n        cnt[] += solve_ex(s[0..n/2], r)[];\n        cnt[] -= solve_ex(s[0..n/2], l-1)[];\n    } else {\n        cnt[] += solve(s[0..n/2], s[0..n-s.mp[n/2]], r)[];\n        cnt[] -= solve(s[0..n/2], s[0..n-s.mp[n/2]], l-1)[];\n    }\n    writeln(cnt[].map!(to!string).join(\" \"));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/lazyseg.d */\n// module dcomp.datastructure.lazyseg;\n\n \nstruct LazySeg(T, L, alias opTT, alias opTL, alias opLL, T eT, L eL) {\n    const int n, sz, lg;\n    T[] d;\n    L[] lz;\n    @disable this();\n    this(int n) {\n        import std.algorithm : fill, each;\n        import core.bitop : bsr;\n        if (n == 0) return;\n        int lg = n.bsr;\n        if ((2^^lg) < n) lg++;\n        this.n = n;\n        this.sz = 2^^lg;\n        this.lg = lg;\n        d = new T[](2*this.sz);\n        d.each!((ref x) => x = eT);\n        lz = new L[](2*this.sz);\n        lz.each!((ref x) => x = eL);\n    }\n    private void lzAdd(int k, L x) {\n        d[k] = opTL(d[k], x);\n        lz[k] = opLL(lz[k], x);\n    }\n    private void push(int k) {\n        if (lz[k] == eL) return;\n        lzAdd(2*k, lz[k]);\n        lzAdd(2*k+1, lz[k]);\n        lz[k] = eL;\n    }\n     \n    T sum(int a, int b, int l, int r, int k) {\n        if (b <= l || r <= a) return eT;\n        if (a <= l && r <= b) return d[k];\n        push(k);\n        int md = (l+r)/2;\n        return opTT(sum(a, b, l, md, 2*k),\n            sum(a, b, md, r, 2*k+1));\n    }\n    T single(int k) {\n        k += sz;\n        foreach_reverse (int i; 1..lg+1) {\n            push(k>>i);\n        }\n        return d[k];\n    }\n    void singleSet(T x, int k) {\n        k += sz;\n        foreach_reverse (int i; 1..lg+1) {\n            push(k>>i);\n        }\n        d[k] = x;\n        foreach (int i; 1..lg+1) {\n            d[k>>i] = opTT(d[2*(k>>i)], d[2*(k>>i)+1]);\n        }\n    }\n    T sum(int a, int b) {\n        assert(0 <= a && a <= b && b <= n);\n        return sum(a, b, 0, sz, 1);\n    }\n    void add(int a, int b, L x, int l, int r, int k) {\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lzAdd(k, x);\n            return;\n        }\n        push(k);\n        int md = (l+r)/2;\n        add(a, b, x, l, md, 2*k);\n        add(a, b, x, md, r, 2*k+1);\n        d[k] = opTT(d[2*k], d[2*k+1]);\n    }\n    void add(int a, int b, L x) {\n        assert(0 <= a && a <= b && b <= n);\n        add(a, b, x, 0, sz, 1);\n    }\n    @property int opDollar() const {return sz;}\n    struct Range {\n        LazySeg* seg;\n        int start, end;\n        @property T sum() {\n            return seg.sum(start, end);\n        }\n    }\n    T opIndex(int k) {\n        assert(0 <= k && k < n);\n        return single(k);\n    }\n    void opIndexAssign(T x, int k) {\n        assert(0 <= k && k < n);\n        singleSet(x, k);\n    }\n    int[2] opSlice(size_t dim)(int start, int end) {\n        assert(0 <= start && start <= end && end <= sz);\n        return [start, end];\n    }\n    Range opIndex(int[2] rng) {\n        return Range(&this, rng[0], rng[1]);\n    }\n    void opIndexOpAssign(string op : \"+\")(L x, int[2] rng) {\n        add(rng[0], rng[1], x);\n    }\n}\n\n \n \n \n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import Counter\n\n\"\"\"\n・実験すると、何回かやるとFibonacci（未証明）\n\"\"\"\n\nS = readline().rstrip()\nl,r = map(int,read().split())\n\ndef double_naive(S):\n    L = len(S)\n    for i in range(1,L+1):\n        T = S[:i] * 2\n        if len(T) > L and T[:L] == S:\n            return T\n\ndef Z_algorithm(S):\n    # 共通接頭辞の長さを返す\n    N=len(S)\n    arr = [0]*N\n    arr[0] = N\n    i,j = 1,0\n    while i<N:\n        while i+j<N and S[j]==S[i+j]:\n            j += 1\n        arr[i]=j\n        if not j:\n            i += 1\n            continue\n        k = 1\n        while i+k<N and k+arr[k]<j:\n            arr[i+k] = arr[k]\n            k += 1\n        i += k; j -= k\n    return arr\n\ndef F(S):\n    N = len(S)\n    opt_len = N\n    Z = Z_algorithm(S)\n    for x in range(N//2+1,N):\n        z = Z[x]\n        if x + z >= N:\n            opt_len = x\n            break\n    return S[:opt_len] * 2\n\nS = F(S)\nT = F(S)\n\n# S,T,TS,TST,...\n\nL = [len(S), len(T)]\nfor _ in range(100):\n    L.append(L[-1] + L[-2])\nctr = [Counter(S), Counter(T)]\nfor _ in range(100):\n    ctr.append(ctr[-1] + ctr[-2])\n\ndef get_dist(N,R):\n    # S_NにおけるR番目以下\n    if N == 0:\n        return Counter(S[:R])\n    if N == 1:\n        return Counter(T[:R])\n    if L[N-1] >= R:\n        return get_dist(N-1,R)\n    return ctr[N-1] + get_dist(N-2,R-L[N-1])\n\nctr = get_dist(99,r) - get_dist(99,l-1)\n\nanswer = [ctr[x + ord('a')] for x in range(26)]\nprint(*answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import Counter\n\n\"\"\"\n・実験すると、何回かやるとFibonacci（未証明）\n\"\"\"\n\nS = readline().rstrip()\nl,r = map(int,read().split())\n\ndef double_naive(S):\n    L = len(S)\n    for i in range(1,L+1):\n        T = S[:i] * 2\n        if len(T) > L and T[:L] == S:\n            return T\n\ndef Z_algorithm(S):\n    # 共通接頭辞の長さを返す\n    N=len(S)\n    arr = [0]*N\n    arr[0] = N\n    i,j = 1,0\n    while i<N:\n        while i+j<N and S[j]==S[i+j]:\n            j += 1\n        arr[i]=j\n        if not j:\n            i += 1\n            continue\n        k = 1\n        while i+k<N and k+arr[k]<j:\n            arr[i+k] = arr[k]\n            k += 1\n        i += k; j -= k\n    return arr\n\ndef F(S):\n    N = len(S)\n    opt_len = N\n    Z = Z_algorithm(S)\n    for x in range(N//2+1,N):\n        z = Z[x]\n        if x + z >= N:\n            opt_len = x\n            break\n    return S[:opt_len] * 2\n\nS = F(S)\nS = F(S)\nT = F(S)\n\n# S,T,TS,TST,...\n\nL = [len(S), len(T)]\nfor _ in range(100):\n    L.append(L[-1] + L[-2])\nctr = [Counter(S), Counter(T)]\nfor _ in range(100):\n    ctr.append(ctr[-1] + ctr[-2])\n\ndef get_dist(N,R):\n    # S_NにおけるR番目以下\n    if N == 0:\n        return Counter(S[:R])\n    if N == 1:\n        return Counter(T[:R])\n    if L[N-1] >= R:\n        return get_dist(N-1,R)\n    return ctr[N-1] + get_dist(N-2,R-L[N-1])\n\nctr = get_dist(99,r) - get_dist(99,l-1)\n\nanswer = [ctr[x + ord('a')] for x in range(26)]\nprint(*answer)"
  },
  {
    "language": "Python",
    "code": "def getSS(S):\n    helfLength = int(len(S) / 2) + 1\n    \n    while S[:int(len(S[helfLength:]))] != S[helfLength:]:\n        helfLength += 1\n        \n    return S[:helfLength] * 2\n\nresult = \"\"\nS = input()\nSS = S\nlr = [int(i) for i in input().split()]\n\ni = 0\nwhile i < 10:\n    SS = getSS(SS)\n    i += 1\n\ncList = [chr(i) for i in range(97, 97+26)]\n\nfor c in cList:\n    result += str(SS[lr[0]-1:lr[1]].count(c)) + \" \"\n\nprint(result.rstrip())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nM = 10 ** 9 + 7\na = ord('a')\n\n\ndef check_cycle(t, p):\n\n    len_t = len(t)\n    if len_t % p != 0:\n        return False\n    pre = t[: p]\n    for i in range(p, len_t, p):\n        if t[i: i + p] != pre:\n            return False\n\n    return True\n\n\ndef solve_cycle(t, l, r):\n\n    len_t = len(t)\n    ql = (l - 1) // len_t\n    rl = (l - 1) % len_t\n    qr = r // len_t\n    rr = r % len_t\n\n    ans = [0] * 26\n    for ch in t:\n        ans[ord(ch) - a] += 1\n    for j in range(26):\n        ans[j] *= (qr - ql)\n    for ch in t[: rr + 1]:\n        ans[ord(ch) - a] += 1\n    for ch in t[: rl + 1]:\n        ans[ord(ch) - a] -= 1\n\n    return ans\n\n\ndef calc_part(tp, tm, len_p, len_m, dp0, dp1, r, ir):\n\n    num_p = 0\n    num_m = 0\n    for i in range(ir, -1, -1):\n        n = dp0[i] * len_p + dp1[i] * len_m\n        if n <= r:\n            num_p += dp0[i]\n            num_m += dp1[i]\n            r -= n\n\n    vec = [0] * 26\n    tr = tp\n    if len_p + len_m < r:\n        num_p += 1\n        num_m += 1\n        r -= len_p + len_m\n    elif len_p < r:\n        num_p += 1\n        r -= len_p\n        tr = tm\n    for ch in tp:\n        vec[ord(ch) - a] += num_p\n    for ch in tm:\n        vec[ord(ch) - a] += num_m\n    for ch in tr[: r]:\n        vec[ord(ch) - a] += 1\n\n    return vec\n\n\ndef solve_part(t, len_p, l, r):\n\n    len_t = len(t)\n    len_m = len_t - 2 * len_p\n    dp0 = [0] * 121\n    dp1 = [0] * 121\n    dp0[0] = 2\n    dp1[0] = 1\n\n    for i in range(1, 121):\n        dp0[i] = dp0[i - 1] + dp1[i - 1]\n        dp1[i] = dp0[i - 1]\n        n = dp0[i] * len_p + dp1[i] * len_m\n        if l - 1 <= n:\n            il = i - 1\n        if r <= n:\n            ir = i - 1\n            break\n\n    vec_l = calc_part(t[: len_p], t[len_p: len_p + len_m], len_p, len_m, dp0, dp1, l - 1, il)\n    vec_r = calc_part(t[: len_p], t[len_p: len_p + len_m], len_p, len_m, dp0, dp1, r, ir)\n\n    ans = [vec_r[j] - vec_l[j] for j in range(26)]\n\n    return ans\n\n\ndef solve(s, l, r):\n\n    t = s[: len(s) // 2]\n    len_t = len(t)\n    if len_t == 1:\n        return solve_cycle(t, l, r)\n\n    len_p = 0\n    ph = 0\n    sh = 0\n    base = 1\n    for i in range(len_t // 2):\n        ph *= 26\n        ph += ord(s[i]) - a\n        ph %= M\n        sh += base * (ord(s[-1 - i]) - a)\n        sh %= M\n        if ph == sh:\n            if check_cycle(t, i + 1):\n                return sovle_cycle(t[: i + 1], l, r)\n            elif t[: i + 1] == t[-1 - i:]:\n                len_p = i + 1\n        base *= 26\n\n    if len_p == 0:\n        return solve_cycle(t, l, r)\n\n    return solve_part(t, len_p, l, r)\n\n\ndef main():\n    s = input()\n    l, r = input().split()\n    l = int(l)\n    r = int(r)\n\n    print(' '.join(list(map(str, solve(s, l, r)))))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "S = input()\n\nhelfLength = int(len(S) / 2) + 1\n\nwhile S[:int(len(S[helfLength:]))] != S[helfLength:]:\n    helfLength += 1\n\nprint(helfLength * 2)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nS = readline().rstrip()\nl,r = map(int,read().split())\n\ndef double_naive(S):\n    L = len(S)\n    for i in range(1,L+1):\n        T = S[:i] * 2\n        if len(T) > L and T[:L] == S:\n            return T\n\ndef Z_algorithm(S):\n    # 共通接頭辞の長さを返す\n    N=len(S)\n    arr = [0]*N\n    arr[0] = N\n    i,j = 1,0\n    while i<N:\n        while i+j<N and S[j]==S[i+j]:\n            j += 1\n        arr[i]=j\n        if not j:\n            i += 1\n            continue\n        k = 1\n        while i+k<N and k+arr[k]<j:\n            arr[i+k] = arr[k]\n            k += 1\n        i += k; j -= k\n    return arr\n\ndef F(S):\n    N = len(S)\n    opt_len = N\n    Z = Z_algorithm(S)\n    for x in range(N//2+1,N):\n        z = Z[x]\n        if x + z >= N:\n            opt_len = x\n            break\n    return S[:opt_len] * 2\n\nS = F(S)\nS = F(S)\nT = F(S)\nS = S[:len(S)//2]\nT = T[:len(T)//2]\n\nS = np.array(list(S)) - ord('a')\nT = np.array(list(T)) - ord('a')\n\n# S,T,TS,TST,...\n\nL = [len(S), len(T)]\nfor _ in range(100):\n    L.append(L[-1] + L[-2])\nctr = [np.bincount(S,minlength=26), np.bincount(T,minlength=26)]\nfor _ in range(100):\n    ctr.append(ctr[-1] + ctr[-2])\n\ndef get_dist(N,R):\n    # S_NにおけるR番目以下\n    if N == 0:\n        return np.bincount(S[:R],minlength=26)\n    if N == 1:\n        return np.bincount(T[:R],minlength=26)\n    if L[N-1] >= R:\n        return get_dist(N-1,R)\n    return ctr[N-1] + get_dist(N-2,R-L[N-1])\n\nc = get_dist(99,r) - get_dist(99,l-1)\n\nprint(*c)"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n\n    // check\n    assert!(ret.len() % 2 == 0);\n    for i in 0..ret.len() / 2 {\n        assert!(ret[i] == ret[i + ret.len() / 2]);\n    }\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            assert!(lens[2] - lens[1] == lens[1] - lens[0]);\n            let v = lens[i] + (lens[i] - lens[i - 1]);\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (&range, &cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n                assert!(range.1 - prev + skip <= prev);\n                assert!(prev - range.0 + range.1 - prev + skip - skip == range.1 - range.0);\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (&range, &cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for i in 0..sa.len() {\n            let index = rank[i];\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let l = l - 1;\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s.as_slice());\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table =\n        rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s.as_slice()));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n\n    let mut table: Vec<[u64; 26]> = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n    fn add_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] += b[i];\n        }\n    }\n\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n\n    let ans = if (n / 2) % (m - n / 2) == 0 {\n        let d = (m - n / 2) as u64;\n        let mut ans = table[d as usize].clone();\n        ans.iter_mut().for_each(|x| *x *= r / d - l / d);\n        add_assign(&mut ans, &table[(l % d) as usize]);\n        add_assign(&mut ans, &table[(r % d) as usize]);\n        ans\n    } else {\n        let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n        loop {\n            let (m, count_m) = seq[seq.len() - 2];\n            let (n, count_n) = seq[seq.len() - 1];\n            seq.push((m + n, add(&count_m, &count_n)));\n            if r < n + m {\n                break;\n            }\n        }\n\n        fn dfs(\n            l: u64,\n            r: u64,\n            k: usize,\n            seq: &[(u64, [u64; 26])],\n            table: &[[u64; 26]],\n        ) -> [u64; 26] {\n            let n = seq[k].0;\n            assert!(l < r);\n            assert!(r <= n);\n            if k == 0 || k == 1 {\n                sub(&table[r as usize], &table[l as usize])\n            } else if l == 0 && r == n {\n                seq[k].1\n            } else {\n                let c = seq[k - 1].0;\n                let mut ans = [0; 26];\n                if l < c {\n                    add_assign(&mut ans, &dfs(l, r.min(c), k - 1, seq, table));\n                }\n                if c < r {\n                    add_assign(&mut ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                }\n                ans\n            }\n        };\n\n        dfs(l, r, seq.len() - 1, &seq, &table)\n    };\n\n    println!(\n        \"{}\",\n        ans.iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            let v = lens[i] + (lens[i] - lens[i - 1]);\n            lens.push(v);\n        }\n    }\n    let mut cnts = vec![0; 26];\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let BASE = 1e+9 as usize + 7;\n    let mut POW_BASE = 1;\n    let MOD = 1e9 as usize + 9;\n    let mut skip = 0;\n    let mut left = 0;\n    let mut right = 0;\n    for i in 0..s.len() / 2 - 1 {\n        left = (left * BASE + (s[i] as u8 - 'a' as u8) as usize) % MOD;\n        right = (right + POW_BASE * (s[s.len() - i - 1] as u8 - 'a' as u8) as usize) % MOD;\n        POW_BASE = (POW_BASE * BASE) % MOD;\n        if left == right {\n            skip = i + 1;\n        }\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n\n    // check\n    assert!(ret.len() % 2 == 0);\n    for i in 0..ret.len() / 2 {\n        assert!(ret[i] == ret[i + ret.len() / 2]);\n    }\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            assert!(lens[2] - lens[1] == lens[1] - lens[0]);\n            let v = lens[i] * 2;\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        // println!(\"{} {}\", i, ranges.len());\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (&range, &cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n                assert!(range.1 - prev + skip <= prev);\n                assert!(prev - range.0 + range.1 - prev + skip - skip == range.1 - range.0);\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (&range, &cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n\n#[test]\nfn test() {\n    solve(&vec!['a'; 200000], 10, 10000000000000000);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            let v = lens[i] + (lens[i] - lens[i - 1]);\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (&range, &cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (&range, &cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nfn error_function(a: &Vec<usize>) -> Vec<usize> {\n    let n = a.len();\n    let mut err: Vec<usize> = vec![0; n+1];\n\n    for i in 2..n+1 {\n        let mut now = err[i-1];\n        while now > 0 && a[i-1] != a[now] {\n            now = err[now];\n        }\n        if a[i-1] == a[now] {\n            err[i] = now + 1;\n        } else {\n            err[i] = 0;\n        }\n    }\n    err\n}\n\nfn compute(s: &Vec<usize>, c: usize, l: usize) -> Vec<usize> {\n    let n = s.len();\n    let mut ret = vec![0; 26];\n    let mut par = vec![0; 26];\n    if n % c == 0 {\n        for i in 0..n {\n            par[s[i]] += 1;\n        }\n        let cn = l / n;\n        for i in 0..26 {\n            ret[i] = par[i] * cn;\n        }\n        for i in 0..l%c {\n            ret[s[i]] += 1;\n        }\n    } else {\n        let mut len = vec![0; 120];\n        let mut vec = vec![vec![0; 26]; 120];\n        for i in 0..n {\n            vec[0][s[i]] += 1;\n            vec[1][s[i]] += 1;\n        }\n        for i in 0..c {\n            vec[1][s[i]] += 1;\n        }\n\n        len[0] = n;\n        len[1] = n + c;\n        for i in 2..len.len() {\n            len[i] = len[i-1] + len[i-2];\n            for j in 0..26 {\n                vec[i][j] = vec[i-1][j] + vec[i-2][j];\n            }\n            if len[i] >= l {\n                return count(i, l, &len, &vec, &s)\n            }\n        }\n    }\n    ret\n}\n\nfn count(level: usize, head: usize, len: &Vec<usize>, vec: &Vec<Vec<usize>>, s: &Vec<usize>) -> Vec<usize> {\n    let mut ret = vec![0; 26];\n    if level == 0 {\n        for i in 0..head {\n            ret[s[i]] += 1;\n        }\n        ret\n    } else if level == 1 {\n        let n = s.len();\n        for i in 0..head {\n            ret[s[i%n]] += 1;\n        }\n        ret\n    } else {\n        if head <= len[level-1] {\n            count(level-1, head, len, vec, s)\n        } else {\n            let x = count(level-2, head - len[level-1], len, vec, s);\n            for i in 0..26 {\n                ret[i] += vec[level-1][i];\n                ret[i] += x[i];\n            }\n            ret\n        }\n    }\n}\n\nfn main() {\n    let s: String = read();\n    let s = s.into_bytes();\n    let mut s: Vec<usize> = s.into_iter().map(|x| (x - 'a' as u8) as usize).collect();\n    let n = s.len();\n    let s = s.split_off(n / 2);\n\n    let (l, r): (usize, usize) = read();\n    let n = s.len();\n    let err = error_function(&s);\n    let cycle = n - err[err.len()-1];\n\n    let ll = compute(&s, cycle, l-1);\n    let rr = compute(&s, cycle, r);\n\n    for i in 0..26 {\n        if i >= 1 {\n            print!(\" \");\n        }\n        print!(\"{}\", rr[i] - ll[i]);\n    }\n    println!();\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n\n    // check\n    assert!(ret.len() % 2 == 0);\n    for i in 0..ret.len() / 2 {\n        assert!(ret[i] == ret[i + ret.len() / 2]);\n    }\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            assert!(lens[2] - lens[1] == lens[1] - lens[0]);\n            let v = lens[i] + (lens[i] - lens[i - 1]);\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (range, cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(*range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n                assert!(range.1 - prev + skip <= prev);\n                assert!(prev - range.0 + range.1 - prev + skip - skip == range.1 - range.0);\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (range, cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for i in 0..sa.len() {\n            let index = rank[i];\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let r = r + 1;\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s.as_slice());\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table =\n        rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s.as_slice()));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n\n    let mut table: Vec<[u64; 26]> = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n    fn add_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] += b[i];\n        }\n    }\n\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n\n    let ans = if (n / 2) % (m - n / 2) == 0 {\n        let d = (m - n / 2) as u64;\n        let mut ans = table[d as usize];\n        ans.iter_mut().for_each(|x| *x *= r / d - l / d);\n        add_assign(&mut ans, &table[(l % d) as usize]);\n        add_assign(&mut ans, &table[(r % d) as usize]);\n        ans\n    } else {\n        let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n        loop {\n            let (m, count_m) = seq[seq.len() - 2];\n            let (n, count_n) = seq[seq.len() - 1];\n            seq.push((m + n, add(&count_m, &count_n)));\n            if r < n + m {\n                break;\n            }\n        }\n\n        fn dfs(\n            l: u64,\n            r: u64,\n            k: usize,\n            seq: &[(u64, [u64; 26])],\n            table: &[[u64; 26]],\n        ) -> [u64; 26] {\n            let n = seq[k].0;\n            assert!(l < r);\n            assert!(r <= n);\n            if k == 0 || k == 1 {\n                sub(&table[r as usize], &table[l as usize])\n            } else if l == 0 && r == n {\n                seq[k].1\n            } else {\n                let c = seq[k - 1].0;\n                let mut ans = [0; 26];\n                if l < c {\n                    add_assign(&mut ans, &dfs(l, r.min(c), k - 1, seq, table));\n                }\n                if c < r {\n                    add_assign(&mut ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                }\n                ans\n            }\n        };\n\n        dfs(l, r, seq.len() - 1, &seq, &table)\n    };\n\n    println!(\n        \"{}\",\n        ans.iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for &index in &rank {\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\n#[allow(clippy::many_single_char_names)]\nfn solve(s: &[char], l: u64, r: u64) -> [u64; 26] {\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s);\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table = rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n\n    let mut table: Vec<[u64; 26]> = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n    fn add_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] += b[i];\n        }\n    }\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n    fn sub_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] -= b[i];\n        }\n    }\n\n    if (n / 2) % (m - n / 2) == 0 {\n        let d = (m - n / 2) as u64;\n        let mut ans = table[d as usize];\n        ans.iter_mut().for_each(|x| *x *= r / d - l / d);\n        add_assign(&mut ans, &table[(r % d) as usize]);\n        sub_assign(&mut ans, &table[(l % d) as usize]);\n        ans\n    } else {\n        let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n        loop {\n            let (m, count_m) = seq[seq.len() - 2];\n            let (n, count_n) = seq[seq.len() - 1];\n            seq.push((m + n, add(&count_m, &count_n)));\n            if r < n + m {\n                break;\n            }\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn dfs(\n            l: u64,\n            r: u64,\n            k: usize,\n            seq: &[(u64, [u64; 26])],\n            table: &[[u64; 26]],\n        ) -> [u64; 26] {\n            let n = seq[k].0;\n            assert!(l < r);\n            assert!(r <= n);\n            if k == 0 || k == 1 {\n                sub(&table[r as usize], &table[l as usize])\n            } else if l == 0 && r == n {\n                seq[k].1\n            } else {\n                let c = seq[k - 1].0;\n                let mut ans = [0; 26];\n                if l < c {\n                    add_assign(&mut ans, &dfs(l, r.min(c), k - 1, seq, table));\n                }\n                if c < r {\n                    add_assign(&mut ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                }\n                ans\n            }\n        };\n\n        dfs(l, r, seq.len() - 1, &seq, &table)\n    }\n}\n\nfn brute(s: &[char], l: u64, r: u64) -> [u64; 26] {\n    let l = l as usize;\n    let r = r as usize;\n    let mut s = s.to_vec();\n\n    while s.len() <= r {\n        let n = s.len();\n        let sa = suffix_array::suffix_array(s.as_slice());\n        let mut rank = vec![0; n];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let sparse_table =\n            rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s.as_slice()));\n        let lcp = |u: usize, v: usize| -> usize {\n            if u == v {\n                n - u\n            } else {\n                let l = rank[u];\n                let r = rank[v];\n                let (l, r) = (l.min(r), l.max(r));\n                sparse_table.seq[sparse_table.query(l..r).unwrap()]\n            }\n        };\n\n        let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n        let swp = s.clone();\n        s.extend(&swp[n - m..m]);\n        eprintln!(\"s = {:?}\", s.iter().collect::<String>());\n    }\n\n    let mut ans = [0; 26];\n    for &c in &s[l..r] {\n        ans[(c as u8 - b'a') as usize] += 1;\n    }\n    ans\n}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let l = l - 1;\n\n    println!(\n        \"{}\",\n        solve(&s, l, r)\n            .iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    macro_rules! compare {\n        ($s:expr, $l:expr, $r:expr) => {{\n            let brute_result = brute(&$s.chars().collect::<Vec<_>>(), $l, $r);\n            let solve_result = solve(&$s.chars().collect::<Vec<_>>(), $l, $r);\n            assert_eq!(brute_result, solve_result);\n        }};\n    }\n\n    #[test]\n    fn test() {\n        compare!(&\"aa\", 550, 770);\n        compare!(&\"abaaabaa\", 550, 770);\n        compare!(&\"abaaba\", 550, 770);\n        compare!(&\"abaaba\", 550, 770);\n        compare!(\n            &std::iter::repeat(\"abracadabra\").take(6).collect::<String>(),\n            550,\n            770\n        );\n        compare!(\n            &std::iter::repeat(\"abcab\").take(6).collect::<String>(),\n            550,\n            770\n        );\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n\n    // check\n    assert!(ret.len() % 2 == 0);\n    for i in 0..ret.len() / 2 {\n        assert!(ret[i] == ret[i + ret.len() / 2]);\n    }\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            let v = lens[i] + (lens[i] - lens[i - 1]);\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (&range, &cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (&range, &cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for i in 0..sa.len() {\n            let index = rank[i];\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let r = r + 1;\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s.as_slice());\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table =\n        rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s.as_slice()));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n\n    let mut table = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n\n    let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n    loop {\n        let (m, count_m) = seq[seq.len() - 2];\n        let (n, count_n) = seq[seq.len() - 1];\n        seq.push((m + n, add(&count_m, &count_n)));\n        if r < n + m {\n            break;\n        }\n    }\n\n    fn dfs(l: u64, r: u64, k: usize, seq: &[(u64, [u64; 26])], table: &[[u64; 26]]) -> [u64; 26] {\n        let n = seq[k].0;\n        assert!(l < r);\n        assert!(r <= n);\n        if k == 0 || k == 1 {\n            sub(&table[r as usize], &table[l as usize])\n        } else if l == 0 && r == n {\n            seq[k].1\n        } else {\n            let c = seq[k - 1].0;\n            let mut ans = [0; 26];\n            if l < c {\n                let swp = add(&ans, &dfs(l, r.min(c), k - 1, seq, table));\n                ans = swp.clone();\n            }\n            if c < r {\n                let swp = add(&ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                ans = swp.clone();\n            }\n            ans\n        }\n    };\n\n    println!(\n        \"{}\",\n        dfs(l, r, seq.len() - 1, &seq, &table)\n            .iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n\n    // check\n    assert!(ret.len() % 2 == 0);\n    for i in 0..ret.len() / 2 {\n        assert!(ret[i] == ret[i + ret.len() / 2]);\n    }\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            assert!(lens[2] - lens[1] == lens[1] - lens[0]);\n            let v = lens[i] * 2;\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        // println!(\"{} {}\", i, ranges.len());\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (&range, &cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n                assert!(range.1 - prev + skip <= prev);\n                assert!(prev - range.0 + range.1 - prev + skip - skip == range.1 - range.0);\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (&range, &cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n\n#[test]\nfn test() {\n    solve(&vec!['a'; 200000], 10, 10000000000000000);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for i in 0..sa.len() {\n            let index = rank[i];\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let r = r + 1;\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s.as_slice());\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table =\n        rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s.as_slice()));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (1..n)\n        .filter(|&i| i != n / 2 && lcp(0, i) == n - i)\n        .last()\n        .unwrap_or(n);\n\n    let mut table = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n\n    let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n    loop {\n        let (m, count_m) = seq[seq.len() - 2];\n        let (n, count_n) = seq[seq.len() - 1];\n        seq.push((m + n, add(&count_m, &count_n)));\n        if r < n + m {\n            break;\n        }\n    }\n\n    fn dfs(l: u64, r: u64, k: usize, seq: &[(u64, [u64; 26])], table: &[[u64; 26]]) -> [u64; 26] {\n        let n = seq[k].0;\n        assert!(l < r);\n        assert!(r <= n);\n        if k == 0 || k == 1 {\n            sub(&table[r as usize], &table[l as usize])\n        } else if l == 0 && r == n {\n            seq[k].1\n        } else {\n            let c = seq[k - 1].0;\n            let mut ans = [0; 26];\n            if l < c {\n                let swp = add(&ans, &dfs(l, r.min(c), k - 1, seq, table));\n                ans = swp.clone();\n            }\n            if c < r {\n                let swp = add(&ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                ans = swp.clone();\n            }\n            ans\n        }\n    };\n\n    println!(\n        \"{}\",\n        dfs(l, r, seq.len() - 1, &seq, &table)\n            .iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for i in 0..sa.len() {\n            let index = rank[i];\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let l = l - 1;\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s.as_slice());\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table =\n        rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s.as_slice()));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n\n    let mut table: Vec<[u64; 26]> = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n    fn add_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] += b[i];\n        }\n    }\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n    fn sub_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] -= b[i];\n        }\n    }\n\n    let ans = if (n / 2) % (m - n / 2) == 0 {\n        let d = (m - n / 2) as u64;\n        let mut ans = table[d as usize].clone();\n        ans.iter_mut().for_each(|x| *x *= r / d - l / d);\n        add_assign(&mut ans, &table[(r % d) as usize]);\n        sub_assign(&mut ans, &table[(l % d) as usize]);\n        ans\n    } else {\n        let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n        loop {\n            let (m, count_m) = seq[seq.len() - 2];\n            let (n, count_n) = seq[seq.len() - 1];\n            seq.push((m + n, add(&count_m, &count_n)));\n            if r < n + m {\n                break;\n            }\n        }\n\n        fn dfs(\n            l: u64,\n            r: u64,\n            k: usize,\n            seq: &[(u64, [u64; 26])],\n            table: &[[u64; 26]],\n        ) -> [u64; 26] {\n            let n = seq[k].0;\n            assert!(l < r);\n            assert!(r <= n);\n            if k == 0 || k == 1 {\n                sub(&table[r as usize], &table[l as usize])\n            } else if l == 0 && r == n {\n                seq[k].1\n            } else {\n                let c = seq[k - 1].0;\n                let mut ans = [0; 26];\n                if l < c {\n                    add_assign(&mut ans, &dfs(l, r.min(c), k - 1, seq, table));\n                }\n                if c < r {\n                    add_assign(&mut ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                }\n                ans\n            }\n        };\n\n        dfs(l, r, seq.len() - 1, &seq, &table)\n    };\n\n    println!(\n        \"{}\",\n        ans.iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nfn error_function(a: &Vec<usize>) -> Vec<usize> {\n    let n = a.len();\n    let mut err: Vec<usize> = vec![0; n+1];\n\n    for i in 2..n+1 {\n        let mut now = err[i-1];\n        while now > 0 && a[i-1] != a[now] {\n            now = err[now];\n        }\n        if a[i-1] == a[now] {\n            err[i] = now + 1;\n        } else {\n            err[i] = 0;\n        }\n    }\n    err\n}\n\nfn compute(s: &Vec<usize>, c: usize, l: usize) -> Vec<usize> {\n    let n = s.len();\n    let mut ret = vec![0; 26];\n    let mut par = vec![0; 26];\n    if n % c == 0 {\n        for i in 0..n {\n            par[s[i]] += 1;\n        }\n        let cn = l/n;\n        for i in 0..26 {\n            ret[i] = par[i] * cn;\n        }\n        for i in 0..l%n {\n            ret[s[i]] += 1;\n        }\n    } else {\n        let mut len = vec![0; 120];\n        let mut vec = vec![vec![0; 26]; 120];\n        for i in 0..n {\n            vec[0][s[i]] += 1;\n            vec[1][s[i]] += 1;\n        }\n        for i in 0..c {\n            vec[1][s[i]] += 1;\n        }\n\n        len[0] = n;\n        len[1] = n + c;\n        for i in 2..len.len() {\n            len[i] = len[i-1] + len[i-2];\n            for j in 0..26 {\n                vec[i][j] = vec[i-1][j] + vec[i-2][j];\n            }\n            if len[i] >= l {\n                return count(i, l, &len, &vec, &s)\n            }\n        }\n    }\n    ret\n}\n\nfn count(level: usize, head: usize, len: &Vec<usize>, vec: &Vec<Vec<usize>>, s: &Vec<usize>) -> Vec<usize> {\n    let mut ret = vec![0; 26];\n    if level <= 1 {\n        let n = s.len();\n        for i in 0..head {\n            ret[s[i%n]] += 1;\n        }\n        ret\n    } else {\n        if head <= len[level-1] {\n            count(level-1, head, len, vec, s)\n        } else {\n            let x = count(level-2, head - len[level-1], len, vec, s);\n            for i in 0..26 {\n                ret[i] += vec[level-1][i];\n                ret[i] += x[i];\n            }\n            ret\n        }\n    }\n}\n\nfn main() {\n    let s: String = read();\n    let s = s.into_bytes();\n    let mut s: Vec<usize> = s.into_iter().map(|x| (x - 'a' as u8) as usize).collect();\n    let n = s.len();\n    let s = s.split_off(n / 2);\n\n    let (l, r): (usize, usize) = read();\n    let n = s.len();\n    let err = error_function(&s);\n    let cycle = n - err[err.len()-1];\n\n    let ll = compute(&s, cycle, l-1);\n    let rr = compute(&s, cycle, r);\n\n    for i in 0..26 {\n        if i >= 1 {\n            print!(\" \");\n        }\n        print!(\"{}\", rr[i] - ll[i]);\n    }\n    println!();\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn print_s(s: &Vec<char>) {\n    for &c in s.iter() {\n        print!(\"{}\", c);\n    }\n    println!(\"\");\n}\n\nfn expand_s(s: &Vec<char>) -> Vec<char> {\n    let mut skip = 0;\n    'inner_loop: for i in s.len() / 2 + 1..s.len() {\n        for j in i..s.len() {\n            if s[j] != s[j - i] {\n                continue 'inner_loop;\n            }\n        }\n        skip = s.len() - i;\n        break;\n    }\n    // println!(\"{}\", skip);\n    let ret = s.iter()\n        .chain(s[skip..s.len() - skip].iter())\n        .cloned()\n        .collect::<Vec<_>>();\n\n    // check\n    assert!(ret.len() % 2 == 0);\n    for i in 0..ret.len() / 2 {\n        assert!(ret[i] == ret[i + ret.len() / 2]);\n    }\n    ret\n}\n\n#[allow(dead_code)]\nfn naive(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut s = s.clone();\n    while s.len() < r {\n        s = expand_s(&s);\n    }\n    let mut cnts = vec![0; 26];\n    for i in l..r {\n        cnts[(s[i] as u8 - 'a' as u8) as usize] += 1;\n    }\n    cnts\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize) -> Vec<usize> {\n    let mut temp_s = s.clone();\n    let mut lens = vec![s.len()];\n    for _ in 0..2 {\n        temp_s = expand_s(&temp_s);\n        lens.push(temp_s.len());\n    }\n    // println!(\"{:?}\", lens);\n    for i in 2.. {\n        if r <= lens[i] {\n            break;\n        }\n        if lens[0] + lens[1] == lens[2] {\n            let v = lens[i - 1] + lens[i];\n            lens.push(v);\n        } else {\n            // assert!(lens[2] - lens[1] == lens[1] - lens[0]);\n            let v = lens[i] + (lens[i] - lens[i - 1]);\n            lens.push(v);\n        }\n    }\n    // println!(\"{:?}\", lens);\n    let mut ranges = HashMap::<(usize, usize), usize>::new();\n    ranges.insert((l, r), 1);\n    for i in (1..lens.len()).rev() {\n        let mut nranges = HashMap::<(usize, usize), usize>::new();\n        let skip = lens[i - 1] - lens[i] / 2;\n        let prev = lens[i - 1];\n        for (&range, &cnt) in ranges.iter() {\n            if range.1 <= prev {\n                *nranges.entry(range).or_insert(0) += cnt;\n            } else if prev <= range.0 {\n                let offset = range.0 - prev;\n                *nranges\n                    .entry((skip + offset, range.1 - prev + skip))\n                    .or_insert(0) += cnt;\n            } else {\n                *nranges.entry((range.0, prev)).or_insert(0) += cnt;\n                *nranges.entry((skip, range.1 - prev + skip)).or_insert(0) += cnt;\n                assert!(range.1 - prev + skip <= prev);\n                assert!(prev - range.0 + range.1 - prev + skip - skip == range.1 - range.0);\n            }\n        }\n        ranges = nranges;\n    }\n    let mut cnts = vec![0; 26];\n    for (&range, &cnt) in ranges.iter() {\n        for i in range.0..range.1 {\n            cnts[(s[i] as u8 - 'a' as u8) as usize] += cnt;\n        }\n    }\n    cnts\n}\n\nfn main() {\n    let s = read::<String>().chars().collect::<Vec<char>>();\n    let l = read::<usize>() - 1;\n    let r = read::<usize>();\n    let cnts = solve(&s, l, r);\n    for i in 0..26 {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", cnts[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n// ordtools {{{\n#[allow(dead_code)]\nmod ordtools {\n    pub trait Ordtools: PartialOrd + Clone + Sized {\n        fn change_min(&mut self, rhs: &Self) {\n            if rhs < self {\n                *self = rhs.clone();\n            }\n        }\n\n        fn change_max(&mut self, rhs: &Self) {\n            if rhs > self {\n                *self = rhs.clone();\n            }\n        }\n    }\n\n    impl<T: PartialOrd + Clone + Sized> Ordtools for T {}\n}\n// }}}\n// rmq {{{\n#[allow(dead_code)]\nmod rmq {\n    use super::ordtools::Ordtools;\n    use std::ops::{Bound, Range, RangeBounds};\n\n    // TODO: クレートを分けます。\n    trait BitPosition {\n        fn pow_of_two(self) -> usize;\n    }\n\n    impl BitPosition for usize {\n        fn pow_of_two(self) -> usize {\n            1 << self\n        }\n    }\n\n    trait Bit {\n        fn flip(self) -> Self;\n        fn reverse_and_flip(self) -> Self;\n        fn lg_unchecked(self) -> u32;\n        fn lg_usize_unchecked(self) -> usize;\n        fn lg(self) -> Option<u32>;\n        fn lg_usize(self) -> Option<usize>;\n        fn lg_ceil(self) -> u32;\n        fn lg_ceil_usize(self) -> usize;\n    }\n\n    impl Bit for usize {\n        fn flip(self) -> Self {\n            self ^ std::usize::MAX\n        }\n        fn reverse_and_flip(self) -> Self {\n            self.reverse_bits() ^ std::usize::MAX\n        }\n        fn lg_ceil(self) -> u32 {\n            self.next_power_of_two().trailing_zeros()\n        }\n        fn lg_ceil_usize(self) -> usize {\n            self.lg_ceil() as usize\n        }\n        fn lg_unchecked(self) -> u32 {\n            (self + 1).lg_ceil() - 1\n        }\n        fn lg_usize_unchecked(self) -> usize {\n            self.lg_unchecked() as usize\n        }\n        fn lg(self) -> Option<u32> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_unchecked())\n            }\n        }\n        fn lg_usize(self) -> Option<usize> {\n            if self == 0 {\n                None\n            } else {\n                Some(self.lg_usize_unchecked())\n            }\n        }\n    }\n\n    pub struct FastMinimum {\n        lca: Box<LeastCommonAncestor>,\n    }\n    impl FastMinimum {\n        pub fn build<T: Ord>(seq: &[T]) -> Self {\n            assert!(!seq.is_empty());\n            let parent = construct_cartesian_tree(seq);\n            let mut tree = vec![vec![]; seq.len()];\n            let mut root = 0;\n            for (i, &p) in parent.iter().enumerate() {\n                if i == p {\n                    root = i;\n                } else {\n                    tree[i].push(p);\n                    tree[p].push(i);\n                }\n            }\n            Self {\n                lca: Box::new(LeastCommonAncestor::from_tree(root, &tree)),\n            }\n        }\n\n        pub fn query(&self, range: impl RangeBounds<usize>) -> Option<usize> {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    if x == 0 {\n                        return None;\n                    } else {\n                        x - 1\n                    }\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            if start > end {\n                None\n            } else {\n                Some(self.lca.query(start, end))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: impl RangeBounds<usize>) -> usize {\n            let start = match range.start_bound() {\n                Bound::Excluded(&x) => x + 1,\n                Bound::Included(&x) => x,\n                Bound::Unbounded => 0,\n            };\n            let end = match range.end_bound() {\n                Bound::Excluded(&x) => {\n                    assert!(x != 0);\n                    x - 1\n                }\n                Bound::Included(&x) => x,\n                Bound::Unbounded => self.lca.vertex_count() - 1,\n            };\n            assert!(start <= end);\n            self.lca.query(start, end)\n        }\n    }\n\n    pub fn construct_cartesian_tree<T: Ord>(seq: &[T]) -> Vec<usize> {\n        let mut p = vec![0; seq.len()];\n        let mut stack = Vec::with_capacity(seq.len());\n        stack.push(0);\n        for x in 1..seq.len() {\n            if let Some((j, y)) = stack\n                .iter()\n                .copied()\n                .enumerate()\n                .rfind(|&(_, y)| seq[y] <= seq[x])\n            {\n                p[x] = y;\n                if j != stack.len() - 1 {\n                    let z = stack[j + 1];\n                    p[z] = x;\n                }\n                stack.truncate(j + 1);\n                stack.push(x);\n            } else {\n                p[stack[0]] = x;\n                p[x] = x;\n                stack = vec![x];\n            }\n        }\n        p\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct LeastCommonAncestor {\n        span: Vec<Range<usize>>,\n        time_to_id: Vec<usize>,\n        compound_table: CompoundTable,\n    }\n\n    impl LeastCommonAncestor {\n        pub fn vertex_count(&self) -> usize {\n            self.span.len()\n        }\n\n        pub fn from_tree(root: usize, tree: &[Vec<usize>]) -> Self {\n            // dfs に渡したい環境変数を束ねます。\n            #[derive(Debug, Eq, PartialEq)]\n            struct Env<'a> {\n                time: usize,\n                time_to_id: Vec<usize>,\n                span: Vec<Range<usize>>,\n                depth_table: Vec<usize>,\n                tree: &'a [Vec<usize>],\n            }\n            let mut env = Env {\n                time: 0,\n                time_to_id: vec![0; tree.len() * 2 - 1],\n                depth_table: vec![0; tree.len() * 2 - 1],\n                span: vec![tree.len() * 2 - 1..0; tree.len()],\n                tree,\n            };\n\n            fn dfs(x: usize, p: usize, d: usize, env: &mut Env) {\n                env.time_to_id[env.time] = x;\n                env.depth_table[env.time] = d;\n                env.span[x].start.change_min(&env.time);\n                env.time += 1;\n\n                for y in env.tree[x].iter().copied().filter(|&y| y != p) {\n                    dfs(y, x, d + 1, env);\n                    env.time_to_id[env.time] = x;\n                    env.depth_table[env.time] = d;\n                    env.time += 1;\n                }\n                env.span[x].end.change_max(&(env.time));\n            }\n            dfs(root, root, 0, &mut env);\n\n            Self {\n                span: env.span,\n                time_to_id: env.time_to_id,\n                compound_table: CompoundTable::from_vec(env.depth_table),\n            }\n        }\n\n        pub fn query(&self, u: usize, v: usize) -> usize {\n            let Range {\n                start: start_u,\n                end: end_u,\n            } = self.span[u];\n            let Range {\n                start: start_v,\n                end: end_v,\n            } = self.span[v];\n            self.time_to_id[self\n                .compound_table\n                .query_nonempty(start_u.min(start_v)..end_u.max(end_v))]\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct CompoundTable {\n        seq: Vec<usize>,\n        block_size: usize,\n        pattern: Vec<usize>,\n        encyclopedia: Encyclopedia,\n        sparse_table: SparseTable<usize>,\n    }\n    impl CompoundTable {\n        #[inline]\n        pub fn from_vec(seq: Vec<usize>) -> Self {\n            let block_size = seq\n                .len()\n                .lg_usize()\n                .map(|x| ((x as f64) * 0.65) as usize)\n                .unwrap_or(1)\n                .max(1);\n            Self::from_vec_with_block_size(seq, block_size)\n        }\n\n        pub fn from_vec_with_block_size(seq: Vec<usize>, block_size: usize) -> Self {\n            assert!(block_size <= seq.len());\n            assert!(!seq.is_empty());\n            assert!(\n                (0..seq.len() - 1).all(|i| seq[i] + 1 == seq[i + 1] || seq[i] == seq[i + 1] + 1)\n            );\n\n            // ブロックごとのパターンを計算です。\n            let mut pattern = vec![0; (seq.len() + block_size - 1) / block_size];\n            for (i, x) in pattern.iter_mut().enumerate() {\n                let mut coeff = 1;\n                for j in block_size * i + 1..(block_size * (i + 1)).min(seq.len()) {\n                    if seq[j - 1] > seq[j] {\n                        *x += coeff;\n                    }\n                    coeff += coeff;\n                }\n            }\n            let encyclopedia = Encyclopedia::with_len(block_size);\n            let sparse_table = SparseTable::from_vec(\n                pattern\n                    .iter()\n                    .copied()\n                    .enumerate()\n                    .map(|(i, seq_id)| {\n                        seq[block_size * i + encyclopedia.query_nonempty(seq_id, 0..block_size)]\n                    })\n                    .collect(),\n            );\n\n            Self {\n                block_size,\n                seq,\n                pattern,\n                encyclopedia,\n                sparse_table,\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let k = self.block_size;\n            let start_block = start / k;\n            let start_rem = start - start_block * k;\n            let end_block = end / k;\n            let end_rem = end - end_block * k;\n            if start_block == end_block {\n                start_block * self.block_size\n                    + self\n                        .encyclopedia\n                        .query_nonempty(self.pattern[start_rem], start_rem..end_rem)\n            } else {\n                let left = self\n                    .encyclopedia\n                    .query(self.pattern[start_block], start_rem..self.block_size)\n                    .map(|i| start_block * self.block_size + i);\n                let center =\n                    self.sparse_table\n                        .query(start_block + 1..end_block)\n                        .map(|central_block| {\n                            central_block * self.block_size\n                                + self\n                                    .encyclopedia\n                                    .query_nonempty(self.pattern[central_block], 0..self.block_size)\n                        });\n                let right = self\n                    .pattern\n                    .get(end_block)\n                    .and_then(|&pattern| self.encyclopedia.query(pattern, 0..end_rem))\n                    .map(|i| end_block * self.block_size + i);\n                [left, center, right]\n                    .iter()\n                    .flatten()\n                    .copied()\n                    .min_by_key(|&i| self.seq[i]) // std::cmp::min は同点の場合 first が優先です。\n                    .unwrap()\n            }\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct SparseTable<T: Ord + std::fmt::Debug> {\n        pub seq: Vec<T>,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl<T: Ord + std::fmt::Debug> SparseTable<T> {\n        pub fn from_vec(seq: Vec<T>) -> Self {\n            let n = seq.len();\n            let h = n.lg_usize().unwrap_or(0) + 1;\n            let mut table = vec![vec![0; n]; h];\n            table[0] = (0..n).collect();\n            let mut d = 1;\n            for i in 1..h {\n                let (left, right) = table.split_at_mut(i);\n                let crr = &mut right[0];\n                crr.copy_from_slice(&left[i - 1]);\n                for j in d..seq.len() {\n                    if seq[crr[j - d]] > seq[crr[j]] {\n                        crr[j - d] = crr[j];\n                    }\n                }\n                d += d;\n            }\n            Self { table, seq }\n        }\n\n        #[inline]\n        pub fn query(&self, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(range))\n            }\n        }\n\n        pub fn query_nonempty(&self, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            let d = match end - start {\n                1 => 1,\n                _ => ((end - start).next_power_of_two() as usize) / 2,\n            };\n            assert!(d <= end - start && end - start <= 2 * d);\n            let row = &self.table[d.trailing_zeros() as usize];\n            let mut ans = row[start];\n            if let Some(&x) = row.get(end - d) {\n                // ans < x は保証されています。\n                if self.seq[ans] > self.seq[x] {\n                    ans = x;\n                }\n            }\n            ans\n        }\n    }\n\n    #[derive(Debug, Clone, Eq, PartialEq)]\n    pub struct Encyclopedia {\n        len: usize,\n        table: Vec<Vec<usize>>,\n    }\n\n    impl Encyclopedia {\n        pub fn with_len(len: usize) -> Self {\n            Self {\n                len,\n                table: if len == 0 {\n                    vec![vec![]]\n                } else {\n                    let mut ans = vec![vec![0; len]; (len - 1).pow_of_two()];\n                    let mut a: Vec<usize> = (0..len).collect();\n                    for ans in ans.iter_mut() {\n                        // 累積 min-position を計算していきます。\n                        ans[0] = 0;\n                        for i in 1..len {\n                            let j = ans[i - 1];\n                            ans[i] = if a[j] <= a[i] { j } else { i };\n                        }\n\n                        // a を次のイテレーションで使うものに変えます。\n                        // もっとも左の Pos を Neg に変えて、それより前をすべて Pos に変えます。\n                        if let Some(s) = (0..len - 1).find(|&i| a[i] < a[i + 1]) {\n                            a[s] = a[s + 1] + 1;\n                            (0..s).rev().for_each(|i| a[i] = a[i + 1] - 1);\n                        }\n                    }\n                    ans\n                },\n            }\n        }\n\n        #[inline]\n        pub fn query(&self, seq_id: usize, range: Range<usize>) -> Option<usize> {\n            if range.start >= range.end {\n                None\n            } else {\n                Some(self.query_nonempty(seq_id, range))\n            }\n        }\n\n        pub fn query_nonempty(&self, seq_id: usize, range: Range<usize>) -> usize {\n            let Range { start, end } = range;\n            assert!(start < end);\n            start + self.table[seq_id >> start][end - start - 1]\n        }\n    }\n\n    pub fn construct_seq_from_seq_id(len: usize, seq_id: usize) -> Vec<usize> {\n        assert!(seq_id < len.pow_of_two());\n        let mut ans = vec![2 * len; len]; // あとで調整するので、とりあえず大きめの値にしておきます。`\n        let mut x = seq_id;\n        for i in 0..len - 1 {\n            ans[i + 1] = if x % 2 == 0 { ans[i] + 1 } else { ans[i] - 1 };\n            x /= 2;\n        }\n        let diff = ans[len - 1] - (len - 1);\n        ans.iter_mut().for_each(|x| *x -= diff);\n        ans\n    }\n}\n// }}}\n// suffix_array {{{\n#[allow(dead_code)]\nmod suffix_array {\n    pub fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {\n        let n = s.len();\n        let mut ord: Vec<usize> = (0..n).collect();\n        ord.sort_by_key(|&i| &s[i]);\n        let mut cmp = vec![0; n];\n        for i in 1..n {\n            cmp[i] = if s[ord[i - 1]] == s[ord[i]] {\n                cmp[i - 1]\n            } else {\n                cmp[i - 1] + 1\n            };\n        }\n        for d in std::iter::successors(Some(1), |x| Some(x * 2)).take_while(|&x| x <= n) {\n            let mut ord_inverse = vec![0; n];\n            (0..n).for_each(|i| ord_inverse[ord[i]] = i);\n            let cmp_count = *cmp.last().unwrap() + 1;\n            let mut pos = vec![0; cmp_count];\n            for (i, &c) in cmp.iter().enumerate().rev() {\n                pos[c] = i;\n            }\n\n            let mut ord_swp = vec![0; n];\n            let mut insert = |i| {\n                let c = cmp[ord_inverse[i]];\n                ord_swp[pos[c]] = i;\n                pos[c] += 1;\n            };\n            (n - d..n).for_each(&mut insert);\n            ord.iter()\n                .filter(|&&i| d <= i)\n                .map(|i| i - d)\n                .for_each(insert);\n\n            let mut cmp_swp = vec![0; n];\n            for i in 1..n {\n                let l = ord_swp[i - 1];\n                let r = ord_swp[i];\n                cmp_swp[i] = if (\n                    cmp[ord_inverse[l]],\n                    ord_inverse.get(l + d).map(|&ld| cmp[ld]).unwrap_or(n),\n                ) == (\n                    cmp[ord_inverse[r]],\n                    ord_inverse.get(r + d).map(|&rd| cmp[rd]).unwrap_or(n),\n                ) {\n                    cmp_swp[i - 1]\n                } else {\n                    cmp_swp[i - 1] + 1\n                }\n            }\n\n            ord = ord_swp;\n            cmp = cmp_swp;\n        }\n        ord\n    }\n\n    fn calc_lcp<T: Ord>(s: &[T], pos1: usize, pos2: usize, mut lcp: usize) -> usize {\n        while pos1 + lcp < s.len() && pos1 + lcp < s.len() && s[pos1 + lcp] == s[pos2 + lcp] {\n            lcp += 1;\n        }\n        lcp\n    }\n\n    pub fn lcp_array<T: Ord>(sa: &[usize], s: &[T]) -> Vec<usize> {\n        let mut rank = vec![0; sa.len()];\n        for (i, x) in sa.iter().copied().enumerate() {\n            rank[x] = i;\n        }\n\n        let mut lcp_array = vec![0; sa.len()];\n        let mut lcp = 0;\n        for &index in &rank {\n            let pos1 = sa[index];\n            if index == sa.len() - 1 {\n                lcp_array[index] = lcp;\n                lcp = 0;\n                continue;\n            }\n\n            let pos2 = sa[index + 1];\n            lcp = calc_lcp(&s, pos1, pos2, lcp);\n            lcp_array[index] = lcp;\n            lcp = lcp.saturating_sub(1);\n        }\n\n        lcp_array\n    }\n}\n// }}}\n\n#[allow(clippy::many_single_char_names)]\nfn solve(s: &[char], l: u64, r: u64) -> [u64; 26] {\n    let n = s.len();\n\n    let sa = suffix_array::suffix_array(s);\n    let mut rank = vec![0; n];\n    for (i, x) in sa.iter().copied().enumerate() {\n        rank[x] = i;\n    }\n\n    let sparse_table = rmq::SparseTable::from_vec(suffix_array::lcp_array(sa.as_slice(), s));\n    let lcp = |u: usize, v: usize| -> usize {\n        if u == v {\n            n - u\n        } else {\n            let l = rank[u];\n            let r = rank[v];\n            let (l, r) = (l.min(r), l.max(r));\n            sparse_table.seq[sparse_table.query(l..r).unwrap()]\n        }\n    };\n\n    let m = (n / 2 + 1..n).find(|&i| lcp(0, i) == n - i).unwrap_or(n);\n\n    let mut table: Vec<[u64; 26]> = vec![[0; 26]; n + 1];\n    for i in 0..n {\n        let (left, right) = table.split_at_mut(i + 1);\n        right[0].copy_from_slice(&left[i]);\n        right[0][(s[i] as u8 - b'a') as usize] += 1;\n    }\n    fn add(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] + b[i];\n        }\n        c\n    }\n    fn add_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] += b[i];\n        }\n    }\n    fn sub(a: &[u64; 26], b: &[u64; 26]) -> [u64; 26] {\n        let mut c = [0; 26];\n        for i in 0..26 {\n            c[i] = a[i] - b[i];\n        }\n        c\n    }\n    fn sub_assign(a: &mut [u64; 26], b: &[u64; 26]) {\n        for i in 0..26 {\n            a[i] -= b[i];\n        }\n    }\n\n    if (n / 2) % (m - n / 2) == 0 {\n        let d = (m - n / 2) as u64;\n        let mut ans = table[d as usize];\n        ans.iter_mut().for_each(|x| *x *= r / d - l / d);\n        add_assign(&mut ans, &table[(r % d) as usize]);\n        sub_assign(&mut ans, &table[(l % d) as usize]);\n        ans\n    } else {\n        let mut seq = vec![(n as u64 / 2, table[n / 2]), (m as u64, table[m])];\n        loop {\n            let (m, count_m) = seq[seq.len() - 2];\n            let (n, count_n) = seq[seq.len() - 1];\n            seq.push((m + n, add(&count_m, &count_n)));\n            if r < n + m {\n                break;\n            }\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        fn dfs(\n            l: u64,\n            r: u64,\n            k: usize,\n            seq: &[(u64, [u64; 26])],\n            table: &[[u64; 26]],\n        ) -> [u64; 26] {\n            let n = seq[k].0;\n            assert!(l < r);\n            assert!(r <= n);\n            if k == 0 || k == 1 {\n                sub(&table[r as usize], &table[l as usize])\n            } else if l == 0 && r == n {\n                seq[k].1\n            } else {\n                let c = seq[k - 1].0;\n                let mut ans = [0; 26];\n                if l < c {\n                    add_assign(&mut ans, &dfs(l, r.min(c), k - 1, seq, table));\n                }\n                if c < r {\n                    add_assign(&mut ans, &dfs(0, r - l.max(c), k - 2, seq, table));\n                }\n                ans\n            }\n        };\n\n        dfs(l, r, seq.len() - 1, &seq, &table)\n    }\n}\n\n#[allow(clippy::many_single_char_names)]\nfn brute(s: &[char], l: u64, r: u64) -> [u64; 26] {\n    let l = l as usize;\n    let r = r as usize;\n    let mut s = s.to_vec();\n\n    while s.len() <= r {\n        let n = s.len();\n        let m = (n / 2 + 1..n)\n            .find(|&m| &s[m..] == &s[..n - m])\n            .unwrap_or(n);\n        let swp = s.clone();\n        s.extend(&swp[n - m..m]);\n        eprintln!(\"s = {:?}\", s.iter().collect::<String>());\n    }\n\n    let mut ans = [0; 26];\n    for &c in &s[l..r] {\n        ans[(c as u8 - b'a') as usize] += 1;\n    }\n    ans\n}\n\nfn main() {\n    input!(s: proconio::marker::Chars, l: u64, r: u64);\n    let l = l - 1;\n\n    println!(\n        \"{}\",\n        solve(&s, l, r)\n            .iter()\n            .map(|x| x.to_string())\n            .fold(String::new(), |acc, x| if acc.is_empty() {\n                x\n            } else {\n                acc + \" \" + x.as_ref()\n            })\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn compare(s: &[char], l: usize, r: usize) {\n        let brute_result = brute(s, l as u64, r as u64);\n        let solve_result = solve(s, l as u64, r as u64);\n        assert_eq!(\n            brute_result, solve_result,\n            \"s = {:?}, l = {} r = {}\",\n            &s, l, r\n        );\n    }\n\n    fn compare_str(s: &str, l: usize, r: usize) {\n        compare(&s.chars().collect::<Vec<_>>(), l, r);\n    }\n\n    #[test]\n    fn test_handmade() {\n        compare_str(&\"aa\", 550, 770);\n        compare_str(&\"abaaabaa\", 550, 770);\n        compare_str(&\"abaaba\", 550, 770);\n        compare_str(&\"abaaba\", 550, 770);\n        compare_str(&\"abcabcababcabcab\", 550, 770);\n        compare_str(\n            &std::iter::repeat(\"abracadabra\").take(6).collect::<String>(),\n            550,\n            770,\n        );\n        compare_str(\n            &std::iter::repeat(\"abcab\").take(6).collect::<String>(),\n            550,\n            770,\n        );\n    }\n\n    #[test]\n    fn test_random() {\n        let len = 77;\n        for _ in 0..100 {\n            let s = std::iter::repeat_with(|| ((rand::random::<u8>() % 13) / 12 + b'a') as char)\n                .take(len)\n                .collect::<String>();\n            let s = s.chars().chain(s.chars()).collect::<String>();\n            eprintln!(\"s = {:?}\", &s);\n        }\n    }\n}\n"
  }
]