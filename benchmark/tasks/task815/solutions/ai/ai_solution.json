[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py)\n        return false;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else if (rank[px] > rank[py]) {\n        parent[py] = px;\n    } else {\n        parent[py] = px;\n        rank[px]++;\n    }\n    return true;\n}\n\nint main() {\n    int N, u, v;\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    bool possible = true;\n    int edges = 0;\n    \n    for (int i = 1; i < N; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        \n        bool edge_added = false;\n        for (int j = 0; j < k; j++) {\n            scanf(\"%d %d\", &u, &v);\n            \n            if (!edge_added && unionSet(u, v)) {\n                edges++;\n                edge_added = true;\n            }\n        }\n        \n        if (!edge_added) {\n            possible = false;\n            break;\n        }\n    }\n    \n    if (possible && edges == N - 1) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:00:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint parent[MAX_N + 1];\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nEdge edges[MAX_N];\nint edge_count = 0;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nint union_sets(int u, int v) {\n    int root_u = find(u);\n    int root_v = find(v);\n    if (root_u == root_v) {\n        return 0;\n    }\n    parent[root_v] = root_u;\n    return 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n    }\n    \n    int possible = 1;\n    for (int i = 0; i < N - 1; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        int* set = (int*)malloc(k * sizeof(int));\n        for (int j = 0; j < k; j++) {\n            scanf(\"%d\", &set[j]);\n        }\n        \n        int found = 0;\n        for (int j = 0; j < k && !found; j++) {\n            for (int l = j + 1; l < k && !found; l++) {\n                int u = set[j];\n                int v = set[l];\n                if (find(u) != find(v)) {\n                    edges[edge_count].u = u;\n                    edges[edge_count].v = v;\n                    edge_count++;\n                    union_sets(u, v);\n                    found = 1;\n                }\n            }\n        }\n        \n        if (!found) {\n            possible = 0;\n        }\n        free(set);\n    }\n    \n    if (possible && edge_count == N - 1) {\n        printf(\"YES\\n\");\n        for (int i = 0; i < edge_count; i++) {\n            printf(\"%d %d\\n\", edges[i].u, edges[i].v);\n        }\n    } else {\n        printf(\"NO\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent, rank;\n    DSU(int n) : parent(n), rank(n, 1) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    bool unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return false;\n        if (rank[u] > rank[v]) swap(u, v);\n        parent[u] = v;\n        if (rank[u] == rank[v]) rank[v]++;\n        return true;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> sets(N-1);\n    for (int i = 0; i < N-1; ++i) {\n        int k;\n        cin >> k;\n        sets[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> sets[i][j];\n            sets[i][j]--; // converting to 0-based\n        }\n    }\n\n    vector<pair<int, int>> edges;\n    DSU dsu(N);\n\n    // We need to process sets in a way that maximizes the chance of forming a tree\n    // One approach is to process sets in order of increasing size\n    sort(sets.begin(), sets.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.size() < b.size();\n    });\n\n    bool possible = true;\n    for (auto& s : sets) {\n        bool found = false;\n        for (int u : s) {\n            for (int v : s) {\n                if (u != v && dsu.unite(u, v)) {\n                    edges.emplace_back(u+1, v+1); // converting back to 1-based\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n        if (!found) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (possible && edges.size() == N-1) {\n        cout << \"YES\" << endl;\n        for (auto& e : edges) {\n            cout << e.first << \" \" << e.second << endl;\n        }\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeFromSubsets {\n    static class DSU {\n        int[] parent;\n        int[] rank;\n\n        DSU(int n) {\n            parent = new int[n + 1];\n            rank = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n\n        boolean union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU == rootV) {\n                return false;\n            }\n            if (rank[rootU] > rank[rootV]) {\n                parent[rootV] = rootU;\n            } else if (rank[rootU] < rank[rootV]) {\n                parent[rootU] = rootV;\n            } else {\n                parent[rootV] = rootU;\n                rank[rootU]++;\n            }\n            return true;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        List<Set<Integer>> subsets = new ArrayList<>();\n        for (int i = 0; i < N - 1; i++) {\n            int size = sc.nextInt();\n            Set<Integer> set = new HashSet<>();\n            for (int j = 0; j < size; j++) {\n                set.add(sc.nextInt());\n            }\n            subsets.add(set);\n        }\n\n        DSU dsu = new DSU(N);\n        List<int[]> edges = new ArrayList<>();\n        boolean[] used = new boolean[N - 1];\n\n        for (int i = 0; i < N - 1; i++) {\n            Set<Integer> set = subsets.get(i);\n            boolean found = false;\n            for (int u : set) {\n                for (int v : set) {\n                    if (u != v && dsu.union(u, v)) {\n                        edges.add(new int[]{u, v});\n                        used[i] = true;\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n        }\n\n        if (edges.size() != N - 1) {\n            System.out.println(\"NO\");\n        } else {\n            System.out.println(\"YES\");\n            for (int[] edge : edges) {\n                System.out.println(edge[0] + \" \" + edge[1]);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:01:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeFormation {\n    public static void solve(List<Set<Integer>> sets) {\n        int N = sets.size() + 1;\n        List<int[]> edges = new ArrayList<>();\n        \n        // Try to form a tree\n        int[] parent = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n        }\n        \n        for (Set<Integer> set : sets) {\n            boolean found = false;\n            for (int u : set) {\n                for (int v : set) {\n                    if (u == v) continue;\n                    \n                    // Find roots of u and v\n                    int rootU = find(parent, u);\n                    int rootV = find(parent, v);\n                    \n                    // If not already connected, connect them\n                    if (rootU != rootV) {\n                        parent[rootU] = rootV;\n                        edges.add(new int[]{u, v});\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) break;\n            }\n            \n            // If no valid edge found, tree is impossible\n            if (!found) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        \n        // Check if single connected component\n        int root = find(parent, 1);\n        for (int i = 2; i <= N; i++) {\n            if (find(parent, i) != root) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        \n        // Output edges forming the tree\n        System.out.println(\"Yes\");\n        for (int[] edge : edges) {\n            System.out.println(edge[0] + \" \" + edge[1]);\n        }\n    }\n    \n    private static int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n}",
    "timestamp": "2025-08-05 23:01:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\npublic:\n    UnionFind(int n) {\n        parent.resize(n+1);\n        rank.resize(n+1, 0);\n        for (int i = 0; i <= n; i++) \n            parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) \n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    bool unionSet(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) \n            swap(px, py);\n        parent[py] = px;\n        if (rank[px] == rank[py]) \n            rank[px]++;\n        return true;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int N;\n    cin >> N;\n    \n    vector<vector<int>> sets(N-1);\n    \n    for (int i = 0; i < N-1; i++) {\n        int K;\n        cin >> K;\n        sets[i].resize(K);\n        for (int j = 0; j < K; j++) \n            cin >> sets[i][j];\n    }\n    \n    vector<pair<int,int>> edges;\n    \n    for (int i = 0; i < N-1; i++) {\n        for (int u = 0; u < sets[i].size(); u++) {\n            for (int v = u+1; v < sets[i].size(); v++) {\n                UnionFind uf(N);\n                bool possible = true;\n                \n                edges.clear();\n                edges.push_back({sets[i][u], sets[i][v]});\n                \n                for (int j = 0; j < N-1; j++) {\n                    if (j == i) continue;\n                    bool found = false;\n                    \n                    for (int x = 0; x < sets[j].size(); x++) {\n                        for (int y = x+1; y < sets[j].size(); y++) {\n                            if (uf.unionSet(sets[j][x], sets[j][y])) {\n                                edges.push_back({sets[j][x], sets[j][y]});\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (found) break;\n                    }\n                    \n                    if (!found) {\n                        possible = false;\n                        break;\n                    }\n                }\n                \n                if (possible) {\n                    set<int> vertices;\n                    for (auto& [x,y] : edges) {\n                        vertices.insert(x);\n                        vertices.insert(y);\n                    }\n                    \n                    if (vertices.size() == N) {\n                        cout << \"YES\\n\";\n                        for (auto& [x,y] : edges) \n                            cout << x << \" \" << y << \"\\n\";\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << \"NO\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_form_tree(N, subsets):\n    from collections import defaultdict\n\n    if N == 1:\n        return True, []\n\n    def find_root(parent):\n        if parent[root] != root:\n            parent[root] = find_root(parent[root])\n        return parent[root]\n\n    edges = []\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n    \n    degree = defaultdict(int)\n\n    for subset in subsets:\n        found = False\n        for u in subset:\n            for v in subset:\n                if u != v:\n                    root_u = find_root(u)\n                    root_v = find_root(v)\n\n                    if root_u != root_v:\n                        if rank[root_u] > rank[root_v]:\n                            parent[root_v] = root_u\n                        elif rank[root_u] < rank[root_v]:\n                            parent[root_u] = root_v\n                        else:\n                            parent[root_v] = root_u\n                            rank[root_u] += 1\n\n                        edges.append((u, v))\n                        degree[u] += 1\n                        degree[v] += 1\n                        found = True\n                        break\n            if found:\n                break\n    \n    if len(edges) != N - 1:\n        return False, []\n\n    if sum(degree.values()) // 2 != N - 1:\n        return False, []\n\n    return True, edges\n\n# Example Usage\nN = 5\nsubsets = [\n    {1, 2, 3},\n    {3, 4},\n    {4, 5},\n    {2, 5}\n]\ncan_form_tree(N, subsets)",
    "timestamp": "2025-08-13 13:17:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeFormation {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<Set<Integer>> subsets = new ArrayList<>();\n        \n        for (int i = 0; i < N - 1; i++) {\n            int size = scanner.nextInt();\n            Set<Integer> subset = new HashSet<>();\n            for (int j = 0; j < size; j++) {\n                subset.add(scanner.nextInt());\n            }\n            subsets.add(subset);\n        }\n        \n        scanner.close();\n        \n        if (canFormTree(subsets, N)) {\n            System.out.println(\"YES\");\n            List<Pair> edges = formTree(subsets, N);\n            for (Pair edge : edges) {\n                System.out.println(edge.u + \" \" + edge.v);\n            }\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n    \n    private static boolean canFormTree(List<Set<Integer>> subsets, int N) {\n        int[] degree = new int[N + 1];\n        \n        for (Set<Integer> subset : subsets) {\n            for (int vertex : subset) {\n                degree[vertex]++;\n            }\n        }\n        \n        int rootCount = 0;\n        for (int i = 1; i <= N; i++) {\n            if (degree[i] == 1) {\n                rootCount++;\n            }\n        }\n        \n        return rootCount == 2;\n    }\n    \n    private static List<Pair> formTree(List<Set<Integer>> subsets, int N) {\n        List<Pair> edges = new ArrayList<>();\n        Map<Integer, Integer> degreeMap = new HashMap<>();\n        \n        for (Set<Integer> subset : subsets) {\n            for (int vertex : subset) {\n                degreeMap.put(vertex, degreeMap.getOrDefault(vertex, 0) + 1);\n            }\n        }\n        \n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingInt(degreeMap::get));\n        pq.addAll(degreeMap.keySet());\n        \n        for (Set<Integer> subset : subsets) {\n            Integer u = null, v = null;\n            for (Integer vertex : subset) {\n                if (pq.contains(vertex)) {\n                    if (u == null) {\n                        u = vertex;\n                    } else {\n                        v = vertex;\n                        break;\n                    }\n                }\n            }\n            \n            if (u != null && v != null) {\n                edges.add(new Pair(u, v));\n                pq.remove(u);\n                pq.remove(v);\n                degreeMap.put(u, degreeMap.get(u) - 1);\n                degreeMap.put(v, degreeMap.get(v) - 1);\n                \n                if (degreeMap.get(u) > 0) {\n                    pq.add(u);\n                }\n                if (degreeMap.get(v) > 0) {\n                    pq.add(v);\n                }\n            }\n        }\n        \n        return edges;\n    }\n    \n    static class Pair {\n        int u, v;\n        \n        Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:18:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define MAXN 10000\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint parent[MAXN];\nbool used[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool union_sets(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        parent[rootX] = rootY;\n        return true;\n    }\n    return false;\n}\n\nEdge edges[MAXN];\n\nbool buildTree(int N, int num_edges, int sets[MAXN - 1][MAXN], int set_sizes[MAXN - 1], Edge result[MAXN - 1]) {\n    for (int i = 1; i <= N; ++i) {\n        parent[i] = i;\n        used[i] = false;\n    }\n\n    for (int i = 0; i < num_edges; ++i) {\n        bool found = false;\n        for (int j = 0; j < set_sizes[i]; ++j) {\n            for (int k = j + 1; k < set_sizes[i]; ++k) {\n                int u = sets[i][j], v = sets[i][k];\n                if (union_sets(u, v)) {\n                    result[i].u = u;\n                    result[i].v = v;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n        if (!found)\n            return false;\n    }\n\n    return true;\n}\n\nint main() {\n    int N, num_edges;\n    scanf(\"%d\", &N);\n    num_edges = N - 1;\n\n    int sets[MAXN - 1][MAXN];\n    int set_sizes[MAXN - 1];\n\n    for (int i = 0; i < num_edges; ++i) {\n        scanf(\"%d\", &set_sizes[i]);\n        for (int j = 0; j < set_sizes[i]; ++j) {\n            scanf(\"%d\", &sets[i][j]);\n        }\n    }\n\n    Edge result[MAXN - 1];\n    if (buildTree(N, num_edges, sets, set_sizes, result)) {\n        printf(\"Yes\\n\");\n        for (int i = 0; i < num_edges; ++i) {\n            printf(\"%d %d\\n\", result[i].u, result[i].v);\n        }\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:18:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool isTreePossible(int N, vector<unordered_set<int>> &subsets) {\n    if (subsets.size() != N - 1) return false;\n    \n    vector<int> degree(N + 1, 0);\n    vector<pair<int, int>> edges;\n    \n    for (auto &subset : subsets) {\n        if (subset.size() < 2) return false;\n        \n        auto it = subset.begin();\n        int u = *it;\n        ++it;\n        int v = *it;\n        \n        edges.emplace_back(u, v);\n        degree[u]++;\n        degree[v]++;\n    }\n    \n    int leafCount = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (degree[i] == 1) leafCount++;\n        else if (degree[i] == 0 || degree[i] > 2) return false;\n    }\n    \n    return leafCount == 2;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<unordered_set<int>> subsets(N - 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int size;\n        cin >> size;\n        for (int j = 0; j < size; ++j) {\n            int x;\n            cin >> x;\n            subsets[i].insert(x);\n        }\n    }\n    \n    if (isTreePossible(N, subsets)) {\n        cout << \"Possible\\n\";\n        for (auto s : subsets) {\n            auto it = s.begin();\n            int u = *it;\n            ++it;\n            int v = *it;\n            cout << u << \" \" << v << endl;\n        }\n    } else {\n        cout << \"Not possible\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:18:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_form_tree(N, sets):\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if visited[neighbor]:\n                return False\n            if not dfs(neighbor, node):\n                return False\n        return True\n\n    def find_tree_configuration():\n        for edge_choice in range(1 << (2 * (N-1))):\n            graph.clear()\n            for i in range(1, N+1):\n                graph[i] = []\n            \n            valid = True\n            for i in range(N-1):\n                set_i = sets[i]\n                u_candidates = []\n                v_candidates = []\n                \n                for x in set_i:\n                    for y in set_i:\n                        if x != y:\n                            u_candidates.append(x)\n                            v_candidates.append(y)\n                \n                if len(u_candidates) == 0:\n                    valid = False\n                    break\n                \n                choice = (edge_choice >> (2*i)) & 3\n                u = u_candidates[choice // 2]\n                v = v_candidates[choice % 2]\n                \n                if u == v:\n                    valid = False\n                    break\n                \n                graph[u].append(v)\n                graph[v].append(u)\n            \n            if not valid:\n                continue\n            \n            visited = [False] * (N+1)\n            start_node = 1\n            while start_node <= N and len(graph[start_node]) == 0:\n                start_node += 1\n            \n            if start_node > N:\n                continue\n            \n            if dfs(start_node, 0) and sum(visited[1:]) == N:\n                return [(u_candidates[choice // 2], v_candidates[choice % 2]) for i, choice in enumerate([(edge_choice >> (2*i)) & 3 for i in range(N-1)])]\n        \n        return None\n\n    graph = {i: [] for i in range(1, N+1)}\n    result = find_tree_configuration()\n    return result is not None, result\n\n# Example usage:\nN = 4\nsets = [\n    {1, 2, 3},\n    {2, 3, 4},\n    {1, 3, 4}\n]\n\npossible, configuration = can_form_tree(N, sets)\nprint(possible)\nif possible:\n    print(configuration)",
    "timestamp": "2025-08-13 13:18:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    E = []\n    for _ in range(N-1):\n        parts = list(map(int, sys.stdin.readline().split()))\n        k = parts[0]\n        elements = parts[1:]\n        E.append(elements)\n    \n    parent = [0]*(N+1)\n    visited = [False]*(N+1)\n    edges = []\n    possible = True\n    \n    # We'll use BFS to build the tree, selecting edges from the sets\n    q = deque()\n    root = 1\n    visited[root] = True\n    q.append(root)\n    \n    edge_ptr = 0\n    \n    while q and edge_ptr < N-1:\n        u = q.popleft()\n        found = False\n        # Look for an edge set that contains u and an unvisited node\n        for i in range(edge_ptr, N-1):\n            candidates = []\n            for v in E[i]:\n                if v == u:\n                    continue\n                if not visited[v]:\n                    candidates.append(v)\n            if candidates:\n                # Select the first candidate\n                v = candidates[0]\n                edges.append((u, v))\n                parent[v] = u\n                visited[v] = True\n                q.append(v)\n                # Swap the current edge set with edge_ptr to mark it as used\n                E[i], E[edge_ptr] = E[edge_ptr], E[i]\n                edge_ptr += 1\n                found = True\n                break\n        if not found:\n            # Check if any remaining edge sets can be used\n            for i in range(edge_ptr, N-1):\n                for v in E[i]:\n                    if visited[v]:\n                        candidates = []\n                        for w in E[i]:\n                            if w != v and not visited[w]:\n                                candidates.append(w)\n                        if candidates:\n                            w = candidates[0]\n                            edges.append((v, w))\n                            parent[w] = v\n                            visited[w] = True\n                            q.append(w)\n                            E[i], E[edge_ptr] = E[edge_ptr], E[i]\n                            edge_ptr += 1\n                            found = True\n                            break\n                if found:\n                    break\n            if not found:\n                possible = False\n                break\n    \n    if possible and edge_ptr == N-1:\n        # Verify that all nodes are visited (connected)\n        if sum(visited[1:N+1]) != N:\n            possible = False\n        else:\n            # Check for cycles (though BFS tree should be acyclic)\n            pass\n    \n    if possible:\n        print(\"YES\")\n        for u, v in edges:\n            print(u, v)\n    else:\n        print(\"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 13:18:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findTreeEdges(N, subsets) {\n    const degree = Array(N + 1).fill(0);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    \n    // Construct adjacency list and degree count from given subsets\n    subsets.forEach(E => {\n        E.forEach(node => degree[node]++);\n        if (E.length < 2) return;\n        adj[E[0]].push(E[1]);\n        adj[E[1]].push(E[0]);\n    });\n\n    const edges = [];\n    const visited = Array(N + 1).fill(false);\n    \n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of adj[node]) {\n            if (!visited[neighbor]) {\n                edges.push([node, neighbor]);\n                dfs(neighbor);\n            }\n        }\n    }\n    \n    // Find the starting node with minimum degree to make a spanning tree\n    let start = 1;\n    for (let i = 1; i <= N; i++) {\n        if (degree[i] > 0 && (start === 0 || degree[i] < degree[start])) {\n            start = i;\n        }\n    }\n    \n    // Initiate DFS from the start node\n    dfs(start);\n\n    // Check if we have N-1 edges and if all nodes are part of the tree\n    if (edges.length === N - 1 && edges.length === adj.filter(l => l.length).length - 1) {\n        return edges;\n    } else {\n        return \"It's not possible to construct such a tree.\";\n    }\n}\n\n// Example usage:\n// const N = 4;\n// const subsets = [[1, 2, 3], [2, 3, 4], [1, 3]];\n// const result = findTreeEdges(N, subsets);\n// console.log(result);\n// Output could vary but should be an array of edges that form a valid tree or a message indicating impossibility",
    "timestamp": "2025-08-13 13:18:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, sets) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const degree = new Array(N + 1).fill(0);\n\n    for (const set of sets) {\n        const edges = [];\n        for (let u of set) {\n            for (let v of set) {\n                if (u !== v) {\n                    edges.push([u, v]);\n                }\n            }\n        }\n\n        let found = false;\n        for (const [u, v] of edges) {\n            if (degree[u] < N - 1 && degree[v] < N - 1) {\n                graph[u].push(v);\n                graph[v].push(u);\n                degree[u]++;\n                degree[v]++;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) return null;\n    }\n\n    function dfs(node, parent) {\n        visited[node] = true;\n        for (const neighbor of graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, node);\n            } else if (neighbor !== parent) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    const visited = new Array(N + 1).fill(false);\n    dfs(1, -1);\n\n    return visited.slice(1).every(v => v) ? graph : null;\n}",
    "timestamp": "2025-08-13 13:19:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n    let ptr = 0;\n    const N = parseInt(input[ptr++], 10);\n    const E = [];\n    for (let i = 0; i < N - 1; i++) {\n        const parts = input[ptr++].trim().split(' ');\n        const k = parseInt(parts[0], 10);\n        const set = parts.slice(1).map(x => parseInt(x, 10));\n        E.push(set);\n    }\n\n    const parent = new Array(N + 1).fill(0);\n    const edges = [];\n\n    function find(u) {\n        if (parent[u] !== u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    function union(u, v) {\n        const rootU = find(u);\n        const rootV = find(v);\n        if (rootU !== rootV) {\n            parent[rootV] = rootU;\n            return true;\n        }\n        return false;\n    }\n\n    // Initialize DSU\n    for (let i = 1; i <= N; i++) {\n        parent[i] = i;\n    }\n\n    let possible = true;\n    const used = new Array(N - 1).fill(false);\n\n    for (let i = 0; i < N - 1; i++) {\n        let found = false;\n        for (let j = 0; j < E[i].length; j++) {\n            for (let k = j + 1; k < E[i].length; k++) {\n                const u = E[i][j];\n                const v = E[i][k];\n                if (find(u) !== find(v)) {\n                    union(u, v);\n                    edges.push([u, v]);\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n        if (!found) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (possible && edges.length === N - 1) {\n        console.log(\"YES\");\n        edges.forEach(edge => console.log(edge[0], edge[1]));\n    } else {\n        console.log(\"NO\");\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:19:18"
  }
]